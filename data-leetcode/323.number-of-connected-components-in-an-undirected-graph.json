[
    {
        "title": "Merge k Sorted Lists",
        "question_content": "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\nMerge all the linked-lists into one sorted linked-list and return it.\n&nbsp;\nExample 1:\n\nInput: lists = [[1,4,5],[1,3,4],[2,6]]\nOutput: [1,1,2,3,4,4,5,6]\nExplanation: The linked-lists are:\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\nmerging them into one sorted list:\n1->1->2->3->4->4->5->6\n\nExample 2:\n\nInput: lists = []\nOutput: []\n\nExample 3:\n\nInput: lists = [[]]\nOutput: []\n\n&nbsp;\nConstraints:\n\n\tk == lists.length\n\t0 <= k <= 104\n\t0 <= lists[i].length <= 500\n\t-104 <= lists[i][j] <= 104\n\tlists[i] is sorted in ascending order.\n\tThe sum of lists[i].length will not exceed 104.",
        "solutions": [
            {
                "id": 10528,
                "title": "a-java-solution-based-on-priority-queue",
                "content": "If someone understand how priority queue works, then it would be trivial to walk through the codes. \\n\\nMy question: is that possible to solve this question under the same time complexity without implementing the priority queue?\\n\\n\\n    public class Solution {\\n        public ListNode mergeKLists(List<ListNode> lists) {\\n            if (lists==null||lists.size()==0) return null;\\n            \\n            PriorityQueue<ListNode> queue= new PriorityQueue<ListNode>(lists.size(),new Comparator<ListNode>(){\\n                @Override\\n                public int compare(ListNode o1,ListNode o2){\\n                    if (o1.val<o2.val)\\n                        return -1;\\n                    else if (o1.val==o2.val)\\n                        return 0;\\n                    else \\n                        return 1;\\n                }\\n            });\\n            \\n            ListNode dummy = new ListNode(0);\\n            ListNode tail=dummy;\\n            \\n            for (ListNode node:lists)\\n                if (node!=null)\\n                    queue.add(node);\\n                \\n            while (!queue.isEmpty()){\\n                tail.next=queue.poll();\\n                tail=tail.next;\\n                \\n                if (tail.next!=null)\\n                    queue.add(tail.next);\\n            }\\n            return dummy.next;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public ListNode mergeKLists(List<ListNode> lists) {\\n            if (lists==null||lists.size()==0) return null;\\n            \\n            PriorityQueue<ListNode> queue= new PriorityQueue<ListNode>(lists.size(),new Comparator<ListNode>(){\\n                @Override\\n                public int compare(ListNode o1,ListNode o2){\\n                    if (o1.val<o2.val)\\n                        return -1;\\n                    else if (o1.val==o2.val)\\n                        return 0;\\n                    else \\n                        return 1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 10531,
                "title": "sharing-my-straightforward-c-solution-without-data-structure-other-than-vector",
                "content": "    ListNode *mergeKLists(vector<ListNode *> &lists) {\\n        if(lists.empty()){\\n            return nullptr;\\n        }\\n        while(lists.size() > 1){\\n            lists.push_back(mergeTwoLists(lists[0], lists[1]));\\n            lists.erase(lists.begin());\\n            lists.erase(lists.begin());\\n        }\\n        return lists.front();\\n    }\\n    ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) {\\n        if(l1 == nullptr){\\n            return l2;\\n        }\\n        if(l2 == nullptr){\\n            return l1;\\n        }\\n        if(l1->val <= l2->val){\\n            l1->next = mergeTwoLists(l1->next, l2);\\n            return l1;\\n        }\\n        else{\\n            l2->next = mergeTwoLists(l1, l2->next);\\n            return l2;\\n        }\\n    }\\n\\nThe second function is from Merge Two Sorted Lists. \\n\\nThe basic idea is really simple. We can merge first two lists and then push it back. Keep doing this until there is only one list left in vector. Actually, we can regard this as an iterative divide-and-conquer solution.",
                "solutionTags": [
                    "C++",
                    "Divide and Conquer",
                    "Merge Sort"
                ],
                "code": "    ListNode *mergeKLists(vector<ListNode *> &lists) {\\n        if(lists.empty()){\\n            return nullptr;\\n        }\\n        while(lists.size() > 1){\\n            lists.push_back(mergeTwoLists(lists[0], lists[1]));\\n            lists.erase(lists.begin());\\n            lists.erase(lists.begin());\\n        }\\n        return lists.front();\\n    }\\n    ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) {\\n        if(l1 == nullptr){\\n            return l2;\\n        }\\n        if(l2 == nullptr){\\n            return l1;\\n        }\\n        if(l1->val <= l2->val){\\n            l1->next = mergeTwoLists(l1->next, l2);\\n            return l1;\\n        }\\n        else{\\n            l2->next = mergeTwoLists(l1, l2->next);\\n            return l2;\\n        }\\n    }\\n\\nThe second function is from Merge Two Sorted Lists. \\n\\nThe basic idea is really simple. We can merge first two lists and then push it back. Keep doing this until there is only one list left in vector. Actually, we can regard this as an iterative divide-and-conquer solution.",
                "codeTag": "Unknown"
            },
            {
                "id": 10522,
                "title": "my-simple-java-solution-use-recursion",
                "content": "    public static ListNode mergeKLists(ListNode[] lists){\\n        return partion(lists,0,lists.length-1);\\n    }\\n\\n    public static ListNode partion(ListNode[] lists,int s,int e){\\n        if(s==e)  return lists[s];\\n        if(s<e){\\n            int q=(s+e)/2;\\n            ListNode l1=partion(lists,s,q);\\n            ListNode l2=partion(lists,q+1,e);\\n            return merge(l1,l2);\\n        }else\\n            return null;\\n    }\\n\\n    //This function is from Merge Two Sorted Lists.\\n    public static ListNode merge(ListNode l1,ListNode l2){\\n        if(l1==null) return l2;\\n        if(l2==null) return l1;\\n        if(l1.val<l2.val){\\n            l1.next=merge(l1.next,l2);\\n            return l1;\\n        }else{\\n            l2.next=merge(l1,l2.next);\\n            return l2;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public static ListNode mergeKLists(ListNode[] lists){\\n        return partion(lists,0,lists.length-1);\\n    }\\n\\n    public static ListNode partion(ListNode[] lists,int s,int e){\\n        if(s==e)  return lists[s];\\n        if(s<e){\\n            int q=(s+e)/2;\\n            ListNode l1=partion(lists,s,q);\\n            ListNode l2=partion(lists,q+1,e);\\n            return merge(l1,l2);\\n        }else\\n            return null;\\n    }\\n\\n    //This function is from Merge Two Sorted Lists.\\n    public static ListNode merge(ListNode l1,ListNode l2){\\n        if(l1==null) return l2;\\n        if(l2==null) return l1;\\n        if(l1.val<l2.val){\\n            l1.next=merge(l1.next,l2);\\n            return l1;\\n        }else{\\n            l2.next=merge(l1,l2.next);\\n            return l2;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 10919,
                "title": "python-easy-to-understand-divide-and-conquer-solution",
                "content": "```\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        if not lists:\\n            return None\\n        if len(lists) == 1:\\n            return lists[0]\\n        mid = len(lists) // 2\\n        l, r = self.mergeKLists(lists[:mid]), self.mergeKLists(lists[mid:])\\n        return self.merge(l, r)\\n    \\n    def merge(self, l, r):\\n        dummy = p = ListNode()\\n        while l and r:\\n            if l.val < r.val:\\n                p.next = l\\n                l = l.next\\n            else:\\n                p.next = r\\n                r = r.next\\n            p = p.next\\n        p.next = l or r\\n        return dummy.next\\n    \\n    def merge1(self, l, r):\\n        if not l or not r:\\n            return l or r\\n        if l.val< r.val:\\n            l.next = self.merge(l.next, r)\\n            return l\\n        r.next = self.merge(l, r.next)\\n        return r\\n```",
                "solutionTags": [
                    "Python",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        if not lists:\\n            return None\\n        if len(lists) == 1:\\n            return lists[0]\\n        mid = len(lists) // 2\\n        l, r = self.mergeKLists(lists[:mid]), self.mergeKLists(lists[mid:])\\n        return self.merge(l, r)\\n    \\n    def merge(self, l, r):\\n        dummy = p = ListNode()\\n        while l and r:\\n            if l.val < r.val:\\n                p.next = l\\n                l = l.next\\n            else:\\n                p.next = r\\n                r = r.next\\n            p = p.next\\n        p.next = l or r\\n        return dummy.next\\n    \\n    def merge1(self, l, r):\\n        if not l or not r:\\n            return l or r\\n        if l.val< r.val:\\n            l.next = self.merge(l.next, r)\\n            return l\\n        r.next = self.merge(l, r.next)\\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 10527,
                "title": "difference-between-priority-queue-and-heap-and-c-implementation",
                "content": "I have seen lots of solutions confuse `priority queue` with `heap`. I find a good [link][1] and list the talk below.\\n\\n**Concept:**\\n\\n1.`Heap` is a kind of `data structure`. It is a name for a particular way of storing data that makes certain operations very efficient. We can use a tree or array to describe it.\\n\\n       18\\n      /\\t\\\\\\n     10\\t 16\\n    / \\\\   / \\\\\\n    9  5  8  12\\n    \\n    18, 10, 16, 9, 5, 8, 12\\n\\n2.`Priority queue` is an `abstract datatype`. It is a shorthand way of describing a particular interface and behavior, and says nothing about the underlying implementation.\\n\\nA heap is a very good data structure to implement a priority queue. The operations which are made efficient by the heap data structure are the operations that the priority queue interface needs.\\n\\n\\n**Implementation: c++** \\n\\n1.`priority_queue`: we can only get the top element (from ChiangKaiShrek's [solution][2])\\n\\n    struct compare {\\n        bool operator()(const ListNode* l, const ListNode* r) {\\n            return l->val > r->val;\\n        }\\n    };\\n    ListNode *mergeKLists(vector<ListNode *> &lists) { //priority_queue\\n        priority_queue<ListNode *, vector<ListNode *>, compare> q;\\n        for(auto l : lists) {\\n            if(l)  q.push(l);\\n        }\\n        if(q.empty())  return NULL;\\n\\n        ListNode* result = q.top();\\n        q.pop();\\n        if(result->next) q.push(result->next);\\n        ListNode* tail = result;            \\n        while(!q.empty()) {\\n            tail->next = q.top();\\n            q.pop();\\n            tail = tail->next;\\n            if(tail->next) q.push(tail->next);\\n        }\\n        return result;\\n    }\\n\\n2.`make_heap`: we can access all the elements (from my answer for that solution)\\n\\n    static bool heapComp(ListNode* a, ListNode* b) {\\n            return a->val > b->val;\\n    }\\n    ListNode* mergeKLists(vector<ListNode*>& lists) { //make_heap\\n        ListNode head(0);\\n        ListNode *curNode = &head;\\n        vector<ListNode*> v;   \\n        for(int i =0; i<lists.size(); i++){\\n            if(lists[i]) v.push_back(lists[i]);\\n        }\\n        make_heap(v.begin(), v.end(), heapComp); //vector -> heap data strcture\\n    \\n        while(v.size()>0){\\n            curNode->next=v.front();\\n            pop_heap(v.begin(), v.end(), heapComp); \\n            v.pop_back(); \\n            curNode = curNode->next;\\n            if(curNode->next) {\\n                v.push_back(curNode->next); \\n                push_heap(v.begin(), v.end(), heapComp);\\n            }\\n        }\\n        return head.next;\\n    }\\n\\nIf there is something wrong, please figure it out. Hoping to learn more about them.\\n\\n\\n  [1]: http://stackoverflow.com/questions/18993269/difference-between-priority-queue-and-a-heap\\n  [2]: https://leetcode.com/discuss/21363/brief-c-solution-with-priority_queue",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "I have seen lots of solutions confuse `priority queue` with `heap`. I find a good [link][1] and list the talk below.\\n\\n**Concept:**\\n\\n1.`Heap` is a kind of `data structure`. It is a name for a particular way of storing data that makes certain operations very efficient. We can use a tree or array to describe it.\\n\\n       18\\n      /\\t\\\\\\n     10\\t 16\\n    / \\\\   / \\\\\\n    9  5  8  12\\n    \\n    18, 10, 16, 9, 5, 8, 12\\n\\n2.`Priority queue` is an `abstract datatype`. It is a shorthand way of describing a particular interface and behavior, and says nothing about the underlying implementation.\\n\\nA heap is a very good data structure to implement a priority queue. The operations which are made efficient by the heap data structure are the operations that the priority queue interface needs.\\n\\n\\n**Implementation: c++** \\n\\n1.`priority_queue`: we can only get the top element (from ChiangKaiShrek's [solution][2])\\n\\n    struct compare {\\n        bool operator()(const ListNode* l, const ListNode* r) {\\n            return l->val > r->val;\\n        }\\n    };\\n    ListNode *mergeKLists(vector<ListNode *> &lists) { //priority_queue\\n        priority_queue<ListNode *, vector<ListNode *>, compare> q;\\n        for(auto l : lists) {\\n            if(l)  q.push(l);\\n        }\\n        if(q.empty())  return NULL;\\n\\n        ListNode* result = q.top();\\n        q.pop();\\n        if(result->next) q.push(result->next);\\n        ListNode* tail = result;            \\n        while(!q.empty()) {\\n            tail->next = q.top();\\n            q.pop();\\n            tail = tail->next;\\n            if(tail->next) q.push(tail->next);\\n        }\\n        return result;\\n    }\\n\\n2.`make_heap`: we can access all the elements (from my answer for that solution)\\n\\n    static bool heapComp(ListNode* a, ListNode* b) {\\n            return a->val > b->val;\\n    }\\n    ListNode* mergeKLists(vector<ListNode*>& lists) { //make_heap\\n        ListNode head(0);\\n        ListNode *curNode = &head;\\n        vector<ListNode*> v;   \\n        for(int i =0; i<lists.size(); i++){\\n            if(lists[i]) v.push_back(lists[i]);\\n        }\\n        make_heap(v.begin(), v.end(), heapComp); //vector -> heap data strcture\\n    \\n        while(v.size()>0){\\n            curNode->next=v.front();\\n            pop_heap(v.begin(), v.end(), heapComp); \\n            v.pop_back(); \\n            curNode = curNode->next;\\n            if(curNode->next) {\\n                v.push_back(curNode->next); \\n                push_heap(v.begin(), v.end(), heapComp);\\n            }\\n        }\\n        return head.next;\\n    }\\n\\nIf there is something wrong, please figure it out. Hoping to learn more about them.\\n\\n\\n  [1]: http://stackoverflow.com/questions/18993269/difference-between-priority-queue-and-a-heap\\n  [2]: https://leetcode.com/discuss/21363/brief-c-solution-with-priority_queue",
                "codeTag": "Unknown"
            },
            {
                "id": 10511,
                "title": "10-line-python-solution-with-priority-queue",
                "content": "    from Queue import PriorityQueue\\n    class Solution(object):\\n        def mergeKLists(self, lists):\\n            dummy = ListNode(None)\\n            curr = dummy\\n            q = PriorityQueue()\\n            for node in lists:\\n                if node: q.put((node.val,node))\\n            while q.qsize()>0:\\n                curr.next = q.get()[1]\\n                curr=curr.next\\n                if curr.next: q.put((curr.next.val, curr.next))\\n            return dummy.next",
                "solutionTags": [],
                "code": "    from Queue import PriorityQueue\\n    class Solution(object):\\n        def mergeKLists(self, lists):\\n            dummy = ListNode(None)\\n            curr = dummy\\n            q = PriorityQueue()\\n            for node in lists:\\n                if node: q.put((node.val,node))\\n            while q.qsize()>0:\\n                curr.next = q.get()[1]\\n                curr=curr.next\\n                if curr.next: q.put((curr.next.val, curr.next))\\n            return dummy.next",
                "codeTag": "Java"
            },
            {
                "id": 429518,
                "title": "java-summary-of-all-solutions-b-f-minpq-divide-and-conquer",
                "content": "Reference: [LeetCode](https://leetcode.com/problems/merge-k-sorted-lists/) <span class=\"gray\">EPI 10.1</span>\\nDifficulty: <span class=\"red\">Hard</span>\\n\\n\\n## Problem\\n\\n> Merge `k` sorted linked lists and return it as one sorted list. Analyze and describe its complexity.\\n\\n**Example:** \\n\\n```java\\nInput:\\n[\\n  1->4->5,\\n  1->3->4,\\n  2->6\\n]\\nOutput: 1->1->2->3->4->4->5->6\\n```\\n\\n\\n## Analysis\\n\\n**Focus on the third and fifth solution.**\\n\\n**Test Case:**\\n\\n```java\\n// 1\\n[[1,4,5],[1,3,4],[2,6]]\\n[1,2,4,4,5]\\n// 2\\n[[], [], []]\\n[]\\n// 3\\n[[1,2],[],[5]]\\n[1,2,5]\\n// 4\\n[[1,4,5],[2,4]]\\n[1,2,4,4,5]\\n// 5\\n[[1]]\\n[1]\\n// 6 ---- Be careful of this one\\n[]\\n```\\n\\n### Brute-Force\\n\\nIt is okay if `N` is not too large.\\n\\n- Traverse all the linked lists and collect the values of the nodes into an `array`. - `O(N)`\\n- Sort the array. - `O(N\\\\log{N})`\\n- Traverse the array and make the linked list. - `O(N)`\\n\\n**Time:** `O(N\\\\log{N})` where `N` is the total number of nodes.\\n**Space:** `O(N)` since we need an array and a new linked list.\\n\\n\\n\\n\\n### Compare One-By-One\\n\\n(if `k` is much less than `N`, `k` is the number of lists)\\n\\nCompare every `k` nodes (head of every list) and get the smallest node.\\n\\n**Note:**\\n\\n- Use `minIdx` to record the location and to check if the list is empty.\\n\\n```java\\npublic ListNode mergeKLists(ListNode[] lists) {\\n  if (lists == null || lists.length == 0) {\\n    return null;\\n  }\\n  ListNode dummy = new ListNode(-1);\\n  ListNode prev = dummy;\\n\\n  while (true) {\\n    ListNode minNode = null;\\n    int minIdx = -1;\\n    \\n    // Iterate over lists\\n    for (int i = 0; i < lists.length; ++i) {\\n      ListNode currList = lists[i];\\n      if (currList == null) continue;\\n      if (minNode == null || currList.val < minNode.val) {\\n        minNode = currList;\\n        minIdx = i;\\n      }\\n    }\\n    // check if finished\\n    if (minNode == null) break;\\n\\n    // link\\n    prev.next = minNode;\\n    prev = prev.next;\\n\\n    // delete\\n    lists[minIdx] = minNode.next; // may be null\\n  }\\n  return dummy.next;\\n}\\n```\\n\\n\\n**Time:** `O(kN)` where `k` is the number of linked lists. `311 ms`\\n**Space:** `O(N)` creating a new linked list. Or `O(1)` if we apply an in-place method. Connect selected nodes instead of creating new nodes.\\n\\n\\n\\n### Compare One-By-One (minPQ)\\n\\nUse a minimum `priority queue` to store `k` nodes. Pop the smallest node and offer its next node if it is not `null`.\\n\\n```java\\n// Compare One-By-One (PQ)\\npublic ListNode mergeKLists(ListNode[] lists) {\\n  if (lists == null || lists.length == 0) {\\n    return null;\\n  }\\n  ListNode dummy = new ListNode(-1);\\n  ListNode prev = dummy;\\n\\n  PriorityQueue<ListNode> minPQ = new PriorityQueue<>((o1, o2) -> {\\n    return o1.val - o2.val;\\n  });\\n\\n  // Init PQ\\n  for (int i = 0; i < lists.length; ++i) {\\n    if (lists[i] != null) {\\n      minPQ.offer(lists[i]);\\n    }\\n  }\\n\\n  // Play with PQ\\n  while (minPQ.size() > 0) {\\n    ListNode curr = pq.poll();\\n    prev.next = curr;\\n    prev = prev.next; // update\\n\\n    // you don\\'t need to set curr.next as null since the last node is always be one of the last node of each list. Its next must be null.\\n    if (curr.next != null) {\\n      minPQ.offer(curr.next);\\n    }\\n  }\\n  \\n  return dummy.next;\\n}\\n```\\n\\n**Time:** `O(N\\\\log{k})` `34 ms`\\n- Initializing the priority queue takes `O(k\\\\log{k})`\\n- Pop `N` nodes from the priority queue takes `O(N\\\\log{k})`\\n\\n**Space:** `O(k)` since priority queue stores `k` nodes. `O(1)` or `O(N)` depends on the input `N` and `k` and whether we create a new linked list.\\n\\n\\n\\n### Merge Lists One-By-One\\n\\nWe need to merge `k` lists by merging `(k-1)` times.\\n\\n**Note:**\\n\\n- `mergeList(dummy.next, n)` is thoughtful. At the beginning, `dummy.next` is null, but it does not matter.\\n- Alternatively, we can use the first place of the array to store merged list.\\n\\n```java\\npublic ListNode mergeKLists(ListNode[] lists) {\\n  if (lists == null || lists.length == 0) {\\n    return null;\\n  }\\n  // Use the 0-th list as a return list\\n  for (int i = 1; i < lists.length; ++i) {\\n    lists[0] = mergeList(lists[0], lists[i]);\\n  }\\n\\n  return lists[0];\\n}\\n\\nprivate ListNode mergeList(ListNode n1, ListNode n2) {\\n  ListNode dummy = new ListNode(-1);\\n  ListNode prev = dummy;\\n  while (n1 != null && n2 != null) {\\n    if (n1.val < n2.val) {\\n      prev.next = n1;\\n      n1 = n1.next;\\n    } else {\\n      prev.next = n2;\\n      n2 = n2.next;\\n    }\\n    prev = prev.next;\\n  }\\n  prev.next = (n1 != null) ? n1 : n2;\\n\\n  return dummy.next;\\n}\\n```\\n\\n\\n**Time:** `O(kN)` `250 ms`\\n- Merge two sorted lists in `O(n)` time where `n` is the total number of nodes in two lists. (worst case)\\n- To sum up we have: `O(\\\\sum_{i=1}^{k-1}(i * \\\\frac{N}{k} + \\\\frac{N}{k}) = O(kN)`. (key: `n = \\\\frac{N}{k}`) `skip it...`\\n\\n**Space:** `O(1)` since we merge in place.\\n\\n\\n\\n\\n### Merge Lists with Divide And Conquer\\n\\nIn effect, we don\\'t need to traverse most nodes many times repeatedly. We can divide lists in half until there is only one list. Merge them one by one to get the final result. It\\'s similar to mergesort.\\n\\n\\n**Note:**\\n\\n- Recall of the `left-leaning` and `right-leaning` cases.\\n- The base case is thoughtful. `lo > hi` actually won\\'t occur. And `lists[lo]` won\\'t change other elements on the other side.\\n- `lists.length == 0` condition is very important.\\n  - Input case: `[]`.\\n\\n```java\\n// mergeDivideAndConquer - O(kN)\\npublic ListNode mergeDivideAndConquer(ListNode[] lists) {\\n  if (lists == null || lists.length == 0) {\\n    return null;\\n  }\\n  return divideAndConquer(lists, 0, lists.length - 1);\\n}\\n\\nprivate ListNode divideAndConquer(ListNode[] lists, int lo, int hi) {\\n  if (lo > hi) { // invalid\\n    return null;\\n  }\\n  if (lo == hi) { // size = 1\\n    return lists[lo];\\n  }\\n  int mid = lo + (hi - lo) / 2; // left-leaning\\n  ListNode left = divideAndConquer(lists, lo, mid);\\n  ListNode right = divideAndConquer(lists, mid + 1, hi);\\n  return mergeList(left, right);\\n}\\n\\nprivate ListNode mergeList(ListNode n1, ListNode n2) { ... }\\n```\\n\\n\\n**Time:** `O(N\\\\log{k})` `2 ms`\\n**Space:** `O(\\\\log{k})` if we use recursion (depth of the recursion tree).\\n    \\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/qpogs.jpg \"Merge with Divide And Conquer\")\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer",
                    "Heap (Priority Queue)",
                    "Merge Sort"
                ],
                "code": "```java\\nInput:\\n[\\n  1->4->5,\\n  1->3->4,\\n  2->6\\n]\\nOutput: 1->1->2->3->4->4->5->6\\n```\n```java\\n// 1\\n[[1,4,5],[1,3,4],[2,6]]\\n[1,2,4,4,5]\\n// 2\\n[[], [], []]\\n[]\\n// 3\\n[[1,2],[],[5]]\\n[1,2,5]\\n// 4\\n[[1,4,5],[2,4]]\\n[1,2,4,4,5]\\n// 5\\n[[1]]\\n[1]\\n// 6 ---- Be careful of this one\\n[]\\n```\n```java\\npublic ListNode mergeKLists(ListNode[] lists) {\\n  if (lists == null || lists.length == 0) {\\n    return null;\\n  }\\n  ListNode dummy = new ListNode(-1);\\n  ListNode prev = dummy;\\n\\n  while (true) {\\n    ListNode minNode = null;\\n    int minIdx = -1;\\n    \\n    // Iterate over lists\\n    for (int i = 0; i < lists.length; ++i) {\\n      ListNode currList = lists[i];\\n      if (currList == null) continue;\\n      if (minNode == null || currList.val < minNode.val) {\\n        minNode = currList;\\n        minIdx = i;\\n      }\\n    }\\n    // check if finished\\n    if (minNode == null) break;\\n\\n    // link\\n    prev.next = minNode;\\n    prev = prev.next;\\n\\n    // delete\\n    lists[minIdx] = minNode.next; // may be null\\n  }\\n  return dummy.next;\\n}\\n```\n```java\\n// Compare One-By-One (PQ)\\npublic ListNode mergeKLists(ListNode[] lists) {\\n  if (lists == null || lists.length == 0) {\\n    return null;\\n  }\\n  ListNode dummy = new ListNode(-1);\\n  ListNode prev = dummy;\\n\\n  PriorityQueue<ListNode> minPQ = new PriorityQueue<>((o1, o2) -> {\\n    return o1.val - o2.val;\\n  });\\n\\n  // Init PQ\\n  for (int i = 0; i < lists.length; ++i) {\\n    if (lists[i] != null) {\\n      minPQ.offer(lists[i]);\\n    }\\n  }\\n\\n  // Play with PQ\\n  while (minPQ.size() > 0) {\\n    ListNode curr = pq.poll();\\n    prev.next = curr;\\n    prev = prev.next; // update\\n\\n    // you don\\'t need to set curr.next as null since the last node is always be one of the last node of each list. Its next must be null.\\n    if (curr.next != null) {\\n      minPQ.offer(curr.next);\\n    }\\n  }\\n  \\n  return dummy.next;\\n}\\n```\n```java\\npublic ListNode mergeKLists(ListNode[] lists) {\\n  if (lists == null || lists.length == 0) {\\n    return null;\\n  }\\n  // Use the 0-th list as a return list\\n  for (int i = 1; i < lists.length; ++i) {\\n    lists[0] = mergeList(lists[0], lists[i]);\\n  }\\n\\n  return lists[0];\\n}\\n\\nprivate ListNode mergeList(ListNode n1, ListNode n2) {\\n  ListNode dummy = new ListNode(-1);\\n  ListNode prev = dummy;\\n  while (n1 != null && n2 != null) {\\n    if (n1.val < n2.val) {\\n      prev.next = n1;\\n      n1 = n1.next;\\n    } else {\\n      prev.next = n2;\\n      n2 = n2.next;\\n    }\\n    prev = prev.next;\\n  }\\n  prev.next = (n1 != null) ? n1 : n2;\\n\\n  return dummy.next;\\n}\\n```\n```java\\n// mergeDivideAndConquer - O(kN)\\npublic ListNode mergeDivideAndConquer(ListNode[] lists) {\\n  if (lists == null || lists.length == 0) {\\n    return null;\\n  }\\n  return divideAndConquer(lists, 0, lists.length - 1);\\n}\\n\\nprivate ListNode divideAndConquer(ListNode[] lists, int lo, int hi) {\\n  if (lo > hi) { // invalid\\n    return null;\\n  }\\n  if (lo == hi) { // size = 1\\n    return lists[lo];\\n  }\\n  int mid = lo + (hi - lo) / 2; // left-leaning\\n  ListNode left = divideAndConquer(lists, lo, mid);\\n  ListNode right = divideAndConquer(lists, mid + 1, hi);\\n  return mergeList(left, right);\\n}\\n\\nprivate ListNode mergeList(ListNode n1, ListNode n2) { ... }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 465094,
                "title": "problems-with-python3-and-multiple-solutions",
                "content": "**Python 2 Solution:**\\n```\\ndef mergeKLists_Python2(self, lists):\\n\\th = []\\n\\thead = tail = ListNode(0)\\n\\tfor i in lists:\\n\\t\\tif i:\\n\\t\\t\\theapq.heappush(h, (i.val, i))\\n\\n\\twhile h:\\n\\t\\tnode = heapq.heappop(h)[1]\\n\\t\\ttail.next = node\\n\\t\\ttail = tail.next\\n\\t\\tif node.next:\\n\\t\\t\\theapq.heappush(h, (node.next.val, node.next))\\n\\n\\treturn head.next\\n```\\n\\n**Python 3:** \\nThe above solution works fine with Python 2.However, with Python3 it gives Type Error:\\nTypeError: \\'<\\' not supported between instances of \\'ListNode\\' and \\'ListNode\\'\\n**This error occurs because the cmp() special method is no longer honored in Python 3**\\n\\nHere are the two ways we can solve this problem:\\n**a) Implement eq, lt methods** \\n\\t\\nOne of the solution would be to provide `__eq__ and __lt__` method implementation to `ListNode` class\\n```\\ndef mergeKLists_Python3(self, lists):\\n\\tListNode.__eq__ = lambda self, other: self.val == other.val\\n\\tListNode.__lt__ = lambda self, other: self.val < other.val\\n\\th = []\\n\\thead = tail = ListNode(0)\\n\\tfor i in lists:\\n\\t\\tif i:\\n\\t\\t\\theapq.heappush(h, (i.val, i))\\n\\n\\twhile h:\\n\\t\\tnode = heapq.heappop(h)[1]\\n\\t\\ttail.next = node\\n\\t\\ttail = tail.next\\n\\t\\tif node.next:\\n\\t\\t\\theapq.heappush(h, (node.next.val, node.next))\\n\\n\\treturn head.next\\n```\\n\\n**b) Fix heapq** \\n\\nThe problem while adding `ListNode` objects as tasks is that the Tuple comparison breaks for (priority, task) pairs if the priorities are equal and the tasks do not have a default comparison order. The solution is to store entries as 3-element list including the priority, an entry count, and the task.\\nThe entry count serves as a tie-breaker so that two tasks with the same priority are returned in the order they were added.\\nAnd since no two entry counts are the same, the tuple comparison will never attempt to directly compare two tasks.\\n\\n```\\ndef mergeKLists_heapq(self, lists):\\n\\th = []\\n\\thead = tail = ListNode(0)\\n\\tfor i in range(len(lists)):\\n\\t\\theapq.heappush(h, (lists[i].val, i, lists[i]))\\n\\n\\twhile h:\\n\\t\\tnode = heapq.heappop(h)\\n\\t\\tnode = node[2]\\n\\t\\ttail.next = node\\n\\t\\ttail = tail.next\\n\\t\\tif node.next:\\n\\t\\t\\ti+=1\\n\\t\\t\\theapq.heappush(h, (node.next.val, i, node.next))\\n\\n\\treturn head.next\\n```\\n\\t",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef mergeKLists_Python2(self, lists):\\n\\th = []\\n\\thead = tail = ListNode(0)\\n\\tfor i in lists:\\n\\t\\tif i:\\n\\t\\t\\theapq.heappush(h, (i.val, i))\\n\\n\\twhile h:\\n\\t\\tnode = heapq.heappop(h)[1]\\n\\t\\ttail.next = node\\n\\t\\ttail = tail.next\\n\\t\\tif node.next:\\n\\t\\t\\theapq.heappush(h, (node.next.val, node.next))\\n\\n\\treturn head.next\\n```\n```\\ndef mergeKLists_Python3(self, lists):\\n\\tListNode.__eq__ = lambda self, other: self.val == other.val\\n\\tListNode.__lt__ = lambda self, other: self.val < other.val\\n\\th = []\\n\\thead = tail = ListNode(0)\\n\\tfor i in lists:\\n\\t\\tif i:\\n\\t\\t\\theapq.heappush(h, (i.val, i))\\n\\n\\twhile h:\\n\\t\\tnode = heapq.heappop(h)[1]\\n\\t\\ttail.next = node\\n\\t\\ttail = tail.next\\n\\t\\tif node.next:\\n\\t\\t\\theapq.heappush(h, (node.next.val, node.next))\\n\\n\\treturn head.next\\n```\n```\\ndef mergeKLists_heapq(self, lists):\\n\\th = []\\n\\thead = tail = ListNode(0)\\n\\tfor i in range(len(lists)):\\n\\t\\theapq.heappush(h, (lists[i].val, i, lists[i]))\\n\\n\\twhile h:\\n\\t\\tnode = heapq.heappop(h)\\n\\t\\tnode = node[2]\\n\\t\\ttail.next = node\\n\\t\\ttail = tail.next\\n\\t\\tif node.next:\\n\\t\\t\\ti+=1\\n\\t\\t\\theapq.heappush(h, (node.next.val, i, node.next))\\n\\n\\treturn head.next\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1746240,
                "title": "c-solution-w-explanation-step-by-step-optimisation-three-different-approaches",
                "content": "***Brief note about Question-***\\n\\nWe have to ***Merge all the linked-lists into one sorted linked-list and return it.***\\n```\\nTake an example -\\nGiven: k number of sorted linked list in ascending order.\\nAim: Merge them into a single sorted linked list.\\n\\nTake anthor example which is not given in question-\\nL1: 1 -> 5 -> 7 -> 9 -> N\\nL2: 2 -> 4 -> 8 -> N\\nL3: 3 -> 6 -> N\\n\\nSo our answer should like this:\\n1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> N\\n```\\n________________________\\n***Solution - I (Most basic approach, Accepted)-***\\n* Okay, so the most basic approach we can think of is, we are obedient person, and not to do anything extra from ourself,\\n* We will simply do what the question wants us to do, we create an array which store all the elements of all \\'k\\' linked list present in the array.\\n* After storing all elements, we sort them a/c to their vaules.\\n*  Now, the only task which is left is to link them, so we start linking them.\\n\\n**Okay, I got the approach, but how i will implement this or code these words-**\\n\\n1. We take help of a `vector pair` which of value and Node type.\\n1. But why vector pair?\\n1. See,  *Here we have k different linked list na and each linked list contain some elements so to observe that we need a vector pair.*\\n1. Okay good, I take a vector pair,so now what i have to do?\\n1. Now we start storing each value in this vector pair.\\n1. After this, by using `sort function` (present in STL) we sort this vectorAnd at last, i start linking them, it can be done simply by putting next pointer i.e `arr[i].second -> next = arr[i + 1].second`.\\n\\n```\\nSuppose if total number of nodes present in all linked list is \\'n\\' \\nTime Complexity --> O(n log n) // as sorting takes (n log n) time\\nSpace Complexity --> O(n) // to store nodes of the all linked list\\nIt paases [ 133 / 133] in built test cases\\n```\\n**Code (C++)**\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        int k = lists.size(); // taking size of the list\\n        if(k == 0) // if size is zero\\n            return NULL; // simply return NULL\\n        \\n        // making a vector pair where first contain value and second contain node\\n        vector<pair<int, ListNode*>> arr; \\n        \\n        for(int i = 0; i < k; i++) // traverse all over the list\\n        {\\n            ListNode* curr_list = lists[i]; // extracting current linked list\\n            \\n            while(curr_list != NULL) // while current linked list is NOT NULL\\n            {\\n                arr.push_back({curr_list -> val, curr_list}); // push into vector\\n                curr_list = curr_list -> next;\\n            }\\n        }\\n        \\n        // this does not gurantee that k is zero, \\n        // suppose an array like this [[],[],[],],here k = 3 and size of array is 0\\n        if(arr.size() == 0) // if their is no element i.e zero element\\n            return NULL;\\n        \\n        sort(arr.begin(), arr.end()); // sort the vector on the basis of values\\n        \\n        // start making links b/w the elements of vector\\n        for(int i = 0; i < arr.size() - 1; i++)\\n        {\\n            arr[i].second -> next = arr[i + 1].second;\\n        }\\n        \\n        // in the next of last node put NULL\\n        arr[arr.size() - 1].second -> next = NULL;\\n        \\n        return arr[0].second; // return first node of the vector\\n    }\\n};\\n```\\n___________________________\\n***Solution - II (Further optimization in time as well as in space, Using priority queue, Accepted)-***\\n* Now, we want to become a good programmer and anyhow we want to optimize our soloution.\\n* The main point is to observe here is that ***every linked list is already sorted*** and our task is just to merge them.\\n* Our approach to merge linked list is same as about merge function of merge sort.\\n* In merge sort, we have just two arrays / linked list but here we have \\'k\\' linked list.\\n* So by using `min heap` we compare k node values and add the smallest one to the final list.\\n* One property of min heap we have to remember here is that, ***it keeps smallest element always on the top,*** so using that property we merge our k sorted linked list.\\n```\\nSuppose if total number of nodes present in all linked list is \\'n\\' \\nTime Complexity --> O(n log k) // as we are using min heap\\nSpace Complexity --> O(k) // at a single point of time min heap always handle the k elements\\nIt paases [ 133 / 133] in built test cases\\n```\\n**Code (C++)**\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\n\\nclass Solution {\\npublic:\\n    // we define pair as pi\\n    #define pi pair<int, ListNode* >\\n    \\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        int k = lists.size(); // taking the size of the linked list\\n        \\n        if(k == 0) // if no linked list is present\\n            return NULL; // simply return null\\n        \\n        priority_queue<pi, vector<pi>, greater<pi>> minh; // making priority queue\\n        \\n        for(int i = 0; i < k; i++) // traverse from the whole array \\n        {\\n            ListNode* curr_list = lists[i]; // extracting current linked list\\n            \\n            if(curr_list != NULL) // if element present in the linked list\\n            {\\n                minh.push({curr_list -> val, curr_list}); // push into min heap\\n            }\\n        }\\n        \\n        // this does not gurantee that k is zero, \\n        // suppose an array like this [[],[],[],],here k = 3 and size of array is 0\\n        if(minh.size() == 0) // if their is no element i.e zero element\\n            return NULL;\\n        \\n        ListNode* head = new ListNode(); // can also be called as dummy\\n        ListNode* curr = head; // make a pointer pointing to head\\n        \\n        while(minh.empty() == false) // adding further most elements to min heap\\n        {\\n            pair<int, ListNode*> temp = minh.top(); // extracting top pair\\n            minh.pop(); // pop that pair\\n            \\n            if(temp.second -> next != NULL) // if elements still remaining in the linked list then push them\\n            {\\n                minh.push({temp.second -> next -> val, temp.second -> next});\\n            }\\n            \\n            curr -> next = temp.second;\\n            curr = curr -> next;\\n        }\\n        \\n        curr -> next = NULL; \\n        head = head -> next; // move head, which is actually containg the list\\n        \\n        return head; // return head\\n    }\\n};\\n```\\n___________________________\\n***Solution - III (Further optimization in space, Accepted)-***\\n* Okay, the question arises, if we just have to merge k linked list, \\n* Is the use of priority queue is necesssary? Can\\'t we do it without using the priority queue?\\n* The answer is ***YES***, we can do further optimization in space complexity as well.\\n* We use `two pointers` for doing this.\\n* First we put start pointer to zero index and last pointer to last index and after that we start merging them thinking of as two sorted linked list.\\n* And again we will continue this task until we get a single linked list.\\n* See commented code, you will get it easily.\\n```\\nSuppose if total number of nodes present in all linked list is \\'n\\' \\nTime Complexity --> O(n log k)\\nSpace Complexity --> O(1) \\nIt paases [ 133 / 133] in built test cases\\n```\\n**Code (C++)**\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // this do the same work as merge function of merging two values\\n    ListNode* merge(ListNode* first, ListNode* second)\\n    {\\n        ListNode* result = NULL;\\n        \\n        if(first == nullptr)\\n            return second;\\n        \\n        if(second == nullptr)\\n            return first;\\n        \\n        \\n        if(first -> val <= second -> val)\\n        {\\n            result = first;\\n            result -> next = merge(first -> next, second);\\n        }\\n        else\\n        {\\n            result = second;\\n            result -> next = merge(first, second -> next);\\n        }\\n        return result;\\n    }\\n    ListNode* mergeKLists(vector<ListNode*>& arr) {\\n        int k = arr.size(); // extracting size of array\\n        if(k == 0) // if size of array is value\\n            return NULL;\\n        \\n        int start = 0; // start pointer\\n        int last = k -1; // last pointer\\n        int temp;\\n        while(last != 0) // if last pointer not becomes zero\\n        {\\n            start = 0;\\n            temp = last;\\n            while(start < temp)\\n            {\\n                // merge them and store in one of the linked list\\n                arr[start] = merge(arr[start],arr[temp]);\\n                start++; // increment start\\n                temp--; // decrese start\\n                \\n                if(start >= temp) // if at any point start passes the temp\\n                {\\n                    last = temp;\\n                }\\n            }\\n        }\\n        return arr[0]; // return first linked list of the aray as now it contains the all nodes in the sorted order.\\n        \\n    }\\n};\\n```\\n\\n***`If u find this useful , please consider to give a upvote!!`***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nTake an example -\\nGiven: k number of sorted linked list in ascending order.\\nAim: Merge them into a single sorted linked list.\\n\\nTake anthor example which is not given in question-\\nL1: 1 -> 5 -> 7 -> 9 -> N\\nL2: 2 -> 4 -> 8 -> N\\nL3: 3 -> 6 -> N\\n\\nSo our answer should like this:\\n1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> N\\n```\n```\\nSuppose if total number of nodes present in all linked list is \\'n\\' \\nTime Complexity --> O(n log n) // as sorting takes (n log n) time\\nSpace Complexity --> O(n) // to store nodes of the all linked list\\nIt paases [ 133 / 133] in built test cases\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        int k = lists.size(); // taking size of the list\\n        if(k == 0) // if size is zero\\n            return NULL; // simply return NULL\\n        \\n        // making a vector pair where first contain value and second contain node\\n        vector<pair<int, ListNode*>> arr; \\n        \\n        for(int i = 0; i < k; i++) // traverse all over the list\\n        {\\n            ListNode* curr_list = lists[i]; // extracting current linked list\\n            \\n            while(curr_list != NULL) // while current linked list is NOT NULL\\n            {\\n                arr.push_back({curr_list -> val, curr_list}); // push into vector\\n                curr_list = curr_list -> next;\\n            }\\n        }\\n        \\n        // this does not gurantee that k is zero, \\n        // suppose an array like this [[],[],[],],here k = 3 and size of array is 0\\n        if(arr.size() == 0) // if their is no element i.e zero element\\n            return NULL;\\n        \\n        sort(arr.begin(), arr.end()); // sort the vector on the basis of values\\n        \\n        // start making links b/w the elements of vector\\n        for(int i = 0; i < arr.size() - 1; i++)\\n        {\\n            arr[i].second -> next = arr[i + 1].second;\\n        }\\n        \\n        // in the next of last node put NULL\\n        arr[arr.size() - 1].second -> next = NULL;\\n        \\n        return arr[0].second; // return first node of the vector\\n    }\\n};\\n```\n```\\nSuppose if total number of nodes present in all linked list is \\'n\\' \\nTime Complexity --> O(n log k) // as we are using min heap\\nSpace Complexity --> O(k) // at a single point of time min heap always handle the k elements\\nIt paases [ 133 / 133] in built test cases\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\n\\nclass Solution {\\npublic:\\n    // we define pair as pi\\n    #define pi pair<int, ListNode* >\\n    \\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        int k = lists.size(); // taking the size of the linked list\\n        \\n        if(k == 0) // if no linked list is present\\n            return NULL; // simply return null\\n        \\n        priority_queue<pi, vector<pi>, greater<pi>> minh; // making priority queue\\n        \\n        for(int i = 0; i < k; i++) // traverse from the whole array \\n        {\\n            ListNode* curr_list = lists[i]; // extracting current linked list\\n            \\n            if(curr_list != NULL) // if element present in the linked list\\n            {\\n                minh.push({curr_list -> val, curr_list}); // push into min heap\\n            }\\n        }\\n        \\n        // this does not gurantee that k is zero, \\n        // suppose an array like this [[],[],[],],here k = 3 and size of array is 0\\n        if(minh.size() == 0) // if their is no element i.e zero element\\n            return NULL;\\n        \\n        ListNode* head = new ListNode(); // can also be called as dummy\\n        ListNode* curr = head; // make a pointer pointing to head\\n        \\n        while(minh.empty() == false) // adding further most elements to min heap\\n        {\\n            pair<int, ListNode*> temp = minh.top(); // extracting top pair\\n            minh.pop(); // pop that pair\\n            \\n            if(temp.second -> next != NULL) // if elements still remaining in the linked list then push them\\n            {\\n                minh.push({temp.second -> next -> val, temp.second -> next});\\n            }\\n            \\n            curr -> next = temp.second;\\n            curr = curr -> next;\\n        }\\n        \\n        curr -> next = NULL; \\n        head = head -> next; // move head, which is actually containg the list\\n        \\n        return head; // return head\\n    }\\n};\\n```\n```\\nSuppose if total number of nodes present in all linked list is \\'n\\' \\nTime Complexity --> O(n log k)\\nSpace Complexity --> O(1) \\nIt paases [ 133 / 133] in built test cases\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // this do the same work as merge function of merging two values\\n    ListNode* merge(ListNode* first, ListNode* second)\\n    {\\n        ListNode* result = NULL;\\n        \\n        if(first == nullptr)\\n            return second;\\n        \\n        if(second == nullptr)\\n            return first;\\n        \\n        \\n        if(first -> val <= second -> val)\\n        {\\n            result = first;\\n            result -> next = merge(first -> next, second);\\n        }\\n        else\\n        {\\n            result = second;\\n            result -> next = merge(first, second -> next);\\n        }\\n        return result;\\n    }\\n    ListNode* mergeKLists(vector<ListNode*>& arr) {\\n        int k = arr.size(); // extracting size of array\\n        if(k == 0) // if size of array is value\\n            return NULL;\\n        \\n        int start = 0; // start pointer\\n        int last = k -1; // last pointer\\n        int temp;\\n        while(last != 0) // if last pointer not becomes zero\\n        {\\n            start = 0;\\n            temp = last;\\n            while(start < temp)\\n            {\\n                // merge them and store in one of the linked list\\n                arr[start] = merge(arr[start],arr[temp]);\\n                start++; // increment start\\n                temp--; // decrese start\\n                \\n                if(start >= temp) // if at any point start passes the temp\\n                {\\n                    last = temp;\\n                }\\n            }\\n        }\\n        return arr[0]; // return first linked list of the aray as now it contains the all nodes in the sorted order.\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1032540,
                "title": "c-simplest-easy-and-short-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* merge2Lists(ListNode* l1, ListNode* l2) {\\n        if (!l1) return l2;\\n        if (!l2) return l1;\\n        ListNode* head = l1->val <= l2->val? l1 : l2;\\n        head->next = l1->val <= l2->val ? merge2Lists(l1->next, l2) : merge2Lists(l1, l2->next);\\n        return head;\\n    }\\n    \\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if (lists.size() == 0) return NULL;\\n        \\n        ListNode* head = lists[0];\\n        \\n        for (int i = 1; i < lists.size(); i++)\\n            head = merge2Lists(head, lists[i]);\\n        \\n        return head;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* merge2Lists(ListNode* l1, ListNode* l2) {\\n        if (!l1) return l2;\\n        if (!l2) return l1;\\n        ListNode* head = l1->val <= l2->val? l1 : l2;\\n        head->next = l1->val <= l2->val ? merge2Lists(l1->next, l2) : merge2Lists(l1, l2->next);\\n        return head;\\n    }\\n    \\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if (lists.size() == 0) return NULL;\\n        \\n        ListNode* head = lists[0];\\n        \\n        for (int i = 1; i < lists.size(); i++)\\n            head = merge2Lists(head, lists[i]);\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 424567,
                "title": "super-easy-min-heap-c-solution",
                "content": "```\\nListNode* mergeKLists(vector<ListNode*>& lists) {\\n        \\n        if(lists.empty()) return nullptr;\\n        \\n        priority_queue<pair<int,ListNode*>> pq;\\n        int n=lists.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            while(lists[i]!=nullptr)\\n            {\\n                pq.push({-lists[i]->val,lists[i]});\\n                lists[i]=lists[i]->next;\\n            }\\n        }\\n        \\n        \\n        ListNode* head=nullptr;\\n        ListNode* k=nullptr;\\n        \\n        if(pq.empty()) return head;\\n        \\n        head=pq.top().second;\\n        k=pq.top().second;\\n        pq.pop();\\n        \\n     \\n        while(!pq.empty())\\n        {\\n            k->next=pq.top().second;\\n            k=pq.top().second;\\n            pq.pop();\\n            \\n        }\\n        k->next=NULL;\\n        \\n        return head==NULL?nullptr:head;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nListNode* mergeKLists(vector<ListNode*>& lists) {\\n        \\n        if(lists.empty()) return nullptr;\\n        \\n        priority_queue<pair<int,ListNode*>> pq;\\n        int n=lists.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            while(lists[i]!=nullptr)\\n            {\\n                pq.push({-lists[i]->val,lists[i]});\\n                lists[i]=lists[i]->next;\\n            }\\n        }\\n        \\n        \\n        ListNode* head=nullptr;\\n        ListNode* k=nullptr;\\n        \\n        if(pq.empty()) return head;\\n        \\n        head=pq.top().second;\\n        k=pq.top().second;\\n        pq.pop();\\n        \\n     \\n        while(!pq.empty())\\n        {\\n            k->next=pq.top().second;\\n            k=pq.top().second;\\n            pq.pop();\\n            \\n        }\\n        k->next=NULL;\\n        \\n        return head==NULL?nullptr:head;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3285930,
                "title": "100-faster-c-java-python",
                "content": "# Code\\n\\nPlease **Upvote** And **Comment** ....!\\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F\\n\\n```JAVA []\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        if (lists == null || lists.length == 0) {\\n            return null;\\n        }\\n        return mergeKListsHelper(lists, 0, lists.length - 1);\\n    }\\n    \\n    private ListNode mergeKListsHelper(ListNode[] lists, int start, int end) {\\n        if (start == end) {\\n            return lists[start];\\n        }\\n        if (start + 1 == end) {\\n            return merge(lists[start], lists[end]);\\n        }\\n        int mid = start + (end - start) / 2;\\n        ListNode left = mergeKListsHelper(lists, start, mid);\\n        ListNode right = mergeKListsHelper(lists, mid + 1, end);\\n        return merge(left, right);\\n    }\\n    \\n    private ListNode merge(ListNode l1, ListNode l2) {\\n        ListNode dummy = new ListNode(0);\\n        ListNode curr = dummy;\\n        \\n        while (l1 != null && l2 != null) {\\n            if (l1.val < l2.val) {\\n                curr.next = l1;\\n                l1 = l1.next;\\n            } else {\\n                curr.next = l2;\\n                l2 = l2.next;\\n            }\\n            curr = curr.next;\\n        }\\n        \\n        curr.next = (l1 != null) ? l1 : l2;\\n        \\n        return dummy.next;\\n    }\\n}\\n\\n\\n```\\n```python []\\nclass Solution:\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        if not lists:\\n            return None\\n        if len(lists) == 1:\\n            return lists[0]\\n        \\n        mid = len(lists) // 2\\n        left = self.mergeKLists(lists[:mid])\\n        right = self.mergeKLists(lists[mid:])\\n        \\n        return self.merge(left, right)\\n    \\n    def merge(self, l1, l2):\\n        dummy = ListNode(0)\\n        curr = dummy\\n        \\n        while l1 and l2:\\n            if l1.val < l2.val:\\n                curr.next = l1\\n                l1 = l1.next\\n            else:\\n                curr.next = l2\\n                l2 = l2.next\\n            curr = curr.next\\n        \\n        curr.next = l1 or l2\\n        \\n        return dummy.next\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if (lists.empty()) {\\n            return nullptr;\\n        }\\n        return mergeKListsHelper(lists, 0, lists.size() - 1);\\n    }\\n    \\n    ListNode* mergeKListsHelper(vector<ListNode*>& lists, int start, int end) {\\n        if (start == end) {\\n            return lists[start];\\n        }\\n        if (start + 1 == end) {\\n            return merge(lists[start], lists[end]);\\n        }\\n        int mid = start + (end - start) / 2;\\n        ListNode* left = mergeKListsHelper(lists, start, mid);\\n        ListNode* right = mergeKListsHelper(lists, mid + 1, end);\\n        return merge(left, right);\\n    }\\n    \\n    ListNode* merge(ListNode* l1, ListNode* l2) {\\n        ListNode* dummy = new ListNode(0);\\n        ListNode* curr = dummy;\\n        \\n        while (l1 && l2) {\\n            if (l1->val < l2->val) {\\n                curr->next = l1;\\n                l1 = l1->next;\\n            } else {\\n                curr->next = l2;\\n                l2 = l2->next;\\n            }\\n            curr = curr->next;\\n        }\\n        \\n        curr->next = l1 ? l1 : l2;\\n        \\n        return dummy->next;\\n    }\\n};\\n\\n```\\n![8873f9b1-dfa4-4d9c-bb67-1b6db9d65e35_1674992431.3815322.jpeg](https://assets.leetcode.com/users/images/ae87d327-68b0-485b-959d-21ff0ad8af6e_1678582147.0744655.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Linked List",
                    "Heap (Priority Queue)"
                ],
                "code": "```JAVA []\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        if (lists == null || lists.length == 0) {\\n            return null;\\n        }\\n        return mergeKListsHelper(lists, 0, lists.length - 1);\\n    }\\n    \\n    private ListNode mergeKListsHelper(ListNode[] lists, int start, int end) {\\n        if (start == end) {\\n            return lists[start];\\n        }\\n        if (start + 1 == end) {\\n            return merge(lists[start], lists[end]);\\n        }\\n        int mid = start + (end - start) / 2;\\n        ListNode left = mergeKListsHelper(lists, start, mid);\\n        ListNode right = mergeKListsHelper(lists, mid + 1, end);\\n        return merge(left, right);\\n    }\\n    \\n    private ListNode merge(ListNode l1, ListNode l2) {\\n        ListNode dummy = new ListNode(0);\\n        ListNode curr = dummy;\\n        \\n        while (l1 != null && l2 != null) {\\n            if (l1.val < l2.val) {\\n                curr.next = l1;\\n                l1 = l1.next;\\n            } else {\\n                curr.next = l2;\\n                l2 = l2.next;\\n            }\\n            curr = curr.next;\\n        }\\n        \\n        curr.next = (l1 != null) ? l1 : l2;\\n        \\n        return dummy.next;\\n    }\\n}\\n\\n\\n```\n```python []\\nclass Solution:\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        if not lists:\\n            return None\\n        if len(lists) == 1:\\n            return lists[0]\\n        \\n        mid = len(lists) // 2\\n        left = self.mergeKLists(lists[:mid])\\n        right = self.mergeKLists(lists[mid:])\\n        \\n        return self.merge(left, right)\\n    \\n    def merge(self, l1, l2):\\n        dummy = ListNode(0)\\n        curr = dummy\\n        \\n        while l1 and l2:\\n            if l1.val < l2.val:\\n                curr.next = l1\\n                l1 = l1.next\\n            else:\\n                curr.next = l2\\n                l2 = l2.next\\n            curr = curr.next\\n        \\n        curr.next = l1 or l2\\n        \\n        return dummy.next\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if (lists.empty()) {\\n            return nullptr;\\n        }\\n        return mergeKListsHelper(lists, 0, lists.size() - 1);\\n    }\\n    \\n    ListNode* mergeKListsHelper(vector<ListNode*>& lists, int start, int end) {\\n        if (start == end) {\\n            return lists[start];\\n        }\\n        if (start + 1 == end) {\\n            return merge(lists[start], lists[end]);\\n        }\\n        int mid = start + (end - start) / 2;\\n        ListNode* left = mergeKListsHelper(lists, start, mid);\\n        ListNode* right = mergeKListsHelper(lists, mid + 1, end);\\n        return merge(left, right);\\n    }\\n    \\n    ListNode* merge(ListNode* l1, ListNode* l2) {\\n        ListNode* dummy = new ListNode(0);\\n        ListNode* curr = dummy;\\n        \\n        while (l1 && l2) {\\n            if (l1->val < l2->val) {\\n                curr->next = l1;\\n                l1 = l1->next;\\n            } else {\\n                curr->next = l2;\\n                l2 = l2->next;\\n            }\\n            curr = curr->next;\\n        }\\n        \\n        curr->next = l1 ? l1 : l2;\\n        \\n        return dummy->next;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 10513,
                "title": "108ms-python-solution-with-heapq-and-avoid-changing-heap-size",
                "content": "    def mergeKLists(self, lists):\\n        from heapq import heappush, heappop, heapreplace, heapify\\n        dummy = node = ListNode(0)\\n        h = [(n.val, n) for n in lists if n]\\n        heapify(h)\\n        while h:\\n            v, n = h[0]\\n            if n.next is None:\\n                heappop(h) #only change heap size when necessary\\n            else:\\n                heapreplace(h, (n.next.val, n.next))\\n            node.next = n\\n            node = node.next\\n    \\n        return dummy.next",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def mergeKLists(self, lists):\\n        from heapq import heappush, heappop, heapreplace, heapify\\n        dummy = node = ListNode(0)\\n        h = [(n.val, n) for n in lists if n]\\n        heapify(h)\\n        while h:\\n            v, n = h[0]\\n            if n.next is None:\\n                heappop(h) #only change heap size when necessary\\n            else:\\n                heapreplace(h, (n.next.val, n.next))\\n            node.next = n\\n            node = node.next\\n    \\n        return dummy.next",
                "codeTag": "Python3"
            },
            {
                "id": 3286058,
                "title": "image-explanation-5-methods-divide-conquer-priority-queue-complete-intuition",
                "content": "# Video Solution\\nhttps://youtu.be/wIimE9hKcl4\\n\\n# Approach & Complete Inutuition\\nMethod 1: Brute Force\\nMethod 2: Compare K elements One By One\\nMethod 3: Compare K elements by Priority Queue\\nMethod 4: Merge 2 Lists at a time\\nMethod 5: Merge K lists by Divide & Conquer (**`Most Optimal`**)\\n\\n# Image Explanation\\n![image.png](https://assets.leetcode.com/users/images/46885295-5e87-479a-8884-963030ac6b18_1678586862.7911444.png)\\n![image.png](https://assets.leetcode.com/users/images/0051b520-4469-4725-86bd-fb606fb591f8_1678586878.7285347.png)\\n![image.png](https://assets.leetcode.com/users/images/79bc054d-ad53-4525-9611-f128de5fd3b5_1678586890.0865543.png)\\n![image.png](https://assets.leetcode.com/users/images/dfc83aae-06ff-48b0-981c-6fc83aafbac0_1678586902.1306381.png)\\n![image.png](https://assets.leetcode.com/users/images/4d2b0950-93cb-4d94-abf4-03d94f60ddf9_1678586913.2264328.png)\\n![image.png](https://assets.leetcode.com/users/images/1367ca55-aaba-496a-a78e-000d970c2587_1678586925.7524848.png)\\n![image.png](https://assets.leetcode.com/users/images/9cd1e449-e965-4b84-b784-c2fbdc6d6628_1678586935.1948905.png)\\n![image.png](https://assets.leetcode.com/users/images/f64cdbaf-f12d-4777-bad5-38610db30d87_1678586948.0475173.png)\\n![image.png](https://assets.leetcode.com/users/images/7dd6025c-2362-4956-a4f3-bd3e74f7e075_1678586961.0338929.png)\\n![image.png](https://assets.leetcode.com/users/images/d4636fc5-48da-4c57-b482-bdd2e610e00e_1678586977.6893442.png)\\n![image.png](https://assets.leetcode.com/users/images/9d283a96-29a5-4e55-ba99-77bbc9b0851a_1678586986.6568656.png)\\n![image.png](https://assets.leetcode.com/users/images/2d477989-3163-4c7e-9a0e-52e5a0b5215f_1678587002.2201269.png)\\n![image.png](https://assets.leetcode.com/users/images/06dfa807-5026-4469-8b19-62f3debc59ea_1678587012.1176128.png)\\n![image.png](https://assets.leetcode.com/users/images/2439d09b-7e90-4664-b935-0f4eb58e5d20_1678587047.020193.png)\\n![image.png](https://assets.leetcode.com/users/images/97149ca1-bbef-4995-91e8-86cedec6ce24_1678587054.8823147.png)\\n\\n\\n# Method 5 - Code (Divide & Conquer)\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if(lists.size() == 0) return NULL;\\n        return mergeKListsHelper(lists, 0, lists.size()-1);\\n    }\\n\\n    ListNode* mergeKListsHelper(vector<ListNode*>& lists, int start, int end) {\\n        if(start>end) return NULL; \\n        if(start==end) return lists[start];\\n\\n        int mid = start + (end-start)/2;\\n        ListNode* left = mergeKListsHelper(lists, start, mid);\\n        ListNode* right = mergeKListsHelper(lists, mid + 1, end);\\n        return merge(left, right);\\n    }\\n\\n    ListNode* merge(ListNode* list1Head, ListNode* list2Head) {\\n        ListNode* dummyHead = new ListNode(-1);\\n        ListNode* dummyTail = dummyHead;\\n\\n        while(list1Head!=NULL && list2Head!=NULL){\\n            if(list1Head->val < list2Head->val){\\n                dummyTail->next = list1Head;\\n                list1Head = list1Head->next;\\n            }else{\\n                dummyTail->next = list2Head;\\n                list2Head = list2Head->next;\\n            }\\n            dummyTail = dummyTail->next;\\n        }\\n        dummyTail->next = (list1Head != NULL) ? list1Head : list2Head;\\n        return dummyHead->next;\\n    }\\n};\\n```\\n\\n# Method 3 - Code (Priority Queue)\\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if(lists.size() == 0) return NULL;\\n\\n        ListNode* dummyHead = new ListNode(-1);\\n        ListNode* dummyTail = dummyHead;\\n\\n        priority_queue<pair<int, ListNode*>, vector<pair<int, ListNode*>>, greater<pair<int, ListNode*>>> pq;\\n        for(auto head : lists)  if(head != NULL) pq.push({head->val, head});\\n\\n        while(!pq.empty()){\\n            ListNode* minNode = pq.top().second;\\n            pq.pop();\\n            if(minNode->next != NULL) pq.push({minNode->next->val, minNode->next});\\n\\n            dummyTail->next = minNode;\\n            dummyTail = dummyTail->next;\\n        }\\n        return dummyHead->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if(lists.size() == 0) return NULL;\\n        return mergeKListsHelper(lists, 0, lists.size()-1);\\n    }\\n\\n    ListNode* mergeKListsHelper(vector<ListNode*>& lists, int start, int end) {\\n        if(start>end) return NULL; \\n        if(start==end) return lists[start];\\n\\n        int mid = start + (end-start)/2;\\n        ListNode* left = mergeKListsHelper(lists, start, mid);\\n        ListNode* right = mergeKListsHelper(lists, mid + 1, end);\\n        return merge(left, right);\\n    }\\n\\n    ListNode* merge(ListNode* list1Head, ListNode* list2Head) {\\n        ListNode* dummyHead = new ListNode(-1);\\n        ListNode* dummyTail = dummyHead;\\n\\n        while(list1Head!=NULL && list2Head!=NULL){\\n            if(list1Head->val < list2Head->val){\\n                dummyTail->next = list1Head;\\n                list1Head = list1Head->next;\\n            }else{\\n                dummyTail->next = list2Head;\\n                list2Head = list2Head->next;\\n            }\\n            dummyTail = dummyTail->next;\\n        }\\n        dummyTail->next = (list1Head != NULL) ? list1Head : list2Head;\\n        return dummyHead->next;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if(lists.size() == 0) return NULL;\\n\\n        ListNode* dummyHead = new ListNode(-1);\\n        ListNode* dummyTail = dummyHead;\\n\\n        priority_queue<pair<int, ListNode*>, vector<pair<int, ListNode*>>, greater<pair<int, ListNode*>>> pq;\\n        for(auto head : lists)  if(head != NULL) pq.push({head->val, head});\\n\\n        while(!pq.empty()){\\n            ListNode* minNode = pq.top().second;\\n            pq.pop();\\n            if(minNode->next != NULL) pq.push({minNode->next->val, minNode->next});\\n\\n            dummyTail->next = minNode;\\n            dummyTail = dummyTail->next;\\n        }\\n        return dummyHead->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 152022,
                "title": "brute-force-merge-sort-heap",
                "content": "## Brute Force\\nWe might merge two sorted list among `lists` each round, until there is only one list.\\n```\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        if (lists.length == 0)\\n            return null;\\n        ListNode merged = null;\\n        for (ListNode head : lists) {\\n            merged = mergeTwoLists(merged, head);\\n        }\\n        return merged;\\n    }\\n    \\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\\n        if (l1 == null)\\n            return l2;\\n        if (l2 == null)\\n            return l1;\\n        if (l1.val < l2.val) {\\n            l1.next = mergeTwoLists(l1.next, l2);\\n            return l1;\\n        }\\n        else {\\n            l2.next = mergeTwoLists(l1, l2.next);\\n            return l2;\\n        }\\n    }\\n}\\n```\\n## Merge Sort\\nSorting always reminds us of Merge Sort algorithm, the only difference between sorting numbers and sorting lists is the merging process, i.e. `mergeTwoLists`.\\n```\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        if (lists.length == 0)\\n            return null;\\n        return mergeKLists(lists, 0, lists.length - 1);\\n    }\\n    \\n    private ListNode mergeKLists(ListNode[] lists, int start, int end) {\\n        if (end < start)\\n            return null;\\n        if (start == end)\\n            return lists[start];\\n        if (start + 1 == end)\\n            return mergeTwoLists(lists[start], lists[end]);\\n        \\n        int mid = start + ((end - start) >> 1);\\n        ListNode lower = mergeKLists(lists, start, mid);\\n        ListNode upper = mergeKLists(lists, mid + 1, end);\\n        \\n        return mergeTwoLists(lower, upper);\\n    }\\n    \\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\\n        if (l1 == null)\\n            return l2;\\n        if (l2 == null)\\n            return l1;\\n        if (l1.val < l2.val) {\\n            l1.next = mergeTwoLists(l1.next, l2);\\n            return l1;\\n        }\\n        else {\\n            l2.next = mergeTwoLists(l1, l2.next);\\n            return l2;\\n        }\\n    }\\n}\\n```\\n## Heap\\nIn order to build one sorted list, we always want the minimum node among heads of lists.\\nThat\\'s natural to Min Heap.\\n```\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        if (lists.length == 0) {\\n            return null;\\n        }\\n        \\n        PriorityQueue<ListNode> minHeap = new PriorityQueue<>((a, b) -> a.val - b.val);\\n        for (ListNode head : lists) {\\n            if (head != null) // Ensures no \"null\" in minHeap\\n                minHeap.offer(head);\\n        }\\n        \\n        ListNode dummyHead = new ListNode(), cur = dummyHead;\\n        while (!minHeap.isEmpty()) {\\n            ListNode min = minHeap.poll();\\n            cur.next = min;\\n            cur = cur.next;\\n            \\n            if (min.next != null) // Ensures no \"null\" in minHeap\\n                minHeap.offer(min.next);\\n        }\\n        \\n        return dummyHead.next;\\n    }\\n}\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        if (lists.length == 0)\\n            return null;\\n        ListNode merged = null;\\n        for (ListNode head : lists) {\\n            merged = mergeTwoLists(merged, head);\\n        }\\n        return merged;\\n    }\\n    \\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\\n        if (l1 == null)\\n            return l2;\\n        if (l2 == null)\\n            return l1;\\n        if (l1.val < l2.val) {\\n            l1.next = mergeTwoLists(l1.next, l2);\\n            return l1;\\n        }\\n        else {\\n            l2.next = mergeTwoLists(l1, l2.next);\\n            return l2;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        if (lists.length == 0)\\n            return null;\\n        return mergeKLists(lists, 0, lists.length - 1);\\n    }\\n    \\n    private ListNode mergeKLists(ListNode[] lists, int start, int end) {\\n        if (end < start)\\n            return null;\\n        if (start == end)\\n            return lists[start];\\n        if (start + 1 == end)\\n            return mergeTwoLists(lists[start], lists[end]);\\n        \\n        int mid = start + ((end - start) >> 1);\\n        ListNode lower = mergeKLists(lists, start, mid);\\n        ListNode upper = mergeKLists(lists, mid + 1, end);\\n        \\n        return mergeTwoLists(lower, upper);\\n    }\\n    \\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\\n        if (l1 == null)\\n            return l2;\\n        if (l2 == null)\\n            return l1;\\n        if (l1.val < l2.val) {\\n            l1.next = mergeTwoLists(l1.next, l2);\\n            return l1;\\n        }\\n        else {\\n            l2.next = mergeTwoLists(l1, l2.next);\\n            return l2;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        if (lists.length == 0) {\\n            return null;\\n        }\\n        \\n        PriorityQueue<ListNode> minHeap = new PriorityQueue<>((a, b) -> a.val - b.val);\\n        for (ListNode head : lists) {\\n            if (head != null) // Ensures no \"null\" in minHeap\\n                minHeap.offer(head);\\n        }\\n        \\n        ListNode dummyHead = new ListNode(), cur = dummyHead;\\n        while (!minHeap.isEmpty()) {\\n            ListNode min = minHeap.poll();\\n            cur.next = min;\\n            cur = cur.next;\\n            \\n            if (min.next != null) // Ensures no \"null\" in minHeap\\n                minHeap.offer(min.next);\\n        }\\n        \\n        return dummyHead.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 10640,
                "title": "simple-java-merge-sort",
                "content": "For this problem, use merge sort is simple and fast, I wonder why some guys solve it use PriorityQueue.\\n\\nI think the complexity is k * n * logk. Because the recursion depth is logK,  and in each level, every element will be compared.\\n\\n    public ListNode mergeKLists(ListNode[] lists) {\\n\\t\\tif (lists == null || lists.length == 0)\\n\\t\\t\\treturn null;\\n        return mergeKLists(lists, 0, lists.length - 1);\\n    }\\n\\tprivate ListNode mergeKLists(ListNode[] lists, int start, int end) {\\n\\t\\tif (start == end) {\\n\\t\\t\\treturn lists[start];\\n\\t\\t} else if (start < end){\\n\\t\\t\\tint mid = (end - start) / 2 + start;\\n\\t\\t\\tListNode left = mergeKLists(lists, start, mid);\\n\\t\\t\\tListNode right = mergeKLists(lists, mid + 1, end);\\n\\t\\t\\treturn mergeTwoLists(left, right);\\n\\t\\t} else {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\t}\\n\\nmergeTwoLists is base on the Merge Two Sorted Lists problem.",
                "solutionTags": [
                    "Merge Sort"
                ],
                "code": "For this problem, use merge sort is simple and fast, I wonder why some guys solve it use PriorityQueue.\\n\\nI think the complexity is k * n * logk. Because the recursion depth is logK,  and in each level, every element will be compared.\\n\\n    public ListNode mergeKLists(ListNode[] lists) {\\n\\t\\tif (lists == null || lists.length == 0)\\n\\t\\t\\treturn null;\\n        return mergeKLists(lists, 0, lists.length - 1);\\n    }\\n\\tprivate ListNode mergeKLists(ListNode[] lists, int start, int end) {\\n\\t\\tif (start == end) {\\n\\t\\t\\treturn lists[start];\\n\\t\\t} else if (start < end){\\n\\t\\t\\tint mid = (end - start) / 2 + start;\\n\\t\\t\\tListNode left = mergeKLists(lists, start, mid);\\n\\t\\t\\tListNode right = mergeKLists(lists, mid + 1, end);\\n\\t\\t\\treturn mergeTwoLists(left, right);\\n\\t\\t} else {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\t}\\n\\nmergeTwoLists is base on the Merge Two Sorted Lists problem.",
                "codeTag": "Unknown"
            },
            {
                "id": 2281039,
                "title": "c-all-5-standard-approaches-only-in-single-post-most-learning",
                "content": "\\u2714 ***All codes are running successfully !***\\n*if you find that this post to be helpful for you, So, please take out **one second** for single UPVOTE.* \\n\\n----\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n```\\n\\n----\\n**Approach-1 : USING MIN HEAP**\\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    struct compare\\n    {\\n        bool operator()(ListNode* a, ListNode *b)\\n        {\\n            return a->val > b->val;   // min heap  \\n        }\\n    };\\n    \\n    ListNode* mergeKLists(vector<ListNode*>& arr) // saari linked list ka head arr mai hai\\n    {\\n        int j;\\n        for(j = 0;j< arr.size();j++){\\n            if(arr[j] != NULL)\\n                break;\\n        }\\n        if(j == arr.size()){ // all list empty\\n            return NULL;\\n        }\\n        \\n        priority_queue<ListNode*, vector<ListNode*>, compare>pq;   \\n        for(int i = 0;i<arr.size();i++){\\n            if(arr[i] != NULL)\\n                pq.push(arr[i]);\\n        }\\n        \\n        ListNode *mergeH = new ListNode(0);\\n        ListNode *last = mergeH;\\n        while(!pq.empty())\\n        {\\n            ListNode* curr = pq.top();\\n            pq.pop();\\n            \\n            last->next = curr;\\n            last = last->next;\\n            \\n            if(curr != NULL && curr->next != NULL){\\n                pq.push(curr->next);\\n            }\\n            \\n        }\\n        return mergeH->next;\\n    }\\n};\\n```\\n\\n----\\n**Approach - 2 : Using simple Merging of 2 sorted array**\\n**Time : `381 ms`**\\n```\\nclass Solution {\\npublic:\\n    \\n    ListNode* mergeTwoSorted(ListNode *a, ListNode* b)\\n    {\\n        if(a==NULL) return b;\\n        if(b==NULL) return a;\\n        \\n        if(a->val<=b->val){\\n            a->next = mergeTwoSorted(a->next, b);\\n            return a;\\n        }\\n        else{\\n            b->next = mergeTwoSorted(a, b->next);\\n            return b;\\n        }\\n    }\\n    \\n    ListNode* mergeKLists(vector<ListNode*>& lists)\\n    {\\n        if(lists.size()==0) return NULL;\\n        while(lists.size() > 1){\\n            lists.push_back(mergeTwoSorted(lists[0], lists[1])); // time consuming \\n            // erase first 2 heads of lists\\n            lists.erase(lists.begin()); // time consuming \\n            lists.erase(lists.begin());\\n        }\\n        return lists[0];\\n    }\\n};\\n```\\n\\n\\n----\\n**Approach - 3 : Optimization of Approach 2**\\nwithout using **push_back**, **erase**, which is time consuming,\\n**Time : `47 ms`**\\n```\\nclass Solution {\\npublic:\\n    \\n    ListNode* mergeTwoSorted(ListNode *a, ListNode* b)\\n    {\\n        if(a==NULL) return b;\\n        if(b==NULL) return a;\\n        \\n        if(a->val<=b->val){\\n            a->next = mergeTwoSorted(a->next, b);\\n            return a;\\n        }\\n        else{\\n            b->next = mergeTwoSorted(a, b->next);\\n            return b;\\n        }\\n    }\\n    \\n    ListNode* mergeKLists(vector<ListNode*>& lists)\\n    {\\n        int n=lists.size();\\n        if(lists.size()==0) return NULL;\\n        while(n>1){\\n            \\n            for(int i=0;i<n/2;i++)\\n                lists[i] = mergeTwoSorted(lists[i], lists[n-i-1]);\\n            n = (n+1)/2;\\n        }\\n        return lists.front();\\n    }\\n};\\n```\\n\\n----\\n**Approach - 4 : Iterative Merging of 2 lists**\\n**Time  :** **`17ms`**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    ListNode* mergeTwoSorted(ListNode *l1, ListNode* l2)\\n    {\\n        ListNode* dummy = new ListNode(-1);\\n        ListNode* last = dummy;\\n        \\n        while(l1 and l2)\\n        {\\n            if(l1->val <= l2->val){\\n                last->next = l1;\\n                last = l1;\\n                l1=l1->next;\\n            }\\n            else{\\n                last->next = l2;\\n                last = l2;\\n                l2=l2->next;\\n            }\\n        }\\n        \\n        if(!l1)\\n            last->next = l2;\\n        else\\n            last->next = l1;\\n        return dummy->next;\\n    }\\n    \\n    ListNode* mergeKLists(vector<ListNode*>& lists)\\n    {\\n        int n=lists.size();\\n        if(lists.size()==0) return NULL;\\n        while(n>1){\\n            \\n            for(int i=0;i<n/2;i++)\\n                lists[i] = mergeTwoSorted(lists[i], lists[n-i-1]);\\n            n = (n+1)/2;\\n        }\\n        return lists.front();\\n    }\\n};\\n```\\n\\n----\\n**Approach - 5 : USING MAX HEAP**\\n**Time  :** **`35 ms`**\\n\\n```\\nclass Solution {\\npublic:\\n\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        \\n        if(lists.empty()) return NULL;\\n        \\n        // MAX heap\\n        priority_queue<pair<int, ListNode*>> pq; // (value, Node address)\\n        int n=lists.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            ListNode *p = lists[i];\\n            while(p)\\n            {\\n                pq.push({-p->val, p}); // acts as min heap\\n                p = p->next;\\n            }\\n        }\\n                \\n        ListNode* head=NULL;\\n        ListNode* last=NULL;\\n        \\n        if(pq.empty()) return head;\\n        \\n        head=pq.top().second;\\n        last=pq.top().second;\\n        pq.pop();\\n        \\n        \\n        while(!pq.empty())\\n        {\\n            last->next = pq.top().second;\\n            last = pq.top().second;\\n            pq.pop();\\n            \\n        }\\n        last->next=NULL;\\n        \\n        return head;\\n        \\n    }\\n};\\n```\\n*Thanks for Upvoting !*\\n\\uD83D\\uDE42\\n**It highly motivates me for writing a such clustered posts in which all approaches will be present in a single place.**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Recursion",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    struct compare\\n    {\\n        bool operator()(ListNode* a, ListNode *b)\\n        {\\n            return a->val > b->val;   // min heap  \\n        }\\n    };\\n    \\n    ListNode* mergeKLists(vector<ListNode*>& arr) // saari linked list ka head arr mai hai\\n    {\\n        int j;\\n        for(j = 0;j< arr.size();j++){\\n            if(arr[j] != NULL)\\n                break;\\n        }\\n        if(j == arr.size()){ // all list empty\\n            return NULL;\\n        }\\n        \\n        priority_queue<ListNode*, vector<ListNode*>, compare>pq;   \\n        for(int i = 0;i<arr.size();i++){\\n            if(arr[i] != NULL)\\n                pq.push(arr[i]);\\n        }\\n        \\n        ListNode *mergeH = new ListNode(0);\\n        ListNode *last = mergeH;\\n        while(!pq.empty())\\n        {\\n            ListNode* curr = pq.top();\\n            pq.pop();\\n            \\n            last->next = curr;\\n            last = last->next;\\n            \\n            if(curr != NULL && curr->next != NULL){\\n                pq.push(curr->next);\\n            }\\n            \\n        }\\n        return mergeH->next;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    ListNode* mergeTwoSorted(ListNode *a, ListNode* b)\\n    {\\n        if(a==NULL) return b;\\n        if(b==NULL) return a;\\n        \\n        if(a->val<=b->val){\\n            a->next = mergeTwoSorted(a->next, b);\\n            return a;\\n        }\\n        else{\\n            b->next = mergeTwoSorted(a, b->next);\\n            return b;\\n        }\\n    }\\n    \\n    ListNode* mergeKLists(vector<ListNode*>& lists)\\n    {\\n        if(lists.size()==0) return NULL;\\n        while(lists.size() > 1){\\n            lists.push_back(mergeTwoSorted(lists[0], lists[1])); // time consuming \\n            // erase first 2 heads of lists\\n            lists.erase(lists.begin()); // time consuming \\n            lists.erase(lists.begin());\\n        }\\n        return lists[0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    ListNode* mergeTwoSorted(ListNode *a, ListNode* b)\\n    {\\n        if(a==NULL) return b;\\n        if(b==NULL) return a;\\n        \\n        if(a->val<=b->val){\\n            a->next = mergeTwoSorted(a->next, b);\\n            return a;\\n        }\\n        else{\\n            b->next = mergeTwoSorted(a, b->next);\\n            return b;\\n        }\\n    }\\n    \\n    ListNode* mergeKLists(vector<ListNode*>& lists)\\n    {\\n        int n=lists.size();\\n        if(lists.size()==0) return NULL;\\n        while(n>1){\\n            \\n            for(int i=0;i<n/2;i++)\\n                lists[i] = mergeTwoSorted(lists[i], lists[n-i-1]);\\n            n = (n+1)/2;\\n        }\\n        return lists.front();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    ListNode* mergeTwoSorted(ListNode *l1, ListNode* l2)\\n    {\\n        ListNode* dummy = new ListNode(-1);\\n        ListNode* last = dummy;\\n        \\n        while(l1 and l2)\\n        {\\n            if(l1->val <= l2->val){\\n                last->next = l1;\\n                last = l1;\\n                l1=l1->next;\\n            }\\n            else{\\n                last->next = l2;\\n                last = l2;\\n                l2=l2->next;\\n            }\\n        }\\n        \\n        if(!l1)\\n            last->next = l2;\\n        else\\n            last->next = l1;\\n        return dummy->next;\\n    }\\n    \\n    ListNode* mergeKLists(vector<ListNode*>& lists)\\n    {\\n        int n=lists.size();\\n        if(lists.size()==0) return NULL;\\n        while(n>1){\\n            \\n            for(int i=0;i<n/2;i++)\\n                lists[i] = mergeTwoSorted(lists[i], lists[n-i-1]);\\n            n = (n+1)/2;\\n        }\\n        return lists.front();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        \\n        if(lists.empty()) return NULL;\\n        \\n        // MAX heap\\n        priority_queue<pair<int, ListNode*>> pq; // (value, Node address)\\n        int n=lists.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            ListNode *p = lists[i];\\n            while(p)\\n            {\\n                pq.push({-p->val, p}); // acts as min heap\\n                p = p->next;\\n            }\\n        }\\n                \\n        ListNode* head=NULL;\\n        ListNode* last=NULL;\\n        \\n        if(pq.empty()) return head;\\n        \\n        head=pq.top().second;\\n        last=pq.top().second;\\n        pq.pop();\\n        \\n        \\n        while(!pq.empty())\\n        {\\n            last->next = pq.top().second;\\n            last = pq.top().second;\\n            pq.pop();\\n            \\n        }\\n        last->next=NULL;\\n        \\n        return head;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1032723,
                "title": "python-heap-solution-explained",
                "content": "There are a bunch of different solutions for this problem, let us discuss solution, using **heaps** here. We need to iterate over `k` lists and on each step to choose the minimum element among `k` candidates, think of it as extention of classical merge stage in merge sort. If each time we find this minimum element, using lists, overall complexity will be `O(nk)`, where `n` is total number of elements in all lists. However we can do better: we create heap with the following tuples as elements:\\n1. First value of tuple is our value of nodes, because we want to sort using these values\\n2. Second value of tuple is index in `lists`, form where we choose this element. Why we need this? Because when we will merge this element, we need to go to the next element in the corresponding list.\\n\\nNow, let us discuss main steps of algorithm:\\n1. Create `dummy` node in linked list, which will help us to deal with border cases, such as empty lists and so on.\\n2. `curr` is current element in linked list where are in now.\\n3. Put all starts of `k` linked lists to heap (actually there can be less than `k`, because some of lists can be empty)\\n4. Extract `val, ind` element from our heap: it will be current minumum element, and attach it to the end of constucted merged least so far, move `curr` iterator to the right.\\n5. If we still did not reach the end of current list, move one step to the right in this list and put new candidate to heap.\\n6. Return `dummy.next`.\\n\\n**Complexity**: time complexity is `O(n log k)`, because we have `O(n)` steps, where we put and remove from heap, which have at most `k` elements. Space complexity is `O(n)`: because we need to return newly constructed linked list.\\n\\n```\\nclass Solution:\\n    def mergeKLists(self, lists):\\n        dummy = curr = ListNode(0)\\n        heap = []\\n        for ind, el in enumerate(lists):\\n            if el: heappush(heap, (el.val, ind))\\n                \\n        while heap:\\n            val, ind = heappop(heap)\\n            curr.next = ListNode(val)\\n            curr = curr.next\\n            if lists[ind].next:\\n                lists[ind] = lists[ind].next\\n                heappush(heap, (lists[ind].val, ind))\\n                \\n        return dummy.next\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def mergeKLists(self, lists):\\n        dummy = curr = ListNode(0)\\n        heap = []\\n        for ind, el in enumerate(lists):\\n            if el: heappush(heap, (el.val, ind))\\n                \\n        while heap:\\n            val, ind = heappop(heap)\\n            curr.next = ListNode(val)\\n            curr = curr.next\\n            if lists[ind].next:\\n                lists[ind] = lists[ind].next\\n                heappush(heap, (lists[ind].val, ind))\\n                \\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1032502,
                "title": "python-simple-heap-solution",
                "content": "```html5\\n<b>Time Complexity: O(n&middot;log(m))</b> where n is the total number of elements and m is the number of lists\\n<b>Space Complexity: O(n)</b>\\n```\\n\\nQuestions are welcome.\\n\\n**Approach:**\\n\\n1. Take the first node of each of the linked lists\\nand add it into a heap.  When you add it to the heap\\nadd (node.val, i) where i is the i<sup>th</sup> list.\\n\\n2. Create a dummy node ```head```.  \\n\\n3. Pop the first node from the heap and make it the\\nnext node in the dummy-list.  Remember to add the\\nfirst node from the i<sup>th</sup> linked list into the heap\\nsince we just removed a node from this list from the heap.\\n\\n4. Repeat until the heap is empty.\\n\\n```python\\nclass Solution:\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        head = ListNode(None)\\n        curr = head\\n        h = []\\n        for i in range(len(lists)):\\n            if lists[i]:\\n                heapq.heappush(h, (lists[i].val, i))\\n                lists[i] = lists[i].next\\n        \\n        while h:\\n            val, i = heapq.heappop(h)\\n            curr.next = ListNode(val)\\n            curr = curr.next\\n            if lists[i]:\\n                heapq.heappush(h, (lists[i].val, i))\\n                lists[i] = lists[i].next\\n        \\n        return head.next\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```html5\\n<b>Time Complexity: O(n&middot;log(m))</b> where n is the total number of elements and m is the number of lists\\n<b>Space Complexity: O(n)</b>\\n```\n```head```\n```python\\nclass Solution:\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        head = ListNode(None)\\n        curr = head\\n        h = []\\n        for i in range(len(lists)):\\n            if lists[i]:\\n                heapq.heappush(h, (lists[i].val, i))\\n                lists[i] = lists[i].next\\n        \\n        while h:\\n            val, i = heapq.heappop(h)\\n            curr.next = ListNode(val)\\n            curr = curr.next\\n            if lists[i]:\\n                heapq.heappush(h, (lists[i].val, i))\\n                lists[i] = lists[i].next\\n        \\n        return head.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 114606,
                "title": "extremely-simple-javascript-solution",
                "content": "### Solution\\nIn JS, an array has the shift() and pop() method that allows user to remove the head and tail element from the original array. \\n\\n```javascript\\nfunction mergeLists(a, b) {\\n    const dummy = new ListNode(0);\\n    let temp = dummy;\\n     while (a !== null && b !== null) {\\n         if (a.val < b.val) {\\n             temp.next = a;\\n             a = a.next;\\n         } else {\\n             temp.next = b;\\n             b = b.next;\\n         }\\n         temp = temp.next;\\n     }\\n    if (a !== null) {\\n        temp.next = a;\\n    }\\n    if (b !== null) {\\n        temp.next = b;\\n    }\\n    return dummy.next;\\n}\\n\\nvar mergeKLists = function(lists) {\\n    if (lists.length === 0 ) {\\n        return null;\\n    }\\n    // two two\\n    // priority queue\\n    while (lists.length > 1) {\\n        let a = lists.shift(); // the head will contains the \"less\" length list\\n        let b = lists.shift(); // acturally, we can use the linkedlist to replace it, the while loop will be the while( list.header.next !== null || lists.length > 0)\\n        const h = mergeLists(a, b);\\n        lists.push(h);\\n    }\\n    return lists[0];\\n};\\n```\\nAnother devide and conquer solution\\n```javascript\\nfunction merge (left, right) {\\n    if (!left) {\\n        return right;\\n    } else if (!right) {\\n        return left;\\n    } else if (left.val < right.val){\\n        left.next = merge(left.next, right);\\n        return left;\\n    } else {\\n        right.next = merge(left, right.next);\\n        return right;\\n    }\\n}\\n\\n\\nfunction helper(lists, start, end) {\\n    if (start === end) {\\n        return lists[start];\\n    } else if (start < end) {\\n        const mid = parseInt((start + end) / 2);\\n        const left = helper(lists, start, mid);\\n        const right = helper(lists, mid + 1, end);\\n        return merge(left, right);\\n    } else {\\n        return null;\\n    }\\n    \\n}\\n\\nvar mergeKLists = function(lists) {\\n    return helper(lists, 0, lists.length - 1);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nfunction mergeLists(a, b) {\\n    const dummy = new ListNode(0);\\n    let temp = dummy;\\n     while (a !== null && b !== null) {\\n         if (a.val < b.val) {\\n             temp.next = a;\\n             a = a.next;\\n         } else {\\n             temp.next = b;\\n             b = b.next;\\n         }\\n         temp = temp.next;\\n     }\\n    if (a !== null) {\\n        temp.next = a;\\n    }\\n    if (b !== null) {\\n        temp.next = b;\\n    }\\n    return dummy.next;\\n}\\n\\nvar mergeKLists = function(lists) {\\n    if (lists.length === 0 ) {\\n        return null;\\n    }\\n    // two two\\n    // priority queue\\n    while (lists.length > 1) {\\n        let a = lists.shift(); // the head will contains the \"less\" length list\\n        let b = lists.shift(); // acturally, we can use the linkedlist to replace it, the while loop will be the while( list.header.next !== null || lists.length > 0)\\n        const h = mergeLists(a, b);\\n        lists.push(h);\\n    }\\n    return lists[0];\\n};\\n```\n```javascript\\nfunction merge (left, right) {\\n    if (!left) {\\n        return right;\\n    } else if (!right) {\\n        return left;\\n    } else if (left.val < right.val){\\n        left.next = merge(left.next, right);\\n        return left;\\n    } else {\\n        right.next = merge(left, right.next);\\n        return right;\\n    }\\n}\\n\\n\\nfunction helper(lists, start, end) {\\n    if (start === end) {\\n        return lists[start];\\n    } else if (start < end) {\\n        const mid = parseInt((start + end) / 2);\\n        const left = helper(lists, start, mid);\\n        const right = helper(lists, mid + 1, end);\\n        return merge(left, right);\\n    } else {\\n        return null;\\n    }\\n    \\n}\\n\\nvar mergeKLists = function(lists) {\\n    return helper(lists, 0, lists.length - 1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3286070,
                "title": "day-71-divide-and-conquer-easiest-beginner-friendly-sol",
                "content": "**NOTE 1 - PLEASE READ INTUITION AND APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n**NOTE 2 - BEFORE SOLVING THIS PROBELM, I WILL HIGHLY RECOMMEND YOU TO SOLVE BELOW PROBLEM FOR BETTER UNDERSTANDING.**\\n**21. Merge Two Sorted Lists :** https://leetcode.com/problems/merge-two-sorted-lists/description/ \\n**SOLUTION :** https://leetcode.com/problems/merge-two-sorted-lists/solutions/3288537/o-m-n-time-and-o-1-space-easiest-beginner-friendly-solution/\\n\\n# Intuition of this Problem:\\n**This solution uses the merge sort algorithm to merge all the linked lists in the input vector into a single sorted linked list. The merge sort algorithm works by recursively dividing the input into halves, sorting each half separately, and then merging the two sorted halves into a single sorted output.**\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach for this Problem:\\n1. Define a function merge that takes two pointers to linked lists as input and merges them in a sorted manner.\\n    - a. Create a dummy node with a value of -1 and a temporary node pointing to it.\\n    - b. Compare the first node of the left and right linked lists, and append the smaller one to the temporary node.\\n    - c. Continue this process until either of the lists becomes empty.\\n    - d. Append the remaining nodes of the non-empty list to the temporary node.\\n    - e. Return the next node of the dummy node.\\n\\n1. Define a function mergeSort that takes three arguments - a vector of linked lists, a starting index, and an ending index. It performs merge sort on the linked lists from the starting index to the ending index.\\n    - a. If the starting index is equal to the ending index, return the linked list at that index.\\n    - b. Calculate the mid index and call mergeSort recursively on the left and right halves of the vector.\\n    - c. Merge the two sorted linked lists obtained from the recursive calls using the merge function and return the result.\\n\\n1. Define the main function mergeKLists that takes the vector of linked lists as input and returns a single sorted linked list.\\n    - a. If the input vector is empty, return a null pointer.\\n    - b. Call the mergeSort function on the entire input vector, from index 0 to index k-1, where k is the size of the input vector.\\n    - c. Return the merged linked list obtained from the mergeSort function call.\\n1. End of algorithm.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Humble Request:\\n- If my solution is helpful to you then please **UPVOTE** my solution, your **UPVOTE** motivates me to post such kind of solution.\\n- Please let me know in comments if there is need to do any improvement in my approach, code....anything.\\n- **Let\\'s connect on** https://www.linkedin.com/in/abhinash-singh-1b851b188\\n\\n![57jfh9.jpg](https://assets.leetcode.com/users/images/c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg)\\n\\n# Code:\\n```C++ []\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* merge(ListNode *left, ListNode *right) {\\n        ListNode *dummy = new ListNode(-1);\\n        ListNode *temp = dummy;\\n        while (left != nullptr && right != nullptr) {\\n            if (left -> val < right -> val) {\\n                temp -> next = left;\\n                temp = temp -> next;\\n                left = left -> next;\\n            }\\n            else {\\n                temp -> next = right;\\n                temp = temp -> next;\\n                right = right -> next;\\n            }\\n        }\\n        while (left != nullptr) {\\n            temp -> next = left;\\n            temp = temp -> next;\\n            left = left -> next;\\n        }\\n        while (right != nullptr) {\\n            temp -> next = right;\\n            temp = temp -> next;\\n            right = right -> next;\\n        }\\n        return dummy -> next;\\n    }\\n    ListNode* mergeSort(vector<ListNode*>& lists, int start, int end) {\\n        if (start == end) \\n            return lists[start];\\n        int mid = start + (end - start) / 2;\\n        ListNode *left = mergeSort(lists, start, mid);\\n        ListNode *right = mergeSort(lists, mid + 1, end);\\n        return merge(left, right);\\n    }\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if (lists.size() == 0)\\n            return nullptr;\\n        return mergeSort(lists, 0, lists.size() - 1);\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public ListNode merge(ListNode left, ListNode right) {\\n        ListNode dummy = new ListNode(-1);\\n        ListNode temp = dummy;\\n        while (left != null && right != null) {\\n            if (left.val < right.val) {\\n                temp.next = left;\\n                temp = temp.next;\\n                left = left.next;\\n            } else {\\n                temp.next = right;\\n                temp = temp.next;\\n                right = right.next;\\n            }\\n        }\\n        while (left != null) {\\n            temp.next = left;\\n            temp = temp.next;\\n            left = left.next;\\n        }\\n        while (right != null) {\\n            temp.next = right;\\n            temp = temp.next;\\n            right = right.next;\\n        }\\n        return dummy.next;\\n    }\\n    \\n    public ListNode mergeSort(List<ListNode> lists, int start, int end) {\\n        if (start == end) {\\n            return lists.get(start);\\n        }\\n        int mid = start + (end - start) / 2;\\n        ListNode left = mergeSort(lists, start, mid);\\n        ListNode right = mergeSort(lists, mid + 1, end);\\n        return merge(left, right);\\n    }\\n    \\n    public ListNode mergeKLists(List<ListNode> lists) {\\n        if (lists.size() == 0) {\\n            return null;\\n        }\\n        return mergeSort(lists, 0, lists.size() - 1);\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def merge(self, left: ListNode, right: ListNode) -> ListNode:\\n        dummy = ListNode(-1)\\n        temp = dummy\\n        while left and right:\\n            if left.val < right.val:\\n                temp.next = left\\n                temp = temp.next\\n                left = left.next\\n            else:\\n                temp.next = right\\n                temp = temp.next\\n                right = right.next\\n        while left:\\n            temp.next = left\\n            temp = temp.next\\n            left = left.next\\n        while right:\\n            temp.next = right\\n            temp = temp.next\\n            right = right.next\\n        return dummy.next\\n    \\n    def mergeSort(self, lists: List[ListNode], start: int, end: int) -> ListNode:\\n        if start == end:\\n            return lists[start]\\n        mid = start + (end - start) // 2\\n        left = self.mergeSort(lists, start, mid)\\n        right = self.mergeSort(lists, mid + 1, end)\\n        return self.merge(left, right)\\n    \\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        if not lists:\\n            return None\\n        return self.mergeSort(lists, 0, len(lists) - 1)\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity: **O(N log k)**, where N is the total number of nodes in all the linked lists, and k is the number of linked lists in the input vector. This is because the merge sort algorithm requires O(N log N) time to sort N items, and in this case, N is the total number of nodes in all the linked lists. The number of levels in the recursion tree of the merge sort algorithm is log k, where k is the number of linked lists in the input vector. Each level of the recursion tree requires O(N) time to merge the sorted lists, so the total time complexity is O(N log k).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(log k)**, which is the maximum depth of the recursion tree of the merge sort algorithm. The space used by each recursive call is constant, so the total space used by the algorithm is proportional to the maximum depth of the recursion tree. Since the depth of the tree is log k, the space complexity of the algorithm is O(log k).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Divide and Conquer",
                    "Merge Sort"
                ],
                "code": "```C++ []\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* merge(ListNode *left, ListNode *right) {\\n        ListNode *dummy = new ListNode(-1);\\n        ListNode *temp = dummy;\\n        while (left != nullptr && right != nullptr) {\\n            if (left -> val < right -> val) {\\n                temp -> next = left;\\n                temp = temp -> next;\\n                left = left -> next;\\n            }\\n            else {\\n                temp -> next = right;\\n                temp = temp -> next;\\n                right = right -> next;\\n            }\\n        }\\n        while (left != nullptr) {\\n            temp -> next = left;\\n            temp = temp -> next;\\n            left = left -> next;\\n        }\\n        while (right != nullptr) {\\n            temp -> next = right;\\n            temp = temp -> next;\\n            right = right -> next;\\n        }\\n        return dummy -> next;\\n    }\\n    ListNode* mergeSort(vector<ListNode*>& lists, int start, int end) {\\n        if (start == end) \\n            return lists[start];\\n        int mid = start + (end - start) / 2;\\n        ListNode *left = mergeSort(lists, start, mid);\\n        ListNode *right = mergeSort(lists, mid + 1, end);\\n        return merge(left, right);\\n    }\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if (lists.size() == 0)\\n            return nullptr;\\n        return mergeSort(lists, 0, lists.size() - 1);\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public ListNode merge(ListNode left, ListNode right) {\\n        ListNode dummy = new ListNode(-1);\\n        ListNode temp = dummy;\\n        while (left != null && right != null) {\\n            if (left.val < right.val) {\\n                temp.next = left;\\n                temp = temp.next;\\n                left = left.next;\\n            } else {\\n                temp.next = right;\\n                temp = temp.next;\\n                right = right.next;\\n            }\\n        }\\n        while (left != null) {\\n            temp.next = left;\\n            temp = temp.next;\\n            left = left.next;\\n        }\\n        while (right != null) {\\n            temp.next = right;\\n            temp = temp.next;\\n            right = right.next;\\n        }\\n        return dummy.next;\\n    }\\n    \\n    public ListNode mergeSort(List<ListNode> lists, int start, int end) {\\n        if (start == end) {\\n            return lists.get(start);\\n        }\\n        int mid = start + (end - start) / 2;\\n        ListNode left = mergeSort(lists, start, mid);\\n        ListNode right = mergeSort(lists, mid + 1, end);\\n        return merge(left, right);\\n    }\\n    \\n    public ListNode mergeKLists(List<ListNode> lists) {\\n        if (lists.size() == 0) {\\n            return null;\\n        }\\n        return mergeSort(lists, 0, lists.size() - 1);\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def merge(self, left: ListNode, right: ListNode) -> ListNode:\\n        dummy = ListNode(-1)\\n        temp = dummy\\n        while left and right:\\n            if left.val < right.val:\\n                temp.next = left\\n                temp = temp.next\\n                left = left.next\\n            else:\\n                temp.next = right\\n                temp = temp.next\\n                right = right.next\\n        while left:\\n            temp.next = left\\n            temp = temp.next\\n            left = left.next\\n        while right:\\n            temp.next = right\\n            temp = temp.next\\n            right = right.next\\n        return dummy.next\\n    \\n    def mergeSort(self, lists: List[ListNode], start: int, end: int) -> ListNode:\\n        if start == end:\\n            return lists[start]\\n        mid = start + (end - start) // 2\\n        left = self.mergeSort(lists, start, mid)\\n        right = self.mergeSort(lists, mid + 1, end)\\n        return self.merge(left, right)\\n    \\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        if not lists:\\n            return None\\n        return self.mergeSort(lists, 0, len(lists) - 1)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 10809,
                "title": "13-lines-in-java",
                "content": "Hi guys!\\n\\nThe approach is standard - PriorityQueue, but I noticed that solutions presented before are kind of a bit long. So that's the concise version. :)\\n\\nHope it helps!\\n\\n----------\\n\\n    public class Solution {\\n        public ListNode mergeKLists(List<ListNode> lists) {\\n            Queue<ListNode> heap = new PriorityQueue(new Comparator<ListNode>(){\\n                @Override public int compare(ListNode l1, ListNode l2) { \\n                    return l1.val - l2.val; \\n                }\\n            });\\n            ListNode head = new ListNode(0), tail = head;\\n            for (ListNode node : lists) if (node != null) heap.offer(node);\\n            while (!heap.isEmpty()) {\\n                tail.next = heap.poll();\\n                tail = tail.next;\\n                if (tail.next != null) heap.offer(tail.next);\\n            }\\n            return head.next;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public ListNode mergeKLists(List<ListNode> lists) {\\n            Queue<ListNode> heap = new PriorityQueue(new Comparator<ListNode>(){\\n                @Override public int compare(ListNode l1, ListNode l2) { \\n                    return l1.val - l2.val; \\n                }",
                "codeTag": "Java"
            },
            {
                "id": 10543,
                "title": "brief-c-solution-with-priority-queue",
                "content": "We just need to define a comparison struct for ListNodes, then managing the priority\\\\_queue is quite straightforward. After filling the priority\\\\_queue, if it is non-empty, we set the head and tail. Then we repeatedly pop the top off the queue and append that to the tail. If the next node is not null, we push it onto the queue.\\n\\n\\n\\n    class Solution {\\n        struct compare {\\n            bool operator()(const ListNode* l, const ListNode* r) {\\n                return l->val > r->val;\\n            }\\n        };\\n        \\n    public:\\n        ListNode *mergeKLists(vector<ListNode *> &lists) {\\n            priority_queue<ListNode *, vector<ListNode *>, compare> q;\\n            for (auto l : lists) {\\n                if (l) {\\n                    q.push(l);\\n                }\\n            }\\n            \\n            if (q.empty()) {\\n                return NULL;\\n            }\\n            \\n            ListNode* result = q.top();\\n            q.pop();\\n            if (result->next) {\\n                q.push(result->next);\\n            }\\n\\n            ListNode* tail = result;            \\n            while (!q.empty()) {\\n                tail->next = q.top();\\n                q.pop();\\n                tail = tail->next;\\n                if (tail->next) {\\n                    q.push(tail->next);\\n                }\\n            }\\n            \\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n        struct compare {\\n            bool operator()(const ListNode* l, const ListNode* r) {\\n                return l->val > r->val;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1745539,
                "title": "python3-priority-queue-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nThe main challenge in the problem is the fact that the number of lists `k` can be huge and iterating over list heads every time attaching a new node to the result would be time-consuming. Essentially what is important to know on every merging step is what is the smallest node among all list heads. We can utilize the priority queue to fast access the current smallest node. \\n\\nFirst, we form the initial heap with tuples containing val and node itself. Notice that in Python implementation of the heap, the first element of the tuple is considered as a priority. In case the heap already has an element with the same priority, the Python compares the next element of the tuple. That is why we need index `i` in the second place.\\n\\nThen we run a cycle until the heap is empty. On every step, we pop out the smallest node and attach it to the result. Right away we push to the heap the next node.\\n\\nTime: **O(k * n * log(k))** - scan and manipulation with heap\\nSpace: **O(k)** - for the heap\\n\\nRuntime: 96 ms, faster than **93.66%** of Python3 online submissions for Merge k Sorted Lists.\\nMemory Usage: 17.9 MB, less than **61.96%** of Python3 online submissions for Merge k Sorted Lists.\\n\\n```\\ndef mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n\\theap, res = [], ListNode()\\n\\tfor i, list in enumerate(lists):\\n\\t\\tif list: \\n\\t\\t\\theappush(heap, (list.val, i, list))\\n\\n\\tcur = res\\n\\twhile heap:\\n\\t\\t_, i, list = heappop(heap)\\n\\t\\tif list.next:\\n\\t\\t\\theappush(heap, (list.next.val, i, list.next))\\n\\n\\t\\tcur.next, cur = list, list\\n\\n\\treturn res.next\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ndef mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n\\theap, res = [], ListNode()\\n\\tfor i, list in enumerate(lists):\\n\\t\\tif list: \\n\\t\\t\\theappush(heap, (list.val, i, list))\\n\\n\\tcur = res\\n\\twhile heap:\\n\\t\\t_, i, list = heappop(heap)\\n\\t\\tif list.next:\\n\\t\\t\\theappush(heap, (list.next.val, i, list.next))\\n\\n\\t\\tcur.next, cur = list, list\\n\\n\\treturn res.next\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 611161,
                "title": "fast-c-solution-95-with-comments-and-explanation-uses-minheap",
                "content": "The implementation beats 85% in terms of speed.\\nComplexity: **nlog(k)**\\n```\\nclass Solution\\n{\\npublic:\\n    ListNode *mergeKLists(vector<ListNode *> &lists)\\n    {\\n        if (lists.empty() || lists.size() == 0)\\n        {\\n            return NULL;\\n        }\\n\\n        // This comparator will be used to build MIN HEAP.\\n        // We use a LAMBDA to define the comparator.\\n        auto comp = [&](ListNode *a, ListNode *b) {\\n            return a->val > b->val;\\n        };\\n\\n        // This priority queue is our MIN HEAP\\n        priority_queue<ListNode *, vector<ListNode *>, decltype(comp)> pq(comp);\\n\\n        /*\\n        * We iterate the list of LinkedLists and add the head\\n        * of every list to the heap (the heap becomes of size k)\\n        */\\n        for (int i = 0; i < lists.size(); i++)\\n        {\\n            if (lists[i])\\n            {\\n                pq.push(lists[i]);\\n            }\\n        }\\n\\n        ListNode dummyHead(0);\\n        ListNode *tail = &dummyHead;\\n\\n        // Simply start popping the nodes from the heap and keep adding them to the list;\\n        while (!pq.empty())\\n        {\\n            // Pop the top element and store it in temp\\n            auto temp = pq.top();\\n            pq.pop();\\n\\n            // Add it to the list\\n            tail->next = temp;\\n            // Move the tail to the newly added element\\n            tail = tail->next;\\n\\n            // if there are more nodes attached to this node in the list\\n            // Push the next node of the list into the heap\\n            if (temp->next)\\n            {\\n                pq.push(temp->next);\\n            }\\n        }\\n\\n        // Make sure you set the next pointer of the last added node to NULL\\n        tail->next = NULL;\\n\\n        // We used the dummyHead to keep track of the start of the list.\\n        return dummyHead.next;\\n    }\\n};\\n```\\n\\nWe can think of an even faster solution though.\\nWe can store the values of all the nodes in an **ordered map**, with the second value as the frequency and after going over all the nodes of all the linked lists, simply iterate over that map and keep creating new ListNodes for every value (depending on the frequency).\\nRuns faster than 95% submissions\\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        // Create an ordered map\\n        map<int, int> nodes;\\n        \\n        // Add all nodes of all the LinkedLists to the map with\\n        // with the ListNode->val as the key & that value\\'s frequency as the mapped value\\n        for(int i = 0; i < lists.size(); ++i){\\n            auto node = lists[i];\\n            while(node){\\n                int temp = node->val;\\n                nodes[temp]++;\\n                node = node->next;\\n            }\\n        }\\n        \\n        ListNode dummyHead(0);\\n        ListNode* tail = &dummyHead;\\n        \\n        for(auto it: nodes){\\n            while(it.second != 0){\\n                ListNode* newNode= new ListNode(it.first);\\n                tail->next = newNode;\\n                tail = tail->next;\\n                it.second--;\\n            }\\n        }\\n        return dummyHead.next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    ListNode *mergeKLists(vector<ListNode *> &lists)\\n    {\\n        if (lists.empty() || lists.size() == 0)\\n        {\\n            return NULL;\\n        }\\n\\n        // This comparator will be used to build MIN HEAP.\\n        // We use a LAMBDA to define the comparator.\\n        auto comp = [&](ListNode *a, ListNode *b) {\\n            return a->val > b->val;\\n        };\\n\\n        // This priority queue is our MIN HEAP\\n        priority_queue<ListNode *, vector<ListNode *>, decltype(comp)> pq(comp);\\n\\n        /*\\n        * We iterate the list of LinkedLists and add the head\\n        * of every list to the heap (the heap becomes of size k)\\n        */\\n        for (int i = 0; i < lists.size(); i++)\\n        {\\n            if (lists[i])\\n            {\\n                pq.push(lists[i]);\\n            }\\n        }\\n\\n        ListNode dummyHead(0);\\n        ListNode *tail = &dummyHead;\\n\\n        // Simply start popping the nodes from the heap and keep adding them to the list;\\n        while (!pq.empty())\\n        {\\n            // Pop the top element and store it in temp\\n            auto temp = pq.top();\\n            pq.pop();\\n\\n            // Add it to the list\\n            tail->next = temp;\\n            // Move the tail to the newly added element\\n            tail = tail->next;\\n\\n            // if there are more nodes attached to this node in the list\\n            // Push the next node of the list into the heap\\n            if (temp->next)\\n            {\\n                pq.push(temp->next);\\n            }\\n        }\\n\\n        // Make sure you set the next pointer of the last added node to NULL\\n        tail->next = NULL;\\n\\n        // We used the dummyHead to keep track of the start of the list.\\n        return dummyHead.next;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        // Create an ordered map\\n        map<int, int> nodes;\\n        \\n        // Add all nodes of all the LinkedLists to the map with\\n        // with the ListNode->val as the key & that value\\'s frequency as the mapped value\\n        for(int i = 0; i < lists.size(); ++i){\\n            auto node = lists[i];\\n            while(node){\\n                int temp = node->val;\\n                nodes[temp]++;\\n                node = node->next;\\n            }\\n        }\\n        \\n        ListNode dummyHead(0);\\n        ListNode* tail = &dummyHead;\\n        \\n        for(auto it: nodes){\\n            while(it.second != 0){\\n                ListNode* newNode= new ListNode(it.first);\\n                tail->next = newNode;\\n                tail = tail->next;\\n                it.second--;\\n            }\\n        }\\n        return dummyHead.next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 327596,
                "title": "javascript-3-solutions",
                "content": "1\\uFE0F\\u20E3push to array and sort\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode[]} lists\\n * @return {ListNode}\\n */\\nvar mergeKLists_sort = function(lists) {\\n    if(!lists || !lists.length) return null;\\n    let arr = [], res = new ListNode(-1);\\n    \\n    lists.forEach(list => {\\n        let cur = list;\\n        while(cur) {\\n            arr.push(cur.val);\\n            cur = cur.next;\\n        }\\n    });\\n    \\n    let cur = res;\\n    arr.sort((a,b) => a - b)\\n        .forEach(n => {\\n        let temp = new ListNode(n);\\n        cur.next = temp;\\n        cur = cur.next;\\n    });\\n    return res.next;\\n};\\n```\\n\\n2\\uFE0F\\u20E3compare one by one\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode[]} lists\\n * @return {ListNode}\\n */\\nvar mergeKLists_compare_one_by_one = function(lists) {\\n    if(!lists || !lists.length) return null;\\n    const findMinNode = (lists = lists) => {\\n        let index = -1, \\n            min = Number.MAX_SAFE_INTEGER;\\n        for(let i = 0; i < lists.length; i++) {\\n            if(!lists[i]) continue;\\n            if(lists[i].val <= min) {\\n                min = lists[i].val;\\n                index = i;\\n            }\\n        }\\n        \\n        let resNode = null;\\n        if(index !== -1) {\\n            resNode = lists[index];\\n            lists[index] = lists[index].next;\\n        }\\n        return resNode;\\n    };\\n    \\n    let res = new ListNode(-1),\\n        cur = res,\\n        temp = findMinNode(lists);\\n    while(temp) {\\n        cur.next = temp;\\n        cur = cur.next;\\n        temp = findMinNode(lists);\\n    }\\n    return res.next;\\n}\\n```\\n\\n\\n3\\uFE0F\\u20E3use priority queue (min heap)\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode[]} lists\\n * @return {ListNode}\\n */\\nvar mergeKLists_priority_queue = function(lists) {\\n    let queue = new PriorityQueue();\\n    lists.forEach(list => {\\n        if(list) queue.enqueue(list, list.val)\\n    });\\n\\n    let res = new ListNode(-1);\\n    let cur = res;\\n    while(!queue.isEmpty()) {\\n        cur.next = queue.dequeue();\\n        cur = cur.next;\\n        if(cur.next) queue.enqueue(cur.next, cur.next.val);\\n    }\\n    return res.next;\\n}\\n\\nclass Node {\\n\\tconstructor(val, priority) {\\n\\t\\tthis.val = val;\\n\\t\\tthis.priority = priority;\\n\\t}\\n}\\n\\nclass PriorityQueue {\\n\\tconstructor() {\\n\\t\\tthis.values = [];\\n\\t}\\n\\n\\tenqueue(val, priority) {\\n\\t\\tlet node = new Node(val, priority);\\n\\t\\tthis.values.push(node);\\n\\t\\tthis.bubbleUp();\\n\\t}\\n\\n\\tdequeue() {\\n\\t\\tlet max = this.values[0];\\n\\t\\tlet end = this.values.pop();\\n\\t\\tif(this.values.length) {\\n\\t\\t\\tthis.values[0] = end;\\n\\t\\t\\tthis.bubbleDown();\\n\\t\\t}\\n\\t\\treturn max.val;\\n\\t}\\n    \\n    isEmpty() {\\n        return !this.values.length;\\n    }\\n    \\n    bubbleUp(index = this.values.length - 1) {\\n\\t\\tif(index <= 0) return;\\n\\t\\tlet parentIndex = Math.floor((index - 1) / 2);\\n\\t\\tif(this.values[index].priority <= this.values[parentIndex].priority) {\\n\\t\\t\\t[this.values[index], this.values[parentIndex]] = [this.values[parentIndex], this.values[index]];\\n\\t\\t\\tthis.bubbleUp(parentIndex);\\n\\t\\t}\\n\\t}\\n\\t\\n\\tbubbleDown(index = 0, swapIndex = null) {\\n\\t\\tlet leftIndex = index * 2 + 1,\\n\\t\\t\\trightIndex = index * 2 + 2,\\n\\t\\t\\tlength = this.values.length;\\n\\n\\t\\tif(leftIndex < length) {\\n\\t\\t\\tif(this.values[leftIndex].priority <= this.values[index].priority) {\\n\\t\\t\\t\\tswapIndex = leftIndex;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif(rightIndex < length) {\\n\\t\\t\\tif((swapIndex === null && this.values[rightIndex].priority <= this.values[index].priority) || (swapIndex !== null && this.values[rightIndex].priority <= this.values[leftIndex].priority)) {\\n\\t\\t\\t\\tswapIndex = rightIndex;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif(swapIndex !== null) {\\n\\t\\t\\t[this.values[index], this.values[swapIndex]] = [this.values[swapIndex], this.values[index]];\\n\\t\\t\\tthis.bubbleDown(swapIndex, null);\\n\\t\\t}\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode[]} lists\\n * @return {ListNode}\\n */\\nvar mergeKLists_sort = function(lists) {\\n    if(!lists || !lists.length) return null;\\n    let arr = [], res = new ListNode(-1);\\n    \\n    lists.forEach(list => {\\n        let cur = list;\\n        while(cur) {\\n            arr.push(cur.val);\\n            cur = cur.next;\\n        }\\n    });\\n    \\n    let cur = res;\\n    arr.sort((a,b) => a - b)\\n        .forEach(n => {\\n        let temp = new ListNode(n);\\n        cur.next = temp;\\n        cur = cur.next;\\n    });\\n    return res.next;\\n};\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode[]} lists\\n * @return {ListNode}\\n */\\nvar mergeKLists_compare_one_by_one = function(lists) {\\n    if(!lists || !lists.length) return null;\\n    const findMinNode = (lists = lists) => {\\n        let index = -1, \\n            min = Number.MAX_SAFE_INTEGER;\\n        for(let i = 0; i < lists.length; i++) {\\n            if(!lists[i]) continue;\\n            if(lists[i].val <= min) {\\n                min = lists[i].val;\\n                index = i;\\n            }\\n        }\\n        \\n        let resNode = null;\\n        if(index !== -1) {\\n            resNode = lists[index];\\n            lists[index] = lists[index].next;\\n        }\\n        return resNode;\\n    };\\n    \\n    let res = new ListNode(-1),\\n        cur = res,\\n        temp = findMinNode(lists);\\n    while(temp) {\\n        cur.next = temp;\\n        cur = cur.next;\\n        temp = findMinNode(lists);\\n    }\\n    return res.next;\\n}\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode[]} lists\\n * @return {ListNode}\\n */\\nvar mergeKLists_priority_queue = function(lists) {\\n    let queue = new PriorityQueue();\\n    lists.forEach(list => {\\n        if(list) queue.enqueue(list, list.val)\\n    });\\n\\n    let res = new ListNode(-1);\\n    let cur = res;\\n    while(!queue.isEmpty()) {\\n        cur.next = queue.dequeue();\\n        cur = cur.next;\\n        if(cur.next) queue.enqueue(cur.next, cur.next.val);\\n    }\\n    return res.next;\\n}\\n\\nclass Node {\\n\\tconstructor(val, priority) {\\n\\t\\tthis.val = val;\\n\\t\\tthis.priority = priority;\\n\\t}\\n}\\n\\nclass PriorityQueue {\\n\\tconstructor() {\\n\\t\\tthis.values = [];\\n\\t}\\n\\n\\tenqueue(val, priority) {\\n\\t\\tlet node = new Node(val, priority);\\n\\t\\tthis.values.push(node);\\n\\t\\tthis.bubbleUp();\\n\\t}\\n\\n\\tdequeue() {\\n\\t\\tlet max = this.values[0];\\n\\t\\tlet end = this.values.pop();\\n\\t\\tif(this.values.length) {\\n\\t\\t\\tthis.values[0] = end;\\n\\t\\t\\tthis.bubbleDown();\\n\\t\\t}\\n\\t\\treturn max.val;\\n\\t}\\n    \\n    isEmpty() {\\n        return !this.values.length;\\n    }\\n    \\n    bubbleUp(index = this.values.length - 1) {\\n\\t\\tif(index <= 0) return;\\n\\t\\tlet parentIndex = Math.floor((index - 1) / 2);\\n\\t\\tif(this.values[index].priority <= this.values[parentIndex].priority) {\\n\\t\\t\\t[this.values[index], this.values[parentIndex]] = [this.values[parentIndex], this.values[index]];\\n\\t\\t\\tthis.bubbleUp(parentIndex);\\n\\t\\t}\\n\\t}\\n\\t\\n\\tbubbleDown(index = 0, swapIndex = null) {\\n\\t\\tlet leftIndex = index * 2 + 1,\\n\\t\\t\\trightIndex = index * 2 + 2,\\n\\t\\t\\tlength = this.values.length;\\n\\n\\t\\tif(leftIndex < length) {\\n\\t\\t\\tif(this.values[leftIndex].priority <= this.values[index].priority) {\\n\\t\\t\\t\\tswapIndex = leftIndex;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif(rightIndex < length) {\\n\\t\\t\\tif((swapIndex === null && this.values[rightIndex].priority <= this.values[index].priority) || (swapIndex !== null && this.values[rightIndex].priority <= this.values[leftIndex].priority)) {\\n\\t\\t\\t\\tswapIndex = rightIndex;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif(swapIndex !== null) {\\n\\t\\t\\t[this.values[index], this.values[swapIndex]] = [this.values[swapIndex], this.values[index]];\\n\\t\\t\\tthis.bubbleDown(swapIndex, null);\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286803,
                "title": "python3-and-c-95-ms-beats-95-60-and-easy",
                "content": "# Please UPVOTE\\uD83D\\uDE0A\\n![image.png](https://assets.leetcode.com/users/images/71bb105c-bbdb-4f07-9d29-893ea49c0174_1678597927.929296.png)\\n\\n\\n# Python3\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        v=[]\\n        for i in lists:\\n            x=i\\n            while x:\\n                v+=[x.val]\\n                x=x.next\\n        v=sorted(v,reverse=True)\\n        ans=None\\n        for i in v:\\n            ans=ListNode(i,ans)\\n        return ans\\n```\\n# C++\\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        vector<int>v;\\n        for(int i=0;i<lists.size();i++){\\n            while(lists[i]){\\n                v.push_back(lists[i]->val);\\n                lists[i]=lists[i]->next;\\n            }\\n        }\\n        sort(rbegin(v),rend(v));\\n        ListNode* ans=nullptr;\\n        for(int i=0;i<v.size();i++){\\n            ans=new ListNode(v[i],ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python3",
                    "Sort"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        v=[]\\n        for i in lists:\\n            x=i\\n            while x:\\n                v+=[x.val]\\n                x=x.next\\n        v=sorted(v,reverse=True)\\n        ans=None\\n        for i in v:\\n            ans=ListNode(i,ans)\\n        return ans\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        vector<int>v;\\n        for(int i=0;i<lists.size();i++){\\n            while(lists[i]){\\n                v.push_back(lists[i]->val);\\n                lists[i]=lists[i]->next;\\n            }\\n        }\\n        sort(rbegin(v),rend(v));\\n        ListNode* ans=nullptr;\\n        for(int i=0;i<v.size();i++){\\n            ans=new ListNode(v[i],ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1032551,
                "title": "c-3-sols-brute-force-priority-queue-divide-and-conquer-method",
                "content": "Solution 1:\\n**Brute Force**\\n```\\nclass Solution {\\npublic:\\n    \\n    ListNode* merge(ListNode* a,ListNode* b) {\\n        if(!a) return b;\\n        if(!b) return a;\\n        ListNode* temp=NULL;\\n        if(a->val<=b->val) \\n        {\\n            temp =a;\\n            temp->next = merge(a->next,b);\\n        }\\n        else \\n        {\\n            temp = b;\\n            temp->next = merge(a,b->next);\\n        }\\n        return temp;        \\n    }\\n    \\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if(lists.size()==0) return NULL;\\n        if(lists.size()==1) return lists[0];\\n        ListNode* ans=NULL;\\n        for(auto l : lists) \\n        {\\n            ans = merge(ans,l);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nSolution 2:\\n**Priority queue**\\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if(lists.size()==0) return NULL;\\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        \\n        for(int i=0;i<lists.size();i++)\\n        {\\n            ListNode* head = lists[i];\\n            while(head!=NULL)\\n            {\\n                pq.push(head->val);\\n                head = head->next;\\n            }\\n        }\\n        ListNode* start = NULL;\\n        ListNode* end = NULL;\\n        while(!pq.empty()) {\\n            if(start==NULL)\\n            {\\n                start = new ListNode(pq.top());\\n                end = start;\\n                pq.pop();\\n            }\\n            else{\\n                end->next = new ListNode(pq.top());\\n                pq.pop();\\n                end = end->next;\\n            }\\n        }\\n            return start;\\n    }\\n};\\n```\\nSolution 3:\\n**Divide and Conquer**\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    ListNode* mergesort(ListNode* a  , ListNode* b) {\\n        if(!a) \\n            return b;\\n        if(!b)\\n            return a;\\n        ListNode* ans=NULL;\\n        if(a->val<=b->val)\\n        {\\n            ans=a;\\n            ans->next = mergesort(a->next,b);\\n        }\\n        else\\n        {\\n            ans=b;\\n            ans->next = mergesort(a,b->next);\\n        }\\n        return ans;\\n    }\\n    \\n    ListNode* mergeK(vector<ListNode*>& lists,int k) {\\n        while(k!=0) {\\n            int i = 0,j = k;\\n            while(i<j) {\\n                lists[i]=mergesort(lists[i],lists[j]);\\n                i++;\\n                j--;\\n                if(i>=j) \\n                    k=j;\\n            }\\n        }\\n        return lists[0];\\n    }\\n    \\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if(lists.size()==1)\\n            return lists[0];\\n        if(lists.size()==0) \\n            return NULL;\\n        ListNode*newhead = mergeK(lists,lists.size()-1);\\n        return newhead;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Divide and Conquer",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    ListNode* merge(ListNode* a,ListNode* b) {\\n        if(!a) return b;\\n        if(!b) return a;\\n        ListNode* temp=NULL;\\n        if(a->val<=b->val) \\n        {\\n            temp =a;\\n            temp->next = merge(a->next,b);\\n        }\\n        else \\n        {\\n            temp = b;\\n            temp->next = merge(a,b->next);\\n        }\\n        return temp;        \\n    }\\n    \\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if(lists.size()==0) return NULL;\\n        if(lists.size()==1) return lists[0];\\n        ListNode* ans=NULL;\\n        for(auto l : lists) \\n        {\\n            ans = merge(ans,l);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if(lists.size()==0) return NULL;\\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        \\n        for(int i=0;i<lists.size();i++)\\n        {\\n            ListNode* head = lists[i];\\n            while(head!=NULL)\\n            {\\n                pq.push(head->val);\\n                head = head->next;\\n            }\\n        }\\n        ListNode* start = NULL;\\n        ListNode* end = NULL;\\n        while(!pq.empty()) {\\n            if(start==NULL)\\n            {\\n                start = new ListNode(pq.top());\\n                end = start;\\n                pq.pop();\\n            }\\n            else{\\n                end->next = new ListNode(pq.top());\\n                pq.pop();\\n                end = end->next;\\n            }\\n        }\\n            return start;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    ListNode* mergesort(ListNode* a  , ListNode* b) {\\n        if(!a) \\n            return b;\\n        if(!b)\\n            return a;\\n        ListNode* ans=NULL;\\n        if(a->val<=b->val)\\n        {\\n            ans=a;\\n            ans->next = mergesort(a->next,b);\\n        }\\n        else\\n        {\\n            ans=b;\\n            ans->next = mergesort(a,b->next);\\n        }\\n        return ans;\\n    }\\n    \\n    ListNode* mergeK(vector<ListNode*>& lists,int k) {\\n        while(k!=0) {\\n            int i = 0,j = k;\\n            while(i<j) {\\n                lists[i]=mergesort(lists[i],lists[j]);\\n                i++;\\n                j--;\\n                if(i>=j) \\n                    k=j;\\n            }\\n        }\\n        return lists[0];\\n    }\\n    \\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if(lists.size()==1)\\n            return lists[0];\\n        if(lists.size()==0) \\n            return NULL;\\n        ListNode*newhead = mergeK(lists,lists.size()-1);\\n        return newhead;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1030987,
                "title": "javascript-minpriorityqueue",
                "content": "Following Approach 3 from the solution set\\n\\nThis uses `MinPriorityQueue` class from the `datastructures-js` library that is available in the LeetCode runtime. I would argue that since these datastructures are available in other languages I would not expect to have to write my own implementation in an interview and it should be sufficient to \"stub\" a class as long as I can explain the underlying data structure\\n\\n```\\nconst mergeKLists = function(lists) {\\n  const queue = new MinPriorityQueue({ priority: x => x.val })\\n\\n  for (const head of lists) {\\n    if (head) {\\n      queue.enqueue(head)\\n    }\\n  }\\n\\n  let result = new ListNode()\\n  const head = result\\n\\n  while (!queue.isEmpty()) {\\n    const { val, next } = queue.dequeue().element\\n\\n    result.next = new ListNode(val)\\n    result = result.next\\n\\n    if (next) {\\n      queue.enqueue(next)\\n    }\\n  }\\n\\n  return head.next\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nconst mergeKLists = function(lists) {\\n  const queue = new MinPriorityQueue({ priority: x => x.val })\\n\\n  for (const head of lists) {\\n    if (head) {\\n      queue.enqueue(head)\\n    }\\n  }\\n\\n  let result = new ListNode()\\n  const head = result\\n\\n  while (!queue.isEmpty()) {\\n    const { val, next } = queue.dequeue().element\\n\\n    result.next = new ListNode(val)\\n    result = result.next\\n\\n    if (next) {\\n      queue.enqueue(next)\\n    }\\n  }\\n\\n  return head.next\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1447503,
                "title": "python-2-solutions-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Merge Two Sorted Lists  K-1 times**\\n- Use the idea from [21. Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/discuss/1447438).\\n```python\\nclass Solution:\\n    def mergeTwoLists(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\\n        dummyHead = curHead = ListNode(0)\\n        while l1 != None and l2 != None:\\n            if l1.val <= l2.val:\\n                curHead.next = l1\\n                curHead = curHead.next\\n                l1 = l1.next\\n            else:\\n                curHead.next = l2\\n                curHead = curHead.next\\n                l2 = l2.next\\n                \\n        if l1 != None: curHead.next = l1\\n        if l2 != None: curHead.next = l2\\n        return dummyHead.next\\n    \\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        k = len(lists)\\n        if k == 0: return None\\n        if k == 1: return lists[0]\\n        \\n        curList = lists[0]\\n        for i in range(1, k):\\n            curList = self.mergeTwoLists(curList, lists[i])\\n        return curList\\n```\\nComplexity:\\n- Time: `O(K^2 * M)`, where `K <= 10^4` is length of `lists`, `M <= 500` is number of elements each list.\\n\\t- Explain: `mergeTwoLists(list1, list2)` take `O(|list1|+|list2|)`.\\n\\t- We merge `k` lists\\n\\t\\t- Merge first list and second list: `M + M = 2M`\\n\\t\\t- Merge current list and third list: `2M + M = 3M`\\n\\t\\t- ...\\n\\t\\t- Merge current list and `k` list: `K*M`\\n\\t\\t- Total: `O(2M + 3M + ... + K * M) ~ O(M * K * (K+1)/2) ~ O(K^2 * M)`\\n- Space: `O(1)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Merge with Divide and Conquer**\\n- Step = 1, \\n\\t- `lists[0] = mergeTwoLists(lists[0], lists[1])`.\\n\\t- `lists[2] = mergeTwoLists(lists[2], lists[3])`.\\n\\t- `lists[4] = mergeTwoLists(lists[4], lists[5])`.\\n\\t- ...\\n- Step = 2, \\n\\t- `lists[0] = mergeTwoLists(lists[0], lists[2])`.\\n\\t- `lists[4] = mergeTwoLists(lists[4], lists[6])`.\\n\\t- `lists[8] = mergeTwoLists(lists[8], lists[10])`.\\n- Step = 4, 8...\\n```python\\nclass Solution:\\n    def mergeTwoLists(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\\n        dummyHead = curHead = ListNode(0)\\n        while l1 != None and l2 != None:\\n            if l1.val <= l2.val:\\n                curHead.next = l1\\n                curHead = curHead.next\\n                l1 = l1.next\\n            else:\\n                curHead.next = l2\\n                curHead = curHead.next\\n                l2 = l2.next\\n                \\n        if l1 != None: curHead.next = l1\\n        if l2 != None: curHead.next = l2\\n        return dummyHead.next\\n    \\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        k = len(lists)\\n        if k == 0: return None\\n        step = 1\\n        while step < k:\\n            for i in range(0, k-step, step + step):\\n                lists[i] = self.mergeTwoLists(lists[i], lists[i+step])\\n            step += step \\n        return lists[0]\\n```\\nComplexity:\\n- Time: `O(logK * M * K)`, where `K <= 10^4` is length of `lists`, `M <= 500` is number of elements each list.\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def mergeTwoLists(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\\n        dummyHead = curHead = ListNode(0)\\n        while l1 != None and l2 != None:\\n            if l1.val <= l2.val:\\n                curHead.next = l1\\n                curHead = curHead.next\\n                l1 = l1.next\\n            else:\\n                curHead.next = l2\\n                curHead = curHead.next\\n                l2 = l2.next\\n                \\n        if l1 != None: curHead.next = l1\\n        if l2 != None: curHead.next = l2\\n        return dummyHead.next\\n    \\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        k = len(lists)\\n        if k == 0: return None\\n        if k == 1: return lists[0]\\n        \\n        curList = lists[0]\\n        for i in range(1, k):\\n            curList = self.mergeTwoLists(curList, lists[i])\\n        return curList\\n```\n```python\\nclass Solution:\\n    def mergeTwoLists(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\\n        dummyHead = curHead = ListNode(0)\\n        while l1 != None and l2 != None:\\n            if l1.val <= l2.val:\\n                curHead.next = l1\\n                curHead = curHead.next\\n                l1 = l1.next\\n            else:\\n                curHead.next = l2\\n                curHead = curHead.next\\n                l2 = l2.next\\n                \\n        if l1 != None: curHead.next = l1\\n        if l2 != None: curHead.next = l2\\n        return dummyHead.next\\n    \\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        k = len(lists)\\n        if k == 0: return None\\n        step = 1\\n        while step < k:\\n            for i in range(0, k-step, step + step):\\n                lists[i] = self.mergeTwoLists(lists[i], lists[i+step])\\n            step += step \\n        return lists[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 368112,
                "title": "simple-python-heapq-with-custom-comparator-function",
                "content": "We use a priority-queue (`heapq`) find the next element to add. To make the implementation simple we \"monkey patch\" the `ListNode` class to have a custom _less-than_ function using `setattr`. Note that, simply using the tuple trick and pushing `(node.val, node)` to the priority queue will not work because the lists have values in common.\\n\\n```\\nclass Solution:\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        \\n        setattr(ListNode, \"__lt__\", lambda self, other: self.val <= other.val)\\n            \\n        pq = []\\n        for l in lists:\\n            if l:\\n                heapq.heappush(pq,  l)\\n        \\n        out = ListNode(None)\\n        head = out\\n        while pq:\\n            l = heapq.heappop(pq)\\n            head.next = l\\n            head = head.next\\n            if l and l.next:\\n                heapq.heappush( pq, l.next)\\n            \\n        return out.next\\n```\\n            \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        \\n        setattr(ListNode, \"__lt__\", lambda self, other: self.val <= other.val)\\n            \\n        pq = []\\n        for l in lists:\\n            if l:\\n                heapq.heappush(pq,  l)\\n        \\n        out = ListNode(None)\\n        head = out\\n        while pq:\\n            l = heapq.heappop(pq)\\n            head.next = l\\n            head = head.next\\n            if l and l.next:\\n                heapq.heappush( pq, l.next)\\n            \\n        return out.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 10610,
                "title": "c-code-o-nlogk-in-time-o-1-in-space-divide-conquer",
                "content": "    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        int k = (int)lists.size();\\n        if(k==0) return NULL;\\n        if(k==1) return lists[0];\\n        return doMerge(lists, 0, (int)lists.size()-1);\\n    }\\n    \\n    \\n    ListNode* doMerge(vector<ListNode*>& lists, int left, int right) {\\n        if(left==right) return lists[left];\\n        else if(left+1==right) return merge2Lists(lists[left], lists[right]);\\n        ListNode* l1 = doMerge(lists, left, (left+right)/2);\\n        ListNode* l2 = doMerge(lists, (left+right)/2+1, right);\\n        return merge2Lists(l1, l2);\\n    }\\n    \\n    \\n    ListNode* merge2Lists(ListNode* l1, ListNode* l2) {\\n        if(l1==l2) return l1;\\n        if(!l1) return l2;\\n        if(!l2) return l1;\\n        if(l1->val>l2->val) return merge2Lists(l2, l1);\\n        ListNode* newl2 = new ListNode(0); newl2->next = l2;\\n        ListNode* p1 = l1;\\n        while (p1->next && newl2->next) {\\n            if (p1->next->val<newl2->next->val) {\\n                p1 = p1->next;\\n            } else {\\n                ListNode* temp = p1->next;\\n                p1->next = newl2->next;\\n                newl2->next = newl2->next->next;\\n                p1->next->next = temp;\\n                p1 = p1->next;\\n            }\\n        }\\n        if(!p1->next) p1->next = newl2->next;\\n        delete newl2;\\n        return l1;\\n    }",
                "solutionTags": [],
                "code": "    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        int k = (int)lists.size();\\n        if(k==0) return NULL;\\n        if(k==1) return lists[0];\\n        return doMerge(lists, 0, (int)lists.size()-1);\\n    }\\n    \\n    \\n    ListNode* doMerge(vector<ListNode*>& lists, int left, int right) {\\n        if(left==right) return lists[left];\\n        else if(left+1==right) return merge2Lists(lists[left], lists[right]);\\n        ListNode* l1 = doMerge(lists, left, (left+right)/2);\\n        ListNode* l2 = doMerge(lists, (left+right)/2+1, right);\\n        return merge2Lists(l1, l2);\\n    }\\n    \\n    \\n    ListNode* merge2Lists(ListNode* l1, ListNode* l2) {\\n        if(l1==l2) return l1;\\n        if(!l1) return l2;\\n        if(!l2) return l1;\\n        if(l1->val>l2->val) return merge2Lists(l2, l1);\\n        ListNode* newl2 = new ListNode(0); newl2->next = l2;\\n        ListNode* p1 = l1;\\n        while (p1->next && newl2->next) {\\n            if (p1->next->val<newl2->next->val) {\\n                p1 = p1->next;\\n            } else {\\n                ListNode* temp = p1->next;\\n                p1->next = newl2->next;\\n                newl2->next = newl2->next->next;\\n                p1->next->next = temp;\\n                p1 = p1->next;\\n            }\\n        }\\n        if(!p1->next) p1->next = newl2->next;\\n        delete newl2;\\n        return l1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3435078,
                "title": "c-java-python-javascript-easy-solution-fully-explained",
                "content": "# Intuition:\\nThe problem can be solved by merging two sorted linked lists at a time. If we have K linked lists, we can merge the first and second linked lists, then merge the result with the third linked list, and so on. This process will result in a single sorted linked list containing all elements.\\n\\n# Approach:\\n\\n1. Define a function mergeTwoLists that takes two sorted linked lists as input and merges them into a single sorted linked list using a recursive approach.\\n2. In the mergeKLists function, initialize a pointer ans to NULL.\\n3. Iterate over the input vector lists, and at each iteration, merge ans with the current linked list using the mergeTwoLists function.\\n4. Return ans.\\n# Complexity:\\n\\n- Time complexity: \\nThe time complexity of this solution is O(N log k), where N is the total number of elements in all linked lists, and k is the number of linked lists. The reason for this complexity is that we are merging two lists at a time, and the number of merged lists is reduced by a factor of 2 at each iteration. Thus, the total number of iterations is log k. In each iteration, we perform N comparisons and updates, so the total time complexity is O(N log k).\\n\\n- Space Complexity:\\nThe space complexity of this solution is O(1) since we are not using any additional data structures. The only extra space used is the recursion stack space, which is O(log k) for the recursive approach used in mergeTwoLists.\\n\\n---\\n# C++\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\\n        // Recursive Approach \\n        ListNode* ptr1 = list1;\\n        ListNode* ptr2 = list2;\\n        if(ptr1 == NULL){\\n            return list2;\\n        }\\n        if(ptr2 == NULL){\\n            return list1;\\n        }\\n        if(ptr1->val < ptr2->val){\\n            ptr1->next = mergeTwoLists(ptr1->next, ptr2);\\n            return ptr1;\\n        }\\n        else{\\n            ptr2->next = mergeTwoLists(ptr1, ptr2->next);\\n            return ptr2;\\n        }\\n    }\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans = NULL;\\n        int count=0;\\n        while(count<lists.size()){\\n            ans = mergeTwoLists(ans,lists[count]);\\n            count++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n# Java\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\\n        if (l1 == null) {\\n            return l2;\\n        }\\n        if (l2 == null) {\\n            return l1;\\n        }\\n        if (l1.val < l2.val) {\\n            l1.next = mergeTwoLists(l1.next, l2);\\n            return l1;\\n        } else {\\n            l2.next = mergeTwoLists(l1, l2.next);\\n            return l2;\\n        }\\n    }\\n\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        ListNode ans = null;\\n        for (int i = 0; i < lists.length; i++) {\\n            ans = mergeTwoLists(ans, lists[i]);\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\\n---\\n# JavaScript\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode[]} lists\\n * @return {ListNode}\\n */\\nvar mergeTwoLists = function(l1, l2) {\\n    if (!l1) {\\n        return l2;\\n    }\\n    if (!l2) {\\n        return l1;\\n    }\\n    if (l1.val < l2.val) {\\n        l1.next = mergeTwoLists(l1.next, l2);\\n        return l1;\\n    } else {\\n        l2.next = mergeTwoLists(l1, l2.next);\\n        return l2;\\n    }\\n};\\n\\nvar mergeKLists = function(lists) {\\n    let ans = null;\\n    for (let i = 0; i < lists.length; i++) {\\n        ans = mergeTwoLists(ans, lists[i]);\\n    }\\n    return ans;\\n};\\n\\n```\\n---\\n# Python\\n### Different Approach\\n- To avoid the \"Time Limit Exceeded\" error, we can use a more efficient approach using a min-heap or priority queue.\\n```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        # Create a min-heap and initialize it with the first node of each list\\n        heap = []\\n        for i in range(len(lists)):\\n            if lists[i]:\\n                heapq.heappush(heap, (lists[i].val, i))\\n\\n        # Create a dummy node to build the merged list\\n        dummy = ListNode(0)\\n        current = dummy\\n\\n        # Merge the lists using the min-heap\\n        while heap:\\n            val, index = heapq.heappop(heap)\\n            current.next = lists[index]\\n            current = current.next\\n            lists[index] = lists[index].next\\n            if lists[index]:\\n                heapq.heappush(heap, (lists[index].val, index))\\n\\n        return dummy.next\\n\\n```\\n> # ***Thanks For Voting***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\\n        // Recursive Approach \\n        ListNode* ptr1 = list1;\\n        ListNode* ptr2 = list2;\\n        if(ptr1 == NULL){\\n            return list2;\\n        }\\n        if(ptr2 == NULL){\\n            return list1;\\n        }\\n        if(ptr1->val < ptr2->val){\\n            ptr1->next = mergeTwoLists(ptr1->next, ptr2);\\n            return ptr1;\\n        }\\n        else{\\n            ptr2->next = mergeTwoLists(ptr1, ptr2->next);\\n            return ptr2;\\n        }\\n    }\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans = NULL;\\n        int count=0;\\n        while(count<lists.size()){\\n            ans = mergeTwoLists(ans,lists[count]);\\n            count++;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\\n        if (l1 == null) {\\n            return l2;\\n        }\\n        if (l2 == null) {\\n            return l1;\\n        }\\n        if (l1.val < l2.val) {\\n            l1.next = mergeTwoLists(l1.next, l2);\\n            return l1;\\n        } else {\\n            l2.next = mergeTwoLists(l1, l2.next);\\n            return l2;\\n        }\\n    }\\n\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        ListNode ans = null;\\n        for (int i = 0; i < lists.length; i++) {\\n            ans = mergeTwoLists(ans, lists[i]);\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode[]} lists\\n * @return {ListNode}\\n */\\nvar mergeTwoLists = function(l1, l2) {\\n    if (!l1) {\\n        return l2;\\n    }\\n    if (!l2) {\\n        return l1;\\n    }\\n    if (l1.val < l2.val) {\\n        l1.next = mergeTwoLists(l1.next, l2);\\n        return l1;\\n    } else {\\n        l2.next = mergeTwoLists(l1, l2.next);\\n        return l2;\\n    }\\n};\\n\\nvar mergeKLists = function(lists) {\\n    let ans = null;\\n    for (let i = 0; i < lists.length; i++) {\\n        ans = mergeTwoLists(ans, lists[i]);\\n    }\\n    return ans;\\n};\\n\\n```\n```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        # Create a min-heap and initialize it with the first node of each list\\n        heap = []\\n        for i in range(len(lists)):\\n            if lists[i]:\\n                heapq.heappush(heap, (lists[i].val, i))\\n\\n        # Create a dummy node to build the merged list\\n        dummy = ListNode(0)\\n        current = dummy\\n\\n        # Merge the lists using the min-heap\\n        while heap:\\n            val, index = heapq.heappop(heap)\\n            current.next = lists[index]\\n            current = current.next\\n            lists[index] = lists[index].next\\n            if lists[index]:\\n                heapq.heappush(heap, (lists[index].val, index))\\n\\n        return dummy.next\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 10882,
                "title": "c-solution-using-merge-sort",
                "content": "    class Solution {\\n    public:\\n        ListNode* mergeKLists(vector<ListNode*>& lists) {\\n            return partition(lists, 0, lists.size()-1);\\n        }\\n        \\n        ListNode* partition(vector<ListNode*>& lists, int start, int end){\\n            if(start == end){\\n                return lists[start];\\n            }\\n            \\n            if(start < end){\\n                int mid = (end+start)/2;\\n                \\n                ListNode* l1 = partition(lists, start, mid);\\n                ListNode* l2 = partition(lists, mid+1, end);\\n                return merge(l1, l2);\\n            }\\n            \\n            return NULL;\\n        }\\n        \\n        ListNode* merge(ListNode* l1, ListNode* l2){\\n            if(!l1) return l2;\\n            if(!l2) return l1;\\n            \\n            if(l1->val < l2->val){\\n                l1->next = merge(l1->next, l2);\\n                return l1;\\n            }else{\\n                l2->next = merge(l1, l2->next);\\n                return l2;\\n            }\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Merge Sort"
                ],
                "code": "class Solution {\\n    public:\\n        ListNode* mergeKLists(vector<ListNode*>& lists) {\\n            return partition(lists, 0, lists.size()-1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2992596,
                "title": "solution",
                "content": "```C++ []\\nofstream ans(\"user.out\");\\nint main() {\\n    vector<int> v;\\n    v.reserve(1e4);\\n    string s;\\n    while (getline(cin, s)) {\\n        s.erase(remove(begin(s), end(s), \\'[\\'), end(s));\\n        s.erase(remove(begin(s), end(s), \\']\\'), end(s));\\n        for (auto &i: s) if (i == \\',\\') i = \\' \\';\\n        istringstream iss(s);\\n        int temp;\\n        v.clear();\\n        while (iss >> temp) v.push_back(temp);\\n        sort(v.begin(), v.end());\\n        ans << \\'[\\';\\n        for (int i = 0; i < v.size(); ++i) {\\n            if (i) ans << \\',\\';\\n            ans << v[i];\\n        }\\n        ans << \"]\\\\n\";\\n    }\\n}\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        return nullptr;\\n    }\\n};\\n```\\n\\n```Python3 []\\nf = open(\"user.out\", \\'w\\')\\nfor s in sys.stdin:\\n    print(\\'[\\', \\',\\'.join(\\n        map(str, sorted(int(v) for v in s.rstrip().replace(\\'[\\', \\',\\').replace(\\']\\', \\',\\').split(\\',\\') if v))), \\']\\', sep=\\'\\',\\n          file=f)\\nexit(0)\\n```\\n\\n```Java []\\nclass Solution {\\n\\n    ListNode merge(ListNode list1, ListNode list2) {\\n\\n        if (list1 == null) {\\n            return list2;\\n        } else if (list2 == null) {\\n            return list1;\\n        }\\n\\n        ListNode head = null, curr = head;\\n        ListNode curr1 = list1, curr2 = list2;\\n        while (curr1 != null && curr2 != null) {\\n\\n            ListNode minNode = null;\\n            if (curr1.val < curr2.val) {\\n                minNode = curr1;\\n                curr1 = curr1.next;\\n            } else {\\n                minNode = curr2;\\n                curr2 = curr2.next;\\n            }\\n\\n            if (head == null) {\\n                curr = head = minNode;\\n            } else {\\n                curr.next = minNode;\\n                curr = curr.next;\\n            }\\n        }\\n\\n        if (curr1 != null) {\\n            curr.next = curr1;\\n        } else if (curr2 != null) {\\n            curr.next = curr2;\\n        }\\n\\n        return head;\\n    }\\n\\n    ListNode mergeSort(ListNode[] lists, int beg, int end) {\\n\\n        if (beg == end) {\\n            return lists[beg];\\n        }\\n\\n        int mid = (beg + end) / 2;\\n        ListNode list1 = mergeSort(lists, beg, mid);\\n        ListNode list2 = mergeSort(lists, mid + 1, end);\\n        ListNode head = merge(list1, list2);\\n        return head;\\n    }\\n\\n    public ListNode mergeKLists(ListNode[] lists) {\\n\\n        if (lists.length == 0) {\\n            return null;\\n        }\\n        return mergeSort(lists, 0, lists.length - 1);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nofstream ans(\"user.out\");\\nint main() {\\n    vector<int> v;\\n    v.reserve(1e4);\\n    string s;\\n    while (getline(cin, s)) {\\n        s.erase(remove(begin(s), end(s), \\'[\\'), end(s));\\n        s.erase(remove(begin(s), end(s), \\']\\'), end(s));\\n        for (auto &i: s) if (i == \\',\\') i = \\' \\';\\n        istringstream iss(s);\\n        int temp;\\n        v.clear();\\n        while (iss >> temp) v.push_back(temp);\\n        sort(v.begin(), v.end());\\n        ans << \\'[\\';\\n        for (int i = 0; i < v.size(); ++i) {\\n            if (i) ans << \\',\\';\\n            ans << v[i];\\n        }\\n        ans << \"]\\\\n\";\\n    }\\n}\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        return nullptr;\\n    }\\n};\\n```\n```Python3 []\\nf = open(\"user.out\", \\'w\\')\\nfor s in sys.stdin:\\n    print(\\'[\\', \\',\\'.join(\\n        map(str, sorted(int(v) for v in s.rstrip().replace(\\'[\\', \\',\\').replace(\\']\\', \\',\\').split(\\',\\') if v))), \\']\\', sep=\\'\\',\\n          file=f)\\nexit(0)\\n```\n```Java []\\nclass Solution {\\n\\n    ListNode merge(ListNode list1, ListNode list2) {\\n\\n        if (list1 == null) {\\n            return list2;\\n        } else if (list2 == null) {\\n            return list1;\\n        }\\n\\n        ListNode head = null, curr = head;\\n        ListNode curr1 = list1, curr2 = list2;\\n        while (curr1 != null && curr2 != null) {\\n\\n            ListNode minNode = null;\\n            if (curr1.val < curr2.val) {\\n                minNode = curr1;\\n                curr1 = curr1.next;\\n            } else {\\n                minNode = curr2;\\n                curr2 = curr2.next;\\n            }\\n\\n            if (head == null) {\\n                curr = head = minNode;\\n            } else {\\n                curr.next = minNode;\\n                curr = curr.next;\\n            }\\n        }\\n\\n        if (curr1 != null) {\\n            curr.next = curr1;\\n        } else if (curr2 != null) {\\n            curr.next = curr2;\\n        }\\n\\n        return head;\\n    }\\n\\n    ListNode mergeSort(ListNode[] lists, int beg, int end) {\\n\\n        if (beg == end) {\\n            return lists[beg];\\n        }\\n\\n        int mid = (beg + end) / 2;\\n        ListNode list1 = mergeSort(lists, beg, mid);\\n        ListNode list2 = mergeSort(lists, mid + 1, end);\\n        ListNode head = merge(list1, list2);\\n        return head;\\n    }\\n\\n    public ListNode mergeKLists(ListNode[] lists) {\\n\\n        if (lists.length == 0) {\\n            return null;\\n        }\\n        return mergeSort(lists, 0, lists.length - 1);\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1745569,
                "title": "very-detailed-explanation-going-from-o-nlogn-o-n-k-o-n-log-k",
                "content": "```\\nOkay, so for this problem we are given several linked list in our array. \\nEach linked list is sorted in asscending order & we merge all the list together to be one sorted linked list. \\nThere are many ways to solve this problem. \\n```\\nLet\\'s take an example,\\n\\n**Input**: lists = [[1,3,4],[5,6,7],[3,4,5]]\\n**Output**: [ 1, 3, 3, 4, 4, 5, 5, 6, 7 ]\\n```\\nThe brute force approach is,\\n```\\nWe can simply iterate over all the list node & add them into an array. Then we sort the array & loop through to make the connection b/w nodes. And this will take **Time complexity - BigO(NlogN)** & **Space complexity - BigO(N)**\\n\\n![image](https://assets.leetcode.com/users/images/8d98d812-2ad4-4405-a85f-d4b5ed0c2e57_1644023126.8413756.png)\\n\\n```\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        if(lists == null || lists.length == 0) return null;\\n        \\n        ListNode head = new ListNode(0); // dummy node head\\n        ListNode temp = head; // taking into temporary variable\\n        List<Integer> l = new ArrayList<>();\\n        for(ListNode list : lists){ // adding all the values in the list\\n            while(list != null){\\n                l.add(list.val);\\n                list = list.next;\\n            }\\n        }\\n        Collections.sort(l); // sorting that list we get above\\n        for(int val : l){ // iterating over the list & creating new single linked list\\n            temp.next = new ListNode(val);\\n            temp = temp.next;\\n        }\\n        return head.next;\\n    }\\n}\\n```\\n\\n\\n<hr>\\n<hr>\\n\\n```\\nLet\\'s Optimize a more bit.\\n```\\n\\n<hr>\\n<hr>\\n\\nLet\\'s take an example,\\n\\n**Input**: lists = [[1,2,3,4],[2,3,4,5],[1,1,2,3]]\\n**Output**: [ 1, 3, 3, 4, 4, 5, 5, 6, 7 ]\\n\\n![image](https://assets.leetcode.com/users/images/d727edf5-2cdd-4514-bcec-9dc0bb85e790_1644028027.4866238.png)\\n\\nAs you see that each of these 3 lists are sorted in itself. \\n* We compare the 1\\'st three values of the list & pick which ever is the lowest.\\n\\n\\n* We will have a dummy node to put that smallest value next to the dummy node. \\n* Now from which ever list we have selected this node will move the pointer to it\\'s next node\\n* Similarly, we will compare the value again & over again and which ever is the smallest we put that in result list.\\n\\n![image](https://assets.leetcode.com/users/images/d90a887b-818e-472f-bda0-d29b01de5267_1644028607.8243701.png)\\n\\nWe continuously doing this, until we reach end of all the list.\\n\\n*I hope you got the idea,* **let\\'s code it up:**\\n```\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        if(lists == null || lists.length == 0) return null; // base case\\n        \\n        ListNode head = new ListNode(0); // dummy node created & you can chose any value of your choice, I choose 0 \"Because we indian invented that\"\\n        ListNode temp = head;\\n        \\n        while(true){ // running infinite\\n            int p = 0; // point to list with minimum value\\n            for(int i = 0; i < lists.length; i++){\\n                if(lists[p] == null || (lists[i] != null && lists[p].val > lists[i].val)){\\n                p = i;\\n                }\\n            }\\n            if(lists[p] == null){ // it means no value present\\n                break;\\n            }\\n            temp.next = lists[p];\\n            temp = temp.next;\\n            lists[p] = lists[p].next;\\n        }\\n        return head.next;\\n    }\\n}\\n```\\nANALYSIS :-\\n* **Time Complexity :-** BigO(N * K) where N is no. of nodes & K is size of the lists\\n\\n* **Space Complexity :-** BigO(N) \\n\\n\\n<hr>\\n<hr>\\n\\n```\\nLet\\'s move to more Optimal Approach. \\n```\\n\\n<hr>\\n<hr>\\n\\n\\n***So, the knowledge of Merge Sort Algorithm is very prevalent here. It will involved a divide n conquer approach.***\\n\\nSo, there are 2 step\\'s that we need to perform.\\n1. The 1st step is dividing the lists recursively until arriving at our base case.\\n2. And our 2nd step is to merge the lists together to be in sorted order.\\n\\nThe intution behind this approach is we will be merging together sorted lists in multiple parts of the array recursively, **hence we using divide and conquer.**\\n\\nLet\\'s take one more example:\\n```\\nInput: lists = [[1,4,5],[1,3,4],[2,6]]\\nOutput: [1,1,2,3,4,4,5,6]\\n```\\n* So, what i say is, at each step we gonna have a start & end index. Start is going to be at 0 & end is going to be at 2.\\n\\n\\n* As you can see start is left most side of our array i.e. `[1, 4, 5]`\\n* And end is on our right most side of our array i.e. `[2, 6]`\\n* So, with the start & end values, we are now going to compute our mid point. If we do our mid =  start + end / 2 i.e. `mid = (0 + 2 ) / 2 = 1`\\n* And what this is telling us, we gonna split our array base on this mid point. So, the left side will be `[Start, mid] i.e. [ [1, 4, 5], [1, 3, 4] ]`\\n* And our right side will be `[mid + 1, end] i.e. [ [2, 6] ]`\\n\\n![image](https://assets.leetcode.com/users/images/635d1b3b-88aa-4950-8ef3-d65feff30a5d_1644024352.4191604.png)\\n\\nAnd we gonna continueosuly do this until we arrive at our base cases where our start index is equals to our end index\\n\\n* So, after splitting at index 1 we now have the following list **[ [1, 4, 5], [1, 3, 4] ]** & we do this same logic recursively over and over we arrive at the base cases. \\n* So, now let\\'s do the same thing with left side again. Now our **start = 0 & end = 1**. If we calculate mid again i.e. `mid = (0 + 1) / 2 = 0 `\\n* We gonna have one list which is `[ [1, 4, 5] ]` & another list which is `[ [1, 3, 4] ]`\\n* So, now as you can see after we did that, the division resulted it into 2 base cases, since each list is on it\\'s own.\\n\\n![image](https://assets.leetcode.com/users/images/64d6e6db-d064-48b7-a542-407de3182fb4_1644024724.0997772.png)\\n\\nWhat does this mean\\'s that we just need to go back, up the chain and merge the list together.\\n\\n* So, `[1,4,5]` get return from our recursive call\\n* And `[1,3,4]` get returns from a separate recursive call\\n* ANd then, we going to merge them back together and that would result in array of `[[1,,1,3,4,45]]`\\n* Now if we go back & look at our right subtree, in the previous division step we did. We were left with the base case of `[[2,6]]`, this will get return\\n\\n![image](https://assets.leetcode.com/users/images/e31a836f-303a-4be1-97ff-2fcb9d7d7711_1644025139.2216055.png)\\n\\nAnd finally we gonna merge `[[2,6]]` with previously merge array. And merging these together gives us `[ [ 1, 1, 2, 3, 4, 4, 5, 6 ] ]` which is our final answer.\\n\\n![image](https://assets.leetcode.com/users/images/24c24608-3638-4ad6-85ab-5a27dccadce4_1644025300.024822.png)\\n\\n*Now, I hope approach is crystal clear,* **let\\'s code it**\\n\\n```\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        // Base Condition\\n        if(lists == null || lists.length == 0) return null;\\n        // Creating helper function helps in dividing and conquer approach\\n        return getMid(lists, 0, lists.length - 1); // created start & end index\\n    }\\n    private ListNode getMid(ListNode lists[], int start, int end){\\n        // Handle base case, when start & end index are same\\n        if(start == end) return lists[start];\\n        int mid = start + (end - start) / 2; // calculating mid & why we writing in this way to handle index overflow\\n        ListNode left = getMid(lists, start, mid); // in left mid become our new end\\n        ListNode right = getMid(lists, mid + 1, end); // in right this time start is mid + 1\\n        \\n        return merge(left, right);// merge the left & right together\\n    }\\n    private ListNode merge(ListNode l1, ListNode l2){\\n        ListNode result = new ListNode(0); // created dummy node with any value of your choice, i choose 0 \"Because we indian invented that\"\\n        ListNode curr = result; // use this pointer to move over\\n        \\n        while(l1 != null || l2 != null){\\n            if(l1 == null){\\n                curr.next = l2; // bcz if l1 is null we know l2 must have value\\n                l2 = l2.next;\\n            }\\n            else if(l2 == null){\\n                curr.next = l1; // bcz if l2 is null we know l1 must have value\\n                l1 = l1.next;\\n            }else if(l1.val < l2.val){ // if we made up till this point we know they both have value & let\\'s compare them\\n                curr.next  = l1;\\n                l1 = l1.next;\\n            }\\n            else{\\n                curr.next = l2;\\n                l2 = l2.next;\\n            }\\n            curr = curr.next;\\n        }\\n        return result.next; // why we not return only result bcz, result has dummy value of 0\\n    }\\n}\\n```\\nANALYSIS :-\\n* **Time Complexity :-** BigO(N * log(K)) where N is no of nodes we have when we are merging 2 lists together. ANd log of K portion comes from our recursive func. getMid. K is the no. of recursive call that we going to have to make.\\n\\n* **Space Complexity :-** BigO(K) where K is also no. of recursive call that we going to have to make, since every time we make a recursive call it add to ours stack space",
                "solutionTags": [],
                "code": "```\\nOkay, so for this problem we are given several linked list in our array. \\nEach linked list is sorted in asscending order & we merge all the list together to be one sorted linked list. \\nThere are many ways to solve this problem. \\n```\n```\\nThe brute force approach is,\\n```\n```\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        if(lists == null || lists.length == 0) return null;\\n        \\n        ListNode head = new ListNode(0); // dummy node head\\n        ListNode temp = head; // taking into temporary variable\\n        List<Integer> l = new ArrayList<>();\\n        for(ListNode list : lists){ // adding all the values in the list\\n            while(list != null){\\n                l.add(list.val);\\n                list = list.next;\\n            }\\n        }\\n        Collections.sort(l); // sorting that list we get above\\n        for(int val : l){ // iterating over the list & creating new single linked list\\n            temp.next = new ListNode(val);\\n            temp = temp.next;\\n        }\\n        return head.next;\\n    }\\n}\\n```\n```\\nLet\\'s Optimize a more bit.\\n```\n```\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        if(lists == null || lists.length == 0) return null; // base case\\n        \\n        ListNode head = new ListNode(0); // dummy node created & you can chose any value of your choice, I choose 0 \"Because we indian invented that\"\\n        ListNode temp = head;\\n        \\n        while(true){ // running infinite\\n            int p = 0; // point to list with minimum value\\n            for(int i = 0; i < lists.length; i++){\\n                if(lists[p] == null || (lists[i] != null && lists[p].val > lists[i].val)){\\n                p = i;\\n                }\\n            }\\n            if(lists[p] == null){ // it means no value present\\n                break;\\n            }\\n            temp.next = lists[p];\\n            temp = temp.next;\\n            lists[p] = lists[p].next;\\n        }\\n        return head.next;\\n    }\\n}\\n```\n```\\nLet\\'s move to more Optimal Approach. \\n```\n```\\nInput: lists = [[1,4,5],[1,3,4],[2,6]]\\nOutput: [1,1,2,3,4,4,5,6]\\n```\n```\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        // Base Condition\\n        if(lists == null || lists.length == 0) return null;\\n        // Creating helper function helps in dividing and conquer approach\\n        return getMid(lists, 0, lists.length - 1); // created start & end index\\n    }\\n    private ListNode getMid(ListNode lists[], int start, int end){\\n        // Handle base case, when start & end index are same\\n        if(start == end) return lists[start];\\n        int mid = start + (end - start) / 2; // calculating mid & why we writing in this way to handle index overflow\\n        ListNode left = getMid(lists, start, mid); // in left mid become our new end\\n        ListNode right = getMid(lists, mid + 1, end); // in right this time start is mid + 1\\n        \\n        return merge(left, right);// merge the left & right together\\n    }\\n    private ListNode merge(ListNode l1, ListNode l2){\\n        ListNode result = new ListNode(0); // created dummy node with any value of your choice, i choose 0 \"Because we indian invented that\"\\n        ListNode curr = result; // use this pointer to move over\\n        \\n        while(l1 != null || l2 != null){\\n            if(l1 == null){\\n                curr.next = l2; // bcz if l1 is null we know l2 must have value\\n                l2 = l2.next;\\n            }\\n            else if(l2 == null){\\n                curr.next = l1; // bcz if l2 is null we know l1 must have value\\n                l1 = l1.next;\\n            }else if(l1.val < l2.val){ // if we made up till this point we know they both have value & let\\'s compare them\\n                curr.next  = l1;\\n                l1 = l1.next;\\n            }\\n            else{\\n                curr.next = l2;\\n                l2 = l2.next;\\n            }\\n            curr = curr.next;\\n        }\\n        return result.next; // why we not return only result bcz, result has dummy value of 0\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 10607,
                "title": "three-ways-to-solve-this-problem-in-python-build-in-sort-merge-and-priority-queue",
                "content": "I figured out that OJ converts Python list into a ListNode automatically, so in my solution I return a list directly(Sorry for my laziness)\\n\\nThe first solution uses Python build-in sort, to my surprise it's the fastest one, although it's kind of a hack:\\n\\n    def mergeKLists(lists):\\n        ret = []\\n        for lst in lists:\\n            while lst:\\n                ret.append(lst.val)\\n                lst = lst.next\\n                \\n        return sorted(ret)\\n\\nThe second solution uses merge sort:\\n\\n    def mergeKLists(lists):\\n        \\n        def merge(lst1, lst2):\\n            dummy = pt = ListNode(-1)\\n            while lst1 and lst2:\\n                if lst1.val < lst2.val:\\n                    pt.next = lst1\\n                    lst1 = lst1.next\\n                else:\\n                    pt.next = lst2\\n                    lst2 = lst2.next\\n                pt = pt.next\\n                \\n            pt.next = lst1 if not lst2 else lst2\\n            return dummy.next\\n            \\n        \\n        if not lists:\\n            return None\\n\\n        if len(lists) == 1:\\n            return lists[0]\\n        mid = len(lists)/2\\n        left = mergeKLists(lists[:mid])\\n        right = mergeKLists(lists[mid:])\\n\\n        return merge(left, right)\\n\\nThe third one uses priority queue:\\n\\n        \\n    \\n\\n    import heapq\\n    def mergeKLists(lists):\\n            \\n        ret, heap = [], []\\n        for lst in lists:\\n            while lst:\\n                heapq.heappush(heap, lst.val)\\n                lst = lst.next\\n    \\n        while heap:\\n            ret.append(heapq.heappop(heap))\\n        return ret",
                "solutionTags": [],
                "code": "I figured out that OJ converts Python list into a ListNode automatically, so in my solution I return a list directly(Sorry for my laziness)\\n\\nThe first solution uses Python build-in sort, to my surprise it's the fastest one, although it's kind of a hack:\\n\\n    def mergeKLists(lists):\\n        ret = []\\n        for lst in lists:\\n            while lst:\\n                ret.append(lst.val)\\n                lst = lst.next\\n                \\n        return sorted(ret)\\n\\nThe second solution uses merge sort:\\n\\n    def mergeKLists(lists):\\n        \\n        def merge(lst1, lst2):\\n            dummy = pt = ListNode(-1)\\n            while lst1 and lst2:\\n                if lst1.val < lst2.val:\\n                    pt.next = lst1\\n                    lst1 = lst1.next\\n                else:\\n                    pt.next = lst2\\n                    lst2 = lst2.next\\n                pt = pt.next\\n                \\n            pt.next = lst1 if not lst2 else lst2\\n            return dummy.next\\n            \\n        \\n        if not lists:\\n            return None\\n\\n        if len(lists) == 1:\\n            return lists[0]\\n        mid = len(lists)/2\\n        left = mergeKLists(lists[:mid])\\n        right = mergeKLists(lists[mid:])\\n\\n        return merge(left, right)\\n\\nThe third one uses priority queue:\\n\\n        \\n    \\n\\n    import heapq\\n    def mergeKLists(lists):\\n            \\n        ret, heap = [], []\\n        for lst in lists:\\n            while lst:\\n                heapq.heappush(heap, lst.val)\\n                lst = lst.next\\n    \\n        while heap:\\n            ret.append(heapq.heappop(heap))\\n        return ret",
                "codeTag": "Python3"
            },
            {
                "id": 10630,
                "title": "c-using-minheap-priorityqueue-implemented-using-sorteddictionary",
                "content": "We need to keep track of the heads of all lists at all times and be able to do the following operations efficiently:\\n1- Get/Remove Min\\n2- Add (once you remove the head of one list, you need to add the next from that list)\\n\\nA min heap (or a priority queue) is obviously the data structure we need here, where the key of the dictionary is the value of the ListNode, and the value of the dictionary is a queue of ListNodes having that value. (we need to queue the ones with the same value since Dictionary cannot have dupes)\\nI implemented mine using a SortedDictionary of queues. \\nSortedDictionary is internally implemented using a binary tree, and provides O(logn) for Add() and O(1) for PopMin(), so it's as efficient as it gets. \\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int x) { val = x; }\\n * }\\n */\\npublic class Solution {\\n    \\n    public class MinHeap\\n    {\\n        public SortedDictionary<int, Queue<ListNode>> map = new SortedDictionary<int, Queue<ListNode>>();\\n\\n        public void Add(int val, ListNode node)\\n        {\\n            if(!map.ContainsKey(val))\\n            {\\n                map.Add(val, new Queue<ListNode>());\\n            }\\n\\n            map[val].Enqueue(node);\\n        }\\n\\n        public ListNode PopMin()\\n        {\\n            int minKey = map.First().Key;\\n            ListNode node = map[minKey].Dequeue();\\n\\n            if (map[minKey].Count == 0)\\n                map.Remove(minKey);\\n\\n            return node;\\n        }\\n    }\\n    \\n    public ListNode MergeKLists(ListNode[] lists) \\n    {\\n        MinHeap heap = new MinHeap();\\n        foreach (var node in lists)\\n        {\\n            if(node == null)\\n                continue;\\n            \\n            heap.Add(node.val, node);\\n        }\\n\\n        ListNode curr = null, newHead = null;\\n\\n        while (heap.map.Count > 0)\\n        {\\n            ListNode node = heap.PopMin();\\n\\n            if (node.next != null)\\n            {\\n                heap.Add(node.next.val, node.next);\\n            }\\n\\n            if (curr == null)\\n            {\\n                curr = node;\\n                newHead = curr;\\n            }\\n            else\\n            {\\n                curr.next = node;\\n                curr = curr.next;\\n            }\\n        }\\n\\n        return newHead;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int x) { val = x; }\\n * }\\n */\\npublic class Solution {\\n    \\n    public class MinHeap\\n    {\\n        public SortedDictionary<int, Queue<ListNode>> map = new SortedDictionary<int, Queue<ListNode>>();\\n\\n        public void Add(int val, ListNode node)\\n        {\\n            if(!map.ContainsKey(val))\\n            {\\n                map.Add(val, new Queue<ListNode>());\\n            }\\n\\n            map[val].Enqueue(node);\\n        }\\n\\n        public ListNode PopMin()\\n        {\\n            int minKey = map.First().Key;\\n            ListNode node = map[minKey].Dequeue();\\n\\n            if (map[minKey].Count == 0)\\n                map.Remove(minKey);\\n\\n            return node;\\n        }\\n    }\\n    \\n    public ListNode MergeKLists(ListNode[] lists) \\n    {\\n        MinHeap heap = new MinHeap();\\n        foreach (var node in lists)\\n        {\\n            if(node == null)\\n                continue;\\n            \\n            heap.Add(node.val, node);\\n        }\\n\\n        ListNode curr = null, newHead = null;\\n\\n        while (heap.map.Count > 0)\\n        {\\n            ListNode node = heap.PopMin();\\n\\n            if (node.next != null)\\n            {\\n                heap.Add(node.next.val, node.next);\\n            }\\n\\n            if (curr == null)\\n            {\\n                curr = node;\\n                newHead = curr;\\n            }\\n            else\\n            {\\n                curr.next = node;\\n                curr = curr.next;\\n            }\\n        }\\n\\n        return newHead;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1656809,
                "title": "solution-swift-merge-k-sorted-lists-test-cases",
                "content": "```swift\\nclass Solution {\\n    func mergeKLists(_ lists: [ListNode?]) -> ListNode? {\\n        \\n        var arr: [Int] = []\\n        \\n        for list in lists.compactMap ({ $0 }) {\\n            var head: ListNode? = list\\n            while head != nil {\\n                arr.append(head!.val)\\n                head = head?.next\\n            }\\n        }\\n        arr.sort()\\n        if arr.isEmpty { return nil }\\n        \\n        let node = ListNode(0)\\n        var curr = ListNode(arr[0])\\n        node.next = curr\\n        \\n        for n in arr.dropFirst() {\\n            let tmp = ListNode(n)\\n            curr.next = tmp\\n            if let next = curr.next { curr = next }\\n        }\\n        return node.next\\n    }\\n}\\n```\\n\\n---\\n\\n<p><details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 2 tests, with 0 failures (0 unexpected) in 0.021 (0.023) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    /// The linked-lists are:\\n    /// [\\n    ///   1->4->5,\\n    ///   1->3->4,\\n    ///   2->6\\n    /// ]\\n    /// merging them into one sorted list:\\n    /// 1->1->2->3->4->4->5->6\\n    func test0() {\\n        let lists = [ListNode([1, 4, 5]), ListNode([1, 3, 4]), ListNode([2, 6])]\\n        let value = solution.mergeKLists(lists)\\n        XCTAssertEqual(value?.val, ListNode([1,1,2,3,4,4,5,6])?.val)\\n    }\\n    \\n    func test1() {\\n        let value = solution.mergeKLists([ListNode([])])\\n        XCTAssertEqual(value?.val, ListNode([])?.val)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details></p>\\n\\n<p>\\n<details>\\n<summary>\\n<b>ListNode</b>\\n</summary>\\n\\n<br>\\n\\n```swift\\npublic class ListNode {\\n    public var val: Int\\n    public var next: ListNode?\\n    public init() { self.val = 0; self.next = nil; }\\n    public init(_ val: Int) { self.val = val; self.next = nil; }\\n    public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n    \\n    public init?(_ array: [Int]) {\\n        guard !array.isEmpty else { return nil }\\n        self.val = array[0]\\n        var prev: ListNode = self\\n        for i in 1..<array.count {\\n            let new = ListNode(array[i])\\n            prev.next = new\\n            prev = new\\n        }\\n    }\\n}\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func mergeKLists(_ lists: [ListNode?]) -> ListNode? {\\n        \\n        var arr: [Int] = []\\n        \\n        for list in lists.compactMap ({ $0 }) {\\n            var head: ListNode? = list\\n            while head != nil {\\n                arr.append(head!.val)\\n                head = head?.next\\n            }\\n        }\\n        arr.sort()\\n        if arr.isEmpty { return nil }\\n        \\n        let node = ListNode(0)\\n        var curr = ListNode(arr[0])\\n        node.next = curr\\n        \\n        for n in arr.dropFirst() {\\n            let tmp = ListNode(n)\\n            curr.next = tmp\\n            if let next = curr.next { curr = next }\\n        }\\n        return node.next\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    /// The linked-lists are:\\n    /// [\\n    ///   1->4->5,\\n    ///   1->3->4,\\n    ///   2->6\\n    /// ]\\n    /// merging them into one sorted list:\\n    /// 1->1->2->3->4->4->5->6\\n    func test0() {\\n        let lists = [ListNode([1, 4, 5]), ListNode([1, 3, 4]), ListNode([2, 6])]\\n        let value = solution.mergeKLists(lists)\\n        XCTAssertEqual(value?.val, ListNode([1,1,2,3,4,4,5,6])?.val)\\n    }\\n    \\n    func test1() {\\n        let value = solution.mergeKLists([ListNode([])])\\n        XCTAssertEqual(value?.val, ListNode([])?.val)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\n```swift\\npublic class ListNode {\\n    public var val: Int\\n    public var next: ListNode?\\n    public init() { self.val = 0; self.next = nil; }\\n    public init(_ val: Int) { self.val = val; self.next = nil; }\\n    public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n    \\n    public init?(_ array: [Int]) {\\n        guard !array.isEmpty else { return nil }\\n        self.val = array[0]\\n        var prev: ListNode = self\\n        for i in 1..<array.count {\\n            let new = ListNode(array[i])\\n            prev.next = new\\n            prev = new\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 541375,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n        public ListNode MergeKLists(ListNode[] lists)\\n        {            \\n            if (lists == null || lists.Length == 0)\\n                return null;\\n         \\n            return Merge(lists, 0, lists.Length - 1);\\n        }\\n\\n        private ListNode Merge(ListNode[] lists, int i, int j)\\n        {\\n            if (j == i)\\n                return lists[i];\\n            else\\n            {\\n                int mid = i + (j - i) / 2;\\n\\n                ListNode left = Merge(lists, i, mid),\\n                         right = Merge(lists, mid + 1, j);\\n\\n                return Merge(left, right);\\n            }\\n        }\\n\\n        private ListNode Merge(ListNode list1, ListNode list2)\\n        {\\n            ListNode dummy = new ListNode(0),\\n                     cur = dummy;\\n\\n            while (list1 != null && list2 != null)\\n            {\\n                if (list1.val <= list2.val)\\n                {\\n                    cur.next = list1;\\n                    list1 = list1.next;\\n                }\\n                else\\n                {\\n                    cur.next = list2;\\n                    list2 = list2.next;\\n                }\\n\\n                cur = cur.next;\\n            }\\n\\n            if (list1 != null)\\n                cur.next = list1;\\n\\n            if (list2 != null)\\n                cur.next = list2;\\n\\n            return dummy.next;\\n        }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n        public ListNode MergeKLists(ListNode[] lists)\\n        {            \\n            if (lists == null || lists.Length == 0)\\n                return null;\\n         \\n            return Merge(lists, 0, lists.Length - 1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 427631,
                "title": "3-python-solutions-with-inline-comments-and-analysis-brute-force-brute-force-min-heap",
                "content": "**3 Python Solutions with Inline Comments and Analysis (Brute Force, Brute Force+, Min Heap), 99.85%, 5.01%, and 90.17%**\\n\\nI decided to write up the 3 solutions I came up with. I was a bit suprised that the \"brute force\" was so efficient, but I suppose the test inputs matter as well as the fact Python relies on C subroutines for some things like sorting.\\n\\nAny comments and advice appreciated!\\n\\n**Brute Force: convert to array list, sort, convert back to linked list**\\n*Asymptotic WC Runtime: O(NlgN)\\nBest Test Runtime: 68ms, 99.85%*\\n\\n```python\\n# Brute Force Approach\\n# O(NlgN) = O(aN + bNlgN + cN)\\n#   where N is the number of total elements\\n#   and k is the number of sorted linked lists\\n# Idea:\\n#   1) Traverse all linked lists, \\n#       adding every element to an arraylist\\n#       O(N)\\n#   2) Sort the array list\\n#       O(NlgN)\\n#   3) Transform the array list into a linkedlist\\n#       O(N)\\n# Best Runtime\\n# Runtime: 68 ms, faster than 99.85% of Python online submissions for Merge k Sorted Lists.\\n# Memory Usage: 17.6 MB, less than 37.88% of Python online submissions for Merge k Sorted Lists.\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        \"\"\"\\n        :type lists: List[ListNode]\\n        :rtype: ListNode\\n        \"\"\"\\n        # validate input\\n        if not lists:\\n            return None\\n        # shortcut, just return 1st linkedlist if only a single list\\n        if len(lists) == 1:\\n            return lists[0]\\n\\n        # Create an empty array and fill it with all the elements\\n        #     from the LinkedLists\\n        array = []\\n        for ll in lists:\\n            node = ll\\n            while node:\\n                array.append(node)\\n                node = node.next\\n        # Verify elements were actually added to the array (LL could have all been empty)\\n        if not array:\\n            return None                \\n\\n        # Sort the array\\n        array.sort(key=lambda node: node.val)\\n    \\n        # Create a new linked list from the array\\n        head = array[0]\\n        for i in xrange(1, len(array)):\\n            prev = array[i-1]\\n            node = array[i]\\n            prev.next = node\\n        return head\\n```\\nThis one\\'s runtime was pretty suprising considering the asymptotic runtime should be the worst (assuming k < N). A reminder to ALWAYS PROFILE your code in production and try a couple different ways when possible. And consider which of your variables will actually be larger in the data you have to deal with.\\n\\n**Brute Force+ Approach: while there are non-empty linked lists, choose the minimum element from all lists**\\n*Asymptotic WC Runtime: O(kN)\\nBest Test Runtime:  6968 ms, 5.01%*\\n\\n```python\\n# Brute Force+ Approach\\n# O(kN) = O(akN)\\n#   where N is the number of total elements\\n#   and k is the number of sorted linked lists\\n# Idea:\\n#   1) Keep a list of pointers for your position in every list\\n#       and with it\\n#       O(N)\\n#   2) Go through all k lists choosing the smallest element \\n#       and adding it to your returned linked list\\n#       updating its pointer to point to its next\\n#       repeat until all N elements have been added\\n#       (i.e. all pointers point to None)\\n#       so N iterations of O(k) search\\n#       O(kN)\\n# Best Runtime\\n# Runtime: 6968 ms, faster than 5.01% of Python online submissions for Merge k Sorted Lists.\\n# Memory Usage: 17.4 MB, less than 80.30% of Python online submissions for Merge k Sorted Lists.\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        \"\"\"\\n        :type lists: List[ListNode]\\n        :rtype: ListNode\\n        \"\"\"\\n        # validate input\\n        if not lists:\\n            return None\\n        # shortcut, just return 1st linkedlist if only a single list\\n        if len(lists) == 1:\\n            return lists[0]\\n\\n        # create a temporary head and a node pointer to track what\\n        #     elements we\\'ve added to the return list\\n        temp_head = ListNode(-1)\\n        node = temp_head\\n\\n        # while there are still linked lists with elements in them,\\n        #   choose the list with the smallest starting element\\n        #   and add that element to our return llist\\n        #   and move the list it came from\\'s pointer forward\\n        #   (note: we modify the input lists instead of keeping a pointer)\\n        while any((ll is not None for ll in lists)):\\n            smallest_val = float(\"inf\")\\n            smallest_index = None\\n            for index, ll in enumerate(lists):\\n                if ll is not None:\\n                    if ll.val < smallest_val:\\n                        smallest_val = ll.val\\n                        smallest_index = index\\n            node.next = lists[smallest_index]\\n            lists[smallest_index] = lists[smallest_index].next\\n            node = node.next\\n        # return all the items after our temporary head\\n        #     (i.e. our actual sorted list)\\n        return temp_head.next\\n```\\nThis algorithm suprisingly performed the worst.\\n\\n*Note:* You can get a slight speed up by removing all the empy elements from `list`, but it\\'s still pretty dreadful. (e.g. add `lists = filter(None, lists)` to the end of the while loop)\\n```\\n# Runtime: 5084 ms, faster than 5.01% of Python online submissions for Merge k Sorted Lists.\\n# Memory Usage: 17.4 MB, less than 71.21% of Python online submissions for Merge k Sorted Lists.\\n```\\n\\n**Minimum Heap/Priority Queue Approach**\\n*Asymptotic WC Runtime:  O(Nlgk)\\nBest Test Runtime:  84 ms, 90.17%*\\nThis algorithm is an extension of the previous idea, but instead of wasting work recomparing all the values, it uses a minimum heap to keep a ranking of all the smallest elements seen so far.\\n\\n```python\\n# Min Heap Approach\\n# O(Nlgk) = O(klgk + Nlgk)\\n#   where N is the number of total elements\\n#   and k is the number of sorted linked lists\\n# Idea:\\n#   We can leverage a min heap to extend the BF+ approach while\\n#   maintaing a ranking of the k minimum elements remaining in each list\\n#   without having to do unnecessary additional work recomparing nodes\\n#   we\\'ve already considered.\\n#   1) Build a min-heap of the first node of each of the k LinkedLists\\n#       O(klgk)\\n#   2) While there\\'s a queue: (note all N elements added to it in total)\\n#       a) pop the minimum element from the heap O(lgk)\\n#       b) push its next node to the heap, if it exists O(lgk)\\n#       O(Nlgk)\\n# Best Runtime\\n# Runtime: 84 ms, faster than 90.17% of Python online submissions for Merge k Sorted Lists.\\n# Memory Usage: 17.5 MB, less than 40.91% of Python online submissions for Merge k Sorted Lists.\\nimport heapq\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        \"\"\"\\n        :type lists: List[ListNode]\\n        :rtype: ListNode\\n        \"\"\"\\n        # validate input\\n        if not lists:\\n            return None\\n        # shortcut, just return 1st linkedlist if only a single list\\n        if len(lists) == 1:\\n            return lists[0]\\n\\n        # create a temporary head and a node pointer to track what\\n        #     elements we\\'ve added to the return list\\n        temp_head = ListNode(-1)\\n        node = temp_head\\n\\n        # Create a min-heap tracking the smallest elements seen so far\\n        #   (up to k elements adde)\\n        queue = []\\n        for ll in lists:\\n            if ll:\\n                heapq.heappush(queue, (ll.val, ll))\\n        \\n        # while there\\'s elts in the queue, \\n        #   pop its minimum element and add it to the return llist\\n        #   if it has a next element, add that to the priority queue in its place\\n        while queue:\\n            value, next_node = heapq.heappop(queue)\\n            node.next = next_node\\n            if next_node.next:\\n                heapq.heappush(queue, (next_node.next.val, next_node.next))\\n            node = node.next\\n        \\n        return temp_head.next\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\n# Brute Force Approach\\n# O(NlgN) = O(aN + bNlgN + cN)\\n#   where N is the number of total elements\\n#   and k is the number of sorted linked lists\\n# Idea:\\n#   1) Traverse all linked lists, \\n#       adding every element to an arraylist\\n#       O(N)\\n#   2) Sort the array list\\n#       O(NlgN)\\n#   3) Transform the array list into a linkedlist\\n#       O(N)\\n# Best Runtime\\n# Runtime: 68 ms, faster than 99.85% of Python online submissions for Merge k Sorted Lists.\\n# Memory Usage: 17.6 MB, less than 37.88% of Python online submissions for Merge k Sorted Lists.\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        \"\"\"\\n        :type lists: List[ListNode]\\n        :rtype: ListNode\\n        \"\"\"\\n        # validate input\\n        if not lists:\\n            return None\\n        # shortcut, just return 1st linkedlist if only a single list\\n        if len(lists) == 1:\\n            return lists[0]\\n\\n        # Create an empty array and fill it with all the elements\\n        #     from the LinkedLists\\n        array = []\\n        for ll in lists:\\n            node = ll\\n            while node:\\n                array.append(node)\\n                node = node.next\\n        # Verify elements were actually added to the array (LL could have all been empty)\\n        if not array:\\n            return None                \\n\\n        # Sort the array\\n        array.sort(key=lambda node: node.val)\\n    \\n        # Create a new linked list from the array\\n        head = array[0]\\n        for i in xrange(1, len(array)):\\n            prev = array[i-1]\\n            node = array[i]\\n            prev.next = node\\n        return head\\n```\n```python\\n# Brute Force+ Approach\\n# O(kN) = O(akN)\\n#   where N is the number of total elements\\n#   and k is the number of sorted linked lists\\n# Idea:\\n#   1) Keep a list of pointers for your position in every list\\n#       and with it\\n#       O(N)\\n#   2) Go through all k lists choosing the smallest element \\n#       and adding it to your returned linked list\\n#       updating its pointer to point to its next\\n#       repeat until all N elements have been added\\n#       (i.e. all pointers point to None)\\n#       so N iterations of O(k) search\\n#       O(kN)\\n# Best Runtime\\n# Runtime: 6968 ms, faster than 5.01% of Python online submissions for Merge k Sorted Lists.\\n# Memory Usage: 17.4 MB, less than 80.30% of Python online submissions for Merge k Sorted Lists.\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        \"\"\"\\n        :type lists: List[ListNode]\\n        :rtype: ListNode\\n        \"\"\"\\n        # validate input\\n        if not lists:\\n            return None\\n        # shortcut, just return 1st linkedlist if only a single list\\n        if len(lists) == 1:\\n            return lists[0]\\n\\n        # create a temporary head and a node pointer to track what\\n        #     elements we\\'ve added to the return list\\n        temp_head = ListNode(-1)\\n        node = temp_head\\n\\n        # while there are still linked lists with elements in them,\\n        #   choose the list with the smallest starting element\\n        #   and add that element to our return llist\\n        #   and move the list it came from\\'s pointer forward\\n        #   (note: we modify the input lists instead of keeping a pointer)\\n        while any((ll is not None for ll in lists)):\\n            smallest_val = float(\"inf\")\\n            smallest_index = None\\n            for index, ll in enumerate(lists):\\n                if ll is not None:\\n                    if ll.val < smallest_val:\\n                        smallest_val = ll.val\\n                        smallest_index = index\\n            node.next = lists[smallest_index]\\n            lists[smallest_index] = lists[smallest_index].next\\n            node = node.next\\n        # return all the items after our temporary head\\n        #     (i.e. our actual sorted list)\\n        return temp_head.next\\n```\n```\\n# Runtime: 5084 ms, faster than 5.01% of Python online submissions for Merge k Sorted Lists.\\n# Memory Usage: 17.4 MB, less than 71.21% of Python online submissions for Merge k Sorted Lists.\\n```\n```python\\n# Min Heap Approach\\n# O(Nlgk) = O(klgk + Nlgk)\\n#   where N is the number of total elements\\n#   and k is the number of sorted linked lists\\n# Idea:\\n#   We can leverage a min heap to extend the BF+ approach while\\n#   maintaing a ranking of the k minimum elements remaining in each list\\n#   without having to do unnecessary additional work recomparing nodes\\n#   we\\'ve already considered.\\n#   1) Build a min-heap of the first node of each of the k LinkedLists\\n#       O(klgk)\\n#   2) While there\\'s a queue: (note all N elements added to it in total)\\n#       a) pop the minimum element from the heap O(lgk)\\n#       b) push its next node to the heap, if it exists O(lgk)\\n#       O(Nlgk)\\n# Best Runtime\\n# Runtime: 84 ms, faster than 90.17% of Python online submissions for Merge k Sorted Lists.\\n# Memory Usage: 17.5 MB, less than 40.91% of Python online submissions for Merge k Sorted Lists.\\nimport heapq\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        \"\"\"\\n        :type lists: List[ListNode]\\n        :rtype: ListNode\\n        \"\"\"\\n        # validate input\\n        if not lists:\\n            return None\\n        # shortcut, just return 1st linkedlist if only a single list\\n        if len(lists) == 1:\\n            return lists[0]\\n\\n        # create a temporary head and a node pointer to track what\\n        #     elements we\\'ve added to the return list\\n        temp_head = ListNode(-1)\\n        node = temp_head\\n\\n        # Create a min-heap tracking the smallest elements seen so far\\n        #   (up to k elements adde)\\n        queue = []\\n        for ll in lists:\\n            if ll:\\n                heapq.heappush(queue, (ll.val, ll))\\n        \\n        # while there\\'s elts in the queue, \\n        #   pop its minimum element and add it to the return llist\\n        #   if it has a next element, add that to the priority queue in its place\\n        while queue:\\n            value, next_node = heapq.heappop(queue)\\n            node.next = next_node\\n            if next_node.next:\\n                heapq.heappush(queue, (next_node.next.val, next_node.next))\\n            node = node.next\\n        \\n        return temp_head.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 11010,
                "title": "a-solution-use-divide-and-conquer-algorithm-in-java",
                "content": "    public ListNode mergeKLists(List<ListNode> lists) {\\n            int length = lists.size() ;\\n    \\n            if(length == 0)\\n                return null ;\\n            if(length == 1){\\n                return lists.get(0) ;\\n            }\\n    \\n            int mid = (length - 1)/2 ;\\n            ListNode l1 = mergeKLists(lists.subList(0,mid + 1)) ;\\n            ListNode l2 = mergeKLists(lists.subList(mid + 1,length)) ;\\n    \\n            return mergeTowLists(l1,l2) ;\\n    \\n        }\\n    \\n        public ListNode mergeTowLists(ListNode l1 , ListNode l2){\\n            ListNode result = new ListNode(0) ;\\n            ListNode list = result ;\\n            while(l1 != null && l2 != null){\\n                if(l1.val < l2.val){\\n                    list.next = l1 ;\\n                    l1 = l1.next ;\\n                }else{\\n                    list.next = l2 ;\\n                    l2 = l2.next ;\\n                }\\n                list = list.next ;\\n            }\\n    \\n            while(l1 != null){\\n                list.next = l1 ;\\n                l1 = l1.next ;\\n                list = list.next ;\\n            }\\n    \\n            while(l2 != null){\\n                list.next = l2 ;\\n                l2 = l2.next ;\\n                list = list.next ;\\n            }\\n    \\n            return result.next ;\\n        }",
                "solutionTags": [],
                "code": "    public ListNode mergeKLists(List<ListNode> lists) {\\n            int length = lists.size() ;\\n    \\n            if(length == 0)\\n                return null ;\\n            if(length == 1){\\n                return lists.get(0) ;\\n            }\\n    \\n            int mid = (length - 1)/2 ;\\n            ListNode l1 = mergeKLists(lists.subList(0,mid + 1)) ;\\n            ListNode l2 = mergeKLists(lists.subList(mid + 1,length)) ;\\n    \\n            return mergeTowLists(l1,l2) ;\\n    \\n        }\\n    \\n        public ListNode mergeTowLists(ListNode l1 , ListNode l2){\\n            ListNode result = new ListNode(0) ;\\n            ListNode list = result ;\\n            while(l1 != null && l2 != null){\\n                if(l1.val < l2.val){\\n                    list.next = l1 ;\\n                    l1 = l1.next ;\\n                }else{\\n                    list.next = l2 ;\\n                    l2 = l2.next ;\\n                }\\n                list = list.next ;\\n            }\\n    \\n            while(l1 != null){\\n                list.next = l1 ;\\n                l1 = l1.next ;\\n                list = list.next ;\\n            }\\n    \\n            while(l2 != null){\\n                list.next = l2 ;\\n                l2 = l2.next ;\\n                list = list.next ;\\n            }\\n    \\n            return result.next ;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 1032578,
                "title": "simple-java-solution-with-explaination-4-ms-heap",
                "content": "The idea is to use minheap to store all the elements of the Lists and then just get min element one by one and start appending it to the List. here to save space we are just re-using listnode objects and add it to the heap. and later just update next pointer.\\nto save null checks dumy node is used\\n```\\n/**\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        PriorityQueue<ListNode> minHeap = new PriorityQueue<>((o1,o2)->o1.val-o2.val);\\n        ListNode dummy = new ListNode(-1);\\n        ListNode head=dummy;\\n        for(ListNode list:lists) {\\n            while(list!=null) {\\n                minHeap.add(list);\\n                list=list.next;\\n            }\\n        }\\n        while(!minHeap.isEmpty()) {\\n            dummy.next=minHeap.poll();\\n            dummy=dummy.next;\\n            dummy.next=null;\\n        }\\n        return head.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/**\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        PriorityQueue<ListNode> minHeap = new PriorityQueue<>((o1,o2)->o1.val-o2.val);\\n        ListNode dummy = new ListNode(-1);\\n        ListNode head=dummy;\\n        for(ListNode list:lists) {\\n            while(list!=null) {\\n                minHeap.add(list);\\n                list=list.next;\\n            }\\n        }\\n        while(!minHeap.isEmpty()) {\\n            dummy.next=minHeap.poll();\\n            dummy=dummy.next;\\n            dummy.next=null;\\n        }\\n        return head.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 10617,
                "title": "javascript-o-n-log-k-time-and-o-k-space-using-min-heap",
                "content": "```\\nclass Heap {\\n    constructor(comparator) {\\n        this.data = [];\\n        this.comparator = comparator || ((parent, child) => parent - child);\\n    }\\n\\n    get size() {\\n        return this.data.length;\\n    }\\n\\n    bubbleUp(c) {\\n        if (c === 0) return;\\n        const p = Math.floor((c + 1) / 2) - 1;\\n        if (this.comparator(this.data[p], this.data[c]) > 0) {\\n            [this.data[p], this.data[c]] = [this.data[c], this.data[p]];\\n        }\\n        this.bubbleUp(p);\\n    }\\n\\n    bubbleDown(p) {\\n        const c = 2 * (p + 1) - 1;\\n        if (c >= this.data.length) return;\\n\\n        const leftDelta = this.comparator(this.data[p], this.data[c]);\\n        const rightDelta = c + 1 >= this.data.length ? 0 : this.comparator(this.data[p], this.data[c + 1]);\\n        if (leftDelta <= 0 && rightDelta <= 0) return;\\n\\n        const swapChildIndex = c + (leftDelta <= rightDelta);\\n        [this.data[p], this.data[swapChildIndex]] = [this.data[swapChildIndex], this.data[p]];\\n        this.bubbleDown(swapChildIndex);\\n    }\\n\\n    add(val) {\\n        this.data.push(val);\\n        this.bubbleUp(this.data.length - 1);\\n    }\\n\\n    poll() {\\n        if (this.size < 2) return this.data.pop();\\n        [this.data[0], this.data[this.size - 1]] = [this.data[this.size - 1], this.data[0]];\\n        const val = this.data.pop();\\n        this.bubbleDown(0);\\n        return val;\\n    }\\n}\\n\\nvar mergeKLists = function(lists) {\\n    if (!lists.length) return null;\\n    \\n    const minHeap = new Heap((parent, child) => parent.val - child.val);\\n    for (let node of lists) {\\n        if (node) minHeap.add(node);\\n    }\\n    \\n    const dummy = new ListNode();\\n    let tail = dummy;\\n    while (minHeap.size) {\\n        tail.next = minHeap.poll();\\n        tail = tail.next;\\n        if (tail.next) minHeap.add(tail.next);\\n    }\\n    \\n    return dummy.next;\\n};\\n```\\nThis is O(n log k) time where n is the total number of nodes and k is the number of lists or the maximum size of the heap.\\n\\nJavaScript doesn't have built-in priority queuing, so we use a heap from scratch here. I'm considering writing a JS package to fill some of these holes for LeetCode use.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Heap {\\n    constructor(comparator) {\\n        this.data = [];\\n        this.comparator = comparator || ((parent, child) => parent - child);\\n    }\\n\\n    get size() {\\n        return this.data.length;\\n    }\\n\\n    bubbleUp(c) {\\n        if (c === 0) return;\\n        const p = Math.floor((c + 1) / 2) - 1;\\n        if (this.comparator(this.data[p], this.data[c]) > 0) {\\n            [this.data[p], this.data[c]] = [this.data[c], this.data[p]];\\n        }\\n        this.bubbleUp(p);\\n    }\\n\\n    bubbleDown(p) {\\n        const c = 2 * (p + 1) - 1;\\n        if (c >= this.data.length) return;\\n\\n        const leftDelta = this.comparator(this.data[p], this.data[c]);\\n        const rightDelta = c + 1 >= this.data.length ? 0 : this.comparator(this.data[p], this.data[c + 1]);\\n        if (leftDelta <= 0 && rightDelta <= 0) return;\\n\\n        const swapChildIndex = c + (leftDelta <= rightDelta);\\n        [this.data[p], this.data[swapChildIndex]] = [this.data[swapChildIndex], this.data[p]];\\n        this.bubbleDown(swapChildIndex);\\n    }\\n\\n    add(val) {\\n        this.data.push(val);\\n        this.bubbleUp(this.data.length - 1);\\n    }\\n\\n    poll() {\\n        if (this.size < 2) return this.data.pop();\\n        [this.data[0], this.data[this.size - 1]] = [this.data[this.size - 1], this.data[0]];\\n        const val = this.data.pop();\\n        this.bubbleDown(0);\\n        return val;\\n    }\\n}\\n\\nvar mergeKLists = function(lists) {\\n    if (!lists.length) return null;\\n    \\n    const minHeap = new Heap((parent, child) => parent.val - child.val);\\n    for (let node of lists) {\\n        if (node) minHeap.add(node);\\n    }\\n    \\n    const dummy = new ListNode();\\n    let tail = dummy;\\n    while (minHeap.size) {\\n        tail.next = minHeap.poll();\\n        tail = tail.next;\\n        if (tail.next) minHeap.add(tail.next);\\n    }\\n    \\n    return dummy.next;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 892010,
                "title": "java-divide-and-conquer-recursive-2ms-faster-than-92",
                "content": "```\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        int k = lists.length;\\n        if (k == 0) return null;\\n        \\n        return mergeKLists(lists, 0, k-1);\\n    }\\n    \\n    public ListNode mergeKLists(ListNode[] lists, int start, int end) {\\n        if (end - start == 0) return lists[start];\\n        if (end - start == 1) {\\n            return mergeLists(lists[start], lists[end]);\\n        }  \\n        \\n        int mid = start + ((end - start) / 2);\\n        ListNode listA = mergeKLists(lists, start, mid);\\n        ListNode listB = mergeKLists(lists, mid+1, end);\\n        \\n        return mergeLists(listA, listB);\\n    }\\n\\n    \\n    \\n    public ListNode mergeLists(ListNode listA, ListNode listB) {\\n        if (listA == null) return listB;\\n        if (listB == null) return listA;\\n        \\n        if (listA.val < listB.val) {\\n            listA.next = mergeLists(listA.next, listB);\\n            return listA;\\n        } \\n        else {\\n            listB.next = mergeLists(listA, listB.next);\\n            return listB;\\n        } \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        int k = lists.length;\\n        if (k == 0) return null;\\n        \\n        return mergeKLists(lists, 0, k-1);\\n    }\\n    \\n    public ListNode mergeKLists(ListNode[] lists, int start, int end) {\\n        if (end - start == 0) return lists[start];\\n        if (end - start == 1) {\\n            return mergeLists(lists[start], lists[end]);\\n        }  \\n        \\n        int mid = start + ((end - start) / 2);\\n        ListNode listA = mergeKLists(lists, start, mid);\\n        ListNode listB = mergeKLists(lists, mid+1, end);\\n        \\n        return mergeLists(listA, listB);\\n    }\\n\\n    \\n    \\n    public ListNode mergeLists(ListNode listA, ListNode listB) {\\n        if (listA == null) return listB;\\n        if (listB == null) return listA;\\n        \\n        if (listA.val < listB.val) {\\n            listA.next = mergeLists(listA.next, listB);\\n            return listA;\\n        } \\n        else {\\n            listB.next = mergeLists(listA, listB.next);\\n            return listB;\\n        } \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1663722,
                "title": "python-3-heapq-implementation-with-tips-and-tricks",
                "content": "```\\nclass Solution:\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        heap = []  # create a heap\\n        new_list = ListNode()  # dummy node\\n        \\n        counter = 0  # This counter is to add an abitrary value to the heap more below\\n        \\'\\'\\'\\n        We will be passing a tuple into the queue. Originally, I wanted to do heap.push((node.val, node))\\n        But in this case, we\\'ll get a runtime error. heapq uses the first item of an inserted tuple. If two tuples are inserted,\\n        it compares by the next item in the tuple. (1, node1) and (1, node2) will generated a TypeError. This is becuase the node\\n        class Leetcode provided does not have a __lt__ function, that is, nodes can\\'t be compared! We remedy this by setting a counter\\n        as the second item in our tuple. So instead of (node.val, node), we will input (node.val, counter, node) then increment the counter.\\n        This way, if two nodes have the same val, we get the one that entered the heap first, which will have a lower counter val. \\n        In any case if we have items like this in there: (1, 0, node1), (2, 1, node), (-1, 3, node), when we pop, we will get in order:\\n        (-1, 3, node), (1, 0, node1), (2, 1, node). So regardless the counter value, we will get the smallest items first! The counter is more\\n        like the priorit in which we get them! Hope that made sense!\\n        \\'\\'\\'\\n        for linked_list in lists:\\n            if not linked_list:\\n                continue\\n            \\n            # push all head nodes in our priority queue\\n            list_val = linked_list.val\\n            heapq.heappush(heap, (list_val, counter, linked_list))\\n            counter += 1\\n        \\n        # If we have an empty heap after pushing all heads, that means there are no nodes at all!\\n        if not heap:\\n            return None\\n        \\n        # keep popping out of the heap\\n        cur_node = new_list\\n        while heap:\\n            node_tuple = heapq.heappop(heap)\\n            node = node_tuple[2]\\n            node_next = node.next\\n            cur_node.next = node\\n            cur_node = cur_node.next\\n            \\n            # whichever node was the smallest, its next will be added to the heap, if it is not null\\n            if node_next:\\n                list_val = node_next.val\\n                new_node_tuple = (list_val, counter, node_next)\\n                heapq.heappush(heap, new_node_tuple)\\n                counter += 1\\n        \\n        # get the dummy node\\'s next. Which is the head\\n        return new_list.next\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        heap = []  # create a heap\\n        new_list = ListNode()  # dummy node\\n        \\n        counter = 0  # This counter is to add an abitrary value to the heap more below\\n        \\'\\'\\'\\n        We will be passing a tuple into the queue. Originally, I wanted to do heap.push((node.val, node))\\n        But in this case, we\\'ll get a runtime error. heapq uses the first item of an inserted tuple. If two tuples are inserted,\\n        it compares by the next item in the tuple. (1, node1) and (1, node2) will generated a TypeError. This is becuase the node\\n        class Leetcode provided does not have a __lt__ function, that is, nodes can\\'t be compared! We remedy this by setting a counter\\n        as the second item in our tuple. So instead of (node.val, node), we will input (node.val, counter, node) then increment the counter.\\n        This way, if two nodes have the same val, we get the one that entered the heap first, which will have a lower counter val. \\n        In any case if we have items like this in there: (1, 0, node1), (2, 1, node), (-1, 3, node), when we pop, we will get in order:\\n        (-1, 3, node), (1, 0, node1), (2, 1, node). So regardless the counter value, we will get the smallest items first! The counter is more\\n        like the priorit in which we get them! Hope that made sense!\\n        \\'\\'\\'\\n        for linked_list in lists:\\n            if not linked_list:\\n                continue\\n            \\n            # push all head nodes in our priority queue\\n            list_val = linked_list.val\\n            heapq.heappush(heap, (list_val, counter, linked_list))\\n            counter += 1\\n        \\n        # If we have an empty heap after pushing all heads, that means there are no nodes at all!\\n        if not heap:\\n            return None\\n        \\n        # keep popping out of the heap\\n        cur_node = new_list\\n        while heap:\\n            node_tuple = heapq.heappop(heap)\\n            node = node_tuple[2]\\n            node_next = node.next\\n            cur_node.next = node\\n            cur_node = cur_node.next\\n            \\n            # whichever node was the smallest, its next will be added to the heap, if it is not null\\n            if node_next:\\n                list_val = node_next.val\\n                new_node_tuple = (list_val, counter, node_next)\\n                heapq.heappush(heap, new_node_tuple)\\n                counter += 1\\n        \\n        # get the dummy node\\'s next. Which is the head\\n        return new_list.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 258407,
                "title": "100-java-recursive-solution",
                "content": "```\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        //edge case []\\n        if (lists.length == 0) return null;\\n        return partition(lists, 0, lists.length-1);\\n    }\\n    \\n    public ListNode partition(ListNode[] lists, int start, int end) {\\n        if (start == end) return lists[start];\\n        \\n        // start will always be less than or equal to end\\n        int mid = (start + end) / 2;\\n        ListNode l1 = partition(lists, start, mid);\\n        ListNode l2 = partition(lists, mid+1, end);\\n        return mergeTwo(l1, l2);\\n    }\\n    \\n    public ListNode mergeTwo(ListNode l1, ListNode l2) {\\n        if (l1==null) return l2;\\n        if (l2==null) return l1;\\n        \\n        if (l1.val < l2.val) {\\n            l1.next = mergeTwo(l1.next, l2);\\n            return l1;\\n        } else {\\n            l2.next = mergeTwo(l1, l2.next);\\n            return l2;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        //edge case []\\n        if (lists.length == 0) return null;\\n        return partition(lists, 0, lists.length-1);\\n    }\\n    \\n    public ListNode partition(ListNode[] lists, int start, int end) {\\n        if (start == end) return lists[start];\\n        \\n        // start will always be less than or equal to end\\n        int mid = (start + end) / 2;\\n        ListNode l1 = partition(lists, start, mid);\\n        ListNode l2 = partition(lists, mid+1, end);\\n        return mergeTwo(l1, l2);\\n    }\\n    \\n    public ListNode mergeTwo(ListNode l1, ListNode l2) {\\n        if (l1==null) return l2;\\n        if (l2==null) return l1;\\n        \\n        if (l1.val < l2.val) {\\n            l1.next = mergeTwo(l1.next, l2);\\n            return l1;\\n        } else {\\n            l2.next = mergeTwo(l1, l2.next);\\n            return l2;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 183195,
                "title": "python-heapq-solution",
                "content": "This Solution is for Python3 leetcode environment:\\n```\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        q, h = len(lists), []\\n        for i in range(q):\\n            if lists[i]:\\n                heapq.heappush(h, (lists[i].val, i, lists[i]))\\n        \\n        rhead = rtail = ListNode(0)\\n        \\n        while h:\\n            i, n = heapq.heappop(h)[1:]\\n            rtail.next = n\\n            rtail = rtail.next\\n            if n.next:\\n                heapq.heappush(h, (n.next.val, i, n.next))\\n                \\n        return rhead.next\\n\\n```\\nWe can also rewrite it in a following way:\\n```\\nclass ListNodeExtension(ListNode):\\n    def __lt__(self, other):\\n        return self.val < other.val\\n\\nclass Solution:\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        ListNode.__lt__ = ListNodeExtension.__lt__\\n        heap = []\\n        for n in lists:\\n            if n:\\n                heapq.heappush(heap, n)\\n        \\n        head = tail = ListNode(0) # Result pointers\\n        while heap:\\n            tail.next = heapq.heappop(heap)\\n            tail = tail.next\\n            if tail.next:\\n                heapq.heappush(heap, tail.next)\\n                \\n        return head.next\\n```\\n\\nPython2 Solution.\\nSince Python2 version of ListNode class here has a __lt__ method implementation, the solution gets as simple as that:\\n```\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        h = []\\n        for lst in lists:\\n            if lst:\\n                heapq.heappush(h, (lst.val, lst))\\n        \\n        rhead = rtail = ListNode(0)\\n        while h:\\n            _, n = heapq.heappop(h)\\n            rtail.next = n\\n            rtail = rtail.next\\n            if n.next:\\n                heapq.heappush(h, (n.next.val, n.next))\\n                \\n        return rhead.next\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        q, h = len(lists), []\\n        for i in range(q):\\n            if lists[i]:\\n                heapq.heappush(h, (lists[i].val, i, lists[i]))\\n        \\n        rhead = rtail = ListNode(0)\\n        \\n        while h:\\n            i, n = heapq.heappop(h)[1:]\\n            rtail.next = n\\n            rtail = rtail.next\\n            if n.next:\\n                heapq.heappush(h, (n.next.val, i, n.next))\\n                \\n        return rhead.next\\n\\n```\n```\\nclass ListNodeExtension(ListNode):\\n    def __lt__(self, other):\\n        return self.val < other.val\\n\\nclass Solution:\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        ListNode.__lt__ = ListNodeExtension.__lt__\\n        heap = []\\n        for n in lists:\\n            if n:\\n                heapq.heappush(heap, n)\\n        \\n        head = tail = ListNode(0) # Result pointers\\n        while heap:\\n            tail.next = heapq.heappop(heap)\\n            tail = tail.next\\n            if tail.next:\\n                heapq.heappush(heap, tail.next)\\n                \\n        return head.next\\n```\n```\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        h = []\\n        for lst in lists:\\n            if lst:\\n                heapq.heappush(h, (lst.val, lst))\\n        \\n        rhead = rtail = ListNode(0)\\n        while h:\\n            _, n = heapq.heappop(h)\\n            rtail.next = n\\n            rtail = rtail.next\\n            if n.next:\\n                heapq.heappush(h, (n.next.val, n.next))\\n                \\n        return rhead.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288787,
                "title": "java-easy-divide-and-conquer-similar-to-merge-sort",
                "content": "**Similar to merge sort (Divide and conquer)**\\n```\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        if (lists == null || lists.length == 0) {\\n            return null;\\n        }\\n        return divideAndConquer(lists, 0, lists.length - 1);\\n    }\\n    public ListNode divideAndConquer(ListNode[] lists,int low,int high){\\n        if(low>high)\\n            return null;\\n        if(low==high)\\n            return lists[low];\\n        int mid=low+(high-low)/2;\\n        ListNode left=divideAndConquer(lists,low,mid);\\n        ListNode right=divideAndConquer(lists,mid+1,high);\\n        return merge(left,right);\\n    }\\n    public ListNode merge(ListNode n1, ListNode n2) {\\n        ListNode dummy = new ListNode(-1);\\n        ListNode prev = dummy;\\n        while (n1!=null && n2!=null){\\n            if (n1.val<n2.val) {\\n                prev.next = n1;\\n                n1 = n1.next;\\n            }\\n            else{\\n                prev.next = n2;\\n                n2 = n2.next;\\n            }\\n            prev = prev.next;\\n        }\\n        if(n1!=null)\\n            prev.next=n1;\\n        if(n2!=null)\\n            prev.next=n2;\\n        return dummy.next;\\n    }\\n}\\n```\\n**Time Complexity: O(Nlog(k))\\nSpace Complexity: O(log(k)) as we use recursion (depth of the recursion tree)**\\n\\n![image](https://assets.leetcode.com/users/images/1bfc96ef-6cb6-4e21-a466-7bf1c9523336_1678634065.5824854.png)\\n\\n![image](https://assets.leetcode.com/users/images/658f2cdb-43a5-4c04-b850-bb85684bfe7c_1678634076.8951302.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Divide and Conquer",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        if (lists == null || lists.length == 0) {\\n            return null;\\n        }\\n        return divideAndConquer(lists, 0, lists.length - 1);\\n    }\\n    public ListNode divideAndConquer(ListNode[] lists,int low,int high){\\n        if(low>high)\\n            return null;\\n        if(low==high)\\n            return lists[low];\\n        int mid=low+(high-low)/2;\\n        ListNode left=divideAndConquer(lists,low,mid);\\n        ListNode right=divideAndConquer(lists,mid+1,high);\\n        return merge(left,right);\\n    }\\n    public ListNode merge(ListNode n1, ListNode n2) {\\n        ListNode dummy = new ListNode(-1);\\n        ListNode prev = dummy;\\n        while (n1!=null && n2!=null){\\n            if (n1.val<n2.val) {\\n                prev.next = n1;\\n                n1 = n1.next;\\n            }\\n            else{\\n                prev.next = n2;\\n                n2 = n2.next;\\n            }\\n            prev = prev.next;\\n        }\\n        if(n1!=null)\\n            prev.next=n1;\\n        if(n2!=null)\\n            prev.next=n2;\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1902441,
                "title": "100-fastest-swift-solution-time-o-n-log-k-space-o-k",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n log(k)), where n is the total number of nodes in two linked lists, and k is the number of linked lists.\\n    //   - space: O(k), where k is the number of linked l43q   QAists.\\n    \\n    func mergeKLists(_ lists: [ListNode?]) -> ListNode? {\\n        guard !lists.isEmpty else { return nil }\\n        let n = lists.count\\n        var lists = lists\\n        var interval = 1\\n        \\n        while interval < n {\\n            var i = 0\\n            while i + interval < n {\\n                lists[i] = mergeTwoLists(lists[i], lists[i + interval])\\n                i += interval * 2\\n            }\\n            interval *= 2\\n        }\\n        \\n        return lists[0]\\n    }\\n    \\n    \\n    private func mergeTwoLists(_ l1: ListNode?, _ l2: ListNode?) -> ListNode? {\\n        let dummy = ListNode(-1)\\n        var cur: ListNode? = dummy\\n        var l1 = l1\\n        var l2 = l2\\n        \\n        while l1 != nil || l2 != nil {\\n            if let l1Val = l1?.val, let l2Val = l2?.val {\\n                if l1Val < l2Val {\\n                    cur?.next = l1\\n                    l1 = l1?.next\\n                } else {\\n                    cur?.next = l2\\n                    l2 = l2?.next\\n                }\\n                \\n            } else if l1 != nil {\\n                cur?.next = l1\\n                l1 = l1?.next\\n            } else if l2 != nil {\\n                cur?.next = l2\\n                l2 = l2?.next\\n            }\\n            cur = cur?.next\\n        }\\n        \\n        return dummy.next\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n log(k)), where n is the total number of nodes in two linked lists, and k is the number of linked lists.\\n    //   - space: O(k), where k is the number of linked l43q   QAists.\\n    \\n    func mergeKLists(_ lists: [ListNode?]) -> ListNode? {\\n        guard !lists.isEmpty else { return nil }\\n        let n = lists.count\\n        var lists = lists\\n        var interval = 1\\n        \\n        while interval < n {\\n            var i = 0\\n            while i + interval < n {\\n                lists[i] = mergeTwoLists(lists[i], lists[i + interval])\\n                i += interval * 2\\n            }\\n            interval *= 2\\n        }\\n        \\n        return lists[0]\\n    }\\n    \\n    \\n    private func mergeTwoLists(_ l1: ListNode?, _ l2: ListNode?) -> ListNode? {\\n        let dummy = ListNode(-1)\\n        var cur: ListNode? = dummy\\n        var l1 = l1\\n        var l2 = l2\\n        \\n        while l1 != nil || l2 != nil {\\n            if let l1Val = l1?.val, let l2Val = l2?.val {\\n                if l1Val < l2Val {\\n                    cur?.next = l1\\n                    l1 = l1?.next\\n                } else {\\n                    cur?.next = l2\\n                    l2 = l2?.next\\n                }\\n                \\n            } else if l1 != nil {\\n                cur?.next = l1\\n                l1 = l1?.next\\n            } else if l2 != nil {\\n                cur?.next = l2\\n                l2 = l2?.next\\n            }\\n            cur = cur?.next\\n        }\\n        \\n        return dummy.next\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1284754,
                "title": "easy-c-solution-using-priority-queue",
                "content": "```\\ntypedef pair<int,ListNode *> node;\\nclass Solution\\n{\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) \\n    {\\n        priority_queue<node,vector<node>,greater<node>>q;\\n        for(int i=0;i<lists.size();i++)\\n        {\\n            if(lists[i])\\n            {\\n                q.push({lists[i]->val,lists[i]});\\n            }\\n        }\\n        ListNode *head=NULL,*tmp;\\n        while(!q.empty())\\n        {\\n            auto p=q.top();\\n            q.pop();\\n            if(!head)\\n            {\\n                head=p.second;\\n            }\\n            else\\n            {\\n                tmp->next=p.second;\\n            }\\n            tmp=p.second;\\n            if(p.second->next)\\n            {\\n                q.push({p.second->next->val,p.second->next});\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```\\n***Please upvote if you have got any help from my code.Thank you.***",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ntypedef pair<int,ListNode *> node;\\nclass Solution\\n{\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) \\n    {\\n        priority_queue<node,vector<node>,greater<node>>q;\\n        for(int i=0;i<lists.size();i++)\\n        {\\n            if(lists[i])\\n            {\\n                q.push({lists[i]->val,lists[i]});\\n            }\\n        }\\n        ListNode *head=NULL,*tmp;\\n        while(!q.empty())\\n        {\\n            auto p=q.top();\\n            q.pop();\\n            if(!head)\\n            {\\n                head=p.second;\\n            }\\n            else\\n            {\\n                tmp->next=p.second;\\n            }\\n            tmp=p.second;\\n            if(p.second->next)\\n            {\\n                q.push({p.second->next->val,p.second->next});\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 850425,
                "title": "simple-cpp-priority-queue-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    struct compare\\n    {\\n        bool operator()(ListNode* &a,ListNode* &b)\\n        {\\n            return a->val>b->val;\\n        }\\n    };\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        priority_queue<ListNode*,vector<ListNode*>,compare>minh;\\n        for(int i=0;i<lists.size();i++)\\n        {\\n           if(lists[i]!=NULL) minh.push(lists[i]);\\n        }\\n        ListNode* head=new ListNode(0);\\n        ListNode* temp=head;\\n        while(minh.size()>0)\\n        {\\n            ListNode* p=minh.top();\\n            minh.pop();\\n            temp->next=new ListNode(p->val);\\n            temp=temp->next;\\n            if(p->next!=NULL) minh.push(p->next);\\n        }\\n        return head->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct compare\\n    {\\n        bool operator()(ListNode* &a,ListNode* &b)\\n        {\\n            return a->val>b->val;\\n        }\\n    };\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        priority_queue<ListNode*,vector<ListNode*>,compare>minh;\\n        for(int i=0;i<lists.size();i++)\\n        {\\n           if(lists[i]!=NULL) minh.push(lists[i]);\\n        }\\n        ListNode* head=new ListNode(0);\\n        ListNode* temp=head;\\n        while(minh.size()>0)\\n        {\\n            ListNode* p=minh.top();\\n            minh.pop();\\n            temp->next=new ListNode(p->val);\\n            temp=temp->next;\\n            if(p->next!=NULL) minh.push(p->next);\\n        }\\n        return head->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 203549,
                "title": "python-solution",
                "content": "We first put the heads of the `k` linked lists (more precisely the tuple `(val, index)`, where `val` is the value of the node, and `index` is the index of node in `lists`) into a min-heap. We initialize a node `head`. Then we continuously pop elements from `heap` until `heap` is empty, and each time we pop an element `(val, index)`, we create a new ListNode with value `val`, and append it to the linked list with head `head`. Before popping again from `heap`, we need to add the next node in `lists[index]` to `heap` if it exists. This is achieved by the lines:\\n```\\nif lists[index].next:\\n\\tlists[index] = lists[index].next\\n\\theapq.heappush(heap, (lists[index].val, index))\\n```\\nTime complexity: `O(N log k)`, space complexity: `O(N + k)`, where `N` is the total number of nodes in the `k` linked lists.\\n```\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        \"\"\"\\n        :type lists: List[ListNode]\\n        :rtype: ListNode\\n        \"\"\"\\n        heap = [(lists[i].val, i) for i in range(len(lists)) if lists[i]]\\n        heapq.heapify(heap)\\n        head = None\\n        while heap:\\n            nex = heapq.heappop(heap)\\n            node = ListNode(nex[0])\\n            index = nex[1]\\n            if not head:\\n                head = node\\n                trav = head\\n            else:\\n                trav.next = node\\n                trav = trav.next\\n            if lists[index].next:\\n                lists[index] = lists[index].next\\n                heapq.heappush(heap, (lists[index].val, index))\\n        return head \\n```",
                "solutionTags": [],
                "code": "```\\nif lists[index].next:\\n\\tlists[index] = lists[index].next\\n\\theapq.heappush(heap, (lists[index].val, index))\\n```\n```\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        \"\"\"\\n        :type lists: List[ListNode]\\n        :rtype: ListNode\\n        \"\"\"\\n        heap = [(lists[i].val, i) for i in range(len(lists)) if lists[i]]\\n        heapq.heapify(heap)\\n        head = None\\n        while heap:\\n            nex = heapq.heappop(heap)\\n            node = ListNode(nex[0])\\n            index = nex[1]\\n            if not head:\\n                head = node\\n                trav = head\\n            else:\\n                trav.next = node\\n                trav = trav.next\\n            if lists[index].next:\\n                lists[index] = lists[index].next\\n                heapq.heappush(heap, (lists[index].val, index))\\n        return head \\n```",
                "codeTag": "Java"
            },
            {
                "id": 10552,
                "title": "python-133ms-solution",
                "content": "\\n    from operator import attrgetter\\n    \\n    class Solution:\\n        # @param a list of ListNode\\n        # @return a ListNode\\n        def mergeKLists(self, lists):\\n            sorted_list = []\\n            for head in lists:\\n                curr = head\\n                while curr is not None:\\n                    sorted_list.append(curr)\\n                    curr = curr.next\\n    \\n            sorted_list = sorted(sorted_list, key=attrgetter('val'))\\n            for i, node in enumerate(sorted_list):\\n                try:\\n                    node.next = sorted_list[i + 1]\\n                except:\\n                    node.next = None\\n    \\n            if sorted_list:\\n                return sorted_list[0]\\n            else:\\n                return None",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n    from operator import attrgetter\\n    \\n    class Solution:\\n        # @param a list of ListNode\\n        # @return a ListNode\\n        def mergeKLists(self, lists):\\n            sorted_list = []\\n            for head in lists:\\n                curr = head\\n                while curr is not None:\\n                    sorted_list.append(curr)\\n                    curr = curr.next\\n    \\n            sorted_list = sorted(sorted_list, key=attrgetter('val'))\\n            for i, node in enumerate(sorted_list):\\n                try:\\n                    node.next = sorted_list[i + 1]\\n                except:\\n                    node.next = None\\n    \\n            if sorted_list:\\n                return sorted_list[0]\\n            else:\\n                return None",
                "codeTag": "Java"
            },
            {
                "id": 3286192,
                "title": "java-easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        if (lists == null || lists.length == 0) {\\n            return null;\\n        }\\n        return mergeKListsHelper(lists, 0, lists.length - 1);\\n    }\\n    \\n    private ListNode mergeKListsHelper(ListNode[] lists, int start, int end) {\\n        if (start == end) {\\n            return lists[start];\\n        }\\n        if (start + 1 == end) {\\n            return merge(lists[start], lists[end]);\\n        }\\n        int mid = start + (end - start) / 2;\\n        ListNode left = mergeKListsHelper(lists, start, mid);\\n        ListNode right = mergeKListsHelper(lists, mid + 1, end);\\n        return merge(left, right);\\n    }\\n    \\n    private ListNode merge(ListNode l1, ListNode l2) {\\n        ListNode dummy = new ListNode(0);\\n        ListNode curr = dummy;\\n        \\n        while (l1 != null && l2 != null) {\\n            if (l1.val < l2.val) {\\n                curr.next = l1;\\n                l1 = l1.next;\\n            } else {\\n                curr.next = l2;\\n                l2 = l2.next;\\n            }\\n            curr = curr.next;\\n        }\\n        \\n        curr.next = (l1 != null) ? l1 : l2;\\n        \\n        return dummy.next;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        if (lists == null || lists.length == 0) {\\n            return null;\\n        }\\n        return mergeKListsHelper(lists, 0, lists.length - 1);\\n    }\\n    \\n    private ListNode mergeKListsHelper(ListNode[] lists, int start, int end) {\\n        if (start == end) {\\n            return lists[start];\\n        }\\n        if (start + 1 == end) {\\n            return merge(lists[start], lists[end]);\\n        }\\n        int mid = start + (end - start) / 2;\\n        ListNode left = mergeKListsHelper(lists, start, mid);\\n        ListNode right = mergeKListsHelper(lists, mid + 1, end);\\n        return merge(left, right);\\n    }\\n    \\n    private ListNode merge(ListNode l1, ListNode l2) {\\n        ListNode dummy = new ListNode(0);\\n        ListNode curr = dummy;\\n        \\n        while (l1 != null && l2 != null) {\\n            if (l1.val < l2.val) {\\n                curr.next = l1;\\n                l1 = l1.next;\\n            } else {\\n                curr.next = l2;\\n                l2 = l2.next;\\n            }\\n            curr = curr.next;\\n        }\\n        \\n        curr.next = (l1 != null) ? l1 : l2;\\n        \\n        return dummy.next;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1034920,
                "title": "c-sortedset-tuples",
                "content": "I really like the divide and conquer approach, it is probably the cleanest way to go about solving things IMO. The approach I came up with before seeing that way  was similar to the heap-based / priority queue solutions.\\n\\nThere is a slight issue trying to implement in C# that the language does not have the perfect data structure. A `SortedSet` keeps elements sorted, but does not allow duplicates without a bit of a hack. The hack being, to use a `SortedSet` of tuples, knowing that the default comparer compares elements left-to-right, returning the first inequality. For the first element of each tuple, use the value to compare, the second value is the list index that it belongs to. For example, the numbers `[1,2,3,3,2,3,4]` can be converted to `[(1,0),(2,1),(3,2),(3,3),(2,4),(3,5),(4,6)].` The `2` at index `1` will be considered less than the `2` at index `4`. With that in mind, here is my solution!\\n\\n```cs\\npublic ListNode MergeKLists(ListNode[] lists) {\\n    if (lists == null)\\n        return null;\\n\\n    var ss = new SortedSet<(int Value, int Index, ListNode Node)>();\\n    for (int i = 0; i < lists.Length; i++)\\n        if (lists[i] != null)\\n            ss.Add((lists[i].val, i, lists[i]));\\n\\n    ListNode head = new ListNode(), tail = head;\\n    while (ss.Count > 0) {\\n        var min = ss.Min;\\n        ss.Remove(min);\\n\\n        tail.next = min.Node;\\n        tail = tail.next;\\n\\n        var next = min.Node.next;\\n        if (next != null)\\n            ss.Add((next.val, min.Index, next));\\n    }\\n    return head.next;\\n}\\n```\\n\\n\\n**Update for .NET 6**\\n\\nStarting with .NET 6 we have access to a `PriorityQueue`. The above solution can be changed to take advante of the new data structure as follows:\\n\\n```cs\\npublic ListNode MergeKLists(ListNode[] lists) {\\n    if (lists == null)\\n        return null;\\n\\n    var pq = new PriorityQueue<ListNode, int>();\\n    foreach (var list in lists)\\n        if (list != null)\\n            pq.Enqueue(list, list.val);\\n\\n    ListNode head = new ListNode(), tail = head;\\n    while (pq.Count > 0) {\\n        var node = pq.Dequeue();\\n\\n        tail.next = node;\\n        tail = node;\\n\\n        if (node.next != null)\\n            pq.Enqueue(node.next, node.next.val);\\n    }\\n    return head.next;\\n}\\n```\\n\\nI also posted a divide and conquer solution here:\\n\\n* https://leetcode.com/problems/merge-k-sorted-lists/discuss/1037796/C-Divide-and-Conquer",
                "solutionTags": [
                    "C"
                ],
                "code": "```cs\\npublic ListNode MergeKLists(ListNode[] lists) {\\n    if (lists == null)\\n        return null;\\n\\n    var ss = new SortedSet<(int Value, int Index, ListNode Node)>();\\n    for (int i = 0; i < lists.Length; i++)\\n        if (lists[i] != null)\\n            ss.Add((lists[i].val, i, lists[i]));\\n\\n    ListNode head = new ListNode(), tail = head;\\n    while (ss.Count > 0) {\\n        var min = ss.Min;\\n        ss.Remove(min);\\n\\n        tail.next = min.Node;\\n        tail = tail.next;\\n\\n        var next = min.Node.next;\\n        if (next != null)\\n            ss.Add((next.val, min.Index, next));\\n    }\\n    return head.next;\\n}\\n```\n```cs\\npublic ListNode MergeKLists(ListNode[] lists) {\\n    if (lists == null)\\n        return null;\\n\\n    var pq = new PriorityQueue<ListNode, int>();\\n    foreach (var list in lists)\\n        if (list != null)\\n            pq.Enqueue(list, list.val);\\n\\n    ListNode head = new ListNode(), tail = head;\\n    while (pq.Count > 0) {\\n        var node = pq.Dequeue();\\n\\n        tail.next = node;\\n        tail = node;\\n\\n        if (node.next != null)\\n            pq.Enqueue(node.next, node.next.val);\\n    }\\n    return head.next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 258231,
                "title": "easy-understand-js-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode[]} lists\\n * @return {ListNode}\\n */\\nvar mergeKLists = function(lists) {\\n    if(lists.length===0)return null;\\n    return lists.reduce(mergeTwoLists);\\n};\\n\\nfunction mergeTwoLists(l1, l2) {\\n    let l3 = new ListNode();\\n    let curr = l3;\\n      \\n    while(l1&&l2) {\\n        if(l1.val < l2.val) {\\n          curr.next = l1\\n          l1 = l1.next;\\n        } else {\\n          curr.next = l2\\n          l2 = l2.next;\\n        }\\n        curr = curr.next;\\n      }\\n      \\n      curr.next = l1 || l2;\\n      return l3.next\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode[]} lists\\n * @return {ListNode}\\n */\\nvar mergeKLists = function(lists) {\\n    if(lists.length===0)return null;\\n    return lists.reduce(mergeTwoLists);\\n};\\n\\nfunction mergeTwoLists(l1, l2) {\\n    let l3 = new ListNode();\\n    let curr = l3;\\n      \\n    while(l1&&l2) {\\n        if(l1.val < l2.val) {\\n          curr.next = l1\\n          l1 = l1.next;\\n        } else {\\n          curr.next = l2\\n          l2 = l2.next;\\n        }\\n        curr = curr.next;\\n      }\\n      \\n      curr.next = l1 || l2;\\n      return l3.next\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 10888,
                "title": "my-accepted-java-solution-using-priorityqueue",
                "content": "    public ListNode mergeKLists(ListNode[] lists) {\\n        ListNode dummy = new ListNode(0), cur = dummy;\\n        if (lists == null || lists.length < 1) {\\n            return null;\\n        }\\n        PriorityQueue<ListNode> minHeap = new PriorityQueue<ListNode>(lists.length, new Comparator<ListNode>() {\\n            public int compare(ListNode l1, ListNode l2) {\\n                return l1.val - l2.val;\\n            }    \\n        });\\n        for (int i = 0; i < lists.length; i++) {\\n            if (lists[i] != null) {\\n                minHeap.offer(lists[i]);\\n            }\\n        }\\n        while (!minHeap.isEmpty()) {\\n            ListNode temp = minHeap.poll();\\n            cur.next = temp;\\n            if (temp.next != null) {\\n                minHeap.offer(temp.next);\\n            }\\n            cur = temp;\\n        }\\n        return dummy.next;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public ListNode mergeKLists(ListNode[] lists) {\\n        ListNode dummy = new ListNode(0), cur = dummy;\\n        if (lists == null || lists.length < 1) {\\n            return null;\\n        }\\n        PriorityQueue<ListNode> minHeap = new PriorityQueue<ListNode>(lists.length, new Comparator<ListNode>() {\\n            public int compare(ListNode l1, ListNode l2) {\\n                return l1.val - l2.val;\\n            }    \\n        });\\n        for (int i = 0; i < lists.length; i++) {\\n            if (lists[i] != null) {\\n                minHeap.offer(lists[i]);\\n            }\\n        }\\n        while (!minHeap.isEmpty()) {\\n            ListNode temp = minHeap.poll();\\n            cur.next = temp;\\n            if (temp.next != null) {\\n                minHeap.offer(temp.next);\\n            }\\n            cur = temp;\\n        }\\n        return dummy.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1937005,
                "title": "python-easy-solution-faster-than-92",
                "content": "# Please upvote if it helps!\\n## Intuitive Approachs\\n- Traverse all the linked list and store into an array\\n- Sort the array and create a new linked list using the sorted array\\n- Return the linked list\\n- That\\'s all\\n\\n```\\ndef mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        arr = []\\n        for l in lists:\\n            while l:\\n                arr.append(l.val)\\n                l = l.next\\n        \\n        arr.sort()\\n        res = ListNode(0)\\n        rNext = res\\n        for d in arr:\\n            rNext.next = ListNode(d)\\n            rNext = rNext.next\\n            \\n        return res.next\\n```\\n\\n## Leave a comment if you have any question.\\n![image](https://assets.leetcode.com/users/images/70dd5f90-c79b-4ab9-bc34-18ff03bf305d_1649697278.3938332.png)\\n",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\ndef mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        arr = []\\n        for l in lists:\\n            while l:\\n                arr.append(l.val)\\n                l = l.next\\n        \\n        arr.sort()\\n        res = ListNode(0)\\n        rNext = res\\n        for d in arr:\\n            rNext.next = ListNode(d)\\n            rNext = rNext.next\\n            \\n        return res.next\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1746156,
                "title": "easiest-solution-using-set-and-linkedlist-only",
                "content": "\\n**Simple Approach Here Is:**\\n\\n**In short:**\\n\\nGiven Vector of LinkedList Is Lists = [[1,4,5], [1,3,4], [2,6]] (Total 8 Elements (With **Repeated elements**) \\u2026 So, Store Value in **Multiset**)\\n\\n**Lists** : [[1,4,5], [1,3,4], [2,6]]\\n**MultiSet** : [1,1,2,3,4,4,5,6]\\nCreate **New LinkedList** : [1,1,2,3,4,4,5,6]\\n**Return Node** of LinkedList.\\n\\n**Full Explanation:**\\n\\nFirst Take All Element of LinkedList by LinkedList in One **Multiset** (i.e. Given Vector of LinkedList Is Lists = [[1,4,5], [1,3,4], [2,6]] So Total Element of Individual LinkedList Is 3,3 And 2 So That Our Set Has **Total** 3+3+2 = **8 Elements**. As We Know That **Set Has a property to Store Elements in Sorted Order** So Simply, We **Insert Element One by One in Set** and **Final Set Is [1,1,2,3,4,4,5,6]** So Here Our Answer Now We Only Have to **Store This Elements in One New LinkedList** and **Return Node of That LinkedList**.......Simple. **Don\\'t Forget To UpVote :)**\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        multiset<int> s;\\n        for(auto x:lists){\\n            while(x!=NULL){\\n                s.insert(x->val);\\n                x=x->next;\\n            }\\n        }\\n        ListNode *head = new ListNode(0); //head is set to zero so in last we return head->next;\\n        ListNode *temp = head;\\n        for(auto y:s){\\n            temp->next = new ListNode(y);\\n            temp=temp->next;\\n        }\\n        return head->next; //here head->next is our first node\\n    }\\n};\\n\\n```\\n\\n",
                "solutionTags": [
                    "Linked List",
                    "Merge Sort",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        multiset<int> s;\\n        for(auto x:lists){\\n            while(x!=NULL){\\n                s.insert(x->val);\\n                x=x->next;\\n            }\\n        }\\n        ListNode *head = new ListNode(0); //head is set to zero so in last we return head->next;\\n        ListNode *temp = head;\\n        for(auto y:s){\\n            temp->next = new ListNode(y);\\n            temp=temp->next;\\n        }\\n        return head->next; //here head->next is our first node\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 283278,
                "title": "ruby-all-solutions-summarized-with-complexity",
                "content": "```ruby\\nclass ListNode\\n    attr_accessor :val, :next\\n    def initialize(val)\\n        @val = val\\n        @next = nil\\n    end\\nend\\n\\n# Approach 1 (Brute-Force)\\n# @param {ListNode[]} lists\\n# @return {ListNode}\\ndef merge_k_lists(lists)\\n    nodes = []\\n    lists.each do |l|\\n        while l\\n            nodes << l\\n            l = l.next\\n        end\\n    end\\n\\n    nodes = nodes.sort_by(&:val)\\n    dummy = tmp = ListNode.new(nil)\\n    nodes.each do |node|\\n        tmp.next = node\\n        tmp = tmp.next\\n    end\\n\\n    dummy.next\\nend\\n\\n# Approach 5: Divide and Conquer (Merge Sort Way)\\n# @param {ListNode[]} lists\\n# @return {ListNode}\\ndef merge_k_lists(lists, s_idx = 0, e_idx = lists.size - 1)\\n    return if lists.empty?\\n    return lists[e_idx] if s_idx == e_idx\\n\\n    mid = (s_idx + e_idx) / 2\\n    left = merge_k_lists(lists, s_idx, mid)\\n    right = merge_k_lists(lists, mid + 1, e_idx)\\n\\n    merge_two_lists(left, right)\\nend\\n\\ndef merge_two_lists(l1, l2)\\n    dummy = curr = ListNode.new(nil)\\n\\n    while l1 || l2\\n        if (l1 && l2 && l1.val < l2.val) || !l2\\n            curr.next, l1 = l1, l1.next\\n        elsif (l1 && l2) || !l1\\n            curr.next, l2 = l2, l2.next\\n        end\\n        curr = curr.next\\n    end\\n\\n    dummy.next\\nend\\n\\n# Approach 6: Divide and Conquer Iterative\\n# @param {ListNode[]} lists\\n# @return {ListNode}\\ndef merge_k_lists(lists)\\n    k, interval = lists.size, 1\\n\\n    while interval < k\\n        0.step(k - interval, interval * 2) do |i|\\n            l, r = lists[i], lists[i + interval]\\n            lists[i] = merge_two_lists(l, r)\\n        end\\n        interval *= 2\\n    end\\n\\n    k > 0 ? lists.first : lists\\nend\\n\\ndef merge_two_lists(l1, l2)\\n    dummy = curr = ListNode.new(nil)\\n\\n    while l1 || l2\\n        if (l1 && l2 && l1.val < l2.val) || !l2\\n            curr.next, l1 = l1, l1.next\\n        elsif (l1 && l2) || !l1\\n            curr.next, l2 = l2, l2.next\\n        end\\n        curr = curr.next\\n    end\\n\\n    dummy.next\\nend\\n\\n# 23. Merge k Sorted Lists\\n# https://leetcode.com/problems/merge-k-sorted-lists/description/\\n\\n# There are 5 approaches\\n# Approach 1: Brute force, collect all nodes and sort by value. Approach from above.\\n# Time: O(nlog(n))\\n# Space: O(n)\\n\\n# Approach 2: Iterate through all the lists and take the minimum from the k lists \\n# Time: O(k * n)\\n# Space: O(1)\\n\\n# Approach 3: The comparison process can be optimized in the above process using priority queue.\\n# Time: O(nlogk)\\n# Space: O(1)\\n\\n# Approach 4: Divide and Conquer, Merge k lists k-1 times two at a time.\\n# Time: O(nk)\\n# Space: O(1)\\n\\n# Approach 5: Divide and Conquer, Merge sort way (Optimal)\\n# Time: O(nlogk)\\n# Space: O(log(k)), log(k) for stack\\n\\n# Approach 6: Divide and Conquer, Iterative\\n# Time: O(nlogk)\\n# Space: O(1)\\n```",
                "solutionTags": [],
                "code": "```ruby\\nclass ListNode\\n    attr_accessor :val, :next\\n    def initialize(val)\\n        @val = val\\n        @next = nil\\n    end\\nend\\n\\n# Approach 1 (Brute-Force)\\n# @param {ListNode[]} lists\\n# @return {ListNode}\\ndef merge_k_lists(lists)\\n    nodes = []\\n    lists.each do |l|\\n        while l\\n            nodes << l\\n            l = l.next\\n        end\\n    end\\n\\n    nodes = nodes.sort_by(&:val)\\n    dummy = tmp = ListNode.new(nil)\\n    nodes.each do |node|\\n        tmp.next = node\\n        tmp = tmp.next\\n    end\\n\\n    dummy.next\\nend\\n\\n# Approach 5: Divide and Conquer (Merge Sort Way)\\n# @param {ListNode[]} lists\\n# @return {ListNode}\\ndef merge_k_lists(lists, s_idx = 0, e_idx = lists.size - 1)\\n    return if lists.empty?\\n    return lists[e_idx] if s_idx == e_idx\\n\\n    mid = (s_idx + e_idx) / 2\\n    left = merge_k_lists(lists, s_idx, mid)\\n    right = merge_k_lists(lists, mid + 1, e_idx)\\n\\n    merge_two_lists(left, right)\\nend\\n\\ndef merge_two_lists(l1, l2)\\n    dummy = curr = ListNode.new(nil)\\n\\n    while l1 || l2\\n        if (l1 && l2 && l1.val < l2.val) || !l2\\n            curr.next, l1 = l1, l1.next\\n        elsif (l1 && l2) || !l1\\n            curr.next, l2 = l2, l2.next\\n        end\\n        curr = curr.next\\n    end\\n\\n    dummy.next\\nend\\n\\n# Approach 6: Divide and Conquer Iterative\\n# @param {ListNode[]} lists\\n# @return {ListNode}\\ndef merge_k_lists(lists)\\n    k, interval = lists.size, 1\\n\\n    while interval < k\\n        0.step(k - interval, interval * 2) do |i|\\n            l, r = lists[i], lists[i + interval]\\n            lists[i] = merge_two_lists(l, r)\\n        end\\n        interval *= 2\\n    end\\n\\n    k > 0 ? lists.first : lists\\nend\\n\\ndef merge_two_lists(l1, l2)\\n    dummy = curr = ListNode.new(nil)\\n\\n    while l1 || l2\\n        if (l1 && l2 && l1.val < l2.val) || !l2\\n            curr.next, l1 = l1, l1.next\\n        elsif (l1 && l2) || !l1\\n            curr.next, l2 = l2, l2.next\\n        end\\n        curr = curr.next\\n    end\\n\\n    dummy.next\\nend\\n\\n# 23. Merge k Sorted Lists\\n# https://leetcode.com/problems/merge-k-sorted-lists/description/\\n\\n# There are 5 approaches\\n# Approach 1: Brute force, collect all nodes and sort by value. Approach from above.\\n# Time: O(nlog(n))\\n# Space: O(n)\\n\\n# Approach 2: Iterate through all the lists and take the minimum from the k lists \\n# Time: O(k * n)\\n# Space: O(1)\\n\\n# Approach 3: The comparison process can be optimized in the above process using priority queue.\\n# Time: O(nlogk)\\n# Space: O(1)\\n\\n# Approach 4: Divide and Conquer, Merge k lists k-1 times two at a time.\\n# Time: O(nk)\\n# Space: O(1)\\n\\n# Approach 5: Divide and Conquer, Merge sort way (Optimal)\\n# Time: O(nlogk)\\n# Space: O(log(k)), log(k) for stack\\n\\n# Approach 6: Divide and Conquer, Iterative\\n# Time: O(nlogk)\\n# Space: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 222324,
                "title": "javascript",
                "content": "```\\nvar mergeKLists = function(lists) {\\n  const merge = (l1, l2) => {\\n    if (!l1 || !l2) return l1 || l2;\\n    let node = {};\\n    const root = node;\\n    while (l1 && l2) {\\n      if (l1.val <= l2.val) {\\n        node.next = l1;\\n        l1 = l1.next;\\n      } else {\\n        node.next = l2;\\n        l2 = l2.next;\\n      }\\n      node = node.next;\\n    }\\n    if (l1) node.next = l1;\\n    if (l2) node.next = l2;\\n    return root.next;\\n  }\\n  \\n  let root = lists[0];\\n  for (let i = 1; i < lists.length; i++) {\\n    root = merge(root, lists[i]);\\n  }\\n  \\n  return root || null;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar mergeKLists = function(lists) {\\n  const merge = (l1, l2) => {\\n    if (!l1 || !l2) return l1 || l2;\\n    let node = {};\\n    const root = node;\\n    while (l1 && l2) {\\n      if (l1.val <= l2.val) {\\n        node.next = l1;\\n        l1 = l1.next;\\n      } else {\\n        node.next = l2;\\n        l2 = l2.next;\\n      }\\n      node = node.next;\\n    }\\n    if (l1) node.next = l1;\\n    if (l2) node.next = l2;\\n    return root.next;\\n  }\\n  \\n  let root = lists[0];\\n  for (let i = 1; i < lists.length; i++) {\\n    root = merge(root, lists[i]);\\n  }\\n  \\n  return root || null;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 10996,
                "title": "elegan-solution-based-on-a-heap-of-lists",
                "content": "I convert the vector of lists into an heap and I use it to generate the merged list:\\n\\n    class Solution {\\n        \\n    public:\\n        \\n        ListNode *mergeKLists(vector<ListNode *> &lists) {\\n            \\n            // Begin and end of our range of elements:\\n            auto it_begin = begin(lists);\\n            auto it_end = end(lists);\\n            \\n            // Removes empty lists:\\n            it_end = remove_if(it_begin, it_end, isNull);\\n            if (it_begin == it_end) return nullptr; // All lists where empty.\\n            \\n            // Head and tail of the merged list:\\n            ListNode *head = nullptr;\\n            ListNode *tail = nullptr;\\n            \\n            // Builds a min-heap over the list of lists:\\n            make_heap(it_begin, it_end, minHeapPred);\\n            \\n            // The first element in the heap is the head of our merged list:\\n            head = tail = *it_begin;\\n            \\n            while (distance(it_begin, it_end) > 1) {\\n                \\n                // Moves the heap's front list to its back:\\n                pop_heap(it_begin, it_end, minHeapPred);\\n                \\n                // And removes one node from it:\\n                --it_end;\\n                *it_end = (*it_end)->next;\\n                \\n                // If it is not empty it inserts it back into the heap:\\n                if (*it_end) {\\n                    \\n                    ++it_end;\\n                    push_heap(it_begin, it_end, minHeapPred);\\n                }\\n                \\n                // After  the push we have our next node in front of the heap:\\n                tail->next = *it_begin;\\n                tail = tail->next;\\n            }\\n            \\n            return head;\\n        }\\n        \\n    private:\\n        \\n        // Predicate to remove all null nodes from a vector:\\n        static bool isNull(const ListNode* a) {\\n            \\n            return a == nullptr;\\n        }\\n    \\n        // Predicate to generate a min heap of list node pointers:\\n        static bool minHeapPred(const ListNode* a,\\n                                const ListNode* b) {\\n    \\n            assert(a);\\n            assert(b);\\n            \\n            return a->val > b->val;\\n        }\\n        \\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n        \\n    public:\\n        \\n        ListNode *mergeKLists(vector<ListNode *> &lists) {\\n            \\n            // Begin and end of our range of elements:\\n            auto it_begin = begin(lists);\\n            auto it_end = end(lists);\\n            \\n            // Removes empty lists:\\n            it_end = remove_if(it_begin, it_end, isNull);\\n            if (it_begin == it_end) return nullptr; // All lists where empty.\\n            \\n            // Head and tail of the merged list:\\n            ListNode *head = nullptr;\\n            ListNode *tail = nullptr;\\n            \\n            // Builds a min-heap over the list of lists:\\n            make_heap(it_begin, it_end, minHeapPred);\\n            \\n            // The first element in the heap is the head of our merged list:\\n            head = tail = *it_begin;\\n            \\n            while (distance(it_begin, it_end) > 1) {\\n                \\n                // Moves the heap's front list to its back:\\n                pop_heap(it_begin, it_end, minHeapPred);\\n                \\n                // And removes one node from it:\\n                --it_end;\\n                *it_end = (*it_end)->next;\\n                \\n                // If it is not empty it inserts it back into the heap:\\n                if (*it_end) {\\n                    \\n                    ++it_end;\\n                    push_heap(it_begin, it_end, minHeapPred);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 10849,
                "title": "8-lines-python-with-generators-and-heapq-merge",
                "content": "Solution 1\\n-\\nBuilding the new list with just the **values** from the old ones, leaving the old lists intact.\\n\\n    def mergeKLists(self, lists):\\n        def vals(node):\\n            while node:\\n                yield node.val\\n                node = node.next\\n        dummy = last = ListNode(None)\\n        for val in heapq.merge(*map(vals, lists)):\\n            last.next = last = ListNode(val)\\n        return dummy.next\\n\\n---\\n\\nSolution 2\\n-\\n\\nBuilding the new list with the **nodes** from the old ones.\\n\\n    def mergeKLists(self, lists):\\n        def gen(node):\\n            while node:\\n                yield node.val, node\\n                node = node.next\\n        dummy = last = ListNode(None)\\n        for _, last.next in heapq.merge(*map(gen, lists)):\\n            last = last.next\\n        return dummy.next",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "Solution 1\\n-\\nBuilding the new list with just the **values** from the old ones, leaving the old lists intact.\\n\\n    def mergeKLists(self, lists):\\n        def vals(node):\\n            while node:\\n                yield node.val\\n                node = node.next\\n        dummy = last = ListNode(None)\\n        for val in heapq.merge(*map(vals, lists)):\\n            last.next = last = ListNode(val)\\n        return dummy.next\\n\\n---\\n\\nSolution 2\\n-\\n\\nBuilding the new list with the **nodes** from the old ones.\\n\\n    def mergeKLists(self, lists):\\n        def gen(node):\\n            while node:\\n                yield node.val, node\\n                node = node.next\\n        dummy = last = ListNode(None)\\n        for _, last.next in heapq.merge(*map(gen, lists)):\\n            last = last.next\\n        return dummy.next",
                "codeTag": "Python3"
            },
            {
                "id": 3288425,
                "title": "c-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        vector<int>v;\\n        for(int i=0;i<lists.size();i++){\\n            while(lists[i]){\\n                v.push_back(lists[i]->val);\\n                lists[i]=lists[i]->next;\\n            }\\n        }\\n        sort(rbegin(v),rend(v));\\n        ListNode* ans=nullptr;\\n        for(int i=0;i<v.size();i++){\\n            ans=new ListNode(v[i],ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        vector<int>v;\\n        for(int i=0;i<lists.size();i++){\\n            while(lists[i]){\\n                v.push_back(lists[i]->val);\\n                lists[i]=lists[i]->next;\\n            }\\n        }\\n        sort(rbegin(v),rend(v));\\n        ListNode* ans=nullptr;\\n        for(int i=0;i<v.size();i++){\\n            ans=new ListNode(v[i],ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287717,
                "title": "merge-k-sorted-linked-lists-in-o-n-log-k-time-with-priority-queue-full-explanation",
                "content": "# Intuition\\nWe can use a min heap to store the head node of each linked list, and repeatedly extract the minimum node from the heap and append it to the output list until the heap is empty. At each step, we can add the next node in the corresponding linked list to the heap.\\n\\n# Approach\\nIn the code snippet below, we define a lambda function cmp to compare two ListNode pointers based on their val field. We create a priority_queue pq with the comparison function cmp. We then iterate over each list in lists and add its head node to pq if it\\'s not null.\\n\\nWe then create a dummy node dummy and a pointer curr to it. We repeatedly extract the minimum node from pq, append it to curr, and set curr to point to the appended node. If the extracted node has a non-null next, we add it to pq.\\n\\nFinally, we return the next pointer of dummy, which points to the first node of the merged list.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this code is O(N log k), where N is the total number of nodes in all the linked lists, and k is the number of linked lists.\\n\\n- Space complexity:\\nThe space complexity of this code is O(k), as we are storing at most k nodes in the min-heap at any given time. \\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        auto cmp = [](ListNode* a, ListNode* b) { return a->val > b->val; };\\n        priority_queue<ListNode*, vector<ListNode*>, decltype(cmp)> pq(cmp);\\n        \\n        for (auto list : lists) {\\n            if (list) pq.push(list);\\n        }\\n        \\n        ListNode dummy(0);\\n        ListNode* curr = &dummy;\\n        while (!pq.empty()) {\\n            auto node = pq.top();\\n            pq.pop();\\n            \\n            curr->next = node;\\n            curr = curr->next;\\n            \\n            if (node->next) pq.push(node->next);\\n        }\\n        \\n        return dummy.next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        auto cmp = [](ListNode* a, ListNode* b) { return a->val > b->val; };\\n        priority_queue<ListNode*, vector<ListNode*>, decltype(cmp)> pq(cmp);\\n        \\n        for (auto list : lists) {\\n            if (list) pq.push(list);\\n        }\\n        \\n        ListNode dummy(0);\\n        ListNode* curr = &dummy;\\n        while (!pq.empty()) {\\n            auto node = pq.top();\\n            pq.pop();\\n            \\n            curr->next = node;\\n            curr = curr->next;\\n            \\n            if (node->next) pq.push(node->next);\\n        }\\n        \\n        return dummy.next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2459834,
                "title": "rust-0-ms-binaryheap-functions-for-debugging-with-detailed-comments",
                "content": "This [solution](https://leetcode.com/submissions/detail/779533796/) employs *BINARY (MIN) HEAP* data structure. It demonstrated **0 ms runtime (100%)** and used **3.1 MB memory (96.02%)**. Detailed comments are provided.\\n\\n**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n\\n```\\n// 1. to implement a PRIORITY QUEUE, the BINARY HEAP data structure is chosen\\nuse std::collections::BinaryHeap;\\n\\n// 2. entire Box<ListNode> is stored in the BINARY HEAP, not just ListNode.val;\\n//    this requires implementation of Ord and PartialOrd for ListNode\\nuse std::cmp::Ordering;\\n\\nimpl PartialOrd<ListNode> for ListNode \\n{\\n    fn partial_cmp(&self, other: &ListNode) -> Option<Ordering> \\n    {\\n        other.val.partial_cmp(&self.val)     // - for MIN HEAP\\n        //self.val.partial_cmp(&other.val)   // - for MAX HEAP\\n    }\\n}\\n\\nimpl Ord for ListNode \\n{\\n    fn cmp(&self, other: &Self) -> Ordering \\n    {\\n        other.val.cmp(&self.val)             // - for MIN HEAP\\n        //self.val.cmp(&other.val)           // - for MAX HEAP\\n    }\\n}\\n\\nimpl Solution\\n{\\n    pub fn merge_k_lists(lists: Vec<Option<Box<ListNode>>>) -> Option<Box<ListNode>> \\n    {\\n        // 3. maximum heap capacity is known in advance\\n        let mut heap: BinaryHeap<Box<ListNode>> = BinaryHeap::with_capacity(lists.len());\\n\\n        // 4. initialize heap with first nodes from each ListNode\\n        for list in lists\\n        {\\n            match list\\n            {\\n                Some (node) => heap.push(node),\\n                None => {}\\n            }\\n        }\\n            \\n        // 5. initialize dummy node to reduce computations\\n        let mut dummy_node = Box::new(ListNode::new(0));\\n\\n        // 6. to further build a list of nodes, we keep track of the current node\\n        let mut curr_node = &mut dummy_node;\\n    \\n        // 7. interaction with BINARY HEAP\\n        while let Some(node) = heap.pop() \\n        {\\n            // 8. get min value from the heap\\n            let mut new_node = Box::new(ListNode::new(node.val));\\n            curr_node.next = Some(new_node);\\n            curr_node = curr_node.next.as_mut().unwrap();\\n\\n            // 9. push min.next value to heap\\n            if node.next.is_some()\\n            {\\n                heap.push(node.next.unwrap());\\n            }\\n        }\\n\\n        return dummy_node.next;\\n    }\\n}\\n```\\n\\nUseful debugging functions are also supplied.\\n```\\nfn listnode_from_vec(vec: &Vec<i32>) -> Option<Box<ListNode>>\\n{\\n    let mut dummy_node = ListNode::new(0);\\n    let mut curr = &mut dummy_node;\\n    \\n    for &v in vec\\n    {\\n        let node = ListNode::new(v);\\n        curr.next = Some(Box::new(node));\\n        curr = curr.next.as_mut().unwrap();\\n    }\\n\\n    return dummy_node.next;\\n}\\n\\nfn listnode_to_vec(listnode: &Option<Box<ListNode>>) -> Vec<i32>\\n{\\n    let mut vec: Vec<i32> = Vec::new();\\n    let mut curr = listnode;\\n    loop \\n    {\\n        match curr\\n        {\\n            Some(ref node) => vec.push(node.val),\\n            None => break\\n        }\\n        curr = &(curr.as_ref().unwrap().next);\\n    }\\n    return vec;\\n}\\n\\nfn print_listnode(listnode: &Option<Box<ListNode>>)\\n{\\n    let mut curr = listnode;\\n    loop \\n    {\\n        match curr\\n        {\\n            Some(ref node) => print!(\"{} \", node.val),\\n            None => break\\n        }\\n        curr = &(curr.as_ref().unwrap().next);\\n    }\\n    println!(\"\\\\n\");\\n}\\n```\\nUsage example:\\n```\\nfn main() \\n{\\n    let vec_1: Vec<i32> = Vec::from([1,2,6]);\\n    let vec_2: Vec<i32> = Vec::from([2,4]);\\n    let vec_3: Vec<i32> = Vec::from([-10,5,20]);\\n\\n    let l1: Option<Box<ListNode>> = listnode_from_vec(&vec_1);\\n    let l2: Option<Box<ListNode>> = listnode_from_vec(&vec_2);\\n    let l3: Option<Box<ListNode>> = listnode_from_vec(&vec_3);\\n\\n    let mut lists: Vec<Option<Box<ListNode>>> = Vec::new();\\n    lists.push(l1);\\n    lists.push(l2);\\n    lists.push(l3);\\n\\n    let sorted = Solution::merge_k_lists(lists);\\n    print_listnode(&sorted);\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n// 1. to implement a PRIORITY QUEUE, the BINARY HEAP data structure is chosen\\nuse std::collections::BinaryHeap;\\n\\n// 2. entire Box<ListNode> is stored in the BINARY HEAP, not just ListNode.val;\\n//    this requires implementation of Ord and PartialOrd for ListNode\\nuse std::cmp::Ordering;\\n\\nimpl PartialOrd<ListNode> for ListNode \\n{\\n    fn partial_cmp(&self, other: &ListNode) -> Option<Ordering> \\n    {\\n        other.val.partial_cmp(&self.val)     // - for MIN HEAP\\n        //self.val.partial_cmp(&other.val)   // - for MAX HEAP\\n    }\\n}\\n\\nimpl Ord for ListNode \\n{\\n    fn cmp(&self, other: &Self) -> Ordering \\n    {\\n        other.val.cmp(&self.val)             // - for MIN HEAP\\n        //self.val.cmp(&other.val)           // - for MAX HEAP\\n    }\\n}\\n\\nimpl Solution\\n{\\n    pub fn merge_k_lists(lists: Vec<Option<Box<ListNode>>>) -> Option<Box<ListNode>> \\n    {\\n        // 3. maximum heap capacity is known in advance\\n        let mut heap: BinaryHeap<Box<ListNode>> = BinaryHeap::with_capacity(lists.len());\\n\\n        // 4. initialize heap with first nodes from each ListNode\\n        for list in lists\\n        {\\n            match list\\n            {\\n                Some (node) => heap.push(node),\\n                None => {}\\n            }\\n        }\\n            \\n        // 5. initialize dummy node to reduce computations\\n        let mut dummy_node = Box::new(ListNode::new(0));\\n\\n        // 6. to further build a list of nodes, we keep track of the current node\\n        let mut curr_node = &mut dummy_node;\\n    \\n        // 7. interaction with BINARY HEAP\\n        while let Some(node) = heap.pop() \\n        {\\n            // 8. get min value from the heap\\n            let mut new_node = Box::new(ListNode::new(node.val));\\n            curr_node.next = Some(new_node);\\n            curr_node = curr_node.next.as_mut().unwrap();\\n\\n            // 9. push min.next value to heap\\n            if node.next.is_some()\\n            {\\n                heap.push(node.next.unwrap());\\n            }\\n        }\\n\\n        return dummy_node.next;\\n    }\\n}\\n```\n```\\nfn listnode_from_vec(vec: &Vec<i32>) -> Option<Box<ListNode>>\\n{\\n    let mut dummy_node = ListNode::new(0);\\n    let mut curr = &mut dummy_node;\\n    \\n    for &v in vec\\n    {\\n        let node = ListNode::new(v);\\n        curr.next = Some(Box::new(node));\\n        curr = curr.next.as_mut().unwrap();\\n    }\\n\\n    return dummy_node.next;\\n}\\n\\nfn listnode_to_vec(listnode: &Option<Box<ListNode>>) -> Vec<i32>\\n{\\n    let mut vec: Vec<i32> = Vec::new();\\n    let mut curr = listnode;\\n    loop \\n    {\\n        match curr\\n        {\\n            Some(ref node) => vec.push(node.val),\\n            None => break\\n        }\\n        curr = &(curr.as_ref().unwrap().next);\\n    }\\n    return vec;\\n}\\n\\nfn print_listnode(listnode: &Option<Box<ListNode>>)\\n{\\n    let mut curr = listnode;\\n    loop \\n    {\\n        match curr\\n        {\\n            Some(ref node) => print!(\"{} \", node.val),\\n            None => break\\n        }\\n        curr = &(curr.as_ref().unwrap().next);\\n    }\\n    println!(\"\\\\n\");\\n}\\n```\n```\\nfn main() \\n{\\n    let vec_1: Vec<i32> = Vec::from([1,2,6]);\\n    let vec_2: Vec<i32> = Vec::from([2,4]);\\n    let vec_3: Vec<i32> = Vec::from([-10,5,20]);\\n\\n    let l1: Option<Box<ListNode>> = listnode_from_vec(&vec_1);\\n    let l2: Option<Box<ListNode>> = listnode_from_vec(&vec_2);\\n    let l3: Option<Box<ListNode>> = listnode_from_vec(&vec_3);\\n\\n    let mut lists: Vec<Option<Box<ListNode>>> = Vec::new();\\n    lists.push(l1);\\n    lists.push(l2);\\n    lists.push(l3);\\n\\n    let sorted = Solution::merge_k_lists(lists);\\n    print_listnode(&sorted);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2087622,
                "title": "short-and-simple-pq-solution-java",
                "content": "### Logic:\\nTo merge two lists A and B, we simply need to compare A.val and B.val and iterate accordingly. What about three lists? Four? We find ourselves having k different conditions to allow for the appropriate comparissons of k lists. No matter how you do this, naively comparing nodes one at a time for k lists takes O(Nk) time. With two lists, this is fine. But there\\'s a simple way we can make these comparissons easier. \\n\\nWouldn\\'t it be nice if we had easy access to the smallest node at any given point? We can skip doing all these k comparissons if this was the case. Well turns out there is a way to simulate this! We can use a priority queue. \\n___\\n### Why a Priority Queue?:\\nPriority queues (or min-heaps) work by bubbling up the smallest value to the top of the queue. This allows us to access the smallest value in constant time. The only con is that insertion, or the act of bubbling up, takes logarithmic time. \\n\\nThis is useful for us since we can get the smallest ListNode value (and the list corresponding to that value) in just `O(logk)`. Do this N times and you have your resultant list! The first step is to chuck all the non-null heads from the input to our priority queue and work from there; polling the current ListNode from the top of the priority queue and passing in the next ListNode of that corresponding list.\\n___\\n### Code:\\nFor the priority queue to work, we must modify our priority queue to be of type ListNode and compare for type ListNode.val. \\nIf you have any questions, suggestions or improvements, feel free to let me know!\\n```java\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        int n = lists.length;\\n        if (lists == null || n == 0) return null;\\n        \\n        // Ensure our pq takes in ListNodes and compares their values.\\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((ListNode a, ListNode b) -> a.val - b.val);\\n        \\n        // Add the head of all non-null lists to the pq to begin.\\n        for (ListNode list: lists)\\n            if (list != null) pq.add(list);\\n        \\n        // Dummy node pointer to help add to our output list.\\n        ListNode ptr = new ListNode(-1);\\n        ListNode head = ptr;\\n        \\n        // 1) Get the smallest node from the PriorityQueue.\\n        // 2) Add it to our output list.\\n        // 3) Add the next node of the current list to the pq if it\\'s not null\\n        // 4) Repeat\\n        while (!pq.isEmpty()) {\\n            ListNode curr = pq.poll();\\n            ptr.next = new ListNode(curr.val);\\n            ptr = ptr.next;\\n            if (curr.next != null) pq.add(curr.next);\\n        }\\n        \\n        return head.next;\\n    }\\n}\\n```\\n**Time Complexity:** `O(nlogk)` where `n` is the total number of nodes and `k` is the number of lists.\\n**Space Complexity:** `O(n)` to create the new list (or `O(1)` extra space).",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```java\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        int n = lists.length;\\n        if (lists == null || n == 0) return null;\\n        \\n        // Ensure our pq takes in ListNodes and compares their values.\\n        PriorityQueue<ListNode> pq = new PriorityQueue<>((ListNode a, ListNode b) -> a.val - b.val);\\n        \\n        // Add the head of all non-null lists to the pq to begin.\\n        for (ListNode list: lists)\\n            if (list != null) pq.add(list);\\n        \\n        // Dummy node pointer to help add to our output list.\\n        ListNode ptr = new ListNode(-1);\\n        ListNode head = ptr;\\n        \\n        // 1) Get the smallest node from the PriorityQueue.\\n        // 2) Add it to our output list.\\n        // 3) Add the next node of the current list to the pq if it\\'s not null\\n        // 4) Repeat\\n        while (!pq.isEmpty()) {\\n            ListNode curr = pq.poll();\\n            ptr.next = new ListNode(curr.val);\\n            ptr = ptr.next;\\n            if (curr.next != null) pq.add(curr.next);\\n        }\\n        \\n        return head.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1606044,
                "title": "python-divide-and-conquer-based-on-merge-sort-easy-to-understand-solution",
                "content": "Below is a divide and conquer soution based on Merge sort.\\n\\nIn Merge sort we basically divide a list into two smaller lists. And then we divide the smaller lists further. This division of list stops when we have just one element left in the list. We stop at that time because we know single element in a list will always be sorted. Now coming to this question, each of the linked lists are sorted. So if we consider every linked list as a single entity, this becomes similar to our general merge sort. \\ne.g - \\nGiven LLs - \\n [\\t[1, 4],\\t[2, 3, 4], [5] ]\\n\\nAssume it as:\\n[\\tA,\\tB,\\tC ]  \\n\\nWe have to apply merge sort on this. So this is easy now, right? :)\\n\\nTime complexity - nklogk assuming n elements in all the k lists. or Nlogk where N is total numbers of elements in result List\\n\\n```\\nclass Solution:\\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        length = len(lists)\\n        \\n\\t\\t# The list is empty. \\n        if not length:\\n            return None\\n        # There is only one Linked list - base condition. return the Linked list as is, because this is sorted\\n        if length == 1:\\n            return lists[0]\\n        \\n        mid = length//2\\n\\t\\t# get the left sorted half and right sorted half\\n        left = self.mergeKLists(lists[0:mid])\\n        right = self.mergeKLists(lists[mid:])\\n        \\n        return self.mergeTwolists(left,right)\\n        \\n    # Merge two lists is another Leetcode question.  Visit - https://leetcode.com/problems/merge-two-sorted-lists/\\n    def mergeTwolists(self, l1, l2):\\n        tail = head = ListNode(0)        \\n        while l1 and l2:\\n            if l1.val < l2.val:\\n                tail.next = l1\\n                l1 = l1.next\\n            else:\\n                tail.next = l2\\n                l2 = l2.next\\n                \\n            tail = tail.next\\n            \\n        tail.next = l1 or l2\\n            \\n        return head.next\\n```\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution:\\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        length = len(lists)\\n        \\n\\t\\t# The list is empty. \\n        if not length:\\n            return None\\n        # There is only one Linked list - base condition. return the Linked list as is, because this is sorted\\n        if length == 1:\\n            return lists[0]\\n        \\n        mid = length//2\\n\\t\\t# get the left sorted half and right sorted half\\n        left = self.mergeKLists(lists[0:mid])\\n        right = self.mergeKLists(lists[mid:])\\n        \\n        return self.mergeTwolists(left,right)\\n        \\n    # Merge two lists is another Leetcode question.  Visit - https://leetcode.com/problems/merge-two-sorted-lists/\\n    def mergeTwolists(self, l1, l2):\\n        tail = head = ListNode(0)        \\n        while l1 and l2:\\n            if l1.val < l2.val:\\n                tail.next = l1\\n                l1 = l1.next\\n            else:\\n                tail.next = l2\\n                l2 = l2.next\\n                \\n            tail = tail.next\\n            \\n        tail.next = l1 or l2\\n            \\n        return head.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1527470,
                "title": "simple-c-solution-with-explanation",
                "content": "## Method 1 (Brute Force)\\nA simple way of doing this is to make a big list by iterating over the vector and then sorting it using any of the sorting techniques lijke merge sort or quick sort. \\n**TIme Complexity** : O(n * k) [for iterating over vector of size n and average linked list size k) + O(p * log p) [sorting the big list of size p = n * k)\\n\\n## Method 2 (Optimized)\\nAnother way of doing this is to make use of the fact that linked lists are k sorted. We\\'ll use a min priority queue. Since we know that linked list is k sorted , we first push head of all the lists in the priority queue. The minimum of these will be the first node of the list. After that we move this min node to its next (if exists) and push that next node again to the priority queue. This way we keep adding nodes to the resultant list and the moment priority queue becomes empty, we get our resulting list.\\nThe code for same is as follows :\\n\\n```\\n#define pi pair<int,ListNode *>\\n ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        int n = lists.size();\\n\\t\\t//intitalizing our resultant list\\n        ListNode *newHead = new ListNode(0);\\n        ListNode *tail = newHead;\\n        \\n\\t\\t//min ority queue which stores {node->val , node} \\n\\t\\t// that it isn arranged by node\\'s val\\n        priority_queue<pi,vector<pi>,greater<pi>> pq;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n\\t\\t\\t//pushing all non-null nodes into the priority queue\\n            if(lists[i]) pq.push({lists[i]->val , lists[i]});\\n        }\\n        \\n        \\n        while(!pq.empty())\\n        {\\n\\t\\t\\t//here we pop out the current min node present in pq\\n            ListNode *node = pq.top().second;\\n            pq.pop();\\n\\t\\t\\t//add this min node to resultant list\\n            tail->next = node;\\n            tail = tail->next;\\n            \\n\\t\\t\\t//if next of this node exist push it in pq\\n            if(node->next) pq.push({node->next->val,node->next});\\n        }\\n        \\n        //when pq becomes empty we get our required list.\\n        return newHead->next;\\n    }\\n```\\n\\n**Time Complexity :** O(k* log k) [for pushing elements in pq]  + O(N * log k) [logK for popping min node and pushing it\\'s next back, and we are doing this N times]\\n\\n**Space Complexity :** O(k) [at any momemnt pq will have max k elements]\\n",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n#define pi pair<int,ListNode *>\\n ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        int n = lists.size();\\n\\t\\t//intitalizing our resultant list\\n        ListNode *newHead = new ListNode(0);\\n        ListNode *tail = newHead;\\n        \\n\\t\\t//min ority queue which stores {node->val , node} \\n\\t\\t// that it isn arranged by node\\'s val\\n        priority_queue<pi,vector<pi>,greater<pi>> pq;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n\\t\\t\\t//pushing all non-null nodes into the priority queue\\n            if(lists[i]) pq.push({lists[i]->val , lists[i]});\\n        }\\n        \\n        \\n        while(!pq.empty())\\n        {\\n\\t\\t\\t//here we pop out the current min node present in pq\\n            ListNode *node = pq.top().second;\\n            pq.pop();\\n\\t\\t\\t//add this min node to resultant list\\n            tail->next = node;\\n            tail = tail->next;\\n            \\n\\t\\t\\t//if next of this node exist push it in pq\\n            if(node->next) pq.push({node->next->val,node->next});\\n        }\\n        \\n        //when pq becomes empty we get our required list.\\n        return newHead->next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1237414,
                "title": "c-merge-sort-like-solution-intuition",
                "content": "## Intuition\\nMerging two sorted lists is easy, so if we could somehow divide this problem into a similar structure, we could have a good solution. This is what merge sort does, in the merge step, we merge k sorted lists.\\n\\nWe pair up the k lists into k/2 pairs, with 2n/k elements on average, and then merge the pairs. Then we pass the resulting list of linked lists to a recursive call of the mergekSortedLists  function, and so on, until we reach just two linked lists, or one linked list. Then we return either the merged list in case of two lists, or just the remaining list, in  case of single list left.\\n\\nIf you are having trouble merging two sorted linked lists, here is the algorithm for it:\\n```\\nAlgorithm merge2Lists(list1, list2):\\n1. while both list1 and list2 point to a non null node:\\n\\t2. if list1.val <= list2.val add list1.val to the resulting list, and advance the list1 pointer\\n\\t3. else if list1.val > list2.val add list2.val to the resulting list and advance the list2 pointer\\n4. for any elements remaining in either of the lists:\\n\\t5. add the element to the tail of the resulting list and advance the pointer.\\n6. return the head of the result list.\\n```\\n\\n<br>\\n\\n## Code \\n```\\nListNode * merge2Lists(ListNode *l1, ListNode *l2) {\\n\\tif(!l1) return l2;\\n\\telse if(!l2) return l1;\\n\\tListNode *ptr1 = l1, *ptr2 = l2;\\n\\tListNode *l3 = new ListNode(-1);\\n\\tListNode *ptr3 = l3;\\n\\twhile(ptr1 && ptr2) {\\n\\t\\tif(ptr1->val <= ptr2->val) {\\n\\t\\t\\tptr3->next = new ListNode(ptr1->val);\\n\\t\\t\\tptr3 = ptr3->next;\\n\\t\\t\\tptr1 = ptr1->next;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tptr3->next = new ListNode(ptr2->val);\\n\\t\\t\\tptr3 = ptr3->next;\\n\\t\\t\\tptr2 = ptr2->next;\\n\\t\\t}\\n\\t}\\n\\twhile(ptr1) {\\n\\t\\tptr3->next = new ListNode(ptr1->val);\\n\\t\\tptr3 = ptr3->next;\\n\\t\\tptr1 = ptr1->next;\\n\\t}\\n\\twhile(ptr2) {\\n\\t\\tptr3->next = new ListNode(ptr2->val);\\n\\t\\tptr3 = ptr3->next;\\n\\t\\tptr2 = ptr2->next;\\n\\t}\\n\\tptr3 = l3->next;\\n\\tdelete l3;\\n\\treturn ptr3;\\n}\\nListNode* mergeKLists(vector<ListNode*>& lists) {\\n\\tint k = lists.size();\\n\\tif(k == 0) return nullptr;\\n\\telse if(k == 1) return lists[0];\\n\\telse if(k == 2) {\\n\\t\\treturn merge2Lists(lists[0], lists[1]);\\n\\t}\\n\\tvector<ListNode *> mergedLists;\\n\\tfor(int i = 0; i<k; i+=2) {\\n\\t\\tif(i<k-1) {\\n\\t\\t\\t//at least two left\\n\\t\\t\\tmergedLists.push_back(merge2Lists(lists[i], lists[i+1]));\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tmergedLists.push_back(lists[i]);\\n\\t\\t}\\n\\t}\\n\\treturn mergeKLists(mergedLists);\\n}\\n```\\n\\n<br>\\n\\n## Complexity\\n**Time: O(nlogk)** where n is the total number of elements, and k is the number of lists initially given\\n**Space: O(nlogk)** since the merging requires an extra space of O(n) for the result list and there are O(logk) calls to it.\\n<br>\\n\\n**Upvote** if you learned something from this post, and feel free to ask any doubts, or suggest any corrections/improvements in the comments.\\n",
                "solutionTags": [
                    "C",
                    "Divide and Conquer",
                    "Recursion",
                    "Merge Sort"
                ],
                "code": "```\\nAlgorithm merge2Lists(list1, list2):\\n1. while both list1 and list2 point to a non null node:\\n\\t2. if list1.val <= list2.val add list1.val to the resulting list, and advance the list1 pointer\\n\\t3. else if list1.val > list2.val add list2.val to the resulting list and advance the list2 pointer\\n4. for any elements remaining in either of the lists:\\n\\t5. add the element to the tail of the resulting list and advance the pointer.\\n6. return the head of the result list.\\n```\n```\\nListNode * merge2Lists(ListNode *l1, ListNode *l2) {\\n\\tif(!l1) return l2;\\n\\telse if(!l2) return l1;\\n\\tListNode *ptr1 = l1, *ptr2 = l2;\\n\\tListNode *l3 = new ListNode(-1);\\n\\tListNode *ptr3 = l3;\\n\\twhile(ptr1 && ptr2) {\\n\\t\\tif(ptr1->val <= ptr2->val) {\\n\\t\\t\\tptr3->next = new ListNode(ptr1->val);\\n\\t\\t\\tptr3 = ptr3->next;\\n\\t\\t\\tptr1 = ptr1->next;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tptr3->next = new ListNode(ptr2->val);\\n\\t\\t\\tptr3 = ptr3->next;\\n\\t\\t\\tptr2 = ptr2->next;\\n\\t\\t}\\n\\t}\\n\\twhile(ptr1) {\\n\\t\\tptr3->next = new ListNode(ptr1->val);\\n\\t\\tptr3 = ptr3->next;\\n\\t\\tptr1 = ptr1->next;\\n\\t}\\n\\twhile(ptr2) {\\n\\t\\tptr3->next = new ListNode(ptr2->val);\\n\\t\\tptr3 = ptr3->next;\\n\\t\\tptr2 = ptr2->next;\\n\\t}\\n\\tptr3 = l3->next;\\n\\tdelete l3;\\n\\treturn ptr3;\\n}\\nListNode* mergeKLists(vector<ListNode*>& lists) {\\n\\tint k = lists.size();\\n\\tif(k == 0) return nullptr;\\n\\telse if(k == 1) return lists[0];\\n\\telse if(k == 2) {\\n\\t\\treturn merge2Lists(lists[0], lists[1]);\\n\\t}\\n\\tvector<ListNode *> mergedLists;\\n\\tfor(int i = 0; i<k; i+=2) {\\n\\t\\tif(i<k-1) {\\n\\t\\t\\t//at least two left\\n\\t\\t\\tmergedLists.push_back(merge2Lists(lists[i], lists[i+1]));\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tmergedLists.push_back(lists[i]);\\n\\t\\t}\\n\\t}\\n\\treturn mergeKLists(mergedLists);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1034139,
                "title": "c-priority-queue-simple-and-easy-to-understand-solution",
                "content": "```\\nclass comparator{\\n    public:\\n    bool operator()(ListNode *x,ListNode *y){\\n        return (x->val>y->val);\\n    }\\n};\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        priority_queue<ListNode*,vector<ListNode*>,comparator> pq;\\n        \\n        for(int i=0;i<lists.size();i++){\\n            if(lists[i])\\n                pq.push(lists[i]);\\n        }\\n        ListNode *dummy=new ListNode(-1);\\n        ListNode *tail=dummy;\\n        \\n        while(!pq.empty()){\\n            ListNode *top=pq.top();\\n            pq.pop();\\n            tail->next=top;\\n            tail=tail->next;\\n            if(top->next)\\n                pq.push(top->next);\\n        }   \\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass comparator{\\n    public:\\n    bool operator()(ListNode *x,ListNode *y){\\n        return (x->val>y->val);\\n    }\\n};\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        priority_queue<ListNode*,vector<ListNode*>,comparator> pq;\\n        \\n        for(int i=0;i<lists.size();i++){\\n            if(lists[i])\\n                pq.push(lists[i]);\\n        }\\n        ListNode *dummy=new ListNode(-1);\\n        ListNode *tail=dummy;\\n        \\n        while(!pq.empty()){\\n            ListNode *top=pq.top();\\n            pq.pop();\\n            tail->next=top;\\n            tail=tail->next;\\n            if(top->next)\\n                pq.push(top->next);\\n        }   \\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 522375,
                "title": "c-using-priority-queue",
                "content": "By using priority queue, time complexity is `O(n log k)`, additional space complexity is `O(k)`, where `n` is the total number of nodes, `k` is the number of linked lists.\\n```c++\\n\\tListNode* mergeKLists(vector<ListNode*>& lists) {\\n        // min priority queue\\n        auto cmp = [](ListNode* a, ListNode* b){return a->val > b->val;};\\n        priority_queue<ListNode*, vector<ListNode*>, decltype(cmp)> q(cmp);\\n        \\n        for(int i = 0; i < lists.size(); i++)\\n            if(lists[i] != nullptr) \\n                q.push(lists[i]);\\n        ListNode* dummy = new ListNode(0);\\n        ListNode* cursor = dummy;\\n        while(!q.empty()){\\n            ListNode* curr = q.top();\\n            q.pop();\\n            if(curr->next != nullptr) q.push(curr->next);\\n            cursor->next = curr;\\n            cursor = curr;\\n        }\\n        return dummy->next;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```c++\\n\\tListNode* mergeKLists(vector<ListNode*>& lists) {\\n        // min priority queue\\n        auto cmp = [](ListNode* a, ListNode* b){return a->val > b->val;};\\n        priority_queue<ListNode*, vector<ListNode*>, decltype(cmp)> q(cmp);\\n        \\n        for(int i = 0; i < lists.size(); i++)\\n            if(lists[i] != nullptr) \\n                q.push(lists[i]);\\n        ListNode* dummy = new ListNode(0);\\n        ListNode* cursor = dummy;\\n        while(!q.empty()){\\n            ListNode* curr = q.top();\\n            q.pop();\\n            if(curr->next != nullptr) q.push(curr->next);\\n            cursor->next = curr;\\n            cursor = curr;\\n        }\\n        return dummy->next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 468082,
                "title": "test-cases",
                "content": "Make these work before you hit `submit`:\\n\\n```\\n[[1,4,5,9],[1,2,3,4,6]]\\n[[1,4,5],[1,3,4],[2,6]]\\n[[1,4,5],[1,3,4],[2,6],[1,2,3,4,6]]\\n[[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025]]\\n[[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4]]\\n[[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[-33,-17,-9,-3,18,25,39,44,654]]\\n[[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567]]\\n[[1,4,5],[1,3,4],[],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567]]\\n[[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[],[-88,-53,22,99,1025],[1,3,4],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567]]\\n[[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567]]\\n[[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[-33,-17,-9,-3,18,25,39,44,654],[],[1,5,567]]\\n[[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[]]\\n[[1,4,5],[],[1,3,4],[],[2,6],[],[1,2,3,4,6],[],[-88,-53,22,99,1025],[],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[]]\\n[[],[],[],[],[],[],[1,4,5],[],[],[1,3,4],[],[],[2,6],[],[],[1,2,3,4,6],[],[],[-88,-53,22,99,1025],[],[],[1,3,4],[],[],[-33,-17,-9,-3,18,25,39,44,654],[],[],[1,5,567],[],[],[]]\\n[[1,4,5],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[2,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,2,3,4,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,4,5],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[2,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,5,567],[-88,-53,22,99,1025],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[-33,-17,-9,-3,18,25,39,44,654],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,5,567]]\\n[[1,4,5],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[2,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,2,3,4,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,4,5],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[2,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,5,567],[-88,-53,22,99,1025],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[-33,-17,-9,-3,18,25,39,44,654],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,5,567],[1,4,5],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[2,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,2,3,4,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,4,5],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[2,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,5,567],[-88,-53,22,99,1025],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[-33,-17,-9,-3,18,25,39,44,654],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,5,567],[1,4,5],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[2,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,2,3,4,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,4,5],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[2,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,5,567],[-88,-53,22,99,1025],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[-33,-17,-9,-3,18,25,39,44,654],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,5,567],[1,4,5],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[2,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,2,3,4,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,4,5],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[2,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,5,567],[-88,-53,22,99,1025],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[-33,-17,-9,-3,18,25,39,44,654],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,5,567],[1,4,5],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[2,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,2,3,4,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,4,5],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[2,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,5,567],[-88,-53,22,99,1025],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[-33,-17,-9,-3,18,25,39,44,654],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,5,567],[1,4,5],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[2,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,2,3,4,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,4,5],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[2,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,5,567],[-88,-53,22,99,1025],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[-33,-17,-9,-3,18,25,39,44,654],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,5,567]]\\n```\\n",
                "solutionTags": [],
                "code": "```\\n[[1,4,5,9],[1,2,3,4,6]]\\n[[1,4,5],[1,3,4],[2,6]]\\n[[1,4,5],[1,3,4],[2,6],[1,2,3,4,6]]\\n[[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025]]\\n[[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4]]\\n[[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[-33,-17,-9,-3,18,25,39,44,654]]\\n[[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567]]\\n[[1,4,5],[1,3,4],[],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567]]\\n[[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[],[-88,-53,22,99,1025],[1,3,4],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567]]\\n[[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567]]\\n[[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[-33,-17,-9,-3,18,25,39,44,654],[],[1,5,567]]\\n[[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[]]\\n[[1,4,5],[],[1,3,4],[],[2,6],[],[1,2,3,4,6],[],[-88,-53,22,99,1025],[],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[]]\\n[[],[],[],[],[],[],[1,4,5],[],[],[1,3,4],[],[],[2,6],[],[],[1,2,3,4,6],[],[],[-88,-53,22,99,1025],[],[],[1,3,4],[],[],[-33,-17,-9,-3,18,25,39,44,654],[],[],[1,5,567],[],[],[]]\\n[[1,4,5],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[2,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,2,3,4,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,4,5],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[2,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,5,567],[-88,-53,22,99,1025],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[-33,-17,-9,-3,18,25,39,44,654],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,5,567]]\\n[[1,4,5],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[2,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,2,3,4,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,4,5],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[2,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,5,567],[-88,-53,22,99,1025],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[-33,-17,-9,-3,18,25,39,44,654],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,5,567],[1,4,5],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[2,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,2,3,4,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,4,5],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[2,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,5,567],[-88,-53,22,99,1025],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[-33,-17,-9,-3,18,25,39,44,654],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,5,567],[1,4,5],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[2,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,2,3,4,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,4,5],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[2,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,5,567],[-88,-53,22,99,1025],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[-33,-17,-9,-3,18,25,39,44,654],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,5,567],[1,4,5],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[2,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,2,3,4,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,4,5],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[2,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,5,567],[-88,-53,22,99,1025],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[-33,-17,-9,-3,18,25,39,44,654],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,5,567],[1,4,5],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[2,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,2,3,4,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,4,5],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[2,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,5,567],[-88,-53,22,99,1025],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[-33,-17,-9,-3,18,25,39,44,654],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,5,567],[1,4,5],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[2,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,2,3,4,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,4,5],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[2,6],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,5,567],[-88,-53,22,99,1025],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,3,4],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[-33,-17,-9,-3,18,25,39,44,654],[1,4,5],[1,3,4],[2,6],[1,2,3,4,6],[-88,-53,22,99,1025],[1,3,4],[],[-33,-17,-9,-3,18,25,39,44,654],[1,5,567],[1,5,567]]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3286856,
                "title": "java-solution-8ms-runtime-beginner-friendly-sorting",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI have followed the basic approach to just traverse the array `lists` and store all elements in an temporary array `l1`.\\nNow i will just sort the array and store in resultant ListNode `ans`.\\n# Complexity\\n- Time complexity: O(MN Log MN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n`M` is the length of `lists` array and `N` is the length of maximum  `linkedlist`. \\n- Space complexity: O(MN)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSince we store all the elements in an additional array. Maximum number of elements will be `M*N`. \\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n    if(lists.length == 0) return null;\\n    List<Integer> l1 = new ArrayList<>();\\n      for(ListNode arr : lists){\\n          while(arr != null){\\n              l1.add(arr.val);\\n              arr = arr.next;\\n          }\\n      }\\n      Collections.sort(l1); \\n      \\n      ListNode ans = null;\\n      ListNode temp = null;\\n      for (Integer i : l1){\\n          if(temp == null){\\n              temp = new ListNode(i);\\n              ans = temp;\\n          }\\n          else{\\n              temp.next = new ListNode(i);\\n              temp = temp.next;\\n          }\\n      }\\n      return ans;\\n    }\\n}\\n```\\n\\nIf any query or suggestions for better approach, Please do comment !!\\n\\n**PLEASE DO UPVOTE ME !!**\\n\\nThank You",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n    if(lists.length == 0) return null;\\n    List<Integer> l1 = new ArrayList<>();\\n      for(ListNode arr : lists){\\n          while(arr != null){\\n              l1.add(arr.val);\\n              arr = arr.next;\\n          }\\n      }\\n      Collections.sort(l1); \\n      \\n      ListNode ans = null;\\n      ListNode temp = null;\\n      for (Integer i : l1){\\n          if(temp == null){\\n              temp = new ListNode(i);\\n              ans = temp;\\n          }\\n          else{\\n              temp.next = new ListNode(i);\\n              temp = temp.next;\\n          }\\n      }\\n      return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2511383,
                "title": "java-solution-using-priorityqueue-with-explanation",
                "content": "# Approach : Priority Queue\\n**Algo : step-1 : Store the values of ListNode[] in PriorityQueue\\n               Step-2 : Make a new List Using these Values**\\n\\t\\t\\t\\n```\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        \\n        for(ListNode list : lists)\\n        {\\n            while(list!=null)\\n            {\\n                pq.add(list.val);\\n                list = list.next;\\n            }\\n        }\\n        \\n        ListNode ans = new ListNode(0);\\n        if(pq.size()==0) return null;\\n        else{\\n            ListNode temp = ans;\\n            while(pq.size()!=0){\\n            temp.next = new ListNode(pq.poll());\\n            temp = temp.next;\\n        }\\n    }\\n     return ans.next;   \\n  }\\n    \\n}\\n```\\t\\t\\t",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        \\n        for(ListNode list : lists)\\n        {\\n            while(list!=null)\\n            {\\n                pq.add(list.val);\\n                list = list.next;\\n            }\\n        }\\n        \\n        ListNode ans = new ListNode(0);\\n        if(pq.size()==0) return null;\\n        else{\\n            ListNode temp = ans;\\n            while(pq.size()!=0){\\n            temp.next = new ListNode(pq.poll());\\n            temp = temp.next;\\n        }\\n    }\\n     return ans.next;   \\n  }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330932,
                "title": "simple-java-solution-using-divide-and-conquer-technique-1ms",
                "content": "```\\nclass Solution {\\n    public static ListNode mergetwosll(ListNode l1, ListNode l2){\\n        if(l1 == null || l2 == null){\\n                return l1 != null ? l1 : l2;\\n            }\\n        \\n        ListNode dummy = new ListNode(-1);\\n        ListNode prev = dummy;\\n        ListNode c1 = l1;\\n        ListNode c2 = l2;\\n        \\n        while(c1 != null && c2 != null){\\n            if(c1.val < c2.val){\\n                prev.next = c1;\\n                c1 = c1.next;\\n            }\\n            else{\\n                prev.next = c2;\\n                c2 = c2.next;\\n            }\\n            prev = prev.next;\\n        }\\n        \\n        prev.next = c1 != null ? c1 : c2;\\n        \\n        return dummy.next;\\n        \\n    }\\n    \\n    public static ListNode mergeKListshelper(ListNode[] lists, int si, int ei){\\n        if(si == ei){\\n            return lists[si];\\n        }\\n        \\n        int mid = (si + ei) / 2;\\n        \\n        ListNode l1 = mergeKListshelper(lists, si, mid);\\n        ListNode l2 = mergeKListshelper(lists, mid + 1, ei);\\n        \\n        return mergetwosll(l1, l2);\\n        \\n    }\\n    \\n    public ListNode mergeKLists(ListNode[] lists) {\\n        if(lists.length == 0){\\n            return null;\\n        }\\n        \\n        return mergeKListshelper(lists, 0, lists.length - 1);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public static ListNode mergetwosll(ListNode l1, ListNode l2){\\n        if(l1 == null || l2 == null){\\n                return l1 != null ? l1 : l2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 908846,
                "title": "python-3-commented-o-n-log-k-faster-than-90-64",
                "content": "*Runtime: 96 ms, faster than 90.64% of Python3 online submissions for Merge k Sorted Lists.\\nMemory Usage: 18.8 MB, less than 12.86% of Python3 online submissions for Merge k Sorted Lists.*\\n\\n```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nimport heapq\\n\\nclass Solution:\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        if not lists:\\n            return None\\n        # initialize heap\\n        heap = [(node.val, i) for i, node in enumerate(lists) if node]\\n        heapq.heapify(heap)\\n        # initialize nodelist to return\\n        head = ListNode()\\n        node = head\\n\\t\\t# merge\\n        while heap:\\n            # pop the min from heap\\n            value, i = heapq.heappop(heap)\\n            # add node to output chain\\n            node.next = ListNode(value)\\n            node = node.next\\n            # move the pointer to the next node if there is one\\n            if lists[i].next:\\n                lists[i] = lists[i].next\\n                new_value = lists[i].val\\n\\t\\t\\t\\t# push next element into the heap\\n                heapq.heappush(heap, (new_value, i))\\n        return head.next\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nimport heapq\\n\\nclass Solution:\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        if not lists:\\n            return None\\n        # initialize heap\\n        heap = [(node.val, i) for i, node in enumerate(lists) if node]\\n        heapq.heapify(heap)\\n        # initialize nodelist to return\\n        head = ListNode()\\n        node = head\\n\\t\\t# merge\\n        while heap:\\n            # pop the min from heap\\n            value, i = heapq.heappop(heap)\\n            # add node to output chain\\n            node.next = ListNode(value)\\n            node = node.next\\n            # move the pointer to the next node if there is one\\n            if lists[i].next:\\n                lists[i] = lists[i].next\\n                new_value = lists[i].val\\n\\t\\t\\t\\t# push next element into the heap\\n                heapq.heappush(heap, (new_value, i))\\n        return head.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 858669,
                "title": "python-heap",
                "content": "```\\nfrom heapq import heappush, heappop\\n\\n\\nclass Solution:\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        \\n        h = []\\n        for i in range(len(lists)):\\n            if lists[i]:\\n                heappush(h, [lists[i].val, i])\\n                lists[i] = lists[i].next\\n        \\n        head = p = ListNode()\\n        while h:\\n            v, i = heappop(h)\\n            p.next = ListNode(v)\\n            p = p.next\\n            if lists[i]:\\n                heappush(h, [lists[i].val, i])\\n                lists[i] = lists[i].next\\n        \\n        return head.next",
                "solutionTags": [],
                "code": "```\\nfrom heapq import heappush, heappop\\n\\n\\nclass Solution:\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        \\n        h = []\\n        for i in range(len(lists)):\\n            if lists[i]:\\n                heappush(h, [lists[i].val, i])\\n                lists[i] = lists[i].next\\n        \\n        head = p = ListNode()\\n        while h:\\n            v, i = heappop(h)\\n            p.next = ListNode(v)\\n            p = p.next\\n            if lists[i]:\\n                heappush(h, [lists[i].val, i])\\n                lists[i] = lists[i].next\\n        \\n        return head.next",
                "codeTag": "Java"
            },
            {
                "id": 800817,
                "title": "javascript-3-clean-solutions",
                "content": "# Solution 1: Append the minimum node at each round\\n```javascript\\nvar mergeKLists = function(lists) {\\n    const dummyHead = new ListNode();\\n    let curr = dummyHead;\\n    \\n    function findMin(arr) {\\n        let min = Infinity;\\n        \\n        for(let node of arr) {\\n            if(!node) continue;\\n            min = Math.min(min, node.val);\\n        }\\n        return min;\\n    }\\n    \\n    while(true) {\\n        const min = findMin(lists);\\n        if(min === Infinity) return dummyHead.next;\\n        \\n        for(let i = 0; i < lists.length; i++) {\\n            if(!lists[i] || lists[i].val > min) continue; \\n            curr.next = lists[i];\\n            curr = curr.next;\\n            lists[i] = lists[i].next;\\n        }\\n    }\\n};\\n```\\n\\n# Solution 2: Divide and conquer\\n```javascript\\nvar mergeKLists = function(lists) {\\n    if(!lists.length) return null;\\n  \\n    function merge(left, right) {\\n        if(!left) return right;\\n        if(!right) return left;\\n        \\n        if(left.val < right.val) {\\n            left.next = merge(left.next, right);\\n            return left;\\n        }\\n        right.next = merge(left, right.next);\\n        return right;\\n    }\\n    \\n    function recurse(start, end) {\\n        if(start === end) return lists[start];\\n        const mid = Math.floor((start+end)/2);\\n        const left = recurse(start, mid);\\n        const right = recurse(mid+1, end);\\n        return merge(left, right);\\n    }\\n    return recurse(0, lists.length-1)\\n};\\n```\\n# Solution 3: Merge 2 lists at a time\\n```javascript\\nvar mergeKLists = function(lists) {\\n    if(!lists.length) return null;\\n    \\n    function mergeTwoLists(a, b) {\\n        const dummyHead = new ListNode();\\n        let curA = a, curB = b, curD = dummyHead;\\n        \\n        while(curA && curB) {\\n            if(curA.val < curB.val) {\\n                curD.next = curA;\\n                curA = curA.next;\\n            } else {\\n                curD.next = curB;\\n                curB = curB.next;\\n            }\\n            curD = curD.next;\\n        }\\n        if(curA) curD.next = curA;\\n        if(curB) curD.next = curB;\\n        return dummyHead.next;\\n    }\\n    \\n    while(lists.length > 1) {\\n        const a = lists.shift();\\n        const b = lists.shift();\\n        const res = mergeTwoLists(a, b);\\n        lists.push(res);\\n    }\\n    return lists[0];\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar mergeKLists = function(lists) {\\n    const dummyHead = new ListNode();\\n    let curr = dummyHead;\\n    \\n    function findMin(arr) {\\n        let min = Infinity;\\n        \\n        for(let node of arr) {\\n            if(!node) continue;\\n            min = Math.min(min, node.val);\\n        }\\n        return min;\\n    }\\n    \\n    while(true) {\\n        const min = findMin(lists);\\n        if(min === Infinity) return dummyHead.next;\\n        \\n        for(let i = 0; i < lists.length; i++) {\\n            if(!lists[i] || lists[i].val > min) continue; \\n            curr.next = lists[i];\\n            curr = curr.next;\\n            lists[i] = lists[i].next;\\n        }\\n    }\\n};\\n```\n```javascript\\nvar mergeKLists = function(lists) {\\n    if(!lists.length) return null;\\n  \\n    function merge(left, right) {\\n        if(!left) return right;\\n        if(!right) return left;\\n        \\n        if(left.val < right.val) {\\n            left.next = merge(left.next, right);\\n            return left;\\n        }\\n        right.next = merge(left, right.next);\\n        return right;\\n    }\\n    \\n    function recurse(start, end) {\\n        if(start === end) return lists[start];\\n        const mid = Math.floor((start+end)/2);\\n        const left = recurse(start, mid);\\n        const right = recurse(mid+1, end);\\n        return merge(left, right);\\n    }\\n    return recurse(0, lists.length-1)\\n};\\n```\n```javascript\\nvar mergeKLists = function(lists) {\\n    if(!lists.length) return null;\\n    \\n    function mergeTwoLists(a, b) {\\n        const dummyHead = new ListNode();\\n        let curA = a, curB = b, curD = dummyHead;\\n        \\n        while(curA && curB) {\\n            if(curA.val < curB.val) {\\n                curD.next = curA;\\n                curA = curA.next;\\n            } else {\\n                curD.next = curB;\\n                curB = curB.next;\\n            }\\n            curD = curD.next;\\n        }\\n        if(curA) curD.next = curA;\\n        if(curB) curD.next = curB;\\n        return dummyHead.next;\\n    }\\n    \\n    while(lists.length > 1) {\\n        const a = lists.shift();\\n        const b = lists.shift();\\n        const res = mergeTwoLists(a, b);\\n        lists.push(res);\\n    }\\n    return lists[0];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 622057,
                "title": "c-simple-approach-94-faster-explained",
                "content": "### For solving this problem we have followed following steps:-\\n* Traverse all the nodes one by one and and push down into a vector.\\n* Sort the vector.\\n* Store sorted node one by one into the new linked list.\\n\\n**IF YOU UNDERSTOOD THE SOLUTION, DON\\'T FORGET TO UPVOTE:)**\\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        vector<int> v;\\n        if(lists.size()==0)\\n            return NULL;\\n        for(int i=0;i<lists.size();i++)\\n        {\\n            ListNode* temp=lists[i];\\n            while(temp!=NULL)\\n            {\\n                v.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(v.size()==0)    //if there exist no node within the lists then return null.//\\n            return NULL;\\n        sort(v.begin(),v.end());\\n        ListNode* start=new ListNode(v[0]);\\n        ListNode* temp1=start;\\n        for(int i=1;i<v.size();i++)\\n        {\\n            temp1->next=new ListNode(v[i]);\\n            temp1=temp1->next;\\n        }\\n        return start;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        vector<int> v;\\n        if(lists.size()==0)\\n            return NULL;\\n        for(int i=0;i<lists.size();i++)\\n        {\\n            ListNode* temp=lists[i];\\n            while(temp!=NULL)\\n            {\\n                v.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(v.size()==0)    //if there exist no node within the lists then return null.//\\n            return NULL;\\n        sort(v.begin(),v.end());\\n        ListNode* start=new ListNode(v[0]);\\n        ListNode* temp1=start;\\n        for(int i=1;i<v.size();i++)\\n        {\\n            temp1->next=new ListNode(v[i]);\\n            temp1=temp1->next;\\n        }\\n        return start;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 434487,
                "title": "kotlin-simple-recursive-approach",
                "content": "It\\'s not the fastest approach but no extra memory is used, code it\\'s also a lot simpler to understand than other solutions.\\n```\\nfun mergeKLists(lists: Array<ListNode?>): ListNode? {\\n    return when {\\n        lists.size == 1 -> lists.first()\\n        lists.isEmpty() -> null\\n        else -> lists.reduce { l1, l2 -> merge2Lists(l1, l2) }\\n    }\\n}\\n\\nfun merge2Lists(l1: ListNode?, l2: ListNode?): ListNode? {\\n    if (l1 == null || l2 == null) {\\n        return l1 ?: l2\\n    }\\n\\n    return if (l1.`val` < l2.`val`) {\\n        l1.next = merge2Lists(l1.next, l2)\\n        l1\\n    } else {\\n        l2.next = merge2Lists(l1, l2.next)\\n        l2\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Recursion"
                ],
                "code": "```\\nfun mergeKLists(lists: Array<ListNode?>): ListNode? {\\n    return when {\\n        lists.size == 1 -> lists.first()\\n        lists.isEmpty() -> null\\n        else -> lists.reduce { l1, l2 -> merge2Lists(l1, l2) }\\n    }\\n}\\n\\nfun merge2Lists(l1: ListNode?, l2: ListNode?): ListNode? {\\n    if (l1 == null || l2 == null) {\\n        return l1 ?: l2\\n    }\\n\\n    return if (l1.`val` < l2.`val`) {\\n        l1.next = merge2Lists(l1.next, l2)\\n        l1\\n    } else {\\n        l2.next = merge2Lists(l1, l2.next)\\n        l2\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 388339,
                "title": "an-example-of-overwriting-listnode-to-make-customized-heap-happen",
                "content": "```\\ndef __lt__(self,other):\\n    return self.val<other.val\\nListNode.__lt__ = __lt__\\nclass Solution:\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        h = []\\n        for n in lists:\\n            if n:\\n                heapq.heappush(h,n)\\n        dummy = head = ListNode(0)\\n        while h:\\n            cur = heapq.heappop(h)\\n            head.next = cur\\n            head = head.next\\n            if cur and cur.next:\\n                heapq.heappush(h,cur.next)\\n        return dummy.next\\n```",
                "solutionTags": [],
                "code": "```\\ndef __lt__(self,other):\\n    return self.val<other.val\\nListNode.__lt__ = __lt__\\nclass Solution:\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        h = []\\n        for n in lists:\\n            if n:\\n                heapq.heappush(h,n)\\n        dummy = head = ListNode(0)\\n        while h:\\n            cur = heapq.heappop(h)\\n            head.next = cur\\n            head = head.next\\n            if cur and cur.next:\\n                heapq.heappush(h,cur.next)\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 265225,
                "title": "easy-python-heapq-with-listnode-in-leetcode-environment",
                "content": "```\\nimport heapq     \\nclass Solution:\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        if not lists:\\n            return None\\n        \\n        def my_lt(self, other):\\n            return self.val<other.val\\n        \\n        setattr(ListNode, \"__lt__\", my_lt)\\n        sortedList = curr = ListNode(\"Dummy\")\\n        h = []\\n        for head in lists:\\n            if head:\\n                h.append(head)\\n        heapq.heapify(h)\\n        while h:\\n            top = heapq.heappop(h)\\n            curr.next = top\\n            curr = top\\n            if top.next:\\n                heapq.heappush(h, top.next)\\n        return sortedList.next\\n```",
                "solutionTags": [],
                "code": "```\\nimport heapq     \\nclass Solution:\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        if not lists:\\n            return None\\n        \\n        def my_lt(self, other):\\n            return self.val<other.val\\n        \\n        setattr(ListNode, \"__lt__\", my_lt)\\n        sortedList = curr = ListNode(\"Dummy\")\\n        h = []\\n        for head in lists:\\n            if head:\\n                h.append(head)\\n        heapq.heapify(h)\\n        while h:\\n            top = heapq.heappop(h)\\n            curr.next = top\\n            curr = top\\n            if top.next:\\n                heapq.heappush(h, top.next)\\n        return sortedList.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 244840,
                "title": "c-4-solutions",
                "content": "The first idea is very simple: traverse the head of the k lists and pick up the one with the minimum value, append it to the merged list and update that head to the next node. Once every head of the k lists is `NULL`, we are done.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode *dummy = new ListNode(0), *cur = dummy;\\n        int n = lists.size(), min = INT_MAX, idx = 0;\\n        while (true) {\\n            for (int i = 0; i < n; i++) {\\n                if (lists[i] && lists[i] -> val < min) {\\n                    min = lists[i] -> val;\\n                    idx = i;\\n                }\\n            }\\n            if (min == INT_MAX) {\\n                break;\\n            }\\n            cur -> next = lists[idx];\\n            cur = cur -> next;\\n            lists[idx] = lists[idx] -> next;\\n            min = INT_MAX;\\n        }\\n        return dummy -> next;\\n    }\\n};\\n```\\n\\nSince you are looking for the minimum among k values, you may also want to use a `priority_queue` (a heap) to optimize this process.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode *dummy = new ListNode(0), *cur = dummy;\\n        priority_queue<pair<int, ListNode*>, vector<pair<int, ListNode*>>> pq;\\n        for (ListNode* l : lists) {\\n            if (l) {\\n                pq.push({-l -> val, l});\\n            }\\n        }\\n        while (!pq.empty()) {\\n            ListNode* node = pq.top().second;\\n            pq.pop();\\n            cur -> next = node;\\n            cur = cur -> next;\\n            node = node -> next;\\n            if (node) {\\n                pq.push({-node -> val, node});\\n            }\\n        }\\n        return dummy -> next;\\n    }\\n};\\n```\\n\\nNote that `priority_queue` is by default a max heap and when it stores a `pair`, the `first` element will be used for comparison. So I negate the value of the node when I add the pair to `pq`.\\n\\nYou may also have your custom comparator for comparing `ListNode` directly.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode *dummy = new ListNode(0), *cur = dummy;\\n        priority_queue<ListNode*, vector<ListNode*>, comapre> pq;\\n        for (ListNode* l : lists) {\\n            if (l) {\\n                pq.push(l);\\n            }\\n        }\\n        while (!pq.empty()) {\\n            ListNode* node = pq.top();\\n            pq.pop();\\n            cur -> next = node;\\n            cur = cur -> next;\\n            if (node -> next) {\\n                pq.push(node -> next);\\n            }\\n        }\\n        return dummy -> next;\\n    }\\nprivate:\\n    struct comapre {\\n        bool operator()(ListNode* l, ListNode* r) {\\n            return l -> val > r -> val;\\n        }\\n    };\\n};\\n```\\n\\nIf you have solved [Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/), you may apply that function to this problem by merging every two lists until only one is remaining.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if (lists.empty()) {\\n            return NULL;\\n        }\\n        for (int n = lists.size(); n > 1; n = (n + 1) / 2) {\\n            for (int i = 0; i < n / 2; i++) {\\n                lists[i] = mergeTwoLists(lists[i], lists[n - 1 - i]);\\n            }\\n        }\\n        return lists[0];\\n    }\\nprivate:\\n    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\\n        ListNode *dummy = new ListNode(0), *cur = dummy;\\n        while (l1 && l2) {\\n            if (l1 -> val < l2 -> val) {\\n                cur -> next = l1;\\n                l1 = l1 -> next;\\n            } else {\\n                cur -> next = l2;\\n                l2 = l2 -> next;\\n            }\\n            cur = cur -> next;\\n        }\\n        cur -> next = l1 ? l1 : l2;\\n        return dummy -> next;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode *dummy = new ListNode(0), *cur = dummy;\\n        int n = lists.size(), min = INT_MAX, idx = 0;\\n        while (true) {\\n            for (int i = 0; i < n; i++) {\\n                if (lists[i] && lists[i] -> val < min) {\\n                    min = lists[i] -> val;\\n                    idx = i;\\n                }\\n            }\\n            if (min == INT_MAX) {\\n                break;\\n            }\\n            cur -> next = lists[idx];\\n            cur = cur -> next;\\n            lists[idx] = lists[idx] -> next;\\n            min = INT_MAX;\\n        }\\n        return dummy -> next;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode *dummy = new ListNode(0), *cur = dummy;\\n        priority_queue<pair<int, ListNode*>, vector<pair<int, ListNode*>>> pq;\\n        for (ListNode* l : lists) {\\n            if (l) {\\n                pq.push({-l -> val, l});\\n            }\\n        }\\n        while (!pq.empty()) {\\n            ListNode* node = pq.top().second;\\n            pq.pop();\\n            cur -> next = node;\\n            cur = cur -> next;\\n            node = node -> next;\\n            if (node) {\\n                pq.push({-node -> val, node});\\n            }\\n        }\\n        return dummy -> next;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode *dummy = new ListNode(0), *cur = dummy;\\n        priority_queue<ListNode*, vector<ListNode*>, comapre> pq;\\n        for (ListNode* l : lists) {\\n            if (l) {\\n                pq.push(l);\\n            }\\n        }\\n        while (!pq.empty()) {\\n            ListNode* node = pq.top();\\n            pq.pop();\\n            cur -> next = node;\\n            cur = cur -> next;\\n            if (node -> next) {\\n                pq.push(node -> next);\\n            }\\n        }\\n        return dummy -> next;\\n    }\\nprivate:\\n    struct comapre {\\n        bool operator()(ListNode* l, ListNode* r) {\\n            return l -> val > r -> val;\\n        }\\n    };\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if (lists.empty()) {\\n            return NULL;\\n        }\\n        for (int n = lists.size(); n > 1; n = (n + 1) / 2) {\\n            for (int i = 0; i < n / 2; i++) {\\n                lists[i] = mergeTwoLists(lists[i], lists[n - 1 - i]);\\n            }\\n        }\\n        return lists[0];\\n    }\\nprivate:\\n    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\\n        ListNode *dummy = new ListNode(0), *cur = dummy;\\n        while (l1 && l2) {\\n            if (l1 -> val < l2 -> val) {\\n                cur -> next = l1;\\n                l1 = l1 -> next;\\n            } else {\\n                cur -> next = l2;\\n                l2 = l2 -> next;\\n            }\\n            cur = cur -> next;\\n        }\\n        cur -> next = l1 ? l1 : l2;\\n        return dummy -> next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 201087,
                "title": "8ms-in-c",
                "content": "```\\nstruct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2) {\\n    if (l1 == NULL) {\\n        return l2;\\n    }else if (l2 == NULL){\\n        return l1;\\n    }else if (l1->val < l2->val){\\n        l1->next = mergeTwoLists(l1->next, l2);\\n        return l1;\\n    }else{\\n        l2->next = mergeTwoLists(l1, l2->next);\\n        return l2;\\n    }\\n}\\n\\nstruct ListNode *mergeKLists(struct ListNode **lists, int listsSize) {\\n    if (listsSize == 0)  {\\n        return NULL;\\n    }\\n    if (listsSize == 1)   {\\n        return lists[0];\\n    }\\n    for (int i = 0,j = listsSize - 1; i < j; i++, j--) {\\n        lists[i] = mergeTwoLists(lists[i], lists[j]);\\n        listsSize--;\\n    }\\n    return mergeKLists(lists, listsSize);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstruct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2) {\\n    if (l1 == NULL) {\\n        return l2;\\n    }else if (l2 == NULL){\\n        return l1;\\n    }else if (l1->val < l2->val){\\n        l1->next = mergeTwoLists(l1->next, l2);\\n        return l1;\\n    }else{\\n        l2->next = mergeTwoLists(l1, l2->next);\\n        return l2;\\n    }\\n}\\n\\nstruct ListNode *mergeKLists(struct ListNode **lists, int listsSize) {\\n    if (listsSize == 0)  {\\n        return NULL;\\n    }\\n    if (listsSize == 1)   {\\n        return lists[0];\\n    }\\n    for (int i = 0,j = listsSize - 1; i < j; i++, j--) {\\n        lists[i] = mergeTwoLists(lists[i], lists[j]);\\n        listsSize--;\\n    }\\n    return mergeKLists(lists, listsSize);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 181149,
                "title": "python-heapq-solution",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\nimport heapq\\n\\nclass MyListNode(ListNode):\\n    def __init__(self, val, nex):\\n        self.val = val\\n        self.next = nex\\n    \\n    def __lt__(self, other):\\n        return self.val < other.val\\n\\nclass Solution:\\n    def mergeKLists(self, lists):\\n        \"\"\"\\n        :type lists: List[ListNode]\\n        :rtype: ListNode\\n        \"\"\"\\n        \\n        heap = [MyListNode(l.val, l.next) for l in lists if l is not None]\\n        heapq.heapify(heap)\\n        \\n        res = ListNode(-1)\\n        cur = res\\n        while heap:\\n            smallest = heapq.heappop(heap)\\n            if smallest.next is not None:\\n                heapq.heappush(heap, MyListNode(smallest.next.val, smallest.next.next))\\n            cur.next= smallest\\n            cur = cur.next\\n        cur.next = None\\n        return res.next\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\nimport heapq\\n\\nclass MyListNode(ListNode):\\n    def __init__(self, val, nex):\\n        self.val = val\\n        self.next = nex\\n    \\n    def __lt__(self, other):\\n        return self.val < other.val\\n\\nclass Solution:\\n    def mergeKLists(self, lists):\\n        \"\"\"\\n        :type lists: List[ListNode]\\n        :rtype: ListNode\\n        \"\"\"\\n        \\n        heap = [MyListNode(l.val, l.next) for l in lists if l is not None]\\n        heapq.heapify(heap)\\n        \\n        res = ListNode(-1)\\n        cur = res\\n        while heap:\\n            smallest = heapq.heappop(heap)\\n            if smallest.next is not None:\\n                heapq.heappush(heap, MyListNode(smallest.next.val, smallest.next.next))\\n            cur.next= smallest\\n            cur = cur.next\\n        cur.next = None\\n        return res.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 10655,
                "title": "golang-concise-solutions-priority-queue-and-using-merge-two-lists-method",
                "content": "Two ways to solve,\\n1) Use priority queue by using `container/heap` \\n\\n```\\nfunc mergeKLists(lists []*ListNode) *ListNode {\\n\\tpq := make(PQ, 0)\\n\\tfor _, node := range lists {\\n\\t\\tif node != nil {\\n\\t\\t\\tpq = append(pq, node)\\n\\t\\t}\\n\\t}\\n\\n\\tif len(pq) == 0 {\\n\\t\\treturn nil\\n\\t}\\n\\theap.Init(&pq)\\n\\n\\thead := &ListNode{}\\n\\tdummyHead := head\\n\\n\\tfor len(pq) > 0 {\\n\\t\\tmin := heap.Pop(&pq)\\n\\t\\tminNode := min.(*ListNode)\\n\\t\\thead.Next = minNode\\n\\t\\thead = head.Next\\n\\n\\t\\tif minNode.Next != nil {\\n\\t\\t\\theap.Push(&pq, minNode.Next)\\n\\t\\t}\\n\\t}\\n\\treturn dummyHead.Next\\n}\\n\\ntype PQ []*ListNode\\n\\nfunc (pq PQ) Len() int {\\n\\treturn len(pq)\\n}\\n\\nfunc (pq PQ) Swap(a, b int) {\\n\\tpq[a], pq[b] = pq[b], pq[a]\\n}\\n\\nfunc (pq PQ) Less(a, b int) bool {\\n\\treturn pq[a].Val < pq[b].Val\\n}\\n\\nfunc (pq *PQ) Push(nodeInterface interface{}) {\\n\\tnode := nodeInterface.(*ListNode)\\n\\t*pq = append(*pq, node)\\n}\\n\\nfunc (pq *PQ) Pop() interface{} {\\n\\told := *pq\\n\\tlastNode := old[len(*pq)-1]\\n\\t*pq = old[:len(*pq)-1]\\n\\treturn lastNode\\n}\\n```\\n\\n2. Apply the same algorithm as \"merge two lists\" while taking 2 lists , until we can merge all.\\n\\n```\\nfunc mergeKLists(lists []*ListNode) *ListNode {\\n\\tlistsLen := len(lists)\\n\\tif listsLen == 0 {\\n\\t\\treturn nil\\n\\t} else if listsLen == 1 {\\n\\t\\treturn lists[0]\\n\\t}\\n\\n\\tfor len(lists) > 1 {\\n\\t\\tlist1, list2 := lists[0], lists[1]\\n\\t\\tmerged := mergeLists(list1, list2)\\n\\n\\t\\tlists = lists[2:]\\n\\t\\tlists = append(lists, merged)\\n\\t}\\n\\treturn lists[0]\\n}\\n\\nfunc mergeLists(listA, listB *ListNode) *ListNode {\\n\\tres := &ListNode{}\\n\\tdummyHead := res\\n\\tfor listA != nil || listB != nil {\\n\\t\\tif listA == nil {\\n\\t\\t\\tres.Next = listB\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tif listB == nil {\\n\\t\\t\\tres.Next = listA\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\tif listA.Val < listB.Val {\\n\\t\\t\\tres.Next = listA\\n\\t\\t\\tres = res.Next\\n\\t\\t\\tlistA = listA.Next\\n\\t\\t} else {\\n\\t\\t\\tres.Next = listB\\n\\t\\t\\tres = res.Next\\n\\t\\t\\tlistB = listB.Next\\n\\t\\t}\\n\\t}\\n\\treturn dummyHead.Next\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc mergeKLists(lists []*ListNode) *ListNode {\\n\\tpq := make(PQ, 0)\\n\\tfor _, node := range lists {\\n\\t\\tif node != nil {\\n\\t\\t\\tpq = append(pq, node)\\n\\t\\t}\\n\\t}\\n\\n\\tif len(pq) == 0 {\\n\\t\\treturn nil\\n\\t}\\n\\theap.Init(&pq)\\n\\n\\thead := &ListNode{}\\n\\tdummyHead := head\\n\\n\\tfor len(pq) > 0 {\\n\\t\\tmin := heap.Pop(&pq)\\n\\t\\tminNode := min.(*ListNode)\\n\\t\\thead.Next = minNode\\n\\t\\thead = head.Next\\n\\n\\t\\tif minNode.Next != nil {\\n\\t\\t\\theap.Push(&pq, minNode.Next)\\n\\t\\t}\\n\\t}\\n\\treturn dummyHead.Next\\n}\\n\\ntype PQ []*ListNode\\n\\nfunc (pq PQ) Len() int {\\n\\treturn len(pq)\\n}\\n\\nfunc (pq PQ) Swap(a, b int) {\\n\\tpq[a], pq[b] = pq[b], pq[a]\\n}\\n\\nfunc (pq PQ) Less(a, b int) bool {\\n\\treturn pq[a].Val < pq[b].Val\\n}\\n\\nfunc (pq *PQ) Push(nodeInterface interface{}) {\\n\\tnode := nodeInterface.(*ListNode)\\n\\t*pq = append(*pq, node)\\n}\\n\\nfunc (pq *PQ) Pop() interface{} {\\n\\told := *pq\\n\\tlastNode := old[len(*pq)-1]\\n\\t*pq = old[:len(*pq)-1]\\n\\treturn lastNode\\n}\\n```\n```\\nfunc mergeKLists(lists []*ListNode) *ListNode {\\n\\tlistsLen := len(lists)\\n\\tif listsLen == 0 {\\n\\t\\treturn nil\\n\\t} else if listsLen == 1 {\\n\\t\\treturn lists[0]\\n\\t}\\n\\n\\tfor len(lists) > 1 {\\n\\t\\tlist1, list2 := lists[0], lists[1]\\n\\t\\tmerged := mergeLists(list1, list2)\\n\\n\\t\\tlists = lists[2:]\\n\\t\\tlists = append(lists, merged)\\n\\t}\\n\\treturn lists[0]\\n}\\n\\nfunc mergeLists(listA, listB *ListNode) *ListNode {\\n\\tres := &ListNode{}\\n\\tdummyHead := res\\n\\tfor listA != nil || listB != nil {\\n\\t\\tif listA == nil {\\n\\t\\t\\tres.Next = listB\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tif listB == nil {\\n\\t\\t\\tres.Next = listA\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\tif listA.Val < listB.Val {\\n\\t\\t\\tres.Next = listA\\n\\t\\t\\tres = res.Next\\n\\t\\t\\tlistA = listA.Next\\n\\t\\t} else {\\n\\t\\t\\tres.Next = listB\\n\\t\\t\\tres = res.Next\\n\\t\\t\\tlistB = listB.Next\\n\\t\\t}\\n\\t}\\n\\treturn dummyHead.Next\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 10896,
                "title": "17-line-c-solution-220ms-by-using-sortedset-as-a-priorityqueue",
                "content": "    public class NodeIndex{\\n        public ListNode Node { get; set; }\\n        public int Index { get; set; }\\n        public NodeIndex(ListNode node, int index) { Node = node; Index = index; }\\n    }\\n    public ListNode MergeKLists(ListNode[] lists) {\\n        SortedSet<NodeIndex> ss = new SortedSet<NodeIndex>(Comparer<NodeIndex>.Create((a, b) => a.Node.val == b.Node.val ? a.Index - b.Index : a.Node.val - b.Node.val));\\n        ListNode head = new ListNode(int.MinValue), p = head;\\n        for(int i = 0; i < lists.Length; i++)\\n            if(lists[i] != null) ss.Add(new NodeIndex(lists[i], i));\\n        while(ss.Count != 0){\\n            NodeIndex nextMerge = ss.Min;\\n            p.next = nextMerge.Node;\\n            p = p.next;\\n            ss.Remove(nextMerge);\\n            if((nextMerge.Node = nextMerge.Node.next) != null) ss.Add(nextMerge);\\n        }\\n        return head.next;\\n    }",
                "solutionTags": [],
                "code": "    public class NodeIndex{\\n        public ListNode Node { get; set; }\\n        public int Index { get; set; }\\n        public NodeIndex(ListNode node, int index) { Node = node; Index = index; }\\n    }\\n    public ListNode MergeKLists(ListNode[] lists) {\\n        SortedSet<NodeIndex> ss = new SortedSet<NodeIndex>(Comparer<NodeIndex>.Create((a, b) => a.Node.val == b.Node.val ? a.Index - b.Index : a.Node.val - b.Node.val));\\n        ListNode head = new ListNode(int.MinValue), p = head;\\n        for(int i = 0; i < lists.Length; i++)\\n            if(lists[i] != null) ss.Add(new NodeIndex(lists[i], i));\\n        while(ss.Count != 0){\\n            NodeIndex nextMerge = ss.Min;\\n            p.next = nextMerge.Node;\\n            p = p.next;\\n            ss.Remove(nextMerge);\\n            if((nextMerge.Node = nextMerge.Node.next) != null) ss.Add(nextMerge);\\n        }\\n        return head.next;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 10983,
                "title": "python-solutions-in-divide-and-conquer-and-heapq",
                "content": "Divide and conquer:\\n\\n    \\n    def mergeKLists(self, lists):\\n        if not lists:\\n            return None\\n            \\n        sentinel = ListNode('0')\\n        while len(lists) > 1:\\n            merged = []\\n            while len(lists) > 1:\\n                merged.append(self.merge(lists.pop(), lists.pop(), sentinel))\\n            lists += merged\\n        return lists[0]\\n        \\n        \\n    def merge(self, x, y, s):\\n        current = s\\n        while x and y:\\n            if x.val < y.val:\\n                current.next = x\\n                x = x.next\\n            else:\\n                current.next = y\\n                y = y.next\\n            current = current.next\\n        current.next = x if x else y\\n        return s.next\\n\\n\\nHeap:\\n \\n    def mergeKLists(self, lists):\\n        current = sentinel = ListNode(0)\\n        lists = [(i.val, i) for i in lists if i]\\n        heapq.heapify(lists)\\n        while lists:\\n            current.next = heapq.heappop(lists)[1]\\n            current = current.next\\n            if current.next:\\n                heapq.heappush(lists, (current.next.val, current.next))\\n        return sentinel.next",
                "solutionTags": [
                    "Python",
                    "Divide and Conquer"
                ],
                "code": "Divide and conquer:\\n\\n    \\n    def mergeKLists(self, lists):\\n        if not lists:\\n            return None\\n            \\n        sentinel = ListNode('0')\\n        while len(lists) > 1:\\n            merged = []\\n            while len(lists) > 1:\\n                merged.append(self.merge(lists.pop(), lists.pop(), sentinel))\\n            lists += merged\\n        return lists[0]\\n        \\n        \\n    def merge(self, x, y, s):\\n        current = s\\n        while x and y:\\n            if x.val < y.val:\\n                current.next = x\\n                x = x.next\\n            else:\\n                current.next = y\\n                y = y.next\\n            current = current.next\\n        current.next = x if x else y\\n        return s.next\\n\\n\\nHeap:\\n \\n    def mergeKLists(self, lists):\\n        current = sentinel = ListNode(0)\\n        lists = [(i.val, i) for i in lists if i]\\n        heapq.heapify(lists)\\n        while lists:\\n            current.next = heapq.heappop(lists)[1]\\n            current = current.next\\n            if current.next:\\n                heapq.heappush(lists, (current.next.val, current.next))\\n        return sentinel.next",
                "codeTag": "Python3"
            },
            {
                "id": 3288414,
                "title": "python-easy-intuitive-approach",
                "content": "# Intuition\\nSince the constraints were:\\n* length of lists, $$k = 10^4$$\\n* length of each linked lists say $$n = 500$$\\n \\nIt was not a difficult choice to go for time complexity of $$O(kn)$$ \\n\\nAs we will get a TLE in python (generally) if we try to exceed $$O(10^8)$$.\\nBut our solution takes $$O(10^4 * 500) < O(10^8)$$\\n\\n\\n\\n# Approach\\n1. We will iterate through the lists and use the first element of each linked list to find the minimum among them, which will take $$O(k)$$ as length of list is $$k$$.\\n2. We will follow step 1 till all the linked lists are completely explored. We will be able to do it in $$O(n)$$ time as length of any listed list is upper bounded by $$n$$.\\n\\n# Complexity\\n- Time complexity: $$O(kn)$$ as both step 1 and step 2 are performed simultaneously.\\n\\n- Space complexity: $$O(n)$$ to create a new linked list whose length is upper bounded by n.\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution:\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        \\n        l = ListNode() # the new list that we want to return\\n        t = l # taking a temporary copy of the new list as we need to move to next pointers to store data.\\n\\n        # get the minimum front value of all linked lists in the input list.\\n        def get_min():\\n            min_val, min_indx = float(\\'inf\\'), -1\\n            for i in range(len(lists)):\\n                if lists[i] != None and lists[i].val < min_val:\\n                    min_val = lists[i].val\\n                    min_indx = i\\n            if min_indx != -1:\\n                # when a min value is found, \\n                # increment the linked list \\n                # so that we don\\'t consider the same min value the next time \\n                # and also the next value of linked list comes at the front\\n                lists[min_indx] = lists[min_indx].next\\n            return min_val\\n        \\n        while(1):\\n            x = get_min() # get the mim value to add to new list\\n            if (x == float(\\'inf\\')): \\n                # if min value is not obtained that means all the linked lists are traversed so break\\n                break\\n            c = ListNode(val=x)\\n            t.next = c\\n            t = t.next\\n        return l.next # as we made l to be just a head for our actual linked list\\n        \\n\\n\\n\\n\\n        \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution:\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        \\n        l = ListNode() # the new list that we want to return\\n        t = l # taking a temporary copy of the new list as we need to move to next pointers to store data.\\n\\n        # get the minimum front value of all linked lists in the input list.\\n        def get_min():\\n            min_val, min_indx = float(\\'inf\\'), -1\\n            for i in range(len(lists)):\\n                if lists[i] != None and lists[i].val < min_val:\\n                    min_val = lists[i].val\\n                    min_indx = i\\n            if min_indx != -1:\\n                # when a min value is found, \\n                # increment the linked list \\n                # so that we don\\'t consider the same min value the next time \\n                # and also the next value of linked list comes at the front\\n                lists[min_indx] = lists[min_indx].next\\n            return min_val\\n        \\n        while(1):\\n            x = get_min() # get the mim value to add to new list\\n            if (x == float(\\'inf\\')): \\n                # if min value is not obtained that means all the linked lists are traversed so break\\n                break\\n            c = ListNode(val=x)\\n            t.next = c\\n            t = t.next\\n        return l.next # as we made l to be just a head for our actual linked list\\n        \\n\\n\\n\\n\\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286229,
                "title": "best-solution-c",
                "content": "Beats >98% of submissions in time\\n\\n# C++ Code\\n``` C++ []\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if (lists.empty()) {\\n            return nullptr;\\n        }\\n        return mergeKListsHelper(lists, 0, lists.size() - 1);\\n    }\\n    \\n    ListNode* mergeKListsHelper(vector<ListNode*>& lists, int start, int end) {\\n        if (start == end) {\\n            return lists[start];\\n        }\\n        if (start + 1 == end) {\\n            return merge(lists[start], lists[end]);\\n        }\\n        int mid = start + (end - start) / 2;\\n        ListNode* left = mergeKListsHelper(lists, start, mid);\\n        ListNode* right = mergeKListsHelper(lists, mid + 1, end);\\n        return merge(left, right);\\n    }\\n    \\n    ListNode* merge(ListNode* l1, ListNode* l2) {\\n        ListNode* dummy = new ListNode(0);\\n        ListNode* curr = dummy;\\n        \\n        while (l1 && l2) {\\n            if (l1->val < l2->val) {\\n                curr->next = l1;\\n                l1 = l1->next;\\n            } else {\\n                curr->next = l2;\\n                l2 = l2->next;\\n            }\\n            curr = curr->next;\\n        }\\n        \\n        curr->next = l1 ? l1 : l2;\\n        \\n        return dummy->next;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if (lists.empty()) {\\n            return nullptr;\\n        }\\n        return mergeKListsHelper(lists, 0, lists.size() - 1);\\n    }\\n    \\n    ListNode* mergeKListsHelper(vector<ListNode*>& lists, int start, int end) {\\n        if (start == end) {\\n            return lists[start];\\n        }\\n        if (start + 1 == end) {\\n            return merge(lists[start], lists[end]);\\n        }\\n        int mid = start + (end - start) / 2;\\n        ListNode* left = mergeKListsHelper(lists, start, mid);\\n        ListNode* right = mergeKListsHelper(lists, mid + 1, end);\\n        return merge(left, right);\\n    }\\n    \\n    ListNode* merge(ListNode* l1, ListNode* l2) {\\n        ListNode* dummy = new ListNode(0);\\n        ListNode* curr = dummy;\\n        \\n        while (l1 && l2) {\\n            if (l1->val < l2->val) {\\n                curr->next = l1;\\n                l1 = l1->next;\\n            } else {\\n                curr->next = l2;\\n                l2 = l2->next;\\n            }\\n            curr = curr->next;\\n        }\\n        \\n        curr->next = l1 ? l1 : l2;\\n        \\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3285913,
                "title": "stepwise-explanation-with-images-simple-priorityqueue",
                "content": "![image](https://assets.leetcode.com/users/images/c65c1ac8-cedd-48eb-b93b-c236b31ffffc_1678584072.5289342.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists)\\n    {\\n        //min heap based on Node value, the minimum value will be at the top in priority queue\\n        priority_queue<pair<int, ListNode*>, vector<pair<int, ListNode*>>, greater<pair<int, ListNode*>>> pq;\\n        for (ListNode* listHead : lists) \\n        {\\n            if (listHead != NULL) pq.push({listHead->val, listHead});\\n        }\\n        //=================================================================================\\n        ListNode* newHead = new ListNode(-1); //dummy node for the new Linked List\\n        ListNode* newTail = newHead;\\n        while(!pq.empty())\\n        {\\n            int minVal = pq.top().first;\\n            ListNode* minNode = pq.top().second;\\n            pq.pop();\\n            if (minNode->next != NULL) \\n                pq.push({minNode->next->val, minNode->next});\\n            \\n            newTail->next = minNode;  //append the min Node to the new Linked List\\n            newTail = minNode; //make the minNode as the new tail of new Linked List\\n        }\\n        //=======================================================================================\\n        return newHead->next;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists)\\n    {\\n        //min heap based on Node value, the minimum value will be at the top in priority queue\\n        priority_queue<pair<int, ListNode*>, vector<pair<int, ListNode*>>, greater<pair<int, ListNode*>>> pq;\\n        for (ListNode* listHead : lists) \\n        {\\n            if (listHead != NULL) pq.push({listHead->val, listHead});\\n        }\\n        //=================================================================================\\n        ListNode* newHead = new ListNode(-1); //dummy node for the new Linked List\\n        ListNode* newTail = newHead;\\n        while(!pq.empty())\\n        {\\n            int minVal = pq.top().first;\\n            ListNode* minNode = pq.top().second;\\n            pq.pop();\\n            if (minNode->next != NULL) \\n                pq.push({minNode->next->val, minNode->next});\\n            \\n            newTail->next = minNode;  //append the min Node to the new Linked List\\n            newTail = minNode; //make the minNode as the new tail of new Linked List\\n        }\\n        //=======================================================================================\\n        return newHead->next;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3099666,
                "title": "efficient-solution-97-o-nlogk-o-1",
                "content": "# Approach\\nLet **pN - n\\'th pointer**\\n1. lists = [p1, p2, p3, p4, p5, p6, p7]\\n2. lists = [p1, null, p3, null, p5, null, p7]\\nmerge lists[i] with lists[i + 1] and save in lists[i]\\nand set counter **cnt** that will be actual positions iterator.\\nWe just swap lists[i] and lists[cnt] every iteration **swap(lists[i])**.\\nIf there was odd number of lists, then just leave it,\\nwe will merge it when there will be even number of elements in lists.\\n2. [p1, p3, p5, p7, null, null, null]\\n**cnt = 3, lists[cnt] = p7.**\\nActually we dont need to set nullptr to trash elements (lists[i], where i is odd), i wrote null just for explanation.\\n2. [p1, null, p5, null, null, null, null]\\n3. [p1, p5, null, null, null, null, null]\\n4. [p1, null, null, null, null, null, null]\\n**So p1 is answer.**\\n\\n# Complexity\\n- Time complexity:\\nO(n*log(k))\\nn - lists number, k - max nodes in list\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // O(nlogk) - time complexity\\n    // O(1) - memory complexity\\n    ListNode* mergeKLists(std::vector<ListNode*>& lists) {\\n        int n = static_cast<int>(lists.size());\\n        if (!n || n == 1 && lists.front() == nullptr) return nullptr;\\n        ListNode* last = nullptr;\\n        while(n > 1) {\\n            int cnt = 0;\\n            for(int i = 0; i < n - 1; i+=2) {\\n                lists[i] = merge2Lists(lists[i], lists[i + 1]);\\n                swap(lists[i], lists[cnt]);\\n                ++cnt;\\n            }\\n            swap(lists[n-1], lists[cnt]);\\n            n = n/2 + n%2;\\n        }\\n        return lists.front();\\n    }\\n\\n    ListNode* merge2Lists(ListNode* l1, ListNode* l2) {\\n        start = nullptr;\\n        if (l1 && l2) {\\n            if (l1->val < l2->val) {\\n                start = l1;\\n                l1 = l1->next;\\n            } else {\\n                start = l2;\\n                l2 = l2->next;\\n            }\\n        } else if (l1) { return l1; }\\n        else if (l2) { return l2; }\\n        else return nullptr;\\n        ListNode* cur = start;\\n        while(true) {\\n            if (l1 && l2) {\\n                if (l1->val < l2->val) {\\n                    cur->next = l1;\\n                    cur = cur->next;\\n                    l1 = l1->next;\\n                } else {\\n                    cur->next = l2;\\n                    cur = cur->next;\\n                    l2 = l2->next;\\n                }\\n            } else if (l1) {\\n                cur->next = l1;\\n                break;\\n            } else if (l2) {\\n                cur->next = l2;\\n                break;\\n            } else break;\\n        }\\n        return start;\\n    }\\n    ListNode* start = nullptr;\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // O(nlogk) - time complexity\\n    // O(1) - memory complexity\\n    ListNode* mergeKLists(std::vector<ListNode*>& lists) {\\n        int n = static_cast<int>(lists.size());\\n        if (!n || n == 1 && lists.front() == nullptr) return nullptr;\\n        ListNode* last = nullptr;\\n        while(n > 1) {\\n            int cnt = 0;\\n            for(int i = 0; i < n - 1; i+=2) {\\n                lists[i] = merge2Lists(lists[i], lists[i + 1]);\\n                swap(lists[i], lists[cnt]);\\n                ++cnt;\\n            }\\n            swap(lists[n-1], lists[cnt]);\\n            n = n/2 + n%2;\\n        }\\n        return lists.front();\\n    }\\n\\n    ListNode* merge2Lists(ListNode* l1, ListNode* l2) {\\n        start = nullptr;\\n        if (l1 && l2) {\\n            if (l1->val < l2->val) {\\n                start = l1;\\n                l1 = l1->next;\\n            } else {\\n                start = l2;\\n                l2 = l2->next;\\n            }\\n        } else if (l1) { return l1; }\\n        else if (l2) { return l2; }\\n        else return nullptr;\\n        ListNode* cur = start;\\n        while(true) {\\n            if (l1 && l2) {\\n                if (l1->val < l2->val) {\\n                    cur->next = l1;\\n                    cur = cur->next;\\n                    l1 = l1->next;\\n                } else {\\n                    cur->next = l2;\\n                    cur = cur->next;\\n                    l2 = l2->next;\\n                }\\n            } else if (l1) {\\n                cur->next = l1;\\n                break;\\n            } else if (l2) {\\n                cur->next = l2;\\n                break;\\n            } else break;\\n        }\\n        return start;\\n    }\\n    ListNode* start = nullptr;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1049884,
                "title": "java-priorityqueue-minheap-clean-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        \\n        // Initiate a minheap based on the val of the node\\n        PriorityQueue<ListNode> queue = new PriorityQueue<>((a, b) -> a.val - b.val);\\n        \\n        // put the first node of every list into queue\\n        for (ListNode node : lists) {\\n            if (node == null) continue;\\n            queue.add(node);\\n        }\\n        \\n        // dummy head to carry the result\\n        ListNode dummyHead = new ListNode(0);\\n        ListNode curr = dummyHead;\\n        \\n        // link the root of minheap to he dummyHead, add the root.next to the minheap, repeate this process untill minheap runs out of nodes\\n        while(!queue.isEmpty()) {\\n            curr.next = queue.poll();\\n            curr = curr.next;\\n            if (curr.next != null) queue.add(curr.next);\\n        }\\n        \\n        return dummyHead.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        \\n        // Initiate a minheap based on the val of the node\\n        PriorityQueue<ListNode> queue = new PriorityQueue<>((a, b) -> a.val - b.val);\\n        \\n        // put the first node of every list into queue\\n        for (ListNode node : lists) {\\n            if (node == null) continue;\\n            queue.add(node);\\n        }\\n        \\n        // dummy head to carry the result\\n        ListNode dummyHead = new ListNode(0);\\n        ListNode curr = dummyHead;\\n        \\n        // link the root of minheap to he dummyHead, add the root.next to the minheap, repeate this process untill minheap runs out of nodes\\n        while(!queue.isEmpty()) {\\n            curr.next = queue.poll();\\n            curr = curr.next;\\n            if (curr.next != null) queue.add(curr.next);\\n        }\\n        \\n        return dummyHead.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 560894,
                "title": "python-3-simple-solution-using-array-beats-97",
                "content": "```\\nclass Solution:\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        if not lists: return \\n        result=[]\\n        for i in lists:\\n            while i:\\n                result.append(i.val)\\n                i=i.next\\n        if not result: return\\n        result.sort()\\n        head=ListNode(result.pop(0))\\n        m=head\\n        while result:\\n            m.next=ListNode(result.pop(0))\\n            m=m.next\\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        if not lists: return \\n        result=[]\\n        for i in lists:\\n            while i:\\n                result.append(i.val)\\n                i=i.next\\n        if not result: return\\n        result.sort()\\n        head=ListNode(result.pop(0))\\n        m=head\\n        while result:\\n            m.next=ListNode(result.pop(0))\\n            m=m.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 507469,
                "title": "python-using-min-heap-or-sort",
                "content": "**Min Heap**\\n```\\nfrom heapq import heappop, heappush\\n\\nclass Solution:\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        values, head, pointer = [], None, None\\n        \\n        for l in lists:\\n            while l:\\n                heappush(values, l.val)\\n                l = l.next\\n        \\n        while values:\\n            if head == None:\\n                head = ListNode(heappop(values))\\n                pointer = head\\n            else:\\n                pointer.next = ListNode(heappop(values))\\n                pointer = pointer.next\\n        \\n        return head\\n```\\n\\n\\n**Sort**\\n```\\nclass Solution:\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        values, head, pointer = [], None, None\\n        \\n        for l in lists:\\n            while l:\\n                values.append(l.val)\\n                l = l.next\\n                \\n        values.sort()\\n        \\n        while values:\\n            if head == None:\\n                head = ListNode(values.pop(0))\\n                pointer = head\\n            else:\\n                pointer.next = ListNode(values.pop(0))\\n                pointer = pointer.next\\n        \\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom heapq import heappop, heappush\\n\\nclass Solution:\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        values, head, pointer = [], None, None\\n        \\n        for l in lists:\\n            while l:\\n                heappush(values, l.val)\\n                l = l.next\\n        \\n        while values:\\n            if head == None:\\n                head = ListNode(heappop(values))\\n                pointer = head\\n            else:\\n                pointer.next = ListNode(heappop(values))\\n                pointer = pointer.next\\n        \\n        return head\\n```\n```\\nclass Solution:\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        values, head, pointer = [], None, None\\n        \\n        for l in lists:\\n            while l:\\n                values.append(l.val)\\n                l = l.next\\n                \\n        values.sort()\\n        \\n        while values:\\n            if head == None:\\n                head = ListNode(values.pop(0))\\n                pointer = head\\n            else:\\n                pointer.next = ListNode(values.pop(0))\\n                pointer = pointer.next\\n        \\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 281817,
                "title": "swift-solution",
                "content": "```\\nfunc mergeKLists(_ lists: [ListNode?]) -> ListNode? {\\n        //base checks\\n        var input = lists\\n        if(input.count == 0) {\\n            return nil\\n        }\\n        if(input.count == 1) {\\n            return input[0]\\n        }\\n        \\n        return partition(lists,0,input.count - 1)\\n    }\\n    \\n    \\n    func partition(_ list:[ListNode?], _ start:Int, _ end:Int) -> ListNode?{\\n        if(start == end) {\\n            return list[start]\\n        }\\n        if(start < end) {\\n            let middle = (start + end)/2\\n            let l1 = partition(list, start,middle)\\n            let l2 = partition(list, middle + 1,end)\\n            return mergeTwoList(l1,l2)\\n        }\\n        return nil\\n    }\\n    \\n    func mergeTwoList(_ l1:ListNode?, _ l2:ListNode?) ->ListNode? {\\n        if(l1 == nil) {return l2}\\n        if(l2 == nil) {return l1}\\n        var result:ListNode?\\n        \\n        if(l1!.val <= l2!.val) {\\n            result = l1\\n            result!.next = mergeTwoList(l1!.next,l2)\\n        }\\n        else {\\n            result = l2\\n            result!.next = mergeTwoList(l1,l2!.next)\\n        }\\n        return result\\n    }\\n\\t```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc mergeKLists(_ lists: [ListNode?]) -> ListNode? {\\n        //base checks\\n        var input = lists\\n        if(input.count == 0) {\\n            return nil\\n        }\\n        if(input.count == 1) {\\n            return input[0]\\n        }\\n        \\n        return partition(lists,0,input.count - 1)\\n    }\\n    \\n    \\n    func partition(_ list:[ListNode?], _ start:Int, _ end:Int) -> ListNode?{\\n        if(start == end) {\\n            return list[start]\\n        }\\n        if(start < end) {\\n            let middle = (start + end)/2\\n            let l1 = partition(list, start,middle)\\n            let l2 = partition(list, middle + 1,end)\\n            return mergeTwoList(l1,l2)\\n        }\\n        return nil\\n    }\\n    \\n    func mergeTwoList(_ l1:ListNode?, _ l2:ListNode?) ->ListNode? {\\n        if(l1 == nil) {return l2}\\n        if(l2 == nil) {return l1}\\n        var result:ListNode?\\n        \\n        if(l1!.val <= l2!.val) {\\n            result = l1\\n            result!.next = mergeTwoList(l1!.next,l2)\\n        }\\n        else {\\n            result = l2\\n            result!.next = mergeTwoList(l1,l2!.next)\\n        }\\n        return result\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 208936,
                "title": "why-am-i-getting-undefined-for-testcase-input",
                "content": "```\\nvar mergeKLists = function(lists) {\\n    let i = 0, last = lists.length - 1, j = last;\\n    if (!lists.length) return lists;\\n    while (last > 0) {\\n        i = 0; j = last;\\n        while (i < j) {\\n            lists[i] = merge2Lists(lists[i], lists[j]);\\n            i++; j--;\\n            if (i >= j) {\\n                last = j;\\n            }\\n        }\\n    }\\n    return lists[0];\\n};\\n```\\n\\nWhen lists length is zero I just return lists which is []. For some odd reason, LeetCode says output of my code is [undefined] which is not same as the expected []. \\n\\nEven if I return an explicit empty array i.e.  `if (!lists.length) return return [];`, I get the same error i.e. \\n\\nInput: []\\nOutput: [undefined]\\nExpected: []\\n\\nAnother strange thing is that final code, used to work for the same test case. But even for it I am getting same error now. I feel like someone has messed up the test case. \\n\\n```\\nvar mergeKLists = function(lists) {\\n    let len = lists.length;\\n    if (!len) return lists;  \\n    while (lists.length > 1) {\\n        lists.push(merge2Lists(lists[0], lists[1]));\\n        lists.shift();\\n        lists.shift();\\n    }\\n    return lists[0];\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar mergeKLists = function(lists) {\\n    let i = 0, last = lists.length - 1, j = last;\\n    if (!lists.length) return lists;\\n    while (last > 0) {\\n        i = 0; j = last;\\n        while (i < j) {\\n            lists[i] = merge2Lists(lists[i], lists[j]);\\n            i++; j--;\\n            if (i >= j) {\\n                last = j;\\n            }\\n        }\\n    }\\n    return lists[0];\\n};\\n```\n```\\nvar mergeKLists = function(lists) {\\n    let len = lists.length;\\n    if (!len) return lists;  \\n    while (lists.length > 1) {\\n        lists.push(merge2Lists(lists[0], lists[1]));\\n        lists.shift();\\n        lists.shift();\\n    }\\n    return lists[0];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 142187,
                "title": "javascript-es6-clean-code-using-divide-conquer-approach-beating-98",
                "content": "```\\nconst mergeKLists = (lists, lo = 0, hi = lists.length - 1) => {\\n    if (lists.length === 0) {\\n        return lists;\\n    }\\n    \\n    if (lo === hi) {\\n        return lists[lo];\\n    }\\n    \\n    const mid = Math.floor((hi + lo) / 2);\\n    const left = mergeKLists(lists, lo, mid);\\n    const right = mergeKLists(lists, mid + 1, hi);\\n    \\n    return mergeTwoLists(left, right);\\n};\\n\\nconst mergeTwoLists = (l1, l2) => {\\n    if (l1 === null) {\\n        return l2;\\n    }\\n    if (l2 === null) {\\n        return l1;\\n    }\\n    if (l1.val < l2.val) {\\n        l1.next = mergeTwoLists(l1.next, l2);\\n        return l1;\\n    } else {\\n        l2.next = mergeTwoLists(l1, l2.next);\\n        return l2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst mergeKLists = (lists, lo = 0, hi = lists.length - 1) => {\\n    if (lists.length === 0) {\\n        return lists;\\n    }\\n    \\n    if (lo === hi) {\\n        return lists[lo];\\n    }\\n    \\n    const mid = Math.floor((hi + lo) / 2);\\n    const left = mergeKLists(lists, lo, mid);\\n    const right = mergeKLists(lists, mid + 1, hi);\\n    \\n    return mergeTwoLists(left, right);\\n};\\n\\nconst mergeTwoLists = (l1, l2) => {\\n    if (l1 === null) {\\n        return l2;\\n    }\\n    if (l2 === null) {\\n        return l1;\\n    }\\n    if (l1.val < l2.val) {\\n        l1.next = mergeTwoLists(l1.next, l2);\\n        return l1;\\n    } else {\\n        l2.next = mergeTwoLists(l1, l2.next);\\n        return l2;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 10805,
                "title": "beat-94-84-3ms-divide-conquer-java-solution",
                "content": "    public class Solution {\\n        public ListNode mergeKLists(ListNode[] lists) {\\n            if(lists == null || lists.length == 0){\\n                return null;\\n            }\\n            return reduce(map(lists, 0, lists.length / 2), map(lists, lists.length / 2 + 1, lists.length - 1));\\n        }\\n        private ListNode map(ListNode[] lists, int from, int to){\\n            if(from > to){\\n                return null;\\n            }\\n            if(from == to){\\n                return lists[from];\\n            }\\n            if(from + 1 == to){\\n                return reduce(lists[from], lists[to]);\\n            }\\n            return reduce(map(lists, from, (from + to) / 2), map(lists, (from + to) / 2 + 1, to));\\n        }\\n        \\n        private ListNode reduce(ListNode first, ListNode second){\\n            if(first == null){\\n                return second;\\n            }\\n            if(second == null){\\n                return first;\\n            }\\n            ListNode head, pre;\\n            if(first.val < second.val){\\n                head = first;\\n                pre = first;\\n                first = first.next;\\n            }else{\\n                head = second;\\n                pre = second;\\n                second = second.next;\\n            }\\n            while(true){\\n                if(first == null){\\n                    pre.next = second;\\n                    break;\\n                }\\n                if(second == null){\\n                    pre.next = first;\\n                    break;\\n                }\\n                if(first.val < second.val){\\n                    pre.next = first;\\n                    pre = pre.next;\\n                    first = first.next;\\n                }else{\\n                    pre.next = second;\\n                    pre = pre.next;\\n                    second = second.next;\\n                }\\n            }\\n            return head;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer"
                ],
                "code": "class Solution {\\n        public ListNode mergeKLists(ListNode[] lists) {\\n            if(lists == null || lists.length == 0){\\n                return null;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 10758,
                "title": "recommend-for-beginners-clean-c-implementation-with-detailed-explanation",
                "content": "There are 2 ways to merge all the #lists linked-list:\\n\\n-1- we can merge the lists[0] with the lists[i] additively and record the results with the cur-pointer\\n\\n-2-  we can merge the top of the linked-lists and push the merged-linked-lists to the tail of the vector.\\n\\n**I can not figure out why the method-1- have TLE problem while the method-2- is OK ?**\\n\\nSolution:\\n\\n     because the method-1- merge-one-list-one-time, but the method-2- merge-2-list-one-time\\n\\nHere is my implementation:\\n\\n       class Solution {\\n        public:\\n            ListNode* mergeKLists(vector<ListNode*>& lists) {\\n                //merge way -1-\\n                if(lists.empty())   return NULL;\\n                ListNode* cur=lists[0];\\n                cout<<lists.size()<<endl;\\n                for(int i=1; i<lists.size(); i++){\\n                    cur=mergeTwoLists(cur, lists[i]);\\n                }\\n                return cur;\\n                \\n                //merge way -2-\\n                if(lists.empty()){\\n                    return nullptr;\\n                }\\n                while(lists.size() > 1){\\n                    lists.push_back(mergeTwoLists(lists[0], lists[1]));\\n                    lists.erase(lists.begin());\\n                    lists.erase(lists.begin());\\n                }\\n                return lists.front();\\n            }\\n         \\n            \\n            ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {\\n                ListNode* dummy=new ListNode(-1);\\n                ListNode* cur=dummy;\\n                while(l1 && l2){\\n                    if(l1->val < l2->val){\\n                        cur->next=l1;\\n                        cur=l1;\\n                        l1=l1->next;\\n                    }\\n                    else{\\n                        cur->next=l2;\\n                        cur=l2;\\n                        l2=l2->next;\\n                    }\\n                }\\n                if(!l1)  cur->next=l2;\\n                if(!l2)  cur->next=l1;\\n                return dummy->next;\\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            ListNode* mergeKLists(vector<ListNode*>& lists) {\\n                //merge way -1-\\n                if(lists.empty())   return NULL;\\n                ListNode* cur=lists[0];\\n                cout<<lists.size()<<endl;\\n                for(int i=1; i<lists.size(); i++){\\n                    cur=mergeTwoLists(cur, lists[i]);\\n                }",
                "codeTag": "C++"
            },
            {
                "id": 3590066,
                "title": "easiest-intutive-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    int length(ListNode* h){\\n        ListNode* l=h;\\n        int c=0;\\n        while(l){\\n            c+=1;\\n            l=l->next;\\n        }\\n        return c;\\n    }\\n\\n    ListNode* merge(ListNode* l1,ListNode* l2){\\n        ListNode* h1=l1,*h2=l2;\\n        ListNode* ll=new ListNode(0);\\n        ListNode* ans=ll;\\n        while(h1 and h2){\\n            if(h1->val <=h2->val){\\n                ans->next=h1;\\n                h1=h1->next;\\n            } else{\\n                ans->next=h2;\\n                h2=h2->next;\\n            }\\n            ans=ans->next;\\n        }\\n\\n        if(h1)\\n        ans->next=h1;\\n        if(h2)\\n        ans->next=h2;\\n\\n        return ll->next;\\n        \\n    }\\n\\n    ListNode* mergeKLists(vector<ListNode*>& a) {\\n        ListNode* st,temp;\\n        if(a.size()==0)\\n        return NULL;\\n        ListNode* l1=a[0];\\n        for(int i=1;i<a.size();i+=1){\\n            \\n            ListNode* l2=a[i];\\n            if(length(l1)<length(l2)){\\n            l1=merge(l2,l1);\\n        } else\\n            l1=merge(l1,l2);\\n\\n        }\\n        return l1;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Merge Sort"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    int length(ListNode* h){\\n        ListNode* l=h;\\n        int c=0;\\n        while(l){\\n            c+=1;\\n            l=l->next;\\n        }\\n        return c;\\n    }\\n\\n    ListNode* merge(ListNode* l1,ListNode* l2){\\n        ListNode* h1=l1,*h2=l2;\\n        ListNode* ll=new ListNode(0);\\n        ListNode* ans=ll;\\n        while(h1 and h2){\\n            if(h1->val <=h2->val){\\n                ans->next=h1;\\n                h1=h1->next;\\n            } else{\\n                ans->next=h2;\\n                h2=h2->next;\\n            }\\n            ans=ans->next;\\n        }\\n\\n        if(h1)\\n        ans->next=h1;\\n        if(h2)\\n        ans->next=h2;\\n\\n        return ll->next;\\n        \\n    }\\n\\n    ListNode* mergeKLists(vector<ListNode*>& a) {\\n        ListNode* st,temp;\\n        if(a.size()==0)\\n        return NULL;\\n        ListNode* l1=a[0];\\n        for(int i=1;i<a.size();i+=1){\\n            \\n            ListNode* l2=a[i];\\n            if(length(l1)<length(l2)){\\n            l1=merge(l2,l1);\\n        } else\\n            l1=merge(l1,l2);\\n\\n        }\\n        return l1;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3285953,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* merge(ListNode* head1,ListNode* head2){\\n        ListNode* head=NULL;\\n        ListNode* tail=NULL;\\n        while(head1&&head2){\\n            if(head1->val<=head2->val){\\n                if(!head){\\n                    head=head1;\\n                    tail=head;\\n                }\\n                else{\\n                    tail->next=head1;\\n                    tail=tail->next;\\n                }\\n                head1=head1->next;\\n            }\\n            else{\\n                if(!head){\\n                    head=head2;\\n                    tail=head;\\n                }\\n                else{\\n                    tail->next=head2;\\n                    tail=tail->next;\\n                }\\n                head2=head2->next;\\n            }\\n        }\\n        while(head1){\\n            if(!head){\\n                head=head1;\\n                tail=head;\\n            }\\n            else{\\n                tail->next=head1;\\n                tail=tail->next;\\n            }\\n            head1=head1->next;\\n        }\\n        while(head2){\\n            if(!head){\\n                head=head2;\\n                tail=head;\\n            }\\n            else{\\n                tail->next=head2;\\n                tail=tail->next;\\n            }\\n            head2=head2->next;            \\n        }\\n        return head;\\n    }\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        int n=lists.size();\\n        if(lists.empty()) return NULL;\\n        ListNode* head=lists[0];\\n        for(int i=1;i<n;i++){\\n            head=merge(head,lists[i]);\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* merge(ListNode* head1,ListNode* head2){\\n        ListNode* head=NULL;\\n        ListNode* tail=NULL;\\n        while(head1&&head2){\\n            if(head1->val<=head2->val){\\n                if(!head){\\n                    head=head1;\\n                    tail=head;\\n                }\\n                else{\\n                    tail->next=head1;\\n                    tail=tail->next;\\n                }\\n                head1=head1->next;\\n            }\\n            else{\\n                if(!head){\\n                    head=head2;\\n                    tail=head;\\n                }\\n                else{\\n                    tail->next=head2;\\n                    tail=tail->next;\\n                }\\n                head2=head2->next;\\n            }\\n        }\\n        while(head1){\\n            if(!head){\\n                head=head1;\\n                tail=head;\\n            }\\n            else{\\n                tail->next=head1;\\n                tail=tail->next;\\n            }\\n            head1=head1->next;\\n        }\\n        while(head2){\\n            if(!head){\\n                head=head2;\\n                tail=head;\\n            }\\n            else{\\n                tail->next=head2;\\n                tail=tail->next;\\n            }\\n            head2=head2->next;            \\n        }\\n        return head;\\n    }\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        int n=lists.size();\\n        if(lists.empty()) return NULL;\\n        ListNode* head=lists[0];\\n        for(int i=1;i<n;i++){\\n            head=merge(head,lists[i]);\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3285878,
                "title": "python3-solution",
                "content": "\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution:\\n    def mergeKLists(self,lists:List[Optional[ListNode]])->Optional[ListNode]:\\n        values,head,pointer=[],None,None\\n        for l in lists:\\n            while l:\\n                heappush(values,l.val)\\n                l=l.next\\n\\n        while values:\\n            if head is None:\\n                head=ListNode(heappop(values))\\n                pointer=head\\n\\n            else:\\n                pointer.next=ListNode(heappop(values))\\n                pointer=pointer.next\\n\\n        return head                              \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\nclass Solution:\\n    def mergeKLists(self,lists:List[Optional[ListNode]])->Optional[ListNode]:\\n        values,head,pointer=[],None,None\\n        for l in lists:\\n            while l:\\n                heappush(values,l.val)\\n                l=l.next\\n\\n        while values:\\n            if head is None:\\n                head=ListNode(heappop(values))\\n                pointer=head\\n\\n            else:\\n                pointer.next=ListNode(heappop(values))\\n                pointer=pointer.next\\n\\n        return head                              \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056025,
                "title": "c-using-vector-simple-and-easy-approach",
                "content": "# Intuition\\nJust insert all the elements in a vector and sort it. Then make a new LL using vector\\'s elements.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        vector<int> v;\\n        \\n        for(auto i:lists){\\n            while(i != NULL){\\n                v.push_back(i->val);\\n                i=i->next;\\n            }\\n        }\\n        \\n        if(v.size() == 0) return NULL;\\n        sort(v.begin(), v.end());\\n        \\n        ListNode* head = new ListNode(v[0]);\\n        ListNode* temp = head;\\n        \\n        for(int i=1; i<v.size(); i++){\\n            ListNode* num = new ListNode(v[i]);\\n            temp->next = num;\\n            temp = temp->next;\\n        }\\n        \\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        vector<int> v;\\n        \\n        for(auto i:lists){\\n            while(i != NULL){\\n                v.push_back(i->val);\\n                i=i->next;\\n            }\\n        }\\n        \\n        if(v.size() == 0) return NULL;\\n        sort(v.begin(), v.end());\\n        \\n        ListNode* head = new ListNode(v[0]);\\n        ListNode* temp = head;\\n        \\n        for(int i=1; i<v.size(); i++){\\n            ListNode* num = new ListNode(v[i]);\\n            temp->next = num;\\n            temp = temp->next;\\n        }\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755021,
                "title": "merge-the-lists",
                "content": "```\\nclass Solution {\\npublic:\\n    void it(ListNode* &t,int v){\\n        ListNode* s=new ListNode(v);\\n        t->next=s;\\n        t=t->next;\\n    }\\n    ListNode* mergeKLists(vector<ListNode*>& l) {\\n        vector<int>v;\\n        if(l.size()==0){//base case\\n            return NULL;\\n        }\\n        for(int p=0;p<l.size();p++){\\n            ListNode* a=l[p];\\n            while(a){\\n                v.push_back(a->val);\\n                a=a->next;\\n            }\\n        }\\n        if(v.size()==0){\\n            return NULL;\\n        }\\n        sort(v.begin(),v.end());\\n\\t\\t//sorted vector\\n        ListNode* s=new ListNode(v[0]);\\n        ListNode* t=s;\\n        for(int p=1;p<v.size();p++){\\n            it(t,v[p]);//adding to tail\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void it(ListNode* &t,int v){\\n        ListNode* s=new ListNode(v);\\n        t->next=s;\\n        t=t->next;\\n    }\\n    ListNode* mergeKLists(vector<ListNode*>& l) {\\n        vector<int>v;\\n        if(l.size()==0){//base case\\n            return NULL;\\n        }\\n        for(int p=0;p<l.size();p++){\\n            ListNode* a=l[p];\\n            while(a){\\n                v.push_back(a->val);\\n                a=a->next;\\n            }\\n        }\\n        if(v.size()==0){\\n            return NULL;\\n        }\\n        sort(v.begin(),v.end());\\n\\t\\t//sorted vector\\n        ListNode* s=new ListNode(v[0]);\\n        ListNode* t=s;\\n        for(int p=1;p<v.size();p++){\\n            it(t,v[p]);//adding to tail\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2702610,
                "title": "beats-97-easy-c-priority-queue-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    class MyCmp{\\n        public:\\n            bool operator()(ListNode *l1,ListNode *l2){\\n                return l1->val>l2->val;\\n            }\\n    };\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        int l=lists.size();\\n        priority_queue<ListNode*,vector<ListNode*>,MyCmp>pq;\\n        for(int i=0;i<l;i++){\\n            if(lists[i]!=NULL){\\n                pq.push(lists[i]);\\n            }\\n        }\\n        ListNode *head=new ListNode();\\n        ListNode* curr=head;\\n        while(!pq.empty()){\\n            curr->next=pq.top();\\n            curr=curr->next;\\n            pq.pop();\\n            if(curr->next!=NULL){\\n                pq.push(curr->next);\\n            }\\n        }\\n        return head->next;\\n        \\n\\n        \\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    class MyCmp{\\n        public:\\n            bool operator()(ListNode *l1,ListNode *l2){\\n                return l1->val>l2->val;\\n            }\\n    };\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        int l=lists.size();\\n        priority_queue<ListNode*,vector<ListNode*>,MyCmp>pq;\\n        for(int i=0;i<l;i++){\\n            if(lists[i]!=NULL){\\n                pq.push(lists[i]);\\n            }\\n        }\\n        ListNode *head=new ListNode();\\n        ListNode* curr=head;\\n        while(!pq.empty()){\\n            curr->next=pq.top();\\n            curr=curr->next;\\n            pq.pop();\\n            if(curr->next!=NULL){\\n                pq.push(curr->next);\\n            }\\n        }\\n        return head->next;\\n        \\n\\n        \\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1812229,
                "title": "3-approaches-with-comments-min-heap-divide-conquer-c",
                "content": "Implementation\\n\\n**1st Approach\\nTime Complexity = O(N * max(k.length))\\nSpace Complexity = O(max(k.length)), bcz of the recursive mergeTwoLists()**\\n\\nIdea : Iterating over the k lists from 1 to N, and adding all the lists into lists[0], and in last returning that lists[0], bcz all other k lists are getting merged into this lists[0]\\n\\n```\\nclass Solution {\\nprivate:\\n    // Recursive Approach to merge the sorted lists\\n    // Time Complexity = O(max(first, second))\\n    // Space Complexity = O(max(first, second)), bcz of stack trace\\n    ListNode* mergeTwoLists(ListNode* first, ListNode* second){\\n        if(!first) return second;\\n        if(!second) return first;        \\n        \\n        if(first->val < second->val){\\n            first->next = mergeTwoLists(first->next, second);\\n            return first;\\n        }\\n        else{\\n            second->next = mergeTwoLists(first, second->next);\\n            return second;\\n        }\\n    }\\n    \\npublic:    \\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if(lists.size() == 0) return NULL;\\n        if(lists.size() == 1) return lists[0];\\n        \\n        // traversing over the lists\\n        for(int itr = 1; itr < lists.size(); itr++){\\n            lists[0] = mergeTwoLists(lists[0], lists[itr]);\\n        }\\n        \\n        return lists[0];\\n    }\\n};\\n```\\n\\n\\n**2nd Approach\\nUsing Priority Queue(Min Heap)\\nTime Complexity = O(N * logK)\\nSpace Complexity = O(max(k.length))**\\n\\nIdea : Storing all k nodes into the Priority Queue and after that just looping until its size become 0, while looping storing the top node into the dummy list, bcz it will be a smallest node, and adding the next of the kth node into Priority Queue, if its not null\\n\\n```\\nclass Solution {\\nprivate:\\n    // using this stuct to compare the data of the node, bcz we are storing the list into the Priority Queue\\n    struct compare {\\n        bool operator()(const ListNode* l, const ListNode* r) {\\n            return l->val > r->val;\\n        }\\n    };\\n    \\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        \\n        // using pq to store the nodes in the ascending order, by default priority queue stores elements into ascending order only\\n        priority_queue<ListNode*, vector<ListNode*>, compare> pq;\\n        \\n        // storing the first node of every k lists into pq\\n        for(int itr = 0; itr < lists.size(); itr++){\\n            if(lists[itr]) pq.push(lists[itr]);\\n        }\\n        \\n        // Using a dummy list to store the result\\n        ListNode* dummy = new ListNode(0);\\n        \\n        // using the res list to return the result\\n        ListNode* res = dummy;\\n        \\n        // iterating over the pq, and storing the nodes into dummy, and if particular kth node is having more nodes then storing those nodes into the pq\\n        while(pq.size()){\\n\\n            // getting the node which is on the top of pq, bcz that will be our smallest node\\n            ListNode* temp = pq.top();\\n            \\n            // removing the top node\\n            pq.pop();\\n            \\n            // storing the temp node into dummy\\n            dummy->next = temp;\\n            \\n            // moving dummy one step ahead\\n            dummy = dummy->next;\\n            \\n            // if particular kth node(temp) is having more nodes then storing the node into the pq\\n            if(temp->next){\\n                pq.push(temp->next);\\n            }\\n        }\\n        \\n        // returning the result\\n        return res->next;\\n    }\\n};\\n```\\n\\n\\n**3rd Approach\\nUsing Divide & Conquer Strategy\\nTime Complexity = O(N * logK)\\nSpace Complexity = O(max(k.length))**\\n\\nIdea : divide the list, take two pointers one from start, another from last, and merge the lists of both start and end index, and store into the start index and increment start by 1 and decrement end by 1, so in the last will be having the all k lists at 0th index in sorted form.\\n\\n```\\nclass Solution {\\nprivate:\\n    // Recursive Approach to merge the sorted lists\\n    // Time Complexity = O(max(first, second))\\n    // Space Complexity = O(max(first, second)), bcz of stack trace\\n    ListNode* mergeTwoLists(ListNode* first, ListNode* second){\\n        if(!first) return second;\\n        if(!second) return first;        \\n        \\n        if(first->val < second->val){\\n            first->next = mergeTwoLists(first->next, second);\\n            return first;\\n        }\\n        else{\\n            second->next = mergeTwoLists(first, second->next);\\n            return second;\\n        }\\n    }\\n    \\npublic:    \\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        \\n        // base case\\n        if(lists.size() == 0) return NULL;\\n        \\n        // start will always start from 0th node, and end will start from last node\\n        int start = 0, end = lists.size()-1;\\n        \\n        while(end > 0){\\n            \\n            // intialize start to 0 everytime\\n            start = 0;\\n            \\n            // run the loop till the time, start is less than the end\\n            while(start < end){\\n                \\n                // merge the start index and end index node and store the merged list into the start index\\n                lists[start] = mergeTwoLists(lists[start], lists[end]);\\n                \\n                // increment start by 1\\n                start++;\\n                \\n                // decrement end by 1\\n                end--;\\n            }\\n        }\\n        \\n        // at the end will be having the all merged nodes on the 0th index\\n        return lists[0];\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Divide and Conquer",
                    "Recursion",
                    "Heap (Priority Queue)",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    // Recursive Approach to merge the sorted lists\\n    // Time Complexity = O(max(first, second))\\n    // Space Complexity = O(max(first, second)), bcz of stack trace\\n    ListNode* mergeTwoLists(ListNode* first, ListNode* second){\\n        if(!first) return second;\\n        if(!second) return first;        \\n        \\n        if(first->val < second->val){\\n            first->next = mergeTwoLists(first->next, second);\\n            return first;\\n        }\\n        else{\\n            second->next = mergeTwoLists(first, second->next);\\n            return second;\\n        }\\n    }\\n    \\npublic:    \\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if(lists.size() == 0) return NULL;\\n        if(lists.size() == 1) return lists[0];\\n        \\n        // traversing over the lists\\n        for(int itr = 1; itr < lists.size(); itr++){\\n            lists[0] = mergeTwoLists(lists[0], lists[itr]);\\n        }\\n        \\n        return lists[0];\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    // using this stuct to compare the data of the node, bcz we are storing the list into the Priority Queue\\n    struct compare {\\n        bool operator()(const ListNode* l, const ListNode* r) {\\n            return l->val > r->val;\\n        }\\n    };\\n    \\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        \\n        // using pq to store the nodes in the ascending order, by default priority queue stores elements into ascending order only\\n        priority_queue<ListNode*, vector<ListNode*>, compare> pq;\\n        \\n        // storing the first node of every k lists into pq\\n        for(int itr = 0; itr < lists.size(); itr++){\\n            if(lists[itr]) pq.push(lists[itr]);\\n        }\\n        \\n        // Using a dummy list to store the result\\n        ListNode* dummy = new ListNode(0);\\n        \\n        // using the res list to return the result\\n        ListNode* res = dummy;\\n        \\n        // iterating over the pq, and storing the nodes into dummy, and if particular kth node is having more nodes then storing those nodes into the pq\\n        while(pq.size()){\\n\\n            // getting the node which is on the top of pq, bcz that will be our smallest node\\n            ListNode* temp = pq.top();\\n            \\n            // removing the top node\\n            pq.pop();\\n            \\n            // storing the temp node into dummy\\n            dummy->next = temp;\\n            \\n            // moving dummy one step ahead\\n            dummy = dummy->next;\\n            \\n            // if particular kth node(temp) is having more nodes then storing the node into the pq\\n            if(temp->next){\\n                pq.push(temp->next);\\n            }\\n        }\\n        \\n        // returning the result\\n        return res->next;\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    // Recursive Approach to merge the sorted lists\\n    // Time Complexity = O(max(first, second))\\n    // Space Complexity = O(max(first, second)), bcz of stack trace\\n    ListNode* mergeTwoLists(ListNode* first, ListNode* second){\\n        if(!first) return second;\\n        if(!second) return first;        \\n        \\n        if(first->val < second->val){\\n            first->next = mergeTwoLists(first->next, second);\\n            return first;\\n        }\\n        else{\\n            second->next = mergeTwoLists(first, second->next);\\n            return second;\\n        }\\n    }\\n    \\npublic:    \\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        \\n        // base case\\n        if(lists.size() == 0) return NULL;\\n        \\n        // start will always start from 0th node, and end will start from last node\\n        int start = 0, end = lists.size()-1;\\n        \\n        while(end > 0){\\n            \\n            // intialize start to 0 everytime\\n            start = 0;\\n            \\n            // run the loop till the time, start is less than the end\\n            while(start < end){\\n                \\n                // merge the start index and end index node and store the merged list into the start index\\n                lists[start] = mergeTwoLists(lists[start], lists[end]);\\n                \\n                // increment start by 1\\n                start++;\\n                \\n                // decrement end by 1\\n                end--;\\n            }\\n        }\\n        \\n        // at the end will be having the all merged nodes on the 0th index\\n        return lists[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1745592,
                "title": "c",
                "content": "```\\nListNode* mergeTwoLists(ListNode* a, ListNode* b){\\n        if(a==NULL) return b;\\n        if(b==NULL) return a;\\n        ListNode* head=NULL;\\n        if(a->val <= b->val)\\n        {   head=a;\\n            head->next = mergeTwoLists(a->next, b);\\n            \\n        }\\n        else{\\n            head=b;\\n            head->next = mergeTwoLists(a, b->next);\\n            \\n        }\\n        return head;\\n    }\\n    \\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if(lists.size()==0){\\n            return NULL;\\n        }\\n        if(lists.size()==1){\\n            return lists[0];\\n        }\\n        \\n        ListNode* res=lists[0];\\n        \\n        for(int i=1;i<lists.size();i++){\\n            res=mergeTwoLists(res,lists[i]);\\n            \\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nListNode* mergeTwoLists(ListNode* a, ListNode* b){\\n        if(a==NULL) return b;\\n        if(b==NULL) return a;\\n        ListNode* head=NULL;\\n        if(a->val <= b->val)\\n        {   head=a;\\n            head->next = mergeTwoLists(a->next, b);\\n            \\n        }\\n        else{\\n            head=b;\\n            head->next = mergeTwoLists(a, b->next);\\n            \\n        }\\n        return head;\\n    }\\n    \\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if(lists.size()==0){\\n            return NULL;\\n        }\\n        if(lists.size()==1){\\n            return lists[0];\\n        }\\n        \\n        ListNode* res=lists[0];\\n        \\n        for(int i=1;i<lists.size();i++){\\n            res=mergeTwoLists(res,lists[i]);\\n            \\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1201446,
                "title": "python-divide-and-conquer-easy-understand-o-nlogk",
                "content": "```\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        \\n        if not lists: # handle []\\n            return None  \\n        \\n        if len(lists) == 1:  # it can handle [[]], len([[]])=1\\n            return lists[0] # return the nodes\\n        \\n        if len(lists) == 2:\\n            return self.merge2Lists(lists[0], lists[1])\\n        \\n        left, right = 0, len(lists)-1\\n        mid = (left+right) // 2\\n        leftSide = lists[:mid]\\n        rightSide = lists[mid:]\\n        leftDone = self.mergeKLists(leftSide)\\n        rightDone = self.mergeKLists(rightSide)\\n            \\n        return self.merge2Lists(leftDone, rightDone)\\n        \\n        \\n    def merge2Lists(self, list1, list2):\\n        \\n        pre = dummy = ListNode(\\'a\\')\\n        \\n        while list1 and list2:\\n            if list1.val <= list2.val:\\n                dummy.next = list1\\n                list1 = list1.next\\n            else:\\n                dummy.next = list2\\n                list2 = list2.next\\n            dummy = dummy.next \\n        \\n        \\n        if list1 and not list2:\\n            dummy.next = list1\\n\\n        if not list1 and list2:\\n            dummy.next = list2\\n        \\n        return pre.next\\n```",
                "solutionTags": [
                    "Python",
                    "Divide and Conquer"
                ],
                "code": "```\\n    def mergeKLists(self, lists: List[ListNode]) -> ListNode:\\n        \\n        if not lists: # handle []\\n            return None  \\n        \\n        if len(lists) == 1:  # it can handle [[]], len([[]])=1\\n            return lists[0] # return the nodes\\n        \\n        if len(lists) == 2:\\n            return self.merge2Lists(lists[0], lists[1])\\n        \\n        left, right = 0, len(lists)-1\\n        mid = (left+right) // 2\\n        leftSide = lists[:mid]\\n        rightSide = lists[mid:]\\n        leftDone = self.mergeKLists(leftSide)\\n        rightDone = self.mergeKLists(rightSide)\\n            \\n        return self.merge2Lists(leftDone, rightDone)\\n        \\n        \\n    def merge2Lists(self, list1, list2):\\n        \\n        pre = dummy = ListNode(\\'a\\')\\n        \\n        while list1 and list2:\\n            if list1.val <= list2.val:\\n                dummy.next = list1\\n                list1 = list1.next\\n            else:\\n                dummy.next = list2\\n                list2 = list2.next\\n            dummy = dummy.next \\n        \\n        \\n        if list1 and not list2:\\n            dummy.next = list1\\n\\n        if not list1 and list2:\\n            dummy.next = list2\\n        \\n        return pre.next\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1198189,
                "title": "merge-sort-min-heap",
                "content": "To achive this, just try first to implement mergeSort at your own, then you\\'ll see is very easy to achive it iterative.\\n```\\nvar mergeKLists = function(lists) {\\n    \\n    const mergeSort = (arr) => {\\n        if(arr.length === 0) return null;\\n        if(arr.length === 1) return arr[0];\\n        const left = arr.splice(0, arr.length / 2);\\n        return merge(mergeSort(left), mergeSort(arr));\\n    }\\n    \\n    const merge = (a,b) => {\\n        const root = new ListNode();\\n        let aux = root;\\n        while(a && b) {\\n            if(a.val < b.val) {\\n                aux.next = a;\\n                a = a.next;\\n            } else {\\n                aux.next = b;\\n                b = b.next;\\n            }\\n            aux = aux.next;\\n        }\\n        aux.next =  a || b;\\n        return root.next;\\n    }\\n    \\n    return mergeSort(lists);\\n};\\n```\\n\\nThis was my first though to be honest.\\n```\\nvar mergeKListsMinHeap = function(lists) {\\n    let root = new ListNode();\\n    let aux = root;\\n    const heap = new MinHeap();\\n    \\n    for(const h of lists) {\\n        if(h) {\\n            heap.push(h);\\n        }\\n    }\\n\\n    while(!heap.isEmpty()) {\\n        const node = heap.pop();\\n        aux.next = node;\\n        aux = aux.next;\\n        if(node.next)\\n            heap.push(node.next);\\n    }\\n    \\n    return root.next;\\n};\\n\\nclass MinHeap {\\n    constructor() {\\n        this.heap = new Array(500);\\n        this.idx = 0;\\n    }\\n    \\n    size = () => this.idx;\\n    isEmpty = () => this.idx === 0;\\n    parent = (i) => (i-1) / 2 | 0;\\n    left = (i) => (i * 2) + 1;\\n    right = (i) => (i * 2) + 2;\\n\\n    isMin = (i, j) => this.heap[i].val < this.heap[j].val;\\n    swap = (a,b) => {\\n        const tmp = this.heap[a];\\n        this.heap[a] = this.heap[b];\\n        this.heap[b] = tmp;\\n    }\\n\\n    push = (node) => {\\n        let i = this.idx;\\n        this.heap[this.idx++] = node;\\n        let p = this.parent(i);\\n        while(i > 0 && this.isMin(i, p)) {\\n            this.swap(i, p);\\n            p = this.parent(i = p);\\n        }\\n    }\\n    \\n    min = (i) => {\\n        let l = this.left(i);\\n        let r = this.right(i);\\n        let best = i;\\n        if(l < this.size() && this.isMin(l, best)) best = l;\\n        if(r < this.size() && this.isMin(r, best)) best = r;\\n        \\n        return this.isMin(i, best) ? i : best;\\n    }\\n    \\n    heapify = (i = 0) => {\\n        let best = this.min(i);\\n        while(best !== i) {\\n            this.swap(i, best);\\n            best = this.min(i = best);\\n        }\\n    }\\n    \\n    pop = () => {\\n        if(this.isEmpty()) return null;\\n        const n = this.heap[0];\\n        this.swap(0, --this.idx);\\n        this.heapify();\\n        return n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar mergeKLists = function(lists) {\\n    \\n    const mergeSort = (arr) => {\\n        if(arr.length === 0) return null;\\n        if(arr.length === 1) return arr[0];\\n        const left = arr.splice(0, arr.length / 2);\\n        return merge(mergeSort(left), mergeSort(arr));\\n    }\\n    \\n    const merge = (a,b) => {\\n        const root = new ListNode();\\n        let aux = root;\\n        while(a && b) {\\n            if(a.val < b.val) {\\n                aux.next = a;\\n                a = a.next;\\n            } else {\\n                aux.next = b;\\n                b = b.next;\\n            }\\n            aux = aux.next;\\n        }\\n        aux.next =  a || b;\\n        return root.next;\\n    }\\n    \\n    return mergeSort(lists);\\n};\\n```\n```\\nvar mergeKListsMinHeap = function(lists) {\\n    let root = new ListNode();\\n    let aux = root;\\n    const heap = new MinHeap();\\n    \\n    for(const h of lists) {\\n        if(h) {\\n            heap.push(h);\\n        }\\n    }\\n\\n    while(!heap.isEmpty()) {\\n        const node = heap.pop();\\n        aux.next = node;\\n        aux = aux.next;\\n        if(node.next)\\n            heap.push(node.next);\\n    }\\n    \\n    return root.next;\\n};\\n\\nclass MinHeap {\\n    constructor() {\\n        this.heap = new Array(500);\\n        this.idx = 0;\\n    }\\n    \\n    size = () => this.idx;\\n    isEmpty = () => this.idx === 0;\\n    parent = (i) => (i-1) / 2 | 0;\\n    left = (i) => (i * 2) + 1;\\n    right = (i) => (i * 2) + 2;\\n\\n    isMin = (i, j) => this.heap[i].val < this.heap[j].val;\\n    swap = (a,b) => {\\n        const tmp = this.heap[a];\\n        this.heap[a] = this.heap[b];\\n        this.heap[b] = tmp;\\n    }\\n\\n    push = (node) => {\\n        let i = this.idx;\\n        this.heap[this.idx++] = node;\\n        let p = this.parent(i);\\n        while(i > 0 && this.isMin(i, p)) {\\n            this.swap(i, p);\\n            p = this.parent(i = p);\\n        }\\n    }\\n    \\n    min = (i) => {\\n        let l = this.left(i);\\n        let r = this.right(i);\\n        let best = i;\\n        if(l < this.size() && this.isMin(l, best)) best = l;\\n        if(r < this.size() && this.isMin(r, best)) best = r;\\n        \\n        return this.isMin(i, best) ? i : best;\\n    }\\n    \\n    heapify = (i = 0) => {\\n        let best = this.min(i);\\n        while(best !== i) {\\n            this.swap(i, best);\\n            best = this.min(i = best);\\n        }\\n    }\\n    \\n    pop = () => {\\n        if(this.isEmpty()) return null;\\n        const n = this.heap[0];\\n        this.swap(0, --this.idx);\\n        this.heapify();\\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1125283,
                "title": "rust-simple-solution-without-box-new",
                "content": "```\\nimpl Solution {\\n    pub fn merge_k_lists(mut xs: Vec<Option<Box<ListNode>>>) -> Option<Box<ListNode>> {\\n        let i = xs.iter().enumerate().min_by_key(|(_, x)| x.as_ref().map_or(std::i32::MAX, |x| x.val))?.0;\\n        let mut h = xs[i].take()?;\\n        xs[i] = h.next;\\n        h.next = Self::merge_k_lists(xs);\\n        Some(h)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn merge_k_lists(mut xs: Vec<Option<Box<ListNode>>>) -> Option<Box<ListNode>> {\\n        let i = xs.iter().enumerate().min_by_key(|(_, x)| x.as_ref().map_or(std::i32::MAX, |x| x.val))?.0;\\n        let mut h = xs[i].take()?;\\n        xs[i] = h.next;\\n        h.next = Self::merge_k_lists(xs);\\n        Some(h)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 862394,
                "title": "simple-java-solution-using-a-priority-queue",
                "content": "```\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        \\n        for(ListNode list: lists) {\\n            while(list != null) {\\n                pq.add(list.val);\\n                list = list.next;\\n            }\\n        }\\n        \\n        ListNode curr = new ListNode(0);\\n        ListNode head = curr;\\n        while(!pq.isEmpty()) {\\n            ListNode t = new ListNode(pq.poll());\\n            curr.next = t;\\n            curr = curr.next;\\n        }\\n        return head.next;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\\n        \\n        for(ListNode list: lists) {\\n            while(list != null) {\\n                pq.add(list.val);\\n                list = list.next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 659745,
                "title": "rust-binaryheap-solution",
                "content": "```rust\\nuse std::{cmp::Reverse, collections::BinaryHeap};\\n\\nimpl PartialOrd for ListNode {\\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\\n        self.val.partial_cmp(&other.val)\\n    }\\n}\\n\\nimpl Ord for ListNode {\\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\\n        self.val.cmp(&other.val)\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn merge_k_lists(lists: Vec<Option<Box<ListNode>>>) -> Option<Box<ListNode>> {\\n        let mut min_heap = BinaryHeap::new();\\n        for list in lists {\\n            if let Some(node) = list {\\n                min_heap.push(Reverse(node));\\n            }\\n        }\\n        let mut dummy_head = ListNode::new(0);\\n        let mut cur = &mut dummy_head;\\n        while let Some(Reverse(node)) = min_heap.pop() {\\n            cur.next = Some(Box::new(ListNode::new(node.val)));\\n            cur = cur.next.as_mut().unwrap();\\n            if let Some(next) = node.next {\\n                min_heap.push(Reverse(next));\\n            }\\n        }\\n        return dummy_head.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Heap (Priority Queue)"
                ],
                "code": "```rust\\nuse std::{cmp::Reverse, collections::BinaryHeap};\\n\\nimpl PartialOrd for ListNode {\\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\\n        self.val.partial_cmp(&other.val)\\n    }\\n}\\n\\nimpl Ord for ListNode {\\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\\n        self.val.cmp(&other.val)\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn merge_k_lists(lists: Vec<Option<Box<ListNode>>>) -> Option<Box<ListNode>> {\\n        let mut min_heap = BinaryHeap::new();\\n        for list in lists {\\n            if let Some(node) = list {\\n                min_heap.push(Reverse(node));\\n            }\\n        }\\n        let mut dummy_head = ListNode::new(0);\\n        let mut cur = &mut dummy_head;\\n        while let Some(Reverse(node)) = min_heap.pop() {\\n            cur.next = Some(Box::new(ListNode::new(node.val)));\\n            cur = cur.next.as_mut().unwrap();\\n            if let Some(next) = node.next {\\n                min_heap.push(Reverse(next));\\n            }\\n        }\\n        return dummy_head.next;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 502167,
                "title": "java-priority-queue-custom-comparing-class-as-min-heap-simple",
                "content": "```\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        PriorityQueue<ListNode> minHeap = new PriorityQueue<>(new NodeComaprator());\\n\\n        for (ListNode listNode : lists) {\\n            ListNode node = listNode;\\n\\n            while (node != null) {\\n                minHeap.add(new ListNode(node.val));\\n                node = node.next;\\n            }\\n        }\\n        \\n        ListNode head = minHeap.isEmpty() ? null : minHeap.poll();\\n        ListNode curr = head;\\n        \\n        while(!minHeap.isEmpty()){\\n            curr.next = minHeap.poll();\\n            curr = curr.next;\\n        }\\n        \\n        return head;\\n    }\\n}\\n\\n\\nclass NodeComaprator implements Comparator<ListNode> {\\n    @Override\\n    public int compare(ListNode o1, ListNode o2) {\\n       return o1.val - o2.val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        PriorityQueue<ListNode> minHeap = new PriorityQueue<>(new NodeComaprator());\\n\\n        for (ListNode listNode : lists) {\\n            ListNode node = listNode;\\n\\n            while (node != null) {\\n                minHeap.add(new ListNode(node.val));\\n                node = node.next;\\n            }\\n        }\\n        \\n        ListNode head = minHeap.isEmpty() ? null : minHeap.poll();\\n        ListNode curr = head;\\n        \\n        while(!minHeap.isEmpty()){\\n            curr.next = minHeap.poll();\\n            curr = curr.next;\\n        }\\n        \\n        return head;\\n    }\\n}\\n\\n\\nclass NodeComaprator implements Comparator<ListNode> {\\n    @Override\\n    public int compare(ListNode o1, ListNode o2) {\\n       return o1.val - o2.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 420969,
                "title": "rust-min-heap",
                "content": "```\\nuse std::cmp::Ordering;\\nuse std::collections::BinaryHeap; // BinaryHeap is Max Heap in default\\n\\nimpl PartialOrd<ListNode> for ListNode {\\n    fn partial_cmp(&self, other: &ListNode) -> Option<Ordering> {\\n        other.val.partial_cmp(&self.val)\\n    }\\n}\\n\\nimpl Ord for ListNode {\\n    fn cmp(&self, other: &Self) -> Ordering {\\n        other.val.cmp(&self.val)\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn merge_k_lists(lists: Vec<Option<Box<ListNode>>>) -> Option<Box<ListNode>> {\\n        let mut res = Box::new(ListNode::new(0));\\n        if lists.len() == 0 {\\n            return None;\\n        }\\n        let mut minHeap = BinaryHeap::new();\\n        for mut list in lists {\\n            if list.is_some() {\\n                minHeap.push(list.take()?); // Storing as Option<Box<ListNode>>\\n            }\\n        }\\n        let mut cur = &mut res;\\n        while !minHeap.is_empty() {\\n            cur.next = minHeap.pop(); // Return as Option<Box<ListNode>>\\n            cur = cur.next.as_mut()?;\\n            if cur.next.is_some() {\\n                minHeap.push(cur.next.take()?);\\n            }\\n        }\\n        res.next\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::cmp::Ordering;\\nuse std::collections::BinaryHeap; // BinaryHeap is Max Heap in default\\n\\nimpl PartialOrd<ListNode> for ListNode {\\n    fn partial_cmp(&self, other: &ListNode) -> Option<Ordering> {\\n        other.val.partial_cmp(&self.val)\\n    }\\n}\\n\\nimpl Ord for ListNode {\\n    fn cmp(&self, other: &Self) -> Ordering {\\n        other.val.cmp(&self.val)\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn merge_k_lists(lists: Vec<Option<Box<ListNode>>>) -> Option<Box<ListNode>> {\\n        let mut res = Box::new(ListNode::new(0));\\n        if lists.len() == 0 {\\n            return None;\\n        }\\n        let mut minHeap = BinaryHeap::new();\\n        for mut list in lists {\\n            if list.is_some() {\\n                minHeap.push(list.take()?); // Storing as Option<Box<ListNode>>\\n            }\\n        }\\n        let mut cur = &mut res;\\n        while !minHeap.is_empty() {\\n            cur.next = minHeap.pop(); // Return as Option<Box<ListNode>>\\n            cur = cur.next.as_mut()?;\\n            if cur.next.is_some() {\\n                minHeap.push(cur.next.take()?);\\n            }\\n        }\\n        res.next\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 278855,
                "title": "c-divide-and-conquer",
                "content": "```\\npublic class Solution {\\n    public ListNode MergeKLists(ListNode[] lists) {\\n        if (lists.Length == 0) return null;\\n        return DFS(lists, 0, lists.Length - 1);\\n    }\\n\\n    private ListNode DFS(ListNode[] lists, int left, int right) {\\n        if (left == right) {\\n            return lists[left];\\n        }\\n        var mid = left + (right - left) / 2;\\n        var leftSortedListNode = DFS(lists, left, mid);\\n        var rightSortedListNode = DFS(lists, mid + 1, right);\\n\\n        var mergedSortedListNode = MergeTwoLists(leftSortedListNode, rightSortedListNode);\\n        return mergedSortedListNode;\\n    }\\n\\n    private ListNode MergeTwoLists(ListNode l1, ListNode l2) {\\n        var dummy = new ListNode(-1);\\n\\n        var cur = dummy;\\n        var cur1 = l1;\\n        var cur2 = l2;\\n\\n        while (cur1 != null && cur2 != null) {\\n            if (cur1.val <= cur2.val) {\\n                cur.next = cur1;\\n                cur1 = cur1.next;\\n            } else {\\n                cur.next = cur2;\\n                cur2 = cur2.next;\\n            }\\n\\n            cur = cur.next;\\n        }\\n\\n        while (cur1 != null) {\\n            cur.next = cur1;\\n            cur = cur.next;\\n            cur1 = cur1.next;\\n        }\\n\\n        while (cur2 != null) {\\n            cur.next = cur2;\\n            cur = cur.next;\\n            cur2 = cur2.next;\\n        }\\n\\n        var newHead = dummy.next;\\n        dummy.next = null;\\n\\n        return newHead;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public ListNode MergeKLists(ListNode[] lists) {\\n        if (lists.Length == 0) return null;\\n        return DFS(lists, 0, lists.Length - 1);\\n    }\\n\\n    private ListNode DFS(ListNode[] lists, int left, int right) {\\n        if (left == right) {\\n            return lists[left];\\n        }\\n        var mid = left + (right - left) / 2;\\n        var leftSortedListNode = DFS(lists, left, mid);\\n        var rightSortedListNode = DFS(lists, mid + 1, right);\\n\\n        var mergedSortedListNode = MergeTwoLists(leftSortedListNode, rightSortedListNode);\\n        return mergedSortedListNode;\\n    }\\n\\n    private ListNode MergeTwoLists(ListNode l1, ListNode l2) {\\n        var dummy = new ListNode(-1);\\n\\n        var cur = dummy;\\n        var cur1 = l1;\\n        var cur2 = l2;\\n\\n        while (cur1 != null && cur2 != null) {\\n            if (cur1.val <= cur2.val) {\\n                cur.next = cur1;\\n                cur1 = cur1.next;\\n            } else {\\n                cur.next = cur2;\\n                cur2 = cur2.next;\\n            }\\n\\n            cur = cur.next;\\n        }\\n\\n        while (cur1 != null) {\\n            cur.next = cur1;\\n            cur = cur.next;\\n            cur1 = cur1.next;\\n        }\\n\\n        while (cur2 != null) {\\n            cur.next = cur2;\\n            cur = cur.next;\\n            cur2 = cur2.next;\\n        }\\n\\n        var newHead = dummy.next;\\n        dummy.next = null;\\n\\n        return newHead;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 221538,
                "title": "rust-4ms-no-clone",
                "content": "```\\nuse std::cmp::Ordering;\\nuse std::collections::BinaryHeap;\\n\\nimpl PartialOrd<ListNode> for ListNode {\\n    fn partial_cmp(&self, other: &ListNode) -> Option<Ordering> {\\n        other.val.partial_cmp(&self.val)\\n    }\\n}\\n\\nimpl Ord for ListNode {\\n    fn cmp(&self, other: &Self) -> Ordering {\\n        other.val.cmp(&self.val)\\n    }\\n}\\n\\nimpl Solution {\\n    #[allow(dead_code)]\\n    pub fn merge_k_lists(lists: Vec<Option<Box<ListNode>>>) -> Option<Box<ListNode>> {\\n        let mut heap = BinaryHeap::new();\\n        for mut node in lists {\\n            if node.is_some() {\\n                heap.push(node.take()?)\\n            }\\n        }\\n        let mut head = heap.pop()?;\\n        let mut pointer = &mut head;\\n        while !heap.is_empty() {\\n            if pointer.next.is_some() {\\n                heap.push(pointer.next.take()?);\\n            }\\n            pointer.next = Some(heap.pop()?);\\n            pointer = pointer.next.as_mut()?;\\n        }\\n        Some(head)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::cmp::Ordering;\\nuse std::collections::BinaryHeap;\\n\\nimpl PartialOrd<ListNode> for ListNode {\\n    fn partial_cmp(&self, other: &ListNode) -> Option<Ordering> {\\n        other.val.partial_cmp(&self.val)\\n    }\\n}\\n\\nimpl Ord for ListNode {\\n    fn cmp(&self, other: &Self) -> Ordering {\\n        other.val.cmp(&self.val)\\n    }\\n}\\n\\nimpl Solution {\\n    #[allow(dead_code)]\\n    pub fn merge_k_lists(lists: Vec<Option<Box<ListNode>>>) -> Option<Box<ListNode>> {\\n        let mut heap = BinaryHeap::new();\\n        for mut node in lists {\\n            if node.is_some() {\\n                heap.push(node.take()?)\\n            }\\n        }\\n        let mut head = heap.pop()?;\\n        let mut pointer = &mut head;\\n        while !heap.is_empty() {\\n            if pointer.next.is_some() {\\n                heap.push(pointer.next.take()?);\\n            }\\n            pointer.next = Some(heap.pop()?);\\n            pointer = pointer.next.as_mut()?;\\n        }\\n        Some(head)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 155642,
                "title": "python-beats-98-79",
                "content": "```\\n        if len(lists) == 0 : return None\\n        ls =[]\\n        for oneList in lists:\\n            while oneList:\\n                ls.append(oneList.val)\\n                oneList = oneList.next\\n        ls.sort()\\n        head = dumphead = ListNode(None)\\n        for one in ls:\\n            head.next = ListNode(one)\\n            head = head.next\\n        return dumphead.next\\n\\n```",
                "solutionTags": [],
                "code": "```\\n        if len(lists) == 0 : return None\\n        ls =[]\\n        for oneList in lists:\\n            while oneList:\\n                ls.append(oneList.val)\\n                oneList = oneList.next\\n        ls.sort()\\n        head = dumphead = ListNode(None)\\n        for one in ls:\\n            head.next = ListNode(one)\\n            head = head.next\\n        return dumphead.next\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 10833,
                "title": "java-easy-version-to-understand-two-methods",
                "content": "## Method1 ##\\n\\n    public static ListNode21 MergeSort(ListNode21 head1, ListNode21 head2) {\\n\\t\\tListNode21 head = new ListNode21(0), rear = head, p = head1, q = head2;\\n\\t\\thead.next = null;\\n\\t\\twhile (p != null && q != null) {\\n\\t\\t\\tif (p.val <= q.val) {\\n\\t\\t\\t\\trear.next = p;\\n\\t\\t\\t\\trear = rear.next;\\n\\t\\t\\t\\tp = p.next;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\trear.next = q;\\n\\t\\t\\t\\trear = rear.next;\\n\\t\\t\\t\\tq = q.next;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (p != null)\\n\\t\\t\\trear.next = p;\\n\\t\\tif (q != null)\\n\\t\\t\\trear.next = q;\\n\\t\\treturn head.next;\\n\\t}\\n\\n\\tpublic static ListNode21 Sort(ListNode21[] lists, int low, int high) {\\n\\t\\tif (low < high) {\\n\\t\\t\\tint mid = low + (high - low) / 2;\\n\\t\\t\\tListNode21 head1 = Sort(lists, low, mid);\\n\\t\\t\\tListNode21 head2 = Sort(lists, mid + 1, high);\\n\\t\\t\\treturn MergeSort(head1, head2);\\n\\t\\t} else\\n\\t\\t\\treturn lists[low];\\n\\t}\\n\\n\\tpublic static ListNode21 mergeKLists(ListNode21[] lists) {\\n\\t\\tif (lists == null || lists.length == 0)\\n\\t\\t\\treturn null;\\n\\t\\tif (lists.length == 1)\\n\\t\\t\\treturn lists[0];\\n\\n\\t\\treturn Sort(lists, 0, lists.length - 1);\\n\\n\\t}\\n## Method2 ##\\n\\n    public ListNode mergeKLists(ListNode[] lists) {\\n\\t\\tif (lists == null || lists.length == 0)\\n\\t\\t\\treturn null;\\n\\t\\tif (lists.length == 1)\\n\\t\\t\\treturn lists[0];\\n\\t\\tPriorityQueue<ListNode> heap = new PriorityQueue<>(new Comparator<ListNode>() {\\n\\t\\t\\tpublic int compare(ListNode o1, ListNode o2) {\\n\\t\\t\\t\\treturn o1.val - o2.val;\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\tListNode head = new ListNode(0), rear = head;\\n\\t\\thead.next = null;\\n\\t\\tfor (ListNode node : lists) {\\n\\t\\t      if (node != null)\\n\\t\\t\\t\\theap.offer(node);\\n\\t\\t}\\n\\n\\t\\twhile (!heap.isEmpty()) {\\n\\t\\t\\tListNode p = heap.poll();\\n\\t\\t\\trear.next = p;\\n\\t\\t\\trear = rear.next;\\n\\t\\t\\tp = p.next;\\n\\t\\t\\tif (p != null)\\n\\t\\t\\t\\theap.offer(p);\\n\\t\\t}\\n\\t\\trear.next = null;\\n\\t\\treturn head.next;\\n\\t}",
                "solutionTags": [],
                "code": "## Method1 ##\\n\\n    public static ListNode21 MergeSort(ListNode21 head1, ListNode21 head2) {\\n\\t\\tListNode21 head = new ListNode21(0), rear = head, p = head1, q = head2;\\n\\t\\thead.next = null;\\n\\t\\twhile (p != null && q != null) {\\n\\t\\t\\tif (p.val <= q.val) {\\n\\t\\t\\t\\trear.next = p;\\n\\t\\t\\t\\trear = rear.next;\\n\\t\\t\\t\\tp = p.next;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\trear.next = q;\\n\\t\\t\\t\\trear = rear.next;\\n\\t\\t\\t\\tq = q.next;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (p != null)\\n\\t\\t\\trear.next = p;\\n\\t\\tif (q != null)\\n\\t\\t\\trear.next = q;\\n\\t\\treturn head.next;\\n\\t}\\n\\n\\tpublic static ListNode21 Sort(ListNode21[] lists, int low, int high) {\\n\\t\\tif (low < high) {\\n\\t\\t\\tint mid = low + (high - low) / 2;\\n\\t\\t\\tListNode21 head1 = Sort(lists, low, mid);\\n\\t\\t\\tListNode21 head2 = Sort(lists, mid + 1, high);\\n\\t\\t\\treturn MergeSort(head1, head2);\\n\\t\\t} else\\n\\t\\t\\treturn lists[low];\\n\\t}\\n\\n\\tpublic static ListNode21 mergeKLists(ListNode21[] lists) {\\n\\t\\tif (lists == null || lists.length == 0)\\n\\t\\t\\treturn null;\\n\\t\\tif (lists.length == 1)\\n\\t\\t\\treturn lists[0];\\n\\n\\t\\treturn Sort(lists, 0, lists.length - 1);\\n\\n\\t}\\n## Method2 ##\\n\\n    public ListNode mergeKLists(ListNode[] lists) {\\n\\t\\tif (lists == null || lists.length == 0)\\n\\t\\t\\treturn null;\\n\\t\\tif (lists.length == 1)\\n\\t\\t\\treturn lists[0];\\n\\t\\tPriorityQueue<ListNode> heap = new PriorityQueue<>(new Comparator<ListNode>() {\\n\\t\\t\\tpublic int compare(ListNode o1, ListNode o2) {\\n\\t\\t\\t\\treturn o1.val - o2.val;\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\tListNode head = new ListNode(0), rear = head;\\n\\t\\thead.next = null;\\n\\t\\tfor (ListNode node : lists) {\\n\\t\\t      if (node != null)\\n\\t\\t\\t\\theap.offer(node);\\n\\t\\t}\\n\\n\\t\\twhile (!heap.isEmpty()) {\\n\\t\\t\\tListNode p = heap.poll();\\n\\t\\t\\trear.next = p;\\n\\t\\t\\trear = rear.next;\\n\\t\\t\\tp = p.next;\\n\\t\\t\\tif (p != null)\\n\\t\\t\\t\\theap.offer(p);\\n\\t\\t}\\n\\t\\trear.next = null;\\n\\t\\treturn head.next;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 10836,
                "title": "javascript-solution-with-graph-explanation",
                "content": "    var mergeKLists = function(lists) {\\n        \\n        var tempArry = [], listsLength;\\n        \\n        //Delete all empty entries.\\n        for (var i = 0; i < lists.length; ) {\\n            if (lists[i]) {\\n                i++;\\n            } else {\\n                lists.splice(i, 1);\\n            }\\n        }\\n        if (lists.length === 0) return [];\\n        \\n        while (lists.length > 1) {\\n            listsLength = lists.length;\\n            if (listsLength % 2 !== 0) {\\n                lists.push(null);\\n                listsLength++;\\n            }\\n            for (var i = 0; i < listsLength; i += 2) {\\n                tempArry.push(merge2Lists(lists[i], lists[i + 1]));\\n            }\\n            lists = tempArry;\\n            tempArry = [];\\n        }\\n        return lists[0];\\n        \\n        function merge2Lists(list1, list2) {\\n            var head = new ListNode(0), temp = head;\\n            while (list1 && list2) {\\n                if (list1.val < list2.val) {\\n                    temp.next = new ListNode(list1.val);\\n                    list1 = list1.next;\\n                } else {\\n                    temp.next = new ListNode(list2.val);\\n                    list2 = list2.next;\\n                }\\n                temp = temp.next;\\n            }\\n            temp.next = list1 ? list1 : list2;\\n            return head.next;\\n        }\\n    };\\n\\n\\n\\n    1  |   |  |   |  |   .\\n    2    |      |      |     .\\n    3        |            |\\n    4              |\\n\\nLine1 is an array, each element is a ListNode (as \"|\" in the graph). If the length of current array is odd, add an null element(as \".\" in the graph), compare them two by two ,put the results into a new array (line2). Keep doing until the length of the result array is 1, which means we merged all elements, and it is the result.",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "    var mergeKLists = function(lists) {\\n        \\n        var tempArry = [], listsLength;\\n        \\n        //Delete all empty entries.\\n        for (var i = 0; i < lists.length; ) {\\n            if (lists[i]) {\\n                i++;\\n            } else {\\n                lists.splice(i, 1);\\n            }\\n        }\\n        if (lists.length === 0) return [];\\n        \\n        while (lists.length > 1) {\\n            listsLength = lists.length;\\n            if (listsLength % 2 !== 0) {\\n                lists.push(null);\\n                listsLength++;\\n            }\\n            for (var i = 0; i < listsLength; i += 2) {\\n                tempArry.push(merge2Lists(lists[i], lists[i + 1]));\\n            }\\n            lists = tempArry;\\n            tempArry = [];\\n        }\\n        return lists[0];\\n        \\n        function merge2Lists(list1, list2) {\\n            var head = new ListNode(0), temp = head;\\n            while (list1 && list2) {\\n                if (list1.val < list2.val) {\\n                    temp.next = new ListNode(list1.val);\\n                    list1 = list1.next;\\n                } else {\\n                    temp.next = new ListNode(list2.val);\\n                    list2 = list2.next;\\n                }\\n                temp = temp.next;\\n            }\\n            temp.next = list1 ? list1 : list2;\\n            return head.next;\\n        }\\n    };\\n\\n\\n\\n    1  |   |  |   |  |   .\\n    2    |      |      |     .\\n    3        |            |\\n    4              |\\n\\nLine1 is an array, each element is a ListNode (as \"|\" in the graph). If the length of current array is odd, add an null element(as \".\" in the graph), compare them two by two ,put the results into a new array (line2). Keep doing until the length of the result array is 1, which means we merged all elements, and it is the result.",
                "codeTag": "Unknown"
            },
            {
                "id": 10924,
                "title": "java-merge-sort-version",
                "content": "    public class Solution {\\n    \\n    public ListNode mergeKLists(ListNode[] lists) {\\n        if(lists == null || lists.length == 0 ){\\n            return null;\\n        }\\n        return mergeKLists(lists,0,lists.length-1);\\n    }\\n    \\n    public ListNode mergeKLists(ListNode[] lists, int left, int right){\\n        if(left < right){\\n            int mid = (left + right)/2;\\n            return merge(mergeKLists(lists,left,mid),mergeKLists(lists,mid+1,right));\\n        }\\n        return lists[left];\\n    }\\n    \\n    public ListNode merge(ListNode n1, ListNode n2){\\n        ListNode head =  new ListNode(0);\\n        ListNode n = head;\\n        while(n1 != null && n2 != null){\\n            if(n1.val < n2.val){\\n                n.next = n1;\\n                n1 = n1.next;\\n                n = n.next;\\n            }else{\\n                n.next = n2;\\n                n = n.next;\\n                n2 = n2.next;\\n            }\\n        }\\n        if( n1 != null){\\n            n.next = n1;\\n        }else{\\n            n.next = n2;\\n        }\\n        return head.next;\\n    }\\n \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    public ListNode mergeKLists(ListNode[] lists) {\\n        if(lists == null || lists.length == 0 ){\\n            return null;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3896470,
                "title": "map",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        map<int, int> mp;\\n        int k = lists.size();\\n\\n        for (int i=0; i<k; i++) {\\n            ListNode *node = lists[i];\\n            while (node) {\\n                mp[node->val]++;\\n                node = node->next;\\n            }\\n        }\\n\\n        ListNode* res = new ListNode();\\n        ListNode* head = res;\\n\\n        for (auto [num, freq]: mp) {\\n            while (freq--) {\\n                res->next = new ListNode(num);\\n                res = res->next;\\n            }\\n        }\\n\\n        return head->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        map<int, int> mp;\\n        int k = lists.size();\\n\\n        for (int i=0; i<k; i++) {\\n            ListNode *node = lists[i];\\n            while (node) {\\n                mp[node->val]++;\\n                node = node->next;\\n            }\\n        }\\n\\n        ListNode* res = new ListNode();\\n        ListNode* head = res;\\n\\n        for (auto [num, freq]: mp) {\\n            while (freq--) {\\n                res->next = new ListNode(num);\\n                res = res->next;\\n            }\\n        }\\n\\n        return head->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3289037,
                "title": "easy-python-solution-using-lists-runtime-67ms-97-85-conversion-of-linked-list-to-list",
                "content": "![image.png](https://assets.leetcode.com/users/images/e935d42c-c04e-45e9-b216-b33d31fe1917_1678638712.3862686.png)\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        \"\"\"\\n        :type lists: List[ListNode]\\n        :rtype: ListNode\\n        \"\"\"\\n        lst=[]\\n        for i in lists:\\n            while i:\\n                lst.append(i.val)\\n                i=i.next\\n        lst.sort()\\n        a=ListNode(0)\\n        tmp=a\\n        for i in lst:\\n            tmp.next=ListNode(i)\\n            tmp=tmp.next\\n        return a.next\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List",
                    "Divide and Conquer",
                    "Heap (Priority Queue)",
                    "Merge Sort"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        \"\"\"\\n        :type lists: List[ListNode]\\n        :rtype: ListNode\\n        \"\"\"\\n        lst=[]\\n        for i in lists:\\n            while i:\\n                lst.append(i.val)\\n                i=i.next\\n        lst.sort()\\n        a=ListNode(0)\\n        tmp=a\\n        for i in lst:\\n            tmp.next=ListNode(i)\\n            tmp=tmp.next\\n        return a.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3287123,
                "title": "python-short-and-clean-heap-priority-queue",
                "content": "# Approach\\n1. Throw the head of each non empty `LinkedList` into a `min_heap`.\\n\\n2. Pop the `node` with smallest value and append it to the `Merged LinkedList`.\\n\\n3. Put back the `node.next` into the `min_heap`.\\n\\n4. Continue until the heap is empty.\\n\\n# Complexity\\n- Time complexity: $$O(n * log(k))$$\\n\\n- Space complexity: $$O(k)$$\\n\\nwhere,\\n`k is the number of LinkedLists in lists`,\\n`n is the total number of nodes across all lists`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def mergeKLists(self, lists: list[ListNode | None]) -> ListNode | None:\\n        ListNode.__lt__ = lambda self, x: self.val < x.val\\n\\n        merged_head = merged_tail = ListNode()\\n        hq = [ll for ll in lists if ll is not None]\\n        heapify(hq)\\n\\n        while hq:\\n            node = heappop(hq)\\n            if node.next: heappush(hq, node.next)\\n            \\n            merged_tail.next = ListNode(node.val)\\n            merged_tail = merged_tail.next\\n        \\n        return merged_head.next\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Heap (Priority Queue)",
                    "Merge Sort"
                ],
                "code": "```python\\nclass Solution:\\n    def mergeKLists(self, lists: list[ListNode | None]) -> ListNode | None:\\n        ListNode.__lt__ = lambda self, x: self.val < x.val\\n\\n        merged_head = merged_tail = ListNode()\\n        hq = [ll for ll in lists if ll is not None]\\n        heapify(hq)\\n\\n        while hq:\\n            node = heappop(hq)\\n            if node.next: heappush(hq, node.next)\\n            \\n            merged_tail.next = ListNode(node.val)\\n            merged_tail = merged_tail.next\\n        \\n        return merged_head.next\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286924,
                "title": "two-pointer-approach-o-n-c-fully-explained",
                "content": "# Intuition\\nGiven that the input linked lists are already sorted, a simple approach to merge them would be to repeatedly merge pairs of lists until only one is left, and return the final merged list. This can be achieved by iterating over the input list of linked lists, and merging the current list with the previously merged list. The merged list can then be used as the input for the next iteration, until all the lists have been merged into one. Once the merging is complete, the final merged list can be returned.link\\n\\n# Approach\\nThe $$solver()$$ function takes in two ListNode pointers, a and b, which represent the heads of two sorted linked lists. It then iteratively compares the values of the nodes in the two linked lists and merges them into a new linked list in sorted order. Once one of the linked lists is exhausted, the remaining nodes in the other list are appended to the new linked list. Finally, the function returns the head of the new merged linked list.\\n\\nThe $$solver()$$ function creates a new dummy node with a value of -1 to serve as the head of the new merged linked list. The new nodes are then appended to this dummy node, and its next pointer is updated to point to the next new node. At the end of the function, the head of the merged list is returned by accessing the next pointer of the dummy node.\\n\\nThe $$mergeKLists()$$ function creates a new dummy node with a value of -100000 to serve as the head of the final merged linked list. It then iterates over the vector of ListNode pointers, repeatedly merging pairs of linked lists using the $$solver()$$ function. The final merged linked list is returned by accessing the next pointer of the dummy node.\\n\\n# Complexity\\n- Time complexity: **O(n)**\\n\\n- Space complexity: **O(1)**\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\n    ListNode* solver(ListNode* a, ListNode* b){\\n        if(!a) return b;\\n        if(!b) return a;\\n        ListNode* res = new ListNode(-1);\\n        ListNode* r = res;\\n        while(a && b){\\n            if(a->val<b->val){\\n                res->next = a;\\n                res = res->next;\\n                a = a->next;\\n            }\\n            else{\\n                res->next = b;\\n                res = res->next;\\n                b = b->next;\\n            }\\n        }\\n        while(a){\\n            res->next = a;\\n            res = res->next;\\n            a = a->next;\\n        }\\n        while(b){\\n            res->next = b;\\n            res = res->next;\\n            b = b->next;\\n        }\\n        return r->next;\\n    }\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* res = new ListNode(-100000);\\n        for(int i =0;i<lists.size();i++){\\n            res = solver(res,lists[i]);\\n        }\\n        return res->next;\\n        \\n    }\\n};\\n```\\n\\n**Please upvote if it helped you.**",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\n    ListNode* solver(ListNode* a, ListNode* b){\\n        if(!a) return b;\\n        if(!b) return a;\\n        ListNode* res = new ListNode(-1);\\n        ListNode* r = res;\\n        while(a && b){\\n            if(a->val<b->val){\\n                res->next = a;\\n                res = res->next;\\n                a = a->next;\\n            }\\n            else{\\n                res->next = b;\\n                res = res->next;\\n                b = b->next;\\n            }\\n        }\\n        while(a){\\n            res->next = a;\\n            res = res->next;\\n            a = a->next;\\n        }\\n        while(b){\\n            res->next = b;\\n            res = res->next;\\n            b = b->next;\\n        }\\n        return r->next;\\n    }\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* res = new ListNode(-100000);\\n        for(int i =0;i<lists.size();i++){\\n            res = solver(res,lists[i]);\\n        }\\n        return res->next;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286172,
                "title": "java-solution-using-priorityqueue",
                "content": "# code\\n- just use priority queue\\n- make a list node of ans\\n- then keep curr to add the elements to ans\\n- then pop from the  priority queue and then move curr to next check if the next element of curr is not null if not null then offer the next element to queue\\n- if this was helpful like++\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        PriorityQueue<ListNode>pq= new PriorityQueue<ListNode>((a,b)-> a.val-b.val);\\n        if(lists==null || lists.length==0) return null;\\n        for(ListNode x:lists)\\n        {\\n            if(x!=null)\\n            pq.offer(x);\\n        }\\n        ListNode ans=new ListNode(-1);\\n        ListNode curr=ans;\\n        while(!pq.isEmpty())\\n        {\\n            curr.next=pq.poll();\\n            curr=curr.next;\\n            if(curr.next!=null)\\n                pq.offer(curr.next);\\n        }\\n        return ans.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        PriorityQueue<ListNode>pq= new PriorityQueue<ListNode>((a,b)-> a.val-b.val);\\n        if(lists==null || lists.length==0) return null;\\n        for(ListNode x:lists)\\n        {\\n            if(x!=null)\\n            pq.offer(x);\\n        }\\n        ListNode ans=new ListNode(-1);\\n        ListNode curr=ans;\\n        while(!pq.isEmpty())\\n        {\\n            curr.next=pq.poll();\\n            curr=curr.next;\\n            if(curr.next!=null)\\n                pq.offer(curr.next);\\n        }\\n        return ans.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286041,
                "title": "two-solutions-using-minheap-and-ordered-set",
                "content": "# Complexity\\n- Time complexity:\\nO(NlogK), where K is the number of Sorted Lists/lists.size(), since at a time *atmost* K elements in MinHeap or OrderedSet\\n\\n- Space complexity:\\nO(N)\\n\\n# Using Min_Heap\\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>&lists) \\n    {\\n        //instead of checking everytime k lists and appending minimum of all to our answer list, maintain priority queue which gives us the minimum element in O(1) instead of O(K), where K is number of lists.\\n        //Sure O(logN) time would be required to insert and delete but its far off better than linear time\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>minheap;//value,index of ListNode in vector\\n        for(int i=0;i<lists.size();i++)\\n        {\\n            if(lists[i]!=NULL)\\n            {\\n                minheap.push({lists[i]->val,i});\\n            }\\n        }\\n        if(minheap.empty())//Edge Case Handling\\n        {\\n            return NULL;\\n        }\\n        ListNode* node=new ListNode();\\n        ListNode* head=node;//store the head of ans\\n        while(1)\\n        {\\n            pair<int,int>x=minheap.top();\\n            minheap.pop();\\n            node->val=x.first;\\n            if(lists[x.second]->next!=NULL)//check if end of list not reached\\n            {\\n                lists[x.second]=lists[x.second]->next;//traverse list further\\n                minheap.push({lists[x.second]->val,x.second});//push value of current pointer at this list\\n            }\\n            if(!minheap.empty())//still elements exist to insert in list\\n            {\\n                node->next=new ListNode();\\n                node=node->next;\\n            }\\n            else//all elements inserted and lists traversed\\n            {\\n                break;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```\\n# Using Ordered_Set\\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>&lists) \\n    {\\n        //same concept of pair as before\\n        set<pair<int,int>>listmin;\\n        for(int i=0;i<lists.size();i++)\\n        {\\n            if(lists[i]!=NULL)\\n            {\\n                listmin.insert({lists[i]->val,i});\\n            }\\n        }\\n        if(listmin.empty())\\n        {\\n            return NULL;\\n        }\\n        ListNode* node=new ListNode();\\n        ListNode* head=node;\\n        while(1)\\n        {\\n            pair<int,int>x=*(listmin.begin());\\n            listmin.erase(listmin.begin());\\n            node->val=x.first;\\n            if(lists[x.second]->next!=NULL)\\n            {\\n                lists[x.second]=lists[x.second]->next;\\n                listmin.insert({lists[x.second]->val,x.second});\\n            }\\n            if(!listmin.empty())\\n            {\\n                node->next=new ListNode();\\n                node=node->next;\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>&lists) \\n    {\\n        //instead of checking everytime k lists and appending minimum of all to our answer list, maintain priority queue which gives us the minimum element in O(1) instead of O(K), where K is number of lists.\\n        //Sure O(logN) time would be required to insert and delete but its far off better than linear time\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>minheap;//value,index of ListNode in vector\\n        for(int i=0;i<lists.size();i++)\\n        {\\n            if(lists[i]!=NULL)\\n            {\\n                minheap.push({lists[i]->val,i});\\n            }\\n        }\\n        if(minheap.empty())//Edge Case Handling\\n        {\\n            return NULL;\\n        }\\n        ListNode* node=new ListNode();\\n        ListNode* head=node;//store the head of ans\\n        while(1)\\n        {\\n            pair<int,int>x=minheap.top();\\n            minheap.pop();\\n            node->val=x.first;\\n            if(lists[x.second]->next!=NULL)//check if end of list not reached\\n            {\\n                lists[x.second]=lists[x.second]->next;//traverse list further\\n                minheap.push({lists[x.second]->val,x.second});//push value of current pointer at this list\\n            }\\n            if(!minheap.empty())//still elements exist to insert in list\\n            {\\n                node->next=new ListNode();\\n                node=node->next;\\n            }\\n            else//all elements inserted and lists traversed\\n            {\\n                break;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>&lists) \\n    {\\n        //same concept of pair as before\\n        set<pair<int,int>>listmin;\\n        for(int i=0;i<lists.size();i++)\\n        {\\n            if(lists[i]!=NULL)\\n            {\\n                listmin.insert({lists[i]->val,i});\\n            }\\n        }\\n        if(listmin.empty())\\n        {\\n            return NULL;\\n        }\\n        ListNode* node=new ListNode();\\n        ListNode* head=node;\\n        while(1)\\n        {\\n            pair<int,int>x=*(listmin.begin());\\n            listmin.erase(listmin.begin());\\n            node->val=x.first;\\n            if(lists[x.second]->next!=NULL)\\n            {\\n                lists[x.second]=lists[x.second]->next;\\n                listmin.insert({lists[x.second]->val,x.second});\\n            }\\n            if(!listmin.empty())\\n            {\\n                node->next=new ListNode();\\n                node=node->next;\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3219544,
                "title": "easy-peasy-python-solution-cheers",
                "content": "\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        if not lists or len(lists)==0:\\n            return None\\n        while len(lists)>1:\\n            combined_lists=[]\\n            for i in range(0,len(lists),2):\\n                list1=lists[i]\\n                list2=lists[i+1] if (i+1) <len(lists) else None\\n                combined_lists.append(self.merge_list(list1,list2))\\n            lists=combined_lists\\n        return lists[0]\\n\\n\\n    def merge_list(self,x,y):\\n        dummy=ListNode()\\n        tail=dummy  \\n        while x and y:\\n            if x.val < y.val:\\n                tail.next=x\\n                x=x.next\\n            else:\\n                tail.next=y\\n                y=y.next\\n            tail=tail.next\\n        if x:\\n            tail.next=x\\n        if y:\\n            tail.next=y\\n        return dummy.next\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        if not lists or len(lists)==0:\\n            return None\\n        while len(lists)>1:\\n            combined_lists=[]\\n            for i in range(0,len(lists),2):\\n                list1=lists[i]\\n                list2=lists[i+1] if (i+1) <len(lists) else None\\n                combined_lists.append(self.merge_list(list1,list2))\\n            lists=combined_lists\\n        return lists[0]\\n\\n\\n    def merge_list(self,x,y):\\n        dummy=ListNode()\\n        tail=dummy  \\n        while x and y:\\n            if x.val < y.val:\\n                tail.next=x\\n                x=x.next\\n            else:\\n                tail.next=y\\n                y=y.next\\n            tail=tail.next\\n        if x:\\n            tail.next=x\\n        if y:\\n            tail.next=y\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207548,
                "title": "c-hash-map-solution-95-96",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        map<int, int> mp;\\n        for(auto& ln : lists){\\n            while(ln){\\n                mp[ln->val]++;\\n                ln = ln->next;\\n            }\\n        }\\n        if(!mp.size())  return nullptr;\\n        ListNode* ans = new ListNode();\\n        ListNode* p = ans;\\n        for(auto& v: mp){\\n            for(int i{}; i<v.second; i++){\\n                p->next = new ListNode(v.first);\\n                p = p->next;\\n            }\\n            \\n        }\\n        return ans->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        map<int, int> mp;\\n        for(auto& ln : lists){\\n            while(ln){\\n                mp[ln->val]++;\\n                ln = ln->next;\\n            }\\n        }\\n        if(!mp.size())  return nullptr;\\n        ListNode* ans = new ListNode();\\n        ListNode* p = ans;\\n        for(auto& v: mp){\\n            for(int i{}; i<v.second; i++){\\n                p->next = new ListNode(v.first);\\n                p = p->next;\\n            }\\n            \\n        }\\n        return ans->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3173495,
                "title": "easy-min-heap-c-solution-step-wise-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPick the smallest node from the head of `k` lists and then move the `head` of the smallest node to `head->next`. We can continue doing this process till we exhaust all lists.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Create a min heap of `k` size .\\n- To the tail of answer list , append the top of the min heap.\\n- Save the top pointer of min heap as `temp`.\\n- pop the top of heap .\\n- Append next pointer of `temp` i.e `temp->next` again to min heap if its not NULL.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Compare {\\n    public:\\n       bool operator()(ListNode* a, ListNode* b){\\n           \\n           return a->val > b->val;\\n      }\\n};\\nclass Solution {\\npublic:\\n\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        int k=lists.size();\\n        ListNode *head=NULL;\\n        ListNode *tail=NULL;\\n        priority_queue< ListNode*, vector<ListNode*> , Compare > pq;\\n        for(int i=0 ; i<k ;i++)\\n        {\\n            if(lists[i]!=NULL)\\n                pq.push(lists[i]);\\n        }\\n\\n        while(!pq.empty())\\n        {\\n            ListNode* temp=pq.top();  \\n            pq.pop();\\n\\n            if(head==NULL && tail==NULL){\\n                head=temp;\\n                tail=temp;\\n            }\\n            else{\\n                tail->next=temp;\\n                tail=tail->next;\\n            }\\n\\n            temp=temp->next;\\n            if(temp!=NULL)\\n                pq.push(temp);\\n        }\\n\\n        return head;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity: `O( N log k ) `\\n    - `O(log k)` for inserting one node in the min heap.\\n    - There are `N` node to be inserted.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(N)`\\n    - `N` new nodes are created for answer list.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Note\\n- Instead of using a custom comparator class for a min heap we can use a `pair< -value , list_pointer >` based priority_queue.\\n ```\\n priority_queue< pair<int,ListNode*> > pq;\\n```\\n- while pushing the value in priority queue make sure you push the negative values because this is a max heap and adding a `- value` of the list will make sure the smallest absolute value `|-value|` is at the top of heap.\\n```\\npq.push( { -lists[i]->val , lists[i] } );\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Compare {\\n    public:\\n       bool operator()(ListNode* a, ListNode* b){\\n           \\n           return a->val > b->val;\\n      }\\n};\\nclass Solution {\\npublic:\\n\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        int k=lists.size();\\n        ListNode *head=NULL;\\n        ListNode *tail=NULL;\\n        priority_queue< ListNode*, vector<ListNode*> , Compare > pq;\\n        for(int i=0 ; i<k ;i++)\\n        {\\n            if(lists[i]!=NULL)\\n                pq.push(lists[i]);\\n        }\\n\\n        while(!pq.empty())\\n        {\\n            ListNode* temp=pq.top();  \\n            pq.pop();\\n\\n            if(head==NULL && tail==NULL){\\n                head=temp;\\n                tail=temp;\\n            }\\n            else{\\n                tail->next=temp;\\n                tail=tail->next;\\n            }\\n\\n            temp=temp->next;\\n            if(temp!=NULL)\\n                pq.push(temp);\\n        }\\n\\n        return head;\\n    }\\n};\\n```\n```\\n priority_queue< pair<int,ListNode*> > pq;\\n```\n```\\npq.push( { -lists[i]->val , lists[i] } );\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2682524,
                "title": "simple-cpp-approach-using-priority-queue",
                "content": "My solution took 39ms and faster that 69.61 % and is easy to understand and implement\\n* * In the below solution i have used min heap which will traverse all the linked list and create a min heap of values \\n* After storing all the values we can traverse min heap extract value from there create node of the value and generate a new linked list\\nNote:- In starting we also initialize a dummy node (-1) and we keep on adding our nodes into its next till the min heap become empty and at last return dummy->next\\n\\nBelow is the CPP Code\\n```\\nListNode* mergeKLists(vector<ListNode*>& lists)\\n    {\\n        \\n        ListNode *head = new ListNode(-1);\\n        ListNode *node = head;\\n        int n = lists.size();\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        for(int i=0;i<n;i++)\\n        {\\n            ListNode *newhead = lists[i];\\n            while(newhead!=NULL)\\n            {\\n                pq.push(newhead->val);\\n                newhead = newhead->next;\\n            }\\n        }\\n        while(pq.empty()!=true)\\n        {\\n            node->next = new ListNode(pq.top());\\n            pq.pop();\\n            node = node->next;\\n        }\\n        return head->next;\\n    }\\n```\\n**If you find my solution helpful and understood well please dont forget to upvote and comment or if you have any suggestion to give**\\n**Happy Coding  !!!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nListNode* mergeKLists(vector<ListNode*>& lists)\\n    {\\n        \\n        ListNode *head = new ListNode(-1);\\n        ListNode *node = head;\\n        int n = lists.size();\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        for(int i=0;i<n;i++)\\n        {\\n            ListNode *newhead = lists[i];\\n            while(newhead!=NULL)\\n            {\\n                pq.push(newhead->val);\\n                newhead = newhead->next;\\n            }\\n        }\\n        while(pq.empty()!=true)\\n        {\\n            node->next = new ListNode(pq.top());\\n            pq.pop();\\n            node = node->next;\\n        }\\n        return head->next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2668940,
                "title": "c-priority-queue-easy-to-understand-well-explained",
                "content": "class Solution {\\npublic:\\n\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n     \\n        int n = lists.size();\\n\\t\\t// if size of lists is zero then return zero.\\n        if(n == 0)\\n        {\\n            return NULL;\\n        }\\n\\t\\t// initialize min heap/ min(priority queue). \\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        int i;\\n\\t\\t// iterate the lists and store each element of each list in priority queue.\\n\\t\\t// in min heap/priority queue every time we pop element from the top the top element will the smallest of all elements in heap.\\n\\t\\t\\n        for(i=0;i<n;i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp != NULL)\\n            {\\n                pq.push(temp->val);\\n                temp = temp->next;\\n            }\\n        }\\n          // so we take the advantage of priority queue and every time pop the smallest element from the heap.\\n         // now make a new linked list and return  sorted linked list  .\\n      \\n\\t  ListNode* start = new ListNode(0);\\n        ListNode* head = start;\\n        while(!pq.empty())\\n        {\\n            head->next = new ListNode(pq.top());\\n            pq.pop();\\n            head = head->next;\\n        }\\n        return start->next;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n     \\n        int n = lists.size();\\n\\t\\t// if size of lists is zero then return zero.\\n        if(n == 0)\\n        {\\n            return NULL;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2642666,
                "title": "easy-to-understand-solution-for-beginners-using-vector-c",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        int k = lists.size(); \\n        \\n        if(k==0) return NULL;\\n        vector<int> datum;\\n        \\n        for(int i=0; i<lists.size(); i++){\\n            ListNode* temp = lists[i];\\n            while(temp){\\n                datum.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(datum.size()==NULL) return NULL;\\n        sort(datum.begin(), datum.end());\\n        \\n        int cnt=0;\\n        ListNode* res = new ListNode();\\n        ListNode* head = res;\\n        \\n        for(int &i: datum){\\n            res->val = i;\\n            cnt++;\\n            if(cnt!=datum.size()){\\n                ListNode* newNode = new ListNode();\\n                res->next=newNode;\\n                res=res->next;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        int k = lists.size(); \\n        \\n        if(k==0) return NULL;\\n        vector<int> datum;\\n        \\n        for(int i=0; i<lists.size(); i++){\\n            ListNode* temp = lists[i];\\n            while(temp){\\n                datum.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(datum.size()==NULL) return NULL;\\n        sort(datum.begin(), datum.end());\\n        \\n        int cnt=0;\\n        ListNode* res = new ListNode();\\n        ListNode* head = res;\\n        \\n        for(int &i: datum){\\n            res->val = i;\\n            cnt++;\\n            if(cnt!=datum.size()){\\n                ListNode* newNode = new ListNode();\\n                res->next=newNode;\\n                res=res->next;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2515362,
                "title": "python-easy-o-n-logn",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        \\n        if not lists or len(lists)==0:\\n            return None\\n        \\n        \\n        while(len(lists)>1):\\n            mergedlist =[]\\n            \\n            for i in range(0,len(lists),2):\\n                \\n                l1 = lists[i]\\n                l2 = lists[i+1] if i+1<len(lists) else None\\n                \\n                mergedlist.append(self.mergetwo(l1,l2))\\n                \\n            lists = mergedlist\\n            \\n        return lists[0]\\n    \\n    def mergetwo(self,l1,l2):\\n        \\n        dummy = ListNode()\\n        tail = dummy\\n        \\n        while l1 and l2:\\n            if l1.val<l2.val:\\n                tail.next = l1\\n                l1 = l1.next\\n            else:\\n                tail.next = l2\\n                l2 = l2.next\\n                \\n            tail = tail.next\\n            \\n            \\n        if l1:\\n            tail.next = l1\\n            \\n        if l2:\\n            tail.next = l2\\n            \\n        return dummy.next    \\n           \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        \\n        if not lists or len(lists)==0:\\n            return None\\n        \\n        \\n        while(len(lists)>1):\\n            mergedlist =[]\\n            \\n            for i in range(0,len(lists),2):\\n                \\n                l1 = lists[i]\\n                l2 = lists[i+1] if i+1<len(lists) else None\\n                \\n                mergedlist.append(self.mergetwo(l1,l2))\\n                \\n            lists = mergedlist\\n            \\n        return lists[0]\\n    \\n    def mergetwo(self,l1,l2):\\n        \\n        dummy = ListNode()\\n        tail = dummy\\n        \\n        while l1 and l2:\\n            if l1.val<l2.val:\\n                tail.next = l1\\n                l1 = l1.next\\n            else:\\n                tail.next = l2\\n                l2 = l2.next\\n                \\n            tail = tail.next\\n            \\n            \\n        if l1:\\n            tail.next = l1\\n            \\n        if l2:\\n            tail.next = l2\\n            \\n        return dummy.next    \\n           \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2383609,
                "title": "java-c-python-javascript-kotlin-o-n-time-beats-99-97-memory-speed-0ms-july-2022",
                "content": "***Hello it would be my pleasure to introduce myself Darian.***\\n\\n<iframe src=\"https://leetcode.com/playground/f9u8nVkh/shared\" frameBorder=\"0\" width=\"1000\" height=\"1000\"></iframe>\\n\\n***Consider upvote if useful! Hopefully it can be used in your advantage!***\\n***Take care brother, peace, love!***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin"
                ],
                "code": "***Hello it would be my pleasure to introduce myself Darian.***\\n\\n<iframe src=\"https://leetcode.com/playground/f9u8nVkh/shared\" frameBorder=\"0\" width=\"1000\" height=\"1000\"></iframe>\\n\\n***Consider upvote if useful! Hopefully it can be used in your advantage!***\\n***Take care brother, peace, love!***",
                "codeTag": "Unknown"
            },
            {
                "id": 1848828,
                "title": "easy-python-min-heap-solution-faster-than-87",
                "content": "Heap is the best data structure for this problem.\\n```\\nclass Solution:\\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        min_heap = []\\n        for i in range(len(lists)):\\n            if lists[i]:\\n                min_heap.append((lists[i].val, i))\\n        heapq.heapify(min_heap)\\n        \\n        res = current = ListNode()\\n        \\n        while len(min_heap): \\n            ID = heapq.heappop(min_heap)[1]\\n            current.next = lists[ID]\\n            current = current.next\\n            lists[ID] = lists[ID].next\\n            if lists[ID]:\\n                heapq.heappush(min_heap, (lists[ID].val, ID))\\n                \\n        return res.next\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        min_heap = []\\n        for i in range(len(lists)):\\n            if lists[i]:\\n                min_heap.append((lists[i].val, i))\\n        heapq.heapify(min_heap)\\n        \\n        res = current = ListNode()\\n        \\n        while len(min_heap): \\n            ID = heapq.heappop(min_heap)[1]\\n            current.next = lists[ID]\\n            current = current.next\\n            lists[ID] = lists[ID].next\\n            if lists[ID]:\\n                heapq.heappush(min_heap, (lists[ID].val, ID))\\n                \\n        return res.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1775553,
                "title": "merge-k-sorted-lists-min-priority-queue-brute-force-easy-way",
                "content": "So My approach was the simpler one,\\n\\nFirst traverse the all given linked list and store their values in a min priority queue and then make a linked list out of it.\\n\\n```\\n ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        priority_queue<int, vector<int> ,greater<int>> pq;\\n        \\n        for(int i =0;i<lists.size();i++){\\n            ListNode* head= lists[i];\\n            while(head != NULL){\\n                pq.push(head->val);\\n                head=head->next;\\n            }\\n        }\\n        \\n        \\n       ListNode* head = NULL;\\n       ListNode* tail = NULL;\\n\\n        while(!pq.empty()){\\n            ListNode * newNode = new ListNode (pq.top());\\n            pq.pop();\\n            \\n            if(head== NULL){\\n                head= newNode;\\n                tail = newNode;\\n            }else{\\n                tail->next = newNode;\\n                tail = tail->next;\\n            }\\n            \\n        }\\n    return head;\\n    }\\n```\\nSuggestions are always welcomed ! :)\\nthank you for giving your time , If you liked this please upvote",
                "solutionTags": [
                    "Linked List",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        priority_queue<int, vector<int> ,greater<int>> pq;\\n        \\n        for(int i =0;i<lists.size();i++){\\n            ListNode* head= lists[i];\\n            while(head != NULL){\\n                pq.push(head->val);\\n                head=head->next;\\n            }\\n        }\\n        \\n        \\n       ListNode* head = NULL;\\n       ListNode* tail = NULL;\\n\\n        while(!pq.empty()){\\n            ListNode * newNode = new ListNode (pq.top());\\n            pq.pop();\\n            \\n            if(head== NULL){\\n                head= newNode;\\n                tail = newNode;\\n            }else{\\n                tail->next = newNode;\\n                tail = tail->next;\\n            }\\n            \\n        }\\n    return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1747547,
                "title": "python-3-90ms-divide-and-conquer-approach",
                "content": "```\\nclass Solution:\\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        if not len(lists):\\n            return None\\n        \\n        while len(lists) > 1:\\n            newLists = [] \\n            for i in range(0, len(lists), 2):\\n                LL1 = lists[i]\\n                LL2 = lists[i + 1] if (i + 1) < len(lists) else None\\n                mergedList = self.merge2List(LL1, LL2)\\n                newLists.append(mergedList)\\n            lists = newLists\\n        return lists[0]\\n                \\n    def merge2List(self, l1, l2):\\n        dummy = ListNode()\\n        current = dummy\\n        while l1 and l2:\\n            if l1.val < l2.val:\\n                current.next = l1\\n                l1 = l1.next\\n            else:\\n                current.next = l2\\n                l2 = l2.next\\n            current = current.next\\n        if l1:\\n            current.next = l1\\n        if l2:\\n            current.next = l2\\n        return dummy.next\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Divide and Conquer",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution:\\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        if not len(lists):\\n            return None\\n        \\n        while len(lists) > 1:\\n            newLists = [] \\n            for i in range(0, len(lists), 2):\\n                LL1 = lists[i]\\n                LL2 = lists[i + 1] if (i + 1) < len(lists) else None\\n                mergedList = self.merge2List(LL1, LL2)\\n                newLists.append(mergedList)\\n            lists = newLists\\n        return lists[0]\\n                \\n    def merge2List(self, l1, l2):\\n        dummy = ListNode()\\n        current = dummy\\n        while l1 and l2:\\n            if l1.val < l2.val:\\n                current.next = l1\\n                l1 = l1.next\\n            else:\\n                current.next = l2\\n                l2 = l2.next\\n            current = current.next\\n        if l1:\\n            current.next = l1\\n        if l2:\\n            current.next = l2\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1746615,
                "title": "c-simple-easy-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    ListNode* merge(ListNode* list1, ListNode* list2)\\n    {\\n        if(list1==NULL)\\n            return list2;\\n        if(list2==NULL)\\n            return list1;\\n        \\n        ListNode* res;\\n        if(list1->val < list2->val)\\n        {\\n            res=list1;\\n            res->next=merge(list1->next,list2);\\n        }\\n        else\\n        {\\n            res=list2;\\n            res->next=merge(list1,list2->next);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    ListNode* mergeKLists(vector<ListNode*>& v) {\\n        \\n        if(v.size()==0)\\n            return NULL;\\n        \\n        while(v.size()!=1)\\n        {\\n            ListNode* x=v[0];\\n            v.erase(v.begin());\\n            ListNode* y=v[0];\\n            v.erase(v.begin());\\n            ListNode* z=merge(x,y);\\n            v.push_back(z);\\n        }\\n        \\n        return v[0];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    ListNode* merge(ListNode* list1, ListNode* list2)\\n    {\\n        if(list1==NULL)\\n            return list2;\\n        if(list2==NULL)\\n            return list1;\\n        \\n        ListNode* res;\\n        if(list1->val < list2->val)\\n        {\\n            res=list1;\\n            res->next=merge(list1->next,list2);\\n        }\\n        else\\n        {\\n            res=list2;\\n            res->next=merge(list1,list2->next);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    ListNode* mergeKLists(vector<ListNode*>& v) {\\n        \\n        if(v.size()==0)\\n            return NULL;\\n        \\n        while(v.size()!=1)\\n        {\\n            ListNode* x=v[0];\\n            v.erase(v.begin());\\n            ListNode* y=v[0];\\n            v.erase(v.begin());\\n            ListNode* z=merge(x,y);\\n            v.push_back(z);\\n        }\\n        \\n        return v[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1746231,
                "title": "merge-sort-c",
                "content": "# C++\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeList(ListNode *p, ListNode *q) {\\n        ListNode *start = new ListNode(-1);\\n        ListNode *head = new ListNode;\\n        head = start;\\n        while (p && q) {\\n            if (p->val > q->val) {\\n                start->next = q;\\n                q = q->next;\\n            }\\n            else {\\n                start->next = p;\\n                p = p->next;\\n            }\\n            start = start->next;\\n        }\\n        while(p) {\\n            start->next = p;\\n            start = start->next;\\n            p = p->next;\\n        }\\n        while(q) {\\n            start->next = q;\\n            start = start->next;\\n            q = q->next;\\n        }\\n        return head->next;\\n    }\\n    \\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if (lists.size() == 0) return nullptr;\\n        \\n        ListNode *head = new ListNode;\\n        head = lists[0];\\n        \\n        for (int i = 1; i < lists.size(); i++) {\\n            head = mergeList(lists[i], head);\\n        }\\n        \\n        return head;\\n    }\\n};\\n```\\n\\n**Feel free to ask doubts\\nAnd please share some suggetsions\\nHAPPY CODING :)**",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Merge Sort"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeList(ListNode *p, ListNode *q) {\\n        ListNode *start = new ListNode(-1);\\n        ListNode *head = new ListNode;\\n        head = start;\\n        while (p && q) {\\n            if (p->val > q->val) {\\n                start->next = q;\\n                q = q->next;\\n            }\\n            else {\\n                start->next = p;\\n                p = p->next;\\n            }\\n            start = start->next;\\n        }\\n        while(p) {\\n            start->next = p;\\n            start = start->next;\\n            p = p->next;\\n        }\\n        while(q) {\\n            start->next = q;\\n            start = start->next;\\n            q = q->next;\\n        }\\n        return head->next;\\n    }\\n    \\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if (lists.size() == 0) return nullptr;\\n        \\n        ListNode *head = new ListNode;\\n        head = lists[0];\\n        \\n        for (int i = 1; i < lists.size(); i++) {\\n            head = mergeList(lists[i], head);\\n        }\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1399908,
                "title": "c-recursive-soln",
                "content": "If you have done merge two sorted lists then its so easy.\\nTake one node with nullptr(say ans);\\nWrite a function which takes two nodes ,merges them and return the head of the result list;\\nJust traverse through the vector call the function with ans and node in vector and assign the return value to ans;\\nAt last return ans;  **BINGO!!**\\n```\\n ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if(lists.size()==0)\\n            return NULL;\\n        ListNode* head=lists[0];\\n        for(int i=1;i<lists.size();i++)\\n            head=solve(head,lists[i]);\\n        return head;\\n    }\\n    ListNode* solve(ListNode* l,ListNode* r){\\n        if(!l)\\n            return r;\\n        if(!r)\\n            return l;\\n        if(l->val>r->val)\\n            return solve(r,l);\\n        l->next=solve(l->next,r);\\n        return l;\\n    }\\n\\t```\\n\\t**UPVOTE!!**",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        if(lists.size()==0)\\n            return NULL;\\n        ListNode* head=lists[0];\\n        for(int i=1;i<lists.size();i++)\\n            head=solve(head,lists[i]);\\n        return head;\\n    }\\n    ListNode* solve(ListNode* l,ListNode* r){\\n        if(!l)\\n            return r;\\n        if(!r)\\n            return l;\\n        if(l->val>r->val)\\n            return solve(r,l);\\n        l->next=solve(l->next,r);\\n        return l;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1389843,
                "title": "java-two-easy-approach-with-explanation-priority-queue-min-heap",
                "content": "```\\n1)//Brute force apprach, creating node//more space is required \\nclass Solution\\n{\\n  class Reff\\n  {\\n     ListNode node;//pointer node \\n     int list;//current list we are in\\n\\n     Reff(ListNode node, int list)//parameterised constructor to initialize\\n     {\\n       this.node= node;\\n       this.list= list;\\n     }\\n  }\\n  public ListNode mergeKLists(ListNode[] lists)\\n  {//T -> O(N log N) S -> O(N)//Slower\\n     PriorityQueue<Reff>  minHeap= new PriorityQueue<>((a,b)->{\\n        return a.node.val - b.node.val;\\n     });//customised sorting based on value \\n    \\n     ListNode root= new ListNode(-1, null);//dummy node to add the nodes in sequential manner \\n     ListNode trav= root;//trav to add the node one by one\\n       \\n     for(int i= 0; i< lists.length; i++){//traversing the lists\\n          if(lists[i] != null)\\n          minHeap.offer(new Reff(lists[i], i));//adding the first node of the lists into the min heap\\n     }\\n    \\n     while(!minHeap.isEmpty())//terminating contion, till all the nodes in the lists list is covered \\n     {\\n        Reff ref= minHeap.poll();//polling the smallest node, at each instant\\n\\n        trav.next= new ListNode(ref.node.val);//creating a new Node and linking with previous node \\n        trav= trav.next;//temp pointing to current node \\n       \\n        if(ref.node != null && ref.node.next != null)//if next element is present, pushing it to the min heap\\n           minHeap.offer(new Reff(ref.node.next, ref.list));\\n        \\n     }\\n     return root.next;//returning the new head, of the sorted list \\n  }\\n}//Please do Upvote, it helps a lot\\n```\\n```\\n2)//optimise approach without node creation, modifying the existing node \\nclass Solution\\n{\\n  public ListNode mergeKLists(ListNode[] lists)\\n  {//T -> O(N log N) S -> O(N)//Faster\\n     PriorityQueue<ListNode>  minHeap= new PriorityQueue<>((a,b)->{\\n        return a.val - b.val;\\n     });//customised sorting based on value \\n    \\n     ListNode root= new ListNode(-1, null);//dummy node to add the nodes in sequential manner \\n     ListNode trav= root;//trav to add the node one by one\\n       \\n     for(int i= 0; i< lists.length; i++){//traversing the lists\\n         if(lists[i] != null)\\n             minHeap.offer(lists[i]);//adding the first node of the lists into the min heap\\n     }\\n      \\n     while(!minHeap.isEmpty())//terminating contion, till all the nodes in the lists list is covered \\n     {\\n        ListNode temp= minHeap.poll();//polling the smallest node, at each instant  \\n       \\n        trav.next= temp;//linking with previous node\\n        trav= trav.next;//temp pointing to current node \\n       \\n        ListNode next= temp.next;.//storing the next pointer \\n        temp.next= null;//removing the forward link \\n       \\n        if(next != null)//if next element is present, pushing it to the min heap\\n           minHeap.offer(next);\\n     }\\n     return root.next;//returning the new head, of the sorted list \\n  }\\n}//Please do Upvote, it helps a lot\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n1)//Brute force apprach, creating node//more space is required \\nclass Solution\\n{\\n  class Reff\\n  {\\n     ListNode node;//pointer node \\n     int list;//current list we are in\\n\\n     Reff(ListNode node, int list)//parameterised constructor to initialize\\n     {\\n       this.node= node;\\n       this.list= list;\\n     }\\n  }\\n  public ListNode mergeKLists(ListNode[] lists)\\n  {//T -> O(N log N) S -> O(N)//Slower\\n     PriorityQueue<Reff>  minHeap= new PriorityQueue<>((a,b)->{\\n        return a.node.val - b.node.val;\\n     });//customised sorting based on value \\n    \\n     ListNode root= new ListNode(-1, null);//dummy node to add the nodes in sequential manner \\n     ListNode trav= root;//trav to add the node one by one\\n       \\n     for(int i= 0; i< lists.length; i++){//traversing the lists\\n          if(lists[i] != null)\\n          minHeap.offer(new Reff(lists[i], i));//adding the first node of the lists into the min heap\\n     }\\n    \\n     while(!minHeap.isEmpty())//terminating contion, till all the nodes in the lists list is covered \\n     {\\n        Reff ref= minHeap.poll();//polling the smallest node, at each instant\\n\\n        trav.next= new ListNode(ref.node.val);//creating a new Node and linking with previous node \\n        trav= trav.next;//temp pointing to current node \\n       \\n        if(ref.node != null && ref.node.next != null)//if next element is present, pushing it to the min heap\\n           minHeap.offer(new Reff(ref.node.next, ref.list));\\n        \\n     }\\n     return root.next;//returning the new head, of the sorted list \\n  }\\n}//Please do Upvote, it helps a lot\\n```\n```\\n2)//optimise approach without node creation, modifying the existing node \\nclass Solution\\n{\\n  public ListNode mergeKLists(ListNode[] lists)\\n  {//T -> O(N log N) S -> O(N)//Faster\\n     PriorityQueue<ListNode>  minHeap= new PriorityQueue<>((a,b)->{\\n        return a.val - b.val;\\n     });//customised sorting based on value \\n    \\n     ListNode root= new ListNode(-1, null);//dummy node to add the nodes in sequential manner \\n     ListNode trav= root;//trav to add the node one by one\\n       \\n     for(int i= 0; i< lists.length; i++){//traversing the lists\\n         if(lists[i] != null)\\n             minHeap.offer(lists[i]);//adding the first node of the lists into the min heap\\n     }\\n      \\n     while(!minHeap.isEmpty())//terminating contion, till all the nodes in the lists list is covered \\n     {\\n        ListNode temp= minHeap.poll();//polling the smallest node, at each instant  \\n       \\n        trav.next= temp;//linking with previous node\\n        trav= trav.next;//temp pointing to current node \\n       \\n        ListNode next= temp.next;.//storing the next pointer \\n        temp.next= null;//removing the forward link \\n       \\n        if(next != null)//if next element is present, pushing it to the min heap\\n           minHeap.offer(next);\\n     }\\n     return root.next;//returning the new head, of the sorted list \\n  }\\n}//Please do Upvote, it helps a lot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1387269,
                "title": "simple-but-fast-ruby-o-nlog-k-solution",
                "content": "Ideas\\n* always pop out min listnode from left of array\\n* insert next node into sorted array at correct index to keep it still a sorted array\\n* when array is empty means you already iterate all listnode\\n\\n```ruby\\ndef merge_k_lists(lists)\\n  # Prepare answer list\\n  head = ListNode.new\\n  tail = head\\n  \\n  # Remove empty list first\\n  lists.delete_if { |list| list.nil? }\\n  \\n  # Sort list from min to max\\n  lists.sort_by! { |list| list.val }\\n  \\n  while !lists.empty?\\n    # Get min node from left of array\\n    min_node = lists.shift\\n    \\n    # Add to answer list\\n    tail.next = min_node\\n    tail = tail.next\\n    \\n    # Prepare next node\\n    new_list = min_node.next\\n    next if new_list.nil?\\n\\n    # Want to insert next node into sorted array at correct index to keep it still a sorted array\\n    # Then we can still shift min node from left in next run\\n    # Using bsearch on a sorted array is very fast\\n    insert_at = lists.bsearch_index { |list| list.val >= new_list.val }\\n    if insert_at.nil?\\n      lists.push(new_list)\\n    else\\n      lists.insert(insert_at, new_list)\\n    end\\n  end\\n  \\n  head.next\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef merge_k_lists(lists)\\n  # Prepare answer list\\n  head = ListNode.new\\n  tail = head\\n  \\n  # Remove empty list first\\n  lists.delete_if { |list| list.nil? }\\n  \\n  # Sort list from min to max\\n  lists.sort_by! { |list| list.val }\\n  \\n  while !lists.empty?\\n    # Get min node from left of array\\n    min_node = lists.shift\\n    \\n    # Add to answer list\\n    tail.next = min_node\\n    tail = tail.next\\n    \\n    # Prepare next node\\n    new_list = min_node.next\\n    next if new_list.nil?\\n\\n    # Want to insert next node into sorted array at correct index to keep it still a sorted array\\n    # Then we can still shift min node from left in next run\\n    # Using bsearch on a sorted array is very fast\\n    insert_at = lists.bsearch_index { |list| list.val >= new_list.val }\\n    if insert_at.nil?\\n      lists.push(new_list)\\n    else\\n      lists.insert(insert_at, new_list)\\n    end\\n  end\\n  \\n  head.next\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1131843,
                "title": "javascript-faster-than-98-84-cjamm",
                "content": "```\\nconst mergeKLists = (lists) => {\\n    if (lists.length === 0) return null;\\n    \\n    const merge = (l1, l2) => {\\n        let temp = new ListNode(),\\n            curr = temp;\\n        while (l1 && l2) {\\n            if (l1.val < l2.val) {\\n                curr.next = l1;\\n                l1 = l1.next;\\n            } else {\\n                curr.next = l2;\\n                l2 = l2.next;\\n            }\\n            curr = curr.next;\\n        }\\n        curr.next = l1 || l2;\\n        return temp.next;\\n    }\\n    \\n    while(lists.length > 1) {\\n        let a = lists.shift();\\n        let b = lists.shift();\\n        const h = merge(a, b)\\n        lists.push(h)\\n    }\\n    return lists[0]\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst mergeKLists = (lists) => {\\n    if (lists.length === 0) return null;\\n    \\n    const merge = (l1, l2) => {\\n        let temp = new ListNode(),\\n            curr = temp;\\n        while (l1 && l2) {\\n            if (l1.val < l2.val) {\\n                curr.next = l1;\\n                l1 = l1.next;\\n            } else {\\n                curr.next = l2;\\n                l2 = l2.next;\\n            }\\n            curr = curr.next;\\n        }\\n        curr.next = l1 || l2;\\n        return temp.next;\\n    }\\n    \\n    while(lists.length > 1) {\\n        let a = lists.shift();\\n        let b = lists.shift();\\n        const h = merge(a, b)\\n        lists.push(h)\\n    }\\n    return lists[0]\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 943926,
                "title": "simple-javascript-solution",
                "content": "```\\nvar mergeKLists = function(lists) {\\n    let i = 0;\\n    \\n    let result = null;\\n    \\n    lists.forEach(v => {\\n        result = mergeList(result, v);\\n    });  \\n    \\n    return result;\\n};\\n                \\nvar mergeList = (l1 , l2) => {\\n    if (l1 == null)\\n        return l2;\\n            \\n    if (l2 == null)\\n        return l1;\\n        \\n    if (l1.val < l2.val) {\\n        l1.next = mergeList(l1.next, l2);\\n        return l1;\\n    } else {\\n        l2.next = mergeList(l1, l2.next);\\n        return l2;\\n    }    \\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar mergeKLists = function(lists) {\\n    let i = 0;\\n    \\n    let result = null;\\n    \\n    lists.forEach(v => {\\n        result = mergeList(result, v);\\n    });  \\n    \\n    return result;\\n};\\n                \\nvar mergeList = (l1 , l2) => {\\n    if (l1 == null)\\n        return l2;\\n            \\n    if (l2 == null)\\n        return l1;\\n        \\n    if (l1.val < l2.val) {\\n        l1.next = mergeList(l1.next, l2);\\n        return l1;\\n    } else {\\n        l2.next = mergeList(l1, l2.next);\\n        return l2;\\n    }    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 820152,
                "title": "easy-cpp-solution-using-divide-and-conquer",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* merge_two(ListNode* a,ListNode* b){\\n        ListNode* res=NULL;\\n        if(a==NULL){\\n            return b;\\n        }\\n        if(b==NULL){\\n            return a;\\n        }\\n        if(a->val<=b->val){\\n            res=a;\\n            res->next=merge_two(a->next,b);\\n        }\\n        else{\\n            res=b;\\n            res->next=merge_two(a,b->next);\\n        }\\n        return res;\\n        \\n    }\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        int i=0,j;\\n        int last=lists.size()-1;\\n        \\n        if(lists.empty()){\\n            return NULL;\\n        }\\n        while(last!=0){\\n            i=0,j=last;\\n            while(i<j){\\n                lists.at(i)=merge_two(lists.at(i),lists.at(j));\\n                i++;\\n                j--;\\n                if(i>=j){\\n                    last=j;\\n                }\\n            }\\n        }\\n        return lists.at(0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* merge_two(ListNode* a,ListNode* b){\\n        ListNode* res=NULL;\\n        if(a==NULL){\\n            return b;\\n        }\\n        if(b==NULL){\\n            return a;\\n        }\\n        if(a->val<=b->val){\\n            res=a;\\n            res->next=merge_two(a->next,b);\\n        }\\n        else{\\n            res=b;\\n            res->next=merge_two(a,b->next);\\n        }\\n        return res;\\n        \\n    }\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        int i=0,j;\\n        int last=lists.size()-1;\\n        \\n        if(lists.empty()){\\n            return NULL;\\n        }\\n        while(last!=0){\\n            i=0,j=last;\\n            while(i<j){\\n                lists.at(i)=merge_two(lists.at(i),lists.at(j));\\n                i++;\\n                j--;\\n                if(i>=j){\\n                    last=j;\\n                }\\n            }\\n        }\\n        return lists.at(0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 766538,
                "title": "easy-c-solution-using-priority-queue",
                "content": "# Using Priority Queue\\n**Approach \\n1.Store first element of every linked list in priority queue.\\n2.Then remove the minimum element and add the next element of that list.**\\n```\\nclass Solution\\n{\\npublic:\\n    struct compare\\n    {\\n        bool operator()(const ListNode* l1, const ListNode* l2)\\n        {\\n            return l1->val > l2->val;\\n        }\\n    };\\n\\n    ListNode* mergeKLists(vector<ListNode*>& lists)\\n    {\\n        priority_queue<ListNode*, vector<ListNode*>, compare> q;\\n\\t\\t\\n\\t\\t//Store first element of every linked list in priority queue\\n        for(auto l : lists)\\n        {  \\n             if(l)\\n                q.push(l);\\n        }\\n\\n        ListNode pre(0);\\n        ListNode *node = &pre;\\n\\t\\t\\n\\t\\t// remove the minimum element and add the next element of that list\\n        while (!q.empty())\\n        {\\n            ListNode *top = q.top();\\n            q.pop();\\n\\n            node->next = top;\\n            node = node->next;\\n            if(top->next)\\n                q.push(top->next);\\n\\n        }\\n\\n        return pre.next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    struct compare\\n    {\\n        bool operator()(const ListNode* l1, const ListNode* l2)\\n        {\\n            return l1->val > l2->val;\\n        }\\n    };\\n\\n    ListNode* mergeKLists(vector<ListNode*>& lists)\\n    {\\n        priority_queue<ListNode*, vector<ListNode*>, compare> q;\\n\\t\\t\\n\\t\\t//Store first element of every linked list in priority queue\\n        for(auto l : lists)\\n        {  \\n             if(l)\\n                q.push(l);\\n        }\\n\\n        ListNode pre(0);\\n        ListNode *node = &pre;\\n\\t\\t\\n\\t\\t// remove the minimum element and add the next element of that list\\n        while (!q.empty())\\n        {\\n            ListNode *top = q.top();\\n            q.pop();\\n\\n            node->next = top;\\n            node = node->next;\\n            if(top->next)\\n                q.push(top->next);\\n\\n        }\\n\\n        return pre.next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 599557,
                "title": "c-solution-with-explanation-efficient",
                "content": "```\\nWe will first start by taking k=2.\\n1->2->3\\n2->7->11\\nWe proceed by picking the the smallest pointer value and moving the pointer of the linked list forward.\\nThe same procedure will follow for k increasing. We will be greedily picking the smallest value and moving the corresponding pointer forward.\\nBut the problem is for k=2 we can check the smaller value of the two just by using < or > symbol.\\nBut if k is large lets say 1 million using such a technique will take years to compute.\\nWe will have to using a smarter data structure to solve this question.\\nThink of a data structure which will take all the values and will be able to give the smallest value in the least time.\\na min heap would be of the right choice.\\n\\n1. We will push all the first pointer of each of the linked list into the heap.\\n2. We must also move the pointer of that list forward.\\n3. Then we start linkig all the smallest nodes and get our solution.\\nRemember that heaps are in the form of trees but for simplicity i have represent it like this. \\n\\nLet k=3\\n1->8->11\\n2->3->7\\n3->6->16\\n          |         |\\n          |    1    |\\n          |    2    |\\n          |    3    |  <-----min heap storing the values of the first with top value as 1\\n          |_________| \\n\\n       ans=   1->\\n\\n          |         |\\n          |    2    |\\n          |    3    |\\n          |    8    |  <-----1 is p0poed out and the next pointer points to 8 which is pushed to the heap with top element as 2.\\n          |_________| \\n\\n       ans=   1->2->\\n\\n          |         |\\n          |    3    |\\n          |    3    |\\n          |    8    |  <-----2 is p0poed out and the next pointer points to 3 which is pushed to the heap with top element as 3.\\n          |_________| \\n\\n\\n          ans = 1->2->3\\n\\n\\n          Similarly the approach follows and u get the final result.\\n\\n\\n    struct comp\\n    {\\n      bool operator()(const ListNode* a,ListNode* b)\\n      {\\n          return a->val>b->val;\\n      }\\n    };\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        priority_queue<ListNode*,vector<ListNode*>,comp> pq;\\n        for(auto x:lists)\\n        {\\n            if(x)pq.push(x);\\n        }\\n        if(pq.empty())return NULL;\\n        ListNode* result=pq.top();\\n        pq.pop();\\n        if(result->next)pq.push(result->next);\\n        ListNode* t=result;\\n        while(!pq.empty())\\n        {\\n            t->next=pq.top();\\n            pq.pop();\\n            t=t->next;\\n            if(t->next)pq.push(t->next);\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nWe will first start by taking k=2.\\n1->2->3\\n2->7->11\\nWe proceed by picking the the smallest pointer value and moving the pointer of the linked list forward.\\nThe same procedure will follow for k increasing. We will be greedily picking the smallest value and moving the corresponding pointer forward.\\nBut the problem is for k=2 we can check the smaller value of the two just by using < or > symbol.\\nBut if k is large lets say 1 million using such a technique will take years to compute.\\nWe will have to using a smarter data structure to solve this question.\\nThink of a data structure which will take all the values and will be able to give the smallest value in the least time.\\na min heap would be of the right choice.\\n\\n1. We will push all the first pointer of each of the linked list into the heap.\\n2. We must also move the pointer of that list forward.\\n3. Then we start linkig all the smallest nodes and get our solution.\\nRemember that heaps are in the form of trees but for simplicity i have represent it like this. \\n\\nLet k=3\\n1->8->11\\n2->3->7\\n3->6->16\\n          |         |\\n          |    1    |\\n          |    2    |\\n          |    3    |  <-----min heap storing the values of the first with top value as 1\\n          |_________| \\n\\n       ans=   1->\\n\\n          |         |\\n          |    2    |\\n          |    3    |\\n          |    8    |  <-----1 is p0poed out and the next pointer points to 8 which is pushed to the heap with top element as 2.\\n          |_________| \\n\\n       ans=   1->2->\\n\\n          |         |\\n          |    3    |\\n          |    3    |\\n          |    8    |  <-----2 is p0poed out and the next pointer points to 3 which is pushed to the heap with top element as 3.\\n          |_________| \\n\\n\\n          ans = 1->2->3\\n\\n\\n          Similarly the approach follows and u get the final result.\\n\\n\\n    struct comp\\n    {\\n      bool operator()(const ListNode* a,ListNode* b)\\n      {\\n          return a->val>b->val;\\n      }\\n    };\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        priority_queue<ListNode*,vector<ListNode*>,comp> pq;\\n        for(auto x:lists)\\n        {\\n            if(x)pq.push(x);\\n        }\\n        if(pq.empty())return NULL;\\n        ListNode* result=pq.top();\\n        pq.pop();\\n        if(result->next)pq.push(result->next);\\n        ListNode* t=result;\\n        while(!pq.empty())\\n        {\\n            t->next=pq.top();\\n            pq.pop();\\n            t=t->next;\\n            if(t->next)pq.push(t->next);\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1572702,
                "content": [
                    {
                        "username": "adambene",
                        "content": "This problem should not be marked as hard.\\nMedium is more proper based on the other problems on leetcode."
                    },
                    {
                        "username": "Pranjal_Bajpai",
                        "content": "i would say easy, its no brainer !"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cwooldridge](/cwooldridge)  POV: you solved your first HARD problem. "
                    },
                    {
                        "username": "jason3410",
                        "content": "[@Mister_CK](/Mister_CK) Cuz your solution make no connection with the ListNodes. And u won\\'t learn anything on this question."
                    },
                    {
                        "username": "user5331Az",
                        "content": "[@Mister_CK](/Mister_CK) putting an element into sorted array is O(log2(n)), sorting of an array is O(n^2) generally."
                    },
                    {
                        "username": "dhunmoon",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "[@cwooldridge](/cwooldridge) I almost started to think that i\\'m a hard problem solver and then I came here"
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Hey man, cmon, let me enjoy this moment\\uD83D\\uDE02"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It should be Easy imo. At least in JS there is no need to use a priority queue. You can just put all the values in an array, sort that array and put them in a list you then return. runs in 79 ms, beats 97% of solutions and it's the same answer as for the Easy problem `21. Merge Two Sorted Lists` (albeit that this is an array of lists, rather than just two, but it's the exact same principle). I really don't understand why this is marked with Hard and Priority Queue, really threw me off. I wrote a whole solution with a priority queue for an hour, only to realise it was completely unnecessary and I wrote a faster algorithm without it in 5 minutes. ([@joseph261059](/joseph261059) I tried using that, but I got an error on the node version (I believe it couldn't find insert), so I copied an implementation of a PriorityQueue using heap from stackoverflow) (PS: I checked, in regular Java it runs in 8 ms (beating only 28% of solutions), but that is still well within the accepted solution range.)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "[@Husoski](/Husoski) In JS, we can use PriorityQueue package in leetcode"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Well this still is hard problem as if go optimize your time complexity the solutions becomes more and more complex!"
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@Husoski](/Husoski) Indeed, but nobody uses programming languages like C in competitive programming. The most popular languages are C++, Java and Python. If there is no standard library with basic data structures like a `vector` or a `heap` in the programming language of your choice, you might want to use another language for the purpose of solving leetcode questions."
                    },
                    {
                        "username": "Husoski",
                        "content": "That depends on the language you used.  In a language with a standard heap or priority queue data structure this is indeed on the easy side of Medium.  I think it\\'s more like Hard in a language like C or JS.  (Assuming, of course, that the solver is going write the minheap code and not copy-paste it! :^)"
                    },
                    {
                        "username": "viocost",
                        "content": "The problem is interesting, but why there are test cases such as [[], []] \\nand not a word about possible inputs expected output?\\n\\nIs it also a telepathy exercise?\\n"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Very annoying; they don\\'t seem to mention how the output is parsed; the result needs to be a ListNode or null.\\nFilter the list then go from there."
                    },
                    {
                        "username": "alistar",
                        "content": "With empty list it seems to expect an empty list as an output, however, it doest not accept it with type-error.\\nLitterally copied and pasted one of the official solutions, it doesn\\'t go through with the same issue!"
                    },
                    {
                        "username": "user9118TR",
                        "content": "[@amithshetty](/amithshetty)  Thaks a lot, how did you know it ??"
                    },
                    {
                        "username": "sony541",
                        "content": "[@amithshetty](/amithshetty) Well, if \"None\" is the end of list, you can think of \"None\" as an empty linked list, nice callout here... It took me a while to figure out, but sounds reasonable after all.. Could\\'ve been clarified in promt though."
                    },
                    {
                        "username": "amithshetty",
                        "content": "IT expects None, i.e not a list but an empty linked list"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-k-sorted-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Compare one by one\n\n  \n**Approach 3:** Optimize Approach 2 by Priority Queue\n\n  \n**Approach 4:** Merge lists one by one\n\n  \n**Approach 5:** Merge with Divide And Conquer\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Kouei",
                        "content": "The fastest C++ code can achieve a time about 370ms ~ 380ms\\n\\nwhile Python code can achieve 100ms, and even amazing, JAVA can do it in just 4ms !\\n\\nThis result is quite counterintuitive."
                    },
                    {
                        "username": "321maayan",
                        "content": "python is build in c and c is powerful as c++\\n"
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "[@Normalitee0os](/Normalitee0os)  post the code lol"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Mine took 15 ms using C++"
                    },
                    {
                        "username": "Normalitee0os",
                        "content": "Mine took 0.1 ms using HTML."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Mine took 23ms in C++"
                    },
                    {
                        "username": "slashtab",
                        "content": "OJ of LeetCode isn\\'t that perfect."
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "mine 22ms with c++; "
                    },
                    {
                        "username": "charonme",
                        "content": "35ms in PHP without using any built-in functions except count"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "mine was 40ms in c++, which could be further optimized"
                    },
                    {
                        "username": "f1rumors",
                        "content": "underlying libraries are a boon"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python...\\n\\nI assume that everyone realizes that without using ListNode that the solution to this problem is one line of code. Flatten the lists to one list and sort the list. \\n\\nWhy are there so many problems that have to be answered using ListNodes? It\\'s a complete waste of time in a language such as python. Shouldn\\'t the simplest solution be the best solution? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of `ListNode` or linked lists in algorithmic problems isn\\'t necessarily about finding the most efficient solution in Python or any specific language. Rather, it\\'s about teaching or testing certain concepts. Here are a few reasons:\\n\\n1. **Conceptual Understanding**: Using `ListNode` often helps in understanding how to manually manipulate pointers and nodes, which is crucial for a deep understanding of data structures.\\n\\n2. **Language Agnostic**: These problems are designed to be language-agnostic. While Python has easy list manipulation, languages like C or C++ do not have such built-in capabilities. The problem is set to be fair to everyone, regardless of the programming language used.\\n\\n3. **Algorithm Complexity**: Some problems require an in-depth understanding of algorithm complexity. Using built-in functions like `sort` can sometimes give a false sense of simplicity when, in fact, the actual task of merging the lists might be more complex.\\n\\n4. **Resource Utilization**: In some cases, especially in embedded systems or other resource-constrained environments, understanding how to work with nodes and pointers is essential for efficient memory usage.\\n\\n5. **Skill Assessment**: These problems are often used in interviews to assess understanding of fundamental computer science concepts, beyond syntactic sugar provided by specific programming languages.\\n\\n6. **Real-world Use Cases**: Not all data comes in simple, sorted, array-like structures. Linked lists, trees, and graphs are data structures commonly used in real-world applications. Understanding them is key to being a well-rounded developer.\\n\\n7. **Optimal Substructure**: Problems that mandate the use of data structures like linked lists often involve an optimal substructure that makes for an elegant solution, thereby teaching you problem-solving patterns that can be applied elsewhere.\\n\\n8. **Consistency**: If a problem was initially posed in a computer science paper or textbook using `ListNodes`, it\\'s often kept that way to maintain consistency with classic algorithm and data structure literature.\\n\\nSo while it may seem unnecessary or verbose, using `ListNode` provides a broader educational benefit, ensuring that you understand both high-level language features and low-level data structure manipulation."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go tell it on an interview :)"
                    },
                    {
                        "username": "Vantrashell",
                        "content": "[@mikael6767](/mikael6767) The goal should very rarely be to write the shortest amount of code. The 1 line solution typically uses a generalized algorithm, which may or may not be useful for what you wish to do. The problem forces ListNode as a guide to push in the direction it wants. Most of the solutions, although using ListNode, ignore this guide as the question very clearly wants a solution that does not create new memory as LinkedLists do not require such a complex operation for insertion. Ultimately, the point is (and why this is a hard problem and not a medium one like others have suggested) to do mergeKLists in O(1) space. The one line of Python most-likely does allocate new memory somewhere. If your customer pays for the amount of ram they use from a cloud service, they would be most pleased if you would keep that cost low."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Ok, @cartesPerforees, then explain why do we need ListNode if we can do this problem way easier without it. The goal is to make the solution with the shortest possible code. In this case 1 line, not 50. Imagine a customer wants you to make this problem: Merge K Sorted Lists. He doesn\\'t say how you need to do it, He just says to do it on python3. How would you do it? Would you write 50 lines of code using ListNode or one line of code. Please read and reply and we can discuss this later."
                    },
                    {
                        "username": "user5331Az",
                        "content": "bravo! dude, the task is for the ones familiar with algorithmic complexity concept at least, definitely not for you."
                    },
                    {
                        "username": "squigity",
                        "content": "[@mikael6767](/mikael6767)  Concept of linked lists is for a different scenario ,  the question here is to know if we understand linked lists or not and not to merge a sorted list from a list of lists"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your comment puzzles me. The whole point of those problems is to give you something to solve, and make it somewhat of a challenge depending on the difficulty tag. Most of the problems on leetcode are artificial and of no practical use, they are just made to help you practise probem solving.\\nI don\\'t get why you complain that they\\'re making things harder for you. That\\'s the point. It\\'s like playing with one of those chinese/japanes wooden brain teasers and  complaining that they should have designed it so that it opens like a normal box."
                    },
                    {
                        "username": "mikael6767",
                        "content": "I realize this. I am programming on python3 and really know that it really is one line of code, but the problem is with ListNode. There are a lot LeetCode problems with ListNode and I can\\'t make them even if they are very easy without it. I have the same problem. I wrote that one line of code and it says it is not right. I would really like for someone to help you, but I\\'m sorry I can\\'t."
                    },
                    {
                        "username": "David_E_something",
                        "content": "If you somehow use a priority queue (heap), this problem becomes very easy."
                    },
                    {
                        "username": "clinkz93",
                        "content": "[@layman806](/layman806) Using a priority queue results in a complexity of O((k + n) * log(k)) instead of O(n * log(n)), which may be preferrable."
                    },
                    {
                        "username": "root89",
                        "content": "[@layman806](/layman806) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@layman806](/layman806) lmao,, you can\\'t beat the interviewer."
                    },
                    {
                        "username": "layman806",
                        "content": "Or just parse all into an array in O(n) time, then sort it in O(n.log(n)) time and convert it to a linked list in O(n) time. This is just too easy to beat. Shouldn\\'t be tagged as hard."
                    },
                    {
                        "username": "JaviOverflow",
                        "content": "When I submit my solution, it fails on the input `[[]]`, how is that input even posible? `ListNode` requires `val` as argument in its constructor. Returning `None` doesn\\'t make the test pass. I\\'m not sure how to tackle that."
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "thenimator",
                        "content": "It\\'s been a while since you had this problem but for anyone else running into it:\\n\\n[[]] simply stands for an array with 1 element with that one element being a null pointer (which in this context stands for an empty linked list and not one where the value of the first element is missing)"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, WTF? ![image](https://assets.leetcode.com/users/beatrizdos/image_1570843047.png)\\n"
                    },
                    {
                        "username": "Will-O-Wisp",
                        "content": "class ListNode(object):\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\n\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        def mergeTwoLists(l1, l2):\\n            dummy = ListNode(0)\\n            current = dummy\\n\\n            while l1 and l2:\\n                if l1.val < l2.val:\\n                    current.next = l1\\n                    l1 = l1.next\\n                else:\\n                    current.next = l2\\n                    l2 = l2.next\\n                current = current.next\\n\\n            current.next = l1 if l1 else l2\\n\\n            return dummy.next\\n\\n        if not lists:\\n            return None\\n\\n        while len(lists) > 1:\\n            merged_lists = []\\n\\n            for i in range(0, len(lists), 2):\\n                l1 = lists[i]\\n                l2 = lists[i + 1] if i + 1 < len(lists) else None\\n                merged_lists.append(mergeTwoLists(l1, l2))\\n\\n            lists = merged_lists\\n\\n        return lists[0] if lists else None\\n\\n\\n# Example usage\\nlists = [\\n    ListNode(1, ListNode(4, ListNode(5))),\\n    ListNode(1, ListNode(3, ListNode(4))),\\n    ListNode(2, ListNode(6))\\n]\\n\\nsolution = Solution()\\nresult = solution.mergeKLists(lists)\\nwhile result:\\n    print(result.val)\\n    result = result.next\\n"
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "qin4",
                        "content": "Util class ListNode in python 3 is not completed. It can\\'t do heapq directly. Fix is easier on server side."
                    }
                ]
            },
            {
                "id": 1572281,
                "content": [
                    {
                        "username": "adambene",
                        "content": "This problem should not be marked as hard.\\nMedium is more proper based on the other problems on leetcode."
                    },
                    {
                        "username": "Pranjal_Bajpai",
                        "content": "i would say easy, its no brainer !"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cwooldridge](/cwooldridge)  POV: you solved your first HARD problem. "
                    },
                    {
                        "username": "jason3410",
                        "content": "[@Mister_CK](/Mister_CK) Cuz your solution make no connection with the ListNodes. And u won\\'t learn anything on this question."
                    },
                    {
                        "username": "user5331Az",
                        "content": "[@Mister_CK](/Mister_CK) putting an element into sorted array is O(log2(n)), sorting of an array is O(n^2) generally."
                    },
                    {
                        "username": "dhunmoon",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "[@cwooldridge](/cwooldridge) I almost started to think that i\\'m a hard problem solver and then I came here"
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Hey man, cmon, let me enjoy this moment\\uD83D\\uDE02"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It should be Easy imo. At least in JS there is no need to use a priority queue. You can just put all the values in an array, sort that array and put them in a list you then return. runs in 79 ms, beats 97% of solutions and it's the same answer as for the Easy problem `21. Merge Two Sorted Lists` (albeit that this is an array of lists, rather than just two, but it's the exact same principle). I really don't understand why this is marked with Hard and Priority Queue, really threw me off. I wrote a whole solution with a priority queue for an hour, only to realise it was completely unnecessary and I wrote a faster algorithm without it in 5 minutes. ([@joseph261059](/joseph261059) I tried using that, but I got an error on the node version (I believe it couldn't find insert), so I copied an implementation of a PriorityQueue using heap from stackoverflow) (PS: I checked, in regular Java it runs in 8 ms (beating only 28% of solutions), but that is still well within the accepted solution range.)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "[@Husoski](/Husoski) In JS, we can use PriorityQueue package in leetcode"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Well this still is hard problem as if go optimize your time complexity the solutions becomes more and more complex!"
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@Husoski](/Husoski) Indeed, but nobody uses programming languages like C in competitive programming. The most popular languages are C++, Java and Python. If there is no standard library with basic data structures like a `vector` or a `heap` in the programming language of your choice, you might want to use another language for the purpose of solving leetcode questions."
                    },
                    {
                        "username": "Husoski",
                        "content": "That depends on the language you used.  In a language with a standard heap or priority queue data structure this is indeed on the easy side of Medium.  I think it\\'s more like Hard in a language like C or JS.  (Assuming, of course, that the solver is going write the minheap code and not copy-paste it! :^)"
                    },
                    {
                        "username": "viocost",
                        "content": "The problem is interesting, but why there are test cases such as [[], []] \\nand not a word about possible inputs expected output?\\n\\nIs it also a telepathy exercise?\\n"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Very annoying; they don\\'t seem to mention how the output is parsed; the result needs to be a ListNode or null.\\nFilter the list then go from there."
                    },
                    {
                        "username": "alistar",
                        "content": "With empty list it seems to expect an empty list as an output, however, it doest not accept it with type-error.\\nLitterally copied and pasted one of the official solutions, it doesn\\'t go through with the same issue!"
                    },
                    {
                        "username": "user9118TR",
                        "content": "[@amithshetty](/amithshetty)  Thaks a lot, how did you know it ??"
                    },
                    {
                        "username": "sony541",
                        "content": "[@amithshetty](/amithshetty) Well, if \"None\" is the end of list, you can think of \"None\" as an empty linked list, nice callout here... It took me a while to figure out, but sounds reasonable after all.. Could\\'ve been clarified in promt though."
                    },
                    {
                        "username": "amithshetty",
                        "content": "IT expects None, i.e not a list but an empty linked list"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-k-sorted-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Compare one by one\n\n  \n**Approach 3:** Optimize Approach 2 by Priority Queue\n\n  \n**Approach 4:** Merge lists one by one\n\n  \n**Approach 5:** Merge with Divide And Conquer\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Kouei",
                        "content": "The fastest C++ code can achieve a time about 370ms ~ 380ms\\n\\nwhile Python code can achieve 100ms, and even amazing, JAVA can do it in just 4ms !\\n\\nThis result is quite counterintuitive."
                    },
                    {
                        "username": "321maayan",
                        "content": "python is build in c and c is powerful as c++\\n"
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "[@Normalitee0os](/Normalitee0os)  post the code lol"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Mine took 15 ms using C++"
                    },
                    {
                        "username": "Normalitee0os",
                        "content": "Mine took 0.1 ms using HTML."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Mine took 23ms in C++"
                    },
                    {
                        "username": "slashtab",
                        "content": "OJ of LeetCode isn\\'t that perfect."
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "mine 22ms with c++; "
                    },
                    {
                        "username": "charonme",
                        "content": "35ms in PHP without using any built-in functions except count"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "mine was 40ms in c++, which could be further optimized"
                    },
                    {
                        "username": "f1rumors",
                        "content": "underlying libraries are a boon"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python...\\n\\nI assume that everyone realizes that without using ListNode that the solution to this problem is one line of code. Flatten the lists to one list and sort the list. \\n\\nWhy are there so many problems that have to be answered using ListNodes? It\\'s a complete waste of time in a language such as python. Shouldn\\'t the simplest solution be the best solution? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of `ListNode` or linked lists in algorithmic problems isn\\'t necessarily about finding the most efficient solution in Python or any specific language. Rather, it\\'s about teaching or testing certain concepts. Here are a few reasons:\\n\\n1. **Conceptual Understanding**: Using `ListNode` often helps in understanding how to manually manipulate pointers and nodes, which is crucial for a deep understanding of data structures.\\n\\n2. **Language Agnostic**: These problems are designed to be language-agnostic. While Python has easy list manipulation, languages like C or C++ do not have such built-in capabilities. The problem is set to be fair to everyone, regardless of the programming language used.\\n\\n3. **Algorithm Complexity**: Some problems require an in-depth understanding of algorithm complexity. Using built-in functions like `sort` can sometimes give a false sense of simplicity when, in fact, the actual task of merging the lists might be more complex.\\n\\n4. **Resource Utilization**: In some cases, especially in embedded systems or other resource-constrained environments, understanding how to work with nodes and pointers is essential for efficient memory usage.\\n\\n5. **Skill Assessment**: These problems are often used in interviews to assess understanding of fundamental computer science concepts, beyond syntactic sugar provided by specific programming languages.\\n\\n6. **Real-world Use Cases**: Not all data comes in simple, sorted, array-like structures. Linked lists, trees, and graphs are data structures commonly used in real-world applications. Understanding them is key to being a well-rounded developer.\\n\\n7. **Optimal Substructure**: Problems that mandate the use of data structures like linked lists often involve an optimal substructure that makes for an elegant solution, thereby teaching you problem-solving patterns that can be applied elsewhere.\\n\\n8. **Consistency**: If a problem was initially posed in a computer science paper or textbook using `ListNodes`, it\\'s often kept that way to maintain consistency with classic algorithm and data structure literature.\\n\\nSo while it may seem unnecessary or verbose, using `ListNode` provides a broader educational benefit, ensuring that you understand both high-level language features and low-level data structure manipulation."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go tell it on an interview :)"
                    },
                    {
                        "username": "Vantrashell",
                        "content": "[@mikael6767](/mikael6767) The goal should very rarely be to write the shortest amount of code. The 1 line solution typically uses a generalized algorithm, which may or may not be useful for what you wish to do. The problem forces ListNode as a guide to push in the direction it wants. Most of the solutions, although using ListNode, ignore this guide as the question very clearly wants a solution that does not create new memory as LinkedLists do not require such a complex operation for insertion. Ultimately, the point is (and why this is a hard problem and not a medium one like others have suggested) to do mergeKLists in O(1) space. The one line of Python most-likely does allocate new memory somewhere. If your customer pays for the amount of ram they use from a cloud service, they would be most pleased if you would keep that cost low."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Ok, @cartesPerforees, then explain why do we need ListNode if we can do this problem way easier without it. The goal is to make the solution with the shortest possible code. In this case 1 line, not 50. Imagine a customer wants you to make this problem: Merge K Sorted Lists. He doesn\\'t say how you need to do it, He just says to do it on python3. How would you do it? Would you write 50 lines of code using ListNode or one line of code. Please read and reply and we can discuss this later."
                    },
                    {
                        "username": "user5331Az",
                        "content": "bravo! dude, the task is for the ones familiar with algorithmic complexity concept at least, definitely not for you."
                    },
                    {
                        "username": "squigity",
                        "content": "[@mikael6767](/mikael6767)  Concept of linked lists is for a different scenario ,  the question here is to know if we understand linked lists or not and not to merge a sorted list from a list of lists"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your comment puzzles me. The whole point of those problems is to give you something to solve, and make it somewhat of a challenge depending on the difficulty tag. Most of the problems on leetcode are artificial and of no practical use, they are just made to help you practise probem solving.\\nI don\\'t get why you complain that they\\'re making things harder for you. That\\'s the point. It\\'s like playing with one of those chinese/japanes wooden brain teasers and  complaining that they should have designed it so that it opens like a normal box."
                    },
                    {
                        "username": "mikael6767",
                        "content": "I realize this. I am programming on python3 and really know that it really is one line of code, but the problem is with ListNode. There are a lot LeetCode problems with ListNode and I can\\'t make them even if they are very easy without it. I have the same problem. I wrote that one line of code and it says it is not right. I would really like for someone to help you, but I\\'m sorry I can\\'t."
                    },
                    {
                        "username": "David_E_something",
                        "content": "If you somehow use a priority queue (heap), this problem becomes very easy."
                    },
                    {
                        "username": "clinkz93",
                        "content": "[@layman806](/layman806) Using a priority queue results in a complexity of O((k + n) * log(k)) instead of O(n * log(n)), which may be preferrable."
                    },
                    {
                        "username": "root89",
                        "content": "[@layman806](/layman806) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@layman806](/layman806) lmao,, you can\\'t beat the interviewer."
                    },
                    {
                        "username": "layman806",
                        "content": "Or just parse all into an array in O(n) time, then sort it in O(n.log(n)) time and convert it to a linked list in O(n) time. This is just too easy to beat. Shouldn\\'t be tagged as hard."
                    },
                    {
                        "username": "JaviOverflow",
                        "content": "When I submit my solution, it fails on the input `[[]]`, how is that input even posible? `ListNode` requires `val` as argument in its constructor. Returning `None` doesn\\'t make the test pass. I\\'m not sure how to tackle that."
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "thenimator",
                        "content": "It\\'s been a while since you had this problem but for anyone else running into it:\\n\\n[[]] simply stands for an array with 1 element with that one element being a null pointer (which in this context stands for an empty linked list and not one where the value of the first element is missing)"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, WTF? ![image](https://assets.leetcode.com/users/beatrizdos/image_1570843047.png)\\n"
                    },
                    {
                        "username": "Will-O-Wisp",
                        "content": "class ListNode(object):\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\n\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        def mergeTwoLists(l1, l2):\\n            dummy = ListNode(0)\\n            current = dummy\\n\\n            while l1 and l2:\\n                if l1.val < l2.val:\\n                    current.next = l1\\n                    l1 = l1.next\\n                else:\\n                    current.next = l2\\n                    l2 = l2.next\\n                current = current.next\\n\\n            current.next = l1 if l1 else l2\\n\\n            return dummy.next\\n\\n        if not lists:\\n            return None\\n\\n        while len(lists) > 1:\\n            merged_lists = []\\n\\n            for i in range(0, len(lists), 2):\\n                l1 = lists[i]\\n                l2 = lists[i + 1] if i + 1 < len(lists) else None\\n                merged_lists.append(mergeTwoLists(l1, l2))\\n\\n            lists = merged_lists\\n\\n        return lists[0] if lists else None\\n\\n\\n# Example usage\\nlists = [\\n    ListNode(1, ListNode(4, ListNode(5))),\\n    ListNode(1, ListNode(3, ListNode(4))),\\n    ListNode(2, ListNode(6))\\n]\\n\\nsolution = Solution()\\nresult = solution.mergeKLists(lists)\\nwhile result:\\n    print(result.val)\\n    result = result.next\\n"
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "qin4",
                        "content": "Util class ListNode in python 3 is not completed. It can\\'t do heapq directly. Fix is easier on server side."
                    }
                ]
            },
            {
                "id": 1566937,
                "content": [
                    {
                        "username": "adambene",
                        "content": "This problem should not be marked as hard.\\nMedium is more proper based on the other problems on leetcode."
                    },
                    {
                        "username": "Pranjal_Bajpai",
                        "content": "i would say easy, its no brainer !"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cwooldridge](/cwooldridge)  POV: you solved your first HARD problem. "
                    },
                    {
                        "username": "jason3410",
                        "content": "[@Mister_CK](/Mister_CK) Cuz your solution make no connection with the ListNodes. And u won\\'t learn anything on this question."
                    },
                    {
                        "username": "user5331Az",
                        "content": "[@Mister_CK](/Mister_CK) putting an element into sorted array is O(log2(n)), sorting of an array is O(n^2) generally."
                    },
                    {
                        "username": "dhunmoon",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "[@cwooldridge](/cwooldridge) I almost started to think that i\\'m a hard problem solver and then I came here"
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Hey man, cmon, let me enjoy this moment\\uD83D\\uDE02"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It should be Easy imo. At least in JS there is no need to use a priority queue. You can just put all the values in an array, sort that array and put them in a list you then return. runs in 79 ms, beats 97% of solutions and it's the same answer as for the Easy problem `21. Merge Two Sorted Lists` (albeit that this is an array of lists, rather than just two, but it's the exact same principle). I really don't understand why this is marked with Hard and Priority Queue, really threw me off. I wrote a whole solution with a priority queue for an hour, only to realise it was completely unnecessary and I wrote a faster algorithm without it in 5 minutes. ([@joseph261059](/joseph261059) I tried using that, but I got an error on the node version (I believe it couldn't find insert), so I copied an implementation of a PriorityQueue using heap from stackoverflow) (PS: I checked, in regular Java it runs in 8 ms (beating only 28% of solutions), but that is still well within the accepted solution range.)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "[@Husoski](/Husoski) In JS, we can use PriorityQueue package in leetcode"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Well this still is hard problem as if go optimize your time complexity the solutions becomes more and more complex!"
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@Husoski](/Husoski) Indeed, but nobody uses programming languages like C in competitive programming. The most popular languages are C++, Java and Python. If there is no standard library with basic data structures like a `vector` or a `heap` in the programming language of your choice, you might want to use another language for the purpose of solving leetcode questions."
                    },
                    {
                        "username": "Husoski",
                        "content": "That depends on the language you used.  In a language with a standard heap or priority queue data structure this is indeed on the easy side of Medium.  I think it\\'s more like Hard in a language like C or JS.  (Assuming, of course, that the solver is going write the minheap code and not copy-paste it! :^)"
                    },
                    {
                        "username": "viocost",
                        "content": "The problem is interesting, but why there are test cases such as [[], []] \\nand not a word about possible inputs expected output?\\n\\nIs it also a telepathy exercise?\\n"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Very annoying; they don\\'t seem to mention how the output is parsed; the result needs to be a ListNode or null.\\nFilter the list then go from there."
                    },
                    {
                        "username": "alistar",
                        "content": "With empty list it seems to expect an empty list as an output, however, it doest not accept it with type-error.\\nLitterally copied and pasted one of the official solutions, it doesn\\'t go through with the same issue!"
                    },
                    {
                        "username": "user9118TR",
                        "content": "[@amithshetty](/amithshetty)  Thaks a lot, how did you know it ??"
                    },
                    {
                        "username": "sony541",
                        "content": "[@amithshetty](/amithshetty) Well, if \"None\" is the end of list, you can think of \"None\" as an empty linked list, nice callout here... It took me a while to figure out, but sounds reasonable after all.. Could\\'ve been clarified in promt though."
                    },
                    {
                        "username": "amithshetty",
                        "content": "IT expects None, i.e not a list but an empty linked list"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-k-sorted-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Compare one by one\n\n  \n**Approach 3:** Optimize Approach 2 by Priority Queue\n\n  \n**Approach 4:** Merge lists one by one\n\n  \n**Approach 5:** Merge with Divide And Conquer\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Kouei",
                        "content": "The fastest C++ code can achieve a time about 370ms ~ 380ms\\n\\nwhile Python code can achieve 100ms, and even amazing, JAVA can do it in just 4ms !\\n\\nThis result is quite counterintuitive."
                    },
                    {
                        "username": "321maayan",
                        "content": "python is build in c and c is powerful as c++\\n"
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "[@Normalitee0os](/Normalitee0os)  post the code lol"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Mine took 15 ms using C++"
                    },
                    {
                        "username": "Normalitee0os",
                        "content": "Mine took 0.1 ms using HTML."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Mine took 23ms in C++"
                    },
                    {
                        "username": "slashtab",
                        "content": "OJ of LeetCode isn\\'t that perfect."
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "mine 22ms with c++; "
                    },
                    {
                        "username": "charonme",
                        "content": "35ms in PHP without using any built-in functions except count"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "mine was 40ms in c++, which could be further optimized"
                    },
                    {
                        "username": "f1rumors",
                        "content": "underlying libraries are a boon"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python...\\n\\nI assume that everyone realizes that without using ListNode that the solution to this problem is one line of code. Flatten the lists to one list and sort the list. \\n\\nWhy are there so many problems that have to be answered using ListNodes? It\\'s a complete waste of time in a language such as python. Shouldn\\'t the simplest solution be the best solution? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of `ListNode` or linked lists in algorithmic problems isn\\'t necessarily about finding the most efficient solution in Python or any specific language. Rather, it\\'s about teaching or testing certain concepts. Here are a few reasons:\\n\\n1. **Conceptual Understanding**: Using `ListNode` often helps in understanding how to manually manipulate pointers and nodes, which is crucial for a deep understanding of data structures.\\n\\n2. **Language Agnostic**: These problems are designed to be language-agnostic. While Python has easy list manipulation, languages like C or C++ do not have such built-in capabilities. The problem is set to be fair to everyone, regardless of the programming language used.\\n\\n3. **Algorithm Complexity**: Some problems require an in-depth understanding of algorithm complexity. Using built-in functions like `sort` can sometimes give a false sense of simplicity when, in fact, the actual task of merging the lists might be more complex.\\n\\n4. **Resource Utilization**: In some cases, especially in embedded systems or other resource-constrained environments, understanding how to work with nodes and pointers is essential for efficient memory usage.\\n\\n5. **Skill Assessment**: These problems are often used in interviews to assess understanding of fundamental computer science concepts, beyond syntactic sugar provided by specific programming languages.\\n\\n6. **Real-world Use Cases**: Not all data comes in simple, sorted, array-like structures. Linked lists, trees, and graphs are data structures commonly used in real-world applications. Understanding them is key to being a well-rounded developer.\\n\\n7. **Optimal Substructure**: Problems that mandate the use of data structures like linked lists often involve an optimal substructure that makes for an elegant solution, thereby teaching you problem-solving patterns that can be applied elsewhere.\\n\\n8. **Consistency**: If a problem was initially posed in a computer science paper or textbook using `ListNodes`, it\\'s often kept that way to maintain consistency with classic algorithm and data structure literature.\\n\\nSo while it may seem unnecessary or verbose, using `ListNode` provides a broader educational benefit, ensuring that you understand both high-level language features and low-level data structure manipulation."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go tell it on an interview :)"
                    },
                    {
                        "username": "Vantrashell",
                        "content": "[@mikael6767](/mikael6767) The goal should very rarely be to write the shortest amount of code. The 1 line solution typically uses a generalized algorithm, which may or may not be useful for what you wish to do. The problem forces ListNode as a guide to push in the direction it wants. Most of the solutions, although using ListNode, ignore this guide as the question very clearly wants a solution that does not create new memory as LinkedLists do not require such a complex operation for insertion. Ultimately, the point is (and why this is a hard problem and not a medium one like others have suggested) to do mergeKLists in O(1) space. The one line of Python most-likely does allocate new memory somewhere. If your customer pays for the amount of ram they use from a cloud service, they would be most pleased if you would keep that cost low."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Ok, @cartesPerforees, then explain why do we need ListNode if we can do this problem way easier without it. The goal is to make the solution with the shortest possible code. In this case 1 line, not 50. Imagine a customer wants you to make this problem: Merge K Sorted Lists. He doesn\\'t say how you need to do it, He just says to do it on python3. How would you do it? Would you write 50 lines of code using ListNode or one line of code. Please read and reply and we can discuss this later."
                    },
                    {
                        "username": "user5331Az",
                        "content": "bravo! dude, the task is for the ones familiar with algorithmic complexity concept at least, definitely not for you."
                    },
                    {
                        "username": "squigity",
                        "content": "[@mikael6767](/mikael6767)  Concept of linked lists is for a different scenario ,  the question here is to know if we understand linked lists or not and not to merge a sorted list from a list of lists"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your comment puzzles me. The whole point of those problems is to give you something to solve, and make it somewhat of a challenge depending on the difficulty tag. Most of the problems on leetcode are artificial and of no practical use, they are just made to help you practise probem solving.\\nI don\\'t get why you complain that they\\'re making things harder for you. That\\'s the point. It\\'s like playing with one of those chinese/japanes wooden brain teasers and  complaining that they should have designed it so that it opens like a normal box."
                    },
                    {
                        "username": "mikael6767",
                        "content": "I realize this. I am programming on python3 and really know that it really is one line of code, but the problem is with ListNode. There are a lot LeetCode problems with ListNode and I can\\'t make them even if they are very easy without it. I have the same problem. I wrote that one line of code and it says it is not right. I would really like for someone to help you, but I\\'m sorry I can\\'t."
                    },
                    {
                        "username": "David_E_something",
                        "content": "If you somehow use a priority queue (heap), this problem becomes very easy."
                    },
                    {
                        "username": "clinkz93",
                        "content": "[@layman806](/layman806) Using a priority queue results in a complexity of O((k + n) * log(k)) instead of O(n * log(n)), which may be preferrable."
                    },
                    {
                        "username": "root89",
                        "content": "[@layman806](/layman806) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@layman806](/layman806) lmao,, you can\\'t beat the interviewer."
                    },
                    {
                        "username": "layman806",
                        "content": "Or just parse all into an array in O(n) time, then sort it in O(n.log(n)) time and convert it to a linked list in O(n) time. This is just too easy to beat. Shouldn\\'t be tagged as hard."
                    },
                    {
                        "username": "JaviOverflow",
                        "content": "When I submit my solution, it fails on the input `[[]]`, how is that input even posible? `ListNode` requires `val` as argument in its constructor. Returning `None` doesn\\'t make the test pass. I\\'m not sure how to tackle that."
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "thenimator",
                        "content": "It\\'s been a while since you had this problem but for anyone else running into it:\\n\\n[[]] simply stands for an array with 1 element with that one element being a null pointer (which in this context stands for an empty linked list and not one where the value of the first element is missing)"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, WTF? ![image](https://assets.leetcode.com/users/beatrizdos/image_1570843047.png)\\n"
                    },
                    {
                        "username": "Will-O-Wisp",
                        "content": "class ListNode(object):\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\n\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        def mergeTwoLists(l1, l2):\\n            dummy = ListNode(0)\\n            current = dummy\\n\\n            while l1 and l2:\\n                if l1.val < l2.val:\\n                    current.next = l1\\n                    l1 = l1.next\\n                else:\\n                    current.next = l2\\n                    l2 = l2.next\\n                current = current.next\\n\\n            current.next = l1 if l1 else l2\\n\\n            return dummy.next\\n\\n        if not lists:\\n            return None\\n\\n        while len(lists) > 1:\\n            merged_lists = []\\n\\n            for i in range(0, len(lists), 2):\\n                l1 = lists[i]\\n                l2 = lists[i + 1] if i + 1 < len(lists) else None\\n                merged_lists.append(mergeTwoLists(l1, l2))\\n\\n            lists = merged_lists\\n\\n        return lists[0] if lists else None\\n\\n\\n# Example usage\\nlists = [\\n    ListNode(1, ListNode(4, ListNode(5))),\\n    ListNode(1, ListNode(3, ListNode(4))),\\n    ListNode(2, ListNode(6))\\n]\\n\\nsolution = Solution()\\nresult = solution.mergeKLists(lists)\\nwhile result:\\n    print(result.val)\\n    result = result.next\\n"
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "qin4",
                        "content": "Util class ListNode in python 3 is not completed. It can\\'t do heapq directly. Fix is easier on server side."
                    }
                ]
            },
            {
                "id": 1565582,
                "content": [
                    {
                        "username": "adambene",
                        "content": "This problem should not be marked as hard.\\nMedium is more proper based on the other problems on leetcode."
                    },
                    {
                        "username": "Pranjal_Bajpai",
                        "content": "i would say easy, its no brainer !"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cwooldridge](/cwooldridge)  POV: you solved your first HARD problem. "
                    },
                    {
                        "username": "jason3410",
                        "content": "[@Mister_CK](/Mister_CK) Cuz your solution make no connection with the ListNodes. And u won\\'t learn anything on this question."
                    },
                    {
                        "username": "user5331Az",
                        "content": "[@Mister_CK](/Mister_CK) putting an element into sorted array is O(log2(n)), sorting of an array is O(n^2) generally."
                    },
                    {
                        "username": "dhunmoon",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "[@cwooldridge](/cwooldridge) I almost started to think that i\\'m a hard problem solver and then I came here"
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Hey man, cmon, let me enjoy this moment\\uD83D\\uDE02"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It should be Easy imo. At least in JS there is no need to use a priority queue. You can just put all the values in an array, sort that array and put them in a list you then return. runs in 79 ms, beats 97% of solutions and it's the same answer as for the Easy problem `21. Merge Two Sorted Lists` (albeit that this is an array of lists, rather than just two, but it's the exact same principle). I really don't understand why this is marked with Hard and Priority Queue, really threw me off. I wrote a whole solution with a priority queue for an hour, only to realise it was completely unnecessary and I wrote a faster algorithm without it in 5 minutes. ([@joseph261059](/joseph261059) I tried using that, but I got an error on the node version (I believe it couldn't find insert), so I copied an implementation of a PriorityQueue using heap from stackoverflow) (PS: I checked, in regular Java it runs in 8 ms (beating only 28% of solutions), but that is still well within the accepted solution range.)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "[@Husoski](/Husoski) In JS, we can use PriorityQueue package in leetcode"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Well this still is hard problem as if go optimize your time complexity the solutions becomes more and more complex!"
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@Husoski](/Husoski) Indeed, but nobody uses programming languages like C in competitive programming. The most popular languages are C++, Java and Python. If there is no standard library with basic data structures like a `vector` or a `heap` in the programming language of your choice, you might want to use another language for the purpose of solving leetcode questions."
                    },
                    {
                        "username": "Husoski",
                        "content": "That depends on the language you used.  In a language with a standard heap or priority queue data structure this is indeed on the easy side of Medium.  I think it\\'s more like Hard in a language like C or JS.  (Assuming, of course, that the solver is going write the minheap code and not copy-paste it! :^)"
                    },
                    {
                        "username": "viocost",
                        "content": "The problem is interesting, but why there are test cases such as [[], []] \\nand not a word about possible inputs expected output?\\n\\nIs it also a telepathy exercise?\\n"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Very annoying; they don\\'t seem to mention how the output is parsed; the result needs to be a ListNode or null.\\nFilter the list then go from there."
                    },
                    {
                        "username": "alistar",
                        "content": "With empty list it seems to expect an empty list as an output, however, it doest not accept it with type-error.\\nLitterally copied and pasted one of the official solutions, it doesn\\'t go through with the same issue!"
                    },
                    {
                        "username": "user9118TR",
                        "content": "[@amithshetty](/amithshetty)  Thaks a lot, how did you know it ??"
                    },
                    {
                        "username": "sony541",
                        "content": "[@amithshetty](/amithshetty) Well, if \"None\" is the end of list, you can think of \"None\" as an empty linked list, nice callout here... It took me a while to figure out, but sounds reasonable after all.. Could\\'ve been clarified in promt though."
                    },
                    {
                        "username": "amithshetty",
                        "content": "IT expects None, i.e not a list but an empty linked list"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-k-sorted-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Compare one by one\n\n  \n**Approach 3:** Optimize Approach 2 by Priority Queue\n\n  \n**Approach 4:** Merge lists one by one\n\n  \n**Approach 5:** Merge with Divide And Conquer\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Kouei",
                        "content": "The fastest C++ code can achieve a time about 370ms ~ 380ms\\n\\nwhile Python code can achieve 100ms, and even amazing, JAVA can do it in just 4ms !\\n\\nThis result is quite counterintuitive."
                    },
                    {
                        "username": "321maayan",
                        "content": "python is build in c and c is powerful as c++\\n"
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "[@Normalitee0os](/Normalitee0os)  post the code lol"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Mine took 15 ms using C++"
                    },
                    {
                        "username": "Normalitee0os",
                        "content": "Mine took 0.1 ms using HTML."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Mine took 23ms in C++"
                    },
                    {
                        "username": "slashtab",
                        "content": "OJ of LeetCode isn\\'t that perfect."
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "mine 22ms with c++; "
                    },
                    {
                        "username": "charonme",
                        "content": "35ms in PHP without using any built-in functions except count"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "mine was 40ms in c++, which could be further optimized"
                    },
                    {
                        "username": "f1rumors",
                        "content": "underlying libraries are a boon"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python...\\n\\nI assume that everyone realizes that without using ListNode that the solution to this problem is one line of code. Flatten the lists to one list and sort the list. \\n\\nWhy are there so many problems that have to be answered using ListNodes? It\\'s a complete waste of time in a language such as python. Shouldn\\'t the simplest solution be the best solution? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of `ListNode` or linked lists in algorithmic problems isn\\'t necessarily about finding the most efficient solution in Python or any specific language. Rather, it\\'s about teaching or testing certain concepts. Here are a few reasons:\\n\\n1. **Conceptual Understanding**: Using `ListNode` often helps in understanding how to manually manipulate pointers and nodes, which is crucial for a deep understanding of data structures.\\n\\n2. **Language Agnostic**: These problems are designed to be language-agnostic. While Python has easy list manipulation, languages like C or C++ do not have such built-in capabilities. The problem is set to be fair to everyone, regardless of the programming language used.\\n\\n3. **Algorithm Complexity**: Some problems require an in-depth understanding of algorithm complexity. Using built-in functions like `sort` can sometimes give a false sense of simplicity when, in fact, the actual task of merging the lists might be more complex.\\n\\n4. **Resource Utilization**: In some cases, especially in embedded systems or other resource-constrained environments, understanding how to work with nodes and pointers is essential for efficient memory usage.\\n\\n5. **Skill Assessment**: These problems are often used in interviews to assess understanding of fundamental computer science concepts, beyond syntactic sugar provided by specific programming languages.\\n\\n6. **Real-world Use Cases**: Not all data comes in simple, sorted, array-like structures. Linked lists, trees, and graphs are data structures commonly used in real-world applications. Understanding them is key to being a well-rounded developer.\\n\\n7. **Optimal Substructure**: Problems that mandate the use of data structures like linked lists often involve an optimal substructure that makes for an elegant solution, thereby teaching you problem-solving patterns that can be applied elsewhere.\\n\\n8. **Consistency**: If a problem was initially posed in a computer science paper or textbook using `ListNodes`, it\\'s often kept that way to maintain consistency with classic algorithm and data structure literature.\\n\\nSo while it may seem unnecessary or verbose, using `ListNode` provides a broader educational benefit, ensuring that you understand both high-level language features and low-level data structure manipulation."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go tell it on an interview :)"
                    },
                    {
                        "username": "Vantrashell",
                        "content": "[@mikael6767](/mikael6767) The goal should very rarely be to write the shortest amount of code. The 1 line solution typically uses a generalized algorithm, which may or may not be useful for what you wish to do. The problem forces ListNode as a guide to push in the direction it wants. Most of the solutions, although using ListNode, ignore this guide as the question very clearly wants a solution that does not create new memory as LinkedLists do not require such a complex operation for insertion. Ultimately, the point is (and why this is a hard problem and not a medium one like others have suggested) to do mergeKLists in O(1) space. The one line of Python most-likely does allocate new memory somewhere. If your customer pays for the amount of ram they use from a cloud service, they would be most pleased if you would keep that cost low."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Ok, @cartesPerforees, then explain why do we need ListNode if we can do this problem way easier without it. The goal is to make the solution with the shortest possible code. In this case 1 line, not 50. Imagine a customer wants you to make this problem: Merge K Sorted Lists. He doesn\\'t say how you need to do it, He just says to do it on python3. How would you do it? Would you write 50 lines of code using ListNode or one line of code. Please read and reply and we can discuss this later."
                    },
                    {
                        "username": "user5331Az",
                        "content": "bravo! dude, the task is for the ones familiar with algorithmic complexity concept at least, definitely not for you."
                    },
                    {
                        "username": "squigity",
                        "content": "[@mikael6767](/mikael6767)  Concept of linked lists is for a different scenario ,  the question here is to know if we understand linked lists or not and not to merge a sorted list from a list of lists"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your comment puzzles me. The whole point of those problems is to give you something to solve, and make it somewhat of a challenge depending on the difficulty tag. Most of the problems on leetcode are artificial and of no practical use, they are just made to help you practise probem solving.\\nI don\\'t get why you complain that they\\'re making things harder for you. That\\'s the point. It\\'s like playing with one of those chinese/japanes wooden brain teasers and  complaining that they should have designed it so that it opens like a normal box."
                    },
                    {
                        "username": "mikael6767",
                        "content": "I realize this. I am programming on python3 and really know that it really is one line of code, but the problem is with ListNode. There are a lot LeetCode problems with ListNode and I can\\'t make them even if they are very easy without it. I have the same problem. I wrote that one line of code and it says it is not right. I would really like for someone to help you, but I\\'m sorry I can\\'t."
                    },
                    {
                        "username": "David_E_something",
                        "content": "If you somehow use a priority queue (heap), this problem becomes very easy."
                    },
                    {
                        "username": "clinkz93",
                        "content": "[@layman806](/layman806) Using a priority queue results in a complexity of O((k + n) * log(k)) instead of O(n * log(n)), which may be preferrable."
                    },
                    {
                        "username": "root89",
                        "content": "[@layman806](/layman806) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@layman806](/layman806) lmao,, you can\\'t beat the interviewer."
                    },
                    {
                        "username": "layman806",
                        "content": "Or just parse all into an array in O(n) time, then sort it in O(n.log(n)) time and convert it to a linked list in O(n) time. This is just too easy to beat. Shouldn\\'t be tagged as hard."
                    },
                    {
                        "username": "JaviOverflow",
                        "content": "When I submit my solution, it fails on the input `[[]]`, how is that input even posible? `ListNode` requires `val` as argument in its constructor. Returning `None` doesn\\'t make the test pass. I\\'m not sure how to tackle that."
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "thenimator",
                        "content": "It\\'s been a while since you had this problem but for anyone else running into it:\\n\\n[[]] simply stands for an array with 1 element with that one element being a null pointer (which in this context stands for an empty linked list and not one where the value of the first element is missing)"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, WTF? ![image](https://assets.leetcode.com/users/beatrizdos/image_1570843047.png)\\n"
                    },
                    {
                        "username": "Will-O-Wisp",
                        "content": "class ListNode(object):\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\n\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        def mergeTwoLists(l1, l2):\\n            dummy = ListNode(0)\\n            current = dummy\\n\\n            while l1 and l2:\\n                if l1.val < l2.val:\\n                    current.next = l1\\n                    l1 = l1.next\\n                else:\\n                    current.next = l2\\n                    l2 = l2.next\\n                current = current.next\\n\\n            current.next = l1 if l1 else l2\\n\\n            return dummy.next\\n\\n        if not lists:\\n            return None\\n\\n        while len(lists) > 1:\\n            merged_lists = []\\n\\n            for i in range(0, len(lists), 2):\\n                l1 = lists[i]\\n                l2 = lists[i + 1] if i + 1 < len(lists) else None\\n                merged_lists.append(mergeTwoLists(l1, l2))\\n\\n            lists = merged_lists\\n\\n        return lists[0] if lists else None\\n\\n\\n# Example usage\\nlists = [\\n    ListNode(1, ListNode(4, ListNode(5))),\\n    ListNode(1, ListNode(3, ListNode(4))),\\n    ListNode(2, ListNode(6))\\n]\\n\\nsolution = Solution()\\nresult = solution.mergeKLists(lists)\\nwhile result:\\n    print(result.val)\\n    result = result.next\\n"
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "qin4",
                        "content": "Util class ListNode in python 3 is not completed. It can\\'t do heapq directly. Fix is easier on server side."
                    }
                ]
            },
            {
                "id": 1568841,
                "content": [
                    {
                        "username": "adambene",
                        "content": "This problem should not be marked as hard.\\nMedium is more proper based on the other problems on leetcode."
                    },
                    {
                        "username": "Pranjal_Bajpai",
                        "content": "i would say easy, its no brainer !"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cwooldridge](/cwooldridge)  POV: you solved your first HARD problem. "
                    },
                    {
                        "username": "jason3410",
                        "content": "[@Mister_CK](/Mister_CK) Cuz your solution make no connection with the ListNodes. And u won\\'t learn anything on this question."
                    },
                    {
                        "username": "user5331Az",
                        "content": "[@Mister_CK](/Mister_CK) putting an element into sorted array is O(log2(n)), sorting of an array is O(n^2) generally."
                    },
                    {
                        "username": "dhunmoon",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "[@cwooldridge](/cwooldridge) I almost started to think that i\\'m a hard problem solver and then I came here"
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Hey man, cmon, let me enjoy this moment\\uD83D\\uDE02"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It should be Easy imo. At least in JS there is no need to use a priority queue. You can just put all the values in an array, sort that array and put them in a list you then return. runs in 79 ms, beats 97% of solutions and it's the same answer as for the Easy problem `21. Merge Two Sorted Lists` (albeit that this is an array of lists, rather than just two, but it's the exact same principle). I really don't understand why this is marked with Hard and Priority Queue, really threw me off. I wrote a whole solution with a priority queue for an hour, only to realise it was completely unnecessary and I wrote a faster algorithm without it in 5 minutes. ([@joseph261059](/joseph261059) I tried using that, but I got an error on the node version (I believe it couldn't find insert), so I copied an implementation of a PriorityQueue using heap from stackoverflow) (PS: I checked, in regular Java it runs in 8 ms (beating only 28% of solutions), but that is still well within the accepted solution range.)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "[@Husoski](/Husoski) In JS, we can use PriorityQueue package in leetcode"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Well this still is hard problem as if go optimize your time complexity the solutions becomes more and more complex!"
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@Husoski](/Husoski) Indeed, but nobody uses programming languages like C in competitive programming. The most popular languages are C++, Java and Python. If there is no standard library with basic data structures like a `vector` or a `heap` in the programming language of your choice, you might want to use another language for the purpose of solving leetcode questions."
                    },
                    {
                        "username": "Husoski",
                        "content": "That depends on the language you used.  In a language with a standard heap or priority queue data structure this is indeed on the easy side of Medium.  I think it\\'s more like Hard in a language like C or JS.  (Assuming, of course, that the solver is going write the minheap code and not copy-paste it! :^)"
                    },
                    {
                        "username": "viocost",
                        "content": "The problem is interesting, but why there are test cases such as [[], []] \\nand not a word about possible inputs expected output?\\n\\nIs it also a telepathy exercise?\\n"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Very annoying; they don\\'t seem to mention how the output is parsed; the result needs to be a ListNode or null.\\nFilter the list then go from there."
                    },
                    {
                        "username": "alistar",
                        "content": "With empty list it seems to expect an empty list as an output, however, it doest not accept it with type-error.\\nLitterally copied and pasted one of the official solutions, it doesn\\'t go through with the same issue!"
                    },
                    {
                        "username": "user9118TR",
                        "content": "[@amithshetty](/amithshetty)  Thaks a lot, how did you know it ??"
                    },
                    {
                        "username": "sony541",
                        "content": "[@amithshetty](/amithshetty) Well, if \"None\" is the end of list, you can think of \"None\" as an empty linked list, nice callout here... It took me a while to figure out, but sounds reasonable after all.. Could\\'ve been clarified in promt though."
                    },
                    {
                        "username": "amithshetty",
                        "content": "IT expects None, i.e not a list but an empty linked list"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-k-sorted-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Compare one by one\n\n  \n**Approach 3:** Optimize Approach 2 by Priority Queue\n\n  \n**Approach 4:** Merge lists one by one\n\n  \n**Approach 5:** Merge with Divide And Conquer\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Kouei",
                        "content": "The fastest C++ code can achieve a time about 370ms ~ 380ms\\n\\nwhile Python code can achieve 100ms, and even amazing, JAVA can do it in just 4ms !\\n\\nThis result is quite counterintuitive."
                    },
                    {
                        "username": "321maayan",
                        "content": "python is build in c and c is powerful as c++\\n"
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "[@Normalitee0os](/Normalitee0os)  post the code lol"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Mine took 15 ms using C++"
                    },
                    {
                        "username": "Normalitee0os",
                        "content": "Mine took 0.1 ms using HTML."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Mine took 23ms in C++"
                    },
                    {
                        "username": "slashtab",
                        "content": "OJ of LeetCode isn\\'t that perfect."
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "mine 22ms with c++; "
                    },
                    {
                        "username": "charonme",
                        "content": "35ms in PHP without using any built-in functions except count"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "mine was 40ms in c++, which could be further optimized"
                    },
                    {
                        "username": "f1rumors",
                        "content": "underlying libraries are a boon"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python...\\n\\nI assume that everyone realizes that without using ListNode that the solution to this problem is one line of code. Flatten the lists to one list and sort the list. \\n\\nWhy are there so many problems that have to be answered using ListNodes? It\\'s a complete waste of time in a language such as python. Shouldn\\'t the simplest solution be the best solution? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of `ListNode` or linked lists in algorithmic problems isn\\'t necessarily about finding the most efficient solution in Python or any specific language. Rather, it\\'s about teaching or testing certain concepts. Here are a few reasons:\\n\\n1. **Conceptual Understanding**: Using `ListNode` often helps in understanding how to manually manipulate pointers and nodes, which is crucial for a deep understanding of data structures.\\n\\n2. **Language Agnostic**: These problems are designed to be language-agnostic. While Python has easy list manipulation, languages like C or C++ do not have such built-in capabilities. The problem is set to be fair to everyone, regardless of the programming language used.\\n\\n3. **Algorithm Complexity**: Some problems require an in-depth understanding of algorithm complexity. Using built-in functions like `sort` can sometimes give a false sense of simplicity when, in fact, the actual task of merging the lists might be more complex.\\n\\n4. **Resource Utilization**: In some cases, especially in embedded systems or other resource-constrained environments, understanding how to work with nodes and pointers is essential for efficient memory usage.\\n\\n5. **Skill Assessment**: These problems are often used in interviews to assess understanding of fundamental computer science concepts, beyond syntactic sugar provided by specific programming languages.\\n\\n6. **Real-world Use Cases**: Not all data comes in simple, sorted, array-like structures. Linked lists, trees, and graphs are data structures commonly used in real-world applications. Understanding them is key to being a well-rounded developer.\\n\\n7. **Optimal Substructure**: Problems that mandate the use of data structures like linked lists often involve an optimal substructure that makes for an elegant solution, thereby teaching you problem-solving patterns that can be applied elsewhere.\\n\\n8. **Consistency**: If a problem was initially posed in a computer science paper or textbook using `ListNodes`, it\\'s often kept that way to maintain consistency with classic algorithm and data structure literature.\\n\\nSo while it may seem unnecessary or verbose, using `ListNode` provides a broader educational benefit, ensuring that you understand both high-level language features and low-level data structure manipulation."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go tell it on an interview :)"
                    },
                    {
                        "username": "Vantrashell",
                        "content": "[@mikael6767](/mikael6767) The goal should very rarely be to write the shortest amount of code. The 1 line solution typically uses a generalized algorithm, which may or may not be useful for what you wish to do. The problem forces ListNode as a guide to push in the direction it wants. Most of the solutions, although using ListNode, ignore this guide as the question very clearly wants a solution that does not create new memory as LinkedLists do not require such a complex operation for insertion. Ultimately, the point is (and why this is a hard problem and not a medium one like others have suggested) to do mergeKLists in O(1) space. The one line of Python most-likely does allocate new memory somewhere. If your customer pays for the amount of ram they use from a cloud service, they would be most pleased if you would keep that cost low."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Ok, @cartesPerforees, then explain why do we need ListNode if we can do this problem way easier without it. The goal is to make the solution with the shortest possible code. In this case 1 line, not 50. Imagine a customer wants you to make this problem: Merge K Sorted Lists. He doesn\\'t say how you need to do it, He just says to do it on python3. How would you do it? Would you write 50 lines of code using ListNode or one line of code. Please read and reply and we can discuss this later."
                    },
                    {
                        "username": "user5331Az",
                        "content": "bravo! dude, the task is for the ones familiar with algorithmic complexity concept at least, definitely not for you."
                    },
                    {
                        "username": "squigity",
                        "content": "[@mikael6767](/mikael6767)  Concept of linked lists is for a different scenario ,  the question here is to know if we understand linked lists or not and not to merge a sorted list from a list of lists"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your comment puzzles me. The whole point of those problems is to give you something to solve, and make it somewhat of a challenge depending on the difficulty tag. Most of the problems on leetcode are artificial and of no practical use, they are just made to help you practise probem solving.\\nI don\\'t get why you complain that they\\'re making things harder for you. That\\'s the point. It\\'s like playing with one of those chinese/japanes wooden brain teasers and  complaining that they should have designed it so that it opens like a normal box."
                    },
                    {
                        "username": "mikael6767",
                        "content": "I realize this. I am programming on python3 and really know that it really is one line of code, but the problem is with ListNode. There are a lot LeetCode problems with ListNode and I can\\'t make them even if they are very easy without it. I have the same problem. I wrote that one line of code and it says it is not right. I would really like for someone to help you, but I\\'m sorry I can\\'t."
                    },
                    {
                        "username": "David_E_something",
                        "content": "If you somehow use a priority queue (heap), this problem becomes very easy."
                    },
                    {
                        "username": "clinkz93",
                        "content": "[@layman806](/layman806) Using a priority queue results in a complexity of O((k + n) * log(k)) instead of O(n * log(n)), which may be preferrable."
                    },
                    {
                        "username": "root89",
                        "content": "[@layman806](/layman806) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@layman806](/layman806) lmao,, you can\\'t beat the interviewer."
                    },
                    {
                        "username": "layman806",
                        "content": "Or just parse all into an array in O(n) time, then sort it in O(n.log(n)) time and convert it to a linked list in O(n) time. This is just too easy to beat. Shouldn\\'t be tagged as hard."
                    },
                    {
                        "username": "JaviOverflow",
                        "content": "When I submit my solution, it fails on the input `[[]]`, how is that input even posible? `ListNode` requires `val` as argument in its constructor. Returning `None` doesn\\'t make the test pass. I\\'m not sure how to tackle that."
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "thenimator",
                        "content": "It\\'s been a while since you had this problem but for anyone else running into it:\\n\\n[[]] simply stands for an array with 1 element with that one element being a null pointer (which in this context stands for an empty linked list and not one where the value of the first element is missing)"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, WTF? ![image](https://assets.leetcode.com/users/beatrizdos/image_1570843047.png)\\n"
                    },
                    {
                        "username": "Will-O-Wisp",
                        "content": "class ListNode(object):\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\n\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        def mergeTwoLists(l1, l2):\\n            dummy = ListNode(0)\\n            current = dummy\\n\\n            while l1 and l2:\\n                if l1.val < l2.val:\\n                    current.next = l1\\n                    l1 = l1.next\\n                else:\\n                    current.next = l2\\n                    l2 = l2.next\\n                current = current.next\\n\\n            current.next = l1 if l1 else l2\\n\\n            return dummy.next\\n\\n        if not lists:\\n            return None\\n\\n        while len(lists) > 1:\\n            merged_lists = []\\n\\n            for i in range(0, len(lists), 2):\\n                l1 = lists[i]\\n                l2 = lists[i + 1] if i + 1 < len(lists) else None\\n                merged_lists.append(mergeTwoLists(l1, l2))\\n\\n            lists = merged_lists\\n\\n        return lists[0] if lists else None\\n\\n\\n# Example usage\\nlists = [\\n    ListNode(1, ListNode(4, ListNode(5))),\\n    ListNode(1, ListNode(3, ListNode(4))),\\n    ListNode(2, ListNode(6))\\n]\\n\\nsolution = Solution()\\nresult = solution.mergeKLists(lists)\\nwhile result:\\n    print(result.val)\\n    result = result.next\\n"
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "qin4",
                        "content": "Util class ListNode in python 3 is not completed. It can\\'t do heapq directly. Fix is easier on server side."
                    }
                ]
            },
            {
                "id": 1804644,
                "content": [
                    {
                        "username": "adambene",
                        "content": "This problem should not be marked as hard.\\nMedium is more proper based on the other problems on leetcode."
                    },
                    {
                        "username": "Pranjal_Bajpai",
                        "content": "i would say easy, its no brainer !"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cwooldridge](/cwooldridge)  POV: you solved your first HARD problem. "
                    },
                    {
                        "username": "jason3410",
                        "content": "[@Mister_CK](/Mister_CK) Cuz your solution make no connection with the ListNodes. And u won\\'t learn anything on this question."
                    },
                    {
                        "username": "user5331Az",
                        "content": "[@Mister_CK](/Mister_CK) putting an element into sorted array is O(log2(n)), sorting of an array is O(n^2) generally."
                    },
                    {
                        "username": "dhunmoon",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "[@cwooldridge](/cwooldridge) I almost started to think that i\\'m a hard problem solver and then I came here"
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Hey man, cmon, let me enjoy this moment\\uD83D\\uDE02"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It should be Easy imo. At least in JS there is no need to use a priority queue. You can just put all the values in an array, sort that array and put them in a list you then return. runs in 79 ms, beats 97% of solutions and it's the same answer as for the Easy problem `21. Merge Two Sorted Lists` (albeit that this is an array of lists, rather than just two, but it's the exact same principle). I really don't understand why this is marked with Hard and Priority Queue, really threw me off. I wrote a whole solution with a priority queue for an hour, only to realise it was completely unnecessary and I wrote a faster algorithm without it in 5 minutes. ([@joseph261059](/joseph261059) I tried using that, but I got an error on the node version (I believe it couldn't find insert), so I copied an implementation of a PriorityQueue using heap from stackoverflow) (PS: I checked, in regular Java it runs in 8 ms (beating only 28% of solutions), but that is still well within the accepted solution range.)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "[@Husoski](/Husoski) In JS, we can use PriorityQueue package in leetcode"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Well this still is hard problem as if go optimize your time complexity the solutions becomes more and more complex!"
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@Husoski](/Husoski) Indeed, but nobody uses programming languages like C in competitive programming. The most popular languages are C++, Java and Python. If there is no standard library with basic data structures like a `vector` or a `heap` in the programming language of your choice, you might want to use another language for the purpose of solving leetcode questions."
                    },
                    {
                        "username": "Husoski",
                        "content": "That depends on the language you used.  In a language with a standard heap or priority queue data structure this is indeed on the easy side of Medium.  I think it\\'s more like Hard in a language like C or JS.  (Assuming, of course, that the solver is going write the minheap code and not copy-paste it! :^)"
                    },
                    {
                        "username": "viocost",
                        "content": "The problem is interesting, but why there are test cases such as [[], []] \\nand not a word about possible inputs expected output?\\n\\nIs it also a telepathy exercise?\\n"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Very annoying; they don\\'t seem to mention how the output is parsed; the result needs to be a ListNode or null.\\nFilter the list then go from there."
                    },
                    {
                        "username": "alistar",
                        "content": "With empty list it seems to expect an empty list as an output, however, it doest not accept it with type-error.\\nLitterally copied and pasted one of the official solutions, it doesn\\'t go through with the same issue!"
                    },
                    {
                        "username": "user9118TR",
                        "content": "[@amithshetty](/amithshetty)  Thaks a lot, how did you know it ??"
                    },
                    {
                        "username": "sony541",
                        "content": "[@amithshetty](/amithshetty) Well, if \"None\" is the end of list, you can think of \"None\" as an empty linked list, nice callout here... It took me a while to figure out, but sounds reasonable after all.. Could\\'ve been clarified in promt though."
                    },
                    {
                        "username": "amithshetty",
                        "content": "IT expects None, i.e not a list but an empty linked list"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-k-sorted-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Compare one by one\n\n  \n**Approach 3:** Optimize Approach 2 by Priority Queue\n\n  \n**Approach 4:** Merge lists one by one\n\n  \n**Approach 5:** Merge with Divide And Conquer\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Kouei",
                        "content": "The fastest C++ code can achieve a time about 370ms ~ 380ms\\n\\nwhile Python code can achieve 100ms, and even amazing, JAVA can do it in just 4ms !\\n\\nThis result is quite counterintuitive."
                    },
                    {
                        "username": "321maayan",
                        "content": "python is build in c and c is powerful as c++\\n"
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "[@Normalitee0os](/Normalitee0os)  post the code lol"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Mine took 15 ms using C++"
                    },
                    {
                        "username": "Normalitee0os",
                        "content": "Mine took 0.1 ms using HTML."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Mine took 23ms in C++"
                    },
                    {
                        "username": "slashtab",
                        "content": "OJ of LeetCode isn\\'t that perfect."
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "mine 22ms with c++; "
                    },
                    {
                        "username": "charonme",
                        "content": "35ms in PHP without using any built-in functions except count"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "mine was 40ms in c++, which could be further optimized"
                    },
                    {
                        "username": "f1rumors",
                        "content": "underlying libraries are a boon"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python...\\n\\nI assume that everyone realizes that without using ListNode that the solution to this problem is one line of code. Flatten the lists to one list and sort the list. \\n\\nWhy are there so many problems that have to be answered using ListNodes? It\\'s a complete waste of time in a language such as python. Shouldn\\'t the simplest solution be the best solution? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of `ListNode` or linked lists in algorithmic problems isn\\'t necessarily about finding the most efficient solution in Python or any specific language. Rather, it\\'s about teaching or testing certain concepts. Here are a few reasons:\\n\\n1. **Conceptual Understanding**: Using `ListNode` often helps in understanding how to manually manipulate pointers and nodes, which is crucial for a deep understanding of data structures.\\n\\n2. **Language Agnostic**: These problems are designed to be language-agnostic. While Python has easy list manipulation, languages like C or C++ do not have such built-in capabilities. The problem is set to be fair to everyone, regardless of the programming language used.\\n\\n3. **Algorithm Complexity**: Some problems require an in-depth understanding of algorithm complexity. Using built-in functions like `sort` can sometimes give a false sense of simplicity when, in fact, the actual task of merging the lists might be more complex.\\n\\n4. **Resource Utilization**: In some cases, especially in embedded systems or other resource-constrained environments, understanding how to work with nodes and pointers is essential for efficient memory usage.\\n\\n5. **Skill Assessment**: These problems are often used in interviews to assess understanding of fundamental computer science concepts, beyond syntactic sugar provided by specific programming languages.\\n\\n6. **Real-world Use Cases**: Not all data comes in simple, sorted, array-like structures. Linked lists, trees, and graphs are data structures commonly used in real-world applications. Understanding them is key to being a well-rounded developer.\\n\\n7. **Optimal Substructure**: Problems that mandate the use of data structures like linked lists often involve an optimal substructure that makes for an elegant solution, thereby teaching you problem-solving patterns that can be applied elsewhere.\\n\\n8. **Consistency**: If a problem was initially posed in a computer science paper or textbook using `ListNodes`, it\\'s often kept that way to maintain consistency with classic algorithm and data structure literature.\\n\\nSo while it may seem unnecessary or verbose, using `ListNode` provides a broader educational benefit, ensuring that you understand both high-level language features and low-level data structure manipulation."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go tell it on an interview :)"
                    },
                    {
                        "username": "Vantrashell",
                        "content": "[@mikael6767](/mikael6767) The goal should very rarely be to write the shortest amount of code. The 1 line solution typically uses a generalized algorithm, which may or may not be useful for what you wish to do. The problem forces ListNode as a guide to push in the direction it wants. Most of the solutions, although using ListNode, ignore this guide as the question very clearly wants a solution that does not create new memory as LinkedLists do not require such a complex operation for insertion. Ultimately, the point is (and why this is a hard problem and not a medium one like others have suggested) to do mergeKLists in O(1) space. The one line of Python most-likely does allocate new memory somewhere. If your customer pays for the amount of ram they use from a cloud service, they would be most pleased if you would keep that cost low."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Ok, @cartesPerforees, then explain why do we need ListNode if we can do this problem way easier without it. The goal is to make the solution with the shortest possible code. In this case 1 line, not 50. Imagine a customer wants you to make this problem: Merge K Sorted Lists. He doesn\\'t say how you need to do it, He just says to do it on python3. How would you do it? Would you write 50 lines of code using ListNode or one line of code. Please read and reply and we can discuss this later."
                    },
                    {
                        "username": "user5331Az",
                        "content": "bravo! dude, the task is for the ones familiar with algorithmic complexity concept at least, definitely not for you."
                    },
                    {
                        "username": "squigity",
                        "content": "[@mikael6767](/mikael6767)  Concept of linked lists is for a different scenario ,  the question here is to know if we understand linked lists or not and not to merge a sorted list from a list of lists"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your comment puzzles me. The whole point of those problems is to give you something to solve, and make it somewhat of a challenge depending on the difficulty tag. Most of the problems on leetcode are artificial and of no practical use, they are just made to help you practise probem solving.\\nI don\\'t get why you complain that they\\'re making things harder for you. That\\'s the point. It\\'s like playing with one of those chinese/japanes wooden brain teasers and  complaining that they should have designed it so that it opens like a normal box."
                    },
                    {
                        "username": "mikael6767",
                        "content": "I realize this. I am programming on python3 and really know that it really is one line of code, but the problem is with ListNode. There are a lot LeetCode problems with ListNode and I can\\'t make them even if they are very easy without it. I have the same problem. I wrote that one line of code and it says it is not right. I would really like for someone to help you, but I\\'m sorry I can\\'t."
                    },
                    {
                        "username": "David_E_something",
                        "content": "If you somehow use a priority queue (heap), this problem becomes very easy."
                    },
                    {
                        "username": "clinkz93",
                        "content": "[@layman806](/layman806) Using a priority queue results in a complexity of O((k + n) * log(k)) instead of O(n * log(n)), which may be preferrable."
                    },
                    {
                        "username": "root89",
                        "content": "[@layman806](/layman806) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@layman806](/layman806) lmao,, you can\\'t beat the interviewer."
                    },
                    {
                        "username": "layman806",
                        "content": "Or just parse all into an array in O(n) time, then sort it in O(n.log(n)) time and convert it to a linked list in O(n) time. This is just too easy to beat. Shouldn\\'t be tagged as hard."
                    },
                    {
                        "username": "JaviOverflow",
                        "content": "When I submit my solution, it fails on the input `[[]]`, how is that input even posible? `ListNode` requires `val` as argument in its constructor. Returning `None` doesn\\'t make the test pass. I\\'m not sure how to tackle that."
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "thenimator",
                        "content": "It\\'s been a while since you had this problem but for anyone else running into it:\\n\\n[[]] simply stands for an array with 1 element with that one element being a null pointer (which in this context stands for an empty linked list and not one where the value of the first element is missing)"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, WTF? ![image](https://assets.leetcode.com/users/beatrizdos/image_1570843047.png)\\n"
                    },
                    {
                        "username": "Will-O-Wisp",
                        "content": "class ListNode(object):\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\n\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        def mergeTwoLists(l1, l2):\\n            dummy = ListNode(0)\\n            current = dummy\\n\\n            while l1 and l2:\\n                if l1.val < l2.val:\\n                    current.next = l1\\n                    l1 = l1.next\\n                else:\\n                    current.next = l2\\n                    l2 = l2.next\\n                current = current.next\\n\\n            current.next = l1 if l1 else l2\\n\\n            return dummy.next\\n\\n        if not lists:\\n            return None\\n\\n        while len(lists) > 1:\\n            merged_lists = []\\n\\n            for i in range(0, len(lists), 2):\\n                l1 = lists[i]\\n                l2 = lists[i + 1] if i + 1 < len(lists) else None\\n                merged_lists.append(mergeTwoLists(l1, l2))\\n\\n            lists = merged_lists\\n\\n        return lists[0] if lists else None\\n\\n\\n# Example usage\\nlists = [\\n    ListNode(1, ListNode(4, ListNode(5))),\\n    ListNode(1, ListNode(3, ListNode(4))),\\n    ListNode(2, ListNode(6))\\n]\\n\\nsolution = Solution()\\nresult = solution.mergeKLists(lists)\\nwhile result:\\n    print(result.val)\\n    result = result.next\\n"
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "qin4",
                        "content": "Util class ListNode in python 3 is not completed. It can\\'t do heapq directly. Fix is easier on server side."
                    }
                ]
            },
            {
                "id": 1750039,
                "content": [
                    {
                        "username": "adambene",
                        "content": "This problem should not be marked as hard.\\nMedium is more proper based on the other problems on leetcode."
                    },
                    {
                        "username": "Pranjal_Bajpai",
                        "content": "i would say easy, its no brainer !"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cwooldridge](/cwooldridge)  POV: you solved your first HARD problem. "
                    },
                    {
                        "username": "jason3410",
                        "content": "[@Mister_CK](/Mister_CK) Cuz your solution make no connection with the ListNodes. And u won\\'t learn anything on this question."
                    },
                    {
                        "username": "user5331Az",
                        "content": "[@Mister_CK](/Mister_CK) putting an element into sorted array is O(log2(n)), sorting of an array is O(n^2) generally."
                    },
                    {
                        "username": "dhunmoon",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "[@cwooldridge](/cwooldridge) I almost started to think that i\\'m a hard problem solver and then I came here"
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Hey man, cmon, let me enjoy this moment\\uD83D\\uDE02"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It should be Easy imo. At least in JS there is no need to use a priority queue. You can just put all the values in an array, sort that array and put them in a list you then return. runs in 79 ms, beats 97% of solutions and it's the same answer as for the Easy problem `21. Merge Two Sorted Lists` (albeit that this is an array of lists, rather than just two, but it's the exact same principle). I really don't understand why this is marked with Hard and Priority Queue, really threw me off. I wrote a whole solution with a priority queue for an hour, only to realise it was completely unnecessary and I wrote a faster algorithm without it in 5 minutes. ([@joseph261059](/joseph261059) I tried using that, but I got an error on the node version (I believe it couldn't find insert), so I copied an implementation of a PriorityQueue using heap from stackoverflow) (PS: I checked, in regular Java it runs in 8 ms (beating only 28% of solutions), but that is still well within the accepted solution range.)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "[@Husoski](/Husoski) In JS, we can use PriorityQueue package in leetcode"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Well this still is hard problem as if go optimize your time complexity the solutions becomes more and more complex!"
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@Husoski](/Husoski) Indeed, but nobody uses programming languages like C in competitive programming. The most popular languages are C++, Java and Python. If there is no standard library with basic data structures like a `vector` or a `heap` in the programming language of your choice, you might want to use another language for the purpose of solving leetcode questions."
                    },
                    {
                        "username": "Husoski",
                        "content": "That depends on the language you used.  In a language with a standard heap or priority queue data structure this is indeed on the easy side of Medium.  I think it\\'s more like Hard in a language like C or JS.  (Assuming, of course, that the solver is going write the minheap code and not copy-paste it! :^)"
                    },
                    {
                        "username": "viocost",
                        "content": "The problem is interesting, but why there are test cases such as [[], []] \\nand not a word about possible inputs expected output?\\n\\nIs it also a telepathy exercise?\\n"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Very annoying; they don\\'t seem to mention how the output is parsed; the result needs to be a ListNode or null.\\nFilter the list then go from there."
                    },
                    {
                        "username": "alistar",
                        "content": "With empty list it seems to expect an empty list as an output, however, it doest not accept it with type-error.\\nLitterally copied and pasted one of the official solutions, it doesn\\'t go through with the same issue!"
                    },
                    {
                        "username": "user9118TR",
                        "content": "[@amithshetty](/amithshetty)  Thaks a lot, how did you know it ??"
                    },
                    {
                        "username": "sony541",
                        "content": "[@amithshetty](/amithshetty) Well, if \"None\" is the end of list, you can think of \"None\" as an empty linked list, nice callout here... It took me a while to figure out, but sounds reasonable after all.. Could\\'ve been clarified in promt though."
                    },
                    {
                        "username": "amithshetty",
                        "content": "IT expects None, i.e not a list but an empty linked list"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-k-sorted-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Compare one by one\n\n  \n**Approach 3:** Optimize Approach 2 by Priority Queue\n\n  \n**Approach 4:** Merge lists one by one\n\n  \n**Approach 5:** Merge with Divide And Conquer\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Kouei",
                        "content": "The fastest C++ code can achieve a time about 370ms ~ 380ms\\n\\nwhile Python code can achieve 100ms, and even amazing, JAVA can do it in just 4ms !\\n\\nThis result is quite counterintuitive."
                    },
                    {
                        "username": "321maayan",
                        "content": "python is build in c and c is powerful as c++\\n"
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "[@Normalitee0os](/Normalitee0os)  post the code lol"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Mine took 15 ms using C++"
                    },
                    {
                        "username": "Normalitee0os",
                        "content": "Mine took 0.1 ms using HTML."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Mine took 23ms in C++"
                    },
                    {
                        "username": "slashtab",
                        "content": "OJ of LeetCode isn\\'t that perfect."
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "mine 22ms with c++; "
                    },
                    {
                        "username": "charonme",
                        "content": "35ms in PHP without using any built-in functions except count"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "mine was 40ms in c++, which could be further optimized"
                    },
                    {
                        "username": "f1rumors",
                        "content": "underlying libraries are a boon"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python...\\n\\nI assume that everyone realizes that without using ListNode that the solution to this problem is one line of code. Flatten the lists to one list and sort the list. \\n\\nWhy are there so many problems that have to be answered using ListNodes? It\\'s a complete waste of time in a language such as python. Shouldn\\'t the simplest solution be the best solution? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of `ListNode` or linked lists in algorithmic problems isn\\'t necessarily about finding the most efficient solution in Python or any specific language. Rather, it\\'s about teaching or testing certain concepts. Here are a few reasons:\\n\\n1. **Conceptual Understanding**: Using `ListNode` often helps in understanding how to manually manipulate pointers and nodes, which is crucial for a deep understanding of data structures.\\n\\n2. **Language Agnostic**: These problems are designed to be language-agnostic. While Python has easy list manipulation, languages like C or C++ do not have such built-in capabilities. The problem is set to be fair to everyone, regardless of the programming language used.\\n\\n3. **Algorithm Complexity**: Some problems require an in-depth understanding of algorithm complexity. Using built-in functions like `sort` can sometimes give a false sense of simplicity when, in fact, the actual task of merging the lists might be more complex.\\n\\n4. **Resource Utilization**: In some cases, especially in embedded systems or other resource-constrained environments, understanding how to work with nodes and pointers is essential for efficient memory usage.\\n\\n5. **Skill Assessment**: These problems are often used in interviews to assess understanding of fundamental computer science concepts, beyond syntactic sugar provided by specific programming languages.\\n\\n6. **Real-world Use Cases**: Not all data comes in simple, sorted, array-like structures. Linked lists, trees, and graphs are data structures commonly used in real-world applications. Understanding them is key to being a well-rounded developer.\\n\\n7. **Optimal Substructure**: Problems that mandate the use of data structures like linked lists often involve an optimal substructure that makes for an elegant solution, thereby teaching you problem-solving patterns that can be applied elsewhere.\\n\\n8. **Consistency**: If a problem was initially posed in a computer science paper or textbook using `ListNodes`, it\\'s often kept that way to maintain consistency with classic algorithm and data structure literature.\\n\\nSo while it may seem unnecessary or verbose, using `ListNode` provides a broader educational benefit, ensuring that you understand both high-level language features and low-level data structure manipulation."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go tell it on an interview :)"
                    },
                    {
                        "username": "Vantrashell",
                        "content": "[@mikael6767](/mikael6767) The goal should very rarely be to write the shortest amount of code. The 1 line solution typically uses a generalized algorithm, which may or may not be useful for what you wish to do. The problem forces ListNode as a guide to push in the direction it wants. Most of the solutions, although using ListNode, ignore this guide as the question very clearly wants a solution that does not create new memory as LinkedLists do not require such a complex operation for insertion. Ultimately, the point is (and why this is a hard problem and not a medium one like others have suggested) to do mergeKLists in O(1) space. The one line of Python most-likely does allocate new memory somewhere. If your customer pays for the amount of ram they use from a cloud service, they would be most pleased if you would keep that cost low."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Ok, @cartesPerforees, then explain why do we need ListNode if we can do this problem way easier without it. The goal is to make the solution with the shortest possible code. In this case 1 line, not 50. Imagine a customer wants you to make this problem: Merge K Sorted Lists. He doesn\\'t say how you need to do it, He just says to do it on python3. How would you do it? Would you write 50 lines of code using ListNode or one line of code. Please read and reply and we can discuss this later."
                    },
                    {
                        "username": "user5331Az",
                        "content": "bravo! dude, the task is for the ones familiar with algorithmic complexity concept at least, definitely not for you."
                    },
                    {
                        "username": "squigity",
                        "content": "[@mikael6767](/mikael6767)  Concept of linked lists is for a different scenario ,  the question here is to know if we understand linked lists or not and not to merge a sorted list from a list of lists"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your comment puzzles me. The whole point of those problems is to give you something to solve, and make it somewhat of a challenge depending on the difficulty tag. Most of the problems on leetcode are artificial and of no practical use, they are just made to help you practise probem solving.\\nI don\\'t get why you complain that they\\'re making things harder for you. That\\'s the point. It\\'s like playing with one of those chinese/japanes wooden brain teasers and  complaining that they should have designed it so that it opens like a normal box."
                    },
                    {
                        "username": "mikael6767",
                        "content": "I realize this. I am programming on python3 and really know that it really is one line of code, but the problem is with ListNode. There are a lot LeetCode problems with ListNode and I can\\'t make them even if they are very easy without it. I have the same problem. I wrote that one line of code and it says it is not right. I would really like for someone to help you, but I\\'m sorry I can\\'t."
                    },
                    {
                        "username": "David_E_something",
                        "content": "If you somehow use a priority queue (heap), this problem becomes very easy."
                    },
                    {
                        "username": "clinkz93",
                        "content": "[@layman806](/layman806) Using a priority queue results in a complexity of O((k + n) * log(k)) instead of O(n * log(n)), which may be preferrable."
                    },
                    {
                        "username": "root89",
                        "content": "[@layman806](/layman806) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@layman806](/layman806) lmao,, you can\\'t beat the interviewer."
                    },
                    {
                        "username": "layman806",
                        "content": "Or just parse all into an array in O(n) time, then sort it in O(n.log(n)) time and convert it to a linked list in O(n) time. This is just too easy to beat. Shouldn\\'t be tagged as hard."
                    },
                    {
                        "username": "JaviOverflow",
                        "content": "When I submit my solution, it fails on the input `[[]]`, how is that input even posible? `ListNode` requires `val` as argument in its constructor. Returning `None` doesn\\'t make the test pass. I\\'m not sure how to tackle that."
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "thenimator",
                        "content": "It\\'s been a while since you had this problem but for anyone else running into it:\\n\\n[[]] simply stands for an array with 1 element with that one element being a null pointer (which in this context stands for an empty linked list and not one where the value of the first element is missing)"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, WTF? ![image](https://assets.leetcode.com/users/beatrizdos/image_1570843047.png)\\n"
                    },
                    {
                        "username": "Will-O-Wisp",
                        "content": "class ListNode(object):\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\n\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        def mergeTwoLists(l1, l2):\\n            dummy = ListNode(0)\\n            current = dummy\\n\\n            while l1 and l2:\\n                if l1.val < l2.val:\\n                    current.next = l1\\n                    l1 = l1.next\\n                else:\\n                    current.next = l2\\n                    l2 = l2.next\\n                current = current.next\\n\\n            current.next = l1 if l1 else l2\\n\\n            return dummy.next\\n\\n        if not lists:\\n            return None\\n\\n        while len(lists) > 1:\\n            merged_lists = []\\n\\n            for i in range(0, len(lists), 2):\\n                l1 = lists[i]\\n                l2 = lists[i + 1] if i + 1 < len(lists) else None\\n                merged_lists.append(mergeTwoLists(l1, l2))\\n\\n            lists = merged_lists\\n\\n        return lists[0] if lists else None\\n\\n\\n# Example usage\\nlists = [\\n    ListNode(1, ListNode(4, ListNode(5))),\\n    ListNode(1, ListNode(3, ListNode(4))),\\n    ListNode(2, ListNode(6))\\n]\\n\\nsolution = Solution()\\nresult = solution.mergeKLists(lists)\\nwhile result:\\n    print(result.val)\\n    result = result.next\\n"
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "qin4",
                        "content": "Util class ListNode in python 3 is not completed. It can\\'t do heapq directly. Fix is easier on server side."
                    }
                ]
            },
            {
                "id": 1569749,
                "content": [
                    {
                        "username": "adambene",
                        "content": "This problem should not be marked as hard.\\nMedium is more proper based on the other problems on leetcode."
                    },
                    {
                        "username": "Pranjal_Bajpai",
                        "content": "i would say easy, its no brainer !"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cwooldridge](/cwooldridge)  POV: you solved your first HARD problem. "
                    },
                    {
                        "username": "jason3410",
                        "content": "[@Mister_CK](/Mister_CK) Cuz your solution make no connection with the ListNodes. And u won\\'t learn anything on this question."
                    },
                    {
                        "username": "user5331Az",
                        "content": "[@Mister_CK](/Mister_CK) putting an element into sorted array is O(log2(n)), sorting of an array is O(n^2) generally."
                    },
                    {
                        "username": "dhunmoon",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "[@cwooldridge](/cwooldridge) I almost started to think that i\\'m a hard problem solver and then I came here"
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Hey man, cmon, let me enjoy this moment\\uD83D\\uDE02"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It should be Easy imo. At least in JS there is no need to use a priority queue. You can just put all the values in an array, sort that array and put them in a list you then return. runs in 79 ms, beats 97% of solutions and it's the same answer as for the Easy problem `21. Merge Two Sorted Lists` (albeit that this is an array of lists, rather than just two, but it's the exact same principle). I really don't understand why this is marked with Hard and Priority Queue, really threw me off. I wrote a whole solution with a priority queue for an hour, only to realise it was completely unnecessary and I wrote a faster algorithm without it in 5 minutes. ([@joseph261059](/joseph261059) I tried using that, but I got an error on the node version (I believe it couldn't find insert), so I copied an implementation of a PriorityQueue using heap from stackoverflow) (PS: I checked, in regular Java it runs in 8 ms (beating only 28% of solutions), but that is still well within the accepted solution range.)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "[@Husoski](/Husoski) In JS, we can use PriorityQueue package in leetcode"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Well this still is hard problem as if go optimize your time complexity the solutions becomes more and more complex!"
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@Husoski](/Husoski) Indeed, but nobody uses programming languages like C in competitive programming. The most popular languages are C++, Java and Python. If there is no standard library with basic data structures like a `vector` or a `heap` in the programming language of your choice, you might want to use another language for the purpose of solving leetcode questions."
                    },
                    {
                        "username": "Husoski",
                        "content": "That depends on the language you used.  In a language with a standard heap or priority queue data structure this is indeed on the easy side of Medium.  I think it\\'s more like Hard in a language like C or JS.  (Assuming, of course, that the solver is going write the minheap code and not copy-paste it! :^)"
                    },
                    {
                        "username": "viocost",
                        "content": "The problem is interesting, but why there are test cases such as [[], []] \\nand not a word about possible inputs expected output?\\n\\nIs it also a telepathy exercise?\\n"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Very annoying; they don\\'t seem to mention how the output is parsed; the result needs to be a ListNode or null.\\nFilter the list then go from there."
                    },
                    {
                        "username": "alistar",
                        "content": "With empty list it seems to expect an empty list as an output, however, it doest not accept it with type-error.\\nLitterally copied and pasted one of the official solutions, it doesn\\'t go through with the same issue!"
                    },
                    {
                        "username": "user9118TR",
                        "content": "[@amithshetty](/amithshetty)  Thaks a lot, how did you know it ??"
                    },
                    {
                        "username": "sony541",
                        "content": "[@amithshetty](/amithshetty) Well, if \"None\" is the end of list, you can think of \"None\" as an empty linked list, nice callout here... It took me a while to figure out, but sounds reasonable after all.. Could\\'ve been clarified in promt though."
                    },
                    {
                        "username": "amithshetty",
                        "content": "IT expects None, i.e not a list but an empty linked list"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-k-sorted-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Compare one by one\n\n  \n**Approach 3:** Optimize Approach 2 by Priority Queue\n\n  \n**Approach 4:** Merge lists one by one\n\n  \n**Approach 5:** Merge with Divide And Conquer\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Kouei",
                        "content": "The fastest C++ code can achieve a time about 370ms ~ 380ms\\n\\nwhile Python code can achieve 100ms, and even amazing, JAVA can do it in just 4ms !\\n\\nThis result is quite counterintuitive."
                    },
                    {
                        "username": "321maayan",
                        "content": "python is build in c and c is powerful as c++\\n"
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "[@Normalitee0os](/Normalitee0os)  post the code lol"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Mine took 15 ms using C++"
                    },
                    {
                        "username": "Normalitee0os",
                        "content": "Mine took 0.1 ms using HTML."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Mine took 23ms in C++"
                    },
                    {
                        "username": "slashtab",
                        "content": "OJ of LeetCode isn\\'t that perfect."
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "mine 22ms with c++; "
                    },
                    {
                        "username": "charonme",
                        "content": "35ms in PHP without using any built-in functions except count"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "mine was 40ms in c++, which could be further optimized"
                    },
                    {
                        "username": "f1rumors",
                        "content": "underlying libraries are a boon"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python...\\n\\nI assume that everyone realizes that without using ListNode that the solution to this problem is one line of code. Flatten the lists to one list and sort the list. \\n\\nWhy are there so many problems that have to be answered using ListNodes? It\\'s a complete waste of time in a language such as python. Shouldn\\'t the simplest solution be the best solution? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of `ListNode` or linked lists in algorithmic problems isn\\'t necessarily about finding the most efficient solution in Python or any specific language. Rather, it\\'s about teaching or testing certain concepts. Here are a few reasons:\\n\\n1. **Conceptual Understanding**: Using `ListNode` often helps in understanding how to manually manipulate pointers and nodes, which is crucial for a deep understanding of data structures.\\n\\n2. **Language Agnostic**: These problems are designed to be language-agnostic. While Python has easy list manipulation, languages like C or C++ do not have such built-in capabilities. The problem is set to be fair to everyone, regardless of the programming language used.\\n\\n3. **Algorithm Complexity**: Some problems require an in-depth understanding of algorithm complexity. Using built-in functions like `sort` can sometimes give a false sense of simplicity when, in fact, the actual task of merging the lists might be more complex.\\n\\n4. **Resource Utilization**: In some cases, especially in embedded systems or other resource-constrained environments, understanding how to work with nodes and pointers is essential for efficient memory usage.\\n\\n5. **Skill Assessment**: These problems are often used in interviews to assess understanding of fundamental computer science concepts, beyond syntactic sugar provided by specific programming languages.\\n\\n6. **Real-world Use Cases**: Not all data comes in simple, sorted, array-like structures. Linked lists, trees, and graphs are data structures commonly used in real-world applications. Understanding them is key to being a well-rounded developer.\\n\\n7. **Optimal Substructure**: Problems that mandate the use of data structures like linked lists often involve an optimal substructure that makes for an elegant solution, thereby teaching you problem-solving patterns that can be applied elsewhere.\\n\\n8. **Consistency**: If a problem was initially posed in a computer science paper or textbook using `ListNodes`, it\\'s often kept that way to maintain consistency with classic algorithm and data structure literature.\\n\\nSo while it may seem unnecessary or verbose, using `ListNode` provides a broader educational benefit, ensuring that you understand both high-level language features and low-level data structure manipulation."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go tell it on an interview :)"
                    },
                    {
                        "username": "Vantrashell",
                        "content": "[@mikael6767](/mikael6767) The goal should very rarely be to write the shortest amount of code. The 1 line solution typically uses a generalized algorithm, which may or may not be useful for what you wish to do. The problem forces ListNode as a guide to push in the direction it wants. Most of the solutions, although using ListNode, ignore this guide as the question very clearly wants a solution that does not create new memory as LinkedLists do not require such a complex operation for insertion. Ultimately, the point is (and why this is a hard problem and not a medium one like others have suggested) to do mergeKLists in O(1) space. The one line of Python most-likely does allocate new memory somewhere. If your customer pays for the amount of ram they use from a cloud service, they would be most pleased if you would keep that cost low."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Ok, @cartesPerforees, then explain why do we need ListNode if we can do this problem way easier without it. The goal is to make the solution with the shortest possible code. In this case 1 line, not 50. Imagine a customer wants you to make this problem: Merge K Sorted Lists. He doesn\\'t say how you need to do it, He just says to do it on python3. How would you do it? Would you write 50 lines of code using ListNode or one line of code. Please read and reply and we can discuss this later."
                    },
                    {
                        "username": "user5331Az",
                        "content": "bravo! dude, the task is for the ones familiar with algorithmic complexity concept at least, definitely not for you."
                    },
                    {
                        "username": "squigity",
                        "content": "[@mikael6767](/mikael6767)  Concept of linked lists is for a different scenario ,  the question here is to know if we understand linked lists or not and not to merge a sorted list from a list of lists"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your comment puzzles me. The whole point of those problems is to give you something to solve, and make it somewhat of a challenge depending on the difficulty tag. Most of the problems on leetcode are artificial and of no practical use, they are just made to help you practise probem solving.\\nI don\\'t get why you complain that they\\'re making things harder for you. That\\'s the point. It\\'s like playing with one of those chinese/japanes wooden brain teasers and  complaining that they should have designed it so that it opens like a normal box."
                    },
                    {
                        "username": "mikael6767",
                        "content": "I realize this. I am programming on python3 and really know that it really is one line of code, but the problem is with ListNode. There are a lot LeetCode problems with ListNode and I can\\'t make them even if they are very easy without it. I have the same problem. I wrote that one line of code and it says it is not right. I would really like for someone to help you, but I\\'m sorry I can\\'t."
                    },
                    {
                        "username": "David_E_something",
                        "content": "If you somehow use a priority queue (heap), this problem becomes very easy."
                    },
                    {
                        "username": "clinkz93",
                        "content": "[@layman806](/layman806) Using a priority queue results in a complexity of O((k + n) * log(k)) instead of O(n * log(n)), which may be preferrable."
                    },
                    {
                        "username": "root89",
                        "content": "[@layman806](/layman806) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@layman806](/layman806) lmao,, you can\\'t beat the interviewer."
                    },
                    {
                        "username": "layman806",
                        "content": "Or just parse all into an array in O(n) time, then sort it in O(n.log(n)) time and convert it to a linked list in O(n) time. This is just too easy to beat. Shouldn\\'t be tagged as hard."
                    },
                    {
                        "username": "JaviOverflow",
                        "content": "When I submit my solution, it fails on the input `[[]]`, how is that input even posible? `ListNode` requires `val` as argument in its constructor. Returning `None` doesn\\'t make the test pass. I\\'m not sure how to tackle that."
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "thenimator",
                        "content": "It\\'s been a while since you had this problem but for anyone else running into it:\\n\\n[[]] simply stands for an array with 1 element with that one element being a null pointer (which in this context stands for an empty linked list and not one where the value of the first element is missing)"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, WTF? ![image](https://assets.leetcode.com/users/beatrizdos/image_1570843047.png)\\n"
                    },
                    {
                        "username": "Will-O-Wisp",
                        "content": "class ListNode(object):\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\n\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        def mergeTwoLists(l1, l2):\\n            dummy = ListNode(0)\\n            current = dummy\\n\\n            while l1 and l2:\\n                if l1.val < l2.val:\\n                    current.next = l1\\n                    l1 = l1.next\\n                else:\\n                    current.next = l2\\n                    l2 = l2.next\\n                current = current.next\\n\\n            current.next = l1 if l1 else l2\\n\\n            return dummy.next\\n\\n        if not lists:\\n            return None\\n\\n        while len(lists) > 1:\\n            merged_lists = []\\n\\n            for i in range(0, len(lists), 2):\\n                l1 = lists[i]\\n                l2 = lists[i + 1] if i + 1 < len(lists) else None\\n                merged_lists.append(mergeTwoLists(l1, l2))\\n\\n            lists = merged_lists\\n\\n        return lists[0] if lists else None\\n\\n\\n# Example usage\\nlists = [\\n    ListNode(1, ListNode(4, ListNode(5))),\\n    ListNode(1, ListNode(3, ListNode(4))),\\n    ListNode(2, ListNode(6))\\n]\\n\\nsolution = Solution()\\nresult = solution.mergeKLists(lists)\\nwhile result:\\n    print(result.val)\\n    result = result.next\\n"
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "qin4",
                        "content": "Util class ListNode in python 3 is not completed. It can\\'t do heapq directly. Fix is easier on server side."
                    }
                ]
            },
            {
                "id": 1569647,
                "content": [
                    {
                        "username": "adambene",
                        "content": "This problem should not be marked as hard.\\nMedium is more proper based on the other problems on leetcode."
                    },
                    {
                        "username": "Pranjal_Bajpai",
                        "content": "i would say easy, its no brainer !"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cwooldridge](/cwooldridge)  POV: you solved your first HARD problem. "
                    },
                    {
                        "username": "jason3410",
                        "content": "[@Mister_CK](/Mister_CK) Cuz your solution make no connection with the ListNodes. And u won\\'t learn anything on this question."
                    },
                    {
                        "username": "user5331Az",
                        "content": "[@Mister_CK](/Mister_CK) putting an element into sorted array is O(log2(n)), sorting of an array is O(n^2) generally."
                    },
                    {
                        "username": "dhunmoon",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "[@cwooldridge](/cwooldridge) I almost started to think that i\\'m a hard problem solver and then I came here"
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Hey man, cmon, let me enjoy this moment\\uD83D\\uDE02"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It should be Easy imo. At least in JS there is no need to use a priority queue. You can just put all the values in an array, sort that array and put them in a list you then return. runs in 79 ms, beats 97% of solutions and it's the same answer as for the Easy problem `21. Merge Two Sorted Lists` (albeit that this is an array of lists, rather than just two, but it's the exact same principle). I really don't understand why this is marked with Hard and Priority Queue, really threw me off. I wrote a whole solution with a priority queue for an hour, only to realise it was completely unnecessary and I wrote a faster algorithm without it in 5 minutes. ([@joseph261059](/joseph261059) I tried using that, but I got an error on the node version (I believe it couldn't find insert), so I copied an implementation of a PriorityQueue using heap from stackoverflow) (PS: I checked, in regular Java it runs in 8 ms (beating only 28% of solutions), but that is still well within the accepted solution range.)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "[@Husoski](/Husoski) In JS, we can use PriorityQueue package in leetcode"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Well this still is hard problem as if go optimize your time complexity the solutions becomes more and more complex!"
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@Husoski](/Husoski) Indeed, but nobody uses programming languages like C in competitive programming. The most popular languages are C++, Java and Python. If there is no standard library with basic data structures like a `vector` or a `heap` in the programming language of your choice, you might want to use another language for the purpose of solving leetcode questions."
                    },
                    {
                        "username": "Husoski",
                        "content": "That depends on the language you used.  In a language with a standard heap or priority queue data structure this is indeed on the easy side of Medium.  I think it\\'s more like Hard in a language like C or JS.  (Assuming, of course, that the solver is going write the minheap code and not copy-paste it! :^)"
                    },
                    {
                        "username": "viocost",
                        "content": "The problem is interesting, but why there are test cases such as [[], []] \\nand not a word about possible inputs expected output?\\n\\nIs it also a telepathy exercise?\\n"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Very annoying; they don\\'t seem to mention how the output is parsed; the result needs to be a ListNode or null.\\nFilter the list then go from there."
                    },
                    {
                        "username": "alistar",
                        "content": "With empty list it seems to expect an empty list as an output, however, it doest not accept it with type-error.\\nLitterally copied and pasted one of the official solutions, it doesn\\'t go through with the same issue!"
                    },
                    {
                        "username": "user9118TR",
                        "content": "[@amithshetty](/amithshetty)  Thaks a lot, how did you know it ??"
                    },
                    {
                        "username": "sony541",
                        "content": "[@amithshetty](/amithshetty) Well, if \"None\" is the end of list, you can think of \"None\" as an empty linked list, nice callout here... It took me a while to figure out, but sounds reasonable after all.. Could\\'ve been clarified in promt though."
                    },
                    {
                        "username": "amithshetty",
                        "content": "IT expects None, i.e not a list but an empty linked list"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-k-sorted-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Compare one by one\n\n  \n**Approach 3:** Optimize Approach 2 by Priority Queue\n\n  \n**Approach 4:** Merge lists one by one\n\n  \n**Approach 5:** Merge with Divide And Conquer\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Kouei",
                        "content": "The fastest C++ code can achieve a time about 370ms ~ 380ms\\n\\nwhile Python code can achieve 100ms, and even amazing, JAVA can do it in just 4ms !\\n\\nThis result is quite counterintuitive."
                    },
                    {
                        "username": "321maayan",
                        "content": "python is build in c and c is powerful as c++\\n"
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "[@Normalitee0os](/Normalitee0os)  post the code lol"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Mine took 15 ms using C++"
                    },
                    {
                        "username": "Normalitee0os",
                        "content": "Mine took 0.1 ms using HTML."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Mine took 23ms in C++"
                    },
                    {
                        "username": "slashtab",
                        "content": "OJ of LeetCode isn\\'t that perfect."
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "mine 22ms with c++; "
                    },
                    {
                        "username": "charonme",
                        "content": "35ms in PHP without using any built-in functions except count"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "mine was 40ms in c++, which could be further optimized"
                    },
                    {
                        "username": "f1rumors",
                        "content": "underlying libraries are a boon"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python...\\n\\nI assume that everyone realizes that without using ListNode that the solution to this problem is one line of code. Flatten the lists to one list and sort the list. \\n\\nWhy are there so many problems that have to be answered using ListNodes? It\\'s a complete waste of time in a language such as python. Shouldn\\'t the simplest solution be the best solution? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of `ListNode` or linked lists in algorithmic problems isn\\'t necessarily about finding the most efficient solution in Python or any specific language. Rather, it\\'s about teaching or testing certain concepts. Here are a few reasons:\\n\\n1. **Conceptual Understanding**: Using `ListNode` often helps in understanding how to manually manipulate pointers and nodes, which is crucial for a deep understanding of data structures.\\n\\n2. **Language Agnostic**: These problems are designed to be language-agnostic. While Python has easy list manipulation, languages like C or C++ do not have such built-in capabilities. The problem is set to be fair to everyone, regardless of the programming language used.\\n\\n3. **Algorithm Complexity**: Some problems require an in-depth understanding of algorithm complexity. Using built-in functions like `sort` can sometimes give a false sense of simplicity when, in fact, the actual task of merging the lists might be more complex.\\n\\n4. **Resource Utilization**: In some cases, especially in embedded systems or other resource-constrained environments, understanding how to work with nodes and pointers is essential for efficient memory usage.\\n\\n5. **Skill Assessment**: These problems are often used in interviews to assess understanding of fundamental computer science concepts, beyond syntactic sugar provided by specific programming languages.\\n\\n6. **Real-world Use Cases**: Not all data comes in simple, sorted, array-like structures. Linked lists, trees, and graphs are data structures commonly used in real-world applications. Understanding them is key to being a well-rounded developer.\\n\\n7. **Optimal Substructure**: Problems that mandate the use of data structures like linked lists often involve an optimal substructure that makes for an elegant solution, thereby teaching you problem-solving patterns that can be applied elsewhere.\\n\\n8. **Consistency**: If a problem was initially posed in a computer science paper or textbook using `ListNodes`, it\\'s often kept that way to maintain consistency with classic algorithm and data structure literature.\\n\\nSo while it may seem unnecessary or verbose, using `ListNode` provides a broader educational benefit, ensuring that you understand both high-level language features and low-level data structure manipulation."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go tell it on an interview :)"
                    },
                    {
                        "username": "Vantrashell",
                        "content": "[@mikael6767](/mikael6767) The goal should very rarely be to write the shortest amount of code. The 1 line solution typically uses a generalized algorithm, which may or may not be useful for what you wish to do. The problem forces ListNode as a guide to push in the direction it wants. Most of the solutions, although using ListNode, ignore this guide as the question very clearly wants a solution that does not create new memory as LinkedLists do not require such a complex operation for insertion. Ultimately, the point is (and why this is a hard problem and not a medium one like others have suggested) to do mergeKLists in O(1) space. The one line of Python most-likely does allocate new memory somewhere. If your customer pays for the amount of ram they use from a cloud service, they would be most pleased if you would keep that cost low."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Ok, @cartesPerforees, then explain why do we need ListNode if we can do this problem way easier without it. The goal is to make the solution with the shortest possible code. In this case 1 line, not 50. Imagine a customer wants you to make this problem: Merge K Sorted Lists. He doesn\\'t say how you need to do it, He just says to do it on python3. How would you do it? Would you write 50 lines of code using ListNode or one line of code. Please read and reply and we can discuss this later."
                    },
                    {
                        "username": "user5331Az",
                        "content": "bravo! dude, the task is for the ones familiar with algorithmic complexity concept at least, definitely not for you."
                    },
                    {
                        "username": "squigity",
                        "content": "[@mikael6767](/mikael6767)  Concept of linked lists is for a different scenario ,  the question here is to know if we understand linked lists or not and not to merge a sorted list from a list of lists"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your comment puzzles me. The whole point of those problems is to give you something to solve, and make it somewhat of a challenge depending on the difficulty tag. Most of the problems on leetcode are artificial and of no practical use, they are just made to help you practise probem solving.\\nI don\\'t get why you complain that they\\'re making things harder for you. That\\'s the point. It\\'s like playing with one of those chinese/japanes wooden brain teasers and  complaining that they should have designed it so that it opens like a normal box."
                    },
                    {
                        "username": "mikael6767",
                        "content": "I realize this. I am programming on python3 and really know that it really is one line of code, but the problem is with ListNode. There are a lot LeetCode problems with ListNode and I can\\'t make them even if they are very easy without it. I have the same problem. I wrote that one line of code and it says it is not right. I would really like for someone to help you, but I\\'m sorry I can\\'t."
                    },
                    {
                        "username": "David_E_something",
                        "content": "If you somehow use a priority queue (heap), this problem becomes very easy."
                    },
                    {
                        "username": "clinkz93",
                        "content": "[@layman806](/layman806) Using a priority queue results in a complexity of O((k + n) * log(k)) instead of O(n * log(n)), which may be preferrable."
                    },
                    {
                        "username": "root89",
                        "content": "[@layman806](/layman806) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@layman806](/layman806) lmao,, you can\\'t beat the interviewer."
                    },
                    {
                        "username": "layman806",
                        "content": "Or just parse all into an array in O(n) time, then sort it in O(n.log(n)) time and convert it to a linked list in O(n) time. This is just too easy to beat. Shouldn\\'t be tagged as hard."
                    },
                    {
                        "username": "JaviOverflow",
                        "content": "When I submit my solution, it fails on the input `[[]]`, how is that input even posible? `ListNode` requires `val` as argument in its constructor. Returning `None` doesn\\'t make the test pass. I\\'m not sure how to tackle that."
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "thenimator",
                        "content": "It\\'s been a while since you had this problem but for anyone else running into it:\\n\\n[[]] simply stands for an array with 1 element with that one element being a null pointer (which in this context stands for an empty linked list and not one where the value of the first element is missing)"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, WTF? ![image](https://assets.leetcode.com/users/beatrizdos/image_1570843047.png)\\n"
                    },
                    {
                        "username": "Will-O-Wisp",
                        "content": "class ListNode(object):\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\n\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        def mergeTwoLists(l1, l2):\\n            dummy = ListNode(0)\\n            current = dummy\\n\\n            while l1 and l2:\\n                if l1.val < l2.val:\\n                    current.next = l1\\n                    l1 = l1.next\\n                else:\\n                    current.next = l2\\n                    l2 = l2.next\\n                current = current.next\\n\\n            current.next = l1 if l1 else l2\\n\\n            return dummy.next\\n\\n        if not lists:\\n            return None\\n\\n        while len(lists) > 1:\\n            merged_lists = []\\n\\n            for i in range(0, len(lists), 2):\\n                l1 = lists[i]\\n                l2 = lists[i + 1] if i + 1 < len(lists) else None\\n                merged_lists.append(mergeTwoLists(l1, l2))\\n\\n            lists = merged_lists\\n\\n        return lists[0] if lists else None\\n\\n\\n# Example usage\\nlists = [\\n    ListNode(1, ListNode(4, ListNode(5))),\\n    ListNode(1, ListNode(3, ListNode(4))),\\n    ListNode(2, ListNode(6))\\n]\\n\\nsolution = Solution()\\nresult = solution.mergeKLists(lists)\\nwhile result:\\n    print(result.val)\\n    result = result.next\\n"
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "qin4",
                        "content": "Util class ListNode in python 3 is not completed. It can\\'t do heapq directly. Fix is easier on server side."
                    }
                ]
            },
            {
                "id": 1568012,
                "content": [
                    {
                        "username": "adambene",
                        "content": "This problem should not be marked as hard.\\nMedium is more proper based on the other problems on leetcode."
                    },
                    {
                        "username": "Pranjal_Bajpai",
                        "content": "i would say easy, its no brainer !"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cwooldridge](/cwooldridge)  POV: you solved your first HARD problem. "
                    },
                    {
                        "username": "jason3410",
                        "content": "[@Mister_CK](/Mister_CK) Cuz your solution make no connection with the ListNodes. And u won\\'t learn anything on this question."
                    },
                    {
                        "username": "user5331Az",
                        "content": "[@Mister_CK](/Mister_CK) putting an element into sorted array is O(log2(n)), sorting of an array is O(n^2) generally."
                    },
                    {
                        "username": "dhunmoon",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "[@cwooldridge](/cwooldridge) I almost started to think that i\\'m a hard problem solver and then I came here"
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Hey man, cmon, let me enjoy this moment\\uD83D\\uDE02"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It should be Easy imo. At least in JS there is no need to use a priority queue. You can just put all the values in an array, sort that array and put them in a list you then return. runs in 79 ms, beats 97% of solutions and it's the same answer as for the Easy problem `21. Merge Two Sorted Lists` (albeit that this is an array of lists, rather than just two, but it's the exact same principle). I really don't understand why this is marked with Hard and Priority Queue, really threw me off. I wrote a whole solution with a priority queue for an hour, only to realise it was completely unnecessary and I wrote a faster algorithm without it in 5 minutes. ([@joseph261059](/joseph261059) I tried using that, but I got an error on the node version (I believe it couldn't find insert), so I copied an implementation of a PriorityQueue using heap from stackoverflow) (PS: I checked, in regular Java it runs in 8 ms (beating only 28% of solutions), but that is still well within the accepted solution range.)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "[@Husoski](/Husoski) In JS, we can use PriorityQueue package in leetcode"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Well this still is hard problem as if go optimize your time complexity the solutions becomes more and more complex!"
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@Husoski](/Husoski) Indeed, but nobody uses programming languages like C in competitive programming. The most popular languages are C++, Java and Python. If there is no standard library with basic data structures like a `vector` or a `heap` in the programming language of your choice, you might want to use another language for the purpose of solving leetcode questions."
                    },
                    {
                        "username": "Husoski",
                        "content": "That depends on the language you used.  In a language with a standard heap or priority queue data structure this is indeed on the easy side of Medium.  I think it\\'s more like Hard in a language like C or JS.  (Assuming, of course, that the solver is going write the minheap code and not copy-paste it! :^)"
                    },
                    {
                        "username": "viocost",
                        "content": "The problem is interesting, but why there are test cases such as [[], []] \\nand not a word about possible inputs expected output?\\n\\nIs it also a telepathy exercise?\\n"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Very annoying; they don\\'t seem to mention how the output is parsed; the result needs to be a ListNode or null.\\nFilter the list then go from there."
                    },
                    {
                        "username": "alistar",
                        "content": "With empty list it seems to expect an empty list as an output, however, it doest not accept it with type-error.\\nLitterally copied and pasted one of the official solutions, it doesn\\'t go through with the same issue!"
                    },
                    {
                        "username": "user9118TR",
                        "content": "[@amithshetty](/amithshetty)  Thaks a lot, how did you know it ??"
                    },
                    {
                        "username": "sony541",
                        "content": "[@amithshetty](/amithshetty) Well, if \"None\" is the end of list, you can think of \"None\" as an empty linked list, nice callout here... It took me a while to figure out, but sounds reasonable after all.. Could\\'ve been clarified in promt though."
                    },
                    {
                        "username": "amithshetty",
                        "content": "IT expects None, i.e not a list but an empty linked list"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-k-sorted-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Compare one by one\n\n  \n**Approach 3:** Optimize Approach 2 by Priority Queue\n\n  \n**Approach 4:** Merge lists one by one\n\n  \n**Approach 5:** Merge with Divide And Conquer\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Kouei",
                        "content": "The fastest C++ code can achieve a time about 370ms ~ 380ms\\n\\nwhile Python code can achieve 100ms, and even amazing, JAVA can do it in just 4ms !\\n\\nThis result is quite counterintuitive."
                    },
                    {
                        "username": "321maayan",
                        "content": "python is build in c and c is powerful as c++\\n"
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "[@Normalitee0os](/Normalitee0os)  post the code lol"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Mine took 15 ms using C++"
                    },
                    {
                        "username": "Normalitee0os",
                        "content": "Mine took 0.1 ms using HTML."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Mine took 23ms in C++"
                    },
                    {
                        "username": "slashtab",
                        "content": "OJ of LeetCode isn\\'t that perfect."
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "mine 22ms with c++; "
                    },
                    {
                        "username": "charonme",
                        "content": "35ms in PHP without using any built-in functions except count"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "mine was 40ms in c++, which could be further optimized"
                    },
                    {
                        "username": "f1rumors",
                        "content": "underlying libraries are a boon"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python...\\n\\nI assume that everyone realizes that without using ListNode that the solution to this problem is one line of code. Flatten the lists to one list and sort the list. \\n\\nWhy are there so many problems that have to be answered using ListNodes? It\\'s a complete waste of time in a language such as python. Shouldn\\'t the simplest solution be the best solution? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of `ListNode` or linked lists in algorithmic problems isn\\'t necessarily about finding the most efficient solution in Python or any specific language. Rather, it\\'s about teaching or testing certain concepts. Here are a few reasons:\\n\\n1. **Conceptual Understanding**: Using `ListNode` often helps in understanding how to manually manipulate pointers and nodes, which is crucial for a deep understanding of data structures.\\n\\n2. **Language Agnostic**: These problems are designed to be language-agnostic. While Python has easy list manipulation, languages like C or C++ do not have such built-in capabilities. The problem is set to be fair to everyone, regardless of the programming language used.\\n\\n3. **Algorithm Complexity**: Some problems require an in-depth understanding of algorithm complexity. Using built-in functions like `sort` can sometimes give a false sense of simplicity when, in fact, the actual task of merging the lists might be more complex.\\n\\n4. **Resource Utilization**: In some cases, especially in embedded systems or other resource-constrained environments, understanding how to work with nodes and pointers is essential for efficient memory usage.\\n\\n5. **Skill Assessment**: These problems are often used in interviews to assess understanding of fundamental computer science concepts, beyond syntactic sugar provided by specific programming languages.\\n\\n6. **Real-world Use Cases**: Not all data comes in simple, sorted, array-like structures. Linked lists, trees, and graphs are data structures commonly used in real-world applications. Understanding them is key to being a well-rounded developer.\\n\\n7. **Optimal Substructure**: Problems that mandate the use of data structures like linked lists often involve an optimal substructure that makes for an elegant solution, thereby teaching you problem-solving patterns that can be applied elsewhere.\\n\\n8. **Consistency**: If a problem was initially posed in a computer science paper or textbook using `ListNodes`, it\\'s often kept that way to maintain consistency with classic algorithm and data structure literature.\\n\\nSo while it may seem unnecessary or verbose, using `ListNode` provides a broader educational benefit, ensuring that you understand both high-level language features and low-level data structure manipulation."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go tell it on an interview :)"
                    },
                    {
                        "username": "Vantrashell",
                        "content": "[@mikael6767](/mikael6767) The goal should very rarely be to write the shortest amount of code. The 1 line solution typically uses a generalized algorithm, which may or may not be useful for what you wish to do. The problem forces ListNode as a guide to push in the direction it wants. Most of the solutions, although using ListNode, ignore this guide as the question very clearly wants a solution that does not create new memory as LinkedLists do not require such a complex operation for insertion. Ultimately, the point is (and why this is a hard problem and not a medium one like others have suggested) to do mergeKLists in O(1) space. The one line of Python most-likely does allocate new memory somewhere. If your customer pays for the amount of ram they use from a cloud service, they would be most pleased if you would keep that cost low."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Ok, @cartesPerforees, then explain why do we need ListNode if we can do this problem way easier without it. The goal is to make the solution with the shortest possible code. In this case 1 line, not 50. Imagine a customer wants you to make this problem: Merge K Sorted Lists. He doesn\\'t say how you need to do it, He just says to do it on python3. How would you do it? Would you write 50 lines of code using ListNode or one line of code. Please read and reply and we can discuss this later."
                    },
                    {
                        "username": "user5331Az",
                        "content": "bravo! dude, the task is for the ones familiar with algorithmic complexity concept at least, definitely not for you."
                    },
                    {
                        "username": "squigity",
                        "content": "[@mikael6767](/mikael6767)  Concept of linked lists is for a different scenario ,  the question here is to know if we understand linked lists or not and not to merge a sorted list from a list of lists"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your comment puzzles me. The whole point of those problems is to give you something to solve, and make it somewhat of a challenge depending on the difficulty tag. Most of the problems on leetcode are artificial and of no practical use, they are just made to help you practise probem solving.\\nI don\\'t get why you complain that they\\'re making things harder for you. That\\'s the point. It\\'s like playing with one of those chinese/japanes wooden brain teasers and  complaining that they should have designed it so that it opens like a normal box."
                    },
                    {
                        "username": "mikael6767",
                        "content": "I realize this. I am programming on python3 and really know that it really is one line of code, but the problem is with ListNode. There are a lot LeetCode problems with ListNode and I can\\'t make them even if they are very easy without it. I have the same problem. I wrote that one line of code and it says it is not right. I would really like for someone to help you, but I\\'m sorry I can\\'t."
                    },
                    {
                        "username": "David_E_something",
                        "content": "If you somehow use a priority queue (heap), this problem becomes very easy."
                    },
                    {
                        "username": "clinkz93",
                        "content": "[@layman806](/layman806) Using a priority queue results in a complexity of O((k + n) * log(k)) instead of O(n * log(n)), which may be preferrable."
                    },
                    {
                        "username": "root89",
                        "content": "[@layman806](/layman806) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@layman806](/layman806) lmao,, you can\\'t beat the interviewer."
                    },
                    {
                        "username": "layman806",
                        "content": "Or just parse all into an array in O(n) time, then sort it in O(n.log(n)) time and convert it to a linked list in O(n) time. This is just too easy to beat. Shouldn\\'t be tagged as hard."
                    },
                    {
                        "username": "JaviOverflow",
                        "content": "When I submit my solution, it fails on the input `[[]]`, how is that input even posible? `ListNode` requires `val` as argument in its constructor. Returning `None` doesn\\'t make the test pass. I\\'m not sure how to tackle that."
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "thenimator",
                        "content": "It\\'s been a while since you had this problem but for anyone else running into it:\\n\\n[[]] simply stands for an array with 1 element with that one element being a null pointer (which in this context stands for an empty linked list and not one where the value of the first element is missing)"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, WTF? ![image](https://assets.leetcode.com/users/beatrizdos/image_1570843047.png)\\n"
                    },
                    {
                        "username": "Will-O-Wisp",
                        "content": "class ListNode(object):\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\n\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        def mergeTwoLists(l1, l2):\\n            dummy = ListNode(0)\\n            current = dummy\\n\\n            while l1 and l2:\\n                if l1.val < l2.val:\\n                    current.next = l1\\n                    l1 = l1.next\\n                else:\\n                    current.next = l2\\n                    l2 = l2.next\\n                current = current.next\\n\\n            current.next = l1 if l1 else l2\\n\\n            return dummy.next\\n\\n        if not lists:\\n            return None\\n\\n        while len(lists) > 1:\\n            merged_lists = []\\n\\n            for i in range(0, len(lists), 2):\\n                l1 = lists[i]\\n                l2 = lists[i + 1] if i + 1 < len(lists) else None\\n                merged_lists.append(mergeTwoLists(l1, l2))\\n\\n            lists = merged_lists\\n\\n        return lists[0] if lists else None\\n\\n\\n# Example usage\\nlists = [\\n    ListNode(1, ListNode(4, ListNode(5))),\\n    ListNode(1, ListNode(3, ListNode(4))),\\n    ListNode(2, ListNode(6))\\n]\\n\\nsolution = Solution()\\nresult = solution.mergeKLists(lists)\\nwhile result:\\n    print(result.val)\\n    result = result.next\\n"
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "qin4",
                        "content": "Util class ListNode in python 3 is not completed. It can\\'t do heapq directly. Fix is easier on server side."
                    }
                ]
            },
            {
                "id": 1572702,
                "content": [
                    {
                        "username": "adambene",
                        "content": "This problem should not be marked as hard.\\nMedium is more proper based on the other problems on leetcode."
                    },
                    {
                        "username": "Pranjal_Bajpai",
                        "content": "i would say easy, its no brainer !"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cwooldridge](/cwooldridge)  POV: you solved your first HARD problem. "
                    },
                    {
                        "username": "jason3410",
                        "content": "[@Mister_CK](/Mister_CK) Cuz your solution make no connection with the ListNodes. And u won\\'t learn anything on this question."
                    },
                    {
                        "username": "user5331Az",
                        "content": "[@Mister_CK](/Mister_CK) putting an element into sorted array is O(log2(n)), sorting of an array is O(n^2) generally."
                    },
                    {
                        "username": "dhunmoon",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "[@cwooldridge](/cwooldridge) I almost started to think that i\\'m a hard problem solver and then I came here"
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Hey man, cmon, let me enjoy this moment\\uD83D\\uDE02"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It should be Easy imo. At least in JS there is no need to use a priority queue. You can just put all the values in an array, sort that array and put them in a list you then return. runs in 79 ms, beats 97% of solutions and it's the same answer as for the Easy problem `21. Merge Two Sorted Lists` (albeit that this is an array of lists, rather than just two, but it's the exact same principle). I really don't understand why this is marked with Hard and Priority Queue, really threw me off. I wrote a whole solution with a priority queue for an hour, only to realise it was completely unnecessary and I wrote a faster algorithm without it in 5 minutes. ([@joseph261059](/joseph261059) I tried using that, but I got an error on the node version (I believe it couldn't find insert), so I copied an implementation of a PriorityQueue using heap from stackoverflow) (PS: I checked, in regular Java it runs in 8 ms (beating only 28% of solutions), but that is still well within the accepted solution range.)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "[@Husoski](/Husoski) In JS, we can use PriorityQueue package in leetcode"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Well this still is hard problem as if go optimize your time complexity the solutions becomes more and more complex!"
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@Husoski](/Husoski) Indeed, but nobody uses programming languages like C in competitive programming. The most popular languages are C++, Java and Python. If there is no standard library with basic data structures like a `vector` or a `heap` in the programming language of your choice, you might want to use another language for the purpose of solving leetcode questions."
                    },
                    {
                        "username": "Husoski",
                        "content": "That depends on the language you used.  In a language with a standard heap or priority queue data structure this is indeed on the easy side of Medium.  I think it\\'s more like Hard in a language like C or JS.  (Assuming, of course, that the solver is going write the minheap code and not copy-paste it! :^)"
                    },
                    {
                        "username": "viocost",
                        "content": "The problem is interesting, but why there are test cases such as [[], []] \\nand not a word about possible inputs expected output?\\n\\nIs it also a telepathy exercise?\\n"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Very annoying; they don\\'t seem to mention how the output is parsed; the result needs to be a ListNode or null.\\nFilter the list then go from there."
                    },
                    {
                        "username": "alistar",
                        "content": "With empty list it seems to expect an empty list as an output, however, it doest not accept it with type-error.\\nLitterally copied and pasted one of the official solutions, it doesn\\'t go through with the same issue!"
                    },
                    {
                        "username": "user9118TR",
                        "content": "[@amithshetty](/amithshetty)  Thaks a lot, how did you know it ??"
                    },
                    {
                        "username": "sony541",
                        "content": "[@amithshetty](/amithshetty) Well, if \"None\" is the end of list, you can think of \"None\" as an empty linked list, nice callout here... It took me a while to figure out, but sounds reasonable after all.. Could\\'ve been clarified in promt though."
                    },
                    {
                        "username": "amithshetty",
                        "content": "IT expects None, i.e not a list but an empty linked list"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-k-sorted-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Compare one by one\n\n  \n**Approach 3:** Optimize Approach 2 by Priority Queue\n\n  \n**Approach 4:** Merge lists one by one\n\n  \n**Approach 5:** Merge with Divide And Conquer\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Kouei",
                        "content": "The fastest C++ code can achieve a time about 370ms ~ 380ms\\n\\nwhile Python code can achieve 100ms, and even amazing, JAVA can do it in just 4ms !\\n\\nThis result is quite counterintuitive."
                    },
                    {
                        "username": "321maayan",
                        "content": "python is build in c and c is powerful as c++\\n"
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "[@Normalitee0os](/Normalitee0os)  post the code lol"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Mine took 15 ms using C++"
                    },
                    {
                        "username": "Normalitee0os",
                        "content": "Mine took 0.1 ms using HTML."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Mine took 23ms in C++"
                    },
                    {
                        "username": "slashtab",
                        "content": "OJ of LeetCode isn\\'t that perfect."
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "mine 22ms with c++; "
                    },
                    {
                        "username": "charonme",
                        "content": "35ms in PHP without using any built-in functions except count"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "mine was 40ms in c++, which could be further optimized"
                    },
                    {
                        "username": "f1rumors",
                        "content": "underlying libraries are a boon"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python...\\n\\nI assume that everyone realizes that without using ListNode that the solution to this problem is one line of code. Flatten the lists to one list and sort the list. \\n\\nWhy are there so many problems that have to be answered using ListNodes? It\\'s a complete waste of time in a language such as python. Shouldn\\'t the simplest solution be the best solution? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of `ListNode` or linked lists in algorithmic problems isn\\'t necessarily about finding the most efficient solution in Python or any specific language. Rather, it\\'s about teaching or testing certain concepts. Here are a few reasons:\\n\\n1. **Conceptual Understanding**: Using `ListNode` often helps in understanding how to manually manipulate pointers and nodes, which is crucial for a deep understanding of data structures.\\n\\n2. **Language Agnostic**: These problems are designed to be language-agnostic. While Python has easy list manipulation, languages like C or C++ do not have such built-in capabilities. The problem is set to be fair to everyone, regardless of the programming language used.\\n\\n3. **Algorithm Complexity**: Some problems require an in-depth understanding of algorithm complexity. Using built-in functions like `sort` can sometimes give a false sense of simplicity when, in fact, the actual task of merging the lists might be more complex.\\n\\n4. **Resource Utilization**: In some cases, especially in embedded systems or other resource-constrained environments, understanding how to work with nodes and pointers is essential for efficient memory usage.\\n\\n5. **Skill Assessment**: These problems are often used in interviews to assess understanding of fundamental computer science concepts, beyond syntactic sugar provided by specific programming languages.\\n\\n6. **Real-world Use Cases**: Not all data comes in simple, sorted, array-like structures. Linked lists, trees, and graphs are data structures commonly used in real-world applications. Understanding them is key to being a well-rounded developer.\\n\\n7. **Optimal Substructure**: Problems that mandate the use of data structures like linked lists often involve an optimal substructure that makes for an elegant solution, thereby teaching you problem-solving patterns that can be applied elsewhere.\\n\\n8. **Consistency**: If a problem was initially posed in a computer science paper or textbook using `ListNodes`, it\\'s often kept that way to maintain consistency with classic algorithm and data structure literature.\\n\\nSo while it may seem unnecessary or verbose, using `ListNode` provides a broader educational benefit, ensuring that you understand both high-level language features and low-level data structure manipulation."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go tell it on an interview :)"
                    },
                    {
                        "username": "Vantrashell",
                        "content": "[@mikael6767](/mikael6767) The goal should very rarely be to write the shortest amount of code. The 1 line solution typically uses a generalized algorithm, which may or may not be useful for what you wish to do. The problem forces ListNode as a guide to push in the direction it wants. Most of the solutions, although using ListNode, ignore this guide as the question very clearly wants a solution that does not create new memory as LinkedLists do not require such a complex operation for insertion. Ultimately, the point is (and why this is a hard problem and not a medium one like others have suggested) to do mergeKLists in O(1) space. The one line of Python most-likely does allocate new memory somewhere. If your customer pays for the amount of ram they use from a cloud service, they would be most pleased if you would keep that cost low."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Ok, @cartesPerforees, then explain why do we need ListNode if we can do this problem way easier without it. The goal is to make the solution with the shortest possible code. In this case 1 line, not 50. Imagine a customer wants you to make this problem: Merge K Sorted Lists. He doesn\\'t say how you need to do it, He just says to do it on python3. How would you do it? Would you write 50 lines of code using ListNode or one line of code. Please read and reply and we can discuss this later."
                    },
                    {
                        "username": "user5331Az",
                        "content": "bravo! dude, the task is for the ones familiar with algorithmic complexity concept at least, definitely not for you."
                    },
                    {
                        "username": "squigity",
                        "content": "[@mikael6767](/mikael6767)  Concept of linked lists is for a different scenario ,  the question here is to know if we understand linked lists or not and not to merge a sorted list from a list of lists"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your comment puzzles me. The whole point of those problems is to give you something to solve, and make it somewhat of a challenge depending on the difficulty tag. Most of the problems on leetcode are artificial and of no practical use, they are just made to help you practise probem solving.\\nI don\\'t get why you complain that they\\'re making things harder for you. That\\'s the point. It\\'s like playing with one of those chinese/japanes wooden brain teasers and  complaining that they should have designed it so that it opens like a normal box."
                    },
                    {
                        "username": "mikael6767",
                        "content": "I realize this. I am programming on python3 and really know that it really is one line of code, but the problem is with ListNode. There are a lot LeetCode problems with ListNode and I can\\'t make them even if they are very easy without it. I have the same problem. I wrote that one line of code and it says it is not right. I would really like for someone to help you, but I\\'m sorry I can\\'t."
                    },
                    {
                        "username": "David_E_something",
                        "content": "If you somehow use a priority queue (heap), this problem becomes very easy."
                    },
                    {
                        "username": "clinkz93",
                        "content": "[@layman806](/layman806) Using a priority queue results in a complexity of O((k + n) * log(k)) instead of O(n * log(n)), which may be preferrable."
                    },
                    {
                        "username": "root89",
                        "content": "[@layman806](/layman806) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@layman806](/layman806) lmao,, you can\\'t beat the interviewer."
                    },
                    {
                        "username": "layman806",
                        "content": "Or just parse all into an array in O(n) time, then sort it in O(n.log(n)) time and convert it to a linked list in O(n) time. This is just too easy to beat. Shouldn\\'t be tagged as hard."
                    },
                    {
                        "username": "JaviOverflow",
                        "content": "When I submit my solution, it fails on the input `[[]]`, how is that input even posible? `ListNode` requires `val` as argument in its constructor. Returning `None` doesn\\'t make the test pass. I\\'m not sure how to tackle that."
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "thenimator",
                        "content": "It\\'s been a while since you had this problem but for anyone else running into it:\\n\\n[[]] simply stands for an array with 1 element with that one element being a null pointer (which in this context stands for an empty linked list and not one where the value of the first element is missing)"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, WTF? ![image](https://assets.leetcode.com/users/beatrizdos/image_1570843047.png)\\n"
                    },
                    {
                        "username": "Will-O-Wisp",
                        "content": "class ListNode(object):\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\n\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        def mergeTwoLists(l1, l2):\\n            dummy = ListNode(0)\\n            current = dummy\\n\\n            while l1 and l2:\\n                if l1.val < l2.val:\\n                    current.next = l1\\n                    l1 = l1.next\\n                else:\\n                    current.next = l2\\n                    l2 = l2.next\\n                current = current.next\\n\\n            current.next = l1 if l1 else l2\\n\\n            return dummy.next\\n\\n        if not lists:\\n            return None\\n\\n        while len(lists) > 1:\\n            merged_lists = []\\n\\n            for i in range(0, len(lists), 2):\\n                l1 = lists[i]\\n                l2 = lists[i + 1] if i + 1 < len(lists) else None\\n                merged_lists.append(mergeTwoLists(l1, l2))\\n\\n            lists = merged_lists\\n\\n        return lists[0] if lists else None\\n\\n\\n# Example usage\\nlists = [\\n    ListNode(1, ListNode(4, ListNode(5))),\\n    ListNode(1, ListNode(3, ListNode(4))),\\n    ListNode(2, ListNode(6))\\n]\\n\\nsolution = Solution()\\nresult = solution.mergeKLists(lists)\\nwhile result:\\n    print(result.val)\\n    result = result.next\\n"
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "qin4",
                        "content": "Util class ListNode in python 3 is not completed. It can\\'t do heapq directly. Fix is easier on server side."
                    }
                ]
            },
            {
                "id": 1572281,
                "content": [
                    {
                        "username": "adambene",
                        "content": "This problem should not be marked as hard.\\nMedium is more proper based on the other problems on leetcode."
                    },
                    {
                        "username": "Pranjal_Bajpai",
                        "content": "i would say easy, its no brainer !"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cwooldridge](/cwooldridge)  POV: you solved your first HARD problem. "
                    },
                    {
                        "username": "jason3410",
                        "content": "[@Mister_CK](/Mister_CK) Cuz your solution make no connection with the ListNodes. And u won\\'t learn anything on this question."
                    },
                    {
                        "username": "user5331Az",
                        "content": "[@Mister_CK](/Mister_CK) putting an element into sorted array is O(log2(n)), sorting of an array is O(n^2) generally."
                    },
                    {
                        "username": "dhunmoon",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "[@cwooldridge](/cwooldridge) I almost started to think that i\\'m a hard problem solver and then I came here"
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Hey man, cmon, let me enjoy this moment\\uD83D\\uDE02"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It should be Easy imo. At least in JS there is no need to use a priority queue. You can just put all the values in an array, sort that array and put them in a list you then return. runs in 79 ms, beats 97% of solutions and it's the same answer as for the Easy problem `21. Merge Two Sorted Lists` (albeit that this is an array of lists, rather than just two, but it's the exact same principle). I really don't understand why this is marked with Hard and Priority Queue, really threw me off. I wrote a whole solution with a priority queue for an hour, only to realise it was completely unnecessary and I wrote a faster algorithm without it in 5 minutes. ([@joseph261059](/joseph261059) I tried using that, but I got an error on the node version (I believe it couldn't find insert), so I copied an implementation of a PriorityQueue using heap from stackoverflow) (PS: I checked, in regular Java it runs in 8 ms (beating only 28% of solutions), but that is still well within the accepted solution range.)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "[@Husoski](/Husoski) In JS, we can use PriorityQueue package in leetcode"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Well this still is hard problem as if go optimize your time complexity the solutions becomes more and more complex!"
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@Husoski](/Husoski) Indeed, but nobody uses programming languages like C in competitive programming. The most popular languages are C++, Java and Python. If there is no standard library with basic data structures like a `vector` or a `heap` in the programming language of your choice, you might want to use another language for the purpose of solving leetcode questions."
                    },
                    {
                        "username": "Husoski",
                        "content": "That depends on the language you used.  In a language with a standard heap or priority queue data structure this is indeed on the easy side of Medium.  I think it\\'s more like Hard in a language like C or JS.  (Assuming, of course, that the solver is going write the minheap code and not copy-paste it! :^)"
                    },
                    {
                        "username": "viocost",
                        "content": "The problem is interesting, but why there are test cases such as [[], []] \\nand not a word about possible inputs expected output?\\n\\nIs it also a telepathy exercise?\\n"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Very annoying; they don\\'t seem to mention how the output is parsed; the result needs to be a ListNode or null.\\nFilter the list then go from there."
                    },
                    {
                        "username": "alistar",
                        "content": "With empty list it seems to expect an empty list as an output, however, it doest not accept it with type-error.\\nLitterally copied and pasted one of the official solutions, it doesn\\'t go through with the same issue!"
                    },
                    {
                        "username": "user9118TR",
                        "content": "[@amithshetty](/amithshetty)  Thaks a lot, how did you know it ??"
                    },
                    {
                        "username": "sony541",
                        "content": "[@amithshetty](/amithshetty) Well, if \"None\" is the end of list, you can think of \"None\" as an empty linked list, nice callout here... It took me a while to figure out, but sounds reasonable after all.. Could\\'ve been clarified in promt though."
                    },
                    {
                        "username": "amithshetty",
                        "content": "IT expects None, i.e not a list but an empty linked list"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-k-sorted-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Compare one by one\n\n  \n**Approach 3:** Optimize Approach 2 by Priority Queue\n\n  \n**Approach 4:** Merge lists one by one\n\n  \n**Approach 5:** Merge with Divide And Conquer\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Kouei",
                        "content": "The fastest C++ code can achieve a time about 370ms ~ 380ms\\n\\nwhile Python code can achieve 100ms, and even amazing, JAVA can do it in just 4ms !\\n\\nThis result is quite counterintuitive."
                    },
                    {
                        "username": "321maayan",
                        "content": "python is build in c and c is powerful as c++\\n"
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "[@Normalitee0os](/Normalitee0os)  post the code lol"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Mine took 15 ms using C++"
                    },
                    {
                        "username": "Normalitee0os",
                        "content": "Mine took 0.1 ms using HTML."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Mine took 23ms in C++"
                    },
                    {
                        "username": "slashtab",
                        "content": "OJ of LeetCode isn\\'t that perfect."
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "mine 22ms with c++; "
                    },
                    {
                        "username": "charonme",
                        "content": "35ms in PHP without using any built-in functions except count"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "mine was 40ms in c++, which could be further optimized"
                    },
                    {
                        "username": "f1rumors",
                        "content": "underlying libraries are a boon"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python...\\n\\nI assume that everyone realizes that without using ListNode that the solution to this problem is one line of code. Flatten the lists to one list and sort the list. \\n\\nWhy are there so many problems that have to be answered using ListNodes? It\\'s a complete waste of time in a language such as python. Shouldn\\'t the simplest solution be the best solution? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of `ListNode` or linked lists in algorithmic problems isn\\'t necessarily about finding the most efficient solution in Python or any specific language. Rather, it\\'s about teaching or testing certain concepts. Here are a few reasons:\\n\\n1. **Conceptual Understanding**: Using `ListNode` often helps in understanding how to manually manipulate pointers and nodes, which is crucial for a deep understanding of data structures.\\n\\n2. **Language Agnostic**: These problems are designed to be language-agnostic. While Python has easy list manipulation, languages like C or C++ do not have such built-in capabilities. The problem is set to be fair to everyone, regardless of the programming language used.\\n\\n3. **Algorithm Complexity**: Some problems require an in-depth understanding of algorithm complexity. Using built-in functions like `sort` can sometimes give a false sense of simplicity when, in fact, the actual task of merging the lists might be more complex.\\n\\n4. **Resource Utilization**: In some cases, especially in embedded systems or other resource-constrained environments, understanding how to work with nodes and pointers is essential for efficient memory usage.\\n\\n5. **Skill Assessment**: These problems are often used in interviews to assess understanding of fundamental computer science concepts, beyond syntactic sugar provided by specific programming languages.\\n\\n6. **Real-world Use Cases**: Not all data comes in simple, sorted, array-like structures. Linked lists, trees, and graphs are data structures commonly used in real-world applications. Understanding them is key to being a well-rounded developer.\\n\\n7. **Optimal Substructure**: Problems that mandate the use of data structures like linked lists often involve an optimal substructure that makes for an elegant solution, thereby teaching you problem-solving patterns that can be applied elsewhere.\\n\\n8. **Consistency**: If a problem was initially posed in a computer science paper or textbook using `ListNodes`, it\\'s often kept that way to maintain consistency with classic algorithm and data structure literature.\\n\\nSo while it may seem unnecessary or verbose, using `ListNode` provides a broader educational benefit, ensuring that you understand both high-level language features and low-level data structure manipulation."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go tell it on an interview :)"
                    },
                    {
                        "username": "Vantrashell",
                        "content": "[@mikael6767](/mikael6767) The goal should very rarely be to write the shortest amount of code. The 1 line solution typically uses a generalized algorithm, which may or may not be useful for what you wish to do. The problem forces ListNode as a guide to push in the direction it wants. Most of the solutions, although using ListNode, ignore this guide as the question very clearly wants a solution that does not create new memory as LinkedLists do not require such a complex operation for insertion. Ultimately, the point is (and why this is a hard problem and not a medium one like others have suggested) to do mergeKLists in O(1) space. The one line of Python most-likely does allocate new memory somewhere. If your customer pays for the amount of ram they use from a cloud service, they would be most pleased if you would keep that cost low."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Ok, @cartesPerforees, then explain why do we need ListNode if we can do this problem way easier without it. The goal is to make the solution with the shortest possible code. In this case 1 line, not 50. Imagine a customer wants you to make this problem: Merge K Sorted Lists. He doesn\\'t say how you need to do it, He just says to do it on python3. How would you do it? Would you write 50 lines of code using ListNode or one line of code. Please read and reply and we can discuss this later."
                    },
                    {
                        "username": "user5331Az",
                        "content": "bravo! dude, the task is for the ones familiar with algorithmic complexity concept at least, definitely not for you."
                    },
                    {
                        "username": "squigity",
                        "content": "[@mikael6767](/mikael6767)  Concept of linked lists is for a different scenario ,  the question here is to know if we understand linked lists or not and not to merge a sorted list from a list of lists"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your comment puzzles me. The whole point of those problems is to give you something to solve, and make it somewhat of a challenge depending on the difficulty tag. Most of the problems on leetcode are artificial and of no practical use, they are just made to help you practise probem solving.\\nI don\\'t get why you complain that they\\'re making things harder for you. That\\'s the point. It\\'s like playing with one of those chinese/japanes wooden brain teasers and  complaining that they should have designed it so that it opens like a normal box."
                    },
                    {
                        "username": "mikael6767",
                        "content": "I realize this. I am programming on python3 and really know that it really is one line of code, but the problem is with ListNode. There are a lot LeetCode problems with ListNode and I can\\'t make them even if they are very easy without it. I have the same problem. I wrote that one line of code and it says it is not right. I would really like for someone to help you, but I\\'m sorry I can\\'t."
                    },
                    {
                        "username": "David_E_something",
                        "content": "If you somehow use a priority queue (heap), this problem becomes very easy."
                    },
                    {
                        "username": "clinkz93",
                        "content": "[@layman806](/layman806) Using a priority queue results in a complexity of O((k + n) * log(k)) instead of O(n * log(n)), which may be preferrable."
                    },
                    {
                        "username": "root89",
                        "content": "[@layman806](/layman806) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@layman806](/layman806) lmao,, you can\\'t beat the interviewer."
                    },
                    {
                        "username": "layman806",
                        "content": "Or just parse all into an array in O(n) time, then sort it in O(n.log(n)) time and convert it to a linked list in O(n) time. This is just too easy to beat. Shouldn\\'t be tagged as hard."
                    },
                    {
                        "username": "JaviOverflow",
                        "content": "When I submit my solution, it fails on the input `[[]]`, how is that input even posible? `ListNode` requires `val` as argument in its constructor. Returning `None` doesn\\'t make the test pass. I\\'m not sure how to tackle that."
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "thenimator",
                        "content": "It\\'s been a while since you had this problem but for anyone else running into it:\\n\\n[[]] simply stands for an array with 1 element with that one element being a null pointer (which in this context stands for an empty linked list and not one where the value of the first element is missing)"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, WTF? ![image](https://assets.leetcode.com/users/beatrizdos/image_1570843047.png)\\n"
                    },
                    {
                        "username": "Will-O-Wisp",
                        "content": "class ListNode(object):\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\n\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        def mergeTwoLists(l1, l2):\\n            dummy = ListNode(0)\\n            current = dummy\\n\\n            while l1 and l2:\\n                if l1.val < l2.val:\\n                    current.next = l1\\n                    l1 = l1.next\\n                else:\\n                    current.next = l2\\n                    l2 = l2.next\\n                current = current.next\\n\\n            current.next = l1 if l1 else l2\\n\\n            return dummy.next\\n\\n        if not lists:\\n            return None\\n\\n        while len(lists) > 1:\\n            merged_lists = []\\n\\n            for i in range(0, len(lists), 2):\\n                l1 = lists[i]\\n                l2 = lists[i + 1] if i + 1 < len(lists) else None\\n                merged_lists.append(mergeTwoLists(l1, l2))\\n\\n            lists = merged_lists\\n\\n        return lists[0] if lists else None\\n\\n\\n# Example usage\\nlists = [\\n    ListNode(1, ListNode(4, ListNode(5))),\\n    ListNode(1, ListNode(3, ListNode(4))),\\n    ListNode(2, ListNode(6))\\n]\\n\\nsolution = Solution()\\nresult = solution.mergeKLists(lists)\\nwhile result:\\n    print(result.val)\\n    result = result.next\\n"
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "qin4",
                        "content": "Util class ListNode in python 3 is not completed. It can\\'t do heapq directly. Fix is easier on server side."
                    }
                ]
            },
            {
                "id": 1566937,
                "content": [
                    {
                        "username": "adambene",
                        "content": "This problem should not be marked as hard.\\nMedium is more proper based on the other problems on leetcode."
                    },
                    {
                        "username": "Pranjal_Bajpai",
                        "content": "i would say easy, its no brainer !"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cwooldridge](/cwooldridge)  POV: you solved your first HARD problem. "
                    },
                    {
                        "username": "jason3410",
                        "content": "[@Mister_CK](/Mister_CK) Cuz your solution make no connection with the ListNodes. And u won\\'t learn anything on this question."
                    },
                    {
                        "username": "user5331Az",
                        "content": "[@Mister_CK](/Mister_CK) putting an element into sorted array is O(log2(n)), sorting of an array is O(n^2) generally."
                    },
                    {
                        "username": "dhunmoon",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "[@cwooldridge](/cwooldridge) I almost started to think that i\\'m a hard problem solver and then I came here"
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Hey man, cmon, let me enjoy this moment\\uD83D\\uDE02"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It should be Easy imo. At least in JS there is no need to use a priority queue. You can just put all the values in an array, sort that array and put them in a list you then return. runs in 79 ms, beats 97% of solutions and it's the same answer as for the Easy problem `21. Merge Two Sorted Lists` (albeit that this is an array of lists, rather than just two, but it's the exact same principle). I really don't understand why this is marked with Hard and Priority Queue, really threw me off. I wrote a whole solution with a priority queue for an hour, only to realise it was completely unnecessary and I wrote a faster algorithm without it in 5 minutes. ([@joseph261059](/joseph261059) I tried using that, but I got an error on the node version (I believe it couldn't find insert), so I copied an implementation of a PriorityQueue using heap from stackoverflow) (PS: I checked, in regular Java it runs in 8 ms (beating only 28% of solutions), but that is still well within the accepted solution range.)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "[@Husoski](/Husoski) In JS, we can use PriorityQueue package in leetcode"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Well this still is hard problem as if go optimize your time complexity the solutions becomes more and more complex!"
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@Husoski](/Husoski) Indeed, but nobody uses programming languages like C in competitive programming. The most popular languages are C++, Java and Python. If there is no standard library with basic data structures like a `vector` or a `heap` in the programming language of your choice, you might want to use another language for the purpose of solving leetcode questions."
                    },
                    {
                        "username": "Husoski",
                        "content": "That depends on the language you used.  In a language with a standard heap or priority queue data structure this is indeed on the easy side of Medium.  I think it\\'s more like Hard in a language like C or JS.  (Assuming, of course, that the solver is going write the minheap code and not copy-paste it! :^)"
                    },
                    {
                        "username": "viocost",
                        "content": "The problem is interesting, but why there are test cases such as [[], []] \\nand not a word about possible inputs expected output?\\n\\nIs it also a telepathy exercise?\\n"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Very annoying; they don\\'t seem to mention how the output is parsed; the result needs to be a ListNode or null.\\nFilter the list then go from there."
                    },
                    {
                        "username": "alistar",
                        "content": "With empty list it seems to expect an empty list as an output, however, it doest not accept it with type-error.\\nLitterally copied and pasted one of the official solutions, it doesn\\'t go through with the same issue!"
                    },
                    {
                        "username": "user9118TR",
                        "content": "[@amithshetty](/amithshetty)  Thaks a lot, how did you know it ??"
                    },
                    {
                        "username": "sony541",
                        "content": "[@amithshetty](/amithshetty) Well, if \"None\" is the end of list, you can think of \"None\" as an empty linked list, nice callout here... It took me a while to figure out, but sounds reasonable after all.. Could\\'ve been clarified in promt though."
                    },
                    {
                        "username": "amithshetty",
                        "content": "IT expects None, i.e not a list but an empty linked list"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-k-sorted-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Compare one by one\n\n  \n**Approach 3:** Optimize Approach 2 by Priority Queue\n\n  \n**Approach 4:** Merge lists one by one\n\n  \n**Approach 5:** Merge with Divide And Conquer\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Kouei",
                        "content": "The fastest C++ code can achieve a time about 370ms ~ 380ms\\n\\nwhile Python code can achieve 100ms, and even amazing, JAVA can do it in just 4ms !\\n\\nThis result is quite counterintuitive."
                    },
                    {
                        "username": "321maayan",
                        "content": "python is build in c and c is powerful as c++\\n"
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "[@Normalitee0os](/Normalitee0os)  post the code lol"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Mine took 15 ms using C++"
                    },
                    {
                        "username": "Normalitee0os",
                        "content": "Mine took 0.1 ms using HTML."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Mine took 23ms in C++"
                    },
                    {
                        "username": "slashtab",
                        "content": "OJ of LeetCode isn\\'t that perfect."
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "mine 22ms with c++; "
                    },
                    {
                        "username": "charonme",
                        "content": "35ms in PHP without using any built-in functions except count"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "mine was 40ms in c++, which could be further optimized"
                    },
                    {
                        "username": "f1rumors",
                        "content": "underlying libraries are a boon"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python...\\n\\nI assume that everyone realizes that without using ListNode that the solution to this problem is one line of code. Flatten the lists to one list and sort the list. \\n\\nWhy are there so many problems that have to be answered using ListNodes? It\\'s a complete waste of time in a language such as python. Shouldn\\'t the simplest solution be the best solution? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of `ListNode` or linked lists in algorithmic problems isn\\'t necessarily about finding the most efficient solution in Python or any specific language. Rather, it\\'s about teaching or testing certain concepts. Here are a few reasons:\\n\\n1. **Conceptual Understanding**: Using `ListNode` often helps in understanding how to manually manipulate pointers and nodes, which is crucial for a deep understanding of data structures.\\n\\n2. **Language Agnostic**: These problems are designed to be language-agnostic. While Python has easy list manipulation, languages like C or C++ do not have such built-in capabilities. The problem is set to be fair to everyone, regardless of the programming language used.\\n\\n3. **Algorithm Complexity**: Some problems require an in-depth understanding of algorithm complexity. Using built-in functions like `sort` can sometimes give a false sense of simplicity when, in fact, the actual task of merging the lists might be more complex.\\n\\n4. **Resource Utilization**: In some cases, especially in embedded systems or other resource-constrained environments, understanding how to work with nodes and pointers is essential for efficient memory usage.\\n\\n5. **Skill Assessment**: These problems are often used in interviews to assess understanding of fundamental computer science concepts, beyond syntactic sugar provided by specific programming languages.\\n\\n6. **Real-world Use Cases**: Not all data comes in simple, sorted, array-like structures. Linked lists, trees, and graphs are data structures commonly used in real-world applications. Understanding them is key to being a well-rounded developer.\\n\\n7. **Optimal Substructure**: Problems that mandate the use of data structures like linked lists often involve an optimal substructure that makes for an elegant solution, thereby teaching you problem-solving patterns that can be applied elsewhere.\\n\\n8. **Consistency**: If a problem was initially posed in a computer science paper or textbook using `ListNodes`, it\\'s often kept that way to maintain consistency with classic algorithm and data structure literature.\\n\\nSo while it may seem unnecessary or verbose, using `ListNode` provides a broader educational benefit, ensuring that you understand both high-level language features and low-level data structure manipulation."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go tell it on an interview :)"
                    },
                    {
                        "username": "Vantrashell",
                        "content": "[@mikael6767](/mikael6767) The goal should very rarely be to write the shortest amount of code. The 1 line solution typically uses a generalized algorithm, which may or may not be useful for what you wish to do. The problem forces ListNode as a guide to push in the direction it wants. Most of the solutions, although using ListNode, ignore this guide as the question very clearly wants a solution that does not create new memory as LinkedLists do not require such a complex operation for insertion. Ultimately, the point is (and why this is a hard problem and not a medium one like others have suggested) to do mergeKLists in O(1) space. The one line of Python most-likely does allocate new memory somewhere. If your customer pays for the amount of ram they use from a cloud service, they would be most pleased if you would keep that cost low."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Ok, @cartesPerforees, then explain why do we need ListNode if we can do this problem way easier without it. The goal is to make the solution with the shortest possible code. In this case 1 line, not 50. Imagine a customer wants you to make this problem: Merge K Sorted Lists. He doesn\\'t say how you need to do it, He just says to do it on python3. How would you do it? Would you write 50 lines of code using ListNode or one line of code. Please read and reply and we can discuss this later."
                    },
                    {
                        "username": "user5331Az",
                        "content": "bravo! dude, the task is for the ones familiar with algorithmic complexity concept at least, definitely not for you."
                    },
                    {
                        "username": "squigity",
                        "content": "[@mikael6767](/mikael6767)  Concept of linked lists is for a different scenario ,  the question here is to know if we understand linked lists or not and not to merge a sorted list from a list of lists"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your comment puzzles me. The whole point of those problems is to give you something to solve, and make it somewhat of a challenge depending on the difficulty tag. Most of the problems on leetcode are artificial and of no practical use, they are just made to help you practise probem solving.\\nI don\\'t get why you complain that they\\'re making things harder for you. That\\'s the point. It\\'s like playing with one of those chinese/japanes wooden brain teasers and  complaining that they should have designed it so that it opens like a normal box."
                    },
                    {
                        "username": "mikael6767",
                        "content": "I realize this. I am programming on python3 and really know that it really is one line of code, but the problem is with ListNode. There are a lot LeetCode problems with ListNode and I can\\'t make them even if they are very easy without it. I have the same problem. I wrote that one line of code and it says it is not right. I would really like for someone to help you, but I\\'m sorry I can\\'t."
                    },
                    {
                        "username": "David_E_something",
                        "content": "If you somehow use a priority queue (heap), this problem becomes very easy."
                    },
                    {
                        "username": "clinkz93",
                        "content": "[@layman806](/layman806) Using a priority queue results in a complexity of O((k + n) * log(k)) instead of O(n * log(n)), which may be preferrable."
                    },
                    {
                        "username": "root89",
                        "content": "[@layman806](/layman806) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@layman806](/layman806) lmao,, you can\\'t beat the interviewer."
                    },
                    {
                        "username": "layman806",
                        "content": "Or just parse all into an array in O(n) time, then sort it in O(n.log(n)) time and convert it to a linked list in O(n) time. This is just too easy to beat. Shouldn\\'t be tagged as hard."
                    },
                    {
                        "username": "JaviOverflow",
                        "content": "When I submit my solution, it fails on the input `[[]]`, how is that input even posible? `ListNode` requires `val` as argument in its constructor. Returning `None` doesn\\'t make the test pass. I\\'m not sure how to tackle that."
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "thenimator",
                        "content": "It\\'s been a while since you had this problem but for anyone else running into it:\\n\\n[[]] simply stands for an array with 1 element with that one element being a null pointer (which in this context stands for an empty linked list and not one where the value of the first element is missing)"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, WTF? ![image](https://assets.leetcode.com/users/beatrizdos/image_1570843047.png)\\n"
                    },
                    {
                        "username": "Will-O-Wisp",
                        "content": "class ListNode(object):\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\n\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        def mergeTwoLists(l1, l2):\\n            dummy = ListNode(0)\\n            current = dummy\\n\\n            while l1 and l2:\\n                if l1.val < l2.val:\\n                    current.next = l1\\n                    l1 = l1.next\\n                else:\\n                    current.next = l2\\n                    l2 = l2.next\\n                current = current.next\\n\\n            current.next = l1 if l1 else l2\\n\\n            return dummy.next\\n\\n        if not lists:\\n            return None\\n\\n        while len(lists) > 1:\\n            merged_lists = []\\n\\n            for i in range(0, len(lists), 2):\\n                l1 = lists[i]\\n                l2 = lists[i + 1] if i + 1 < len(lists) else None\\n                merged_lists.append(mergeTwoLists(l1, l2))\\n\\n            lists = merged_lists\\n\\n        return lists[0] if lists else None\\n\\n\\n# Example usage\\nlists = [\\n    ListNode(1, ListNode(4, ListNode(5))),\\n    ListNode(1, ListNode(3, ListNode(4))),\\n    ListNode(2, ListNode(6))\\n]\\n\\nsolution = Solution()\\nresult = solution.mergeKLists(lists)\\nwhile result:\\n    print(result.val)\\n    result = result.next\\n"
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "qin4",
                        "content": "Util class ListNode in python 3 is not completed. It can\\'t do heapq directly. Fix is easier on server side."
                    }
                ]
            },
            {
                "id": 1565582,
                "content": [
                    {
                        "username": "adambene",
                        "content": "This problem should not be marked as hard.\\nMedium is more proper based on the other problems on leetcode."
                    },
                    {
                        "username": "Pranjal_Bajpai",
                        "content": "i would say easy, its no brainer !"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cwooldridge](/cwooldridge)  POV: you solved your first HARD problem. "
                    },
                    {
                        "username": "jason3410",
                        "content": "[@Mister_CK](/Mister_CK) Cuz your solution make no connection with the ListNodes. And u won\\'t learn anything on this question."
                    },
                    {
                        "username": "user5331Az",
                        "content": "[@Mister_CK](/Mister_CK) putting an element into sorted array is O(log2(n)), sorting of an array is O(n^2) generally."
                    },
                    {
                        "username": "dhunmoon",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "[@cwooldridge](/cwooldridge) I almost started to think that i\\'m a hard problem solver and then I came here"
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Hey man, cmon, let me enjoy this moment\\uD83D\\uDE02"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It should be Easy imo. At least in JS there is no need to use a priority queue. You can just put all the values in an array, sort that array and put them in a list you then return. runs in 79 ms, beats 97% of solutions and it's the same answer as for the Easy problem `21. Merge Two Sorted Lists` (albeit that this is an array of lists, rather than just two, but it's the exact same principle). I really don't understand why this is marked with Hard and Priority Queue, really threw me off. I wrote a whole solution with a priority queue for an hour, only to realise it was completely unnecessary and I wrote a faster algorithm without it in 5 minutes. ([@joseph261059](/joseph261059) I tried using that, but I got an error on the node version (I believe it couldn't find insert), so I copied an implementation of a PriorityQueue using heap from stackoverflow) (PS: I checked, in regular Java it runs in 8 ms (beating only 28% of solutions), but that is still well within the accepted solution range.)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "[@Husoski](/Husoski) In JS, we can use PriorityQueue package in leetcode"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Well this still is hard problem as if go optimize your time complexity the solutions becomes more and more complex!"
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@Husoski](/Husoski) Indeed, but nobody uses programming languages like C in competitive programming. The most popular languages are C++, Java and Python. If there is no standard library with basic data structures like a `vector` or a `heap` in the programming language of your choice, you might want to use another language for the purpose of solving leetcode questions."
                    },
                    {
                        "username": "Husoski",
                        "content": "That depends on the language you used.  In a language with a standard heap or priority queue data structure this is indeed on the easy side of Medium.  I think it\\'s more like Hard in a language like C or JS.  (Assuming, of course, that the solver is going write the minheap code and not copy-paste it! :^)"
                    },
                    {
                        "username": "viocost",
                        "content": "The problem is interesting, but why there are test cases such as [[], []] \\nand not a word about possible inputs expected output?\\n\\nIs it also a telepathy exercise?\\n"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Very annoying; they don\\'t seem to mention how the output is parsed; the result needs to be a ListNode or null.\\nFilter the list then go from there."
                    },
                    {
                        "username": "alistar",
                        "content": "With empty list it seems to expect an empty list as an output, however, it doest not accept it with type-error.\\nLitterally copied and pasted one of the official solutions, it doesn\\'t go through with the same issue!"
                    },
                    {
                        "username": "user9118TR",
                        "content": "[@amithshetty](/amithshetty)  Thaks a lot, how did you know it ??"
                    },
                    {
                        "username": "sony541",
                        "content": "[@amithshetty](/amithshetty) Well, if \"None\" is the end of list, you can think of \"None\" as an empty linked list, nice callout here... It took me a while to figure out, but sounds reasonable after all.. Could\\'ve been clarified in promt though."
                    },
                    {
                        "username": "amithshetty",
                        "content": "IT expects None, i.e not a list but an empty linked list"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-k-sorted-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Compare one by one\n\n  \n**Approach 3:** Optimize Approach 2 by Priority Queue\n\n  \n**Approach 4:** Merge lists one by one\n\n  \n**Approach 5:** Merge with Divide And Conquer\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Kouei",
                        "content": "The fastest C++ code can achieve a time about 370ms ~ 380ms\\n\\nwhile Python code can achieve 100ms, and even amazing, JAVA can do it in just 4ms !\\n\\nThis result is quite counterintuitive."
                    },
                    {
                        "username": "321maayan",
                        "content": "python is build in c and c is powerful as c++\\n"
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "[@Normalitee0os](/Normalitee0os)  post the code lol"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Mine took 15 ms using C++"
                    },
                    {
                        "username": "Normalitee0os",
                        "content": "Mine took 0.1 ms using HTML."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Mine took 23ms in C++"
                    },
                    {
                        "username": "slashtab",
                        "content": "OJ of LeetCode isn\\'t that perfect."
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "mine 22ms with c++; "
                    },
                    {
                        "username": "charonme",
                        "content": "35ms in PHP without using any built-in functions except count"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "mine was 40ms in c++, which could be further optimized"
                    },
                    {
                        "username": "f1rumors",
                        "content": "underlying libraries are a boon"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python...\\n\\nI assume that everyone realizes that without using ListNode that the solution to this problem is one line of code. Flatten the lists to one list and sort the list. \\n\\nWhy are there so many problems that have to be answered using ListNodes? It\\'s a complete waste of time in a language such as python. Shouldn\\'t the simplest solution be the best solution? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of `ListNode` or linked lists in algorithmic problems isn\\'t necessarily about finding the most efficient solution in Python or any specific language. Rather, it\\'s about teaching or testing certain concepts. Here are a few reasons:\\n\\n1. **Conceptual Understanding**: Using `ListNode` often helps in understanding how to manually manipulate pointers and nodes, which is crucial for a deep understanding of data structures.\\n\\n2. **Language Agnostic**: These problems are designed to be language-agnostic. While Python has easy list manipulation, languages like C or C++ do not have such built-in capabilities. The problem is set to be fair to everyone, regardless of the programming language used.\\n\\n3. **Algorithm Complexity**: Some problems require an in-depth understanding of algorithm complexity. Using built-in functions like `sort` can sometimes give a false sense of simplicity when, in fact, the actual task of merging the lists might be more complex.\\n\\n4. **Resource Utilization**: In some cases, especially in embedded systems or other resource-constrained environments, understanding how to work with nodes and pointers is essential for efficient memory usage.\\n\\n5. **Skill Assessment**: These problems are often used in interviews to assess understanding of fundamental computer science concepts, beyond syntactic sugar provided by specific programming languages.\\n\\n6. **Real-world Use Cases**: Not all data comes in simple, sorted, array-like structures. Linked lists, trees, and graphs are data structures commonly used in real-world applications. Understanding them is key to being a well-rounded developer.\\n\\n7. **Optimal Substructure**: Problems that mandate the use of data structures like linked lists often involve an optimal substructure that makes for an elegant solution, thereby teaching you problem-solving patterns that can be applied elsewhere.\\n\\n8. **Consistency**: If a problem was initially posed in a computer science paper or textbook using `ListNodes`, it\\'s often kept that way to maintain consistency with classic algorithm and data structure literature.\\n\\nSo while it may seem unnecessary or verbose, using `ListNode` provides a broader educational benefit, ensuring that you understand both high-level language features and low-level data structure manipulation."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go tell it on an interview :)"
                    },
                    {
                        "username": "Vantrashell",
                        "content": "[@mikael6767](/mikael6767) The goal should very rarely be to write the shortest amount of code. The 1 line solution typically uses a generalized algorithm, which may or may not be useful for what you wish to do. The problem forces ListNode as a guide to push in the direction it wants. Most of the solutions, although using ListNode, ignore this guide as the question very clearly wants a solution that does not create new memory as LinkedLists do not require such a complex operation for insertion. Ultimately, the point is (and why this is a hard problem and not a medium one like others have suggested) to do mergeKLists in O(1) space. The one line of Python most-likely does allocate new memory somewhere. If your customer pays for the amount of ram they use from a cloud service, they would be most pleased if you would keep that cost low."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Ok, @cartesPerforees, then explain why do we need ListNode if we can do this problem way easier without it. The goal is to make the solution with the shortest possible code. In this case 1 line, not 50. Imagine a customer wants you to make this problem: Merge K Sorted Lists. He doesn\\'t say how you need to do it, He just says to do it on python3. How would you do it? Would you write 50 lines of code using ListNode or one line of code. Please read and reply and we can discuss this later."
                    },
                    {
                        "username": "user5331Az",
                        "content": "bravo! dude, the task is for the ones familiar with algorithmic complexity concept at least, definitely not for you."
                    },
                    {
                        "username": "squigity",
                        "content": "[@mikael6767](/mikael6767)  Concept of linked lists is for a different scenario ,  the question here is to know if we understand linked lists or not and not to merge a sorted list from a list of lists"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your comment puzzles me. The whole point of those problems is to give you something to solve, and make it somewhat of a challenge depending on the difficulty tag. Most of the problems on leetcode are artificial and of no practical use, they are just made to help you practise probem solving.\\nI don\\'t get why you complain that they\\'re making things harder for you. That\\'s the point. It\\'s like playing with one of those chinese/japanes wooden brain teasers and  complaining that they should have designed it so that it opens like a normal box."
                    },
                    {
                        "username": "mikael6767",
                        "content": "I realize this. I am programming on python3 and really know that it really is one line of code, but the problem is with ListNode. There are a lot LeetCode problems with ListNode and I can\\'t make them even if they are very easy without it. I have the same problem. I wrote that one line of code and it says it is not right. I would really like for someone to help you, but I\\'m sorry I can\\'t."
                    },
                    {
                        "username": "David_E_something",
                        "content": "If you somehow use a priority queue (heap), this problem becomes very easy."
                    },
                    {
                        "username": "clinkz93",
                        "content": "[@layman806](/layman806) Using a priority queue results in a complexity of O((k + n) * log(k)) instead of O(n * log(n)), which may be preferrable."
                    },
                    {
                        "username": "root89",
                        "content": "[@layman806](/layman806) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@layman806](/layman806) lmao,, you can\\'t beat the interviewer."
                    },
                    {
                        "username": "layman806",
                        "content": "Or just parse all into an array in O(n) time, then sort it in O(n.log(n)) time and convert it to a linked list in O(n) time. This is just too easy to beat. Shouldn\\'t be tagged as hard."
                    },
                    {
                        "username": "JaviOverflow",
                        "content": "When I submit my solution, it fails on the input `[[]]`, how is that input even posible? `ListNode` requires `val` as argument in its constructor. Returning `None` doesn\\'t make the test pass. I\\'m not sure how to tackle that."
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "thenimator",
                        "content": "It\\'s been a while since you had this problem but for anyone else running into it:\\n\\n[[]] simply stands for an array with 1 element with that one element being a null pointer (which in this context stands for an empty linked list and not one where the value of the first element is missing)"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, WTF? ![image](https://assets.leetcode.com/users/beatrizdos/image_1570843047.png)\\n"
                    },
                    {
                        "username": "Will-O-Wisp",
                        "content": "class ListNode(object):\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\n\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        def mergeTwoLists(l1, l2):\\n            dummy = ListNode(0)\\n            current = dummy\\n\\n            while l1 and l2:\\n                if l1.val < l2.val:\\n                    current.next = l1\\n                    l1 = l1.next\\n                else:\\n                    current.next = l2\\n                    l2 = l2.next\\n                current = current.next\\n\\n            current.next = l1 if l1 else l2\\n\\n            return dummy.next\\n\\n        if not lists:\\n            return None\\n\\n        while len(lists) > 1:\\n            merged_lists = []\\n\\n            for i in range(0, len(lists), 2):\\n                l1 = lists[i]\\n                l2 = lists[i + 1] if i + 1 < len(lists) else None\\n                merged_lists.append(mergeTwoLists(l1, l2))\\n\\n            lists = merged_lists\\n\\n        return lists[0] if lists else None\\n\\n\\n# Example usage\\nlists = [\\n    ListNode(1, ListNode(4, ListNode(5))),\\n    ListNode(1, ListNode(3, ListNode(4))),\\n    ListNode(2, ListNode(6))\\n]\\n\\nsolution = Solution()\\nresult = solution.mergeKLists(lists)\\nwhile result:\\n    print(result.val)\\n    result = result.next\\n"
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "qin4",
                        "content": "Util class ListNode in python 3 is not completed. It can\\'t do heapq directly. Fix is easier on server side."
                    }
                ]
            },
            {
                "id": 1568841,
                "content": [
                    {
                        "username": "adambene",
                        "content": "This problem should not be marked as hard.\\nMedium is more proper based on the other problems on leetcode."
                    },
                    {
                        "username": "Pranjal_Bajpai",
                        "content": "i would say easy, its no brainer !"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cwooldridge](/cwooldridge)  POV: you solved your first HARD problem. "
                    },
                    {
                        "username": "jason3410",
                        "content": "[@Mister_CK](/Mister_CK) Cuz your solution make no connection with the ListNodes. And u won\\'t learn anything on this question."
                    },
                    {
                        "username": "user5331Az",
                        "content": "[@Mister_CK](/Mister_CK) putting an element into sorted array is O(log2(n)), sorting of an array is O(n^2) generally."
                    },
                    {
                        "username": "dhunmoon",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "[@cwooldridge](/cwooldridge) I almost started to think that i\\'m a hard problem solver and then I came here"
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Hey man, cmon, let me enjoy this moment\\uD83D\\uDE02"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It should be Easy imo. At least in JS there is no need to use a priority queue. You can just put all the values in an array, sort that array and put them in a list you then return. runs in 79 ms, beats 97% of solutions and it's the same answer as for the Easy problem `21. Merge Two Sorted Lists` (albeit that this is an array of lists, rather than just two, but it's the exact same principle). I really don't understand why this is marked with Hard and Priority Queue, really threw me off. I wrote a whole solution with a priority queue for an hour, only to realise it was completely unnecessary and I wrote a faster algorithm without it in 5 minutes. ([@joseph261059](/joseph261059) I tried using that, but I got an error on the node version (I believe it couldn't find insert), so I copied an implementation of a PriorityQueue using heap from stackoverflow) (PS: I checked, in regular Java it runs in 8 ms (beating only 28% of solutions), but that is still well within the accepted solution range.)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "[@Husoski](/Husoski) In JS, we can use PriorityQueue package in leetcode"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Well this still is hard problem as if go optimize your time complexity the solutions becomes more and more complex!"
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@Husoski](/Husoski) Indeed, but nobody uses programming languages like C in competitive programming. The most popular languages are C++, Java and Python. If there is no standard library with basic data structures like a `vector` or a `heap` in the programming language of your choice, you might want to use another language for the purpose of solving leetcode questions."
                    },
                    {
                        "username": "Husoski",
                        "content": "That depends on the language you used.  In a language with a standard heap or priority queue data structure this is indeed on the easy side of Medium.  I think it\\'s more like Hard in a language like C or JS.  (Assuming, of course, that the solver is going write the minheap code and not copy-paste it! :^)"
                    },
                    {
                        "username": "viocost",
                        "content": "The problem is interesting, but why there are test cases such as [[], []] \\nand not a word about possible inputs expected output?\\n\\nIs it also a telepathy exercise?\\n"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Very annoying; they don\\'t seem to mention how the output is parsed; the result needs to be a ListNode or null.\\nFilter the list then go from there."
                    },
                    {
                        "username": "alistar",
                        "content": "With empty list it seems to expect an empty list as an output, however, it doest not accept it with type-error.\\nLitterally copied and pasted one of the official solutions, it doesn\\'t go through with the same issue!"
                    },
                    {
                        "username": "user9118TR",
                        "content": "[@amithshetty](/amithshetty)  Thaks a lot, how did you know it ??"
                    },
                    {
                        "username": "sony541",
                        "content": "[@amithshetty](/amithshetty) Well, if \"None\" is the end of list, you can think of \"None\" as an empty linked list, nice callout here... It took me a while to figure out, but sounds reasonable after all.. Could\\'ve been clarified in promt though."
                    },
                    {
                        "username": "amithshetty",
                        "content": "IT expects None, i.e not a list but an empty linked list"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-k-sorted-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Compare one by one\n\n  \n**Approach 3:** Optimize Approach 2 by Priority Queue\n\n  \n**Approach 4:** Merge lists one by one\n\n  \n**Approach 5:** Merge with Divide And Conquer\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Kouei",
                        "content": "The fastest C++ code can achieve a time about 370ms ~ 380ms\\n\\nwhile Python code can achieve 100ms, and even amazing, JAVA can do it in just 4ms !\\n\\nThis result is quite counterintuitive."
                    },
                    {
                        "username": "321maayan",
                        "content": "python is build in c and c is powerful as c++\\n"
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "[@Normalitee0os](/Normalitee0os)  post the code lol"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Mine took 15 ms using C++"
                    },
                    {
                        "username": "Normalitee0os",
                        "content": "Mine took 0.1 ms using HTML."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Mine took 23ms in C++"
                    },
                    {
                        "username": "slashtab",
                        "content": "OJ of LeetCode isn\\'t that perfect."
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "mine 22ms with c++; "
                    },
                    {
                        "username": "charonme",
                        "content": "35ms in PHP without using any built-in functions except count"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "mine was 40ms in c++, which could be further optimized"
                    },
                    {
                        "username": "f1rumors",
                        "content": "underlying libraries are a boon"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python...\\n\\nI assume that everyone realizes that without using ListNode that the solution to this problem is one line of code. Flatten the lists to one list and sort the list. \\n\\nWhy are there so many problems that have to be answered using ListNodes? It\\'s a complete waste of time in a language such as python. Shouldn\\'t the simplest solution be the best solution? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of `ListNode` or linked lists in algorithmic problems isn\\'t necessarily about finding the most efficient solution in Python or any specific language. Rather, it\\'s about teaching or testing certain concepts. Here are a few reasons:\\n\\n1. **Conceptual Understanding**: Using `ListNode` often helps in understanding how to manually manipulate pointers and nodes, which is crucial for a deep understanding of data structures.\\n\\n2. **Language Agnostic**: These problems are designed to be language-agnostic. While Python has easy list manipulation, languages like C or C++ do not have such built-in capabilities. The problem is set to be fair to everyone, regardless of the programming language used.\\n\\n3. **Algorithm Complexity**: Some problems require an in-depth understanding of algorithm complexity. Using built-in functions like `sort` can sometimes give a false sense of simplicity when, in fact, the actual task of merging the lists might be more complex.\\n\\n4. **Resource Utilization**: In some cases, especially in embedded systems or other resource-constrained environments, understanding how to work with nodes and pointers is essential for efficient memory usage.\\n\\n5. **Skill Assessment**: These problems are often used in interviews to assess understanding of fundamental computer science concepts, beyond syntactic sugar provided by specific programming languages.\\n\\n6. **Real-world Use Cases**: Not all data comes in simple, sorted, array-like structures. Linked lists, trees, and graphs are data structures commonly used in real-world applications. Understanding them is key to being a well-rounded developer.\\n\\n7. **Optimal Substructure**: Problems that mandate the use of data structures like linked lists often involve an optimal substructure that makes for an elegant solution, thereby teaching you problem-solving patterns that can be applied elsewhere.\\n\\n8. **Consistency**: If a problem was initially posed in a computer science paper or textbook using `ListNodes`, it\\'s often kept that way to maintain consistency with classic algorithm and data structure literature.\\n\\nSo while it may seem unnecessary or verbose, using `ListNode` provides a broader educational benefit, ensuring that you understand both high-level language features and low-level data structure manipulation."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go tell it on an interview :)"
                    },
                    {
                        "username": "Vantrashell",
                        "content": "[@mikael6767](/mikael6767) The goal should very rarely be to write the shortest amount of code. The 1 line solution typically uses a generalized algorithm, which may or may not be useful for what you wish to do. The problem forces ListNode as a guide to push in the direction it wants. Most of the solutions, although using ListNode, ignore this guide as the question very clearly wants a solution that does not create new memory as LinkedLists do not require such a complex operation for insertion. Ultimately, the point is (and why this is a hard problem and not a medium one like others have suggested) to do mergeKLists in O(1) space. The one line of Python most-likely does allocate new memory somewhere. If your customer pays for the amount of ram they use from a cloud service, they would be most pleased if you would keep that cost low."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Ok, @cartesPerforees, then explain why do we need ListNode if we can do this problem way easier without it. The goal is to make the solution with the shortest possible code. In this case 1 line, not 50. Imagine a customer wants you to make this problem: Merge K Sorted Lists. He doesn\\'t say how you need to do it, He just says to do it on python3. How would you do it? Would you write 50 lines of code using ListNode or one line of code. Please read and reply and we can discuss this later."
                    },
                    {
                        "username": "user5331Az",
                        "content": "bravo! dude, the task is for the ones familiar with algorithmic complexity concept at least, definitely not for you."
                    },
                    {
                        "username": "squigity",
                        "content": "[@mikael6767](/mikael6767)  Concept of linked lists is for a different scenario ,  the question here is to know if we understand linked lists or not and not to merge a sorted list from a list of lists"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your comment puzzles me. The whole point of those problems is to give you something to solve, and make it somewhat of a challenge depending on the difficulty tag. Most of the problems on leetcode are artificial and of no practical use, they are just made to help you practise probem solving.\\nI don\\'t get why you complain that they\\'re making things harder for you. That\\'s the point. It\\'s like playing with one of those chinese/japanes wooden brain teasers and  complaining that they should have designed it so that it opens like a normal box."
                    },
                    {
                        "username": "mikael6767",
                        "content": "I realize this. I am programming on python3 and really know that it really is one line of code, but the problem is with ListNode. There are a lot LeetCode problems with ListNode and I can\\'t make them even if they are very easy without it. I have the same problem. I wrote that one line of code and it says it is not right. I would really like for someone to help you, but I\\'m sorry I can\\'t."
                    },
                    {
                        "username": "David_E_something",
                        "content": "If you somehow use a priority queue (heap), this problem becomes very easy."
                    },
                    {
                        "username": "clinkz93",
                        "content": "[@layman806](/layman806) Using a priority queue results in a complexity of O((k + n) * log(k)) instead of O(n * log(n)), which may be preferrable."
                    },
                    {
                        "username": "root89",
                        "content": "[@layman806](/layman806) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@layman806](/layman806) lmao,, you can\\'t beat the interviewer."
                    },
                    {
                        "username": "layman806",
                        "content": "Or just parse all into an array in O(n) time, then sort it in O(n.log(n)) time and convert it to a linked list in O(n) time. This is just too easy to beat. Shouldn\\'t be tagged as hard."
                    },
                    {
                        "username": "JaviOverflow",
                        "content": "When I submit my solution, it fails on the input `[[]]`, how is that input even posible? `ListNode` requires `val` as argument in its constructor. Returning `None` doesn\\'t make the test pass. I\\'m not sure how to tackle that."
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "thenimator",
                        "content": "It\\'s been a while since you had this problem but for anyone else running into it:\\n\\n[[]] simply stands for an array with 1 element with that one element being a null pointer (which in this context stands for an empty linked list and not one where the value of the first element is missing)"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, WTF? ![image](https://assets.leetcode.com/users/beatrizdos/image_1570843047.png)\\n"
                    },
                    {
                        "username": "Will-O-Wisp",
                        "content": "class ListNode(object):\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\n\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        def mergeTwoLists(l1, l2):\\n            dummy = ListNode(0)\\n            current = dummy\\n\\n            while l1 and l2:\\n                if l1.val < l2.val:\\n                    current.next = l1\\n                    l1 = l1.next\\n                else:\\n                    current.next = l2\\n                    l2 = l2.next\\n                current = current.next\\n\\n            current.next = l1 if l1 else l2\\n\\n            return dummy.next\\n\\n        if not lists:\\n            return None\\n\\n        while len(lists) > 1:\\n            merged_lists = []\\n\\n            for i in range(0, len(lists), 2):\\n                l1 = lists[i]\\n                l2 = lists[i + 1] if i + 1 < len(lists) else None\\n                merged_lists.append(mergeTwoLists(l1, l2))\\n\\n            lists = merged_lists\\n\\n        return lists[0] if lists else None\\n\\n\\n# Example usage\\nlists = [\\n    ListNode(1, ListNode(4, ListNode(5))),\\n    ListNode(1, ListNode(3, ListNode(4))),\\n    ListNode(2, ListNode(6))\\n]\\n\\nsolution = Solution()\\nresult = solution.mergeKLists(lists)\\nwhile result:\\n    print(result.val)\\n    result = result.next\\n"
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "qin4",
                        "content": "Util class ListNode in python 3 is not completed. It can\\'t do heapq directly. Fix is easier on server side."
                    }
                ]
            },
            {
                "id": 1804644,
                "content": [
                    {
                        "username": "adambene",
                        "content": "This problem should not be marked as hard.\\nMedium is more proper based on the other problems on leetcode."
                    },
                    {
                        "username": "Pranjal_Bajpai",
                        "content": "i would say easy, its no brainer !"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cwooldridge](/cwooldridge)  POV: you solved your first HARD problem. "
                    },
                    {
                        "username": "jason3410",
                        "content": "[@Mister_CK](/Mister_CK) Cuz your solution make no connection with the ListNodes. And u won\\'t learn anything on this question."
                    },
                    {
                        "username": "user5331Az",
                        "content": "[@Mister_CK](/Mister_CK) putting an element into sorted array is O(log2(n)), sorting of an array is O(n^2) generally."
                    },
                    {
                        "username": "dhunmoon",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "[@cwooldridge](/cwooldridge) I almost started to think that i\\'m a hard problem solver and then I came here"
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Hey man, cmon, let me enjoy this moment\\uD83D\\uDE02"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It should be Easy imo. At least in JS there is no need to use a priority queue. You can just put all the values in an array, sort that array and put them in a list you then return. runs in 79 ms, beats 97% of solutions and it's the same answer as for the Easy problem `21. Merge Two Sorted Lists` (albeit that this is an array of lists, rather than just two, but it's the exact same principle). I really don't understand why this is marked with Hard and Priority Queue, really threw me off. I wrote a whole solution with a priority queue for an hour, only to realise it was completely unnecessary and I wrote a faster algorithm without it in 5 minutes. ([@joseph261059](/joseph261059) I tried using that, but I got an error on the node version (I believe it couldn't find insert), so I copied an implementation of a PriorityQueue using heap from stackoverflow) (PS: I checked, in regular Java it runs in 8 ms (beating only 28% of solutions), but that is still well within the accepted solution range.)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "[@Husoski](/Husoski) In JS, we can use PriorityQueue package in leetcode"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Well this still is hard problem as if go optimize your time complexity the solutions becomes more and more complex!"
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@Husoski](/Husoski) Indeed, but nobody uses programming languages like C in competitive programming. The most popular languages are C++, Java and Python. If there is no standard library with basic data structures like a `vector` or a `heap` in the programming language of your choice, you might want to use another language for the purpose of solving leetcode questions."
                    },
                    {
                        "username": "Husoski",
                        "content": "That depends on the language you used.  In a language with a standard heap or priority queue data structure this is indeed on the easy side of Medium.  I think it\\'s more like Hard in a language like C or JS.  (Assuming, of course, that the solver is going write the minheap code and not copy-paste it! :^)"
                    },
                    {
                        "username": "viocost",
                        "content": "The problem is interesting, but why there are test cases such as [[], []] \\nand not a word about possible inputs expected output?\\n\\nIs it also a telepathy exercise?\\n"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Very annoying; they don\\'t seem to mention how the output is parsed; the result needs to be a ListNode or null.\\nFilter the list then go from there."
                    },
                    {
                        "username": "alistar",
                        "content": "With empty list it seems to expect an empty list as an output, however, it doest not accept it with type-error.\\nLitterally copied and pasted one of the official solutions, it doesn\\'t go through with the same issue!"
                    },
                    {
                        "username": "user9118TR",
                        "content": "[@amithshetty](/amithshetty)  Thaks a lot, how did you know it ??"
                    },
                    {
                        "username": "sony541",
                        "content": "[@amithshetty](/amithshetty) Well, if \"None\" is the end of list, you can think of \"None\" as an empty linked list, nice callout here... It took me a while to figure out, but sounds reasonable after all.. Could\\'ve been clarified in promt though."
                    },
                    {
                        "username": "amithshetty",
                        "content": "IT expects None, i.e not a list but an empty linked list"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-k-sorted-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Compare one by one\n\n  \n**Approach 3:** Optimize Approach 2 by Priority Queue\n\n  \n**Approach 4:** Merge lists one by one\n\n  \n**Approach 5:** Merge with Divide And Conquer\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Kouei",
                        "content": "The fastest C++ code can achieve a time about 370ms ~ 380ms\\n\\nwhile Python code can achieve 100ms, and even amazing, JAVA can do it in just 4ms !\\n\\nThis result is quite counterintuitive."
                    },
                    {
                        "username": "321maayan",
                        "content": "python is build in c and c is powerful as c++\\n"
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "[@Normalitee0os](/Normalitee0os)  post the code lol"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Mine took 15 ms using C++"
                    },
                    {
                        "username": "Normalitee0os",
                        "content": "Mine took 0.1 ms using HTML."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Mine took 23ms in C++"
                    },
                    {
                        "username": "slashtab",
                        "content": "OJ of LeetCode isn\\'t that perfect."
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "mine 22ms with c++; "
                    },
                    {
                        "username": "charonme",
                        "content": "35ms in PHP without using any built-in functions except count"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "mine was 40ms in c++, which could be further optimized"
                    },
                    {
                        "username": "f1rumors",
                        "content": "underlying libraries are a boon"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python...\\n\\nI assume that everyone realizes that without using ListNode that the solution to this problem is one line of code. Flatten the lists to one list and sort the list. \\n\\nWhy are there so many problems that have to be answered using ListNodes? It\\'s a complete waste of time in a language such as python. Shouldn\\'t the simplest solution be the best solution? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of `ListNode` or linked lists in algorithmic problems isn\\'t necessarily about finding the most efficient solution in Python or any specific language. Rather, it\\'s about teaching or testing certain concepts. Here are a few reasons:\\n\\n1. **Conceptual Understanding**: Using `ListNode` often helps in understanding how to manually manipulate pointers and nodes, which is crucial for a deep understanding of data structures.\\n\\n2. **Language Agnostic**: These problems are designed to be language-agnostic. While Python has easy list manipulation, languages like C or C++ do not have such built-in capabilities. The problem is set to be fair to everyone, regardless of the programming language used.\\n\\n3. **Algorithm Complexity**: Some problems require an in-depth understanding of algorithm complexity. Using built-in functions like `sort` can sometimes give a false sense of simplicity when, in fact, the actual task of merging the lists might be more complex.\\n\\n4. **Resource Utilization**: In some cases, especially in embedded systems or other resource-constrained environments, understanding how to work with nodes and pointers is essential for efficient memory usage.\\n\\n5. **Skill Assessment**: These problems are often used in interviews to assess understanding of fundamental computer science concepts, beyond syntactic sugar provided by specific programming languages.\\n\\n6. **Real-world Use Cases**: Not all data comes in simple, sorted, array-like structures. Linked lists, trees, and graphs are data structures commonly used in real-world applications. Understanding them is key to being a well-rounded developer.\\n\\n7. **Optimal Substructure**: Problems that mandate the use of data structures like linked lists often involve an optimal substructure that makes for an elegant solution, thereby teaching you problem-solving patterns that can be applied elsewhere.\\n\\n8. **Consistency**: If a problem was initially posed in a computer science paper or textbook using `ListNodes`, it\\'s often kept that way to maintain consistency with classic algorithm and data structure literature.\\n\\nSo while it may seem unnecessary or verbose, using `ListNode` provides a broader educational benefit, ensuring that you understand both high-level language features and low-level data structure manipulation."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go tell it on an interview :)"
                    },
                    {
                        "username": "Vantrashell",
                        "content": "[@mikael6767](/mikael6767) The goal should very rarely be to write the shortest amount of code. The 1 line solution typically uses a generalized algorithm, which may or may not be useful for what you wish to do. The problem forces ListNode as a guide to push in the direction it wants. Most of the solutions, although using ListNode, ignore this guide as the question very clearly wants a solution that does not create new memory as LinkedLists do not require such a complex operation for insertion. Ultimately, the point is (and why this is a hard problem and not a medium one like others have suggested) to do mergeKLists in O(1) space. The one line of Python most-likely does allocate new memory somewhere. If your customer pays for the amount of ram they use from a cloud service, they would be most pleased if you would keep that cost low."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Ok, @cartesPerforees, then explain why do we need ListNode if we can do this problem way easier without it. The goal is to make the solution with the shortest possible code. In this case 1 line, not 50. Imagine a customer wants you to make this problem: Merge K Sorted Lists. He doesn\\'t say how you need to do it, He just says to do it on python3. How would you do it? Would you write 50 lines of code using ListNode or one line of code. Please read and reply and we can discuss this later."
                    },
                    {
                        "username": "user5331Az",
                        "content": "bravo! dude, the task is for the ones familiar with algorithmic complexity concept at least, definitely not for you."
                    },
                    {
                        "username": "squigity",
                        "content": "[@mikael6767](/mikael6767)  Concept of linked lists is for a different scenario ,  the question here is to know if we understand linked lists or not and not to merge a sorted list from a list of lists"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your comment puzzles me. The whole point of those problems is to give you something to solve, and make it somewhat of a challenge depending on the difficulty tag. Most of the problems on leetcode are artificial and of no practical use, they are just made to help you practise probem solving.\\nI don\\'t get why you complain that they\\'re making things harder for you. That\\'s the point. It\\'s like playing with one of those chinese/japanes wooden brain teasers and  complaining that they should have designed it so that it opens like a normal box."
                    },
                    {
                        "username": "mikael6767",
                        "content": "I realize this. I am programming on python3 and really know that it really is one line of code, but the problem is with ListNode. There are a lot LeetCode problems with ListNode and I can\\'t make them even if they are very easy without it. I have the same problem. I wrote that one line of code and it says it is not right. I would really like for someone to help you, but I\\'m sorry I can\\'t."
                    },
                    {
                        "username": "David_E_something",
                        "content": "If you somehow use a priority queue (heap), this problem becomes very easy."
                    },
                    {
                        "username": "clinkz93",
                        "content": "[@layman806](/layman806) Using a priority queue results in a complexity of O((k + n) * log(k)) instead of O(n * log(n)), which may be preferrable."
                    },
                    {
                        "username": "root89",
                        "content": "[@layman806](/layman806) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@layman806](/layman806) lmao,, you can\\'t beat the interviewer."
                    },
                    {
                        "username": "layman806",
                        "content": "Or just parse all into an array in O(n) time, then sort it in O(n.log(n)) time and convert it to a linked list in O(n) time. This is just too easy to beat. Shouldn\\'t be tagged as hard."
                    },
                    {
                        "username": "JaviOverflow",
                        "content": "When I submit my solution, it fails on the input `[[]]`, how is that input even posible? `ListNode` requires `val` as argument in its constructor. Returning `None` doesn\\'t make the test pass. I\\'m not sure how to tackle that."
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "thenimator",
                        "content": "It\\'s been a while since you had this problem but for anyone else running into it:\\n\\n[[]] simply stands for an array with 1 element with that one element being a null pointer (which in this context stands for an empty linked list and not one where the value of the first element is missing)"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, WTF? ![image](https://assets.leetcode.com/users/beatrizdos/image_1570843047.png)\\n"
                    },
                    {
                        "username": "Will-O-Wisp",
                        "content": "class ListNode(object):\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\n\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        def mergeTwoLists(l1, l2):\\n            dummy = ListNode(0)\\n            current = dummy\\n\\n            while l1 and l2:\\n                if l1.val < l2.val:\\n                    current.next = l1\\n                    l1 = l1.next\\n                else:\\n                    current.next = l2\\n                    l2 = l2.next\\n                current = current.next\\n\\n            current.next = l1 if l1 else l2\\n\\n            return dummy.next\\n\\n        if not lists:\\n            return None\\n\\n        while len(lists) > 1:\\n            merged_lists = []\\n\\n            for i in range(0, len(lists), 2):\\n                l1 = lists[i]\\n                l2 = lists[i + 1] if i + 1 < len(lists) else None\\n                merged_lists.append(mergeTwoLists(l1, l2))\\n\\n            lists = merged_lists\\n\\n        return lists[0] if lists else None\\n\\n\\n# Example usage\\nlists = [\\n    ListNode(1, ListNode(4, ListNode(5))),\\n    ListNode(1, ListNode(3, ListNode(4))),\\n    ListNode(2, ListNode(6))\\n]\\n\\nsolution = Solution()\\nresult = solution.mergeKLists(lists)\\nwhile result:\\n    print(result.val)\\n    result = result.next\\n"
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "qin4",
                        "content": "Util class ListNode in python 3 is not completed. It can\\'t do heapq directly. Fix is easier on server side."
                    }
                ]
            },
            {
                "id": 1750039,
                "content": [
                    {
                        "username": "adambene",
                        "content": "This problem should not be marked as hard.\\nMedium is more proper based on the other problems on leetcode."
                    },
                    {
                        "username": "Pranjal_Bajpai",
                        "content": "i would say easy, its no brainer !"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cwooldridge](/cwooldridge)  POV: you solved your first HARD problem. "
                    },
                    {
                        "username": "jason3410",
                        "content": "[@Mister_CK](/Mister_CK) Cuz your solution make no connection with the ListNodes. And u won\\'t learn anything on this question."
                    },
                    {
                        "username": "user5331Az",
                        "content": "[@Mister_CK](/Mister_CK) putting an element into sorted array is O(log2(n)), sorting of an array is O(n^2) generally."
                    },
                    {
                        "username": "dhunmoon",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "[@cwooldridge](/cwooldridge) I almost started to think that i\\'m a hard problem solver and then I came here"
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Hey man, cmon, let me enjoy this moment\\uD83D\\uDE02"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It should be Easy imo. At least in JS there is no need to use a priority queue. You can just put all the values in an array, sort that array and put them in a list you then return. runs in 79 ms, beats 97% of solutions and it's the same answer as for the Easy problem `21. Merge Two Sorted Lists` (albeit that this is an array of lists, rather than just two, but it's the exact same principle). I really don't understand why this is marked with Hard and Priority Queue, really threw me off. I wrote a whole solution with a priority queue for an hour, only to realise it was completely unnecessary and I wrote a faster algorithm without it in 5 minutes. ([@joseph261059](/joseph261059) I tried using that, but I got an error on the node version (I believe it couldn't find insert), so I copied an implementation of a PriorityQueue using heap from stackoverflow) (PS: I checked, in regular Java it runs in 8 ms (beating only 28% of solutions), but that is still well within the accepted solution range.)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "[@Husoski](/Husoski) In JS, we can use PriorityQueue package in leetcode"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Well this still is hard problem as if go optimize your time complexity the solutions becomes more and more complex!"
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@Husoski](/Husoski) Indeed, but nobody uses programming languages like C in competitive programming. The most popular languages are C++, Java and Python. If there is no standard library with basic data structures like a `vector` or a `heap` in the programming language of your choice, you might want to use another language for the purpose of solving leetcode questions."
                    },
                    {
                        "username": "Husoski",
                        "content": "That depends on the language you used.  In a language with a standard heap or priority queue data structure this is indeed on the easy side of Medium.  I think it\\'s more like Hard in a language like C or JS.  (Assuming, of course, that the solver is going write the minheap code and not copy-paste it! :^)"
                    },
                    {
                        "username": "viocost",
                        "content": "The problem is interesting, but why there are test cases such as [[], []] \\nand not a word about possible inputs expected output?\\n\\nIs it also a telepathy exercise?\\n"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Very annoying; they don\\'t seem to mention how the output is parsed; the result needs to be a ListNode or null.\\nFilter the list then go from there."
                    },
                    {
                        "username": "alistar",
                        "content": "With empty list it seems to expect an empty list as an output, however, it doest not accept it with type-error.\\nLitterally copied and pasted one of the official solutions, it doesn\\'t go through with the same issue!"
                    },
                    {
                        "username": "user9118TR",
                        "content": "[@amithshetty](/amithshetty)  Thaks a lot, how did you know it ??"
                    },
                    {
                        "username": "sony541",
                        "content": "[@amithshetty](/amithshetty) Well, if \"None\" is the end of list, you can think of \"None\" as an empty linked list, nice callout here... It took me a while to figure out, but sounds reasonable after all.. Could\\'ve been clarified in promt though."
                    },
                    {
                        "username": "amithshetty",
                        "content": "IT expects None, i.e not a list but an empty linked list"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-k-sorted-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Compare one by one\n\n  \n**Approach 3:** Optimize Approach 2 by Priority Queue\n\n  \n**Approach 4:** Merge lists one by one\n\n  \n**Approach 5:** Merge with Divide And Conquer\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Kouei",
                        "content": "The fastest C++ code can achieve a time about 370ms ~ 380ms\\n\\nwhile Python code can achieve 100ms, and even amazing, JAVA can do it in just 4ms !\\n\\nThis result is quite counterintuitive."
                    },
                    {
                        "username": "321maayan",
                        "content": "python is build in c and c is powerful as c++\\n"
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "[@Normalitee0os](/Normalitee0os)  post the code lol"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Mine took 15 ms using C++"
                    },
                    {
                        "username": "Normalitee0os",
                        "content": "Mine took 0.1 ms using HTML."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Mine took 23ms in C++"
                    },
                    {
                        "username": "slashtab",
                        "content": "OJ of LeetCode isn\\'t that perfect."
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "mine 22ms with c++; "
                    },
                    {
                        "username": "charonme",
                        "content": "35ms in PHP without using any built-in functions except count"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "mine was 40ms in c++, which could be further optimized"
                    },
                    {
                        "username": "f1rumors",
                        "content": "underlying libraries are a boon"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python...\\n\\nI assume that everyone realizes that without using ListNode that the solution to this problem is one line of code. Flatten the lists to one list and sort the list. \\n\\nWhy are there so many problems that have to be answered using ListNodes? It\\'s a complete waste of time in a language such as python. Shouldn\\'t the simplest solution be the best solution? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of `ListNode` or linked lists in algorithmic problems isn\\'t necessarily about finding the most efficient solution in Python or any specific language. Rather, it\\'s about teaching or testing certain concepts. Here are a few reasons:\\n\\n1. **Conceptual Understanding**: Using `ListNode` often helps in understanding how to manually manipulate pointers and nodes, which is crucial for a deep understanding of data structures.\\n\\n2. **Language Agnostic**: These problems are designed to be language-agnostic. While Python has easy list manipulation, languages like C or C++ do not have such built-in capabilities. The problem is set to be fair to everyone, regardless of the programming language used.\\n\\n3. **Algorithm Complexity**: Some problems require an in-depth understanding of algorithm complexity. Using built-in functions like `sort` can sometimes give a false sense of simplicity when, in fact, the actual task of merging the lists might be more complex.\\n\\n4. **Resource Utilization**: In some cases, especially in embedded systems or other resource-constrained environments, understanding how to work with nodes and pointers is essential for efficient memory usage.\\n\\n5. **Skill Assessment**: These problems are often used in interviews to assess understanding of fundamental computer science concepts, beyond syntactic sugar provided by specific programming languages.\\n\\n6. **Real-world Use Cases**: Not all data comes in simple, sorted, array-like structures. Linked lists, trees, and graphs are data structures commonly used in real-world applications. Understanding them is key to being a well-rounded developer.\\n\\n7. **Optimal Substructure**: Problems that mandate the use of data structures like linked lists often involve an optimal substructure that makes for an elegant solution, thereby teaching you problem-solving patterns that can be applied elsewhere.\\n\\n8. **Consistency**: If a problem was initially posed in a computer science paper or textbook using `ListNodes`, it\\'s often kept that way to maintain consistency with classic algorithm and data structure literature.\\n\\nSo while it may seem unnecessary or verbose, using `ListNode` provides a broader educational benefit, ensuring that you understand both high-level language features and low-level data structure manipulation."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go tell it on an interview :)"
                    },
                    {
                        "username": "Vantrashell",
                        "content": "[@mikael6767](/mikael6767) The goal should very rarely be to write the shortest amount of code. The 1 line solution typically uses a generalized algorithm, which may or may not be useful for what you wish to do. The problem forces ListNode as a guide to push in the direction it wants. Most of the solutions, although using ListNode, ignore this guide as the question very clearly wants a solution that does not create new memory as LinkedLists do not require such a complex operation for insertion. Ultimately, the point is (and why this is a hard problem and not a medium one like others have suggested) to do mergeKLists in O(1) space. The one line of Python most-likely does allocate new memory somewhere. If your customer pays for the amount of ram they use from a cloud service, they would be most pleased if you would keep that cost low."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Ok, @cartesPerforees, then explain why do we need ListNode if we can do this problem way easier without it. The goal is to make the solution with the shortest possible code. In this case 1 line, not 50. Imagine a customer wants you to make this problem: Merge K Sorted Lists. He doesn\\'t say how you need to do it, He just says to do it on python3. How would you do it? Would you write 50 lines of code using ListNode or one line of code. Please read and reply and we can discuss this later."
                    },
                    {
                        "username": "user5331Az",
                        "content": "bravo! dude, the task is for the ones familiar with algorithmic complexity concept at least, definitely not for you."
                    },
                    {
                        "username": "squigity",
                        "content": "[@mikael6767](/mikael6767)  Concept of linked lists is for a different scenario ,  the question here is to know if we understand linked lists or not and not to merge a sorted list from a list of lists"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your comment puzzles me. The whole point of those problems is to give you something to solve, and make it somewhat of a challenge depending on the difficulty tag. Most of the problems on leetcode are artificial and of no practical use, they are just made to help you practise probem solving.\\nI don\\'t get why you complain that they\\'re making things harder for you. That\\'s the point. It\\'s like playing with one of those chinese/japanes wooden brain teasers and  complaining that they should have designed it so that it opens like a normal box."
                    },
                    {
                        "username": "mikael6767",
                        "content": "I realize this. I am programming on python3 and really know that it really is one line of code, but the problem is with ListNode. There are a lot LeetCode problems with ListNode and I can\\'t make them even if they are very easy without it. I have the same problem. I wrote that one line of code and it says it is not right. I would really like for someone to help you, but I\\'m sorry I can\\'t."
                    },
                    {
                        "username": "David_E_something",
                        "content": "If you somehow use a priority queue (heap), this problem becomes very easy."
                    },
                    {
                        "username": "clinkz93",
                        "content": "[@layman806](/layman806) Using a priority queue results in a complexity of O((k + n) * log(k)) instead of O(n * log(n)), which may be preferrable."
                    },
                    {
                        "username": "root89",
                        "content": "[@layman806](/layman806) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@layman806](/layman806) lmao,, you can\\'t beat the interviewer."
                    },
                    {
                        "username": "layman806",
                        "content": "Or just parse all into an array in O(n) time, then sort it in O(n.log(n)) time and convert it to a linked list in O(n) time. This is just too easy to beat. Shouldn\\'t be tagged as hard."
                    },
                    {
                        "username": "JaviOverflow",
                        "content": "When I submit my solution, it fails on the input `[[]]`, how is that input even posible? `ListNode` requires `val` as argument in its constructor. Returning `None` doesn\\'t make the test pass. I\\'m not sure how to tackle that."
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "thenimator",
                        "content": "It\\'s been a while since you had this problem but for anyone else running into it:\\n\\n[[]] simply stands for an array with 1 element with that one element being a null pointer (which in this context stands for an empty linked list and not one where the value of the first element is missing)"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, WTF? ![image](https://assets.leetcode.com/users/beatrizdos/image_1570843047.png)\\n"
                    },
                    {
                        "username": "Will-O-Wisp",
                        "content": "class ListNode(object):\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\n\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        def mergeTwoLists(l1, l2):\\n            dummy = ListNode(0)\\n            current = dummy\\n\\n            while l1 and l2:\\n                if l1.val < l2.val:\\n                    current.next = l1\\n                    l1 = l1.next\\n                else:\\n                    current.next = l2\\n                    l2 = l2.next\\n                current = current.next\\n\\n            current.next = l1 if l1 else l2\\n\\n            return dummy.next\\n\\n        if not lists:\\n            return None\\n\\n        while len(lists) > 1:\\n            merged_lists = []\\n\\n            for i in range(0, len(lists), 2):\\n                l1 = lists[i]\\n                l2 = lists[i + 1] if i + 1 < len(lists) else None\\n                merged_lists.append(mergeTwoLists(l1, l2))\\n\\n            lists = merged_lists\\n\\n        return lists[0] if lists else None\\n\\n\\n# Example usage\\nlists = [\\n    ListNode(1, ListNode(4, ListNode(5))),\\n    ListNode(1, ListNode(3, ListNode(4))),\\n    ListNode(2, ListNode(6))\\n]\\n\\nsolution = Solution()\\nresult = solution.mergeKLists(lists)\\nwhile result:\\n    print(result.val)\\n    result = result.next\\n"
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "qin4",
                        "content": "Util class ListNode in python 3 is not completed. It can\\'t do heapq directly. Fix is easier on server side."
                    }
                ]
            },
            {
                "id": 1569749,
                "content": [
                    {
                        "username": "adambene",
                        "content": "This problem should not be marked as hard.\\nMedium is more proper based on the other problems on leetcode."
                    },
                    {
                        "username": "Pranjal_Bajpai",
                        "content": "i would say easy, its no brainer !"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cwooldridge](/cwooldridge)  POV: you solved your first HARD problem. "
                    },
                    {
                        "username": "jason3410",
                        "content": "[@Mister_CK](/Mister_CK) Cuz your solution make no connection with the ListNodes. And u won\\'t learn anything on this question."
                    },
                    {
                        "username": "user5331Az",
                        "content": "[@Mister_CK](/Mister_CK) putting an element into sorted array is O(log2(n)), sorting of an array is O(n^2) generally."
                    },
                    {
                        "username": "dhunmoon",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "[@cwooldridge](/cwooldridge) I almost started to think that i\\'m a hard problem solver and then I came here"
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Hey man, cmon, let me enjoy this moment\\uD83D\\uDE02"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It should be Easy imo. At least in JS there is no need to use a priority queue. You can just put all the values in an array, sort that array and put them in a list you then return. runs in 79 ms, beats 97% of solutions and it's the same answer as for the Easy problem `21. Merge Two Sorted Lists` (albeit that this is an array of lists, rather than just two, but it's the exact same principle). I really don't understand why this is marked with Hard and Priority Queue, really threw me off. I wrote a whole solution with a priority queue for an hour, only to realise it was completely unnecessary and I wrote a faster algorithm without it in 5 minutes. ([@joseph261059](/joseph261059) I tried using that, but I got an error on the node version (I believe it couldn't find insert), so I copied an implementation of a PriorityQueue using heap from stackoverflow) (PS: I checked, in regular Java it runs in 8 ms (beating only 28% of solutions), but that is still well within the accepted solution range.)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "[@Husoski](/Husoski) In JS, we can use PriorityQueue package in leetcode"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Well this still is hard problem as if go optimize your time complexity the solutions becomes more and more complex!"
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@Husoski](/Husoski) Indeed, but nobody uses programming languages like C in competitive programming. The most popular languages are C++, Java and Python. If there is no standard library with basic data structures like a `vector` or a `heap` in the programming language of your choice, you might want to use another language for the purpose of solving leetcode questions."
                    },
                    {
                        "username": "Husoski",
                        "content": "That depends on the language you used.  In a language with a standard heap or priority queue data structure this is indeed on the easy side of Medium.  I think it\\'s more like Hard in a language like C or JS.  (Assuming, of course, that the solver is going write the minheap code and not copy-paste it! :^)"
                    },
                    {
                        "username": "viocost",
                        "content": "The problem is interesting, but why there are test cases such as [[], []] \\nand not a word about possible inputs expected output?\\n\\nIs it also a telepathy exercise?\\n"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Very annoying; they don\\'t seem to mention how the output is parsed; the result needs to be a ListNode or null.\\nFilter the list then go from there."
                    },
                    {
                        "username": "alistar",
                        "content": "With empty list it seems to expect an empty list as an output, however, it doest not accept it with type-error.\\nLitterally copied and pasted one of the official solutions, it doesn\\'t go through with the same issue!"
                    },
                    {
                        "username": "user9118TR",
                        "content": "[@amithshetty](/amithshetty)  Thaks a lot, how did you know it ??"
                    },
                    {
                        "username": "sony541",
                        "content": "[@amithshetty](/amithshetty) Well, if \"None\" is the end of list, you can think of \"None\" as an empty linked list, nice callout here... It took me a while to figure out, but sounds reasonable after all.. Could\\'ve been clarified in promt though."
                    },
                    {
                        "username": "amithshetty",
                        "content": "IT expects None, i.e not a list but an empty linked list"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-k-sorted-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Compare one by one\n\n  \n**Approach 3:** Optimize Approach 2 by Priority Queue\n\n  \n**Approach 4:** Merge lists one by one\n\n  \n**Approach 5:** Merge with Divide And Conquer\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Kouei",
                        "content": "The fastest C++ code can achieve a time about 370ms ~ 380ms\\n\\nwhile Python code can achieve 100ms, and even amazing, JAVA can do it in just 4ms !\\n\\nThis result is quite counterintuitive."
                    },
                    {
                        "username": "321maayan",
                        "content": "python is build in c and c is powerful as c++\\n"
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "[@Normalitee0os](/Normalitee0os)  post the code lol"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Mine took 15 ms using C++"
                    },
                    {
                        "username": "Normalitee0os",
                        "content": "Mine took 0.1 ms using HTML."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Mine took 23ms in C++"
                    },
                    {
                        "username": "slashtab",
                        "content": "OJ of LeetCode isn\\'t that perfect."
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "mine 22ms with c++; "
                    },
                    {
                        "username": "charonme",
                        "content": "35ms in PHP without using any built-in functions except count"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "mine was 40ms in c++, which could be further optimized"
                    },
                    {
                        "username": "f1rumors",
                        "content": "underlying libraries are a boon"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python...\\n\\nI assume that everyone realizes that without using ListNode that the solution to this problem is one line of code. Flatten the lists to one list and sort the list. \\n\\nWhy are there so many problems that have to be answered using ListNodes? It\\'s a complete waste of time in a language such as python. Shouldn\\'t the simplest solution be the best solution? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of `ListNode` or linked lists in algorithmic problems isn\\'t necessarily about finding the most efficient solution in Python or any specific language. Rather, it\\'s about teaching or testing certain concepts. Here are a few reasons:\\n\\n1. **Conceptual Understanding**: Using `ListNode` often helps in understanding how to manually manipulate pointers and nodes, which is crucial for a deep understanding of data structures.\\n\\n2. **Language Agnostic**: These problems are designed to be language-agnostic. While Python has easy list manipulation, languages like C or C++ do not have such built-in capabilities. The problem is set to be fair to everyone, regardless of the programming language used.\\n\\n3. **Algorithm Complexity**: Some problems require an in-depth understanding of algorithm complexity. Using built-in functions like `sort` can sometimes give a false sense of simplicity when, in fact, the actual task of merging the lists might be more complex.\\n\\n4. **Resource Utilization**: In some cases, especially in embedded systems or other resource-constrained environments, understanding how to work with nodes and pointers is essential for efficient memory usage.\\n\\n5. **Skill Assessment**: These problems are often used in interviews to assess understanding of fundamental computer science concepts, beyond syntactic sugar provided by specific programming languages.\\n\\n6. **Real-world Use Cases**: Not all data comes in simple, sorted, array-like structures. Linked lists, trees, and graphs are data structures commonly used in real-world applications. Understanding them is key to being a well-rounded developer.\\n\\n7. **Optimal Substructure**: Problems that mandate the use of data structures like linked lists often involve an optimal substructure that makes for an elegant solution, thereby teaching you problem-solving patterns that can be applied elsewhere.\\n\\n8. **Consistency**: If a problem was initially posed in a computer science paper or textbook using `ListNodes`, it\\'s often kept that way to maintain consistency with classic algorithm and data structure literature.\\n\\nSo while it may seem unnecessary or verbose, using `ListNode` provides a broader educational benefit, ensuring that you understand both high-level language features and low-level data structure manipulation."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go tell it on an interview :)"
                    },
                    {
                        "username": "Vantrashell",
                        "content": "[@mikael6767](/mikael6767) The goal should very rarely be to write the shortest amount of code. The 1 line solution typically uses a generalized algorithm, which may or may not be useful for what you wish to do. The problem forces ListNode as a guide to push in the direction it wants. Most of the solutions, although using ListNode, ignore this guide as the question very clearly wants a solution that does not create new memory as LinkedLists do not require such a complex operation for insertion. Ultimately, the point is (and why this is a hard problem and not a medium one like others have suggested) to do mergeKLists in O(1) space. The one line of Python most-likely does allocate new memory somewhere. If your customer pays for the amount of ram they use from a cloud service, they would be most pleased if you would keep that cost low."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Ok, @cartesPerforees, then explain why do we need ListNode if we can do this problem way easier without it. The goal is to make the solution with the shortest possible code. In this case 1 line, not 50. Imagine a customer wants you to make this problem: Merge K Sorted Lists. He doesn\\'t say how you need to do it, He just says to do it on python3. How would you do it? Would you write 50 lines of code using ListNode or one line of code. Please read and reply and we can discuss this later."
                    },
                    {
                        "username": "user5331Az",
                        "content": "bravo! dude, the task is for the ones familiar with algorithmic complexity concept at least, definitely not for you."
                    },
                    {
                        "username": "squigity",
                        "content": "[@mikael6767](/mikael6767)  Concept of linked lists is for a different scenario ,  the question here is to know if we understand linked lists or not and not to merge a sorted list from a list of lists"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your comment puzzles me. The whole point of those problems is to give you something to solve, and make it somewhat of a challenge depending on the difficulty tag. Most of the problems on leetcode are artificial and of no practical use, they are just made to help you practise probem solving.\\nI don\\'t get why you complain that they\\'re making things harder for you. That\\'s the point. It\\'s like playing with one of those chinese/japanes wooden brain teasers and  complaining that they should have designed it so that it opens like a normal box."
                    },
                    {
                        "username": "mikael6767",
                        "content": "I realize this. I am programming on python3 and really know that it really is one line of code, but the problem is with ListNode. There are a lot LeetCode problems with ListNode and I can\\'t make them even if they are very easy without it. I have the same problem. I wrote that one line of code and it says it is not right. I would really like for someone to help you, but I\\'m sorry I can\\'t."
                    },
                    {
                        "username": "David_E_something",
                        "content": "If you somehow use a priority queue (heap), this problem becomes very easy."
                    },
                    {
                        "username": "clinkz93",
                        "content": "[@layman806](/layman806) Using a priority queue results in a complexity of O((k + n) * log(k)) instead of O(n * log(n)), which may be preferrable."
                    },
                    {
                        "username": "root89",
                        "content": "[@layman806](/layman806) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@layman806](/layman806) lmao,, you can\\'t beat the interviewer."
                    },
                    {
                        "username": "layman806",
                        "content": "Or just parse all into an array in O(n) time, then sort it in O(n.log(n)) time and convert it to a linked list in O(n) time. This is just too easy to beat. Shouldn\\'t be tagged as hard."
                    },
                    {
                        "username": "JaviOverflow",
                        "content": "When I submit my solution, it fails on the input `[[]]`, how is that input even posible? `ListNode` requires `val` as argument in its constructor. Returning `None` doesn\\'t make the test pass. I\\'m not sure how to tackle that."
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "thenimator",
                        "content": "It\\'s been a while since you had this problem but for anyone else running into it:\\n\\n[[]] simply stands for an array with 1 element with that one element being a null pointer (which in this context stands for an empty linked list and not one where the value of the first element is missing)"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, WTF? ![image](https://assets.leetcode.com/users/beatrizdos/image_1570843047.png)\\n"
                    },
                    {
                        "username": "Will-O-Wisp",
                        "content": "class ListNode(object):\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\n\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        def mergeTwoLists(l1, l2):\\n            dummy = ListNode(0)\\n            current = dummy\\n\\n            while l1 and l2:\\n                if l1.val < l2.val:\\n                    current.next = l1\\n                    l1 = l1.next\\n                else:\\n                    current.next = l2\\n                    l2 = l2.next\\n                current = current.next\\n\\n            current.next = l1 if l1 else l2\\n\\n            return dummy.next\\n\\n        if not lists:\\n            return None\\n\\n        while len(lists) > 1:\\n            merged_lists = []\\n\\n            for i in range(0, len(lists), 2):\\n                l1 = lists[i]\\n                l2 = lists[i + 1] if i + 1 < len(lists) else None\\n                merged_lists.append(mergeTwoLists(l1, l2))\\n\\n            lists = merged_lists\\n\\n        return lists[0] if lists else None\\n\\n\\n# Example usage\\nlists = [\\n    ListNode(1, ListNode(4, ListNode(5))),\\n    ListNode(1, ListNode(3, ListNode(4))),\\n    ListNode(2, ListNode(6))\\n]\\n\\nsolution = Solution()\\nresult = solution.mergeKLists(lists)\\nwhile result:\\n    print(result.val)\\n    result = result.next\\n"
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "qin4",
                        "content": "Util class ListNode in python 3 is not completed. It can\\'t do heapq directly. Fix is easier on server side."
                    }
                ]
            },
            {
                "id": 1569647,
                "content": [
                    {
                        "username": "adambene",
                        "content": "This problem should not be marked as hard.\\nMedium is more proper based on the other problems on leetcode."
                    },
                    {
                        "username": "Pranjal_Bajpai",
                        "content": "i would say easy, its no brainer !"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cwooldridge](/cwooldridge)  POV: you solved your first HARD problem. "
                    },
                    {
                        "username": "jason3410",
                        "content": "[@Mister_CK](/Mister_CK) Cuz your solution make no connection with the ListNodes. And u won\\'t learn anything on this question."
                    },
                    {
                        "username": "user5331Az",
                        "content": "[@Mister_CK](/Mister_CK) putting an element into sorted array is O(log2(n)), sorting of an array is O(n^2) generally."
                    },
                    {
                        "username": "dhunmoon",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "[@cwooldridge](/cwooldridge) I almost started to think that i\\'m a hard problem solver and then I came here"
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Hey man, cmon, let me enjoy this moment\\uD83D\\uDE02"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It should be Easy imo. At least in JS there is no need to use a priority queue. You can just put all the values in an array, sort that array and put them in a list you then return. runs in 79 ms, beats 97% of solutions and it's the same answer as for the Easy problem `21. Merge Two Sorted Lists` (albeit that this is an array of lists, rather than just two, but it's the exact same principle). I really don't understand why this is marked with Hard and Priority Queue, really threw me off. I wrote a whole solution with a priority queue for an hour, only to realise it was completely unnecessary and I wrote a faster algorithm without it in 5 minutes. ([@joseph261059](/joseph261059) I tried using that, but I got an error on the node version (I believe it couldn't find insert), so I copied an implementation of a PriorityQueue using heap from stackoverflow) (PS: I checked, in regular Java it runs in 8 ms (beating only 28% of solutions), but that is still well within the accepted solution range.)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "[@Husoski](/Husoski) In JS, we can use PriorityQueue package in leetcode"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Well this still is hard problem as if go optimize your time complexity the solutions becomes more and more complex!"
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@Husoski](/Husoski) Indeed, but nobody uses programming languages like C in competitive programming. The most popular languages are C++, Java and Python. If there is no standard library with basic data structures like a `vector` or a `heap` in the programming language of your choice, you might want to use another language for the purpose of solving leetcode questions."
                    },
                    {
                        "username": "Husoski",
                        "content": "That depends on the language you used.  In a language with a standard heap or priority queue data structure this is indeed on the easy side of Medium.  I think it\\'s more like Hard in a language like C or JS.  (Assuming, of course, that the solver is going write the minheap code and not copy-paste it! :^)"
                    },
                    {
                        "username": "viocost",
                        "content": "The problem is interesting, but why there are test cases such as [[], []] \\nand not a word about possible inputs expected output?\\n\\nIs it also a telepathy exercise?\\n"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Very annoying; they don\\'t seem to mention how the output is parsed; the result needs to be a ListNode or null.\\nFilter the list then go from there."
                    },
                    {
                        "username": "alistar",
                        "content": "With empty list it seems to expect an empty list as an output, however, it doest not accept it with type-error.\\nLitterally copied and pasted one of the official solutions, it doesn\\'t go through with the same issue!"
                    },
                    {
                        "username": "user9118TR",
                        "content": "[@amithshetty](/amithshetty)  Thaks a lot, how did you know it ??"
                    },
                    {
                        "username": "sony541",
                        "content": "[@amithshetty](/amithshetty) Well, if \"None\" is the end of list, you can think of \"None\" as an empty linked list, nice callout here... It took me a while to figure out, but sounds reasonable after all.. Could\\'ve been clarified in promt though."
                    },
                    {
                        "username": "amithshetty",
                        "content": "IT expects None, i.e not a list but an empty linked list"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-k-sorted-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Compare one by one\n\n  \n**Approach 3:** Optimize Approach 2 by Priority Queue\n\n  \n**Approach 4:** Merge lists one by one\n\n  \n**Approach 5:** Merge with Divide And Conquer\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Kouei",
                        "content": "The fastest C++ code can achieve a time about 370ms ~ 380ms\\n\\nwhile Python code can achieve 100ms, and even amazing, JAVA can do it in just 4ms !\\n\\nThis result is quite counterintuitive."
                    },
                    {
                        "username": "321maayan",
                        "content": "python is build in c and c is powerful as c++\\n"
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "[@Normalitee0os](/Normalitee0os)  post the code lol"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Mine took 15 ms using C++"
                    },
                    {
                        "username": "Normalitee0os",
                        "content": "Mine took 0.1 ms using HTML."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Mine took 23ms in C++"
                    },
                    {
                        "username": "slashtab",
                        "content": "OJ of LeetCode isn\\'t that perfect."
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "mine 22ms with c++; "
                    },
                    {
                        "username": "charonme",
                        "content": "35ms in PHP without using any built-in functions except count"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "mine was 40ms in c++, which could be further optimized"
                    },
                    {
                        "username": "f1rumors",
                        "content": "underlying libraries are a boon"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python...\\n\\nI assume that everyone realizes that without using ListNode that the solution to this problem is one line of code. Flatten the lists to one list and sort the list. \\n\\nWhy are there so many problems that have to be answered using ListNodes? It\\'s a complete waste of time in a language such as python. Shouldn\\'t the simplest solution be the best solution? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of `ListNode` or linked lists in algorithmic problems isn\\'t necessarily about finding the most efficient solution in Python or any specific language. Rather, it\\'s about teaching or testing certain concepts. Here are a few reasons:\\n\\n1. **Conceptual Understanding**: Using `ListNode` often helps in understanding how to manually manipulate pointers and nodes, which is crucial for a deep understanding of data structures.\\n\\n2. **Language Agnostic**: These problems are designed to be language-agnostic. While Python has easy list manipulation, languages like C or C++ do not have such built-in capabilities. The problem is set to be fair to everyone, regardless of the programming language used.\\n\\n3. **Algorithm Complexity**: Some problems require an in-depth understanding of algorithm complexity. Using built-in functions like `sort` can sometimes give a false sense of simplicity when, in fact, the actual task of merging the lists might be more complex.\\n\\n4. **Resource Utilization**: In some cases, especially in embedded systems or other resource-constrained environments, understanding how to work with nodes and pointers is essential for efficient memory usage.\\n\\n5. **Skill Assessment**: These problems are often used in interviews to assess understanding of fundamental computer science concepts, beyond syntactic sugar provided by specific programming languages.\\n\\n6. **Real-world Use Cases**: Not all data comes in simple, sorted, array-like structures. Linked lists, trees, and graphs are data structures commonly used in real-world applications. Understanding them is key to being a well-rounded developer.\\n\\n7. **Optimal Substructure**: Problems that mandate the use of data structures like linked lists often involve an optimal substructure that makes for an elegant solution, thereby teaching you problem-solving patterns that can be applied elsewhere.\\n\\n8. **Consistency**: If a problem was initially posed in a computer science paper or textbook using `ListNodes`, it\\'s often kept that way to maintain consistency with classic algorithm and data structure literature.\\n\\nSo while it may seem unnecessary or verbose, using `ListNode` provides a broader educational benefit, ensuring that you understand both high-level language features and low-level data structure manipulation."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go tell it on an interview :)"
                    },
                    {
                        "username": "Vantrashell",
                        "content": "[@mikael6767](/mikael6767) The goal should very rarely be to write the shortest amount of code. The 1 line solution typically uses a generalized algorithm, which may or may not be useful for what you wish to do. The problem forces ListNode as a guide to push in the direction it wants. Most of the solutions, although using ListNode, ignore this guide as the question very clearly wants a solution that does not create new memory as LinkedLists do not require such a complex operation for insertion. Ultimately, the point is (and why this is a hard problem and not a medium one like others have suggested) to do mergeKLists in O(1) space. The one line of Python most-likely does allocate new memory somewhere. If your customer pays for the amount of ram they use from a cloud service, they would be most pleased if you would keep that cost low."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Ok, @cartesPerforees, then explain why do we need ListNode if we can do this problem way easier without it. The goal is to make the solution with the shortest possible code. In this case 1 line, not 50. Imagine a customer wants you to make this problem: Merge K Sorted Lists. He doesn\\'t say how you need to do it, He just says to do it on python3. How would you do it? Would you write 50 lines of code using ListNode or one line of code. Please read and reply and we can discuss this later."
                    },
                    {
                        "username": "user5331Az",
                        "content": "bravo! dude, the task is for the ones familiar with algorithmic complexity concept at least, definitely not for you."
                    },
                    {
                        "username": "squigity",
                        "content": "[@mikael6767](/mikael6767)  Concept of linked lists is for a different scenario ,  the question here is to know if we understand linked lists or not and not to merge a sorted list from a list of lists"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your comment puzzles me. The whole point of those problems is to give you something to solve, and make it somewhat of a challenge depending on the difficulty tag. Most of the problems on leetcode are artificial and of no practical use, they are just made to help you practise probem solving.\\nI don\\'t get why you complain that they\\'re making things harder for you. That\\'s the point. It\\'s like playing with one of those chinese/japanes wooden brain teasers and  complaining that they should have designed it so that it opens like a normal box."
                    },
                    {
                        "username": "mikael6767",
                        "content": "I realize this. I am programming on python3 and really know that it really is one line of code, but the problem is with ListNode. There are a lot LeetCode problems with ListNode and I can\\'t make them even if they are very easy without it. I have the same problem. I wrote that one line of code and it says it is not right. I would really like for someone to help you, but I\\'m sorry I can\\'t."
                    },
                    {
                        "username": "David_E_something",
                        "content": "If you somehow use a priority queue (heap), this problem becomes very easy."
                    },
                    {
                        "username": "clinkz93",
                        "content": "[@layman806](/layman806) Using a priority queue results in a complexity of O((k + n) * log(k)) instead of O(n * log(n)), which may be preferrable."
                    },
                    {
                        "username": "root89",
                        "content": "[@layman806](/layman806) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@layman806](/layman806) lmao,, you can\\'t beat the interviewer."
                    },
                    {
                        "username": "layman806",
                        "content": "Or just parse all into an array in O(n) time, then sort it in O(n.log(n)) time and convert it to a linked list in O(n) time. This is just too easy to beat. Shouldn\\'t be tagged as hard."
                    },
                    {
                        "username": "JaviOverflow",
                        "content": "When I submit my solution, it fails on the input `[[]]`, how is that input even posible? `ListNode` requires `val` as argument in its constructor. Returning `None` doesn\\'t make the test pass. I\\'m not sure how to tackle that."
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "thenimator",
                        "content": "It\\'s been a while since you had this problem but for anyone else running into it:\\n\\n[[]] simply stands for an array with 1 element with that one element being a null pointer (which in this context stands for an empty linked list and not one where the value of the first element is missing)"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, WTF? ![image](https://assets.leetcode.com/users/beatrizdos/image_1570843047.png)\\n"
                    },
                    {
                        "username": "Will-O-Wisp",
                        "content": "class ListNode(object):\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\n\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        def mergeTwoLists(l1, l2):\\n            dummy = ListNode(0)\\n            current = dummy\\n\\n            while l1 and l2:\\n                if l1.val < l2.val:\\n                    current.next = l1\\n                    l1 = l1.next\\n                else:\\n                    current.next = l2\\n                    l2 = l2.next\\n                current = current.next\\n\\n            current.next = l1 if l1 else l2\\n\\n            return dummy.next\\n\\n        if not lists:\\n            return None\\n\\n        while len(lists) > 1:\\n            merged_lists = []\\n\\n            for i in range(0, len(lists), 2):\\n                l1 = lists[i]\\n                l2 = lists[i + 1] if i + 1 < len(lists) else None\\n                merged_lists.append(mergeTwoLists(l1, l2))\\n\\n            lists = merged_lists\\n\\n        return lists[0] if lists else None\\n\\n\\n# Example usage\\nlists = [\\n    ListNode(1, ListNode(4, ListNode(5))),\\n    ListNode(1, ListNode(3, ListNode(4))),\\n    ListNode(2, ListNode(6))\\n]\\n\\nsolution = Solution()\\nresult = solution.mergeKLists(lists)\\nwhile result:\\n    print(result.val)\\n    result = result.next\\n"
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "qin4",
                        "content": "Util class ListNode in python 3 is not completed. It can\\'t do heapq directly. Fix is easier on server side."
                    }
                ]
            },
            {
                "id": 1568012,
                "content": [
                    {
                        "username": "adambene",
                        "content": "This problem should not be marked as hard.\\nMedium is more proper based on the other problems on leetcode."
                    },
                    {
                        "username": "Pranjal_Bajpai",
                        "content": "i would say easy, its no brainer !"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "[@cwooldridge](/cwooldridge)  POV: you solved your first HARD problem. "
                    },
                    {
                        "username": "jason3410",
                        "content": "[@Mister_CK](/Mister_CK) Cuz your solution make no connection with the ListNodes. And u won\\'t learn anything on this question."
                    },
                    {
                        "username": "user5331Az",
                        "content": "[@Mister_CK](/Mister_CK) putting an element into sorted array is O(log2(n)), sorting of an array is O(n^2) generally."
                    },
                    {
                        "username": "dhunmoon",
                        "content": "Agreed\\n"
                    },
                    {
                        "username": "Msey",
                        "content": "[@cwooldridge](/cwooldridge) I almost started to think that i\\'m a hard problem solver and then I came here"
                    },
                    {
                        "username": "cwooldridge",
                        "content": "Hey man, cmon, let me enjoy this moment\\uD83D\\uDE02"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "It should be Easy imo. At least in JS there is no need to use a priority queue. You can just put all the values in an array, sort that array and put them in a list you then return. runs in 79 ms, beats 97% of solutions and it's the same answer as for the Easy problem `21. Merge Two Sorted Lists` (albeit that this is an array of lists, rather than just two, but it's the exact same principle). I really don't understand why this is marked with Hard and Priority Queue, really threw me off. I wrote a whole solution with a priority queue for an hour, only to realise it was completely unnecessary and I wrote a faster algorithm without it in 5 minutes. ([@joseph261059](/joseph261059) I tried using that, but I got an error on the node version (I believe it couldn't find insert), so I copied an implementation of a PriorityQueue using heap from stackoverflow) (PS: I checked, in regular Java it runs in 8 ms (beating only 28% of solutions), but that is still well within the accepted solution range.)"
                    },
                    {
                        "username": "joseph261059",
                        "content": "[@Husoski](/Husoski) In JS, we can use PriorityQueue package in leetcode"
                    },
                    {
                        "username": "ajaygonepuri",
                        "content": "Well this still is hard problem as if go optimize your time complexity the solutions becomes more and more complex!"
                    },
                    {
                        "username": "Diamantis",
                        "content": "[@Husoski](/Husoski) Indeed, but nobody uses programming languages like C in competitive programming. The most popular languages are C++, Java and Python. If there is no standard library with basic data structures like a `vector` or a `heap` in the programming language of your choice, you might want to use another language for the purpose of solving leetcode questions."
                    },
                    {
                        "username": "Husoski",
                        "content": "That depends on the language you used.  In a language with a standard heap or priority queue data structure this is indeed on the easy side of Medium.  I think it\\'s more like Hard in a language like C or JS.  (Assuming, of course, that the solver is going write the minheap code and not copy-paste it! :^)"
                    },
                    {
                        "username": "viocost",
                        "content": "The problem is interesting, but why there are test cases such as [[], []] \\nand not a word about possible inputs expected output?\\n\\nIs it also a telepathy exercise?\\n"
                    },
                    {
                        "username": "cyjackx",
                        "content": "Very annoying; they don\\'t seem to mention how the output is parsed; the result needs to be a ListNode or null.\\nFilter the list then go from there."
                    },
                    {
                        "username": "alistar",
                        "content": "With empty list it seems to expect an empty list as an output, however, it doest not accept it with type-error.\\nLitterally copied and pasted one of the official solutions, it doesn\\'t go through with the same issue!"
                    },
                    {
                        "username": "user9118TR",
                        "content": "[@amithshetty](/amithshetty)  Thaks a lot, how did you know it ??"
                    },
                    {
                        "username": "sony541",
                        "content": "[@amithshetty](/amithshetty) Well, if \"None\" is the end of list, you can think of \"None\" as an empty linked list, nice callout here... It took me a while to figure out, but sounds reasonable after all.. Could\\'ve been clarified in promt though."
                    },
                    {
                        "username": "amithshetty",
                        "content": "IT expects None, i.e not a list but an empty linked list"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/merge-k-sorted-lists/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Compare one by one\n\n  \n**Approach 3:** Optimize Approach 2 by Priority Queue\n\n  \n**Approach 4:** Merge lists one by one\n\n  \n**Approach 5:** Merge with Divide And Conquer\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Kouei",
                        "content": "The fastest C++ code can achieve a time about 370ms ~ 380ms\\n\\nwhile Python code can achieve 100ms, and even amazing, JAVA can do it in just 4ms !\\n\\nThis result is quite counterintuitive."
                    },
                    {
                        "username": "321maayan",
                        "content": "python is build in c and c is powerful as c++\\n"
                    },
                    {
                        "username": "Abhijeet21o9",
                        "content": "[@Normalitee0os](/Normalitee0os)  post the code lol"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Mine took 15 ms using C++"
                    },
                    {
                        "username": "Normalitee0os",
                        "content": "Mine took 0.1 ms using HTML."
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Mine took 23ms in C++"
                    },
                    {
                        "username": "slashtab",
                        "content": "OJ of LeetCode isn\\'t that perfect."
                    },
                    {
                        "username": "lakshyasinghchouhan2509",
                        "content": "mine 22ms with c++; "
                    },
                    {
                        "username": "charonme",
                        "content": "35ms in PHP without using any built-in functions except count"
                    },
                    {
                        "username": "Filthy_Toad",
                        "content": "mine was 40ms in c++, which could be further optimized"
                    },
                    {
                        "username": "f1rumors",
                        "content": "underlying libraries are a boon"
                    },
                    {
                        "username": "PBK320",
                        "content": "Python...\\n\\nI assume that everyone realizes that without using ListNode that the solution to this problem is one line of code. Flatten the lists to one list and sort the list. \\n\\nWhy are there so many problems that have to be answered using ListNodes? It\\'s a complete waste of time in a language such as python. Shouldn\\'t the simplest solution be the best solution? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The use of `ListNode` or linked lists in algorithmic problems isn\\'t necessarily about finding the most efficient solution in Python or any specific language. Rather, it\\'s about teaching or testing certain concepts. Here are a few reasons:\\n\\n1. **Conceptual Understanding**: Using `ListNode` often helps in understanding how to manually manipulate pointers and nodes, which is crucial for a deep understanding of data structures.\\n\\n2. **Language Agnostic**: These problems are designed to be language-agnostic. While Python has easy list manipulation, languages like C or C++ do not have such built-in capabilities. The problem is set to be fair to everyone, regardless of the programming language used.\\n\\n3. **Algorithm Complexity**: Some problems require an in-depth understanding of algorithm complexity. Using built-in functions like `sort` can sometimes give a false sense of simplicity when, in fact, the actual task of merging the lists might be more complex.\\n\\n4. **Resource Utilization**: In some cases, especially in embedded systems or other resource-constrained environments, understanding how to work with nodes and pointers is essential for efficient memory usage.\\n\\n5. **Skill Assessment**: These problems are often used in interviews to assess understanding of fundamental computer science concepts, beyond syntactic sugar provided by specific programming languages.\\n\\n6. **Real-world Use Cases**: Not all data comes in simple, sorted, array-like structures. Linked lists, trees, and graphs are data structures commonly used in real-world applications. Understanding them is key to being a well-rounded developer.\\n\\n7. **Optimal Substructure**: Problems that mandate the use of data structures like linked lists often involve an optimal substructure that makes for an elegant solution, thereby teaching you problem-solving patterns that can be applied elsewhere.\\n\\n8. **Consistency**: If a problem was initially posed in a computer science paper or textbook using `ListNodes`, it\\'s often kept that way to maintain consistency with classic algorithm and data structure literature.\\n\\nSo while it may seem unnecessary or verbose, using `ListNode` provides a broader educational benefit, ensuring that you understand both high-level language features and low-level data structure manipulation."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Go tell it on an interview :)"
                    },
                    {
                        "username": "Vantrashell",
                        "content": "[@mikael6767](/mikael6767) The goal should very rarely be to write the shortest amount of code. The 1 line solution typically uses a generalized algorithm, which may or may not be useful for what you wish to do. The problem forces ListNode as a guide to push in the direction it wants. Most of the solutions, although using ListNode, ignore this guide as the question very clearly wants a solution that does not create new memory as LinkedLists do not require such a complex operation for insertion. Ultimately, the point is (and why this is a hard problem and not a medium one like others have suggested) to do mergeKLists in O(1) space. The one line of Python most-likely does allocate new memory somewhere. If your customer pays for the amount of ram they use from a cloud service, they would be most pleased if you would keep that cost low."
                    },
                    {
                        "username": "mikael6767",
                        "content": "Ok, @cartesPerforees, then explain why do we need ListNode if we can do this problem way easier without it. The goal is to make the solution with the shortest possible code. In this case 1 line, not 50. Imagine a customer wants you to make this problem: Merge K Sorted Lists. He doesn\\'t say how you need to do it, He just says to do it on python3. How would you do it? Would you write 50 lines of code using ListNode or one line of code. Please read and reply and we can discuss this later."
                    },
                    {
                        "username": "user5331Az",
                        "content": "bravo! dude, the task is for the ones familiar with algorithmic complexity concept at least, definitely not for you."
                    },
                    {
                        "username": "squigity",
                        "content": "[@mikael6767](/mikael6767)  Concept of linked lists is for a different scenario ,  the question here is to know if we understand linked lists or not and not to merge a sorted list from a list of lists"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Your comment puzzles me. The whole point of those problems is to give you something to solve, and make it somewhat of a challenge depending on the difficulty tag. Most of the problems on leetcode are artificial and of no practical use, they are just made to help you practise probem solving.\\nI don\\'t get why you complain that they\\'re making things harder for you. That\\'s the point. It\\'s like playing with one of those chinese/japanes wooden brain teasers and  complaining that they should have designed it so that it opens like a normal box."
                    },
                    {
                        "username": "mikael6767",
                        "content": "I realize this. I am programming on python3 and really know that it really is one line of code, but the problem is with ListNode. There are a lot LeetCode problems with ListNode and I can\\'t make them even if they are very easy without it. I have the same problem. I wrote that one line of code and it says it is not right. I would really like for someone to help you, but I\\'m sorry I can\\'t."
                    },
                    {
                        "username": "David_E_something",
                        "content": "If you somehow use a priority queue (heap), this problem becomes very easy."
                    },
                    {
                        "username": "clinkz93",
                        "content": "[@layman806](/layman806) Using a priority queue results in a complexity of O((k + n) * log(k)) instead of O(n * log(n)), which may be preferrable."
                    },
                    {
                        "username": "root89",
                        "content": "[@layman806](/layman806) \\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "[@layman806](/layman806) lmao,, you can\\'t beat the interviewer."
                    },
                    {
                        "username": "layman806",
                        "content": "Or just parse all into an array in O(n) time, then sort it in O(n.log(n)) time and convert it to a linked list in O(n) time. This is just too easy to beat. Shouldn\\'t be tagged as hard."
                    },
                    {
                        "username": "JaviOverflow",
                        "content": "When I submit my solution, it fails on the input `[[]]`, how is that input even posible? `ListNode` requires `val` as argument in its constructor. Returning `None` doesn\\'t make the test pass. I\\'m not sure how to tackle that."
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "thenimator",
                        "content": "It\\'s been a while since you had this problem but for anyone else running into it:\\n\\n[[]] simply stands for an array with 1 element with that one element being a null pointer (which in this context stands for an empty linked list and not one where the value of the first element is missing)"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, WTF? ![image](https://assets.leetcode.com/users/beatrizdos/image_1570843047.png)\\n"
                    },
                    {
                        "username": "Will-O-Wisp",
                        "content": "class ListNode(object):\\n    def __init__(self, val=0, next=None):\\n        self.val = val\\n        self.next = next\\n\\n\\nclass Solution(object):\\n    def mergeKLists(self, lists):\\n        def mergeTwoLists(l1, l2):\\n            dummy = ListNode(0)\\n            current = dummy\\n\\n            while l1 and l2:\\n                if l1.val < l2.val:\\n                    current.next = l1\\n                    l1 = l1.next\\n                else:\\n                    current.next = l2\\n                    l2 = l2.next\\n                current = current.next\\n\\n            current.next = l1 if l1 else l2\\n\\n            return dummy.next\\n\\n        if not lists:\\n            return None\\n\\n        while len(lists) > 1:\\n            merged_lists = []\\n\\n            for i in range(0, len(lists), 2):\\n                l1 = lists[i]\\n                l2 = lists[i + 1] if i + 1 < len(lists) else None\\n                merged_lists.append(mergeTwoLists(l1, l2))\\n\\n            lists = merged_lists\\n\\n        return lists[0] if lists else None\\n\\n\\n# Example usage\\nlists = [\\n    ListNode(1, ListNode(4, ListNode(5))),\\n    ListNode(1, ListNode(3, ListNode(4))),\\n    ListNode(2, ListNode(6))\\n]\\n\\nsolution = Solution()\\nresult = solution.mergeKLists(lists)\\nwhile result:\\n    print(result.val)\\n    result = result.next\\n"
                    },
                    {
                        "username": "rahulcse79",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* ans=NULL;\\n        \\n        if(lists.size()==0)\\n        return ans;\\n        \\n        vector<int> value;\\n        for(int i=0; i<lists.size(); i++)\\n        {\\n            ListNode* temp = lists[i];\\n            while(temp)\\n            {\\n                value.push_back(temp->val);\\n                temp=temp->next;\\n            }\\n        }\\n        if(value.size()==0)\\n        return ans;\\n        int kl=0;\\n        ListNode* newNode2=NULL;\\n        sort(value.begin(),value.end());\\n        for(int i=0; i<value.size(); i++)\\n        {\\n            ListNode* newNode = new ListNode(value[i]);\\n            kl++;\\n            if(kl==1){\\n            ans = newNode;\\n            newNode2=newNode;\\n            }\\n            else{\\n            newNode2->next = newNode;\\n            newNode2 = newNode;\\n            }\\n        }\\n\\n        value.clear();\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "qin4",
                        "content": "Util class ListNode in python 3 is not completed. It can\\'t do heapq directly. Fix is easier on server side."
                    }
                ]
            },
            {
                "id": 1760895,
                "content": [
                    {
                        "username": "Salmondita007",
                        "content": "They should add Deloitte to the list for companies because I got this exact problem in a coding interview with Deloitte"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "First hard Problem to be solved on my own.\n\nHere is the Approach :-\n\n1. Create a PriorityQueue to store the values of all the nodes in the input lists.\n2. Loop through each ListNode object in the input array, and add all its node values to the PriorityQueue using a while loop.\n3. Create a new linked list with the sorted values.\n4. Loop through the PriorityQueue until it is empty. For each element in the queue, create a new ListNode object with the element value as its val.\n5. If it is the first node added, set it as the head of the merged list. Otherwise, set the next pointer of the previous node to the new node.\n6. Return the head of the merged list."
                    },
                    {
                        "username": "countdankula",
                        "content": "Why not just using \"merge two sorted lists approach\"? Also heapq seems faster for many. Can you explain? \n\nBtw My code:\n\n```class Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:```\n\n        def merge(list1, list2):\n            dummy = ListNode()\n            temp = dummy\n\n            while list1 and list2:\n                if list1.val <= list2.val:\n                    temp.next = list1\n                    temp = temp.next\n                    list1 = list1.next\n\n                else:\n                    temp.next = list2\n                    temp = temp.next\n                    list2 = list2.next\n\n            if list1:\n                temp.next = list1\n\n            if list2:\n                temp.next = list2\n\n            return dummy.next\n\n\n        n = len(lists)\n\n        if not n:\n            return None\n\n        prevMerged = lists[0]\n\n        for i in range(1, n):\n            prevMerged = merge(prevMerged, lists[i])\n\n        return prevMerged\n\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@namandt](/namandt) You\\'re welcome brother"
                    },
                    {
                        "username": "namandt",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) \\nThanks bhai"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3286626/o-nlogn-detailed-solution-with-steps/"
                    },
                    {
                        "username": "lwy202898",
                        "content": "Hi, I think the time complexity for solution 5 is wrong. Suppose there are 8 lists, if I merge them one by one, then I need to merge them 7 times. In the sollution 5, it states that we can merge list1 and list2, list3 and list4, list 5 and list6, list 7 and list8 first, then on that basic, merge the results just like operating in a binary tree. But actually it still cost exactly 7 times not log 8 times. So I think there is no difference between merging them one by one V.S. merging them using divide and conquer."
                    },
                    {
                        "username": "mkArtak",
                        "content": "The problem doesn't define how the edge cases should be handled. That should be explicitly sated. Specifically, the \"empty array input should result in a null result\" should be part of the requirements."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can just see it in the examples right?"
                    },
                    {
                        "username": "frumpel",
                        "content": "It is really frustrating that this question is using linked lists as inputs and outputs as I think this has practically no bearing on the performance or implementation of the solution unless you want to try to implement a sort on top of the existing pointers. What makes this particularly annoying is that there is no mention of the possible pathological inputs, e.g.\\n\\n* [None] - written as \"[[]]\" \\n* [(2,None),None,(0,None)] - written as \"[[2],[],[0]]\"\\n\\nnor is a clear specification for _empty_ output provided\\n\\n* [None] - written as [[]]\\n\\nBut maybe even more frustrating is the fact that - at least in python - it seems to be faster to brute force the issue by unpacking the linked list(s) into an array, sorting the array, and repacking the array as a linked list to get to the top of performance in python, something that would work even if the source lists hadn\\'t been sorted in the first place. Not only that but it\\'s faster than the reference answers by factors big enough to assume that no tests exist to actually demonstrate the impact of the complexity difference.\\n\\nThis is totally a question worth asking in a face to face interview but seems pointless here ..."
                    },
                    {
                        "username": "gorman",
                        "content": "I found this problem easier than most \"Easy\" problems and got a \"beats 92.26%\" on my only submission.\\nAm I missing something?"
                    },
                    {
                        "username": "CyrilKamal",
                        "content": "nah ur just him"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "first hard problem solved...  #feelsgoodman"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast C++ | Python | Java Solution:\\nhttps://www.nileshblog.tech/2022/04/22/leet-code-merge-k-sorted-lists-c-java-python-solution/"
                    },
                    {
                        "username": "smuuth",
                        "content": "For the c++ submission, it asks to return a pointer, so some solutions are returning pointers to locals within the function. Isnt that going to generate a runtime error - returning a pointer to a local?"
                    },
                    {
                        "username": "user2666H",
                        "content": "Ths same test case ([]) is successful when I execute the program but fails when I submit it. Can anyone please let me know if I am missing something here?\\n\\n![image](https://assets.leetcode.com/users/images/59ea7c13-b619-415a-b263-912b3b607fd9_1623490669.4130723.png)\\n"
                    }
                ]
            },
            {
                "id": 1829872,
                "content": [
                    {
                        "username": "Salmondita007",
                        "content": "They should add Deloitte to the list for companies because I got this exact problem in a coding interview with Deloitte"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "First hard Problem to be solved on my own.\n\nHere is the Approach :-\n\n1. Create a PriorityQueue to store the values of all the nodes in the input lists.\n2. Loop through each ListNode object in the input array, and add all its node values to the PriorityQueue using a while loop.\n3. Create a new linked list with the sorted values.\n4. Loop through the PriorityQueue until it is empty. For each element in the queue, create a new ListNode object with the element value as its val.\n5. If it is the first node added, set it as the head of the merged list. Otherwise, set the next pointer of the previous node to the new node.\n6. Return the head of the merged list."
                    },
                    {
                        "username": "countdankula",
                        "content": "Why not just using \"merge two sorted lists approach\"? Also heapq seems faster for many. Can you explain? \n\nBtw My code:\n\n```class Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:```\n\n        def merge(list1, list2):\n            dummy = ListNode()\n            temp = dummy\n\n            while list1 and list2:\n                if list1.val <= list2.val:\n                    temp.next = list1\n                    temp = temp.next\n                    list1 = list1.next\n\n                else:\n                    temp.next = list2\n                    temp = temp.next\n                    list2 = list2.next\n\n            if list1:\n                temp.next = list1\n\n            if list2:\n                temp.next = list2\n\n            return dummy.next\n\n\n        n = len(lists)\n\n        if not n:\n            return None\n\n        prevMerged = lists[0]\n\n        for i in range(1, n):\n            prevMerged = merge(prevMerged, lists[i])\n\n        return prevMerged\n\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@namandt](/namandt) You\\'re welcome brother"
                    },
                    {
                        "username": "namandt",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) \\nThanks bhai"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3286626/o-nlogn-detailed-solution-with-steps/"
                    },
                    {
                        "username": "lwy202898",
                        "content": "Hi, I think the time complexity for solution 5 is wrong. Suppose there are 8 lists, if I merge them one by one, then I need to merge them 7 times. In the sollution 5, it states that we can merge list1 and list2, list3 and list4, list 5 and list6, list 7 and list8 first, then on that basic, merge the results just like operating in a binary tree. But actually it still cost exactly 7 times not log 8 times. So I think there is no difference between merging them one by one V.S. merging them using divide and conquer."
                    },
                    {
                        "username": "mkArtak",
                        "content": "The problem doesn't define how the edge cases should be handled. That should be explicitly sated. Specifically, the \"empty array input should result in a null result\" should be part of the requirements."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can just see it in the examples right?"
                    },
                    {
                        "username": "frumpel",
                        "content": "It is really frustrating that this question is using linked lists as inputs and outputs as I think this has practically no bearing on the performance or implementation of the solution unless you want to try to implement a sort on top of the existing pointers. What makes this particularly annoying is that there is no mention of the possible pathological inputs, e.g.\\n\\n* [None] - written as \"[[]]\" \\n* [(2,None),None,(0,None)] - written as \"[[2],[],[0]]\"\\n\\nnor is a clear specification for _empty_ output provided\\n\\n* [None] - written as [[]]\\n\\nBut maybe even more frustrating is the fact that - at least in python - it seems to be faster to brute force the issue by unpacking the linked list(s) into an array, sorting the array, and repacking the array as a linked list to get to the top of performance in python, something that would work even if the source lists hadn\\'t been sorted in the first place. Not only that but it\\'s faster than the reference answers by factors big enough to assume that no tests exist to actually demonstrate the impact of the complexity difference.\\n\\nThis is totally a question worth asking in a face to face interview but seems pointless here ..."
                    },
                    {
                        "username": "gorman",
                        "content": "I found this problem easier than most \"Easy\" problems and got a \"beats 92.26%\" on my only submission.\\nAm I missing something?"
                    },
                    {
                        "username": "CyrilKamal",
                        "content": "nah ur just him"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "first hard problem solved...  #feelsgoodman"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast C++ | Python | Java Solution:\\nhttps://www.nileshblog.tech/2022/04/22/leet-code-merge-k-sorted-lists-c-java-python-solution/"
                    },
                    {
                        "username": "smuuth",
                        "content": "For the c++ submission, it asks to return a pointer, so some solutions are returning pointers to locals within the function. Isnt that going to generate a runtime error - returning a pointer to a local?"
                    },
                    {
                        "username": "user2666H",
                        "content": "Ths same test case ([]) is successful when I execute the program but fails when I submit it. Can anyone please let me know if I am missing something here?\\n\\n![image](https://assets.leetcode.com/users/images/59ea7c13-b619-415a-b263-912b3b607fd9_1623490669.4130723.png)\\n"
                    }
                ]
            },
            {
                "id": 1572338,
                "content": [
                    {
                        "username": "Salmondita007",
                        "content": "They should add Deloitte to the list for companies because I got this exact problem in a coding interview with Deloitte"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "First hard Problem to be solved on my own.\n\nHere is the Approach :-\n\n1. Create a PriorityQueue to store the values of all the nodes in the input lists.\n2. Loop through each ListNode object in the input array, and add all its node values to the PriorityQueue using a while loop.\n3. Create a new linked list with the sorted values.\n4. Loop through the PriorityQueue until it is empty. For each element in the queue, create a new ListNode object with the element value as its val.\n5. If it is the first node added, set it as the head of the merged list. Otherwise, set the next pointer of the previous node to the new node.\n6. Return the head of the merged list."
                    },
                    {
                        "username": "countdankula",
                        "content": "Why not just using \"merge two sorted lists approach\"? Also heapq seems faster for many. Can you explain? \n\nBtw My code:\n\n```class Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:```\n\n        def merge(list1, list2):\n            dummy = ListNode()\n            temp = dummy\n\n            while list1 and list2:\n                if list1.val <= list2.val:\n                    temp.next = list1\n                    temp = temp.next\n                    list1 = list1.next\n\n                else:\n                    temp.next = list2\n                    temp = temp.next\n                    list2 = list2.next\n\n            if list1:\n                temp.next = list1\n\n            if list2:\n                temp.next = list2\n\n            return dummy.next\n\n\n        n = len(lists)\n\n        if not n:\n            return None\n\n        prevMerged = lists[0]\n\n        for i in range(1, n):\n            prevMerged = merge(prevMerged, lists[i])\n\n        return prevMerged\n\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@namandt](/namandt) You\\'re welcome brother"
                    },
                    {
                        "username": "namandt",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) \\nThanks bhai"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3286626/o-nlogn-detailed-solution-with-steps/"
                    },
                    {
                        "username": "lwy202898",
                        "content": "Hi, I think the time complexity for solution 5 is wrong. Suppose there are 8 lists, if I merge them one by one, then I need to merge them 7 times. In the sollution 5, it states that we can merge list1 and list2, list3 and list4, list 5 and list6, list 7 and list8 first, then on that basic, merge the results just like operating in a binary tree. But actually it still cost exactly 7 times not log 8 times. So I think there is no difference between merging them one by one V.S. merging them using divide and conquer."
                    },
                    {
                        "username": "mkArtak",
                        "content": "The problem doesn't define how the edge cases should be handled. That should be explicitly sated. Specifically, the \"empty array input should result in a null result\" should be part of the requirements."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can just see it in the examples right?"
                    },
                    {
                        "username": "frumpel",
                        "content": "It is really frustrating that this question is using linked lists as inputs and outputs as I think this has practically no bearing on the performance or implementation of the solution unless you want to try to implement a sort on top of the existing pointers. What makes this particularly annoying is that there is no mention of the possible pathological inputs, e.g.\\n\\n* [None] - written as \"[[]]\" \\n* [(2,None),None,(0,None)] - written as \"[[2],[],[0]]\"\\n\\nnor is a clear specification for _empty_ output provided\\n\\n* [None] - written as [[]]\\n\\nBut maybe even more frustrating is the fact that - at least in python - it seems to be faster to brute force the issue by unpacking the linked list(s) into an array, sorting the array, and repacking the array as a linked list to get to the top of performance in python, something that would work even if the source lists hadn\\'t been sorted in the first place. Not only that but it\\'s faster than the reference answers by factors big enough to assume that no tests exist to actually demonstrate the impact of the complexity difference.\\n\\nThis is totally a question worth asking in a face to face interview but seems pointless here ..."
                    },
                    {
                        "username": "gorman",
                        "content": "I found this problem easier than most \"Easy\" problems and got a \"beats 92.26%\" on my only submission.\\nAm I missing something?"
                    },
                    {
                        "username": "CyrilKamal",
                        "content": "nah ur just him"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "first hard problem solved...  #feelsgoodman"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast C++ | Python | Java Solution:\\nhttps://www.nileshblog.tech/2022/04/22/leet-code-merge-k-sorted-lists-c-java-python-solution/"
                    },
                    {
                        "username": "smuuth",
                        "content": "For the c++ submission, it asks to return a pointer, so some solutions are returning pointers to locals within the function. Isnt that going to generate a runtime error - returning a pointer to a local?"
                    },
                    {
                        "username": "user2666H",
                        "content": "Ths same test case ([]) is successful when I execute the program but fails when I submit it. Can anyone please let me know if I am missing something here?\\n\\n![image](https://assets.leetcode.com/users/images/59ea7c13-b619-415a-b263-912b3b607fd9_1623490669.4130723.png)\\n"
                    }
                ]
            },
            {
                "id": 1571059,
                "content": [
                    {
                        "username": "Salmondita007",
                        "content": "They should add Deloitte to the list for companies because I got this exact problem in a coding interview with Deloitte"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "First hard Problem to be solved on my own.\n\nHere is the Approach :-\n\n1. Create a PriorityQueue to store the values of all the nodes in the input lists.\n2. Loop through each ListNode object in the input array, and add all its node values to the PriorityQueue using a while loop.\n3. Create a new linked list with the sorted values.\n4. Loop through the PriorityQueue until it is empty. For each element in the queue, create a new ListNode object with the element value as its val.\n5. If it is the first node added, set it as the head of the merged list. Otherwise, set the next pointer of the previous node to the new node.\n6. Return the head of the merged list."
                    },
                    {
                        "username": "countdankula",
                        "content": "Why not just using \"merge two sorted lists approach\"? Also heapq seems faster for many. Can you explain? \n\nBtw My code:\n\n```class Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:```\n\n        def merge(list1, list2):\n            dummy = ListNode()\n            temp = dummy\n\n            while list1 and list2:\n                if list1.val <= list2.val:\n                    temp.next = list1\n                    temp = temp.next\n                    list1 = list1.next\n\n                else:\n                    temp.next = list2\n                    temp = temp.next\n                    list2 = list2.next\n\n            if list1:\n                temp.next = list1\n\n            if list2:\n                temp.next = list2\n\n            return dummy.next\n\n\n        n = len(lists)\n\n        if not n:\n            return None\n\n        prevMerged = lists[0]\n\n        for i in range(1, n):\n            prevMerged = merge(prevMerged, lists[i])\n\n        return prevMerged\n\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@namandt](/namandt) You\\'re welcome brother"
                    },
                    {
                        "username": "namandt",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) \\nThanks bhai"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3286626/o-nlogn-detailed-solution-with-steps/"
                    },
                    {
                        "username": "lwy202898",
                        "content": "Hi, I think the time complexity for solution 5 is wrong. Suppose there are 8 lists, if I merge them one by one, then I need to merge them 7 times. In the sollution 5, it states that we can merge list1 and list2, list3 and list4, list 5 and list6, list 7 and list8 first, then on that basic, merge the results just like operating in a binary tree. But actually it still cost exactly 7 times not log 8 times. So I think there is no difference between merging them one by one V.S. merging them using divide and conquer."
                    },
                    {
                        "username": "mkArtak",
                        "content": "The problem doesn't define how the edge cases should be handled. That should be explicitly sated. Specifically, the \"empty array input should result in a null result\" should be part of the requirements."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can just see it in the examples right?"
                    },
                    {
                        "username": "frumpel",
                        "content": "It is really frustrating that this question is using linked lists as inputs and outputs as I think this has practically no bearing on the performance or implementation of the solution unless you want to try to implement a sort on top of the existing pointers. What makes this particularly annoying is that there is no mention of the possible pathological inputs, e.g.\\n\\n* [None] - written as \"[[]]\" \\n* [(2,None),None,(0,None)] - written as \"[[2],[],[0]]\"\\n\\nnor is a clear specification for _empty_ output provided\\n\\n* [None] - written as [[]]\\n\\nBut maybe even more frustrating is the fact that - at least in python - it seems to be faster to brute force the issue by unpacking the linked list(s) into an array, sorting the array, and repacking the array as a linked list to get to the top of performance in python, something that would work even if the source lists hadn\\'t been sorted in the first place. Not only that but it\\'s faster than the reference answers by factors big enough to assume that no tests exist to actually demonstrate the impact of the complexity difference.\\n\\nThis is totally a question worth asking in a face to face interview but seems pointless here ..."
                    },
                    {
                        "username": "gorman",
                        "content": "I found this problem easier than most \"Easy\" problems and got a \"beats 92.26%\" on my only submission.\\nAm I missing something?"
                    },
                    {
                        "username": "CyrilKamal",
                        "content": "nah ur just him"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "first hard problem solved...  #feelsgoodman"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast C++ | Python | Java Solution:\\nhttps://www.nileshblog.tech/2022/04/22/leet-code-merge-k-sorted-lists-c-java-python-solution/"
                    },
                    {
                        "username": "smuuth",
                        "content": "For the c++ submission, it asks to return a pointer, so some solutions are returning pointers to locals within the function. Isnt that going to generate a runtime error - returning a pointer to a local?"
                    },
                    {
                        "username": "user2666H",
                        "content": "Ths same test case ([]) is successful when I execute the program but fails when I submit it. Can anyone please let me know if I am missing something here?\\n\\n![image](https://assets.leetcode.com/users/images/59ea7c13-b619-415a-b263-912b3b607fd9_1623490669.4130723.png)\\n"
                    }
                ]
            },
            {
                "id": 1568076,
                "content": [
                    {
                        "username": "Salmondita007",
                        "content": "They should add Deloitte to the list for companies because I got this exact problem in a coding interview with Deloitte"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "First hard Problem to be solved on my own.\n\nHere is the Approach :-\n\n1. Create a PriorityQueue to store the values of all the nodes in the input lists.\n2. Loop through each ListNode object in the input array, and add all its node values to the PriorityQueue using a while loop.\n3. Create a new linked list with the sorted values.\n4. Loop through the PriorityQueue until it is empty. For each element in the queue, create a new ListNode object with the element value as its val.\n5. If it is the first node added, set it as the head of the merged list. Otherwise, set the next pointer of the previous node to the new node.\n6. Return the head of the merged list."
                    },
                    {
                        "username": "countdankula",
                        "content": "Why not just using \"merge two sorted lists approach\"? Also heapq seems faster for many. Can you explain? \n\nBtw My code:\n\n```class Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:```\n\n        def merge(list1, list2):\n            dummy = ListNode()\n            temp = dummy\n\n            while list1 and list2:\n                if list1.val <= list2.val:\n                    temp.next = list1\n                    temp = temp.next\n                    list1 = list1.next\n\n                else:\n                    temp.next = list2\n                    temp = temp.next\n                    list2 = list2.next\n\n            if list1:\n                temp.next = list1\n\n            if list2:\n                temp.next = list2\n\n            return dummy.next\n\n\n        n = len(lists)\n\n        if not n:\n            return None\n\n        prevMerged = lists[0]\n\n        for i in range(1, n):\n            prevMerged = merge(prevMerged, lists[i])\n\n        return prevMerged\n\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@namandt](/namandt) You\\'re welcome brother"
                    },
                    {
                        "username": "namandt",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) \\nThanks bhai"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3286626/o-nlogn-detailed-solution-with-steps/"
                    },
                    {
                        "username": "lwy202898",
                        "content": "Hi, I think the time complexity for solution 5 is wrong. Suppose there are 8 lists, if I merge them one by one, then I need to merge them 7 times. In the sollution 5, it states that we can merge list1 and list2, list3 and list4, list 5 and list6, list 7 and list8 first, then on that basic, merge the results just like operating in a binary tree. But actually it still cost exactly 7 times not log 8 times. So I think there is no difference between merging them one by one V.S. merging them using divide and conquer."
                    },
                    {
                        "username": "mkArtak",
                        "content": "The problem doesn't define how the edge cases should be handled. That should be explicitly sated. Specifically, the \"empty array input should result in a null result\" should be part of the requirements."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can just see it in the examples right?"
                    },
                    {
                        "username": "frumpel",
                        "content": "It is really frustrating that this question is using linked lists as inputs and outputs as I think this has practically no bearing on the performance or implementation of the solution unless you want to try to implement a sort on top of the existing pointers. What makes this particularly annoying is that there is no mention of the possible pathological inputs, e.g.\\n\\n* [None] - written as \"[[]]\" \\n* [(2,None),None,(0,None)] - written as \"[[2],[],[0]]\"\\n\\nnor is a clear specification for _empty_ output provided\\n\\n* [None] - written as [[]]\\n\\nBut maybe even more frustrating is the fact that - at least in python - it seems to be faster to brute force the issue by unpacking the linked list(s) into an array, sorting the array, and repacking the array as a linked list to get to the top of performance in python, something that would work even if the source lists hadn\\'t been sorted in the first place. Not only that but it\\'s faster than the reference answers by factors big enough to assume that no tests exist to actually demonstrate the impact of the complexity difference.\\n\\nThis is totally a question worth asking in a face to face interview but seems pointless here ..."
                    },
                    {
                        "username": "gorman",
                        "content": "I found this problem easier than most \"Easy\" problems and got a \"beats 92.26%\" on my only submission.\\nAm I missing something?"
                    },
                    {
                        "username": "CyrilKamal",
                        "content": "nah ur just him"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "first hard problem solved...  #feelsgoodman"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast C++ | Python | Java Solution:\\nhttps://www.nileshblog.tech/2022/04/22/leet-code-merge-k-sorted-lists-c-java-python-solution/"
                    },
                    {
                        "username": "smuuth",
                        "content": "For the c++ submission, it asks to return a pointer, so some solutions are returning pointers to locals within the function. Isnt that going to generate a runtime error - returning a pointer to a local?"
                    },
                    {
                        "username": "user2666H",
                        "content": "Ths same test case ([]) is successful when I execute the program but fails when I submit it. Can anyone please let me know if I am missing something here?\\n\\n![image](https://assets.leetcode.com/users/images/59ea7c13-b619-415a-b263-912b3b607fd9_1623490669.4130723.png)\\n"
                    }
                ]
            },
            {
                "id": 1569221,
                "content": [
                    {
                        "username": "Salmondita007",
                        "content": "They should add Deloitte to the list for companies because I got this exact problem in a coding interview with Deloitte"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "First hard Problem to be solved on my own.\n\nHere is the Approach :-\n\n1. Create a PriorityQueue to store the values of all the nodes in the input lists.\n2. Loop through each ListNode object in the input array, and add all its node values to the PriorityQueue using a while loop.\n3. Create a new linked list with the sorted values.\n4. Loop through the PriorityQueue until it is empty. For each element in the queue, create a new ListNode object with the element value as its val.\n5. If it is the first node added, set it as the head of the merged list. Otherwise, set the next pointer of the previous node to the new node.\n6. Return the head of the merged list."
                    },
                    {
                        "username": "countdankula",
                        "content": "Why not just using \"merge two sorted lists approach\"? Also heapq seems faster for many. Can you explain? \n\nBtw My code:\n\n```class Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:```\n\n        def merge(list1, list2):\n            dummy = ListNode()\n            temp = dummy\n\n            while list1 and list2:\n                if list1.val <= list2.val:\n                    temp.next = list1\n                    temp = temp.next\n                    list1 = list1.next\n\n                else:\n                    temp.next = list2\n                    temp = temp.next\n                    list2 = list2.next\n\n            if list1:\n                temp.next = list1\n\n            if list2:\n                temp.next = list2\n\n            return dummy.next\n\n\n        n = len(lists)\n\n        if not n:\n            return None\n\n        prevMerged = lists[0]\n\n        for i in range(1, n):\n            prevMerged = merge(prevMerged, lists[i])\n\n        return prevMerged\n\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@namandt](/namandt) You\\'re welcome brother"
                    },
                    {
                        "username": "namandt",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) \\nThanks bhai"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3286626/o-nlogn-detailed-solution-with-steps/"
                    },
                    {
                        "username": "lwy202898",
                        "content": "Hi, I think the time complexity for solution 5 is wrong. Suppose there are 8 lists, if I merge them one by one, then I need to merge them 7 times. In the sollution 5, it states that we can merge list1 and list2, list3 and list4, list 5 and list6, list 7 and list8 first, then on that basic, merge the results just like operating in a binary tree. But actually it still cost exactly 7 times not log 8 times. So I think there is no difference between merging them one by one V.S. merging them using divide and conquer."
                    },
                    {
                        "username": "mkArtak",
                        "content": "The problem doesn't define how the edge cases should be handled. That should be explicitly sated. Specifically, the \"empty array input should result in a null result\" should be part of the requirements."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can just see it in the examples right?"
                    },
                    {
                        "username": "frumpel",
                        "content": "It is really frustrating that this question is using linked lists as inputs and outputs as I think this has practically no bearing on the performance or implementation of the solution unless you want to try to implement a sort on top of the existing pointers. What makes this particularly annoying is that there is no mention of the possible pathological inputs, e.g.\\n\\n* [None] - written as \"[[]]\" \\n* [(2,None),None,(0,None)] - written as \"[[2],[],[0]]\"\\n\\nnor is a clear specification for _empty_ output provided\\n\\n* [None] - written as [[]]\\n\\nBut maybe even more frustrating is the fact that - at least in python - it seems to be faster to brute force the issue by unpacking the linked list(s) into an array, sorting the array, and repacking the array as a linked list to get to the top of performance in python, something that would work even if the source lists hadn\\'t been sorted in the first place. Not only that but it\\'s faster than the reference answers by factors big enough to assume that no tests exist to actually demonstrate the impact of the complexity difference.\\n\\nThis is totally a question worth asking in a face to face interview but seems pointless here ..."
                    },
                    {
                        "username": "gorman",
                        "content": "I found this problem easier than most \"Easy\" problems and got a \"beats 92.26%\" on my only submission.\\nAm I missing something?"
                    },
                    {
                        "username": "CyrilKamal",
                        "content": "nah ur just him"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "first hard problem solved...  #feelsgoodman"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast C++ | Python | Java Solution:\\nhttps://www.nileshblog.tech/2022/04/22/leet-code-merge-k-sorted-lists-c-java-python-solution/"
                    },
                    {
                        "username": "smuuth",
                        "content": "For the c++ submission, it asks to return a pointer, so some solutions are returning pointers to locals within the function. Isnt that going to generate a runtime error - returning a pointer to a local?"
                    },
                    {
                        "username": "user2666H",
                        "content": "Ths same test case ([]) is successful when I execute the program but fails when I submit it. Can anyone please let me know if I am missing something here?\\n\\n![image](https://assets.leetcode.com/users/images/59ea7c13-b619-415a-b263-912b3b607fd9_1623490669.4130723.png)\\n"
                    }
                ]
            },
            {
                "id": 1983767,
                "content": [
                    {
                        "username": "Salmondita007",
                        "content": "They should add Deloitte to the list for companies because I got this exact problem in a coding interview with Deloitte"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "First hard Problem to be solved on my own.\n\nHere is the Approach :-\n\n1. Create a PriorityQueue to store the values of all the nodes in the input lists.\n2. Loop through each ListNode object in the input array, and add all its node values to the PriorityQueue using a while loop.\n3. Create a new linked list with the sorted values.\n4. Loop through the PriorityQueue until it is empty. For each element in the queue, create a new ListNode object with the element value as its val.\n5. If it is the first node added, set it as the head of the merged list. Otherwise, set the next pointer of the previous node to the new node.\n6. Return the head of the merged list."
                    },
                    {
                        "username": "countdankula",
                        "content": "Why not just using \"merge two sorted lists approach\"? Also heapq seems faster for many. Can you explain? \n\nBtw My code:\n\n```class Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:```\n\n        def merge(list1, list2):\n            dummy = ListNode()\n            temp = dummy\n\n            while list1 and list2:\n                if list1.val <= list2.val:\n                    temp.next = list1\n                    temp = temp.next\n                    list1 = list1.next\n\n                else:\n                    temp.next = list2\n                    temp = temp.next\n                    list2 = list2.next\n\n            if list1:\n                temp.next = list1\n\n            if list2:\n                temp.next = list2\n\n            return dummy.next\n\n\n        n = len(lists)\n\n        if not n:\n            return None\n\n        prevMerged = lists[0]\n\n        for i in range(1, n):\n            prevMerged = merge(prevMerged, lists[i])\n\n        return prevMerged\n\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@namandt](/namandt) You\\'re welcome brother"
                    },
                    {
                        "username": "namandt",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) \\nThanks bhai"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3286626/o-nlogn-detailed-solution-with-steps/"
                    },
                    {
                        "username": "lwy202898",
                        "content": "Hi, I think the time complexity for solution 5 is wrong. Suppose there are 8 lists, if I merge them one by one, then I need to merge them 7 times. In the sollution 5, it states that we can merge list1 and list2, list3 and list4, list 5 and list6, list 7 and list8 first, then on that basic, merge the results just like operating in a binary tree. But actually it still cost exactly 7 times not log 8 times. So I think there is no difference between merging them one by one V.S. merging them using divide and conquer."
                    },
                    {
                        "username": "mkArtak",
                        "content": "The problem doesn't define how the edge cases should be handled. That should be explicitly sated. Specifically, the \"empty array input should result in a null result\" should be part of the requirements."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can just see it in the examples right?"
                    },
                    {
                        "username": "frumpel",
                        "content": "It is really frustrating that this question is using linked lists as inputs and outputs as I think this has practically no bearing on the performance or implementation of the solution unless you want to try to implement a sort on top of the existing pointers. What makes this particularly annoying is that there is no mention of the possible pathological inputs, e.g.\\n\\n* [None] - written as \"[[]]\" \\n* [(2,None),None,(0,None)] - written as \"[[2],[],[0]]\"\\n\\nnor is a clear specification for _empty_ output provided\\n\\n* [None] - written as [[]]\\n\\nBut maybe even more frustrating is the fact that - at least in python - it seems to be faster to brute force the issue by unpacking the linked list(s) into an array, sorting the array, and repacking the array as a linked list to get to the top of performance in python, something that would work even if the source lists hadn\\'t been sorted in the first place. Not only that but it\\'s faster than the reference answers by factors big enough to assume that no tests exist to actually demonstrate the impact of the complexity difference.\\n\\nThis is totally a question worth asking in a face to face interview but seems pointless here ..."
                    },
                    {
                        "username": "gorman",
                        "content": "I found this problem easier than most \"Easy\" problems and got a \"beats 92.26%\" on my only submission.\\nAm I missing something?"
                    },
                    {
                        "username": "CyrilKamal",
                        "content": "nah ur just him"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "first hard problem solved...  #feelsgoodman"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast C++ | Python | Java Solution:\\nhttps://www.nileshblog.tech/2022/04/22/leet-code-merge-k-sorted-lists-c-java-python-solution/"
                    },
                    {
                        "username": "smuuth",
                        "content": "For the c++ submission, it asks to return a pointer, so some solutions are returning pointers to locals within the function. Isnt that going to generate a runtime error - returning a pointer to a local?"
                    },
                    {
                        "username": "user2666H",
                        "content": "Ths same test case ([]) is successful when I execute the program but fails when I submit it. Can anyone please let me know if I am missing something here?\\n\\n![image](https://assets.leetcode.com/users/images/59ea7c13-b619-415a-b263-912b3b607fd9_1623490669.4130723.png)\\n"
                    }
                ]
            },
            {
                "id": 1576660,
                "content": [
                    {
                        "username": "Salmondita007",
                        "content": "They should add Deloitte to the list for companies because I got this exact problem in a coding interview with Deloitte"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "First hard Problem to be solved on my own.\n\nHere is the Approach :-\n\n1. Create a PriorityQueue to store the values of all the nodes in the input lists.\n2. Loop through each ListNode object in the input array, and add all its node values to the PriorityQueue using a while loop.\n3. Create a new linked list with the sorted values.\n4. Loop through the PriorityQueue until it is empty. For each element in the queue, create a new ListNode object with the element value as its val.\n5. If it is the first node added, set it as the head of the merged list. Otherwise, set the next pointer of the previous node to the new node.\n6. Return the head of the merged list."
                    },
                    {
                        "username": "countdankula",
                        "content": "Why not just using \"merge two sorted lists approach\"? Also heapq seems faster for many. Can you explain? \n\nBtw My code:\n\n```class Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:```\n\n        def merge(list1, list2):\n            dummy = ListNode()\n            temp = dummy\n\n            while list1 and list2:\n                if list1.val <= list2.val:\n                    temp.next = list1\n                    temp = temp.next\n                    list1 = list1.next\n\n                else:\n                    temp.next = list2\n                    temp = temp.next\n                    list2 = list2.next\n\n            if list1:\n                temp.next = list1\n\n            if list2:\n                temp.next = list2\n\n            return dummy.next\n\n\n        n = len(lists)\n\n        if not n:\n            return None\n\n        prevMerged = lists[0]\n\n        for i in range(1, n):\n            prevMerged = merge(prevMerged, lists[i])\n\n        return prevMerged\n\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@namandt](/namandt) You\\'re welcome brother"
                    },
                    {
                        "username": "namandt",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) \\nThanks bhai"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3286626/o-nlogn-detailed-solution-with-steps/"
                    },
                    {
                        "username": "lwy202898",
                        "content": "Hi, I think the time complexity for solution 5 is wrong. Suppose there are 8 lists, if I merge them one by one, then I need to merge them 7 times. In the sollution 5, it states that we can merge list1 and list2, list3 and list4, list 5 and list6, list 7 and list8 first, then on that basic, merge the results just like operating in a binary tree. But actually it still cost exactly 7 times not log 8 times. So I think there is no difference between merging them one by one V.S. merging them using divide and conquer."
                    },
                    {
                        "username": "mkArtak",
                        "content": "The problem doesn't define how the edge cases should be handled. That should be explicitly sated. Specifically, the \"empty array input should result in a null result\" should be part of the requirements."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can just see it in the examples right?"
                    },
                    {
                        "username": "frumpel",
                        "content": "It is really frustrating that this question is using linked lists as inputs and outputs as I think this has practically no bearing on the performance or implementation of the solution unless you want to try to implement a sort on top of the existing pointers. What makes this particularly annoying is that there is no mention of the possible pathological inputs, e.g.\\n\\n* [None] - written as \"[[]]\" \\n* [(2,None),None,(0,None)] - written as \"[[2],[],[0]]\"\\n\\nnor is a clear specification for _empty_ output provided\\n\\n* [None] - written as [[]]\\n\\nBut maybe even more frustrating is the fact that - at least in python - it seems to be faster to brute force the issue by unpacking the linked list(s) into an array, sorting the array, and repacking the array as a linked list to get to the top of performance in python, something that would work even if the source lists hadn\\'t been sorted in the first place. Not only that but it\\'s faster than the reference answers by factors big enough to assume that no tests exist to actually demonstrate the impact of the complexity difference.\\n\\nThis is totally a question worth asking in a face to face interview but seems pointless here ..."
                    },
                    {
                        "username": "gorman",
                        "content": "I found this problem easier than most \"Easy\" problems and got a \"beats 92.26%\" on my only submission.\\nAm I missing something?"
                    },
                    {
                        "username": "CyrilKamal",
                        "content": "nah ur just him"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "first hard problem solved...  #feelsgoodman"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast C++ | Python | Java Solution:\\nhttps://www.nileshblog.tech/2022/04/22/leet-code-merge-k-sorted-lists-c-java-python-solution/"
                    },
                    {
                        "username": "smuuth",
                        "content": "For the c++ submission, it asks to return a pointer, so some solutions are returning pointers to locals within the function. Isnt that going to generate a runtime error - returning a pointer to a local?"
                    },
                    {
                        "username": "user2666H",
                        "content": "Ths same test case ([]) is successful when I execute the program but fails when I submit it. Can anyone please let me know if I am missing something here?\\n\\n![image](https://assets.leetcode.com/users/images/59ea7c13-b619-415a-b263-912b3b607fd9_1623490669.4130723.png)\\n"
                    }
                ]
            },
            {
                "id": 1575407,
                "content": [
                    {
                        "username": "Salmondita007",
                        "content": "They should add Deloitte to the list for companies because I got this exact problem in a coding interview with Deloitte"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "First hard Problem to be solved on my own.\n\nHere is the Approach :-\n\n1. Create a PriorityQueue to store the values of all the nodes in the input lists.\n2. Loop through each ListNode object in the input array, and add all its node values to the PriorityQueue using a while loop.\n3. Create a new linked list with the sorted values.\n4. Loop through the PriorityQueue until it is empty. For each element in the queue, create a new ListNode object with the element value as its val.\n5. If it is the first node added, set it as the head of the merged list. Otherwise, set the next pointer of the previous node to the new node.\n6. Return the head of the merged list."
                    },
                    {
                        "username": "countdankula",
                        "content": "Why not just using \"merge two sorted lists approach\"? Also heapq seems faster for many. Can you explain? \n\nBtw My code:\n\n```class Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:```\n\n        def merge(list1, list2):\n            dummy = ListNode()\n            temp = dummy\n\n            while list1 and list2:\n                if list1.val <= list2.val:\n                    temp.next = list1\n                    temp = temp.next\n                    list1 = list1.next\n\n                else:\n                    temp.next = list2\n                    temp = temp.next\n                    list2 = list2.next\n\n            if list1:\n                temp.next = list1\n\n            if list2:\n                temp.next = list2\n\n            return dummy.next\n\n\n        n = len(lists)\n\n        if not n:\n            return None\n\n        prevMerged = lists[0]\n\n        for i in range(1, n):\n            prevMerged = merge(prevMerged, lists[i])\n\n        return prevMerged\n\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@namandt](/namandt) You\\'re welcome brother"
                    },
                    {
                        "username": "namandt",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) \\nThanks bhai"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3286626/o-nlogn-detailed-solution-with-steps/"
                    },
                    {
                        "username": "lwy202898",
                        "content": "Hi, I think the time complexity for solution 5 is wrong. Suppose there are 8 lists, if I merge them one by one, then I need to merge them 7 times. In the sollution 5, it states that we can merge list1 and list2, list3 and list4, list 5 and list6, list 7 and list8 first, then on that basic, merge the results just like operating in a binary tree. But actually it still cost exactly 7 times not log 8 times. So I think there is no difference between merging them one by one V.S. merging them using divide and conquer."
                    },
                    {
                        "username": "mkArtak",
                        "content": "The problem doesn't define how the edge cases should be handled. That should be explicitly sated. Specifically, the \"empty array input should result in a null result\" should be part of the requirements."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can just see it in the examples right?"
                    },
                    {
                        "username": "frumpel",
                        "content": "It is really frustrating that this question is using linked lists as inputs and outputs as I think this has practically no bearing on the performance or implementation of the solution unless you want to try to implement a sort on top of the existing pointers. What makes this particularly annoying is that there is no mention of the possible pathological inputs, e.g.\\n\\n* [None] - written as \"[[]]\" \\n* [(2,None),None,(0,None)] - written as \"[[2],[],[0]]\"\\n\\nnor is a clear specification for _empty_ output provided\\n\\n* [None] - written as [[]]\\n\\nBut maybe even more frustrating is the fact that - at least in python - it seems to be faster to brute force the issue by unpacking the linked list(s) into an array, sorting the array, and repacking the array as a linked list to get to the top of performance in python, something that would work even if the source lists hadn\\'t been sorted in the first place. Not only that but it\\'s faster than the reference answers by factors big enough to assume that no tests exist to actually demonstrate the impact of the complexity difference.\\n\\nThis is totally a question worth asking in a face to face interview but seems pointless here ..."
                    },
                    {
                        "username": "gorman",
                        "content": "I found this problem easier than most \"Easy\" problems and got a \"beats 92.26%\" on my only submission.\\nAm I missing something?"
                    },
                    {
                        "username": "CyrilKamal",
                        "content": "nah ur just him"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "first hard problem solved...  #feelsgoodman"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast C++ | Python | Java Solution:\\nhttps://www.nileshblog.tech/2022/04/22/leet-code-merge-k-sorted-lists-c-java-python-solution/"
                    },
                    {
                        "username": "smuuth",
                        "content": "For the c++ submission, it asks to return a pointer, so some solutions are returning pointers to locals within the function. Isnt that going to generate a runtime error - returning a pointer to a local?"
                    },
                    {
                        "username": "user2666H",
                        "content": "Ths same test case ([]) is successful when I execute the program but fails when I submit it. Can anyone please let me know if I am missing something here?\\n\\n![image](https://assets.leetcode.com/users/images/59ea7c13-b619-415a-b263-912b3b607fd9_1623490669.4130723.png)\\n"
                    }
                ]
            },
            {
                "id": 1575389,
                "content": [
                    {
                        "username": "Salmondita007",
                        "content": "They should add Deloitte to the list for companies because I got this exact problem in a coding interview with Deloitte"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "First hard Problem to be solved on my own.\n\nHere is the Approach :-\n\n1. Create a PriorityQueue to store the values of all the nodes in the input lists.\n2. Loop through each ListNode object in the input array, and add all its node values to the PriorityQueue using a while loop.\n3. Create a new linked list with the sorted values.\n4. Loop through the PriorityQueue until it is empty. For each element in the queue, create a new ListNode object with the element value as its val.\n5. If it is the first node added, set it as the head of the merged list. Otherwise, set the next pointer of the previous node to the new node.\n6. Return the head of the merged list."
                    },
                    {
                        "username": "countdankula",
                        "content": "Why not just using \"merge two sorted lists approach\"? Also heapq seems faster for many. Can you explain? \n\nBtw My code:\n\n```class Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:```\n\n        def merge(list1, list2):\n            dummy = ListNode()\n            temp = dummy\n\n            while list1 and list2:\n                if list1.val <= list2.val:\n                    temp.next = list1\n                    temp = temp.next\n                    list1 = list1.next\n\n                else:\n                    temp.next = list2\n                    temp = temp.next\n                    list2 = list2.next\n\n            if list1:\n                temp.next = list1\n\n            if list2:\n                temp.next = list2\n\n            return dummy.next\n\n\n        n = len(lists)\n\n        if not n:\n            return None\n\n        prevMerged = lists[0]\n\n        for i in range(1, n):\n            prevMerged = merge(prevMerged, lists[i])\n\n        return prevMerged\n\n"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "[@namandt](/namandt) You\\'re welcome brother"
                    },
                    {
                        "username": "namandt",
                        "content": "[@cOde_Ranvir25](/cOde_Ranvir25) \\nThanks bhai"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the code link for reference:-\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3286626/o-nlogn-detailed-solution-with-steps/"
                    },
                    {
                        "username": "lwy202898",
                        "content": "Hi, I think the time complexity for solution 5 is wrong. Suppose there are 8 lists, if I merge them one by one, then I need to merge them 7 times. In the sollution 5, it states that we can merge list1 and list2, list3 and list4, list 5 and list6, list 7 and list8 first, then on that basic, merge the results just like operating in a binary tree. But actually it still cost exactly 7 times not log 8 times. So I think there is no difference between merging them one by one V.S. merging them using divide and conquer."
                    },
                    {
                        "username": "mkArtak",
                        "content": "The problem doesn't define how the edge cases should be handled. That should be explicitly sated. Specifically, the \"empty array input should result in a null result\" should be part of the requirements."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you can just see it in the examples right?"
                    },
                    {
                        "username": "frumpel",
                        "content": "It is really frustrating that this question is using linked lists as inputs and outputs as I think this has practically no bearing on the performance or implementation of the solution unless you want to try to implement a sort on top of the existing pointers. What makes this particularly annoying is that there is no mention of the possible pathological inputs, e.g.\\n\\n* [None] - written as \"[[]]\" \\n* [(2,None),None,(0,None)] - written as \"[[2],[],[0]]\"\\n\\nnor is a clear specification for _empty_ output provided\\n\\n* [None] - written as [[]]\\n\\nBut maybe even more frustrating is the fact that - at least in python - it seems to be faster to brute force the issue by unpacking the linked list(s) into an array, sorting the array, and repacking the array as a linked list to get to the top of performance in python, something that would work even if the source lists hadn\\'t been sorted in the first place. Not only that but it\\'s faster than the reference answers by factors big enough to assume that no tests exist to actually demonstrate the impact of the complexity difference.\\n\\nThis is totally a question worth asking in a face to face interview but seems pointless here ..."
                    },
                    {
                        "username": "gorman",
                        "content": "I found this problem easier than most \"Easy\" problems and got a \"beats 92.26%\" on my only submission.\\nAm I missing something?"
                    },
                    {
                        "username": "CyrilKamal",
                        "content": "nah ur just him"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "first hard problem solved...  #feelsgoodman"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast C++ | Python | Java Solution:\\nhttps://www.nileshblog.tech/2022/04/22/leet-code-merge-k-sorted-lists-c-java-python-solution/"
                    },
                    {
                        "username": "smuuth",
                        "content": "For the c++ submission, it asks to return a pointer, so some solutions are returning pointers to locals within the function. Isnt that going to generate a runtime error - returning a pointer to a local?"
                    },
                    {
                        "username": "user2666H",
                        "content": "Ths same test case ([]) is successful when I execute the program but fails when I submit it. Can anyone please let me know if I am missing something here?\\n\\n![image](https://assets.leetcode.com/users/images/59ea7c13-b619-415a-b263-912b3b607fd9_1623490669.4130723.png)\\n"
                    }
                ]
            },
            {
                "id": 1574112,
                "content": [
                    {
                        "username": "geek_1",
                        "content": "Short and concise solution using min heap and D&C in C++/Java/Python:\\nhttps://www.techiedelight.com/efficiently-merge-k-sorted-linked-lists/\\n"
                    },
                    {
                        "username": "Kiron1023",
                        "content": "Follow the link : https://pastebin.ubuntu.com/p/B7MxFymSTf/\\n# ***CHILL***"
                    },
                    {
                        "username": "ProgramRush",
                        "content": "Hi all,\\n\\nI remember a while back we can filter problem polularity based on a time range (like recent 6 months, 1 year, 18 months and 2 years, etc).\\nI like that feature but cannot find it anymore.\\nDo you know where it is now?\\n\\nThanks,"
                    },
                    {
                        "username": "a0kr8322",
                        "content": "The input for Swift is incorrect. Node\\'s next keeps pointing back to the node itself instead of next node in the list. Please fix this bug!"
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/11/13/Leetcode-23-Merge-k-Sorted-Lists/\\n\\nHope helpful!"
                    },
                    {
                        "username": "bharat18",
                        "content": "![0_1483044108138_upload-f8570d03-da5c-4f54-896b-069d934f1d59](/uploads/files/1483044110941-upload-f8570d03-da5c-4f54-896b-069d934f1d59.png) \\n\\nWhy is the input a list of list. It is supposed to be a list of nodes!"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "it is indeed a list of linkedLists. But it seems as if it is a list of lists, because this is how leetcode likes to represent a linkedList in input."
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "import java.util.PriorityQueue;\\n\\nclass ListNode {\\n    int val;\\n    ListNode next;\\n\\n    ListNode() {}\\n\\n    ListNode(int val) {\\n        this.val = val;\\n    }\\n\\n    ListNode(int val, ListNode next) {\\n        this.val = val;\\n        this.next = next;\\n    }\\n}\\n\\npublic class MergeKSortedLists {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        PriorityQueue<ListNode> minHeap = new PriorityQueue<>((a, b) -> a.val - b.val);\\n\\n        // Add the first element from each list to the minHeap\\n        for (ListNode list : lists) {\\n            if (list != null) {\\n                minHeap.add(list);\\n            }\\n        }\\n\\n        ListNode dummy = new ListNode();\\n        ListNode current = dummy;\\n\\n        // Merge the lists while the minHeap is not empty\\n        while (!minHeap.isEmpty()) {\\n            ListNode node = minHeap.poll();\\n            current.next = node;\\n            current = current.next;\\n\\n            if (node.next != null) {\\n                minHeap.add(node.next);\\n            }\\n        }\\n\\n        return dummy.next;\\n    }\\n\\n    public static void main(String[] args) {\\n        MergeKSortedLists merger = new MergeKSortedLists();\\n\\n        // Example 1\\n        ListNode[] lists1 = {\\n            new ListNode(1, new ListNode(4, new ListNode(5))),\\n            new ListNode(1, new ListNode(3, new ListNode(4))),\\n            new ListNode(2, new ListNode(6))\\n        };\\n        ListNode result1 = merger.mergeKLists(lists1);\\n        printList(result1); // Output: 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6\\n\\n        // Example 2\\n        ListNode[] lists2 = {};\\n        ListNode result2 = merger.mergeKLists(lists2);\\n        printList(result2); // Output: (empty list)\\n\\n        // Example 3\\n        ListNode[] lists3 = {null};\\n        ListNode result3 = merger.mergeKLists(lists3);\\n        printList(result3); // Output: (empty list)\\n    }\\n\\n    // Helper function to print the merged list\\n    private static void printList(ListNode head) {\\n        while (head != null) {\\n            System.out.print(head.val + \" -> \");\\n            head = head.next;\\n        }\\n        System.out.println(\"null\");\\n    }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "Line 7: error: <identifier> expected [in MergeKSortedLists.java]\\n    ListNode[] {}\\n              ^"
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "do not this run"
                    },
                    {
                        "username": "marcus68",
                        "content": "Why does this throw an error\n`        nodes = [ (node.val, node) for node in lists]\n        heapq.heapify(nodes)`\nTypeError: '<' not supported between instances of 'ListNode' and 'ListNode'\n    heapq.heapify(nodes)\nLine 12 in mergeKLists (Solution.py)\n    ret = Solution().mergeKLists(param_1)\nLine 39 in _driver (Solution.py)\n    _driver()\nLine 50 in <module> (Solution.py)"
                    },
                    {
                        "username": "eminimus",
                        "content": "when two node values match, the second item in the tuple will be compared, and ListNode does not implement comparison\\n\\nyou can insert a dummy sequence number as the second item in the tuple, guaranteed to never be equal to another so the comparison will stop there\\n\\nor encapsulate the ListNode in another class, for example one that implements __lt__() returning self.node.val, or subclass int if you wanna get weird"
                    },
                    {
                        "username": "duckhai1",
                        "content": "In Java, the implementation of ListNode of the question is incorrect. Should use Integer type for val properties instead of int type, otherwise there will be no distinction between empty list [] and list with zero element [0]"
                    }
                ]
            },
            {
                "id": 1574047,
                "content": [
                    {
                        "username": "geek_1",
                        "content": "Short and concise solution using min heap and D&C in C++/Java/Python:\\nhttps://www.techiedelight.com/efficiently-merge-k-sorted-linked-lists/\\n"
                    },
                    {
                        "username": "Kiron1023",
                        "content": "Follow the link : https://pastebin.ubuntu.com/p/B7MxFymSTf/\\n# ***CHILL***"
                    },
                    {
                        "username": "ProgramRush",
                        "content": "Hi all,\\n\\nI remember a while back we can filter problem polularity based on a time range (like recent 6 months, 1 year, 18 months and 2 years, etc).\\nI like that feature but cannot find it anymore.\\nDo you know where it is now?\\n\\nThanks,"
                    },
                    {
                        "username": "a0kr8322",
                        "content": "The input for Swift is incorrect. Node\\'s next keeps pointing back to the node itself instead of next node in the list. Please fix this bug!"
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/11/13/Leetcode-23-Merge-k-Sorted-Lists/\\n\\nHope helpful!"
                    },
                    {
                        "username": "bharat18",
                        "content": "![0_1483044108138_upload-f8570d03-da5c-4f54-896b-069d934f1d59](/uploads/files/1483044110941-upload-f8570d03-da5c-4f54-896b-069d934f1d59.png) \\n\\nWhy is the input a list of list. It is supposed to be a list of nodes!"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "it is indeed a list of linkedLists. But it seems as if it is a list of lists, because this is how leetcode likes to represent a linkedList in input."
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "import java.util.PriorityQueue;\\n\\nclass ListNode {\\n    int val;\\n    ListNode next;\\n\\n    ListNode() {}\\n\\n    ListNode(int val) {\\n        this.val = val;\\n    }\\n\\n    ListNode(int val, ListNode next) {\\n        this.val = val;\\n        this.next = next;\\n    }\\n}\\n\\npublic class MergeKSortedLists {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        PriorityQueue<ListNode> minHeap = new PriorityQueue<>((a, b) -> a.val - b.val);\\n\\n        // Add the first element from each list to the minHeap\\n        for (ListNode list : lists) {\\n            if (list != null) {\\n                minHeap.add(list);\\n            }\\n        }\\n\\n        ListNode dummy = new ListNode();\\n        ListNode current = dummy;\\n\\n        // Merge the lists while the minHeap is not empty\\n        while (!minHeap.isEmpty()) {\\n            ListNode node = minHeap.poll();\\n            current.next = node;\\n            current = current.next;\\n\\n            if (node.next != null) {\\n                minHeap.add(node.next);\\n            }\\n        }\\n\\n        return dummy.next;\\n    }\\n\\n    public static void main(String[] args) {\\n        MergeKSortedLists merger = new MergeKSortedLists();\\n\\n        // Example 1\\n        ListNode[] lists1 = {\\n            new ListNode(1, new ListNode(4, new ListNode(5))),\\n            new ListNode(1, new ListNode(3, new ListNode(4))),\\n            new ListNode(2, new ListNode(6))\\n        };\\n        ListNode result1 = merger.mergeKLists(lists1);\\n        printList(result1); // Output: 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6\\n\\n        // Example 2\\n        ListNode[] lists2 = {};\\n        ListNode result2 = merger.mergeKLists(lists2);\\n        printList(result2); // Output: (empty list)\\n\\n        // Example 3\\n        ListNode[] lists3 = {null};\\n        ListNode result3 = merger.mergeKLists(lists3);\\n        printList(result3); // Output: (empty list)\\n    }\\n\\n    // Helper function to print the merged list\\n    private static void printList(ListNode head) {\\n        while (head != null) {\\n            System.out.print(head.val + \" -> \");\\n            head = head.next;\\n        }\\n        System.out.println(\"null\");\\n    }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "Line 7: error: <identifier> expected [in MergeKSortedLists.java]\\n    ListNode[] {}\\n              ^"
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "do not this run"
                    },
                    {
                        "username": "marcus68",
                        "content": "Why does this throw an error\n`        nodes = [ (node.val, node) for node in lists]\n        heapq.heapify(nodes)`\nTypeError: '<' not supported between instances of 'ListNode' and 'ListNode'\n    heapq.heapify(nodes)\nLine 12 in mergeKLists (Solution.py)\n    ret = Solution().mergeKLists(param_1)\nLine 39 in _driver (Solution.py)\n    _driver()\nLine 50 in <module> (Solution.py)"
                    },
                    {
                        "username": "eminimus",
                        "content": "when two node values match, the second item in the tuple will be compared, and ListNode does not implement comparison\\n\\nyou can insert a dummy sequence number as the second item in the tuple, guaranteed to never be equal to another so the comparison will stop there\\n\\nor encapsulate the ListNode in another class, for example one that implements __lt__() returning self.node.val, or subclass int if you wanna get weird"
                    },
                    {
                        "username": "duckhai1",
                        "content": "In Java, the implementation of ListNode of the question is incorrect. Should use Integer type for val properties instead of int type, otherwise there will be no distinction between empty list [] and list with zero element [0]"
                    }
                ]
            },
            {
                "id": 1573349,
                "content": [
                    {
                        "username": "geek_1",
                        "content": "Short and concise solution using min heap and D&C in C++/Java/Python:\\nhttps://www.techiedelight.com/efficiently-merge-k-sorted-linked-lists/\\n"
                    },
                    {
                        "username": "Kiron1023",
                        "content": "Follow the link : https://pastebin.ubuntu.com/p/B7MxFymSTf/\\n# ***CHILL***"
                    },
                    {
                        "username": "ProgramRush",
                        "content": "Hi all,\\n\\nI remember a while back we can filter problem polularity based on a time range (like recent 6 months, 1 year, 18 months and 2 years, etc).\\nI like that feature but cannot find it anymore.\\nDo you know where it is now?\\n\\nThanks,"
                    },
                    {
                        "username": "a0kr8322",
                        "content": "The input for Swift is incorrect. Node\\'s next keeps pointing back to the node itself instead of next node in the list. Please fix this bug!"
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/11/13/Leetcode-23-Merge-k-Sorted-Lists/\\n\\nHope helpful!"
                    },
                    {
                        "username": "bharat18",
                        "content": "![0_1483044108138_upload-f8570d03-da5c-4f54-896b-069d934f1d59](/uploads/files/1483044110941-upload-f8570d03-da5c-4f54-896b-069d934f1d59.png) \\n\\nWhy is the input a list of list. It is supposed to be a list of nodes!"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "it is indeed a list of linkedLists. But it seems as if it is a list of lists, because this is how leetcode likes to represent a linkedList in input."
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "import java.util.PriorityQueue;\\n\\nclass ListNode {\\n    int val;\\n    ListNode next;\\n\\n    ListNode() {}\\n\\n    ListNode(int val) {\\n        this.val = val;\\n    }\\n\\n    ListNode(int val, ListNode next) {\\n        this.val = val;\\n        this.next = next;\\n    }\\n}\\n\\npublic class MergeKSortedLists {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        PriorityQueue<ListNode> minHeap = new PriorityQueue<>((a, b) -> a.val - b.val);\\n\\n        // Add the first element from each list to the minHeap\\n        for (ListNode list : lists) {\\n            if (list != null) {\\n                minHeap.add(list);\\n            }\\n        }\\n\\n        ListNode dummy = new ListNode();\\n        ListNode current = dummy;\\n\\n        // Merge the lists while the minHeap is not empty\\n        while (!minHeap.isEmpty()) {\\n            ListNode node = minHeap.poll();\\n            current.next = node;\\n            current = current.next;\\n\\n            if (node.next != null) {\\n                minHeap.add(node.next);\\n            }\\n        }\\n\\n        return dummy.next;\\n    }\\n\\n    public static void main(String[] args) {\\n        MergeKSortedLists merger = new MergeKSortedLists();\\n\\n        // Example 1\\n        ListNode[] lists1 = {\\n            new ListNode(1, new ListNode(4, new ListNode(5))),\\n            new ListNode(1, new ListNode(3, new ListNode(4))),\\n            new ListNode(2, new ListNode(6))\\n        };\\n        ListNode result1 = merger.mergeKLists(lists1);\\n        printList(result1); // Output: 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6\\n\\n        // Example 2\\n        ListNode[] lists2 = {};\\n        ListNode result2 = merger.mergeKLists(lists2);\\n        printList(result2); // Output: (empty list)\\n\\n        // Example 3\\n        ListNode[] lists3 = {null};\\n        ListNode result3 = merger.mergeKLists(lists3);\\n        printList(result3); // Output: (empty list)\\n    }\\n\\n    // Helper function to print the merged list\\n    private static void printList(ListNode head) {\\n        while (head != null) {\\n            System.out.print(head.val + \" -> \");\\n            head = head.next;\\n        }\\n        System.out.println(\"null\");\\n    }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "Line 7: error: <identifier> expected [in MergeKSortedLists.java]\\n    ListNode[] {}\\n              ^"
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "do not this run"
                    },
                    {
                        "username": "marcus68",
                        "content": "Why does this throw an error\n`        nodes = [ (node.val, node) for node in lists]\n        heapq.heapify(nodes)`\nTypeError: '<' not supported between instances of 'ListNode' and 'ListNode'\n    heapq.heapify(nodes)\nLine 12 in mergeKLists (Solution.py)\n    ret = Solution().mergeKLists(param_1)\nLine 39 in _driver (Solution.py)\n    _driver()\nLine 50 in <module> (Solution.py)"
                    },
                    {
                        "username": "eminimus",
                        "content": "when two node values match, the second item in the tuple will be compared, and ListNode does not implement comparison\\n\\nyou can insert a dummy sequence number as the second item in the tuple, guaranteed to never be equal to another so the comparison will stop there\\n\\nor encapsulate the ListNode in another class, for example one that implements __lt__() returning self.node.val, or subclass int if you wanna get weird"
                    },
                    {
                        "username": "duckhai1",
                        "content": "In Java, the implementation of ListNode of the question is incorrect. Should use Integer type for val properties instead of int type, otherwise there will be no distinction between empty list [] and list with zero element [0]"
                    }
                ]
            },
            {
                "id": 1572590,
                "content": [
                    {
                        "username": "geek_1",
                        "content": "Short and concise solution using min heap and D&C in C++/Java/Python:\\nhttps://www.techiedelight.com/efficiently-merge-k-sorted-linked-lists/\\n"
                    },
                    {
                        "username": "Kiron1023",
                        "content": "Follow the link : https://pastebin.ubuntu.com/p/B7MxFymSTf/\\n# ***CHILL***"
                    },
                    {
                        "username": "ProgramRush",
                        "content": "Hi all,\\n\\nI remember a while back we can filter problem polularity based on a time range (like recent 6 months, 1 year, 18 months and 2 years, etc).\\nI like that feature but cannot find it anymore.\\nDo you know where it is now?\\n\\nThanks,"
                    },
                    {
                        "username": "a0kr8322",
                        "content": "The input for Swift is incorrect. Node\\'s next keeps pointing back to the node itself instead of next node in the list. Please fix this bug!"
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/11/13/Leetcode-23-Merge-k-Sorted-Lists/\\n\\nHope helpful!"
                    },
                    {
                        "username": "bharat18",
                        "content": "![0_1483044108138_upload-f8570d03-da5c-4f54-896b-069d934f1d59](/uploads/files/1483044110941-upload-f8570d03-da5c-4f54-896b-069d934f1d59.png) \\n\\nWhy is the input a list of list. It is supposed to be a list of nodes!"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "it is indeed a list of linkedLists. But it seems as if it is a list of lists, because this is how leetcode likes to represent a linkedList in input."
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "import java.util.PriorityQueue;\\n\\nclass ListNode {\\n    int val;\\n    ListNode next;\\n\\n    ListNode() {}\\n\\n    ListNode(int val) {\\n        this.val = val;\\n    }\\n\\n    ListNode(int val, ListNode next) {\\n        this.val = val;\\n        this.next = next;\\n    }\\n}\\n\\npublic class MergeKSortedLists {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        PriorityQueue<ListNode> minHeap = new PriorityQueue<>((a, b) -> a.val - b.val);\\n\\n        // Add the first element from each list to the minHeap\\n        for (ListNode list : lists) {\\n            if (list != null) {\\n                minHeap.add(list);\\n            }\\n        }\\n\\n        ListNode dummy = new ListNode();\\n        ListNode current = dummy;\\n\\n        // Merge the lists while the minHeap is not empty\\n        while (!minHeap.isEmpty()) {\\n            ListNode node = minHeap.poll();\\n            current.next = node;\\n            current = current.next;\\n\\n            if (node.next != null) {\\n                minHeap.add(node.next);\\n            }\\n        }\\n\\n        return dummy.next;\\n    }\\n\\n    public static void main(String[] args) {\\n        MergeKSortedLists merger = new MergeKSortedLists();\\n\\n        // Example 1\\n        ListNode[] lists1 = {\\n            new ListNode(1, new ListNode(4, new ListNode(5))),\\n            new ListNode(1, new ListNode(3, new ListNode(4))),\\n            new ListNode(2, new ListNode(6))\\n        };\\n        ListNode result1 = merger.mergeKLists(lists1);\\n        printList(result1); // Output: 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6\\n\\n        // Example 2\\n        ListNode[] lists2 = {};\\n        ListNode result2 = merger.mergeKLists(lists2);\\n        printList(result2); // Output: (empty list)\\n\\n        // Example 3\\n        ListNode[] lists3 = {null};\\n        ListNode result3 = merger.mergeKLists(lists3);\\n        printList(result3); // Output: (empty list)\\n    }\\n\\n    // Helper function to print the merged list\\n    private static void printList(ListNode head) {\\n        while (head != null) {\\n            System.out.print(head.val + \" -> \");\\n            head = head.next;\\n        }\\n        System.out.println(\"null\");\\n    }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "Line 7: error: <identifier> expected [in MergeKSortedLists.java]\\n    ListNode[] {}\\n              ^"
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "do not this run"
                    },
                    {
                        "username": "marcus68",
                        "content": "Why does this throw an error\n`        nodes = [ (node.val, node) for node in lists]\n        heapq.heapify(nodes)`\nTypeError: '<' not supported between instances of 'ListNode' and 'ListNode'\n    heapq.heapify(nodes)\nLine 12 in mergeKLists (Solution.py)\n    ret = Solution().mergeKLists(param_1)\nLine 39 in _driver (Solution.py)\n    _driver()\nLine 50 in <module> (Solution.py)"
                    },
                    {
                        "username": "eminimus",
                        "content": "when two node values match, the second item in the tuple will be compared, and ListNode does not implement comparison\\n\\nyou can insert a dummy sequence number as the second item in the tuple, guaranteed to never be equal to another so the comparison will stop there\\n\\nor encapsulate the ListNode in another class, for example one that implements __lt__() returning self.node.val, or subclass int if you wanna get weird"
                    },
                    {
                        "username": "duckhai1",
                        "content": "In Java, the implementation of ListNode of the question is incorrect. Should use Integer type for val properties instead of int type, otherwise there will be no distinction between empty list [] and list with zero element [0]"
                    }
                ]
            },
            {
                "id": 1572267,
                "content": [
                    {
                        "username": "geek_1",
                        "content": "Short and concise solution using min heap and D&C in C++/Java/Python:\\nhttps://www.techiedelight.com/efficiently-merge-k-sorted-linked-lists/\\n"
                    },
                    {
                        "username": "Kiron1023",
                        "content": "Follow the link : https://pastebin.ubuntu.com/p/B7MxFymSTf/\\n# ***CHILL***"
                    },
                    {
                        "username": "ProgramRush",
                        "content": "Hi all,\\n\\nI remember a while back we can filter problem polularity based on a time range (like recent 6 months, 1 year, 18 months and 2 years, etc).\\nI like that feature but cannot find it anymore.\\nDo you know where it is now?\\n\\nThanks,"
                    },
                    {
                        "username": "a0kr8322",
                        "content": "The input for Swift is incorrect. Node\\'s next keeps pointing back to the node itself instead of next node in the list. Please fix this bug!"
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/11/13/Leetcode-23-Merge-k-Sorted-Lists/\\n\\nHope helpful!"
                    },
                    {
                        "username": "bharat18",
                        "content": "![0_1483044108138_upload-f8570d03-da5c-4f54-896b-069d934f1d59](/uploads/files/1483044110941-upload-f8570d03-da5c-4f54-896b-069d934f1d59.png) \\n\\nWhy is the input a list of list. It is supposed to be a list of nodes!"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "it is indeed a list of linkedLists. But it seems as if it is a list of lists, because this is how leetcode likes to represent a linkedList in input."
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "import java.util.PriorityQueue;\\n\\nclass ListNode {\\n    int val;\\n    ListNode next;\\n\\n    ListNode() {}\\n\\n    ListNode(int val) {\\n        this.val = val;\\n    }\\n\\n    ListNode(int val, ListNode next) {\\n        this.val = val;\\n        this.next = next;\\n    }\\n}\\n\\npublic class MergeKSortedLists {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        PriorityQueue<ListNode> minHeap = new PriorityQueue<>((a, b) -> a.val - b.val);\\n\\n        // Add the first element from each list to the minHeap\\n        for (ListNode list : lists) {\\n            if (list != null) {\\n                minHeap.add(list);\\n            }\\n        }\\n\\n        ListNode dummy = new ListNode();\\n        ListNode current = dummy;\\n\\n        // Merge the lists while the minHeap is not empty\\n        while (!minHeap.isEmpty()) {\\n            ListNode node = minHeap.poll();\\n            current.next = node;\\n            current = current.next;\\n\\n            if (node.next != null) {\\n                minHeap.add(node.next);\\n            }\\n        }\\n\\n        return dummy.next;\\n    }\\n\\n    public static void main(String[] args) {\\n        MergeKSortedLists merger = new MergeKSortedLists();\\n\\n        // Example 1\\n        ListNode[] lists1 = {\\n            new ListNode(1, new ListNode(4, new ListNode(5))),\\n            new ListNode(1, new ListNode(3, new ListNode(4))),\\n            new ListNode(2, new ListNode(6))\\n        };\\n        ListNode result1 = merger.mergeKLists(lists1);\\n        printList(result1); // Output: 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6\\n\\n        // Example 2\\n        ListNode[] lists2 = {};\\n        ListNode result2 = merger.mergeKLists(lists2);\\n        printList(result2); // Output: (empty list)\\n\\n        // Example 3\\n        ListNode[] lists3 = {null};\\n        ListNode result3 = merger.mergeKLists(lists3);\\n        printList(result3); // Output: (empty list)\\n    }\\n\\n    // Helper function to print the merged list\\n    private static void printList(ListNode head) {\\n        while (head != null) {\\n            System.out.print(head.val + \" -> \");\\n            head = head.next;\\n        }\\n        System.out.println(\"null\");\\n    }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "Line 7: error: <identifier> expected [in MergeKSortedLists.java]\\n    ListNode[] {}\\n              ^"
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "do not this run"
                    },
                    {
                        "username": "marcus68",
                        "content": "Why does this throw an error\n`        nodes = [ (node.val, node) for node in lists]\n        heapq.heapify(nodes)`\nTypeError: '<' not supported between instances of 'ListNode' and 'ListNode'\n    heapq.heapify(nodes)\nLine 12 in mergeKLists (Solution.py)\n    ret = Solution().mergeKLists(param_1)\nLine 39 in _driver (Solution.py)\n    _driver()\nLine 50 in <module> (Solution.py)"
                    },
                    {
                        "username": "eminimus",
                        "content": "when two node values match, the second item in the tuple will be compared, and ListNode does not implement comparison\\n\\nyou can insert a dummy sequence number as the second item in the tuple, guaranteed to never be equal to another so the comparison will stop there\\n\\nor encapsulate the ListNode in another class, for example one that implements __lt__() returning self.node.val, or subclass int if you wanna get weird"
                    },
                    {
                        "username": "duckhai1",
                        "content": "In Java, the implementation of ListNode of the question is incorrect. Should use Integer type for val properties instead of int type, otherwise there will be no distinction between empty list [] and list with zero element [0]"
                    }
                ]
            },
            {
                "id": 1571060,
                "content": [
                    {
                        "username": "geek_1",
                        "content": "Short and concise solution using min heap and D&C in C++/Java/Python:\\nhttps://www.techiedelight.com/efficiently-merge-k-sorted-linked-lists/\\n"
                    },
                    {
                        "username": "Kiron1023",
                        "content": "Follow the link : https://pastebin.ubuntu.com/p/B7MxFymSTf/\\n# ***CHILL***"
                    },
                    {
                        "username": "ProgramRush",
                        "content": "Hi all,\\n\\nI remember a while back we can filter problem polularity based on a time range (like recent 6 months, 1 year, 18 months and 2 years, etc).\\nI like that feature but cannot find it anymore.\\nDo you know where it is now?\\n\\nThanks,"
                    },
                    {
                        "username": "a0kr8322",
                        "content": "The input for Swift is incorrect. Node\\'s next keeps pointing back to the node itself instead of next node in the list. Please fix this bug!"
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/11/13/Leetcode-23-Merge-k-Sorted-Lists/\\n\\nHope helpful!"
                    },
                    {
                        "username": "bharat18",
                        "content": "![0_1483044108138_upload-f8570d03-da5c-4f54-896b-069d934f1d59](/uploads/files/1483044110941-upload-f8570d03-da5c-4f54-896b-069d934f1d59.png) \\n\\nWhy is the input a list of list. It is supposed to be a list of nodes!"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "it is indeed a list of linkedLists. But it seems as if it is a list of lists, because this is how leetcode likes to represent a linkedList in input."
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "import java.util.PriorityQueue;\\n\\nclass ListNode {\\n    int val;\\n    ListNode next;\\n\\n    ListNode() {}\\n\\n    ListNode(int val) {\\n        this.val = val;\\n    }\\n\\n    ListNode(int val, ListNode next) {\\n        this.val = val;\\n        this.next = next;\\n    }\\n}\\n\\npublic class MergeKSortedLists {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        PriorityQueue<ListNode> minHeap = new PriorityQueue<>((a, b) -> a.val - b.val);\\n\\n        // Add the first element from each list to the minHeap\\n        for (ListNode list : lists) {\\n            if (list != null) {\\n                minHeap.add(list);\\n            }\\n        }\\n\\n        ListNode dummy = new ListNode();\\n        ListNode current = dummy;\\n\\n        // Merge the lists while the minHeap is not empty\\n        while (!minHeap.isEmpty()) {\\n            ListNode node = minHeap.poll();\\n            current.next = node;\\n            current = current.next;\\n\\n            if (node.next != null) {\\n                minHeap.add(node.next);\\n            }\\n        }\\n\\n        return dummy.next;\\n    }\\n\\n    public static void main(String[] args) {\\n        MergeKSortedLists merger = new MergeKSortedLists();\\n\\n        // Example 1\\n        ListNode[] lists1 = {\\n            new ListNode(1, new ListNode(4, new ListNode(5))),\\n            new ListNode(1, new ListNode(3, new ListNode(4))),\\n            new ListNode(2, new ListNode(6))\\n        };\\n        ListNode result1 = merger.mergeKLists(lists1);\\n        printList(result1); // Output: 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6\\n\\n        // Example 2\\n        ListNode[] lists2 = {};\\n        ListNode result2 = merger.mergeKLists(lists2);\\n        printList(result2); // Output: (empty list)\\n\\n        // Example 3\\n        ListNode[] lists3 = {null};\\n        ListNode result3 = merger.mergeKLists(lists3);\\n        printList(result3); // Output: (empty list)\\n    }\\n\\n    // Helper function to print the merged list\\n    private static void printList(ListNode head) {\\n        while (head != null) {\\n            System.out.print(head.val + \" -> \");\\n            head = head.next;\\n        }\\n        System.out.println(\"null\");\\n    }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "Line 7: error: <identifier> expected [in MergeKSortedLists.java]\\n    ListNode[] {}\\n              ^"
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "do not this run"
                    },
                    {
                        "username": "marcus68",
                        "content": "Why does this throw an error\n`        nodes = [ (node.val, node) for node in lists]\n        heapq.heapify(nodes)`\nTypeError: '<' not supported between instances of 'ListNode' and 'ListNode'\n    heapq.heapify(nodes)\nLine 12 in mergeKLists (Solution.py)\n    ret = Solution().mergeKLists(param_1)\nLine 39 in _driver (Solution.py)\n    _driver()\nLine 50 in <module> (Solution.py)"
                    },
                    {
                        "username": "eminimus",
                        "content": "when two node values match, the second item in the tuple will be compared, and ListNode does not implement comparison\\n\\nyou can insert a dummy sequence number as the second item in the tuple, guaranteed to never be equal to another so the comparison will stop there\\n\\nor encapsulate the ListNode in another class, for example one that implements __lt__() returning self.node.val, or subclass int if you wanna get weird"
                    },
                    {
                        "username": "duckhai1",
                        "content": "In Java, the implementation of ListNode of the question is incorrect. Should use Integer type for val properties instead of int type, otherwise there will be no distinction between empty list [] and list with zero element [0]"
                    }
                ]
            },
            {
                "id": 2065192,
                "content": [
                    {
                        "username": "geek_1",
                        "content": "Short and concise solution using min heap and D&C in C++/Java/Python:\\nhttps://www.techiedelight.com/efficiently-merge-k-sorted-linked-lists/\\n"
                    },
                    {
                        "username": "Kiron1023",
                        "content": "Follow the link : https://pastebin.ubuntu.com/p/B7MxFymSTf/\\n# ***CHILL***"
                    },
                    {
                        "username": "ProgramRush",
                        "content": "Hi all,\\n\\nI remember a while back we can filter problem polularity based on a time range (like recent 6 months, 1 year, 18 months and 2 years, etc).\\nI like that feature but cannot find it anymore.\\nDo you know where it is now?\\n\\nThanks,"
                    },
                    {
                        "username": "a0kr8322",
                        "content": "The input for Swift is incorrect. Node\\'s next keeps pointing back to the node itself instead of next node in the list. Please fix this bug!"
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/11/13/Leetcode-23-Merge-k-Sorted-Lists/\\n\\nHope helpful!"
                    },
                    {
                        "username": "bharat18",
                        "content": "![0_1483044108138_upload-f8570d03-da5c-4f54-896b-069d934f1d59](/uploads/files/1483044110941-upload-f8570d03-da5c-4f54-896b-069d934f1d59.png) \\n\\nWhy is the input a list of list. It is supposed to be a list of nodes!"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "it is indeed a list of linkedLists. But it seems as if it is a list of lists, because this is how leetcode likes to represent a linkedList in input."
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "import java.util.PriorityQueue;\\n\\nclass ListNode {\\n    int val;\\n    ListNode next;\\n\\n    ListNode() {}\\n\\n    ListNode(int val) {\\n        this.val = val;\\n    }\\n\\n    ListNode(int val, ListNode next) {\\n        this.val = val;\\n        this.next = next;\\n    }\\n}\\n\\npublic class MergeKSortedLists {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        PriorityQueue<ListNode> minHeap = new PriorityQueue<>((a, b) -> a.val - b.val);\\n\\n        // Add the first element from each list to the minHeap\\n        for (ListNode list : lists) {\\n            if (list != null) {\\n                minHeap.add(list);\\n            }\\n        }\\n\\n        ListNode dummy = new ListNode();\\n        ListNode current = dummy;\\n\\n        // Merge the lists while the minHeap is not empty\\n        while (!minHeap.isEmpty()) {\\n            ListNode node = minHeap.poll();\\n            current.next = node;\\n            current = current.next;\\n\\n            if (node.next != null) {\\n                minHeap.add(node.next);\\n            }\\n        }\\n\\n        return dummy.next;\\n    }\\n\\n    public static void main(String[] args) {\\n        MergeKSortedLists merger = new MergeKSortedLists();\\n\\n        // Example 1\\n        ListNode[] lists1 = {\\n            new ListNode(1, new ListNode(4, new ListNode(5))),\\n            new ListNode(1, new ListNode(3, new ListNode(4))),\\n            new ListNode(2, new ListNode(6))\\n        };\\n        ListNode result1 = merger.mergeKLists(lists1);\\n        printList(result1); // Output: 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6\\n\\n        // Example 2\\n        ListNode[] lists2 = {};\\n        ListNode result2 = merger.mergeKLists(lists2);\\n        printList(result2); // Output: (empty list)\\n\\n        // Example 3\\n        ListNode[] lists3 = {null};\\n        ListNode result3 = merger.mergeKLists(lists3);\\n        printList(result3); // Output: (empty list)\\n    }\\n\\n    // Helper function to print the merged list\\n    private static void printList(ListNode head) {\\n        while (head != null) {\\n            System.out.print(head.val + \" -> \");\\n            head = head.next;\\n        }\\n        System.out.println(\"null\");\\n    }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "Line 7: error: <identifier> expected [in MergeKSortedLists.java]\\n    ListNode[] {}\\n              ^"
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "do not this run"
                    },
                    {
                        "username": "marcus68",
                        "content": "Why does this throw an error\n`        nodes = [ (node.val, node) for node in lists]\n        heapq.heapify(nodes)`\nTypeError: '<' not supported between instances of 'ListNode' and 'ListNode'\n    heapq.heapify(nodes)\nLine 12 in mergeKLists (Solution.py)\n    ret = Solution().mergeKLists(param_1)\nLine 39 in _driver (Solution.py)\n    _driver()\nLine 50 in <module> (Solution.py)"
                    },
                    {
                        "username": "eminimus",
                        "content": "when two node values match, the second item in the tuple will be compared, and ListNode does not implement comparison\\n\\nyou can insert a dummy sequence number as the second item in the tuple, guaranteed to never be equal to another so the comparison will stop there\\n\\nor encapsulate the ListNode in another class, for example one that implements __lt__() returning self.node.val, or subclass int if you wanna get weird"
                    },
                    {
                        "username": "duckhai1",
                        "content": "In Java, the implementation of ListNode of the question is incorrect. Should use Integer type for val properties instead of int type, otherwise there will be no distinction between empty list [] and list with zero element [0]"
                    }
                ]
            },
            {
                "id": 2065191,
                "content": [
                    {
                        "username": "geek_1",
                        "content": "Short and concise solution using min heap and D&C in C++/Java/Python:\\nhttps://www.techiedelight.com/efficiently-merge-k-sorted-linked-lists/\\n"
                    },
                    {
                        "username": "Kiron1023",
                        "content": "Follow the link : https://pastebin.ubuntu.com/p/B7MxFymSTf/\\n# ***CHILL***"
                    },
                    {
                        "username": "ProgramRush",
                        "content": "Hi all,\\n\\nI remember a while back we can filter problem polularity based on a time range (like recent 6 months, 1 year, 18 months and 2 years, etc).\\nI like that feature but cannot find it anymore.\\nDo you know where it is now?\\n\\nThanks,"
                    },
                    {
                        "username": "a0kr8322",
                        "content": "The input for Swift is incorrect. Node\\'s next keeps pointing back to the node itself instead of next node in the list. Please fix this bug!"
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/11/13/Leetcode-23-Merge-k-Sorted-Lists/\\n\\nHope helpful!"
                    },
                    {
                        "username": "bharat18",
                        "content": "![0_1483044108138_upload-f8570d03-da5c-4f54-896b-069d934f1d59](/uploads/files/1483044110941-upload-f8570d03-da5c-4f54-896b-069d934f1d59.png) \\n\\nWhy is the input a list of list. It is supposed to be a list of nodes!"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "it is indeed a list of linkedLists. But it seems as if it is a list of lists, because this is how leetcode likes to represent a linkedList in input."
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "import java.util.PriorityQueue;\\n\\nclass ListNode {\\n    int val;\\n    ListNode next;\\n\\n    ListNode() {}\\n\\n    ListNode(int val) {\\n        this.val = val;\\n    }\\n\\n    ListNode(int val, ListNode next) {\\n        this.val = val;\\n        this.next = next;\\n    }\\n}\\n\\npublic class MergeKSortedLists {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        PriorityQueue<ListNode> minHeap = new PriorityQueue<>((a, b) -> a.val - b.val);\\n\\n        // Add the first element from each list to the minHeap\\n        for (ListNode list : lists) {\\n            if (list != null) {\\n                minHeap.add(list);\\n            }\\n        }\\n\\n        ListNode dummy = new ListNode();\\n        ListNode current = dummy;\\n\\n        // Merge the lists while the minHeap is not empty\\n        while (!minHeap.isEmpty()) {\\n            ListNode node = minHeap.poll();\\n            current.next = node;\\n            current = current.next;\\n\\n            if (node.next != null) {\\n                minHeap.add(node.next);\\n            }\\n        }\\n\\n        return dummy.next;\\n    }\\n\\n    public static void main(String[] args) {\\n        MergeKSortedLists merger = new MergeKSortedLists();\\n\\n        // Example 1\\n        ListNode[] lists1 = {\\n            new ListNode(1, new ListNode(4, new ListNode(5))),\\n            new ListNode(1, new ListNode(3, new ListNode(4))),\\n            new ListNode(2, new ListNode(6))\\n        };\\n        ListNode result1 = merger.mergeKLists(lists1);\\n        printList(result1); // Output: 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6\\n\\n        // Example 2\\n        ListNode[] lists2 = {};\\n        ListNode result2 = merger.mergeKLists(lists2);\\n        printList(result2); // Output: (empty list)\\n\\n        // Example 3\\n        ListNode[] lists3 = {null};\\n        ListNode result3 = merger.mergeKLists(lists3);\\n        printList(result3); // Output: (empty list)\\n    }\\n\\n    // Helper function to print the merged list\\n    private static void printList(ListNode head) {\\n        while (head != null) {\\n            System.out.print(head.val + \" -> \");\\n            head = head.next;\\n        }\\n        System.out.println(\"null\");\\n    }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "Line 7: error: <identifier> expected [in MergeKSortedLists.java]\\n    ListNode[] {}\\n              ^"
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "do not this run"
                    },
                    {
                        "username": "marcus68",
                        "content": "Why does this throw an error\n`        nodes = [ (node.val, node) for node in lists]\n        heapq.heapify(nodes)`\nTypeError: '<' not supported between instances of 'ListNode' and 'ListNode'\n    heapq.heapify(nodes)\nLine 12 in mergeKLists (Solution.py)\n    ret = Solution().mergeKLists(param_1)\nLine 39 in _driver (Solution.py)\n    _driver()\nLine 50 in <module> (Solution.py)"
                    },
                    {
                        "username": "eminimus",
                        "content": "when two node values match, the second item in the tuple will be compared, and ListNode does not implement comparison\\n\\nyou can insert a dummy sequence number as the second item in the tuple, guaranteed to never be equal to another so the comparison will stop there\\n\\nor encapsulate the ListNode in another class, for example one that implements __lt__() returning self.node.val, or subclass int if you wanna get weird"
                    },
                    {
                        "username": "duckhai1",
                        "content": "In Java, the implementation of ListNode of the question is incorrect. Should use Integer type for val properties instead of int type, otherwise there will be no distinction between empty list [] and list with zero element [0]"
                    }
                ]
            },
            {
                "id": 2046672,
                "content": [
                    {
                        "username": "geek_1",
                        "content": "Short and concise solution using min heap and D&C in C++/Java/Python:\\nhttps://www.techiedelight.com/efficiently-merge-k-sorted-linked-lists/\\n"
                    },
                    {
                        "username": "Kiron1023",
                        "content": "Follow the link : https://pastebin.ubuntu.com/p/B7MxFymSTf/\\n# ***CHILL***"
                    },
                    {
                        "username": "ProgramRush",
                        "content": "Hi all,\\n\\nI remember a while back we can filter problem polularity based on a time range (like recent 6 months, 1 year, 18 months and 2 years, etc).\\nI like that feature but cannot find it anymore.\\nDo you know where it is now?\\n\\nThanks,"
                    },
                    {
                        "username": "a0kr8322",
                        "content": "The input for Swift is incorrect. Node\\'s next keeps pointing back to the node itself instead of next node in the list. Please fix this bug!"
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/11/13/Leetcode-23-Merge-k-Sorted-Lists/\\n\\nHope helpful!"
                    },
                    {
                        "username": "bharat18",
                        "content": "![0_1483044108138_upload-f8570d03-da5c-4f54-896b-069d934f1d59](/uploads/files/1483044110941-upload-f8570d03-da5c-4f54-896b-069d934f1d59.png) \\n\\nWhy is the input a list of list. It is supposed to be a list of nodes!"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "it is indeed a list of linkedLists. But it seems as if it is a list of lists, because this is how leetcode likes to represent a linkedList in input."
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "import java.util.PriorityQueue;\\n\\nclass ListNode {\\n    int val;\\n    ListNode next;\\n\\n    ListNode() {}\\n\\n    ListNode(int val) {\\n        this.val = val;\\n    }\\n\\n    ListNode(int val, ListNode next) {\\n        this.val = val;\\n        this.next = next;\\n    }\\n}\\n\\npublic class MergeKSortedLists {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        PriorityQueue<ListNode> minHeap = new PriorityQueue<>((a, b) -> a.val - b.val);\\n\\n        // Add the first element from each list to the minHeap\\n        for (ListNode list : lists) {\\n            if (list != null) {\\n                minHeap.add(list);\\n            }\\n        }\\n\\n        ListNode dummy = new ListNode();\\n        ListNode current = dummy;\\n\\n        // Merge the lists while the minHeap is not empty\\n        while (!minHeap.isEmpty()) {\\n            ListNode node = minHeap.poll();\\n            current.next = node;\\n            current = current.next;\\n\\n            if (node.next != null) {\\n                minHeap.add(node.next);\\n            }\\n        }\\n\\n        return dummy.next;\\n    }\\n\\n    public static void main(String[] args) {\\n        MergeKSortedLists merger = new MergeKSortedLists();\\n\\n        // Example 1\\n        ListNode[] lists1 = {\\n            new ListNode(1, new ListNode(4, new ListNode(5))),\\n            new ListNode(1, new ListNode(3, new ListNode(4))),\\n            new ListNode(2, new ListNode(6))\\n        };\\n        ListNode result1 = merger.mergeKLists(lists1);\\n        printList(result1); // Output: 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6\\n\\n        // Example 2\\n        ListNode[] lists2 = {};\\n        ListNode result2 = merger.mergeKLists(lists2);\\n        printList(result2); // Output: (empty list)\\n\\n        // Example 3\\n        ListNode[] lists3 = {null};\\n        ListNode result3 = merger.mergeKLists(lists3);\\n        printList(result3); // Output: (empty list)\\n    }\\n\\n    // Helper function to print the merged list\\n    private static void printList(ListNode head) {\\n        while (head != null) {\\n            System.out.print(head.val + \" -> \");\\n            head = head.next;\\n        }\\n        System.out.println(\"null\");\\n    }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "Line 7: error: <identifier> expected [in MergeKSortedLists.java]\\n    ListNode[] {}\\n              ^"
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "do not this run"
                    },
                    {
                        "username": "marcus68",
                        "content": "Why does this throw an error\n`        nodes = [ (node.val, node) for node in lists]\n        heapq.heapify(nodes)`\nTypeError: '<' not supported between instances of 'ListNode' and 'ListNode'\n    heapq.heapify(nodes)\nLine 12 in mergeKLists (Solution.py)\n    ret = Solution().mergeKLists(param_1)\nLine 39 in _driver (Solution.py)\n    _driver()\nLine 50 in <module> (Solution.py)"
                    },
                    {
                        "username": "eminimus",
                        "content": "when two node values match, the second item in the tuple will be compared, and ListNode does not implement comparison\\n\\nyou can insert a dummy sequence number as the second item in the tuple, guaranteed to never be equal to another so the comparison will stop there\\n\\nor encapsulate the ListNode in another class, for example one that implements __lt__() returning self.node.val, or subclass int if you wanna get weird"
                    },
                    {
                        "username": "duckhai1",
                        "content": "In Java, the implementation of ListNode of the question is incorrect. Should use Integer type for val properties instead of int type, otherwise there will be no distinction between empty list [] and list with zero element [0]"
                    }
                ]
            },
            {
                "id": 2039845,
                "content": [
                    {
                        "username": "geek_1",
                        "content": "Short and concise solution using min heap and D&C in C++/Java/Python:\\nhttps://www.techiedelight.com/efficiently-merge-k-sorted-linked-lists/\\n"
                    },
                    {
                        "username": "Kiron1023",
                        "content": "Follow the link : https://pastebin.ubuntu.com/p/B7MxFymSTf/\\n# ***CHILL***"
                    },
                    {
                        "username": "ProgramRush",
                        "content": "Hi all,\\n\\nI remember a while back we can filter problem polularity based on a time range (like recent 6 months, 1 year, 18 months and 2 years, etc).\\nI like that feature but cannot find it anymore.\\nDo you know where it is now?\\n\\nThanks,"
                    },
                    {
                        "username": "a0kr8322",
                        "content": "The input for Swift is incorrect. Node\\'s next keeps pointing back to the node itself instead of next node in the list. Please fix this bug!"
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.github.io/2018/11/13/Leetcode-23-Merge-k-Sorted-Lists/\\n\\nHope helpful!"
                    },
                    {
                        "username": "bharat18",
                        "content": "![0_1483044108138_upload-f8570d03-da5c-4f54-896b-069d934f1d59](/uploads/files/1483044110941-upload-f8570d03-da5c-4f54-896b-069d934f1d59.png) \\n\\nWhy is the input a list of list. It is supposed to be a list of nodes!"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "it is indeed a list of linkedLists. But it seems as if it is a list of lists, because this is how leetcode likes to represent a linkedList in input."
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "import java.util.PriorityQueue;\\n\\nclass ListNode {\\n    int val;\\n    ListNode next;\\n\\n    ListNode() {}\\n\\n    ListNode(int val) {\\n        this.val = val;\\n    }\\n\\n    ListNode(int val, ListNode next) {\\n        this.val = val;\\n        this.next = next;\\n    }\\n}\\n\\npublic class MergeKSortedLists {\\n    public ListNode mergeKLists(ListNode[] lists) {\\n        PriorityQueue<ListNode> minHeap = new PriorityQueue<>((a, b) -> a.val - b.val);\\n\\n        // Add the first element from each list to the minHeap\\n        for (ListNode list : lists) {\\n            if (list != null) {\\n                minHeap.add(list);\\n            }\\n        }\\n\\n        ListNode dummy = new ListNode();\\n        ListNode current = dummy;\\n\\n        // Merge the lists while the minHeap is not empty\\n        while (!minHeap.isEmpty()) {\\n            ListNode node = minHeap.poll();\\n            current.next = node;\\n            current = current.next;\\n\\n            if (node.next != null) {\\n                minHeap.add(node.next);\\n            }\\n        }\\n\\n        return dummy.next;\\n    }\\n\\n    public static void main(String[] args) {\\n        MergeKSortedLists merger = new MergeKSortedLists();\\n\\n        // Example 1\\n        ListNode[] lists1 = {\\n            new ListNode(1, new ListNode(4, new ListNode(5))),\\n            new ListNode(1, new ListNode(3, new ListNode(4))),\\n            new ListNode(2, new ListNode(6))\\n        };\\n        ListNode result1 = merger.mergeKLists(lists1);\\n        printList(result1); // Output: 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6\\n\\n        // Example 2\\n        ListNode[] lists2 = {};\\n        ListNode result2 = merger.mergeKLists(lists2);\\n        printList(result2); // Output: (empty list)\\n\\n        // Example 3\\n        ListNode[] lists3 = {null};\\n        ListNode result3 = merger.mergeKLists(lists3);\\n        printList(result3); // Output: (empty list)\\n    }\\n\\n    // Helper function to print the merged list\\n    private static void printList(ListNode head) {\\n        while (head != null) {\\n            System.out.print(head.val + \" -> \");\\n            head = head.next;\\n        }\\n        System.out.println(\"null\");\\n    }\\n}\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "Line 7: error: <identifier> expected [in MergeKSortedLists.java]\\n    ListNode[] {}\\n              ^"
                    },
                    {
                        "username": "RAIHANCHOWDURY",
                        "content": "do not this run"
                    },
                    {
                        "username": "marcus68",
                        "content": "Why does this throw an error\n`        nodes = [ (node.val, node) for node in lists]\n        heapq.heapify(nodes)`\nTypeError: '<' not supported between instances of 'ListNode' and 'ListNode'\n    heapq.heapify(nodes)\nLine 12 in mergeKLists (Solution.py)\n    ret = Solution().mergeKLists(param_1)\nLine 39 in _driver (Solution.py)\n    _driver()\nLine 50 in <module> (Solution.py)"
                    },
                    {
                        "username": "eminimus",
                        "content": "when two node values match, the second item in the tuple will be compared, and ListNode does not implement comparison\\n\\nyou can insert a dummy sequence number as the second item in the tuple, guaranteed to never be equal to another so the comparison will stop there\\n\\nor encapsulate the ListNode in another class, for example one that implements __lt__() returning self.node.val, or subclass int if you wanna get weird"
                    },
                    {
                        "username": "duckhai1",
                        "content": "In Java, the implementation of ListNode of the question is incorrect. Should use Integer type for val properties instead of int type, otherwise there will be no distinction between empty list [] and list with zero element [0]"
                    }
                ]
            },
            {
                "id": 2035383,
                "content": [
                    {
                        "username": "jlgarcia_",
                        "content": "The description of the problem is actually terrible, probably one of the worst I\\'ve found on this site.  \\nWorking on Python is hilarious when the hardest part of the problem is understanding the input style which causes a lot of unexpected errors while testing. \\n\\n`Input --> lists = [[], [1]]` is not actually a list which first element in [ ], but actually a `None` value. Is this even explained in the problem at all?"
                    },
                    {
                        "username": "borjaf696",
                        "content": "Solved in two different ways one with the ListNode idea and another one with the Naive idea of sorting a list with the values and then transform into the ListNode. \\nI assume is hard, but the second solution should be allowed... imho... if you do that this problem is not even easy"
                    },
                    {
                        "username": "petriciaa",
                        "content": "I\\'m new, please someone can explain to me. Does LeetCode not accept spread operator? Or is it something else?\\n `var mergeKLists = function(lists) {\\n    ans=[]\\n    for (let i = 0 ; i<lists.length;i++){\\n        ans=[...ans,...lists[i]]\\n    }\\n    return ans.sort()\\n};` "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "This problem should be Medium\\nBut it will be a bit harder with unsorted linked lists"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "I believe they could have been more clear in the example representation. Really confused,"
                    },
                    {
                        "username": "Ultron03",
                        "content": "This problem can only seems hard if you will see the tag first.."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "for the ones who are intimidated by the  `hard` tag, dont be. just the think the problem straight, the only tricky part here is to manipulate a Linked List in an array, if thats done, youre all set."
                    },
                    {
                        "username": "Marvooll",
                        "content": "In the input [[],[]] (testcase 21/133) I got the output [1,1,2,3,4,4,5,6].... how is that even possible HAHAHAHAHHAA"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "MinHeap C++,Priority_Queue.C++.Understand the concept.\\nUse the priority queue (MinHeap).\\nStep1: In that MinHeap store the first node of all K linked list.\\nEdge case: there might be some list empty. So before pushing the node in MinHeap check the node exist or not.\\nStep2: create a dummy node so that we can get the head of new sorted Linked list.\\nStep3: Iterate the MinHeap. So MinHeap give the minimum val node on top. pop that node from MinHeap and point temp->next which is used to traverse the new LinkedList to top of MinHeap Node.\\nStep4:Check if next of top of MinHeap exist or not. If exist the push that node to MinHeap.\\nStep5: return dummy next beacuse that is the head of new Sorted linked list.\\n\\nTime complexity: **T.C=O(klogk) because at any point of time there are at most k element in MinHeap.**\\nSpace complexity: **S.C=O(k)  because at any point of time there are at most k element in MinHeap.**\\n\\nPlease Upvote. If you Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3629851/minheap-c-priority-queue-c-understand-the-concept/"
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "Does anyone have any idea why my code is not working? The error is `TypeError: object of type \\'ListNode\\' has no len()` in the 3rd line (`if len(lists) == 1:`) but lists is an array, not ListNode, so why does it not have a len()? I am also unable to iterate lists.\\n\\nAny help would be greatly appreciated!\\n\\n```\\ndef mergeKLists(self, lists):\\n        if not lists:\\n            return []\\n        if len(lists) == 1: # this is the line with the error\\n            return lists[0]\\n        return self.mergeKLists(self.merge2Lists(lists[0], lists[1]))\\n    \\n    def merge2Lists(self, l1, l2):\\n        curr1, curr2 = l1, l2\\n        curr = head = ListNode(-1)\\n        while curr1 and curr2:\\n            if curr1.val < curr2.val:\\n                curr.next = curr1\\n                curr1 = curr1.next\\n            else:\\n                curr.next = curr2\\n                curr2 = curr2.next\\n            curr = curr.next\\n        if curr1: curr.next = curr1\\n        if curr2: curr.next = curr2\\n        return head.next\\n```"
                    },
                    {
                        "username": "atokeedokee",
                        "content": "I think it\\'s because you are doing a recursion at line 6 (for n >= 2)\\nThen it returns a listNode as an argument for the mergeKLists function\\nAnd a ListNode doesn\\'t have len() so error occurs"
                    }
                ]
            },
            {
                "id": 2034597,
                "content": [
                    {
                        "username": "jlgarcia_",
                        "content": "The description of the problem is actually terrible, probably one of the worst I\\'ve found on this site.  \\nWorking on Python is hilarious when the hardest part of the problem is understanding the input style which causes a lot of unexpected errors while testing. \\n\\n`Input --> lists = [[], [1]]` is not actually a list which first element in [ ], but actually a `None` value. Is this even explained in the problem at all?"
                    },
                    {
                        "username": "borjaf696",
                        "content": "Solved in two different ways one with the ListNode idea and another one with the Naive idea of sorting a list with the values and then transform into the ListNode. \\nI assume is hard, but the second solution should be allowed... imho... if you do that this problem is not even easy"
                    },
                    {
                        "username": "petriciaa",
                        "content": "I\\'m new, please someone can explain to me. Does LeetCode not accept spread operator? Or is it something else?\\n `var mergeKLists = function(lists) {\\n    ans=[]\\n    for (let i = 0 ; i<lists.length;i++){\\n        ans=[...ans,...lists[i]]\\n    }\\n    return ans.sort()\\n};` "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "This problem should be Medium\\nBut it will be a bit harder with unsorted linked lists"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "I believe they could have been more clear in the example representation. Really confused,"
                    },
                    {
                        "username": "Ultron03",
                        "content": "This problem can only seems hard if you will see the tag first.."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "for the ones who are intimidated by the  `hard` tag, dont be. just the think the problem straight, the only tricky part here is to manipulate a Linked List in an array, if thats done, youre all set."
                    },
                    {
                        "username": "Marvooll",
                        "content": "In the input [[],[]] (testcase 21/133) I got the output [1,1,2,3,4,4,5,6].... how is that even possible HAHAHAHAHHAA"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "MinHeap C++,Priority_Queue.C++.Understand the concept.\\nUse the priority queue (MinHeap).\\nStep1: In that MinHeap store the first node of all K linked list.\\nEdge case: there might be some list empty. So before pushing the node in MinHeap check the node exist or not.\\nStep2: create a dummy node so that we can get the head of new sorted Linked list.\\nStep3: Iterate the MinHeap. So MinHeap give the minimum val node on top. pop that node from MinHeap and point temp->next which is used to traverse the new LinkedList to top of MinHeap Node.\\nStep4:Check if next of top of MinHeap exist or not. If exist the push that node to MinHeap.\\nStep5: return dummy next beacuse that is the head of new Sorted linked list.\\n\\nTime complexity: **T.C=O(klogk) because at any point of time there are at most k element in MinHeap.**\\nSpace complexity: **S.C=O(k)  because at any point of time there are at most k element in MinHeap.**\\n\\nPlease Upvote. If you Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3629851/minheap-c-priority-queue-c-understand-the-concept/"
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "Does anyone have any idea why my code is not working? The error is `TypeError: object of type \\'ListNode\\' has no len()` in the 3rd line (`if len(lists) == 1:`) but lists is an array, not ListNode, so why does it not have a len()? I am also unable to iterate lists.\\n\\nAny help would be greatly appreciated!\\n\\n```\\ndef mergeKLists(self, lists):\\n        if not lists:\\n            return []\\n        if len(lists) == 1: # this is the line with the error\\n            return lists[0]\\n        return self.mergeKLists(self.merge2Lists(lists[0], lists[1]))\\n    \\n    def merge2Lists(self, l1, l2):\\n        curr1, curr2 = l1, l2\\n        curr = head = ListNode(-1)\\n        while curr1 and curr2:\\n            if curr1.val < curr2.val:\\n                curr.next = curr1\\n                curr1 = curr1.next\\n            else:\\n                curr.next = curr2\\n                curr2 = curr2.next\\n            curr = curr.next\\n        if curr1: curr.next = curr1\\n        if curr2: curr.next = curr2\\n        return head.next\\n```"
                    },
                    {
                        "username": "atokeedokee",
                        "content": "I think it\\'s because you are doing a recursion at line 6 (for n >= 2)\\nThen it returns a listNode as an argument for the mergeKLists function\\nAnd a ListNode doesn\\'t have len() so error occurs"
                    }
                ]
            },
            {
                "id": 2034313,
                "content": [
                    {
                        "username": "jlgarcia_",
                        "content": "The description of the problem is actually terrible, probably one of the worst I\\'ve found on this site.  \\nWorking on Python is hilarious when the hardest part of the problem is understanding the input style which causes a lot of unexpected errors while testing. \\n\\n`Input --> lists = [[], [1]]` is not actually a list which first element in [ ], but actually a `None` value. Is this even explained in the problem at all?"
                    },
                    {
                        "username": "borjaf696",
                        "content": "Solved in two different ways one with the ListNode idea and another one with the Naive idea of sorting a list with the values and then transform into the ListNode. \\nI assume is hard, but the second solution should be allowed... imho... if you do that this problem is not even easy"
                    },
                    {
                        "username": "petriciaa",
                        "content": "I\\'m new, please someone can explain to me. Does LeetCode not accept spread operator? Or is it something else?\\n `var mergeKLists = function(lists) {\\n    ans=[]\\n    for (let i = 0 ; i<lists.length;i++){\\n        ans=[...ans,...lists[i]]\\n    }\\n    return ans.sort()\\n};` "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "This problem should be Medium\\nBut it will be a bit harder with unsorted linked lists"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "I believe they could have been more clear in the example representation. Really confused,"
                    },
                    {
                        "username": "Ultron03",
                        "content": "This problem can only seems hard if you will see the tag first.."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "for the ones who are intimidated by the  `hard` tag, dont be. just the think the problem straight, the only tricky part here is to manipulate a Linked List in an array, if thats done, youre all set."
                    },
                    {
                        "username": "Marvooll",
                        "content": "In the input [[],[]] (testcase 21/133) I got the output [1,1,2,3,4,4,5,6].... how is that even possible HAHAHAHAHHAA"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "MinHeap C++,Priority_Queue.C++.Understand the concept.\\nUse the priority queue (MinHeap).\\nStep1: In that MinHeap store the first node of all K linked list.\\nEdge case: there might be some list empty. So before pushing the node in MinHeap check the node exist or not.\\nStep2: create a dummy node so that we can get the head of new sorted Linked list.\\nStep3: Iterate the MinHeap. So MinHeap give the minimum val node on top. pop that node from MinHeap and point temp->next which is used to traverse the new LinkedList to top of MinHeap Node.\\nStep4:Check if next of top of MinHeap exist or not. If exist the push that node to MinHeap.\\nStep5: return dummy next beacuse that is the head of new Sorted linked list.\\n\\nTime complexity: **T.C=O(klogk) because at any point of time there are at most k element in MinHeap.**\\nSpace complexity: **S.C=O(k)  because at any point of time there are at most k element in MinHeap.**\\n\\nPlease Upvote. If you Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3629851/minheap-c-priority-queue-c-understand-the-concept/"
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "Does anyone have any idea why my code is not working? The error is `TypeError: object of type \\'ListNode\\' has no len()` in the 3rd line (`if len(lists) == 1:`) but lists is an array, not ListNode, so why does it not have a len()? I am also unable to iterate lists.\\n\\nAny help would be greatly appreciated!\\n\\n```\\ndef mergeKLists(self, lists):\\n        if not lists:\\n            return []\\n        if len(lists) == 1: # this is the line with the error\\n            return lists[0]\\n        return self.mergeKLists(self.merge2Lists(lists[0], lists[1]))\\n    \\n    def merge2Lists(self, l1, l2):\\n        curr1, curr2 = l1, l2\\n        curr = head = ListNode(-1)\\n        while curr1 and curr2:\\n            if curr1.val < curr2.val:\\n                curr.next = curr1\\n                curr1 = curr1.next\\n            else:\\n                curr.next = curr2\\n                curr2 = curr2.next\\n            curr = curr.next\\n        if curr1: curr.next = curr1\\n        if curr2: curr.next = curr2\\n        return head.next\\n```"
                    },
                    {
                        "username": "atokeedokee",
                        "content": "I think it\\'s because you are doing a recursion at line 6 (for n >= 2)\\nThen it returns a listNode as an argument for the mergeKLists function\\nAnd a ListNode doesn\\'t have len() so error occurs"
                    }
                ]
            },
            {
                "id": 2029023,
                "content": [
                    {
                        "username": "jlgarcia_",
                        "content": "The description of the problem is actually terrible, probably one of the worst I\\'ve found on this site.  \\nWorking on Python is hilarious when the hardest part of the problem is understanding the input style which causes a lot of unexpected errors while testing. \\n\\n`Input --> lists = [[], [1]]` is not actually a list which first element in [ ], but actually a `None` value. Is this even explained in the problem at all?"
                    },
                    {
                        "username": "borjaf696",
                        "content": "Solved in two different ways one with the ListNode idea and another one with the Naive idea of sorting a list with the values and then transform into the ListNode. \\nI assume is hard, but the second solution should be allowed... imho... if you do that this problem is not even easy"
                    },
                    {
                        "username": "petriciaa",
                        "content": "I\\'m new, please someone can explain to me. Does LeetCode not accept spread operator? Or is it something else?\\n `var mergeKLists = function(lists) {\\n    ans=[]\\n    for (let i = 0 ; i<lists.length;i++){\\n        ans=[...ans,...lists[i]]\\n    }\\n    return ans.sort()\\n};` "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "This problem should be Medium\\nBut it will be a bit harder with unsorted linked lists"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "I believe they could have been more clear in the example representation. Really confused,"
                    },
                    {
                        "username": "Ultron03",
                        "content": "This problem can only seems hard if you will see the tag first.."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "for the ones who are intimidated by the  `hard` tag, dont be. just the think the problem straight, the only tricky part here is to manipulate a Linked List in an array, if thats done, youre all set."
                    },
                    {
                        "username": "Marvooll",
                        "content": "In the input [[],[]] (testcase 21/133) I got the output [1,1,2,3,4,4,5,6].... how is that even possible HAHAHAHAHHAA"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "MinHeap C++,Priority_Queue.C++.Understand the concept.\\nUse the priority queue (MinHeap).\\nStep1: In that MinHeap store the first node of all K linked list.\\nEdge case: there might be some list empty. So before pushing the node in MinHeap check the node exist or not.\\nStep2: create a dummy node so that we can get the head of new sorted Linked list.\\nStep3: Iterate the MinHeap. So MinHeap give the minimum val node on top. pop that node from MinHeap and point temp->next which is used to traverse the new LinkedList to top of MinHeap Node.\\nStep4:Check if next of top of MinHeap exist or not. If exist the push that node to MinHeap.\\nStep5: return dummy next beacuse that is the head of new Sorted linked list.\\n\\nTime complexity: **T.C=O(klogk) because at any point of time there are at most k element in MinHeap.**\\nSpace complexity: **S.C=O(k)  because at any point of time there are at most k element in MinHeap.**\\n\\nPlease Upvote. If you Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3629851/minheap-c-priority-queue-c-understand-the-concept/"
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "Does anyone have any idea why my code is not working? The error is `TypeError: object of type \\'ListNode\\' has no len()` in the 3rd line (`if len(lists) == 1:`) but lists is an array, not ListNode, so why does it not have a len()? I am also unable to iterate lists.\\n\\nAny help would be greatly appreciated!\\n\\n```\\ndef mergeKLists(self, lists):\\n        if not lists:\\n            return []\\n        if len(lists) == 1: # this is the line with the error\\n            return lists[0]\\n        return self.mergeKLists(self.merge2Lists(lists[0], lists[1]))\\n    \\n    def merge2Lists(self, l1, l2):\\n        curr1, curr2 = l1, l2\\n        curr = head = ListNode(-1)\\n        while curr1 and curr2:\\n            if curr1.val < curr2.val:\\n                curr.next = curr1\\n                curr1 = curr1.next\\n            else:\\n                curr.next = curr2\\n                curr2 = curr2.next\\n            curr = curr.next\\n        if curr1: curr.next = curr1\\n        if curr2: curr.next = curr2\\n        return head.next\\n```"
                    },
                    {
                        "username": "atokeedokee",
                        "content": "I think it\\'s because you are doing a recursion at line 6 (for n >= 2)\\nThen it returns a listNode as an argument for the mergeKLists function\\nAnd a ListNode doesn\\'t have len() so error occurs"
                    }
                ]
            },
            {
                "id": 1980146,
                "content": [
                    {
                        "username": "jlgarcia_",
                        "content": "The description of the problem is actually terrible, probably one of the worst I\\'ve found on this site.  \\nWorking on Python is hilarious when the hardest part of the problem is understanding the input style which causes a lot of unexpected errors while testing. \\n\\n`Input --> lists = [[], [1]]` is not actually a list which first element in [ ], but actually a `None` value. Is this even explained in the problem at all?"
                    },
                    {
                        "username": "borjaf696",
                        "content": "Solved in two different ways one with the ListNode idea and another one with the Naive idea of sorting a list with the values and then transform into the ListNode. \\nI assume is hard, but the second solution should be allowed... imho... if you do that this problem is not even easy"
                    },
                    {
                        "username": "petriciaa",
                        "content": "I\\'m new, please someone can explain to me. Does LeetCode not accept spread operator? Or is it something else?\\n `var mergeKLists = function(lists) {\\n    ans=[]\\n    for (let i = 0 ; i<lists.length;i++){\\n        ans=[...ans,...lists[i]]\\n    }\\n    return ans.sort()\\n};` "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "This problem should be Medium\\nBut it will be a bit harder with unsorted linked lists"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "I believe they could have been more clear in the example representation. Really confused,"
                    },
                    {
                        "username": "Ultron03",
                        "content": "This problem can only seems hard if you will see the tag first.."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "for the ones who are intimidated by the  `hard` tag, dont be. just the think the problem straight, the only tricky part here is to manipulate a Linked List in an array, if thats done, youre all set."
                    },
                    {
                        "username": "Marvooll",
                        "content": "In the input [[],[]] (testcase 21/133) I got the output [1,1,2,3,4,4,5,6].... how is that even possible HAHAHAHAHHAA"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "MinHeap C++,Priority_Queue.C++.Understand the concept.\\nUse the priority queue (MinHeap).\\nStep1: In that MinHeap store the first node of all K linked list.\\nEdge case: there might be some list empty. So before pushing the node in MinHeap check the node exist or not.\\nStep2: create a dummy node so that we can get the head of new sorted Linked list.\\nStep3: Iterate the MinHeap. So MinHeap give the minimum val node on top. pop that node from MinHeap and point temp->next which is used to traverse the new LinkedList to top of MinHeap Node.\\nStep4:Check if next of top of MinHeap exist or not. If exist the push that node to MinHeap.\\nStep5: return dummy next beacuse that is the head of new Sorted linked list.\\n\\nTime complexity: **T.C=O(klogk) because at any point of time there are at most k element in MinHeap.**\\nSpace complexity: **S.C=O(k)  because at any point of time there are at most k element in MinHeap.**\\n\\nPlease Upvote. If you Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3629851/minheap-c-priority-queue-c-understand-the-concept/"
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "Does anyone have any idea why my code is not working? The error is `TypeError: object of type \\'ListNode\\' has no len()` in the 3rd line (`if len(lists) == 1:`) but lists is an array, not ListNode, so why does it not have a len()? I am also unable to iterate lists.\\n\\nAny help would be greatly appreciated!\\n\\n```\\ndef mergeKLists(self, lists):\\n        if not lists:\\n            return []\\n        if len(lists) == 1: # this is the line with the error\\n            return lists[0]\\n        return self.mergeKLists(self.merge2Lists(lists[0], lists[1]))\\n    \\n    def merge2Lists(self, l1, l2):\\n        curr1, curr2 = l1, l2\\n        curr = head = ListNode(-1)\\n        while curr1 and curr2:\\n            if curr1.val < curr2.val:\\n                curr.next = curr1\\n                curr1 = curr1.next\\n            else:\\n                curr.next = curr2\\n                curr2 = curr2.next\\n            curr = curr.next\\n        if curr1: curr.next = curr1\\n        if curr2: curr.next = curr2\\n        return head.next\\n```"
                    },
                    {
                        "username": "atokeedokee",
                        "content": "I think it\\'s because you are doing a recursion at line 6 (for n >= 2)\\nThen it returns a listNode as an argument for the mergeKLists function\\nAnd a ListNode doesn\\'t have len() so error occurs"
                    }
                ]
            },
            {
                "id": 1977923,
                "content": [
                    {
                        "username": "jlgarcia_",
                        "content": "The description of the problem is actually terrible, probably one of the worst I\\'ve found on this site.  \\nWorking on Python is hilarious when the hardest part of the problem is understanding the input style which causes a lot of unexpected errors while testing. \\n\\n`Input --> lists = [[], [1]]` is not actually a list which first element in [ ], but actually a `None` value. Is this even explained in the problem at all?"
                    },
                    {
                        "username": "borjaf696",
                        "content": "Solved in two different ways one with the ListNode idea and another one with the Naive idea of sorting a list with the values and then transform into the ListNode. \\nI assume is hard, but the second solution should be allowed... imho... if you do that this problem is not even easy"
                    },
                    {
                        "username": "petriciaa",
                        "content": "I\\'m new, please someone can explain to me. Does LeetCode not accept spread operator? Or is it something else?\\n `var mergeKLists = function(lists) {\\n    ans=[]\\n    for (let i = 0 ; i<lists.length;i++){\\n        ans=[...ans,...lists[i]]\\n    }\\n    return ans.sort()\\n};` "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "This problem should be Medium\\nBut it will be a bit harder with unsorted linked lists"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "I believe they could have been more clear in the example representation. Really confused,"
                    },
                    {
                        "username": "Ultron03",
                        "content": "This problem can only seems hard if you will see the tag first.."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "for the ones who are intimidated by the  `hard` tag, dont be. just the think the problem straight, the only tricky part here is to manipulate a Linked List in an array, if thats done, youre all set."
                    },
                    {
                        "username": "Marvooll",
                        "content": "In the input [[],[]] (testcase 21/133) I got the output [1,1,2,3,4,4,5,6].... how is that even possible HAHAHAHAHHAA"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "MinHeap C++,Priority_Queue.C++.Understand the concept.\\nUse the priority queue (MinHeap).\\nStep1: In that MinHeap store the first node of all K linked list.\\nEdge case: there might be some list empty. So before pushing the node in MinHeap check the node exist or not.\\nStep2: create a dummy node so that we can get the head of new sorted Linked list.\\nStep3: Iterate the MinHeap. So MinHeap give the minimum val node on top. pop that node from MinHeap and point temp->next which is used to traverse the new LinkedList to top of MinHeap Node.\\nStep4:Check if next of top of MinHeap exist or not. If exist the push that node to MinHeap.\\nStep5: return dummy next beacuse that is the head of new Sorted linked list.\\n\\nTime complexity: **T.C=O(klogk) because at any point of time there are at most k element in MinHeap.**\\nSpace complexity: **S.C=O(k)  because at any point of time there are at most k element in MinHeap.**\\n\\nPlease Upvote. If you Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3629851/minheap-c-priority-queue-c-understand-the-concept/"
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "Does anyone have any idea why my code is not working? The error is `TypeError: object of type \\'ListNode\\' has no len()` in the 3rd line (`if len(lists) == 1:`) but lists is an array, not ListNode, so why does it not have a len()? I am also unable to iterate lists.\\n\\nAny help would be greatly appreciated!\\n\\n```\\ndef mergeKLists(self, lists):\\n        if not lists:\\n            return []\\n        if len(lists) == 1: # this is the line with the error\\n            return lists[0]\\n        return self.mergeKLists(self.merge2Lists(lists[0], lists[1]))\\n    \\n    def merge2Lists(self, l1, l2):\\n        curr1, curr2 = l1, l2\\n        curr = head = ListNode(-1)\\n        while curr1 and curr2:\\n            if curr1.val < curr2.val:\\n                curr.next = curr1\\n                curr1 = curr1.next\\n            else:\\n                curr.next = curr2\\n                curr2 = curr2.next\\n            curr = curr.next\\n        if curr1: curr.next = curr1\\n        if curr2: curr.next = curr2\\n        return head.next\\n```"
                    },
                    {
                        "username": "atokeedokee",
                        "content": "I think it\\'s because you are doing a recursion at line 6 (for n >= 2)\\nThen it returns a listNode as an argument for the mergeKLists function\\nAnd a ListNode doesn\\'t have len() so error occurs"
                    }
                ]
            },
            {
                "id": 1975251,
                "content": [
                    {
                        "username": "jlgarcia_",
                        "content": "The description of the problem is actually terrible, probably one of the worst I\\'ve found on this site.  \\nWorking on Python is hilarious when the hardest part of the problem is understanding the input style which causes a lot of unexpected errors while testing. \\n\\n`Input --> lists = [[], [1]]` is not actually a list which first element in [ ], but actually a `None` value. Is this even explained in the problem at all?"
                    },
                    {
                        "username": "borjaf696",
                        "content": "Solved in two different ways one with the ListNode idea and another one with the Naive idea of sorting a list with the values and then transform into the ListNode. \\nI assume is hard, but the second solution should be allowed... imho... if you do that this problem is not even easy"
                    },
                    {
                        "username": "petriciaa",
                        "content": "I\\'m new, please someone can explain to me. Does LeetCode not accept spread operator? Or is it something else?\\n `var mergeKLists = function(lists) {\\n    ans=[]\\n    for (let i = 0 ; i<lists.length;i++){\\n        ans=[...ans,...lists[i]]\\n    }\\n    return ans.sort()\\n};` "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "This problem should be Medium\\nBut it will be a bit harder with unsorted linked lists"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "I believe they could have been more clear in the example representation. Really confused,"
                    },
                    {
                        "username": "Ultron03",
                        "content": "This problem can only seems hard if you will see the tag first.."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "for the ones who are intimidated by the  `hard` tag, dont be. just the think the problem straight, the only tricky part here is to manipulate a Linked List in an array, if thats done, youre all set."
                    },
                    {
                        "username": "Marvooll",
                        "content": "In the input [[],[]] (testcase 21/133) I got the output [1,1,2,3,4,4,5,6].... how is that even possible HAHAHAHAHHAA"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "MinHeap C++,Priority_Queue.C++.Understand the concept.\\nUse the priority queue (MinHeap).\\nStep1: In that MinHeap store the first node of all K linked list.\\nEdge case: there might be some list empty. So before pushing the node in MinHeap check the node exist or not.\\nStep2: create a dummy node so that we can get the head of new sorted Linked list.\\nStep3: Iterate the MinHeap. So MinHeap give the minimum val node on top. pop that node from MinHeap and point temp->next which is used to traverse the new LinkedList to top of MinHeap Node.\\nStep4:Check if next of top of MinHeap exist or not. If exist the push that node to MinHeap.\\nStep5: return dummy next beacuse that is the head of new Sorted linked list.\\n\\nTime complexity: **T.C=O(klogk) because at any point of time there are at most k element in MinHeap.**\\nSpace complexity: **S.C=O(k)  because at any point of time there are at most k element in MinHeap.**\\n\\nPlease Upvote. If you Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3629851/minheap-c-priority-queue-c-understand-the-concept/"
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "Does anyone have any idea why my code is not working? The error is `TypeError: object of type \\'ListNode\\' has no len()` in the 3rd line (`if len(lists) == 1:`) but lists is an array, not ListNode, so why does it not have a len()? I am also unable to iterate lists.\\n\\nAny help would be greatly appreciated!\\n\\n```\\ndef mergeKLists(self, lists):\\n        if not lists:\\n            return []\\n        if len(lists) == 1: # this is the line with the error\\n            return lists[0]\\n        return self.mergeKLists(self.merge2Lists(lists[0], lists[1]))\\n    \\n    def merge2Lists(self, l1, l2):\\n        curr1, curr2 = l1, l2\\n        curr = head = ListNode(-1)\\n        while curr1 and curr2:\\n            if curr1.val < curr2.val:\\n                curr.next = curr1\\n                curr1 = curr1.next\\n            else:\\n                curr.next = curr2\\n                curr2 = curr2.next\\n            curr = curr.next\\n        if curr1: curr.next = curr1\\n        if curr2: curr.next = curr2\\n        return head.next\\n```"
                    },
                    {
                        "username": "atokeedokee",
                        "content": "I think it\\'s because you are doing a recursion at line 6 (for n >= 2)\\nThen it returns a listNode as an argument for the mergeKLists function\\nAnd a ListNode doesn\\'t have len() so error occurs"
                    }
                ]
            },
            {
                "id": 1940425,
                "content": [
                    {
                        "username": "jlgarcia_",
                        "content": "The description of the problem is actually terrible, probably one of the worst I\\'ve found on this site.  \\nWorking on Python is hilarious when the hardest part of the problem is understanding the input style which causes a lot of unexpected errors while testing. \\n\\n`Input --> lists = [[], [1]]` is not actually a list which first element in [ ], but actually a `None` value. Is this even explained in the problem at all?"
                    },
                    {
                        "username": "borjaf696",
                        "content": "Solved in two different ways one with the ListNode idea and another one with the Naive idea of sorting a list with the values and then transform into the ListNode. \\nI assume is hard, but the second solution should be allowed... imho... if you do that this problem is not even easy"
                    },
                    {
                        "username": "petriciaa",
                        "content": "I\\'m new, please someone can explain to me. Does LeetCode not accept spread operator? Or is it something else?\\n `var mergeKLists = function(lists) {\\n    ans=[]\\n    for (let i = 0 ; i<lists.length;i++){\\n        ans=[...ans,...lists[i]]\\n    }\\n    return ans.sort()\\n};` "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "This problem should be Medium\\nBut it will be a bit harder with unsorted linked lists"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "I believe they could have been more clear in the example representation. Really confused,"
                    },
                    {
                        "username": "Ultron03",
                        "content": "This problem can only seems hard if you will see the tag first.."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "for the ones who are intimidated by the  `hard` tag, dont be. just the think the problem straight, the only tricky part here is to manipulate a Linked List in an array, if thats done, youre all set."
                    },
                    {
                        "username": "Marvooll",
                        "content": "In the input [[],[]] (testcase 21/133) I got the output [1,1,2,3,4,4,5,6].... how is that even possible HAHAHAHAHHAA"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "MinHeap C++,Priority_Queue.C++.Understand the concept.\\nUse the priority queue (MinHeap).\\nStep1: In that MinHeap store the first node of all K linked list.\\nEdge case: there might be some list empty. So before pushing the node in MinHeap check the node exist or not.\\nStep2: create a dummy node so that we can get the head of new sorted Linked list.\\nStep3: Iterate the MinHeap. So MinHeap give the minimum val node on top. pop that node from MinHeap and point temp->next which is used to traverse the new LinkedList to top of MinHeap Node.\\nStep4:Check if next of top of MinHeap exist or not. If exist the push that node to MinHeap.\\nStep5: return dummy next beacuse that is the head of new Sorted linked list.\\n\\nTime complexity: **T.C=O(klogk) because at any point of time there are at most k element in MinHeap.**\\nSpace complexity: **S.C=O(k)  because at any point of time there are at most k element in MinHeap.**\\n\\nPlease Upvote. If you Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3629851/minheap-c-priority-queue-c-understand-the-concept/"
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "Does anyone have any idea why my code is not working? The error is `TypeError: object of type \\'ListNode\\' has no len()` in the 3rd line (`if len(lists) == 1:`) but lists is an array, not ListNode, so why does it not have a len()? I am also unable to iterate lists.\\n\\nAny help would be greatly appreciated!\\n\\n```\\ndef mergeKLists(self, lists):\\n        if not lists:\\n            return []\\n        if len(lists) == 1: # this is the line with the error\\n            return lists[0]\\n        return self.mergeKLists(self.merge2Lists(lists[0], lists[1]))\\n    \\n    def merge2Lists(self, l1, l2):\\n        curr1, curr2 = l1, l2\\n        curr = head = ListNode(-1)\\n        while curr1 and curr2:\\n            if curr1.val < curr2.val:\\n                curr.next = curr1\\n                curr1 = curr1.next\\n            else:\\n                curr.next = curr2\\n                curr2 = curr2.next\\n            curr = curr.next\\n        if curr1: curr.next = curr1\\n        if curr2: curr.next = curr2\\n        return head.next\\n```"
                    },
                    {
                        "username": "atokeedokee",
                        "content": "I think it\\'s because you are doing a recursion at line 6 (for n >= 2)\\nThen it returns a listNode as an argument for the mergeKLists function\\nAnd a ListNode doesn\\'t have len() so error occurs"
                    }
                ]
            },
            {
                "id": 1926865,
                "content": [
                    {
                        "username": "jlgarcia_",
                        "content": "The description of the problem is actually terrible, probably one of the worst I\\'ve found on this site.  \\nWorking on Python is hilarious when the hardest part of the problem is understanding the input style which causes a lot of unexpected errors while testing. \\n\\n`Input --> lists = [[], [1]]` is not actually a list which first element in [ ], but actually a `None` value. Is this even explained in the problem at all?"
                    },
                    {
                        "username": "borjaf696",
                        "content": "Solved in two different ways one with the ListNode idea and another one with the Naive idea of sorting a list with the values and then transform into the ListNode. \\nI assume is hard, but the second solution should be allowed... imho... if you do that this problem is not even easy"
                    },
                    {
                        "username": "petriciaa",
                        "content": "I\\'m new, please someone can explain to me. Does LeetCode not accept spread operator? Or is it something else?\\n `var mergeKLists = function(lists) {\\n    ans=[]\\n    for (let i = 0 ; i<lists.length;i++){\\n        ans=[...ans,...lists[i]]\\n    }\\n    return ans.sort()\\n};` "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "This problem should be Medium\\nBut it will be a bit harder with unsorted linked lists"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "I believe they could have been more clear in the example representation. Really confused,"
                    },
                    {
                        "username": "Ultron03",
                        "content": "This problem can only seems hard if you will see the tag first.."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "for the ones who are intimidated by the  `hard` tag, dont be. just the think the problem straight, the only tricky part here is to manipulate a Linked List in an array, if thats done, youre all set."
                    },
                    {
                        "username": "Marvooll",
                        "content": "In the input [[],[]] (testcase 21/133) I got the output [1,1,2,3,4,4,5,6].... how is that even possible HAHAHAHAHHAA"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "MinHeap C++,Priority_Queue.C++.Understand the concept.\\nUse the priority queue (MinHeap).\\nStep1: In that MinHeap store the first node of all K linked list.\\nEdge case: there might be some list empty. So before pushing the node in MinHeap check the node exist or not.\\nStep2: create a dummy node so that we can get the head of new sorted Linked list.\\nStep3: Iterate the MinHeap. So MinHeap give the minimum val node on top. pop that node from MinHeap and point temp->next which is used to traverse the new LinkedList to top of MinHeap Node.\\nStep4:Check if next of top of MinHeap exist or not. If exist the push that node to MinHeap.\\nStep5: return dummy next beacuse that is the head of new Sorted linked list.\\n\\nTime complexity: **T.C=O(klogk) because at any point of time there are at most k element in MinHeap.**\\nSpace complexity: **S.C=O(k)  because at any point of time there are at most k element in MinHeap.**\\n\\nPlease Upvote. If you Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3629851/minheap-c-priority-queue-c-understand-the-concept/"
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "Does anyone have any idea why my code is not working? The error is `TypeError: object of type \\'ListNode\\' has no len()` in the 3rd line (`if len(lists) == 1:`) but lists is an array, not ListNode, so why does it not have a len()? I am also unable to iterate lists.\\n\\nAny help would be greatly appreciated!\\n\\n```\\ndef mergeKLists(self, lists):\\n        if not lists:\\n            return []\\n        if len(lists) == 1: # this is the line with the error\\n            return lists[0]\\n        return self.mergeKLists(self.merge2Lists(lists[0], lists[1]))\\n    \\n    def merge2Lists(self, l1, l2):\\n        curr1, curr2 = l1, l2\\n        curr = head = ListNode(-1)\\n        while curr1 and curr2:\\n            if curr1.val < curr2.val:\\n                curr.next = curr1\\n                curr1 = curr1.next\\n            else:\\n                curr.next = curr2\\n                curr2 = curr2.next\\n            curr = curr.next\\n        if curr1: curr.next = curr1\\n        if curr2: curr.next = curr2\\n        return head.next\\n```"
                    },
                    {
                        "username": "atokeedokee",
                        "content": "I think it\\'s because you are doing a recursion at line 6 (for n >= 2)\\nThen it returns a listNode as an argument for the mergeKLists function\\nAnd a ListNode doesn\\'t have len() so error occurs"
                    }
                ]
            },
            {
                "id": 1925244,
                "content": [
                    {
                        "username": "jlgarcia_",
                        "content": "The description of the problem is actually terrible, probably one of the worst I\\'ve found on this site.  \\nWorking on Python is hilarious when the hardest part of the problem is understanding the input style which causes a lot of unexpected errors while testing. \\n\\n`Input --> lists = [[], [1]]` is not actually a list which first element in [ ], but actually a `None` value. Is this even explained in the problem at all?"
                    },
                    {
                        "username": "borjaf696",
                        "content": "Solved in two different ways one with the ListNode idea and another one with the Naive idea of sorting a list with the values and then transform into the ListNode. \\nI assume is hard, but the second solution should be allowed... imho... if you do that this problem is not even easy"
                    },
                    {
                        "username": "petriciaa",
                        "content": "I\\'m new, please someone can explain to me. Does LeetCode not accept spread operator? Or is it something else?\\n `var mergeKLists = function(lists) {\\n    ans=[]\\n    for (let i = 0 ; i<lists.length;i++){\\n        ans=[...ans,...lists[i]]\\n    }\\n    return ans.sort()\\n};` "
                    },
                    {
                        "username": "nhienlh94",
                        "content": "This problem should be Medium\\nBut it will be a bit harder with unsorted linked lists"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "I believe they could have been more clear in the example representation. Really confused,"
                    },
                    {
                        "username": "Ultron03",
                        "content": "This problem can only seems hard if you will see the tag first.."
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "for the ones who are intimidated by the  `hard` tag, dont be. just the think the problem straight, the only tricky part here is to manipulate a Linked List in an array, if thats done, youre all set."
                    },
                    {
                        "username": "Marvooll",
                        "content": "In the input [[],[]] (testcase 21/133) I got the output [1,1,2,3,4,4,5,6].... how is that even possible HAHAHAHAHHAA"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "MinHeap C++,Priority_Queue.C++.Understand the concept.\\nUse the priority queue (MinHeap).\\nStep1: In that MinHeap store the first node of all K linked list.\\nEdge case: there might be some list empty. So before pushing the node in MinHeap check the node exist or not.\\nStep2: create a dummy node so that we can get the head of new sorted Linked list.\\nStep3: Iterate the MinHeap. So MinHeap give the minimum val node on top. pop that node from MinHeap and point temp->next which is used to traverse the new LinkedList to top of MinHeap Node.\\nStep4:Check if next of top of MinHeap exist or not. If exist the push that node to MinHeap.\\nStep5: return dummy next beacuse that is the head of new Sorted linked list.\\n\\nTime complexity: **T.C=O(klogk) because at any point of time there are at most k element in MinHeap.**\\nSpace complexity: **S.C=O(k)  because at any point of time there are at most k element in MinHeap.**\\n\\nPlease Upvote. If you Understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3629851/minheap-c-priority-queue-c-understand-the-concept/"
                    },
                    {
                        "username": "SlaveToJavascript",
                        "content": "Does anyone have any idea why my code is not working? The error is `TypeError: object of type \\'ListNode\\' has no len()` in the 3rd line (`if len(lists) == 1:`) but lists is an array, not ListNode, so why does it not have a len()? I am also unable to iterate lists.\\n\\nAny help would be greatly appreciated!\\n\\n```\\ndef mergeKLists(self, lists):\\n        if not lists:\\n            return []\\n        if len(lists) == 1: # this is the line with the error\\n            return lists[0]\\n        return self.mergeKLists(self.merge2Lists(lists[0], lists[1]))\\n    \\n    def merge2Lists(self, l1, l2):\\n        curr1, curr2 = l1, l2\\n        curr = head = ListNode(-1)\\n        while curr1 and curr2:\\n            if curr1.val < curr2.val:\\n                curr.next = curr1\\n                curr1 = curr1.next\\n            else:\\n                curr.next = curr2\\n                curr2 = curr2.next\\n            curr = curr.next\\n        if curr1: curr.next = curr1\\n        if curr2: curr.next = curr2\\n        return head.next\\n```"
                    },
                    {
                        "username": "atokeedokee",
                        "content": "I think it\\'s because you are doing a recursion at line 6 (for n >= 2)\\nThen it returns a listNode as an argument for the mergeKLists function\\nAnd a ListNode doesn\\'t have len() so error occurs"
                    }
                ]
            },
            {
                "id": 1900878,
                "content": [
                    {
                        "username": "Aditya560",
                        "content": "Just Use priority Queue to store val and then replace list[0] at end of NULL with list[1] head  continue till all the list are linked. And store value from queue one by one"
                    },
                    {
                        "username": "sanjitj7",
                        "content": "Does ascending order here means monotonously increasing (i.e. list has same values repeating) or strictly increasing? I think it will affect the solution."
                    },
                    {
                        "username": "Husoski",
                        "content": "Did you mean \"monotonically\"? :^)  Anyway, the constraint says \"sorted in ascending order\" and that doesn\\'t prohibit duplicate values in a single list.  Examples show that the final list can contain duplicate values, and there\\'s no requirement for what order those nodes appear in the result, so the relative ordering of equal values can\\'t matter."
                    },
                    {
                        "username": "dmitrii_bokovikov",
                        "content": "It\\'s a middle problem, needs to be downgraded"
                    },
                    {
                        "username": "gopaldk",
                        "content": "Is anybody getting following exception when tried using Priority Queue?\\njava.lang.ClassCastException: class ListNode cannot be cast to class java.lang.Comparable (ListNode is in unnamed module of loader \\'app\\'; java.lang.Comparable is in module java.base of loader \\'bootstrap\\')\\n  at line 643, java.base/java.util.PriorityQueue.siftUpComparable\\n  at line 639, java.base/java.util.PriorityQueue.siftUp\\n  at line 330, java.base/java.util.PriorityQueue.offer\\n  at line 16, Solution.mergeKLists\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main"
                    },
                    {
                        "username": "Husoski",
                        "content": "That will happen if you don\\'t provide a comparator to the PriorityQueue constructor.  The provided ListNode class does not implement Comparable<ListNode>.  I sidestepped this in my Java solution by making my own QueueEntry class to wrap the list \"head pointer\" references, but using a lambda to specify the comparator, something like:\\n`new PriorityQueue<ListNode>((a, b) -> Integer.compare(a.val, b.val))`.  "
                    },
                    {
                        "username": "TanHess",
                        "content": "I believe there is an issue with the solution class (or something similar) in LeetCode. I am trying to enumerate through the lists variable while it is not empty. As I finish iterating through each of the sublists, I remove them from the lists variable no problem. The issue is once I remove the last one, the lists variable correctly shows as empty before my \"while lists:\" loop begins, but then my \"while lists:\" loop fires again and shows a \"None\" value within the lists variable. Is this a known issue within LeetCode?"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Please help me to understand the time complexity here?\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3391586/what-is-the-time-complexity-here-python/\\n\\nthis solution is taking 1200+ms, i\\'m not getting why this much when \\n"
                    },
                    {
                        "username": "nd4312",
                        "content": "All the official solutions extract the values out of the the lists and then creates a new listnode with the values rather than using the existing ListNode. How is that technically not incorrect?? Merging implies use of existing nodes, not creating new nodes..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "I have a helper function `merge` that performs merge sort.\\n\\nWhy do I get a Time Limit Exceeded when I use `reduce`:\\n\\n```python\\ndef mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        return reduce(self.merge, lists, None)\\n```\\n\\nbut not when I use recursion:\\n\\n```python\\ndef mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        if len(lists) == 0: return None\\n        if len(lists) == 1: return lists[0]\\n\\n        mid = len(lists) // 2\\n\\n        # Recursivel merge the lists\\n        return self.merge(self.mergeKLists(lists[:mid]), self.mergeKLists(lists[mid:]))\\n```\\n"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "easily explained in 10 minutes with dry run, just try and you will love it https://youtu.be/jT7-J3KJbWo"
                    }
                ]
            },
            {
                "id": 1875481,
                "content": [
                    {
                        "username": "Aditya560",
                        "content": "Just Use priority Queue to store val and then replace list[0] at end of NULL with list[1] head  continue till all the list are linked. And store value from queue one by one"
                    },
                    {
                        "username": "sanjitj7",
                        "content": "Does ascending order here means monotonously increasing (i.e. list has same values repeating) or strictly increasing? I think it will affect the solution."
                    },
                    {
                        "username": "Husoski",
                        "content": "Did you mean \"monotonically\"? :^)  Anyway, the constraint says \"sorted in ascending order\" and that doesn\\'t prohibit duplicate values in a single list.  Examples show that the final list can contain duplicate values, and there\\'s no requirement for what order those nodes appear in the result, so the relative ordering of equal values can\\'t matter."
                    },
                    {
                        "username": "dmitrii_bokovikov",
                        "content": "It\\'s a middle problem, needs to be downgraded"
                    },
                    {
                        "username": "gopaldk",
                        "content": "Is anybody getting following exception when tried using Priority Queue?\\njava.lang.ClassCastException: class ListNode cannot be cast to class java.lang.Comparable (ListNode is in unnamed module of loader \\'app\\'; java.lang.Comparable is in module java.base of loader \\'bootstrap\\')\\n  at line 643, java.base/java.util.PriorityQueue.siftUpComparable\\n  at line 639, java.base/java.util.PriorityQueue.siftUp\\n  at line 330, java.base/java.util.PriorityQueue.offer\\n  at line 16, Solution.mergeKLists\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main"
                    },
                    {
                        "username": "Husoski",
                        "content": "That will happen if you don\\'t provide a comparator to the PriorityQueue constructor.  The provided ListNode class does not implement Comparable<ListNode>.  I sidestepped this in my Java solution by making my own QueueEntry class to wrap the list \"head pointer\" references, but using a lambda to specify the comparator, something like:\\n`new PriorityQueue<ListNode>((a, b) -> Integer.compare(a.val, b.val))`.  "
                    },
                    {
                        "username": "TanHess",
                        "content": "I believe there is an issue with the solution class (or something similar) in LeetCode. I am trying to enumerate through the lists variable while it is not empty. As I finish iterating through each of the sublists, I remove them from the lists variable no problem. The issue is once I remove the last one, the lists variable correctly shows as empty before my \"while lists:\" loop begins, but then my \"while lists:\" loop fires again and shows a \"None\" value within the lists variable. Is this a known issue within LeetCode?"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Please help me to understand the time complexity here?\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3391586/what-is-the-time-complexity-here-python/\\n\\nthis solution is taking 1200+ms, i\\'m not getting why this much when \\n"
                    },
                    {
                        "username": "nd4312",
                        "content": "All the official solutions extract the values out of the the lists and then creates a new listnode with the values rather than using the existing ListNode. How is that technically not incorrect?? Merging implies use of existing nodes, not creating new nodes..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "I have a helper function `merge` that performs merge sort.\\n\\nWhy do I get a Time Limit Exceeded when I use `reduce`:\\n\\n```python\\ndef mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        return reduce(self.merge, lists, None)\\n```\\n\\nbut not when I use recursion:\\n\\n```python\\ndef mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        if len(lists) == 0: return None\\n        if len(lists) == 1: return lists[0]\\n\\n        mid = len(lists) // 2\\n\\n        # Recursivel merge the lists\\n        return self.merge(self.mergeKLists(lists[:mid]), self.mergeKLists(lists[mid:]))\\n```\\n"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "easily explained in 10 minutes with dry run, just try and you will love it https://youtu.be/jT7-J3KJbWo"
                    }
                ]
            },
            {
                "id": 1874661,
                "content": [
                    {
                        "username": "Aditya560",
                        "content": "Just Use priority Queue to store val and then replace list[0] at end of NULL with list[1] head  continue till all the list are linked. And store value from queue one by one"
                    },
                    {
                        "username": "sanjitj7",
                        "content": "Does ascending order here means monotonously increasing (i.e. list has same values repeating) or strictly increasing? I think it will affect the solution."
                    },
                    {
                        "username": "Husoski",
                        "content": "Did you mean \"monotonically\"? :^)  Anyway, the constraint says \"sorted in ascending order\" and that doesn\\'t prohibit duplicate values in a single list.  Examples show that the final list can contain duplicate values, and there\\'s no requirement for what order those nodes appear in the result, so the relative ordering of equal values can\\'t matter."
                    },
                    {
                        "username": "dmitrii_bokovikov",
                        "content": "It\\'s a middle problem, needs to be downgraded"
                    },
                    {
                        "username": "gopaldk",
                        "content": "Is anybody getting following exception when tried using Priority Queue?\\njava.lang.ClassCastException: class ListNode cannot be cast to class java.lang.Comparable (ListNode is in unnamed module of loader \\'app\\'; java.lang.Comparable is in module java.base of loader \\'bootstrap\\')\\n  at line 643, java.base/java.util.PriorityQueue.siftUpComparable\\n  at line 639, java.base/java.util.PriorityQueue.siftUp\\n  at line 330, java.base/java.util.PriorityQueue.offer\\n  at line 16, Solution.mergeKLists\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main"
                    },
                    {
                        "username": "Husoski",
                        "content": "That will happen if you don\\'t provide a comparator to the PriorityQueue constructor.  The provided ListNode class does not implement Comparable<ListNode>.  I sidestepped this in my Java solution by making my own QueueEntry class to wrap the list \"head pointer\" references, but using a lambda to specify the comparator, something like:\\n`new PriorityQueue<ListNode>((a, b) -> Integer.compare(a.val, b.val))`.  "
                    },
                    {
                        "username": "TanHess",
                        "content": "I believe there is an issue with the solution class (or something similar) in LeetCode. I am trying to enumerate through the lists variable while it is not empty. As I finish iterating through each of the sublists, I remove them from the lists variable no problem. The issue is once I remove the last one, the lists variable correctly shows as empty before my \"while lists:\" loop begins, but then my \"while lists:\" loop fires again and shows a \"None\" value within the lists variable. Is this a known issue within LeetCode?"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Please help me to understand the time complexity here?\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3391586/what-is-the-time-complexity-here-python/\\n\\nthis solution is taking 1200+ms, i\\'m not getting why this much when \\n"
                    },
                    {
                        "username": "nd4312",
                        "content": "All the official solutions extract the values out of the the lists and then creates a new listnode with the values rather than using the existing ListNode. How is that technically not incorrect?? Merging implies use of existing nodes, not creating new nodes..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "I have a helper function `merge` that performs merge sort.\\n\\nWhy do I get a Time Limit Exceeded when I use `reduce`:\\n\\n```python\\ndef mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        return reduce(self.merge, lists, None)\\n```\\n\\nbut not when I use recursion:\\n\\n```python\\ndef mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        if len(lists) == 0: return None\\n        if len(lists) == 1: return lists[0]\\n\\n        mid = len(lists) // 2\\n\\n        # Recursivel merge the lists\\n        return self.merge(self.mergeKLists(lists[:mid]), self.mergeKLists(lists[mid:]))\\n```\\n"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "easily explained in 10 minutes with dry run, just try and you will love it https://youtu.be/jT7-J3KJbWo"
                    }
                ]
            },
            {
                "id": 1869081,
                "content": [
                    {
                        "username": "Aditya560",
                        "content": "Just Use priority Queue to store val and then replace list[0] at end of NULL with list[1] head  continue till all the list are linked. And store value from queue one by one"
                    },
                    {
                        "username": "sanjitj7",
                        "content": "Does ascending order here means monotonously increasing (i.e. list has same values repeating) or strictly increasing? I think it will affect the solution."
                    },
                    {
                        "username": "Husoski",
                        "content": "Did you mean \"monotonically\"? :^)  Anyway, the constraint says \"sorted in ascending order\" and that doesn\\'t prohibit duplicate values in a single list.  Examples show that the final list can contain duplicate values, and there\\'s no requirement for what order those nodes appear in the result, so the relative ordering of equal values can\\'t matter."
                    },
                    {
                        "username": "dmitrii_bokovikov",
                        "content": "It\\'s a middle problem, needs to be downgraded"
                    },
                    {
                        "username": "gopaldk",
                        "content": "Is anybody getting following exception when tried using Priority Queue?\\njava.lang.ClassCastException: class ListNode cannot be cast to class java.lang.Comparable (ListNode is in unnamed module of loader \\'app\\'; java.lang.Comparable is in module java.base of loader \\'bootstrap\\')\\n  at line 643, java.base/java.util.PriorityQueue.siftUpComparable\\n  at line 639, java.base/java.util.PriorityQueue.siftUp\\n  at line 330, java.base/java.util.PriorityQueue.offer\\n  at line 16, Solution.mergeKLists\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main"
                    },
                    {
                        "username": "Husoski",
                        "content": "That will happen if you don\\'t provide a comparator to the PriorityQueue constructor.  The provided ListNode class does not implement Comparable<ListNode>.  I sidestepped this in my Java solution by making my own QueueEntry class to wrap the list \"head pointer\" references, but using a lambda to specify the comparator, something like:\\n`new PriorityQueue<ListNode>((a, b) -> Integer.compare(a.val, b.val))`.  "
                    },
                    {
                        "username": "TanHess",
                        "content": "I believe there is an issue with the solution class (or something similar) in LeetCode. I am trying to enumerate through the lists variable while it is not empty. As I finish iterating through each of the sublists, I remove them from the lists variable no problem. The issue is once I remove the last one, the lists variable correctly shows as empty before my \"while lists:\" loop begins, but then my \"while lists:\" loop fires again and shows a \"None\" value within the lists variable. Is this a known issue within LeetCode?"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Please help me to understand the time complexity here?\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3391586/what-is-the-time-complexity-here-python/\\n\\nthis solution is taking 1200+ms, i\\'m not getting why this much when \\n"
                    },
                    {
                        "username": "nd4312",
                        "content": "All the official solutions extract the values out of the the lists and then creates a new listnode with the values rather than using the existing ListNode. How is that technically not incorrect?? Merging implies use of existing nodes, not creating new nodes..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "I have a helper function `merge` that performs merge sort.\\n\\nWhy do I get a Time Limit Exceeded when I use `reduce`:\\n\\n```python\\ndef mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        return reduce(self.merge, lists, None)\\n```\\n\\nbut not when I use recursion:\\n\\n```python\\ndef mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        if len(lists) == 0: return None\\n        if len(lists) == 1: return lists[0]\\n\\n        mid = len(lists) // 2\\n\\n        # Recursivel merge the lists\\n        return self.merge(self.mergeKLists(lists[:mid]), self.mergeKLists(lists[mid:]))\\n```\\n"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "easily explained in 10 minutes with dry run, just try and you will love it https://youtu.be/jT7-J3KJbWo"
                    }
                ]
            },
            {
                "id": 1860917,
                "content": [
                    {
                        "username": "Aditya560",
                        "content": "Just Use priority Queue to store val and then replace list[0] at end of NULL with list[1] head  continue till all the list are linked. And store value from queue one by one"
                    },
                    {
                        "username": "sanjitj7",
                        "content": "Does ascending order here means monotonously increasing (i.e. list has same values repeating) or strictly increasing? I think it will affect the solution."
                    },
                    {
                        "username": "Husoski",
                        "content": "Did you mean \"monotonically\"? :^)  Anyway, the constraint says \"sorted in ascending order\" and that doesn\\'t prohibit duplicate values in a single list.  Examples show that the final list can contain duplicate values, and there\\'s no requirement for what order those nodes appear in the result, so the relative ordering of equal values can\\'t matter."
                    },
                    {
                        "username": "dmitrii_bokovikov",
                        "content": "It\\'s a middle problem, needs to be downgraded"
                    },
                    {
                        "username": "gopaldk",
                        "content": "Is anybody getting following exception when tried using Priority Queue?\\njava.lang.ClassCastException: class ListNode cannot be cast to class java.lang.Comparable (ListNode is in unnamed module of loader \\'app\\'; java.lang.Comparable is in module java.base of loader \\'bootstrap\\')\\n  at line 643, java.base/java.util.PriorityQueue.siftUpComparable\\n  at line 639, java.base/java.util.PriorityQueue.siftUp\\n  at line 330, java.base/java.util.PriorityQueue.offer\\n  at line 16, Solution.mergeKLists\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main"
                    },
                    {
                        "username": "Husoski",
                        "content": "That will happen if you don\\'t provide a comparator to the PriorityQueue constructor.  The provided ListNode class does not implement Comparable<ListNode>.  I sidestepped this in my Java solution by making my own QueueEntry class to wrap the list \"head pointer\" references, but using a lambda to specify the comparator, something like:\\n`new PriorityQueue<ListNode>((a, b) -> Integer.compare(a.val, b.val))`.  "
                    },
                    {
                        "username": "TanHess",
                        "content": "I believe there is an issue with the solution class (or something similar) in LeetCode. I am trying to enumerate through the lists variable while it is not empty. As I finish iterating through each of the sublists, I remove them from the lists variable no problem. The issue is once I remove the last one, the lists variable correctly shows as empty before my \"while lists:\" loop begins, but then my \"while lists:\" loop fires again and shows a \"None\" value within the lists variable. Is this a known issue within LeetCode?"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Please help me to understand the time complexity here?\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3391586/what-is-the-time-complexity-here-python/\\n\\nthis solution is taking 1200+ms, i\\'m not getting why this much when \\n"
                    },
                    {
                        "username": "nd4312",
                        "content": "All the official solutions extract the values out of the the lists and then creates a new listnode with the values rather than using the existing ListNode. How is that technically not incorrect?? Merging implies use of existing nodes, not creating new nodes..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "I have a helper function `merge` that performs merge sort.\\n\\nWhy do I get a Time Limit Exceeded when I use `reduce`:\\n\\n```python\\ndef mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        return reduce(self.merge, lists, None)\\n```\\n\\nbut not when I use recursion:\\n\\n```python\\ndef mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        if len(lists) == 0: return None\\n        if len(lists) == 1: return lists[0]\\n\\n        mid = len(lists) // 2\\n\\n        # Recursivel merge the lists\\n        return self.merge(self.mergeKLists(lists[:mid]), self.mergeKLists(lists[mid:]))\\n```\\n"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "easily explained in 10 minutes with dry run, just try and you will love it https://youtu.be/jT7-J3KJbWo"
                    }
                ]
            },
            {
                "id": 1856810,
                "content": [
                    {
                        "username": "Aditya560",
                        "content": "Just Use priority Queue to store val and then replace list[0] at end of NULL with list[1] head  continue till all the list are linked. And store value from queue one by one"
                    },
                    {
                        "username": "sanjitj7",
                        "content": "Does ascending order here means monotonously increasing (i.e. list has same values repeating) or strictly increasing? I think it will affect the solution."
                    },
                    {
                        "username": "Husoski",
                        "content": "Did you mean \"monotonically\"? :^)  Anyway, the constraint says \"sorted in ascending order\" and that doesn\\'t prohibit duplicate values in a single list.  Examples show that the final list can contain duplicate values, and there\\'s no requirement for what order those nodes appear in the result, so the relative ordering of equal values can\\'t matter."
                    },
                    {
                        "username": "dmitrii_bokovikov",
                        "content": "It\\'s a middle problem, needs to be downgraded"
                    },
                    {
                        "username": "gopaldk",
                        "content": "Is anybody getting following exception when tried using Priority Queue?\\njava.lang.ClassCastException: class ListNode cannot be cast to class java.lang.Comparable (ListNode is in unnamed module of loader \\'app\\'; java.lang.Comparable is in module java.base of loader \\'bootstrap\\')\\n  at line 643, java.base/java.util.PriorityQueue.siftUpComparable\\n  at line 639, java.base/java.util.PriorityQueue.siftUp\\n  at line 330, java.base/java.util.PriorityQueue.offer\\n  at line 16, Solution.mergeKLists\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main"
                    },
                    {
                        "username": "Husoski",
                        "content": "That will happen if you don\\'t provide a comparator to the PriorityQueue constructor.  The provided ListNode class does not implement Comparable<ListNode>.  I sidestepped this in my Java solution by making my own QueueEntry class to wrap the list \"head pointer\" references, but using a lambda to specify the comparator, something like:\\n`new PriorityQueue<ListNode>((a, b) -> Integer.compare(a.val, b.val))`.  "
                    },
                    {
                        "username": "TanHess",
                        "content": "I believe there is an issue with the solution class (or something similar) in LeetCode. I am trying to enumerate through the lists variable while it is not empty. As I finish iterating through each of the sublists, I remove them from the lists variable no problem. The issue is once I remove the last one, the lists variable correctly shows as empty before my \"while lists:\" loop begins, but then my \"while lists:\" loop fires again and shows a \"None\" value within the lists variable. Is this a known issue within LeetCode?"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Please help me to understand the time complexity here?\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3391586/what-is-the-time-complexity-here-python/\\n\\nthis solution is taking 1200+ms, i\\'m not getting why this much when \\n"
                    },
                    {
                        "username": "nd4312",
                        "content": "All the official solutions extract the values out of the the lists and then creates a new listnode with the values rather than using the existing ListNode. How is that technically not incorrect?? Merging implies use of existing nodes, not creating new nodes..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "I have a helper function `merge` that performs merge sort.\\n\\nWhy do I get a Time Limit Exceeded when I use `reduce`:\\n\\n```python\\ndef mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        return reduce(self.merge, lists, None)\\n```\\n\\nbut not when I use recursion:\\n\\n```python\\ndef mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        if len(lists) == 0: return None\\n        if len(lists) == 1: return lists[0]\\n\\n        mid = len(lists) // 2\\n\\n        # Recursivel merge the lists\\n        return self.merge(self.mergeKLists(lists[:mid]), self.mergeKLists(lists[mid:]))\\n```\\n"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "easily explained in 10 minutes with dry run, just try and you will love it https://youtu.be/jT7-J3KJbWo"
                    }
                ]
            },
            {
                "id": 1855905,
                "content": [
                    {
                        "username": "Aditya560",
                        "content": "Just Use priority Queue to store val and then replace list[0] at end of NULL with list[1] head  continue till all the list are linked. And store value from queue one by one"
                    },
                    {
                        "username": "sanjitj7",
                        "content": "Does ascending order here means monotonously increasing (i.e. list has same values repeating) or strictly increasing? I think it will affect the solution."
                    },
                    {
                        "username": "Husoski",
                        "content": "Did you mean \"monotonically\"? :^)  Anyway, the constraint says \"sorted in ascending order\" and that doesn\\'t prohibit duplicate values in a single list.  Examples show that the final list can contain duplicate values, and there\\'s no requirement for what order those nodes appear in the result, so the relative ordering of equal values can\\'t matter."
                    },
                    {
                        "username": "dmitrii_bokovikov",
                        "content": "It\\'s a middle problem, needs to be downgraded"
                    },
                    {
                        "username": "gopaldk",
                        "content": "Is anybody getting following exception when tried using Priority Queue?\\njava.lang.ClassCastException: class ListNode cannot be cast to class java.lang.Comparable (ListNode is in unnamed module of loader \\'app\\'; java.lang.Comparable is in module java.base of loader \\'bootstrap\\')\\n  at line 643, java.base/java.util.PriorityQueue.siftUpComparable\\n  at line 639, java.base/java.util.PriorityQueue.siftUp\\n  at line 330, java.base/java.util.PriorityQueue.offer\\n  at line 16, Solution.mergeKLists\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main"
                    },
                    {
                        "username": "Husoski",
                        "content": "That will happen if you don\\'t provide a comparator to the PriorityQueue constructor.  The provided ListNode class does not implement Comparable<ListNode>.  I sidestepped this in my Java solution by making my own QueueEntry class to wrap the list \"head pointer\" references, but using a lambda to specify the comparator, something like:\\n`new PriorityQueue<ListNode>((a, b) -> Integer.compare(a.val, b.val))`.  "
                    },
                    {
                        "username": "TanHess",
                        "content": "I believe there is an issue with the solution class (or something similar) in LeetCode. I am trying to enumerate through the lists variable while it is not empty. As I finish iterating through each of the sublists, I remove them from the lists variable no problem. The issue is once I remove the last one, the lists variable correctly shows as empty before my \"while lists:\" loop begins, but then my \"while lists:\" loop fires again and shows a \"None\" value within the lists variable. Is this a known issue within LeetCode?"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Please help me to understand the time complexity here?\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3391586/what-is-the-time-complexity-here-python/\\n\\nthis solution is taking 1200+ms, i\\'m not getting why this much when \\n"
                    },
                    {
                        "username": "nd4312",
                        "content": "All the official solutions extract the values out of the the lists and then creates a new listnode with the values rather than using the existing ListNode. How is that technically not incorrect?? Merging implies use of existing nodes, not creating new nodes..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "I have a helper function `merge` that performs merge sort.\\n\\nWhy do I get a Time Limit Exceeded when I use `reduce`:\\n\\n```python\\ndef mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        return reduce(self.merge, lists, None)\\n```\\n\\nbut not when I use recursion:\\n\\n```python\\ndef mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        if len(lists) == 0: return None\\n        if len(lists) == 1: return lists[0]\\n\\n        mid = len(lists) // 2\\n\\n        # Recursivel merge the lists\\n        return self.merge(self.mergeKLists(lists[:mid]), self.mergeKLists(lists[mid:]))\\n```\\n"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "easily explained in 10 minutes with dry run, just try and you will love it https://youtu.be/jT7-J3KJbWo"
                    }
                ]
            },
            {
                "id": 1831817,
                "content": [
                    {
                        "username": "Aditya560",
                        "content": "Just Use priority Queue to store val and then replace list[0] at end of NULL with list[1] head  continue till all the list are linked. And store value from queue one by one"
                    },
                    {
                        "username": "sanjitj7",
                        "content": "Does ascending order here means monotonously increasing (i.e. list has same values repeating) or strictly increasing? I think it will affect the solution."
                    },
                    {
                        "username": "Husoski",
                        "content": "Did you mean \"monotonically\"? :^)  Anyway, the constraint says \"sorted in ascending order\" and that doesn\\'t prohibit duplicate values in a single list.  Examples show that the final list can contain duplicate values, and there\\'s no requirement for what order those nodes appear in the result, so the relative ordering of equal values can\\'t matter."
                    },
                    {
                        "username": "dmitrii_bokovikov",
                        "content": "It\\'s a middle problem, needs to be downgraded"
                    },
                    {
                        "username": "gopaldk",
                        "content": "Is anybody getting following exception when tried using Priority Queue?\\njava.lang.ClassCastException: class ListNode cannot be cast to class java.lang.Comparable (ListNode is in unnamed module of loader \\'app\\'; java.lang.Comparable is in module java.base of loader \\'bootstrap\\')\\n  at line 643, java.base/java.util.PriorityQueue.siftUpComparable\\n  at line 639, java.base/java.util.PriorityQueue.siftUp\\n  at line 330, java.base/java.util.PriorityQueue.offer\\n  at line 16, Solution.mergeKLists\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main"
                    },
                    {
                        "username": "Husoski",
                        "content": "That will happen if you don\\'t provide a comparator to the PriorityQueue constructor.  The provided ListNode class does not implement Comparable<ListNode>.  I sidestepped this in my Java solution by making my own QueueEntry class to wrap the list \"head pointer\" references, but using a lambda to specify the comparator, something like:\\n`new PriorityQueue<ListNode>((a, b) -> Integer.compare(a.val, b.val))`.  "
                    },
                    {
                        "username": "TanHess",
                        "content": "I believe there is an issue with the solution class (or something similar) in LeetCode. I am trying to enumerate through the lists variable while it is not empty. As I finish iterating through each of the sublists, I remove them from the lists variable no problem. The issue is once I remove the last one, the lists variable correctly shows as empty before my \"while lists:\" loop begins, but then my \"while lists:\" loop fires again and shows a \"None\" value within the lists variable. Is this a known issue within LeetCode?"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Please help me to understand the time complexity here?\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3391586/what-is-the-time-complexity-here-python/\\n\\nthis solution is taking 1200+ms, i\\'m not getting why this much when \\n"
                    },
                    {
                        "username": "nd4312",
                        "content": "All the official solutions extract the values out of the the lists and then creates a new listnode with the values rather than using the existing ListNode. How is that technically not incorrect?? Merging implies use of existing nodes, not creating new nodes..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "I have a helper function `merge` that performs merge sort.\\n\\nWhy do I get a Time Limit Exceeded when I use `reduce`:\\n\\n```python\\ndef mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        return reduce(self.merge, lists, None)\\n```\\n\\nbut not when I use recursion:\\n\\n```python\\ndef mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        if len(lists) == 0: return None\\n        if len(lists) == 1: return lists[0]\\n\\n        mid = len(lists) // 2\\n\\n        # Recursivel merge the lists\\n        return self.merge(self.mergeKLists(lists[:mid]), self.mergeKLists(lists[mid:]))\\n```\\n"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "easily explained in 10 minutes with dry run, just try and you will love it https://youtu.be/jT7-J3KJbWo"
                    }
                ]
            },
            {
                "id": 1830767,
                "content": [
                    {
                        "username": "Aditya560",
                        "content": "Just Use priority Queue to store val and then replace list[0] at end of NULL with list[1] head  continue till all the list are linked. And store value from queue one by one"
                    },
                    {
                        "username": "sanjitj7",
                        "content": "Does ascending order here means monotonously increasing (i.e. list has same values repeating) or strictly increasing? I think it will affect the solution."
                    },
                    {
                        "username": "Husoski",
                        "content": "Did you mean \"monotonically\"? :^)  Anyway, the constraint says \"sorted in ascending order\" and that doesn\\'t prohibit duplicate values in a single list.  Examples show that the final list can contain duplicate values, and there\\'s no requirement for what order those nodes appear in the result, so the relative ordering of equal values can\\'t matter."
                    },
                    {
                        "username": "dmitrii_bokovikov",
                        "content": "It\\'s a middle problem, needs to be downgraded"
                    },
                    {
                        "username": "gopaldk",
                        "content": "Is anybody getting following exception when tried using Priority Queue?\\njava.lang.ClassCastException: class ListNode cannot be cast to class java.lang.Comparable (ListNode is in unnamed module of loader \\'app\\'; java.lang.Comparable is in module java.base of loader \\'bootstrap\\')\\n  at line 643, java.base/java.util.PriorityQueue.siftUpComparable\\n  at line 639, java.base/java.util.PriorityQueue.siftUp\\n  at line 330, java.base/java.util.PriorityQueue.offer\\n  at line 16, Solution.mergeKLists\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main"
                    },
                    {
                        "username": "Husoski",
                        "content": "That will happen if you don\\'t provide a comparator to the PriorityQueue constructor.  The provided ListNode class does not implement Comparable<ListNode>.  I sidestepped this in my Java solution by making my own QueueEntry class to wrap the list \"head pointer\" references, but using a lambda to specify the comparator, something like:\\n`new PriorityQueue<ListNode>((a, b) -> Integer.compare(a.val, b.val))`.  "
                    },
                    {
                        "username": "TanHess",
                        "content": "I believe there is an issue with the solution class (or something similar) in LeetCode. I am trying to enumerate through the lists variable while it is not empty. As I finish iterating through each of the sublists, I remove them from the lists variable no problem. The issue is once I remove the last one, the lists variable correctly shows as empty before my \"while lists:\" loop begins, but then my \"while lists:\" loop fires again and shows a \"None\" value within the lists variable. Is this a known issue within LeetCode?"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Please help me to understand the time complexity here?\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3391586/what-is-the-time-complexity-here-python/\\n\\nthis solution is taking 1200+ms, i\\'m not getting why this much when \\n"
                    },
                    {
                        "username": "nd4312",
                        "content": "All the official solutions extract the values out of the the lists and then creates a new listnode with the values rather than using the existing ListNode. How is that technically not incorrect?? Merging implies use of existing nodes, not creating new nodes..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "I have a helper function `merge` that performs merge sort.\\n\\nWhy do I get a Time Limit Exceeded when I use `reduce`:\\n\\n```python\\ndef mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        return reduce(self.merge, lists, None)\\n```\\n\\nbut not when I use recursion:\\n\\n```python\\ndef mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        if len(lists) == 0: return None\\n        if len(lists) == 1: return lists[0]\\n\\n        mid = len(lists) // 2\\n\\n        # Recursivel merge the lists\\n        return self.merge(self.mergeKLists(lists[:mid]), self.mergeKLists(lists[mid:]))\\n```\\n"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "easily explained in 10 minutes with dry run, just try and you will love it https://youtu.be/jT7-J3KJbWo"
                    }
                ]
            },
            {
                "id": 1830584,
                "content": [
                    {
                        "username": "Aditya560",
                        "content": "Just Use priority Queue to store val and then replace list[0] at end of NULL with list[1] head  continue till all the list are linked. And store value from queue one by one"
                    },
                    {
                        "username": "sanjitj7",
                        "content": "Does ascending order here means monotonously increasing (i.e. list has same values repeating) or strictly increasing? I think it will affect the solution."
                    },
                    {
                        "username": "Husoski",
                        "content": "Did you mean \"monotonically\"? :^)  Anyway, the constraint says \"sorted in ascending order\" and that doesn\\'t prohibit duplicate values in a single list.  Examples show that the final list can contain duplicate values, and there\\'s no requirement for what order those nodes appear in the result, so the relative ordering of equal values can\\'t matter."
                    },
                    {
                        "username": "dmitrii_bokovikov",
                        "content": "It\\'s a middle problem, needs to be downgraded"
                    },
                    {
                        "username": "gopaldk",
                        "content": "Is anybody getting following exception when tried using Priority Queue?\\njava.lang.ClassCastException: class ListNode cannot be cast to class java.lang.Comparable (ListNode is in unnamed module of loader \\'app\\'; java.lang.Comparable is in module java.base of loader \\'bootstrap\\')\\n  at line 643, java.base/java.util.PriorityQueue.siftUpComparable\\n  at line 639, java.base/java.util.PriorityQueue.siftUp\\n  at line 330, java.base/java.util.PriorityQueue.offer\\n  at line 16, Solution.mergeKLists\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main"
                    },
                    {
                        "username": "Husoski",
                        "content": "That will happen if you don\\'t provide a comparator to the PriorityQueue constructor.  The provided ListNode class does not implement Comparable<ListNode>.  I sidestepped this in my Java solution by making my own QueueEntry class to wrap the list \"head pointer\" references, but using a lambda to specify the comparator, something like:\\n`new PriorityQueue<ListNode>((a, b) -> Integer.compare(a.val, b.val))`.  "
                    },
                    {
                        "username": "TanHess",
                        "content": "I believe there is an issue with the solution class (or something similar) in LeetCode. I am trying to enumerate through the lists variable while it is not empty. As I finish iterating through each of the sublists, I remove them from the lists variable no problem. The issue is once I remove the last one, the lists variable correctly shows as empty before my \"while lists:\" loop begins, but then my \"while lists:\" loop fires again and shows a \"None\" value within the lists variable. Is this a known issue within LeetCode?"
                    },
                    {
                        "username": "rahulnegi2021",
                        "content": "Please help me to understand the time complexity here?\\nhttps://leetcode.com/problems/merge-k-sorted-lists/solutions/3391586/what-is-the-time-complexity-here-python/\\n\\nthis solution is taking 1200+ms, i\\'m not getting why this much when \\n"
                    },
                    {
                        "username": "nd4312",
                        "content": "All the official solutions extract the values out of the the lists and then creates a new listnode with the values rather than using the existing ListNode. How is that technically not incorrect?? Merging implies use of existing nodes, not creating new nodes..."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "how come ppl post a detailed solution at 6:00-6:30 IST, like man u got the question at 5.30 IST only\\nwhat a superpower \\uD83D\\uDE31\\uD83D\\uDE31\\uD83D\\uDE31"
                    },
                    {
                        "username": "drvnprgrmr",
                        "content": "I have a helper function `merge` that performs merge sort.\\n\\nWhy do I get a Time Limit Exceeded when I use `reduce`:\\n\\n```python\\ndef mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        return reduce(self.merge, lists, None)\\n```\\n\\nbut not when I use recursion:\\n\\n```python\\ndef mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\\n        if len(lists) == 0: return None\\n        if len(lists) == 1: return lists[0]\\n\\n        mid = len(lists) // 2\\n\\n        # Recursivel merge the lists\\n        return self.merge(self.mergeKLists(lists[:mid]), self.mergeKLists(lists[mid:]))\\n```\\n"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "easily explained in 10 minutes with dry run, just try and you will love it https://youtu.be/jT7-J3KJbWo"
                    }
                ]
            },
            {
                "id": 1830554,
                "content": [
                    {
                        "username": "spreusche",
                        "content": "I dont think it should be considered \"hard\". I believe it is medium or easy, at least to find a solution. Maybe the best solution is medium"
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "Is it cheating if we use the language\\'s built in sort function after merging the lists\\' values into an array? Asking for a friend"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "[@vylv](/vylv) The point of Big O is not to count every O(n) when you have O(nlogn) in your equation."
                    },
                    {
                        "username": "vylv",
                        "content": "No, it\\'s not cheating. But this is slow solution with O(n) to merge + O(nlogn) to sort + O(n) to convert array to LinkedList."
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I did it using brute force"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don't understand why this is tagged with priority queue and 'hard'. I wrote a solution with a priority queue, because I thought it would be required by the time constraint. But when I looked at the top JS submissions none of them used a priority queue. You can just go through the lists, put everything in an array, sort that array and loop over it, putting everything in a new List and return that. Super simple, took me 5 minutes and the code takes 79 ms (beats 97%). Why would you tag it as hard and priority queue?"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "this is simple solution but how to implement using prority queue bro and the take away from this problem bro"
                    },
                    {
                        "username": "GD18",
                        "content": "easy question if u take extra space, upper mid if u dont"
                    },
                    {
                        "username": "rasel33",
                        "content": "Think about priority_queue it will be an easy one."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Solved it with Linked-List with Merge-Sort Algorithm with brute-force, without array or vector conversion."
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "why does print(lists[0])\\nreturns list index out of range?"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "In LL is empty in case"
                    },
                    {
                        "username": "joseph261059",
                        "content": "For those who don\\'t understand why an array and sort solution is faster than linked list + heap solution, you can check out this video\\n\\nhttps://www.youtube.com/watch?v=DyG9S9nAlUM"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute force makes this question easy otherwise this is indeed a hard problem!"
                    }
                ]
            },
            {
                "id": 1830516,
                "content": [
                    {
                        "username": "spreusche",
                        "content": "I dont think it should be considered \"hard\". I believe it is medium or easy, at least to find a solution. Maybe the best solution is medium"
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "Is it cheating if we use the language\\'s built in sort function after merging the lists\\' values into an array? Asking for a friend"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "[@vylv](/vylv) The point of Big O is not to count every O(n) when you have O(nlogn) in your equation."
                    },
                    {
                        "username": "vylv",
                        "content": "No, it\\'s not cheating. But this is slow solution with O(n) to merge + O(nlogn) to sort + O(n) to convert array to LinkedList."
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I did it using brute force"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don't understand why this is tagged with priority queue and 'hard'. I wrote a solution with a priority queue, because I thought it would be required by the time constraint. But when I looked at the top JS submissions none of them used a priority queue. You can just go through the lists, put everything in an array, sort that array and loop over it, putting everything in a new List and return that. Super simple, took me 5 minutes and the code takes 79 ms (beats 97%). Why would you tag it as hard and priority queue?"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "this is simple solution but how to implement using prority queue bro and the take away from this problem bro"
                    },
                    {
                        "username": "GD18",
                        "content": "easy question if u take extra space, upper mid if u dont"
                    },
                    {
                        "username": "rasel33",
                        "content": "Think about priority_queue it will be an easy one."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Solved it with Linked-List with Merge-Sort Algorithm with brute-force, without array or vector conversion."
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "why does print(lists[0])\\nreturns list index out of range?"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "In LL is empty in case"
                    },
                    {
                        "username": "joseph261059",
                        "content": "For those who don\\'t understand why an array and sort solution is faster than linked list + heap solution, you can check out this video\\n\\nhttps://www.youtube.com/watch?v=DyG9S9nAlUM"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute force makes this question easy otherwise this is indeed a hard problem!"
                    }
                ]
            },
            {
                "id": 1830337,
                "content": [
                    {
                        "username": "spreusche",
                        "content": "I dont think it should be considered \"hard\". I believe it is medium or easy, at least to find a solution. Maybe the best solution is medium"
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "Is it cheating if we use the language\\'s built in sort function after merging the lists\\' values into an array? Asking for a friend"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "[@vylv](/vylv) The point of Big O is not to count every O(n) when you have O(nlogn) in your equation."
                    },
                    {
                        "username": "vylv",
                        "content": "No, it\\'s not cheating. But this is slow solution with O(n) to merge + O(nlogn) to sort + O(n) to convert array to LinkedList."
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I did it using brute force"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don't understand why this is tagged with priority queue and 'hard'. I wrote a solution with a priority queue, because I thought it would be required by the time constraint. But when I looked at the top JS submissions none of them used a priority queue. You can just go through the lists, put everything in an array, sort that array and loop over it, putting everything in a new List and return that. Super simple, took me 5 minutes and the code takes 79 ms (beats 97%). Why would you tag it as hard and priority queue?"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "this is simple solution but how to implement using prority queue bro and the take away from this problem bro"
                    },
                    {
                        "username": "GD18",
                        "content": "easy question if u take extra space, upper mid if u dont"
                    },
                    {
                        "username": "rasel33",
                        "content": "Think about priority_queue it will be an easy one."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Solved it with Linked-List with Merge-Sort Algorithm with brute-force, without array or vector conversion."
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "why does print(lists[0])\\nreturns list index out of range?"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "In LL is empty in case"
                    },
                    {
                        "username": "joseph261059",
                        "content": "For those who don\\'t understand why an array and sort solution is faster than linked list + heap solution, you can check out this video\\n\\nhttps://www.youtube.com/watch?v=DyG9S9nAlUM"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute force makes this question easy otherwise this is indeed a hard problem!"
                    }
                ]
            },
            {
                "id": 1830301,
                "content": [
                    {
                        "username": "spreusche",
                        "content": "I dont think it should be considered \"hard\". I believe it is medium or easy, at least to find a solution. Maybe the best solution is medium"
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "Is it cheating if we use the language\\'s built in sort function after merging the lists\\' values into an array? Asking for a friend"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "[@vylv](/vylv) The point of Big O is not to count every O(n) when you have O(nlogn) in your equation."
                    },
                    {
                        "username": "vylv",
                        "content": "No, it\\'s not cheating. But this is slow solution with O(n) to merge + O(nlogn) to sort + O(n) to convert array to LinkedList."
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I did it using brute force"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don't understand why this is tagged with priority queue and 'hard'. I wrote a solution with a priority queue, because I thought it would be required by the time constraint. But when I looked at the top JS submissions none of them used a priority queue. You can just go through the lists, put everything in an array, sort that array and loop over it, putting everything in a new List and return that. Super simple, took me 5 minutes and the code takes 79 ms (beats 97%). Why would you tag it as hard and priority queue?"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "this is simple solution but how to implement using prority queue bro and the take away from this problem bro"
                    },
                    {
                        "username": "GD18",
                        "content": "easy question if u take extra space, upper mid if u dont"
                    },
                    {
                        "username": "rasel33",
                        "content": "Think about priority_queue it will be an easy one."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Solved it with Linked-List with Merge-Sort Algorithm with brute-force, without array or vector conversion."
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "why does print(lists[0])\\nreturns list index out of range?"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "In LL is empty in case"
                    },
                    {
                        "username": "joseph261059",
                        "content": "For those who don\\'t understand why an array and sort solution is faster than linked list + heap solution, you can check out this video\\n\\nhttps://www.youtube.com/watch?v=DyG9S9nAlUM"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute force makes this question easy otherwise this is indeed a hard problem!"
                    }
                ]
            },
            {
                "id": 1830213,
                "content": [
                    {
                        "username": "spreusche",
                        "content": "I dont think it should be considered \"hard\". I believe it is medium or easy, at least to find a solution. Maybe the best solution is medium"
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "Is it cheating if we use the language\\'s built in sort function after merging the lists\\' values into an array? Asking for a friend"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "[@vylv](/vylv) The point of Big O is not to count every O(n) when you have O(nlogn) in your equation."
                    },
                    {
                        "username": "vylv",
                        "content": "No, it\\'s not cheating. But this is slow solution with O(n) to merge + O(nlogn) to sort + O(n) to convert array to LinkedList."
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I did it using brute force"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don't understand why this is tagged with priority queue and 'hard'. I wrote a solution with a priority queue, because I thought it would be required by the time constraint. But when I looked at the top JS submissions none of them used a priority queue. You can just go through the lists, put everything in an array, sort that array and loop over it, putting everything in a new List and return that. Super simple, took me 5 minutes and the code takes 79 ms (beats 97%). Why would you tag it as hard and priority queue?"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "this is simple solution but how to implement using prority queue bro and the take away from this problem bro"
                    },
                    {
                        "username": "GD18",
                        "content": "easy question if u take extra space, upper mid if u dont"
                    },
                    {
                        "username": "rasel33",
                        "content": "Think about priority_queue it will be an easy one."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Solved it with Linked-List with Merge-Sort Algorithm with brute-force, without array or vector conversion."
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "why does print(lists[0])\\nreturns list index out of range?"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "In LL is empty in case"
                    },
                    {
                        "username": "joseph261059",
                        "content": "For those who don\\'t understand why an array and sort solution is faster than linked list + heap solution, you can check out this video\\n\\nhttps://www.youtube.com/watch?v=DyG9S9nAlUM"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute force makes this question easy otherwise this is indeed a hard problem!"
                    }
                ]
            },
            {
                "id": 1830137,
                "content": [
                    {
                        "username": "spreusche",
                        "content": "I dont think it should be considered \"hard\". I believe it is medium or easy, at least to find a solution. Maybe the best solution is medium"
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "Is it cheating if we use the language\\'s built in sort function after merging the lists\\' values into an array? Asking for a friend"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "[@vylv](/vylv) The point of Big O is not to count every O(n) when you have O(nlogn) in your equation."
                    },
                    {
                        "username": "vylv",
                        "content": "No, it\\'s not cheating. But this is slow solution with O(n) to merge + O(nlogn) to sort + O(n) to convert array to LinkedList."
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I did it using brute force"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don't understand why this is tagged with priority queue and 'hard'. I wrote a solution with a priority queue, because I thought it would be required by the time constraint. But when I looked at the top JS submissions none of them used a priority queue. You can just go through the lists, put everything in an array, sort that array and loop over it, putting everything in a new List and return that. Super simple, took me 5 minutes and the code takes 79 ms (beats 97%). Why would you tag it as hard and priority queue?"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "this is simple solution but how to implement using prority queue bro and the take away from this problem bro"
                    },
                    {
                        "username": "GD18",
                        "content": "easy question if u take extra space, upper mid if u dont"
                    },
                    {
                        "username": "rasel33",
                        "content": "Think about priority_queue it will be an easy one."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Solved it with Linked-List with Merge-Sort Algorithm with brute-force, without array or vector conversion."
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "why does print(lists[0])\\nreturns list index out of range?"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "In LL is empty in case"
                    },
                    {
                        "username": "joseph261059",
                        "content": "For those who don\\'t understand why an array and sort solution is faster than linked list + heap solution, you can check out this video\\n\\nhttps://www.youtube.com/watch?v=DyG9S9nAlUM"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute force makes this question easy otherwise this is indeed a hard problem!"
                    }
                ]
            },
            {
                "id": 1830043,
                "content": [
                    {
                        "username": "spreusche",
                        "content": "I dont think it should be considered \"hard\". I believe it is medium or easy, at least to find a solution. Maybe the best solution is medium"
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "Is it cheating if we use the language\\'s built in sort function after merging the lists\\' values into an array? Asking for a friend"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "[@vylv](/vylv) The point of Big O is not to count every O(n) when you have O(nlogn) in your equation."
                    },
                    {
                        "username": "vylv",
                        "content": "No, it\\'s not cheating. But this is slow solution with O(n) to merge + O(nlogn) to sort + O(n) to convert array to LinkedList."
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I did it using brute force"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don't understand why this is tagged with priority queue and 'hard'. I wrote a solution with a priority queue, because I thought it would be required by the time constraint. But when I looked at the top JS submissions none of them used a priority queue. You can just go through the lists, put everything in an array, sort that array and loop over it, putting everything in a new List and return that. Super simple, took me 5 minutes and the code takes 79 ms (beats 97%). Why would you tag it as hard and priority queue?"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "this is simple solution but how to implement using prority queue bro and the take away from this problem bro"
                    },
                    {
                        "username": "GD18",
                        "content": "easy question if u take extra space, upper mid if u dont"
                    },
                    {
                        "username": "rasel33",
                        "content": "Think about priority_queue it will be an easy one."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Solved it with Linked-List with Merge-Sort Algorithm with brute-force, without array or vector conversion."
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "why does print(lists[0])\\nreturns list index out of range?"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "In LL is empty in case"
                    },
                    {
                        "username": "joseph261059",
                        "content": "For those who don\\'t understand why an array and sort solution is faster than linked list + heap solution, you can check out this video\\n\\nhttps://www.youtube.com/watch?v=DyG9S9nAlUM"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute force makes this question easy otherwise this is indeed a hard problem!"
                    }
                ]
            },
            {
                "id": 1829969,
                "content": [
                    {
                        "username": "spreusche",
                        "content": "I dont think it should be considered \"hard\". I believe it is medium or easy, at least to find a solution. Maybe the best solution is medium"
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "Is it cheating if we use the language\\'s built in sort function after merging the lists\\' values into an array? Asking for a friend"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "[@vylv](/vylv) The point of Big O is not to count every O(n) when you have O(nlogn) in your equation."
                    },
                    {
                        "username": "vylv",
                        "content": "No, it\\'s not cheating. But this is slow solution with O(n) to merge + O(nlogn) to sort + O(n) to convert array to LinkedList."
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I did it using brute force"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don't understand why this is tagged with priority queue and 'hard'. I wrote a solution with a priority queue, because I thought it would be required by the time constraint. But when I looked at the top JS submissions none of them used a priority queue. You can just go through the lists, put everything in an array, sort that array and loop over it, putting everything in a new List and return that. Super simple, took me 5 minutes and the code takes 79 ms (beats 97%). Why would you tag it as hard and priority queue?"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "this is simple solution but how to implement using prority queue bro and the take away from this problem bro"
                    },
                    {
                        "username": "GD18",
                        "content": "easy question if u take extra space, upper mid if u dont"
                    },
                    {
                        "username": "rasel33",
                        "content": "Think about priority_queue it will be an easy one."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Solved it with Linked-List with Merge-Sort Algorithm with brute-force, without array or vector conversion."
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "why does print(lists[0])\\nreturns list index out of range?"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "In LL is empty in case"
                    },
                    {
                        "username": "joseph261059",
                        "content": "For those who don\\'t understand why an array and sort solution is faster than linked list + heap solution, you can check out this video\\n\\nhttps://www.youtube.com/watch?v=DyG9S9nAlUM"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute force makes this question easy otherwise this is indeed a hard problem!"
                    }
                ]
            },
            {
                "id": 1829916,
                "content": [
                    {
                        "username": "spreusche",
                        "content": "I dont think it should be considered \"hard\". I believe it is medium or easy, at least to find a solution. Maybe the best solution is medium"
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "Is it cheating if we use the language\\'s built in sort function after merging the lists\\' values into an array? Asking for a friend"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "[@vylv](/vylv) The point of Big O is not to count every O(n) when you have O(nlogn) in your equation."
                    },
                    {
                        "username": "vylv",
                        "content": "No, it\\'s not cheating. But this is slow solution with O(n) to merge + O(nlogn) to sort + O(n) to convert array to LinkedList."
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I did it using brute force"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don't understand why this is tagged with priority queue and 'hard'. I wrote a solution with a priority queue, because I thought it would be required by the time constraint. But when I looked at the top JS submissions none of them used a priority queue. You can just go through the lists, put everything in an array, sort that array and loop over it, putting everything in a new List and return that. Super simple, took me 5 minutes and the code takes 79 ms (beats 97%). Why would you tag it as hard and priority queue?"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "this is simple solution but how to implement using prority queue bro and the take away from this problem bro"
                    },
                    {
                        "username": "GD18",
                        "content": "easy question if u take extra space, upper mid if u dont"
                    },
                    {
                        "username": "rasel33",
                        "content": "Think about priority_queue it will be an easy one."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Solved it with Linked-List with Merge-Sort Algorithm with brute-force, without array or vector conversion."
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "why does print(lists[0])\\nreturns list index out of range?"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "In LL is empty in case"
                    },
                    {
                        "username": "joseph261059",
                        "content": "For those who don\\'t understand why an array and sort solution is faster than linked list + heap solution, you can check out this video\\n\\nhttps://www.youtube.com/watch?v=DyG9S9nAlUM"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute force makes this question easy otherwise this is indeed a hard problem!"
                    }
                ]
            },
            {
                "id": 1829747,
                "content": [
                    {
                        "username": "spreusche",
                        "content": "I dont think it should be considered \"hard\". I believe it is medium or easy, at least to find a solution. Maybe the best solution is medium"
                    },
                    {
                        "username": "NoMansGhost",
                        "content": "Is it cheating if we use the language\\'s built in sort function after merging the lists\\' values into an array? Asking for a friend"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "[@vylv](/vylv) The point of Big O is not to count every O(n) when you have O(nlogn) in your equation."
                    },
                    {
                        "username": "vylv",
                        "content": "No, it\\'s not cheating. But this is slow solution with O(n) to merge + O(nlogn) to sort + O(n) to convert array to LinkedList."
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I did it using brute force"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I don't understand why this is tagged with priority queue and 'hard'. I wrote a solution with a priority queue, because I thought it would be required by the time constraint. But when I looked at the top JS submissions none of them used a priority queue. You can just go through the lists, put everything in an array, sort that array and loop over it, putting everything in a new List and return that. Super simple, took me 5 minutes and the code takes 79 ms (beats 97%). Why would you tag it as hard and priority queue?"
                    },
                    {
                        "username": "mdsaquib347",
                        "content": "this is simple solution but how to implement using prority queue bro and the take away from this problem bro"
                    },
                    {
                        "username": "GD18",
                        "content": "easy question if u take extra space, upper mid if u dont"
                    },
                    {
                        "username": "rasel33",
                        "content": "Think about priority_queue it will be an easy one."
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Solved it with Linked-List with Merge-Sort Algorithm with brute-force, without array or vector conversion."
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "why does print(lists[0])\\nreturns list index out of range?"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "In LL is empty in case"
                    },
                    {
                        "username": "joseph261059",
                        "content": "For those who don\\'t understand why an array and sort solution is faster than linked list + heap solution, you can check out this video\\n\\nhttps://www.youtube.com/watch?v=DyG9S9nAlUM"
                    },
                    {
                        "username": "Maninder_4",
                        "content": "Brute force makes this question easy otherwise this is indeed a hard problem!"
                    }
                ]
            },
            {
                "id": 1829696,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Merge Sort ! ! !"
                    },
                    {
                        "username": "c4tdog",
                        "content": "good when hard is not really hard :)"
                    },
                    {
                        "username": "jssyc13",
                        "content": "This is not what I expected for Sunday morning."
                    },
                    {
                        "username": "Diamantis",
                        "content": "When I came up with the obvious solution of throwing everything either in a `min heap` or a `vector` and then easily creating the `ListNode*` I though \"hmmm, I wonder why this won't work, rejecting $O(N*lonN)$ with these input constraints will be something I've never seen before\". To my surprise this is a problem between the easy-medium range mislabeled as hard."
                    },
                    {
                        "username": "cheesebread",
                        "content": "I\\'m not sure if it\\'s because I\\'m more experienced now after solving a couple hundred, but this seems pretty intuitive for a hard. I\\'d say it\\'s more a medium."
                    },
                    {
                        "username": "anwendeng",
                        "content": "It seems not so hard to solve this problem. How to modify the merge in Merge sort is a tip.https://leetcode.com/problems/sort-an-array/solutions/3242061/c-merge-sort/"
                    },
                    {
                        "username": "kelsh",
                        "content": "I\\'m somewhat new to leetcode, done some problems but don\\'t grind them. The types made no sense to me in javascript, did you do something to the prototype so it console logs as a normal array?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "This problem uses a data structure called \"linked lists\". They\\'re represented as arrays in the problem description, but they work differently. It basically consists of nodes that each have a .next property that points to the next node until you reach the end of the list (tail node) which points to null. Check out the comment in the code editor for a definition of a linked list. I\\'d recommend you to do some easier linked list problems first, so you can get familiar with the data structure. :) "
                    },
                    {
                        "username": "cagils",
                        "content": "First write the method to merge two sorted lists (available as a separate LeetCode problem)\\nThen use either of the following methods:\\n1) Use a Queue. Take 2 lists from the head merge them and add it to the end until a single list remains.\\n2) Use the standard mergesort algorithm as in merge(mergeSort(left), mergeSort(right))\\n3) Use a min heap if your pl supports it. Store head of every list in min heap (priority queue) and then get the min"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "I solved this problem by creating an array and it passed. Is my solution bad and if I use such approach while interview will the interviewer asks to solve it again"
                    }
                ]
            },
            {
                "id": 1829655,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Merge Sort ! ! !"
                    },
                    {
                        "username": "c4tdog",
                        "content": "good when hard is not really hard :)"
                    },
                    {
                        "username": "jssyc13",
                        "content": "This is not what I expected for Sunday morning."
                    },
                    {
                        "username": "Diamantis",
                        "content": "When I came up with the obvious solution of throwing everything either in a `min heap` or a `vector` and then easily creating the `ListNode*` I though \"hmmm, I wonder why this won't work, rejecting $O(N*lonN)$ with these input constraints will be something I've never seen before\". To my surprise this is a problem between the easy-medium range mislabeled as hard."
                    },
                    {
                        "username": "cheesebread",
                        "content": "I\\'m not sure if it\\'s because I\\'m more experienced now after solving a couple hundred, but this seems pretty intuitive for a hard. I\\'d say it\\'s more a medium."
                    },
                    {
                        "username": "anwendeng",
                        "content": "It seems not so hard to solve this problem. How to modify the merge in Merge sort is a tip.https://leetcode.com/problems/sort-an-array/solutions/3242061/c-merge-sort/"
                    },
                    {
                        "username": "kelsh",
                        "content": "I\\'m somewhat new to leetcode, done some problems but don\\'t grind them. The types made no sense to me in javascript, did you do something to the prototype so it console logs as a normal array?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "This problem uses a data structure called \"linked lists\". They\\'re represented as arrays in the problem description, but they work differently. It basically consists of nodes that each have a .next property that points to the next node until you reach the end of the list (tail node) which points to null. Check out the comment in the code editor for a definition of a linked list. I\\'d recommend you to do some easier linked list problems first, so you can get familiar with the data structure. :) "
                    },
                    {
                        "username": "cagils",
                        "content": "First write the method to merge two sorted lists (available as a separate LeetCode problem)\\nThen use either of the following methods:\\n1) Use a Queue. Take 2 lists from the head merge them and add it to the end until a single list remains.\\n2) Use the standard mergesort algorithm as in merge(mergeSort(left), mergeSort(right))\\n3) Use a min heap if your pl supports it. Store head of every list in min heap (priority queue) and then get the min"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "I solved this problem by creating an array and it passed. Is my solution bad and if I use such approach while interview will the interviewer asks to solve it again"
                    }
                ]
            },
            {
                "id": 1829618,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Merge Sort ! ! !"
                    },
                    {
                        "username": "c4tdog",
                        "content": "good when hard is not really hard :)"
                    },
                    {
                        "username": "jssyc13",
                        "content": "This is not what I expected for Sunday morning."
                    },
                    {
                        "username": "Diamantis",
                        "content": "When I came up with the obvious solution of throwing everything either in a `min heap` or a `vector` and then easily creating the `ListNode*` I though \"hmmm, I wonder why this won't work, rejecting $O(N*lonN)$ with these input constraints will be something I've never seen before\". To my surprise this is a problem between the easy-medium range mislabeled as hard."
                    },
                    {
                        "username": "cheesebread",
                        "content": "I\\'m not sure if it\\'s because I\\'m more experienced now after solving a couple hundred, but this seems pretty intuitive for a hard. I\\'d say it\\'s more a medium."
                    },
                    {
                        "username": "anwendeng",
                        "content": "It seems not so hard to solve this problem. How to modify the merge in Merge sort is a tip.https://leetcode.com/problems/sort-an-array/solutions/3242061/c-merge-sort/"
                    },
                    {
                        "username": "kelsh",
                        "content": "I\\'m somewhat new to leetcode, done some problems but don\\'t grind them. The types made no sense to me in javascript, did you do something to the prototype so it console logs as a normal array?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "This problem uses a data structure called \"linked lists\". They\\'re represented as arrays in the problem description, but they work differently. It basically consists of nodes that each have a .next property that points to the next node until you reach the end of the list (tail node) which points to null. Check out the comment in the code editor for a definition of a linked list. I\\'d recommend you to do some easier linked list problems first, so you can get familiar with the data structure. :) "
                    },
                    {
                        "username": "cagils",
                        "content": "First write the method to merge two sorted lists (available as a separate LeetCode problem)\\nThen use either of the following methods:\\n1) Use a Queue. Take 2 lists from the head merge them and add it to the end until a single list remains.\\n2) Use the standard mergesort algorithm as in merge(mergeSort(left), mergeSort(right))\\n3) Use a min heap if your pl supports it. Store head of every list in min heap (priority queue) and then get the min"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "I solved this problem by creating an array and it passed. Is my solution bad and if I use such approach while interview will the interviewer asks to solve it again"
                    }
                ]
            },
            {
                "id": 1829608,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Merge Sort ! ! !"
                    },
                    {
                        "username": "c4tdog",
                        "content": "good when hard is not really hard :)"
                    },
                    {
                        "username": "jssyc13",
                        "content": "This is not what I expected for Sunday morning."
                    },
                    {
                        "username": "Diamantis",
                        "content": "When I came up with the obvious solution of throwing everything either in a `min heap` or a `vector` and then easily creating the `ListNode*` I though \"hmmm, I wonder why this won't work, rejecting $O(N*lonN)$ with these input constraints will be something I've never seen before\". To my surprise this is a problem between the easy-medium range mislabeled as hard."
                    },
                    {
                        "username": "cheesebread",
                        "content": "I\\'m not sure if it\\'s because I\\'m more experienced now after solving a couple hundred, but this seems pretty intuitive for a hard. I\\'d say it\\'s more a medium."
                    },
                    {
                        "username": "anwendeng",
                        "content": "It seems not so hard to solve this problem. How to modify the merge in Merge sort is a tip.https://leetcode.com/problems/sort-an-array/solutions/3242061/c-merge-sort/"
                    },
                    {
                        "username": "kelsh",
                        "content": "I\\'m somewhat new to leetcode, done some problems but don\\'t grind them. The types made no sense to me in javascript, did you do something to the prototype so it console logs as a normal array?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "This problem uses a data structure called \"linked lists\". They\\'re represented as arrays in the problem description, but they work differently. It basically consists of nodes that each have a .next property that points to the next node until you reach the end of the list (tail node) which points to null. Check out the comment in the code editor for a definition of a linked list. I\\'d recommend you to do some easier linked list problems first, so you can get familiar with the data structure. :) "
                    },
                    {
                        "username": "cagils",
                        "content": "First write the method to merge two sorted lists (available as a separate LeetCode problem)\\nThen use either of the following methods:\\n1) Use a Queue. Take 2 lists from the head merge them and add it to the end until a single list remains.\\n2) Use the standard mergesort algorithm as in merge(mergeSort(left), mergeSort(right))\\n3) Use a min heap if your pl supports it. Store head of every list in min heap (priority queue) and then get the min"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "I solved this problem by creating an array and it passed. Is my solution bad and if I use such approach while interview will the interviewer asks to solve it again"
                    }
                ]
            },
            {
                "id": 1829606,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Merge Sort ! ! !"
                    },
                    {
                        "username": "c4tdog",
                        "content": "good when hard is not really hard :)"
                    },
                    {
                        "username": "jssyc13",
                        "content": "This is not what I expected for Sunday morning."
                    },
                    {
                        "username": "Diamantis",
                        "content": "When I came up with the obvious solution of throwing everything either in a `min heap` or a `vector` and then easily creating the `ListNode*` I though \"hmmm, I wonder why this won't work, rejecting $O(N*lonN)$ with these input constraints will be something I've never seen before\". To my surprise this is a problem between the easy-medium range mislabeled as hard."
                    },
                    {
                        "username": "cheesebread",
                        "content": "I\\'m not sure if it\\'s because I\\'m more experienced now after solving a couple hundred, but this seems pretty intuitive for a hard. I\\'d say it\\'s more a medium."
                    },
                    {
                        "username": "anwendeng",
                        "content": "It seems not so hard to solve this problem. How to modify the merge in Merge sort is a tip.https://leetcode.com/problems/sort-an-array/solutions/3242061/c-merge-sort/"
                    },
                    {
                        "username": "kelsh",
                        "content": "I\\'m somewhat new to leetcode, done some problems but don\\'t grind them. The types made no sense to me in javascript, did you do something to the prototype so it console logs as a normal array?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "This problem uses a data structure called \"linked lists\". They\\'re represented as arrays in the problem description, but they work differently. It basically consists of nodes that each have a .next property that points to the next node until you reach the end of the list (tail node) which points to null. Check out the comment in the code editor for a definition of a linked list. I\\'d recommend you to do some easier linked list problems first, so you can get familiar with the data structure. :) "
                    },
                    {
                        "username": "cagils",
                        "content": "First write the method to merge two sorted lists (available as a separate LeetCode problem)\\nThen use either of the following methods:\\n1) Use a Queue. Take 2 lists from the head merge them and add it to the end until a single list remains.\\n2) Use the standard mergesort algorithm as in merge(mergeSort(left), mergeSort(right))\\n3) Use a min heap if your pl supports it. Store head of every list in min heap (priority queue) and then get the min"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "I solved this problem by creating an array and it passed. Is my solution bad and if I use such approach while interview will the interviewer asks to solve it again"
                    }
                ]
            },
            {
                "id": 1829605,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Merge Sort ! ! !"
                    },
                    {
                        "username": "c4tdog",
                        "content": "good when hard is not really hard :)"
                    },
                    {
                        "username": "jssyc13",
                        "content": "This is not what I expected for Sunday morning."
                    },
                    {
                        "username": "Diamantis",
                        "content": "When I came up with the obvious solution of throwing everything either in a `min heap` or a `vector` and then easily creating the `ListNode*` I though \"hmmm, I wonder why this won't work, rejecting $O(N*lonN)$ with these input constraints will be something I've never seen before\". To my surprise this is a problem between the easy-medium range mislabeled as hard."
                    },
                    {
                        "username": "cheesebread",
                        "content": "I\\'m not sure if it\\'s because I\\'m more experienced now after solving a couple hundred, but this seems pretty intuitive for a hard. I\\'d say it\\'s more a medium."
                    },
                    {
                        "username": "anwendeng",
                        "content": "It seems not so hard to solve this problem. How to modify the merge in Merge sort is a tip.https://leetcode.com/problems/sort-an-array/solutions/3242061/c-merge-sort/"
                    },
                    {
                        "username": "kelsh",
                        "content": "I\\'m somewhat new to leetcode, done some problems but don\\'t grind them. The types made no sense to me in javascript, did you do something to the prototype so it console logs as a normal array?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "This problem uses a data structure called \"linked lists\". They\\'re represented as arrays in the problem description, but they work differently. It basically consists of nodes that each have a .next property that points to the next node until you reach the end of the list (tail node) which points to null. Check out the comment in the code editor for a definition of a linked list. I\\'d recommend you to do some easier linked list problems first, so you can get familiar with the data structure. :) "
                    },
                    {
                        "username": "cagils",
                        "content": "First write the method to merge two sorted lists (available as a separate LeetCode problem)\\nThen use either of the following methods:\\n1) Use a Queue. Take 2 lists from the head merge them and add it to the end until a single list remains.\\n2) Use the standard mergesort algorithm as in merge(mergeSort(left), mergeSort(right))\\n3) Use a min heap if your pl supports it. Store head of every list in min heap (priority queue) and then get the min"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "I solved this problem by creating an array and it passed. Is my solution bad and if I use such approach while interview will the interviewer asks to solve it again"
                    }
                ]
            },
            {
                "id": 1829584,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Merge Sort ! ! !"
                    },
                    {
                        "username": "c4tdog",
                        "content": "good when hard is not really hard :)"
                    },
                    {
                        "username": "jssyc13",
                        "content": "This is not what I expected for Sunday morning."
                    },
                    {
                        "username": "Diamantis",
                        "content": "When I came up with the obvious solution of throwing everything either in a `min heap` or a `vector` and then easily creating the `ListNode*` I though \"hmmm, I wonder why this won't work, rejecting $O(N*lonN)$ with these input constraints will be something I've never seen before\". To my surprise this is a problem between the easy-medium range mislabeled as hard."
                    },
                    {
                        "username": "cheesebread",
                        "content": "I\\'m not sure if it\\'s because I\\'m more experienced now after solving a couple hundred, but this seems pretty intuitive for a hard. I\\'d say it\\'s more a medium."
                    },
                    {
                        "username": "anwendeng",
                        "content": "It seems not so hard to solve this problem. How to modify the merge in Merge sort is a tip.https://leetcode.com/problems/sort-an-array/solutions/3242061/c-merge-sort/"
                    },
                    {
                        "username": "kelsh",
                        "content": "I\\'m somewhat new to leetcode, done some problems but don\\'t grind them. The types made no sense to me in javascript, did you do something to the prototype so it console logs as a normal array?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "This problem uses a data structure called \"linked lists\". They\\'re represented as arrays in the problem description, but they work differently. It basically consists of nodes that each have a .next property that points to the next node until you reach the end of the list (tail node) which points to null. Check out the comment in the code editor for a definition of a linked list. I\\'d recommend you to do some easier linked list problems first, so you can get familiar with the data structure. :) "
                    },
                    {
                        "username": "cagils",
                        "content": "First write the method to merge two sorted lists (available as a separate LeetCode problem)\\nThen use either of the following methods:\\n1) Use a Queue. Take 2 lists from the head merge them and add it to the end until a single list remains.\\n2) Use the standard mergesort algorithm as in merge(mergeSort(left), mergeSort(right))\\n3) Use a min heap if your pl supports it. Store head of every list in min heap (priority queue) and then get the min"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "I solved this problem by creating an array and it passed. Is my solution bad and if I use such approach while interview will the interviewer asks to solve it again"
                    }
                ]
            },
            {
                "id": 1829073,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Merge Sort ! ! !"
                    },
                    {
                        "username": "c4tdog",
                        "content": "good when hard is not really hard :)"
                    },
                    {
                        "username": "jssyc13",
                        "content": "This is not what I expected for Sunday morning."
                    },
                    {
                        "username": "Diamantis",
                        "content": "When I came up with the obvious solution of throwing everything either in a `min heap` or a `vector` and then easily creating the `ListNode*` I though \"hmmm, I wonder why this won't work, rejecting $O(N*lonN)$ with these input constraints will be something I've never seen before\". To my surprise this is a problem between the easy-medium range mislabeled as hard."
                    },
                    {
                        "username": "cheesebread",
                        "content": "I\\'m not sure if it\\'s because I\\'m more experienced now after solving a couple hundred, but this seems pretty intuitive for a hard. I\\'d say it\\'s more a medium."
                    },
                    {
                        "username": "anwendeng",
                        "content": "It seems not so hard to solve this problem. How to modify the merge in Merge sort is a tip.https://leetcode.com/problems/sort-an-array/solutions/3242061/c-merge-sort/"
                    },
                    {
                        "username": "kelsh",
                        "content": "I\\'m somewhat new to leetcode, done some problems but don\\'t grind them. The types made no sense to me in javascript, did you do something to the prototype so it console logs as a normal array?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "This problem uses a data structure called \"linked lists\". They\\'re represented as arrays in the problem description, but they work differently. It basically consists of nodes that each have a .next property that points to the next node until you reach the end of the list (tail node) which points to null. Check out the comment in the code editor for a definition of a linked list. I\\'d recommend you to do some easier linked list problems first, so you can get familiar with the data structure. :) "
                    },
                    {
                        "username": "cagils",
                        "content": "First write the method to merge two sorted lists (available as a separate LeetCode problem)\\nThen use either of the following methods:\\n1) Use a Queue. Take 2 lists from the head merge them and add it to the end until a single list remains.\\n2) Use the standard mergesort algorithm as in merge(mergeSort(left), mergeSort(right))\\n3) Use a min heap if your pl supports it. Store head of every list in min heap (priority queue) and then get the min"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "I solved this problem by creating an array and it passed. Is my solution bad and if I use such approach while interview will the interviewer asks to solve it again"
                    }
                ]
            },
            {
                "id": 1828196,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Merge Sort ! ! !"
                    },
                    {
                        "username": "c4tdog",
                        "content": "good when hard is not really hard :)"
                    },
                    {
                        "username": "jssyc13",
                        "content": "This is not what I expected for Sunday morning."
                    },
                    {
                        "username": "Diamantis",
                        "content": "When I came up with the obvious solution of throwing everything either in a `min heap` or a `vector` and then easily creating the `ListNode*` I though \"hmmm, I wonder why this won't work, rejecting $O(N*lonN)$ with these input constraints will be something I've never seen before\". To my surprise this is a problem between the easy-medium range mislabeled as hard."
                    },
                    {
                        "username": "cheesebread",
                        "content": "I\\'m not sure if it\\'s because I\\'m more experienced now after solving a couple hundred, but this seems pretty intuitive for a hard. I\\'d say it\\'s more a medium."
                    },
                    {
                        "username": "anwendeng",
                        "content": "It seems not so hard to solve this problem. How to modify the merge in Merge sort is a tip.https://leetcode.com/problems/sort-an-array/solutions/3242061/c-merge-sort/"
                    },
                    {
                        "username": "kelsh",
                        "content": "I\\'m somewhat new to leetcode, done some problems but don\\'t grind them. The types made no sense to me in javascript, did you do something to the prototype so it console logs as a normal array?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "This problem uses a data structure called \"linked lists\". They\\'re represented as arrays in the problem description, but they work differently. It basically consists of nodes that each have a .next property that points to the next node until you reach the end of the list (tail node) which points to null. Check out the comment in the code editor for a definition of a linked list. I\\'d recommend you to do some easier linked list problems first, so you can get familiar with the data structure. :) "
                    },
                    {
                        "username": "cagils",
                        "content": "First write the method to merge two sorted lists (available as a separate LeetCode problem)\\nThen use either of the following methods:\\n1) Use a Queue. Take 2 lists from the head merge them and add it to the end until a single list remains.\\n2) Use the standard mergesort algorithm as in merge(mergeSort(left), mergeSort(right))\\n3) Use a min heap if your pl supports it. Store head of every list in min heap (priority queue) and then get the min"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "I solved this problem by creating an array and it passed. Is my solution bad and if I use such approach while interview will the interviewer asks to solve it again"
                    }
                ]
            },
            {
                "id": 1815810,
                "content": [
                    {
                        "username": "justsolveitlmao",
                        "content": "\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Merge Sort ! ! !"
                    },
                    {
                        "username": "c4tdog",
                        "content": "good when hard is not really hard :)"
                    },
                    {
                        "username": "jssyc13",
                        "content": "This is not what I expected for Sunday morning."
                    },
                    {
                        "username": "Diamantis",
                        "content": "When I came up with the obvious solution of throwing everything either in a `min heap` or a `vector` and then easily creating the `ListNode*` I though \"hmmm, I wonder why this won't work, rejecting $O(N*lonN)$ with these input constraints will be something I've never seen before\". To my surprise this is a problem between the easy-medium range mislabeled as hard."
                    },
                    {
                        "username": "cheesebread",
                        "content": "I\\'m not sure if it\\'s because I\\'m more experienced now after solving a couple hundred, but this seems pretty intuitive for a hard. I\\'d say it\\'s more a medium."
                    },
                    {
                        "username": "anwendeng",
                        "content": "It seems not so hard to solve this problem. How to modify the merge in Merge sort is a tip.https://leetcode.com/problems/sort-an-array/solutions/3242061/c-merge-sort/"
                    },
                    {
                        "username": "kelsh",
                        "content": "I\\'m somewhat new to leetcode, done some problems but don\\'t grind them. The types made no sense to me in javascript, did you do something to the prototype so it console logs as a normal array?"
                    },
                    {
                        "username": "Pellyyy",
                        "content": "This problem uses a data structure called \"linked lists\". They\\'re represented as arrays in the problem description, but they work differently. It basically consists of nodes that each have a .next property that points to the next node until you reach the end of the list (tail node) which points to null. Check out the comment in the code editor for a definition of a linked list. I\\'d recommend you to do some easier linked list problems first, so you can get familiar with the data structure. :) "
                    },
                    {
                        "username": "cagils",
                        "content": "First write the method to merge two sorted lists (available as a separate LeetCode problem)\\nThen use either of the following methods:\\n1) Use a Queue. Take 2 lists from the head merge them and add it to the end until a single list remains.\\n2) Use the standard mergesort algorithm as in merge(mergeSort(left), mergeSort(right))\\n3) Use a min heap if your pl supports it. Store head of every list in min heap (priority queue) and then get the min"
                    },
                    {
                        "username": "Asliddin70",
                        "content": "I solved this problem by creating an array and it passed. Is my solution bad and if I use such approach while interview will the interviewer asks to solve it again"
                    }
                ]
            },
            {
                "id": 1807115,
                "content": [
                    {
                        "username": "agamsrivastava004",
                        "content": "C++ here \\nMy approach is to reuse the solution in the merge two sorted linked list problem and just put it in a for loop and go at it 2 at a time \\n\\nI get stuck on the test case - [[2],[],[-1]]\\nWhen I do the output individually it gives correct output --> \\n[[2],[]] ==> [2]\\n[[2],[-1]] ==> [-1,2]\\n\\nlike how is that even possible \\nmy code is-->\\n```\\nListNode* merge2Lists(ListNode* list1, ListNode* list2)\\n{\\n  if(list1 == NULL) return list2;\\n  if(list2 == NULL) return list1;\\n  ListNode* new_node;\\n \\n  if (list1->val < list2->val) {\\n    new_node = list1;\\n    list1 = list1->next;\\n  }\\n  else {\\n    new_node = list2;\\n    list2 = list2->next;\\n  }\\n   ListNode* head = new_node;\\n  while (list1 && list2) {\\n    if (list1->val < list2->val) {\\n      new_node->next = list1;\\n      list1 = list1->next;\\n    }\\n    else {\\n      new_node->next = list2;\\n      list2 = list2->next;\\n    }\\n    new_node = new_node->next;\\n  }\\n  if (!list1) new_node->next = list2;\\n  else new_node->next = list1;\\n  return head;\\n}\\n\\nListNode* mergeKLists(vector<ListNode*>& lists)\\n{\\n  ListNode* head;\\n  if(lists.size() == 0) return head;\\n  if(lists.size() == 1) return lists[0];\\n  for (int i = 0; i < lists.size() - 1; ++i) {\\n    head = merge2Lists(lists[i], lists[i+1]);\\n  }\\n  return head;\\n}\\n```"
                    },
                    {
                        "username": "mikael6767",
                        "content": "Could someone please say how to do this problem using ListNode. I don\\'t know. It\\'s just awful with ListNode. I am programming on Python3 and have no idea what is ListNode. This is very easy on Python3, but please help me with this ListNode!"
                    },
                    {
                        "username": "adherent____",
                        "content": "simple- use dummy list and make merge call with all the elements of vector"
                    },
                    {
                        "username": "hdrwilkinson",
                        "content": "PYTHON 3 HELP NEEDED. I can't understand why I'm getting an error.\n`\nclass Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        prehead = ListNode(-1)\n        pointer = prehead\n\n        t = True\n        while t == True:\n            print(t)\n            print(lists)\n            print(\"\")\n            values = {}\n\n            for i, l in enumerate(lists):\n                values[i] = l.val\n            idx = min(values, key=values.get)\n            pointer.next = ListNode(lists[idx].val)\n            pointer = pointer.next\n\n            if lists[idx].next == None:\n                lists.pop(idx)\n            else:\n                lists[idx] = lists[idx].next\n\n            if not lists:\n                t = False\n                print(t)\n                \n        return prehead.next\n`\n\nOn what is meant to be the final loop, it prints that t = False. But, then it starts another loop with t = True.\n"
                    },
                    {
                        "username": "Falselysium",
                        "content": "I\\'m getting this error when I\\'m using my lists[0] to hold my ans.\\nI\\'m basically merging 2 sorted list with lists[0] and lists[i] where i is all list from 1 to len(lists)\\n\\nlists[0] isn\\'t NULL I\\'ve checked with print statements. \\nI\\'m not sure if it\\'s a pointer thing. \\nand print(len(lists)) returns 3 <b>for the first test case </b>|\\n\\n### Error I\\'m getting\\n```IndexError: list index out of range\\n    temp = lists[0]\\nLine 29 in mergeKLists (Solution.py)\\n    ret = Solution().mergeKLists(param_1)\\nLine 51 in _driver (Solution.py)\\n    _driver()\\nLine 62 in <module> (Solution.py)\\n```\\n\\n## Spoilers part of my not working solution\\n```\\nfor i in lists[1:]:\\n            temp = merge(lists[0] ,i)\\n            lists[0] = temp\\n        temp = lists[0]\\n        temp = temp.next\\n        print(len(lists),temp.val) #printed 3, 1\\n        return temp\\n```\\nSo there are a bunch of unnecessary variables, but I was trying to debug.  "
                    },
                    {
                        "username": "JaafarH",
                        "content": "Why does this code gives an Time limit exceeded please ? (Python)\n\n\n\ndef mergeKLists(self,lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        myList = lists[0]\n        if not lists:\n            return None\n        if len(lists) == 1:\n            return lists[0]\n        i = 1\n        for i in range(len(lists)):\n            myList = self.mergeTwoLists(myList,lists[i])\n        \n        return myList\n        \n\n\n    def mergeTwoLists(self,list1,list2):\n        myList = dummy = ListNode(0)\n        while list1 and list2:\n            if list1.val <= list2.val :\n                myList.next = list1\n                myList = myList.next\n                list1 = list1.next\n            else:\n                myList.next = list2\n                myList = myList.next\n                list2 = list2.next\n        if list1 :\n            myList.next = list1\n        else :\n            myList.next = list2\n        return dummy.next\n"
                    },
                    {
                        "username": "JaafarH",
                        "content": "Please does anyone understands why this code gives me a Time Limit Exceeded ?\n\n `def mergeKLists(self,lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        myList = lists[0]\n        if not lists:\n            return None\n        if len(lists) == 1:\n            return lists[0]\n        i = 1\n        for i in range(len(lists)):\n            myList = self.mergeTwoLists(myList,lists[i])\n        \n        return myList\n        \n\n\n    def mergeTwoLists(self,list1,list2):\n        myList = dummy = ListNode(0)\n        while list1 and list2:\n            if list1.val <= list2.val :\n                myList.next = list1\n                myList = myList.next\n                list1 = list1.next\n            else:\n                myList.next = list2\n                myList = myList.next\n                list2 = list2.next\n        if list1 :\n            myList.next = list1\n        else :\n            myList.next = list2\n        return dummy.next`"
                    },
                    {
                        "username": "grootSingh",
                        "content": "using priority Queue who\\'s Time Complexity is: O(N\\u2217logK) and Space Complexity is: O (K);\\nworks slower and take much more space in comparison to array + sort solution who\\'s \\nTime Complexity is: O(NK\\u2217logN) and Space Complexity is: O (NK);\\n\\nwhy is this happening? why theoretical explanation is not getting the result in practical question?\\n// i am using JavaScript to solve this problem?"
                    },
                    {
                        "username": "omdhyawarneniwar23",
                        "content": "Store all the values of linkedlist of lists in a empty vector,then sort that vector and create new linkedlist from the sorted values of vector."
                    },
                    {
                        "username": "Difoldery",
                        "content": "Maybe smb knows why it cant return zero element of array with length 8\n\n\nclass Solution(object):\n    def mergeKLists(self, lists):\n       \n        per = 10000\n        count = [0]*20010\n\n        for i in lists:\n            g = i\n            while(g != None):\n                count[(int)(g.val)+per]+=1\n                g = g.next\n\n        las = []\n        c = 0\n        for i in range(per*2):\n            if count[i] > 0:\n                for j in range(count[i]):\n                    las.append(ListNode(i-per))\n                    c+=1\n                    \n        for i in range(c):\n            if i > 0:\n                las[c-2-i].next = las[c-1-i]\n        \n        return las[0]\n\n"
                    }
                ]
            },
            {
                "id": 1804696,
                "content": [
                    {
                        "username": "agamsrivastava004",
                        "content": "C++ here \\nMy approach is to reuse the solution in the merge two sorted linked list problem and just put it in a for loop and go at it 2 at a time \\n\\nI get stuck on the test case - [[2],[],[-1]]\\nWhen I do the output individually it gives correct output --> \\n[[2],[]] ==> [2]\\n[[2],[-1]] ==> [-1,2]\\n\\nlike how is that even possible \\nmy code is-->\\n```\\nListNode* merge2Lists(ListNode* list1, ListNode* list2)\\n{\\n  if(list1 == NULL) return list2;\\n  if(list2 == NULL) return list1;\\n  ListNode* new_node;\\n \\n  if (list1->val < list2->val) {\\n    new_node = list1;\\n    list1 = list1->next;\\n  }\\n  else {\\n    new_node = list2;\\n    list2 = list2->next;\\n  }\\n   ListNode* head = new_node;\\n  while (list1 && list2) {\\n    if (list1->val < list2->val) {\\n      new_node->next = list1;\\n      list1 = list1->next;\\n    }\\n    else {\\n      new_node->next = list2;\\n      list2 = list2->next;\\n    }\\n    new_node = new_node->next;\\n  }\\n  if (!list1) new_node->next = list2;\\n  else new_node->next = list1;\\n  return head;\\n}\\n\\nListNode* mergeKLists(vector<ListNode*>& lists)\\n{\\n  ListNode* head;\\n  if(lists.size() == 0) return head;\\n  if(lists.size() == 1) return lists[0];\\n  for (int i = 0; i < lists.size() - 1; ++i) {\\n    head = merge2Lists(lists[i], lists[i+1]);\\n  }\\n  return head;\\n}\\n```"
                    },
                    {
                        "username": "mikael6767",
                        "content": "Could someone please say how to do this problem using ListNode. I don\\'t know. It\\'s just awful with ListNode. I am programming on Python3 and have no idea what is ListNode. This is very easy on Python3, but please help me with this ListNode!"
                    },
                    {
                        "username": "adherent____",
                        "content": "simple- use dummy list and make merge call with all the elements of vector"
                    },
                    {
                        "username": "hdrwilkinson",
                        "content": "PYTHON 3 HELP NEEDED. I can't understand why I'm getting an error.\n`\nclass Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        prehead = ListNode(-1)\n        pointer = prehead\n\n        t = True\n        while t == True:\n            print(t)\n            print(lists)\n            print(\"\")\n            values = {}\n\n            for i, l in enumerate(lists):\n                values[i] = l.val\n            idx = min(values, key=values.get)\n            pointer.next = ListNode(lists[idx].val)\n            pointer = pointer.next\n\n            if lists[idx].next == None:\n                lists.pop(idx)\n            else:\n                lists[idx] = lists[idx].next\n\n            if not lists:\n                t = False\n                print(t)\n                \n        return prehead.next\n`\n\nOn what is meant to be the final loop, it prints that t = False. But, then it starts another loop with t = True.\n"
                    },
                    {
                        "username": "Falselysium",
                        "content": "I\\'m getting this error when I\\'m using my lists[0] to hold my ans.\\nI\\'m basically merging 2 sorted list with lists[0] and lists[i] where i is all list from 1 to len(lists)\\n\\nlists[0] isn\\'t NULL I\\'ve checked with print statements. \\nI\\'m not sure if it\\'s a pointer thing. \\nand print(len(lists)) returns 3 <b>for the first test case </b>|\\n\\n### Error I\\'m getting\\n```IndexError: list index out of range\\n    temp = lists[0]\\nLine 29 in mergeKLists (Solution.py)\\n    ret = Solution().mergeKLists(param_1)\\nLine 51 in _driver (Solution.py)\\n    _driver()\\nLine 62 in <module> (Solution.py)\\n```\\n\\n## Spoilers part of my not working solution\\n```\\nfor i in lists[1:]:\\n            temp = merge(lists[0] ,i)\\n            lists[0] = temp\\n        temp = lists[0]\\n        temp = temp.next\\n        print(len(lists),temp.val) #printed 3, 1\\n        return temp\\n```\\nSo there are a bunch of unnecessary variables, but I was trying to debug.  "
                    },
                    {
                        "username": "JaafarH",
                        "content": "Why does this code gives an Time limit exceeded please ? (Python)\n\n\n\ndef mergeKLists(self,lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        myList = lists[0]\n        if not lists:\n            return None\n        if len(lists) == 1:\n            return lists[0]\n        i = 1\n        for i in range(len(lists)):\n            myList = self.mergeTwoLists(myList,lists[i])\n        \n        return myList\n        \n\n\n    def mergeTwoLists(self,list1,list2):\n        myList = dummy = ListNode(0)\n        while list1 and list2:\n            if list1.val <= list2.val :\n                myList.next = list1\n                myList = myList.next\n                list1 = list1.next\n            else:\n                myList.next = list2\n                myList = myList.next\n                list2 = list2.next\n        if list1 :\n            myList.next = list1\n        else :\n            myList.next = list2\n        return dummy.next\n"
                    },
                    {
                        "username": "JaafarH",
                        "content": "Please does anyone understands why this code gives me a Time Limit Exceeded ?\n\n `def mergeKLists(self,lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        myList = lists[0]\n        if not lists:\n            return None\n        if len(lists) == 1:\n            return lists[0]\n        i = 1\n        for i in range(len(lists)):\n            myList = self.mergeTwoLists(myList,lists[i])\n        \n        return myList\n        \n\n\n    def mergeTwoLists(self,list1,list2):\n        myList = dummy = ListNode(0)\n        while list1 and list2:\n            if list1.val <= list2.val :\n                myList.next = list1\n                myList = myList.next\n                list1 = list1.next\n            else:\n                myList.next = list2\n                myList = myList.next\n                list2 = list2.next\n        if list1 :\n            myList.next = list1\n        else :\n            myList.next = list2\n        return dummy.next`"
                    },
                    {
                        "username": "grootSingh",
                        "content": "using priority Queue who\\'s Time Complexity is: O(N\\u2217logK) and Space Complexity is: O (K);\\nworks slower and take much more space in comparison to array + sort solution who\\'s \\nTime Complexity is: O(NK\\u2217logN) and Space Complexity is: O (NK);\\n\\nwhy is this happening? why theoretical explanation is not getting the result in practical question?\\n// i am using JavaScript to solve this problem?"
                    },
                    {
                        "username": "omdhyawarneniwar23",
                        "content": "Store all the values of linkedlist of lists in a empty vector,then sort that vector and create new linkedlist from the sorted values of vector."
                    },
                    {
                        "username": "Difoldery",
                        "content": "Maybe smb knows why it cant return zero element of array with length 8\n\n\nclass Solution(object):\n    def mergeKLists(self, lists):\n       \n        per = 10000\n        count = [0]*20010\n\n        for i in lists:\n            g = i\n            while(g != None):\n                count[(int)(g.val)+per]+=1\n                g = g.next\n\n        las = []\n        c = 0\n        for i in range(per*2):\n            if count[i] > 0:\n                for j in range(count[i]):\n                    las.append(ListNode(i-per))\n                    c+=1\n                    \n        for i in range(c):\n            if i > 0:\n                las[c-2-i].next = las[c-1-i]\n        \n        return las[0]\n\n"
                    }
                ]
            },
            {
                "id": 1800907,
                "content": [
                    {
                        "username": "agamsrivastava004",
                        "content": "C++ here \\nMy approach is to reuse the solution in the merge two sorted linked list problem and just put it in a for loop and go at it 2 at a time \\n\\nI get stuck on the test case - [[2],[],[-1]]\\nWhen I do the output individually it gives correct output --> \\n[[2],[]] ==> [2]\\n[[2],[-1]] ==> [-1,2]\\n\\nlike how is that even possible \\nmy code is-->\\n```\\nListNode* merge2Lists(ListNode* list1, ListNode* list2)\\n{\\n  if(list1 == NULL) return list2;\\n  if(list2 == NULL) return list1;\\n  ListNode* new_node;\\n \\n  if (list1->val < list2->val) {\\n    new_node = list1;\\n    list1 = list1->next;\\n  }\\n  else {\\n    new_node = list2;\\n    list2 = list2->next;\\n  }\\n   ListNode* head = new_node;\\n  while (list1 && list2) {\\n    if (list1->val < list2->val) {\\n      new_node->next = list1;\\n      list1 = list1->next;\\n    }\\n    else {\\n      new_node->next = list2;\\n      list2 = list2->next;\\n    }\\n    new_node = new_node->next;\\n  }\\n  if (!list1) new_node->next = list2;\\n  else new_node->next = list1;\\n  return head;\\n}\\n\\nListNode* mergeKLists(vector<ListNode*>& lists)\\n{\\n  ListNode* head;\\n  if(lists.size() == 0) return head;\\n  if(lists.size() == 1) return lists[0];\\n  for (int i = 0; i < lists.size() - 1; ++i) {\\n    head = merge2Lists(lists[i], lists[i+1]);\\n  }\\n  return head;\\n}\\n```"
                    },
                    {
                        "username": "mikael6767",
                        "content": "Could someone please say how to do this problem using ListNode. I don\\'t know. It\\'s just awful with ListNode. I am programming on Python3 and have no idea what is ListNode. This is very easy on Python3, but please help me with this ListNode!"
                    },
                    {
                        "username": "adherent____",
                        "content": "simple- use dummy list and make merge call with all the elements of vector"
                    },
                    {
                        "username": "hdrwilkinson",
                        "content": "PYTHON 3 HELP NEEDED. I can't understand why I'm getting an error.\n`\nclass Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        prehead = ListNode(-1)\n        pointer = prehead\n\n        t = True\n        while t == True:\n            print(t)\n            print(lists)\n            print(\"\")\n            values = {}\n\n            for i, l in enumerate(lists):\n                values[i] = l.val\n            idx = min(values, key=values.get)\n            pointer.next = ListNode(lists[idx].val)\n            pointer = pointer.next\n\n            if lists[idx].next == None:\n                lists.pop(idx)\n            else:\n                lists[idx] = lists[idx].next\n\n            if not lists:\n                t = False\n                print(t)\n                \n        return prehead.next\n`\n\nOn what is meant to be the final loop, it prints that t = False. But, then it starts another loop with t = True.\n"
                    },
                    {
                        "username": "Falselysium",
                        "content": "I\\'m getting this error when I\\'m using my lists[0] to hold my ans.\\nI\\'m basically merging 2 sorted list with lists[0] and lists[i] where i is all list from 1 to len(lists)\\n\\nlists[0] isn\\'t NULL I\\'ve checked with print statements. \\nI\\'m not sure if it\\'s a pointer thing. \\nand print(len(lists)) returns 3 <b>for the first test case </b>|\\n\\n### Error I\\'m getting\\n```IndexError: list index out of range\\n    temp = lists[0]\\nLine 29 in mergeKLists (Solution.py)\\n    ret = Solution().mergeKLists(param_1)\\nLine 51 in _driver (Solution.py)\\n    _driver()\\nLine 62 in <module> (Solution.py)\\n```\\n\\n## Spoilers part of my not working solution\\n```\\nfor i in lists[1:]:\\n            temp = merge(lists[0] ,i)\\n            lists[0] = temp\\n        temp = lists[0]\\n        temp = temp.next\\n        print(len(lists),temp.val) #printed 3, 1\\n        return temp\\n```\\nSo there are a bunch of unnecessary variables, but I was trying to debug.  "
                    },
                    {
                        "username": "JaafarH",
                        "content": "Why does this code gives an Time limit exceeded please ? (Python)\n\n\n\ndef mergeKLists(self,lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        myList = lists[0]\n        if not lists:\n            return None\n        if len(lists) == 1:\n            return lists[0]\n        i = 1\n        for i in range(len(lists)):\n            myList = self.mergeTwoLists(myList,lists[i])\n        \n        return myList\n        \n\n\n    def mergeTwoLists(self,list1,list2):\n        myList = dummy = ListNode(0)\n        while list1 and list2:\n            if list1.val <= list2.val :\n                myList.next = list1\n                myList = myList.next\n                list1 = list1.next\n            else:\n                myList.next = list2\n                myList = myList.next\n                list2 = list2.next\n        if list1 :\n            myList.next = list1\n        else :\n            myList.next = list2\n        return dummy.next\n"
                    },
                    {
                        "username": "JaafarH",
                        "content": "Please does anyone understands why this code gives me a Time Limit Exceeded ?\n\n `def mergeKLists(self,lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        myList = lists[0]\n        if not lists:\n            return None\n        if len(lists) == 1:\n            return lists[0]\n        i = 1\n        for i in range(len(lists)):\n            myList = self.mergeTwoLists(myList,lists[i])\n        \n        return myList\n        \n\n\n    def mergeTwoLists(self,list1,list2):\n        myList = dummy = ListNode(0)\n        while list1 and list2:\n            if list1.val <= list2.val :\n                myList.next = list1\n                myList = myList.next\n                list1 = list1.next\n            else:\n                myList.next = list2\n                myList = myList.next\n                list2 = list2.next\n        if list1 :\n            myList.next = list1\n        else :\n            myList.next = list2\n        return dummy.next`"
                    },
                    {
                        "username": "grootSingh",
                        "content": "using priority Queue who\\'s Time Complexity is: O(N\\u2217logK) and Space Complexity is: O (K);\\nworks slower and take much more space in comparison to array + sort solution who\\'s \\nTime Complexity is: O(NK\\u2217logN) and Space Complexity is: O (NK);\\n\\nwhy is this happening? why theoretical explanation is not getting the result in practical question?\\n// i am using JavaScript to solve this problem?"
                    },
                    {
                        "username": "omdhyawarneniwar23",
                        "content": "Store all the values of linkedlist of lists in a empty vector,then sort that vector and create new linkedlist from the sorted values of vector."
                    },
                    {
                        "username": "Difoldery",
                        "content": "Maybe smb knows why it cant return zero element of array with length 8\n\n\nclass Solution(object):\n    def mergeKLists(self, lists):\n       \n        per = 10000\n        count = [0]*20010\n\n        for i in lists:\n            g = i\n            while(g != None):\n                count[(int)(g.val)+per]+=1\n                g = g.next\n\n        las = []\n        c = 0\n        for i in range(per*2):\n            if count[i] > 0:\n                for j in range(count[i]):\n                    las.append(ListNode(i-per))\n                    c+=1\n                    \n        for i in range(c):\n            if i > 0:\n                las[c-2-i].next = las[c-1-i]\n        \n        return las[0]\n\n"
                    }
                ]
            },
            {
                "id": 1795621,
                "content": [
                    {
                        "username": "agamsrivastava004",
                        "content": "C++ here \\nMy approach is to reuse the solution in the merge two sorted linked list problem and just put it in a for loop and go at it 2 at a time \\n\\nI get stuck on the test case - [[2],[],[-1]]\\nWhen I do the output individually it gives correct output --> \\n[[2],[]] ==> [2]\\n[[2],[-1]] ==> [-1,2]\\n\\nlike how is that even possible \\nmy code is-->\\n```\\nListNode* merge2Lists(ListNode* list1, ListNode* list2)\\n{\\n  if(list1 == NULL) return list2;\\n  if(list2 == NULL) return list1;\\n  ListNode* new_node;\\n \\n  if (list1->val < list2->val) {\\n    new_node = list1;\\n    list1 = list1->next;\\n  }\\n  else {\\n    new_node = list2;\\n    list2 = list2->next;\\n  }\\n   ListNode* head = new_node;\\n  while (list1 && list2) {\\n    if (list1->val < list2->val) {\\n      new_node->next = list1;\\n      list1 = list1->next;\\n    }\\n    else {\\n      new_node->next = list2;\\n      list2 = list2->next;\\n    }\\n    new_node = new_node->next;\\n  }\\n  if (!list1) new_node->next = list2;\\n  else new_node->next = list1;\\n  return head;\\n}\\n\\nListNode* mergeKLists(vector<ListNode*>& lists)\\n{\\n  ListNode* head;\\n  if(lists.size() == 0) return head;\\n  if(lists.size() == 1) return lists[0];\\n  for (int i = 0; i < lists.size() - 1; ++i) {\\n    head = merge2Lists(lists[i], lists[i+1]);\\n  }\\n  return head;\\n}\\n```"
                    },
                    {
                        "username": "mikael6767",
                        "content": "Could someone please say how to do this problem using ListNode. I don\\'t know. It\\'s just awful with ListNode. I am programming on Python3 and have no idea what is ListNode. This is very easy on Python3, but please help me with this ListNode!"
                    },
                    {
                        "username": "adherent____",
                        "content": "simple- use dummy list and make merge call with all the elements of vector"
                    },
                    {
                        "username": "hdrwilkinson",
                        "content": "PYTHON 3 HELP NEEDED. I can't understand why I'm getting an error.\n`\nclass Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        prehead = ListNode(-1)\n        pointer = prehead\n\n        t = True\n        while t == True:\n            print(t)\n            print(lists)\n            print(\"\")\n            values = {}\n\n            for i, l in enumerate(lists):\n                values[i] = l.val\n            idx = min(values, key=values.get)\n            pointer.next = ListNode(lists[idx].val)\n            pointer = pointer.next\n\n            if lists[idx].next == None:\n                lists.pop(idx)\n            else:\n                lists[idx] = lists[idx].next\n\n            if not lists:\n                t = False\n                print(t)\n                \n        return prehead.next\n`\n\nOn what is meant to be the final loop, it prints that t = False. But, then it starts another loop with t = True.\n"
                    },
                    {
                        "username": "Falselysium",
                        "content": "I\\'m getting this error when I\\'m using my lists[0] to hold my ans.\\nI\\'m basically merging 2 sorted list with lists[0] and lists[i] where i is all list from 1 to len(lists)\\n\\nlists[0] isn\\'t NULL I\\'ve checked with print statements. \\nI\\'m not sure if it\\'s a pointer thing. \\nand print(len(lists)) returns 3 <b>for the first test case </b>|\\n\\n### Error I\\'m getting\\n```IndexError: list index out of range\\n    temp = lists[0]\\nLine 29 in mergeKLists (Solution.py)\\n    ret = Solution().mergeKLists(param_1)\\nLine 51 in _driver (Solution.py)\\n    _driver()\\nLine 62 in <module> (Solution.py)\\n```\\n\\n## Spoilers part of my not working solution\\n```\\nfor i in lists[1:]:\\n            temp = merge(lists[0] ,i)\\n            lists[0] = temp\\n        temp = lists[0]\\n        temp = temp.next\\n        print(len(lists),temp.val) #printed 3, 1\\n        return temp\\n```\\nSo there are a bunch of unnecessary variables, but I was trying to debug.  "
                    },
                    {
                        "username": "JaafarH",
                        "content": "Why does this code gives an Time limit exceeded please ? (Python)\n\n\n\ndef mergeKLists(self,lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        myList = lists[0]\n        if not lists:\n            return None\n        if len(lists) == 1:\n            return lists[0]\n        i = 1\n        for i in range(len(lists)):\n            myList = self.mergeTwoLists(myList,lists[i])\n        \n        return myList\n        \n\n\n    def mergeTwoLists(self,list1,list2):\n        myList = dummy = ListNode(0)\n        while list1 and list2:\n            if list1.val <= list2.val :\n                myList.next = list1\n                myList = myList.next\n                list1 = list1.next\n            else:\n                myList.next = list2\n                myList = myList.next\n                list2 = list2.next\n        if list1 :\n            myList.next = list1\n        else :\n            myList.next = list2\n        return dummy.next\n"
                    },
                    {
                        "username": "JaafarH",
                        "content": "Please does anyone understands why this code gives me a Time Limit Exceeded ?\n\n `def mergeKLists(self,lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        myList = lists[0]\n        if not lists:\n            return None\n        if len(lists) == 1:\n            return lists[0]\n        i = 1\n        for i in range(len(lists)):\n            myList = self.mergeTwoLists(myList,lists[i])\n        \n        return myList\n        \n\n\n    def mergeTwoLists(self,list1,list2):\n        myList = dummy = ListNode(0)\n        while list1 and list2:\n            if list1.val <= list2.val :\n                myList.next = list1\n                myList = myList.next\n                list1 = list1.next\n            else:\n                myList.next = list2\n                myList = myList.next\n                list2 = list2.next\n        if list1 :\n            myList.next = list1\n        else :\n            myList.next = list2\n        return dummy.next`"
                    },
                    {
                        "username": "grootSingh",
                        "content": "using priority Queue who\\'s Time Complexity is: O(N\\u2217logK) and Space Complexity is: O (K);\\nworks slower and take much more space in comparison to array + sort solution who\\'s \\nTime Complexity is: O(NK\\u2217logN) and Space Complexity is: O (NK);\\n\\nwhy is this happening? why theoretical explanation is not getting the result in practical question?\\n// i am using JavaScript to solve this problem?"
                    },
                    {
                        "username": "omdhyawarneniwar23",
                        "content": "Store all the values of linkedlist of lists in a empty vector,then sort that vector and create new linkedlist from the sorted values of vector."
                    },
                    {
                        "username": "Difoldery",
                        "content": "Maybe smb knows why it cant return zero element of array with length 8\n\n\nclass Solution(object):\n    def mergeKLists(self, lists):\n       \n        per = 10000\n        count = [0]*20010\n\n        for i in lists:\n            g = i\n            while(g != None):\n                count[(int)(g.val)+per]+=1\n                g = g.next\n\n        las = []\n        c = 0\n        for i in range(per*2):\n            if count[i] > 0:\n                for j in range(count[i]):\n                    las.append(ListNode(i-per))\n                    c+=1\n                    \n        for i in range(c):\n            if i > 0:\n                las[c-2-i].next = las[c-1-i]\n        \n        return las[0]\n\n"
                    }
                ]
            },
            {
                "id": 1786798,
                "content": [
                    {
                        "username": "agamsrivastava004",
                        "content": "C++ here \\nMy approach is to reuse the solution in the merge two sorted linked list problem and just put it in a for loop and go at it 2 at a time \\n\\nI get stuck on the test case - [[2],[],[-1]]\\nWhen I do the output individually it gives correct output --> \\n[[2],[]] ==> [2]\\n[[2],[-1]] ==> [-1,2]\\n\\nlike how is that even possible \\nmy code is-->\\n```\\nListNode* merge2Lists(ListNode* list1, ListNode* list2)\\n{\\n  if(list1 == NULL) return list2;\\n  if(list2 == NULL) return list1;\\n  ListNode* new_node;\\n \\n  if (list1->val < list2->val) {\\n    new_node = list1;\\n    list1 = list1->next;\\n  }\\n  else {\\n    new_node = list2;\\n    list2 = list2->next;\\n  }\\n   ListNode* head = new_node;\\n  while (list1 && list2) {\\n    if (list1->val < list2->val) {\\n      new_node->next = list1;\\n      list1 = list1->next;\\n    }\\n    else {\\n      new_node->next = list2;\\n      list2 = list2->next;\\n    }\\n    new_node = new_node->next;\\n  }\\n  if (!list1) new_node->next = list2;\\n  else new_node->next = list1;\\n  return head;\\n}\\n\\nListNode* mergeKLists(vector<ListNode*>& lists)\\n{\\n  ListNode* head;\\n  if(lists.size() == 0) return head;\\n  if(lists.size() == 1) return lists[0];\\n  for (int i = 0; i < lists.size() - 1; ++i) {\\n    head = merge2Lists(lists[i], lists[i+1]);\\n  }\\n  return head;\\n}\\n```"
                    },
                    {
                        "username": "mikael6767",
                        "content": "Could someone please say how to do this problem using ListNode. I don\\'t know. It\\'s just awful with ListNode. I am programming on Python3 and have no idea what is ListNode. This is very easy on Python3, but please help me with this ListNode!"
                    },
                    {
                        "username": "adherent____",
                        "content": "simple- use dummy list and make merge call with all the elements of vector"
                    },
                    {
                        "username": "hdrwilkinson",
                        "content": "PYTHON 3 HELP NEEDED. I can't understand why I'm getting an error.\n`\nclass Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        prehead = ListNode(-1)\n        pointer = prehead\n\n        t = True\n        while t == True:\n            print(t)\n            print(lists)\n            print(\"\")\n            values = {}\n\n            for i, l in enumerate(lists):\n                values[i] = l.val\n            idx = min(values, key=values.get)\n            pointer.next = ListNode(lists[idx].val)\n            pointer = pointer.next\n\n            if lists[idx].next == None:\n                lists.pop(idx)\n            else:\n                lists[idx] = lists[idx].next\n\n            if not lists:\n                t = False\n                print(t)\n                \n        return prehead.next\n`\n\nOn what is meant to be the final loop, it prints that t = False. But, then it starts another loop with t = True.\n"
                    },
                    {
                        "username": "Falselysium",
                        "content": "I\\'m getting this error when I\\'m using my lists[0] to hold my ans.\\nI\\'m basically merging 2 sorted list with lists[0] and lists[i] where i is all list from 1 to len(lists)\\n\\nlists[0] isn\\'t NULL I\\'ve checked with print statements. \\nI\\'m not sure if it\\'s a pointer thing. \\nand print(len(lists)) returns 3 <b>for the first test case </b>|\\n\\n### Error I\\'m getting\\n```IndexError: list index out of range\\n    temp = lists[0]\\nLine 29 in mergeKLists (Solution.py)\\n    ret = Solution().mergeKLists(param_1)\\nLine 51 in _driver (Solution.py)\\n    _driver()\\nLine 62 in <module> (Solution.py)\\n```\\n\\n## Spoilers part of my not working solution\\n```\\nfor i in lists[1:]:\\n            temp = merge(lists[0] ,i)\\n            lists[0] = temp\\n        temp = lists[0]\\n        temp = temp.next\\n        print(len(lists),temp.val) #printed 3, 1\\n        return temp\\n```\\nSo there are a bunch of unnecessary variables, but I was trying to debug.  "
                    },
                    {
                        "username": "JaafarH",
                        "content": "Why does this code gives an Time limit exceeded please ? (Python)\n\n\n\ndef mergeKLists(self,lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        myList = lists[0]\n        if not lists:\n            return None\n        if len(lists) == 1:\n            return lists[0]\n        i = 1\n        for i in range(len(lists)):\n            myList = self.mergeTwoLists(myList,lists[i])\n        \n        return myList\n        \n\n\n    def mergeTwoLists(self,list1,list2):\n        myList = dummy = ListNode(0)\n        while list1 and list2:\n            if list1.val <= list2.val :\n                myList.next = list1\n                myList = myList.next\n                list1 = list1.next\n            else:\n                myList.next = list2\n                myList = myList.next\n                list2 = list2.next\n        if list1 :\n            myList.next = list1\n        else :\n            myList.next = list2\n        return dummy.next\n"
                    },
                    {
                        "username": "JaafarH",
                        "content": "Please does anyone understands why this code gives me a Time Limit Exceeded ?\n\n `def mergeKLists(self,lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        myList = lists[0]\n        if not lists:\n            return None\n        if len(lists) == 1:\n            return lists[0]\n        i = 1\n        for i in range(len(lists)):\n            myList = self.mergeTwoLists(myList,lists[i])\n        \n        return myList\n        \n\n\n    def mergeTwoLists(self,list1,list2):\n        myList = dummy = ListNode(0)\n        while list1 and list2:\n            if list1.val <= list2.val :\n                myList.next = list1\n                myList = myList.next\n                list1 = list1.next\n            else:\n                myList.next = list2\n                myList = myList.next\n                list2 = list2.next\n        if list1 :\n            myList.next = list1\n        else :\n            myList.next = list2\n        return dummy.next`"
                    },
                    {
                        "username": "grootSingh",
                        "content": "using priority Queue who\\'s Time Complexity is: O(N\\u2217logK) and Space Complexity is: O (K);\\nworks slower and take much more space in comparison to array + sort solution who\\'s \\nTime Complexity is: O(NK\\u2217logN) and Space Complexity is: O (NK);\\n\\nwhy is this happening? why theoretical explanation is not getting the result in practical question?\\n// i am using JavaScript to solve this problem?"
                    },
                    {
                        "username": "omdhyawarneniwar23",
                        "content": "Store all the values of linkedlist of lists in a empty vector,then sort that vector and create new linkedlist from the sorted values of vector."
                    },
                    {
                        "username": "Difoldery",
                        "content": "Maybe smb knows why it cant return zero element of array with length 8\n\n\nclass Solution(object):\n    def mergeKLists(self, lists):\n       \n        per = 10000\n        count = [0]*20010\n\n        for i in lists:\n            g = i\n            while(g != None):\n                count[(int)(g.val)+per]+=1\n                g = g.next\n\n        las = []\n        c = 0\n        for i in range(per*2):\n            if count[i] > 0:\n                for j in range(count[i]):\n                    las.append(ListNode(i-per))\n                    c+=1\n                    \n        for i in range(c):\n            if i > 0:\n                las[c-2-i].next = las[c-1-i]\n        \n        return las[0]\n\n"
                    }
                ]
            },
            {
                "id": 1779949,
                "content": [
                    {
                        "username": "agamsrivastava004",
                        "content": "C++ here \\nMy approach is to reuse the solution in the merge two sorted linked list problem and just put it in a for loop and go at it 2 at a time \\n\\nI get stuck on the test case - [[2],[],[-1]]\\nWhen I do the output individually it gives correct output --> \\n[[2],[]] ==> [2]\\n[[2],[-1]] ==> [-1,2]\\n\\nlike how is that even possible \\nmy code is-->\\n```\\nListNode* merge2Lists(ListNode* list1, ListNode* list2)\\n{\\n  if(list1 == NULL) return list2;\\n  if(list2 == NULL) return list1;\\n  ListNode* new_node;\\n \\n  if (list1->val < list2->val) {\\n    new_node = list1;\\n    list1 = list1->next;\\n  }\\n  else {\\n    new_node = list2;\\n    list2 = list2->next;\\n  }\\n   ListNode* head = new_node;\\n  while (list1 && list2) {\\n    if (list1->val < list2->val) {\\n      new_node->next = list1;\\n      list1 = list1->next;\\n    }\\n    else {\\n      new_node->next = list2;\\n      list2 = list2->next;\\n    }\\n    new_node = new_node->next;\\n  }\\n  if (!list1) new_node->next = list2;\\n  else new_node->next = list1;\\n  return head;\\n}\\n\\nListNode* mergeKLists(vector<ListNode*>& lists)\\n{\\n  ListNode* head;\\n  if(lists.size() == 0) return head;\\n  if(lists.size() == 1) return lists[0];\\n  for (int i = 0; i < lists.size() - 1; ++i) {\\n    head = merge2Lists(lists[i], lists[i+1]);\\n  }\\n  return head;\\n}\\n```"
                    },
                    {
                        "username": "mikael6767",
                        "content": "Could someone please say how to do this problem using ListNode. I don\\'t know. It\\'s just awful with ListNode. I am programming on Python3 and have no idea what is ListNode. This is very easy on Python3, but please help me with this ListNode!"
                    },
                    {
                        "username": "adherent____",
                        "content": "simple- use dummy list and make merge call with all the elements of vector"
                    },
                    {
                        "username": "hdrwilkinson",
                        "content": "PYTHON 3 HELP NEEDED. I can't understand why I'm getting an error.\n`\nclass Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        prehead = ListNode(-1)\n        pointer = prehead\n\n        t = True\n        while t == True:\n            print(t)\n            print(lists)\n            print(\"\")\n            values = {}\n\n            for i, l in enumerate(lists):\n                values[i] = l.val\n            idx = min(values, key=values.get)\n            pointer.next = ListNode(lists[idx].val)\n            pointer = pointer.next\n\n            if lists[idx].next == None:\n                lists.pop(idx)\n            else:\n                lists[idx] = lists[idx].next\n\n            if not lists:\n                t = False\n                print(t)\n                \n        return prehead.next\n`\n\nOn what is meant to be the final loop, it prints that t = False. But, then it starts another loop with t = True.\n"
                    },
                    {
                        "username": "Falselysium",
                        "content": "I\\'m getting this error when I\\'m using my lists[0] to hold my ans.\\nI\\'m basically merging 2 sorted list with lists[0] and lists[i] where i is all list from 1 to len(lists)\\n\\nlists[0] isn\\'t NULL I\\'ve checked with print statements. \\nI\\'m not sure if it\\'s a pointer thing. \\nand print(len(lists)) returns 3 <b>for the first test case </b>|\\n\\n### Error I\\'m getting\\n```IndexError: list index out of range\\n    temp = lists[0]\\nLine 29 in mergeKLists (Solution.py)\\n    ret = Solution().mergeKLists(param_1)\\nLine 51 in _driver (Solution.py)\\n    _driver()\\nLine 62 in <module> (Solution.py)\\n```\\n\\n## Spoilers part of my not working solution\\n```\\nfor i in lists[1:]:\\n            temp = merge(lists[0] ,i)\\n            lists[0] = temp\\n        temp = lists[0]\\n        temp = temp.next\\n        print(len(lists),temp.val) #printed 3, 1\\n        return temp\\n```\\nSo there are a bunch of unnecessary variables, but I was trying to debug.  "
                    },
                    {
                        "username": "JaafarH",
                        "content": "Why does this code gives an Time limit exceeded please ? (Python)\n\n\n\ndef mergeKLists(self,lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        myList = lists[0]\n        if not lists:\n            return None\n        if len(lists) == 1:\n            return lists[0]\n        i = 1\n        for i in range(len(lists)):\n            myList = self.mergeTwoLists(myList,lists[i])\n        \n        return myList\n        \n\n\n    def mergeTwoLists(self,list1,list2):\n        myList = dummy = ListNode(0)\n        while list1 and list2:\n            if list1.val <= list2.val :\n                myList.next = list1\n                myList = myList.next\n                list1 = list1.next\n            else:\n                myList.next = list2\n                myList = myList.next\n                list2 = list2.next\n        if list1 :\n            myList.next = list1\n        else :\n            myList.next = list2\n        return dummy.next\n"
                    },
                    {
                        "username": "JaafarH",
                        "content": "Please does anyone understands why this code gives me a Time Limit Exceeded ?\n\n `def mergeKLists(self,lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        myList = lists[0]\n        if not lists:\n            return None\n        if len(lists) == 1:\n            return lists[0]\n        i = 1\n        for i in range(len(lists)):\n            myList = self.mergeTwoLists(myList,lists[i])\n        \n        return myList\n        \n\n\n    def mergeTwoLists(self,list1,list2):\n        myList = dummy = ListNode(0)\n        while list1 and list2:\n            if list1.val <= list2.val :\n                myList.next = list1\n                myList = myList.next\n                list1 = list1.next\n            else:\n                myList.next = list2\n                myList = myList.next\n                list2 = list2.next\n        if list1 :\n            myList.next = list1\n        else :\n            myList.next = list2\n        return dummy.next`"
                    },
                    {
                        "username": "grootSingh",
                        "content": "using priority Queue who\\'s Time Complexity is: O(N\\u2217logK) and Space Complexity is: O (K);\\nworks slower and take much more space in comparison to array + sort solution who\\'s \\nTime Complexity is: O(NK\\u2217logN) and Space Complexity is: O (NK);\\n\\nwhy is this happening? why theoretical explanation is not getting the result in practical question?\\n// i am using JavaScript to solve this problem?"
                    },
                    {
                        "username": "omdhyawarneniwar23",
                        "content": "Store all the values of linkedlist of lists in a empty vector,then sort that vector and create new linkedlist from the sorted values of vector."
                    },
                    {
                        "username": "Difoldery",
                        "content": "Maybe smb knows why it cant return zero element of array with length 8\n\n\nclass Solution(object):\n    def mergeKLists(self, lists):\n       \n        per = 10000\n        count = [0]*20010\n\n        for i in lists:\n            g = i\n            while(g != None):\n                count[(int)(g.val)+per]+=1\n                g = g.next\n\n        las = []\n        c = 0\n        for i in range(per*2):\n            if count[i] > 0:\n                for j in range(count[i]):\n                    las.append(ListNode(i-per))\n                    c+=1\n                    \n        for i in range(c):\n            if i > 0:\n                las[c-2-i].next = las[c-1-i]\n        \n        return las[0]\n\n"
                    }
                ]
            },
            {
                "id": 1779947,
                "content": [
                    {
                        "username": "agamsrivastava004",
                        "content": "C++ here \\nMy approach is to reuse the solution in the merge two sorted linked list problem and just put it in a for loop and go at it 2 at a time \\n\\nI get stuck on the test case - [[2],[],[-1]]\\nWhen I do the output individually it gives correct output --> \\n[[2],[]] ==> [2]\\n[[2],[-1]] ==> [-1,2]\\n\\nlike how is that even possible \\nmy code is-->\\n```\\nListNode* merge2Lists(ListNode* list1, ListNode* list2)\\n{\\n  if(list1 == NULL) return list2;\\n  if(list2 == NULL) return list1;\\n  ListNode* new_node;\\n \\n  if (list1->val < list2->val) {\\n    new_node = list1;\\n    list1 = list1->next;\\n  }\\n  else {\\n    new_node = list2;\\n    list2 = list2->next;\\n  }\\n   ListNode* head = new_node;\\n  while (list1 && list2) {\\n    if (list1->val < list2->val) {\\n      new_node->next = list1;\\n      list1 = list1->next;\\n    }\\n    else {\\n      new_node->next = list2;\\n      list2 = list2->next;\\n    }\\n    new_node = new_node->next;\\n  }\\n  if (!list1) new_node->next = list2;\\n  else new_node->next = list1;\\n  return head;\\n}\\n\\nListNode* mergeKLists(vector<ListNode*>& lists)\\n{\\n  ListNode* head;\\n  if(lists.size() == 0) return head;\\n  if(lists.size() == 1) return lists[0];\\n  for (int i = 0; i < lists.size() - 1; ++i) {\\n    head = merge2Lists(lists[i], lists[i+1]);\\n  }\\n  return head;\\n}\\n```"
                    },
                    {
                        "username": "mikael6767",
                        "content": "Could someone please say how to do this problem using ListNode. I don\\'t know. It\\'s just awful with ListNode. I am programming on Python3 and have no idea what is ListNode. This is very easy on Python3, but please help me with this ListNode!"
                    },
                    {
                        "username": "adherent____",
                        "content": "simple- use dummy list and make merge call with all the elements of vector"
                    },
                    {
                        "username": "hdrwilkinson",
                        "content": "PYTHON 3 HELP NEEDED. I can't understand why I'm getting an error.\n`\nclass Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        prehead = ListNode(-1)\n        pointer = prehead\n\n        t = True\n        while t == True:\n            print(t)\n            print(lists)\n            print(\"\")\n            values = {}\n\n            for i, l in enumerate(lists):\n                values[i] = l.val\n            idx = min(values, key=values.get)\n            pointer.next = ListNode(lists[idx].val)\n            pointer = pointer.next\n\n            if lists[idx].next == None:\n                lists.pop(idx)\n            else:\n                lists[idx] = lists[idx].next\n\n            if not lists:\n                t = False\n                print(t)\n                \n        return prehead.next\n`\n\nOn what is meant to be the final loop, it prints that t = False. But, then it starts another loop with t = True.\n"
                    },
                    {
                        "username": "Falselysium",
                        "content": "I\\'m getting this error when I\\'m using my lists[0] to hold my ans.\\nI\\'m basically merging 2 sorted list with lists[0] and lists[i] where i is all list from 1 to len(lists)\\n\\nlists[0] isn\\'t NULL I\\'ve checked with print statements. \\nI\\'m not sure if it\\'s a pointer thing. \\nand print(len(lists)) returns 3 <b>for the first test case </b>|\\n\\n### Error I\\'m getting\\n```IndexError: list index out of range\\n    temp = lists[0]\\nLine 29 in mergeKLists (Solution.py)\\n    ret = Solution().mergeKLists(param_1)\\nLine 51 in _driver (Solution.py)\\n    _driver()\\nLine 62 in <module> (Solution.py)\\n```\\n\\n## Spoilers part of my not working solution\\n```\\nfor i in lists[1:]:\\n            temp = merge(lists[0] ,i)\\n            lists[0] = temp\\n        temp = lists[0]\\n        temp = temp.next\\n        print(len(lists),temp.val) #printed 3, 1\\n        return temp\\n```\\nSo there are a bunch of unnecessary variables, but I was trying to debug.  "
                    },
                    {
                        "username": "JaafarH",
                        "content": "Why does this code gives an Time limit exceeded please ? (Python)\n\n\n\ndef mergeKLists(self,lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        myList = lists[0]\n        if not lists:\n            return None\n        if len(lists) == 1:\n            return lists[0]\n        i = 1\n        for i in range(len(lists)):\n            myList = self.mergeTwoLists(myList,lists[i])\n        \n        return myList\n        \n\n\n    def mergeTwoLists(self,list1,list2):\n        myList = dummy = ListNode(0)\n        while list1 and list2:\n            if list1.val <= list2.val :\n                myList.next = list1\n                myList = myList.next\n                list1 = list1.next\n            else:\n                myList.next = list2\n                myList = myList.next\n                list2 = list2.next\n        if list1 :\n            myList.next = list1\n        else :\n            myList.next = list2\n        return dummy.next\n"
                    },
                    {
                        "username": "JaafarH",
                        "content": "Please does anyone understands why this code gives me a Time Limit Exceeded ?\n\n `def mergeKLists(self,lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        myList = lists[0]\n        if not lists:\n            return None\n        if len(lists) == 1:\n            return lists[0]\n        i = 1\n        for i in range(len(lists)):\n            myList = self.mergeTwoLists(myList,lists[i])\n        \n        return myList\n        \n\n\n    def mergeTwoLists(self,list1,list2):\n        myList = dummy = ListNode(0)\n        while list1 and list2:\n            if list1.val <= list2.val :\n                myList.next = list1\n                myList = myList.next\n                list1 = list1.next\n            else:\n                myList.next = list2\n                myList = myList.next\n                list2 = list2.next\n        if list1 :\n            myList.next = list1\n        else :\n            myList.next = list2\n        return dummy.next`"
                    },
                    {
                        "username": "grootSingh",
                        "content": "using priority Queue who\\'s Time Complexity is: O(N\\u2217logK) and Space Complexity is: O (K);\\nworks slower and take much more space in comparison to array + sort solution who\\'s \\nTime Complexity is: O(NK\\u2217logN) and Space Complexity is: O (NK);\\n\\nwhy is this happening? why theoretical explanation is not getting the result in practical question?\\n// i am using JavaScript to solve this problem?"
                    },
                    {
                        "username": "omdhyawarneniwar23",
                        "content": "Store all the values of linkedlist of lists in a empty vector,then sort that vector and create new linkedlist from the sorted values of vector."
                    },
                    {
                        "username": "Difoldery",
                        "content": "Maybe smb knows why it cant return zero element of array with length 8\n\n\nclass Solution(object):\n    def mergeKLists(self, lists):\n       \n        per = 10000\n        count = [0]*20010\n\n        for i in lists:\n            g = i\n            while(g != None):\n                count[(int)(g.val)+per]+=1\n                g = g.next\n\n        las = []\n        c = 0\n        for i in range(per*2):\n            if count[i] > 0:\n                for j in range(count[i]):\n                    las.append(ListNode(i-per))\n                    c+=1\n                    \n        for i in range(c):\n            if i > 0:\n                las[c-2-i].next = las[c-1-i]\n        \n        return las[0]\n\n"
                    }
                ]
            },
            {
                "id": 1779154,
                "content": [
                    {
                        "username": "agamsrivastava004",
                        "content": "C++ here \\nMy approach is to reuse the solution in the merge two sorted linked list problem and just put it in a for loop and go at it 2 at a time \\n\\nI get stuck on the test case - [[2],[],[-1]]\\nWhen I do the output individually it gives correct output --> \\n[[2],[]] ==> [2]\\n[[2],[-1]] ==> [-1,2]\\n\\nlike how is that even possible \\nmy code is-->\\n```\\nListNode* merge2Lists(ListNode* list1, ListNode* list2)\\n{\\n  if(list1 == NULL) return list2;\\n  if(list2 == NULL) return list1;\\n  ListNode* new_node;\\n \\n  if (list1->val < list2->val) {\\n    new_node = list1;\\n    list1 = list1->next;\\n  }\\n  else {\\n    new_node = list2;\\n    list2 = list2->next;\\n  }\\n   ListNode* head = new_node;\\n  while (list1 && list2) {\\n    if (list1->val < list2->val) {\\n      new_node->next = list1;\\n      list1 = list1->next;\\n    }\\n    else {\\n      new_node->next = list2;\\n      list2 = list2->next;\\n    }\\n    new_node = new_node->next;\\n  }\\n  if (!list1) new_node->next = list2;\\n  else new_node->next = list1;\\n  return head;\\n}\\n\\nListNode* mergeKLists(vector<ListNode*>& lists)\\n{\\n  ListNode* head;\\n  if(lists.size() == 0) return head;\\n  if(lists.size() == 1) return lists[0];\\n  for (int i = 0; i < lists.size() - 1; ++i) {\\n    head = merge2Lists(lists[i], lists[i+1]);\\n  }\\n  return head;\\n}\\n```"
                    },
                    {
                        "username": "mikael6767",
                        "content": "Could someone please say how to do this problem using ListNode. I don\\'t know. It\\'s just awful with ListNode. I am programming on Python3 and have no idea what is ListNode. This is very easy on Python3, but please help me with this ListNode!"
                    },
                    {
                        "username": "adherent____",
                        "content": "simple- use dummy list and make merge call with all the elements of vector"
                    },
                    {
                        "username": "hdrwilkinson",
                        "content": "PYTHON 3 HELP NEEDED. I can't understand why I'm getting an error.\n`\nclass Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        prehead = ListNode(-1)\n        pointer = prehead\n\n        t = True\n        while t == True:\n            print(t)\n            print(lists)\n            print(\"\")\n            values = {}\n\n            for i, l in enumerate(lists):\n                values[i] = l.val\n            idx = min(values, key=values.get)\n            pointer.next = ListNode(lists[idx].val)\n            pointer = pointer.next\n\n            if lists[idx].next == None:\n                lists.pop(idx)\n            else:\n                lists[idx] = lists[idx].next\n\n            if not lists:\n                t = False\n                print(t)\n                \n        return prehead.next\n`\n\nOn what is meant to be the final loop, it prints that t = False. But, then it starts another loop with t = True.\n"
                    },
                    {
                        "username": "Falselysium",
                        "content": "I\\'m getting this error when I\\'m using my lists[0] to hold my ans.\\nI\\'m basically merging 2 sorted list with lists[0] and lists[i] where i is all list from 1 to len(lists)\\n\\nlists[0] isn\\'t NULL I\\'ve checked with print statements. \\nI\\'m not sure if it\\'s a pointer thing. \\nand print(len(lists)) returns 3 <b>for the first test case </b>|\\n\\n### Error I\\'m getting\\n```IndexError: list index out of range\\n    temp = lists[0]\\nLine 29 in mergeKLists (Solution.py)\\n    ret = Solution().mergeKLists(param_1)\\nLine 51 in _driver (Solution.py)\\n    _driver()\\nLine 62 in <module> (Solution.py)\\n```\\n\\n## Spoilers part of my not working solution\\n```\\nfor i in lists[1:]:\\n            temp = merge(lists[0] ,i)\\n            lists[0] = temp\\n        temp = lists[0]\\n        temp = temp.next\\n        print(len(lists),temp.val) #printed 3, 1\\n        return temp\\n```\\nSo there are a bunch of unnecessary variables, but I was trying to debug.  "
                    },
                    {
                        "username": "JaafarH",
                        "content": "Why does this code gives an Time limit exceeded please ? (Python)\n\n\n\ndef mergeKLists(self,lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        myList = lists[0]\n        if not lists:\n            return None\n        if len(lists) == 1:\n            return lists[0]\n        i = 1\n        for i in range(len(lists)):\n            myList = self.mergeTwoLists(myList,lists[i])\n        \n        return myList\n        \n\n\n    def mergeTwoLists(self,list1,list2):\n        myList = dummy = ListNode(0)\n        while list1 and list2:\n            if list1.val <= list2.val :\n                myList.next = list1\n                myList = myList.next\n                list1 = list1.next\n            else:\n                myList.next = list2\n                myList = myList.next\n                list2 = list2.next\n        if list1 :\n            myList.next = list1\n        else :\n            myList.next = list2\n        return dummy.next\n"
                    },
                    {
                        "username": "JaafarH",
                        "content": "Please does anyone understands why this code gives me a Time Limit Exceeded ?\n\n `def mergeKLists(self,lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        myList = lists[0]\n        if not lists:\n            return None\n        if len(lists) == 1:\n            return lists[0]\n        i = 1\n        for i in range(len(lists)):\n            myList = self.mergeTwoLists(myList,lists[i])\n        \n        return myList\n        \n\n\n    def mergeTwoLists(self,list1,list2):\n        myList = dummy = ListNode(0)\n        while list1 and list2:\n            if list1.val <= list2.val :\n                myList.next = list1\n                myList = myList.next\n                list1 = list1.next\n            else:\n                myList.next = list2\n                myList = myList.next\n                list2 = list2.next\n        if list1 :\n            myList.next = list1\n        else :\n            myList.next = list2\n        return dummy.next`"
                    },
                    {
                        "username": "grootSingh",
                        "content": "using priority Queue who\\'s Time Complexity is: O(N\\u2217logK) and Space Complexity is: O (K);\\nworks slower and take much more space in comparison to array + sort solution who\\'s \\nTime Complexity is: O(NK\\u2217logN) and Space Complexity is: O (NK);\\n\\nwhy is this happening? why theoretical explanation is not getting the result in practical question?\\n// i am using JavaScript to solve this problem?"
                    },
                    {
                        "username": "omdhyawarneniwar23",
                        "content": "Store all the values of linkedlist of lists in a empty vector,then sort that vector and create new linkedlist from the sorted values of vector."
                    },
                    {
                        "username": "Difoldery",
                        "content": "Maybe smb knows why it cant return zero element of array with length 8\n\n\nclass Solution(object):\n    def mergeKLists(self, lists):\n       \n        per = 10000\n        count = [0]*20010\n\n        for i in lists:\n            g = i\n            while(g != None):\n                count[(int)(g.val)+per]+=1\n                g = g.next\n\n        las = []\n        c = 0\n        for i in range(per*2):\n            if count[i] > 0:\n                for j in range(count[i]):\n                    las.append(ListNode(i-per))\n                    c+=1\n                    \n        for i in range(c):\n            if i > 0:\n                las[c-2-i].next = las[c-1-i]\n        \n        return las[0]\n\n"
                    }
                ]
            },
            {
                "id": 1778851,
                "content": [
                    {
                        "username": "agamsrivastava004",
                        "content": "C++ here \\nMy approach is to reuse the solution in the merge two sorted linked list problem and just put it in a for loop and go at it 2 at a time \\n\\nI get stuck on the test case - [[2],[],[-1]]\\nWhen I do the output individually it gives correct output --> \\n[[2],[]] ==> [2]\\n[[2],[-1]] ==> [-1,2]\\n\\nlike how is that even possible \\nmy code is-->\\n```\\nListNode* merge2Lists(ListNode* list1, ListNode* list2)\\n{\\n  if(list1 == NULL) return list2;\\n  if(list2 == NULL) return list1;\\n  ListNode* new_node;\\n \\n  if (list1->val < list2->val) {\\n    new_node = list1;\\n    list1 = list1->next;\\n  }\\n  else {\\n    new_node = list2;\\n    list2 = list2->next;\\n  }\\n   ListNode* head = new_node;\\n  while (list1 && list2) {\\n    if (list1->val < list2->val) {\\n      new_node->next = list1;\\n      list1 = list1->next;\\n    }\\n    else {\\n      new_node->next = list2;\\n      list2 = list2->next;\\n    }\\n    new_node = new_node->next;\\n  }\\n  if (!list1) new_node->next = list2;\\n  else new_node->next = list1;\\n  return head;\\n}\\n\\nListNode* mergeKLists(vector<ListNode*>& lists)\\n{\\n  ListNode* head;\\n  if(lists.size() == 0) return head;\\n  if(lists.size() == 1) return lists[0];\\n  for (int i = 0; i < lists.size() - 1; ++i) {\\n    head = merge2Lists(lists[i], lists[i+1]);\\n  }\\n  return head;\\n}\\n```"
                    },
                    {
                        "username": "mikael6767",
                        "content": "Could someone please say how to do this problem using ListNode. I don\\'t know. It\\'s just awful with ListNode. I am programming on Python3 and have no idea what is ListNode. This is very easy on Python3, but please help me with this ListNode!"
                    },
                    {
                        "username": "adherent____",
                        "content": "simple- use dummy list and make merge call with all the elements of vector"
                    },
                    {
                        "username": "hdrwilkinson",
                        "content": "PYTHON 3 HELP NEEDED. I can't understand why I'm getting an error.\n`\nclass Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        prehead = ListNode(-1)\n        pointer = prehead\n\n        t = True\n        while t == True:\n            print(t)\n            print(lists)\n            print(\"\")\n            values = {}\n\n            for i, l in enumerate(lists):\n                values[i] = l.val\n            idx = min(values, key=values.get)\n            pointer.next = ListNode(lists[idx].val)\n            pointer = pointer.next\n\n            if lists[idx].next == None:\n                lists.pop(idx)\n            else:\n                lists[idx] = lists[idx].next\n\n            if not lists:\n                t = False\n                print(t)\n                \n        return prehead.next\n`\n\nOn what is meant to be the final loop, it prints that t = False. But, then it starts another loop with t = True.\n"
                    },
                    {
                        "username": "Falselysium",
                        "content": "I\\'m getting this error when I\\'m using my lists[0] to hold my ans.\\nI\\'m basically merging 2 sorted list with lists[0] and lists[i] where i is all list from 1 to len(lists)\\n\\nlists[0] isn\\'t NULL I\\'ve checked with print statements. \\nI\\'m not sure if it\\'s a pointer thing. \\nand print(len(lists)) returns 3 <b>for the first test case </b>|\\n\\n### Error I\\'m getting\\n```IndexError: list index out of range\\n    temp = lists[0]\\nLine 29 in mergeKLists (Solution.py)\\n    ret = Solution().mergeKLists(param_1)\\nLine 51 in _driver (Solution.py)\\n    _driver()\\nLine 62 in <module> (Solution.py)\\n```\\n\\n## Spoilers part of my not working solution\\n```\\nfor i in lists[1:]:\\n            temp = merge(lists[0] ,i)\\n            lists[0] = temp\\n        temp = lists[0]\\n        temp = temp.next\\n        print(len(lists),temp.val) #printed 3, 1\\n        return temp\\n```\\nSo there are a bunch of unnecessary variables, but I was trying to debug.  "
                    },
                    {
                        "username": "JaafarH",
                        "content": "Why does this code gives an Time limit exceeded please ? (Python)\n\n\n\ndef mergeKLists(self,lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        myList = lists[0]\n        if not lists:\n            return None\n        if len(lists) == 1:\n            return lists[0]\n        i = 1\n        for i in range(len(lists)):\n            myList = self.mergeTwoLists(myList,lists[i])\n        \n        return myList\n        \n\n\n    def mergeTwoLists(self,list1,list2):\n        myList = dummy = ListNode(0)\n        while list1 and list2:\n            if list1.val <= list2.val :\n                myList.next = list1\n                myList = myList.next\n                list1 = list1.next\n            else:\n                myList.next = list2\n                myList = myList.next\n                list2 = list2.next\n        if list1 :\n            myList.next = list1\n        else :\n            myList.next = list2\n        return dummy.next\n"
                    },
                    {
                        "username": "JaafarH",
                        "content": "Please does anyone understands why this code gives me a Time Limit Exceeded ?\n\n `def mergeKLists(self,lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        myList = lists[0]\n        if not lists:\n            return None\n        if len(lists) == 1:\n            return lists[0]\n        i = 1\n        for i in range(len(lists)):\n            myList = self.mergeTwoLists(myList,lists[i])\n        \n        return myList\n        \n\n\n    def mergeTwoLists(self,list1,list2):\n        myList = dummy = ListNode(0)\n        while list1 and list2:\n            if list1.val <= list2.val :\n                myList.next = list1\n                myList = myList.next\n                list1 = list1.next\n            else:\n                myList.next = list2\n                myList = myList.next\n                list2 = list2.next\n        if list1 :\n            myList.next = list1\n        else :\n            myList.next = list2\n        return dummy.next`"
                    },
                    {
                        "username": "grootSingh",
                        "content": "using priority Queue who\\'s Time Complexity is: O(N\\u2217logK) and Space Complexity is: O (K);\\nworks slower and take much more space in comparison to array + sort solution who\\'s \\nTime Complexity is: O(NK\\u2217logN) and Space Complexity is: O (NK);\\n\\nwhy is this happening? why theoretical explanation is not getting the result in practical question?\\n// i am using JavaScript to solve this problem?"
                    },
                    {
                        "username": "omdhyawarneniwar23",
                        "content": "Store all the values of linkedlist of lists in a empty vector,then sort that vector and create new linkedlist from the sorted values of vector."
                    },
                    {
                        "username": "Difoldery",
                        "content": "Maybe smb knows why it cant return zero element of array with length 8\n\n\nclass Solution(object):\n    def mergeKLists(self, lists):\n       \n        per = 10000\n        count = [0]*20010\n\n        for i in lists:\n            g = i\n            while(g != None):\n                count[(int)(g.val)+per]+=1\n                g = g.next\n\n        las = []\n        c = 0\n        for i in range(per*2):\n            if count[i] > 0:\n                for j in range(count[i]):\n                    las.append(ListNode(i-per))\n                    c+=1\n                    \n        for i in range(c):\n            if i > 0:\n                las[c-2-i].next = las[c-1-i]\n        \n        return las[0]\n\n"
                    }
                ]
            },
            {
                "id": 1777993,
                "content": [
                    {
                        "username": "agamsrivastava004",
                        "content": "C++ here \\nMy approach is to reuse the solution in the merge two sorted linked list problem and just put it in a for loop and go at it 2 at a time \\n\\nI get stuck on the test case - [[2],[],[-1]]\\nWhen I do the output individually it gives correct output --> \\n[[2],[]] ==> [2]\\n[[2],[-1]] ==> [-1,2]\\n\\nlike how is that even possible \\nmy code is-->\\n```\\nListNode* merge2Lists(ListNode* list1, ListNode* list2)\\n{\\n  if(list1 == NULL) return list2;\\n  if(list2 == NULL) return list1;\\n  ListNode* new_node;\\n \\n  if (list1->val < list2->val) {\\n    new_node = list1;\\n    list1 = list1->next;\\n  }\\n  else {\\n    new_node = list2;\\n    list2 = list2->next;\\n  }\\n   ListNode* head = new_node;\\n  while (list1 && list2) {\\n    if (list1->val < list2->val) {\\n      new_node->next = list1;\\n      list1 = list1->next;\\n    }\\n    else {\\n      new_node->next = list2;\\n      list2 = list2->next;\\n    }\\n    new_node = new_node->next;\\n  }\\n  if (!list1) new_node->next = list2;\\n  else new_node->next = list1;\\n  return head;\\n}\\n\\nListNode* mergeKLists(vector<ListNode*>& lists)\\n{\\n  ListNode* head;\\n  if(lists.size() == 0) return head;\\n  if(lists.size() == 1) return lists[0];\\n  for (int i = 0; i < lists.size() - 1; ++i) {\\n    head = merge2Lists(lists[i], lists[i+1]);\\n  }\\n  return head;\\n}\\n```"
                    },
                    {
                        "username": "mikael6767",
                        "content": "Could someone please say how to do this problem using ListNode. I don\\'t know. It\\'s just awful with ListNode. I am programming on Python3 and have no idea what is ListNode. This is very easy on Python3, but please help me with this ListNode!"
                    },
                    {
                        "username": "adherent____",
                        "content": "simple- use dummy list and make merge call with all the elements of vector"
                    },
                    {
                        "username": "hdrwilkinson",
                        "content": "PYTHON 3 HELP NEEDED. I can't understand why I'm getting an error.\n`\nclass Solution:\n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        prehead = ListNode(-1)\n        pointer = prehead\n\n        t = True\n        while t == True:\n            print(t)\n            print(lists)\n            print(\"\")\n            values = {}\n\n            for i, l in enumerate(lists):\n                values[i] = l.val\n            idx = min(values, key=values.get)\n            pointer.next = ListNode(lists[idx].val)\n            pointer = pointer.next\n\n            if lists[idx].next == None:\n                lists.pop(idx)\n            else:\n                lists[idx] = lists[idx].next\n\n            if not lists:\n                t = False\n                print(t)\n                \n        return prehead.next\n`\n\nOn what is meant to be the final loop, it prints that t = False. But, then it starts another loop with t = True.\n"
                    },
                    {
                        "username": "Falselysium",
                        "content": "I\\'m getting this error when I\\'m using my lists[0] to hold my ans.\\nI\\'m basically merging 2 sorted list with lists[0] and lists[i] where i is all list from 1 to len(lists)\\n\\nlists[0] isn\\'t NULL I\\'ve checked with print statements. \\nI\\'m not sure if it\\'s a pointer thing. \\nand print(len(lists)) returns 3 <b>for the first test case </b>|\\n\\n### Error I\\'m getting\\n```IndexError: list index out of range\\n    temp = lists[0]\\nLine 29 in mergeKLists (Solution.py)\\n    ret = Solution().mergeKLists(param_1)\\nLine 51 in _driver (Solution.py)\\n    _driver()\\nLine 62 in <module> (Solution.py)\\n```\\n\\n## Spoilers part of my not working solution\\n```\\nfor i in lists[1:]:\\n            temp = merge(lists[0] ,i)\\n            lists[0] = temp\\n        temp = lists[0]\\n        temp = temp.next\\n        print(len(lists),temp.val) #printed 3, 1\\n        return temp\\n```\\nSo there are a bunch of unnecessary variables, but I was trying to debug.  "
                    },
                    {
                        "username": "JaafarH",
                        "content": "Why does this code gives an Time limit exceeded please ? (Python)\n\n\n\ndef mergeKLists(self,lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        myList = lists[0]\n        if not lists:\n            return None\n        if len(lists) == 1:\n            return lists[0]\n        i = 1\n        for i in range(len(lists)):\n            myList = self.mergeTwoLists(myList,lists[i])\n        \n        return myList\n        \n\n\n    def mergeTwoLists(self,list1,list2):\n        myList = dummy = ListNode(0)\n        while list1 and list2:\n            if list1.val <= list2.val :\n                myList.next = list1\n                myList = myList.next\n                list1 = list1.next\n            else:\n                myList.next = list2\n                myList = myList.next\n                list2 = list2.next\n        if list1 :\n            myList.next = list1\n        else :\n            myList.next = list2\n        return dummy.next\n"
                    },
                    {
                        "username": "JaafarH",
                        "content": "Please does anyone understands why this code gives me a Time Limit Exceeded ?\n\n `def mergeKLists(self,lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        myList = lists[0]\n        if not lists:\n            return None\n        if len(lists) == 1:\n            return lists[0]\n        i = 1\n        for i in range(len(lists)):\n            myList = self.mergeTwoLists(myList,lists[i])\n        \n        return myList\n        \n\n\n    def mergeTwoLists(self,list1,list2):\n        myList = dummy = ListNode(0)\n        while list1 and list2:\n            if list1.val <= list2.val :\n                myList.next = list1\n                myList = myList.next\n                list1 = list1.next\n            else:\n                myList.next = list2\n                myList = myList.next\n                list2 = list2.next\n        if list1 :\n            myList.next = list1\n        else :\n            myList.next = list2\n        return dummy.next`"
                    },
                    {
                        "username": "grootSingh",
                        "content": "using priority Queue who\\'s Time Complexity is: O(N\\u2217logK) and Space Complexity is: O (K);\\nworks slower and take much more space in comparison to array + sort solution who\\'s \\nTime Complexity is: O(NK\\u2217logN) and Space Complexity is: O (NK);\\n\\nwhy is this happening? why theoretical explanation is not getting the result in practical question?\\n// i am using JavaScript to solve this problem?"
                    },
                    {
                        "username": "omdhyawarneniwar23",
                        "content": "Store all the values of linkedlist of lists in a empty vector,then sort that vector and create new linkedlist from the sorted values of vector."
                    },
                    {
                        "username": "Difoldery",
                        "content": "Maybe smb knows why it cant return zero element of array with length 8\n\n\nclass Solution(object):\n    def mergeKLists(self, lists):\n       \n        per = 10000\n        count = [0]*20010\n\n        for i in lists:\n            g = i\n            while(g != None):\n                count[(int)(g.val)+per]+=1\n                g = g.next\n\n        las = []\n        c = 0\n        for i in range(per*2):\n            if count[i] > 0:\n                for j in range(count[i]):\n                    las.append(ListNode(i-per))\n                    c+=1\n                    \n        for i in range(c):\n            if i > 0:\n                las[c-2-i].next = las[c-1-i]\n        \n        return las[0]\n\n"
                    }
                ]
            },
            {
                "id": 1767944,
                "content": [
                    {
                        "username": "shrishailgouragond",
                        "content": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>(10000, new Comparator<ListNode>(){\n            @Override\n             public int compare(ListNode a , ListNode b)\n            {\n                return a.val - b.val;\n            }\n        } );\n        ListNode dummyHead = new ListNode() ;\n        ListNode dummy = dummyHead;\n        for(int i=0;i<lists.length;i++)\n        {\n            if(lists[i]!=null) pq.add(lists[i]);\n        }\n\n        while(!pq.isEmpty())\n        {\n            dummy.next = pq.peek();\n            dummy = dummy.next;\n            ListNode temp = pq.poll();\n\n            if(temp.next!=null)\n            {\n                pq.add(temp.next);\n            }\n        }\n\n        dummy.next = null;\n\n        return dummyHead.next;\n\n    }\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation; \\nhttps://youtu.be/OIesl0ioVKw"
                    },
                    {
                        "username": "JRN803",
                        "content": "I have an approach where I am merging two lists at a time and then using that merged list and merging it with the next list but it fails on the 132/133 test case due to time limit exceeded. Conceptually this approach is O(k+m) where k is the number of lists and m is the average length of the lists. Any ideas?\n\n<img width=\"400\" src=\"file:///var/folders/g4/qz5krndj59lbx5djgg6r0gb40000gn/T/TemporaryItems/NSIRD_screencaptureui_Fj9QdV/Screen%20Shot%202022-12-30%20at%202.49.37%20AM.png\">\n\n<img width=\"400\" src=\"file:///var/folders/g4/qz5krndj59lbx5djgg6r0gb40000gn/T/TemporaryItems/NSIRD_screencaptureui_7meJDs/Screen%20Shot%202022-12-30%20at%202.49.54%20AM.png\">\n"
                    },
                    {
                        "username": "Sandeep9491",
                        "content": "This code should run in O(n * log(k)) time, where n is the total number of nodes in all the input lists and k is the number of input lists. This is because each node is added to and extracted from the heap log(k) times, for a total of n * log(k) heap operations. The heapify function also takes O(k) time to initialize the heap."
                    },
                    {
                        "username": "avibharti",
                        "content": " In Scala  easy solution can achieved with Monoid (typeclass) algebraic property.  \n\nimport cats.implicits._\n\nval lists = List(List(1, 4, 5), List(1, 3, 4), List(2, 6))\n\nval answer = List(1, 1, 2, 3, 4, 4, 5, 6)\n\nval initList: List[Int] = List()\nlists.foldLeft(initList) { _ |+| _ }.sorted \n"
                    },
                    {
                        "username": "alperkaya0",
                        "content": "This should be an easy question but not complaining tho cause i have one more hard question to show on my profile"
                    },
                    {
                        "username": "SHRAVAN3246",
                        "content": "hii everyone how to get the each linked list head node in this problem .\\n \\ni understood the problem but it gives error if i use lists[0].\\nplease reply \\nthanks in advance"
                    },
                    {
                        "username": "alperkaya0",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "reshmithaa",
                        "content": "runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\ndont know the reason why im getting lik this \\nalthough my code is crt \\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* merge2List(ListNode* l1,ListNode* l2){\\n        ListNode* result=NULL,*curr=NULL;\\n        while (l1!=NULL && l2!=NULL){\\n            if (l1->val < l2->val){\\n                if (result==NULL){\\n                    result=l1;\\n                    curr=result;\\n                }\\n                else{\\n                    curr->next=l1;\\n                    curr=curr->next;\\n                }\\n                l1=l1->next;\\n            }\\n            else{\\n                if (result==NULL){\\n                    result=l2;\\n                    curr=result;\\n                }\\n                else{\\n                    curr->next=l2;\\n                    curr=curr->next;\\n                }  \\n                l2=l2->next;  \\n            }\\n        }\\n        while(!l1){\\n            if (result==NULL){\\n                result=l1;\\n                curr=result;\\n            }\\n            else{\\n                curr->next=l1;\\n                curr=curr->next;\\n            }\\n            l1=l1->next;\\n        }\\n        while(!l2){\\n            if (result==NULL){\\n                result=l2;\\n                curr=result;\\n            }\\n            else{\\n                curr->next=l2;\\n                curr=curr->next;\\n            }  \\n            if (l2->next!=NULL)  \\n                l2=l2->next;\\n            else{\\n                break;\\n            }\\n        }\\n        return result;\\n    }\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* result = lists[0];\\n        for (int i=1;i<lists.size();i++){\\n            result=merge2List(result,lists[i]);\\n        }\\n        return result;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1760982,
                "content": [
                    {
                        "username": "shrishailgouragond",
                        "content": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>(10000, new Comparator<ListNode>(){\n            @Override\n             public int compare(ListNode a , ListNode b)\n            {\n                return a.val - b.val;\n            }\n        } );\n        ListNode dummyHead = new ListNode() ;\n        ListNode dummy = dummyHead;\n        for(int i=0;i<lists.length;i++)\n        {\n            if(lists[i]!=null) pq.add(lists[i]);\n        }\n\n        while(!pq.isEmpty())\n        {\n            dummy.next = pq.peek();\n            dummy = dummy.next;\n            ListNode temp = pq.poll();\n\n            if(temp.next!=null)\n            {\n                pq.add(temp.next);\n            }\n        }\n\n        dummy.next = null;\n\n        return dummyHead.next;\n\n    }\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation; \\nhttps://youtu.be/OIesl0ioVKw"
                    },
                    {
                        "username": "JRN803",
                        "content": "I have an approach where I am merging two lists at a time and then using that merged list and merging it with the next list but it fails on the 132/133 test case due to time limit exceeded. Conceptually this approach is O(k+m) where k is the number of lists and m is the average length of the lists. Any ideas?\n\n<img width=\"400\" src=\"file:///var/folders/g4/qz5krndj59lbx5djgg6r0gb40000gn/T/TemporaryItems/NSIRD_screencaptureui_Fj9QdV/Screen%20Shot%202022-12-30%20at%202.49.37%20AM.png\">\n\n<img width=\"400\" src=\"file:///var/folders/g4/qz5krndj59lbx5djgg6r0gb40000gn/T/TemporaryItems/NSIRD_screencaptureui_7meJDs/Screen%20Shot%202022-12-30%20at%202.49.54%20AM.png\">\n"
                    },
                    {
                        "username": "Sandeep9491",
                        "content": "This code should run in O(n * log(k)) time, where n is the total number of nodes in all the input lists and k is the number of input lists. This is because each node is added to and extracted from the heap log(k) times, for a total of n * log(k) heap operations. The heapify function also takes O(k) time to initialize the heap."
                    },
                    {
                        "username": "avibharti",
                        "content": " In Scala  easy solution can achieved with Monoid (typeclass) algebraic property.  \n\nimport cats.implicits._\n\nval lists = List(List(1, 4, 5), List(1, 3, 4), List(2, 6))\n\nval answer = List(1, 1, 2, 3, 4, 4, 5, 6)\n\nval initList: List[Int] = List()\nlists.foldLeft(initList) { _ |+| _ }.sorted \n"
                    },
                    {
                        "username": "alperkaya0",
                        "content": "This should be an easy question but not complaining tho cause i have one more hard question to show on my profile"
                    },
                    {
                        "username": "SHRAVAN3246",
                        "content": "hii everyone how to get the each linked list head node in this problem .\\n \\ni understood the problem but it gives error if i use lists[0].\\nplease reply \\nthanks in advance"
                    },
                    {
                        "username": "alperkaya0",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "reshmithaa",
                        "content": "runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\ndont know the reason why im getting lik this \\nalthough my code is crt \\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* merge2List(ListNode* l1,ListNode* l2){\\n        ListNode* result=NULL,*curr=NULL;\\n        while (l1!=NULL && l2!=NULL){\\n            if (l1->val < l2->val){\\n                if (result==NULL){\\n                    result=l1;\\n                    curr=result;\\n                }\\n                else{\\n                    curr->next=l1;\\n                    curr=curr->next;\\n                }\\n                l1=l1->next;\\n            }\\n            else{\\n                if (result==NULL){\\n                    result=l2;\\n                    curr=result;\\n                }\\n                else{\\n                    curr->next=l2;\\n                    curr=curr->next;\\n                }  \\n                l2=l2->next;  \\n            }\\n        }\\n        while(!l1){\\n            if (result==NULL){\\n                result=l1;\\n                curr=result;\\n            }\\n            else{\\n                curr->next=l1;\\n                curr=curr->next;\\n            }\\n            l1=l1->next;\\n        }\\n        while(!l2){\\n            if (result==NULL){\\n                result=l2;\\n                curr=result;\\n            }\\n            else{\\n                curr->next=l2;\\n                curr=curr->next;\\n            }  \\n            if (l2->next!=NULL)  \\n                l2=l2->next;\\n            else{\\n                break;\\n            }\\n        }\\n        return result;\\n    }\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* result = lists[0];\\n        for (int i=1;i<lists.size();i++){\\n            result=merge2List(result,lists[i]);\\n        }\\n        return result;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1742800,
                "content": [
                    {
                        "username": "shrishailgouragond",
                        "content": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>(10000, new Comparator<ListNode>(){\n            @Override\n             public int compare(ListNode a , ListNode b)\n            {\n                return a.val - b.val;\n            }\n        } );\n        ListNode dummyHead = new ListNode() ;\n        ListNode dummy = dummyHead;\n        for(int i=0;i<lists.length;i++)\n        {\n            if(lists[i]!=null) pq.add(lists[i]);\n        }\n\n        while(!pq.isEmpty())\n        {\n            dummy.next = pq.peek();\n            dummy = dummy.next;\n            ListNode temp = pq.poll();\n\n            if(temp.next!=null)\n            {\n                pq.add(temp.next);\n            }\n        }\n\n        dummy.next = null;\n\n        return dummyHead.next;\n\n    }\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation; \\nhttps://youtu.be/OIesl0ioVKw"
                    },
                    {
                        "username": "JRN803",
                        "content": "I have an approach where I am merging two lists at a time and then using that merged list and merging it with the next list but it fails on the 132/133 test case due to time limit exceeded. Conceptually this approach is O(k+m) where k is the number of lists and m is the average length of the lists. Any ideas?\n\n<img width=\"400\" src=\"file:///var/folders/g4/qz5krndj59lbx5djgg6r0gb40000gn/T/TemporaryItems/NSIRD_screencaptureui_Fj9QdV/Screen%20Shot%202022-12-30%20at%202.49.37%20AM.png\">\n\n<img width=\"400\" src=\"file:///var/folders/g4/qz5krndj59lbx5djgg6r0gb40000gn/T/TemporaryItems/NSIRD_screencaptureui_7meJDs/Screen%20Shot%202022-12-30%20at%202.49.54%20AM.png\">\n"
                    },
                    {
                        "username": "Sandeep9491",
                        "content": "This code should run in O(n * log(k)) time, where n is the total number of nodes in all the input lists and k is the number of input lists. This is because each node is added to and extracted from the heap log(k) times, for a total of n * log(k) heap operations. The heapify function also takes O(k) time to initialize the heap."
                    },
                    {
                        "username": "avibharti",
                        "content": " In Scala  easy solution can achieved with Monoid (typeclass) algebraic property.  \n\nimport cats.implicits._\n\nval lists = List(List(1, 4, 5), List(1, 3, 4), List(2, 6))\n\nval answer = List(1, 1, 2, 3, 4, 4, 5, 6)\n\nval initList: List[Int] = List()\nlists.foldLeft(initList) { _ |+| _ }.sorted \n"
                    },
                    {
                        "username": "alperkaya0",
                        "content": "This should be an easy question but not complaining tho cause i have one more hard question to show on my profile"
                    },
                    {
                        "username": "SHRAVAN3246",
                        "content": "hii everyone how to get the each linked list head node in this problem .\\n \\ni understood the problem but it gives error if i use lists[0].\\nplease reply \\nthanks in advance"
                    },
                    {
                        "username": "alperkaya0",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "reshmithaa",
                        "content": "runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\ndont know the reason why im getting lik this \\nalthough my code is crt \\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* merge2List(ListNode* l1,ListNode* l2){\\n        ListNode* result=NULL,*curr=NULL;\\n        while (l1!=NULL && l2!=NULL){\\n            if (l1->val < l2->val){\\n                if (result==NULL){\\n                    result=l1;\\n                    curr=result;\\n                }\\n                else{\\n                    curr->next=l1;\\n                    curr=curr->next;\\n                }\\n                l1=l1->next;\\n            }\\n            else{\\n                if (result==NULL){\\n                    result=l2;\\n                    curr=result;\\n                }\\n                else{\\n                    curr->next=l2;\\n                    curr=curr->next;\\n                }  \\n                l2=l2->next;  \\n            }\\n        }\\n        while(!l1){\\n            if (result==NULL){\\n                result=l1;\\n                curr=result;\\n            }\\n            else{\\n                curr->next=l1;\\n                curr=curr->next;\\n            }\\n            l1=l1->next;\\n        }\\n        while(!l2){\\n            if (result==NULL){\\n                result=l2;\\n                curr=result;\\n            }\\n            else{\\n                curr->next=l2;\\n                curr=curr->next;\\n            }  \\n            if (l2->next!=NULL)  \\n                l2=l2->next;\\n            else{\\n                break;\\n            }\\n        }\\n        return result;\\n    }\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* result = lists[0];\\n        for (int i=1;i<lists.size();i++){\\n            result=merge2List(result,lists[i]);\\n        }\\n        return result;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1734175,
                "content": [
                    {
                        "username": "shrishailgouragond",
                        "content": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>(10000, new Comparator<ListNode>(){\n            @Override\n             public int compare(ListNode a , ListNode b)\n            {\n                return a.val - b.val;\n            }\n        } );\n        ListNode dummyHead = new ListNode() ;\n        ListNode dummy = dummyHead;\n        for(int i=0;i<lists.length;i++)\n        {\n            if(lists[i]!=null) pq.add(lists[i]);\n        }\n\n        while(!pq.isEmpty())\n        {\n            dummy.next = pq.peek();\n            dummy = dummy.next;\n            ListNode temp = pq.poll();\n\n            if(temp.next!=null)\n            {\n                pq.add(temp.next);\n            }\n        }\n\n        dummy.next = null;\n\n        return dummyHead.next;\n\n    }\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation; \\nhttps://youtu.be/OIesl0ioVKw"
                    },
                    {
                        "username": "JRN803",
                        "content": "I have an approach where I am merging two lists at a time and then using that merged list and merging it with the next list but it fails on the 132/133 test case due to time limit exceeded. Conceptually this approach is O(k+m) where k is the number of lists and m is the average length of the lists. Any ideas?\n\n<img width=\"400\" src=\"file:///var/folders/g4/qz5krndj59lbx5djgg6r0gb40000gn/T/TemporaryItems/NSIRD_screencaptureui_Fj9QdV/Screen%20Shot%202022-12-30%20at%202.49.37%20AM.png\">\n\n<img width=\"400\" src=\"file:///var/folders/g4/qz5krndj59lbx5djgg6r0gb40000gn/T/TemporaryItems/NSIRD_screencaptureui_7meJDs/Screen%20Shot%202022-12-30%20at%202.49.54%20AM.png\">\n"
                    },
                    {
                        "username": "Sandeep9491",
                        "content": "This code should run in O(n * log(k)) time, where n is the total number of nodes in all the input lists and k is the number of input lists. This is because each node is added to and extracted from the heap log(k) times, for a total of n * log(k) heap operations. The heapify function also takes O(k) time to initialize the heap."
                    },
                    {
                        "username": "avibharti",
                        "content": " In Scala  easy solution can achieved with Monoid (typeclass) algebraic property.  \n\nimport cats.implicits._\n\nval lists = List(List(1, 4, 5), List(1, 3, 4), List(2, 6))\n\nval answer = List(1, 1, 2, 3, 4, 4, 5, 6)\n\nval initList: List[Int] = List()\nlists.foldLeft(initList) { _ |+| _ }.sorted \n"
                    },
                    {
                        "username": "alperkaya0",
                        "content": "This should be an easy question but not complaining tho cause i have one more hard question to show on my profile"
                    },
                    {
                        "username": "SHRAVAN3246",
                        "content": "hii everyone how to get the each linked list head node in this problem .\\n \\ni understood the problem but it gives error if i use lists[0].\\nplease reply \\nthanks in advance"
                    },
                    {
                        "username": "alperkaya0",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "reshmithaa",
                        "content": "runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\ndont know the reason why im getting lik this \\nalthough my code is crt \\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* merge2List(ListNode* l1,ListNode* l2){\\n        ListNode* result=NULL,*curr=NULL;\\n        while (l1!=NULL && l2!=NULL){\\n            if (l1->val < l2->val){\\n                if (result==NULL){\\n                    result=l1;\\n                    curr=result;\\n                }\\n                else{\\n                    curr->next=l1;\\n                    curr=curr->next;\\n                }\\n                l1=l1->next;\\n            }\\n            else{\\n                if (result==NULL){\\n                    result=l2;\\n                    curr=result;\\n                }\\n                else{\\n                    curr->next=l2;\\n                    curr=curr->next;\\n                }  \\n                l2=l2->next;  \\n            }\\n        }\\n        while(!l1){\\n            if (result==NULL){\\n                result=l1;\\n                curr=result;\\n            }\\n            else{\\n                curr->next=l1;\\n                curr=curr->next;\\n            }\\n            l1=l1->next;\\n        }\\n        while(!l2){\\n            if (result==NULL){\\n                result=l2;\\n                curr=result;\\n            }\\n            else{\\n                curr->next=l2;\\n                curr=curr->next;\\n            }  \\n            if (l2->next!=NULL)  \\n                l2=l2->next;\\n            else{\\n                break;\\n            }\\n        }\\n        return result;\\n    }\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* result = lists[0];\\n        for (int i=1;i<lists.size();i++){\\n            result=merge2List(result,lists[i]);\\n        }\\n        return result;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1734034,
                "content": [
                    {
                        "username": "shrishailgouragond",
                        "content": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>(10000, new Comparator<ListNode>(){\n            @Override\n             public int compare(ListNode a , ListNode b)\n            {\n                return a.val - b.val;\n            }\n        } );\n        ListNode dummyHead = new ListNode() ;\n        ListNode dummy = dummyHead;\n        for(int i=0;i<lists.length;i++)\n        {\n            if(lists[i]!=null) pq.add(lists[i]);\n        }\n\n        while(!pq.isEmpty())\n        {\n            dummy.next = pq.peek();\n            dummy = dummy.next;\n            ListNode temp = pq.poll();\n\n            if(temp.next!=null)\n            {\n                pq.add(temp.next);\n            }\n        }\n\n        dummy.next = null;\n\n        return dummyHead.next;\n\n    }\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation; \\nhttps://youtu.be/OIesl0ioVKw"
                    },
                    {
                        "username": "JRN803",
                        "content": "I have an approach where I am merging two lists at a time and then using that merged list and merging it with the next list but it fails on the 132/133 test case due to time limit exceeded. Conceptually this approach is O(k+m) where k is the number of lists and m is the average length of the lists. Any ideas?\n\n<img width=\"400\" src=\"file:///var/folders/g4/qz5krndj59lbx5djgg6r0gb40000gn/T/TemporaryItems/NSIRD_screencaptureui_Fj9QdV/Screen%20Shot%202022-12-30%20at%202.49.37%20AM.png\">\n\n<img width=\"400\" src=\"file:///var/folders/g4/qz5krndj59lbx5djgg6r0gb40000gn/T/TemporaryItems/NSIRD_screencaptureui_7meJDs/Screen%20Shot%202022-12-30%20at%202.49.54%20AM.png\">\n"
                    },
                    {
                        "username": "Sandeep9491",
                        "content": "This code should run in O(n * log(k)) time, where n is the total number of nodes in all the input lists and k is the number of input lists. This is because each node is added to and extracted from the heap log(k) times, for a total of n * log(k) heap operations. The heapify function also takes O(k) time to initialize the heap."
                    },
                    {
                        "username": "avibharti",
                        "content": " In Scala  easy solution can achieved with Monoid (typeclass) algebraic property.  \n\nimport cats.implicits._\n\nval lists = List(List(1, 4, 5), List(1, 3, 4), List(2, 6))\n\nval answer = List(1, 1, 2, 3, 4, 4, 5, 6)\n\nval initList: List[Int] = List()\nlists.foldLeft(initList) { _ |+| _ }.sorted \n"
                    },
                    {
                        "username": "alperkaya0",
                        "content": "This should be an easy question but not complaining tho cause i have one more hard question to show on my profile"
                    },
                    {
                        "username": "SHRAVAN3246",
                        "content": "hii everyone how to get the each linked list head node in this problem .\\n \\ni understood the problem but it gives error if i use lists[0].\\nplease reply \\nthanks in advance"
                    },
                    {
                        "username": "alperkaya0",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "reshmithaa",
                        "content": "runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\ndont know the reason why im getting lik this \\nalthough my code is crt \\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* merge2List(ListNode* l1,ListNode* l2){\\n        ListNode* result=NULL,*curr=NULL;\\n        while (l1!=NULL && l2!=NULL){\\n            if (l1->val < l2->val){\\n                if (result==NULL){\\n                    result=l1;\\n                    curr=result;\\n                }\\n                else{\\n                    curr->next=l1;\\n                    curr=curr->next;\\n                }\\n                l1=l1->next;\\n            }\\n            else{\\n                if (result==NULL){\\n                    result=l2;\\n                    curr=result;\\n                }\\n                else{\\n                    curr->next=l2;\\n                    curr=curr->next;\\n                }  \\n                l2=l2->next;  \\n            }\\n        }\\n        while(!l1){\\n            if (result==NULL){\\n                result=l1;\\n                curr=result;\\n            }\\n            else{\\n                curr->next=l1;\\n                curr=curr->next;\\n            }\\n            l1=l1->next;\\n        }\\n        while(!l2){\\n            if (result==NULL){\\n                result=l2;\\n                curr=result;\\n            }\\n            else{\\n                curr->next=l2;\\n                curr=curr->next;\\n            }  \\n            if (l2->next!=NULL)  \\n                l2=l2->next;\\n            else{\\n                break;\\n            }\\n        }\\n        return result;\\n    }\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* result = lists[0];\\n        for (int i=1;i<lists.size();i++){\\n            result=merge2List(result,lists[i]);\\n        }\\n        return result;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1729550,
                "content": [
                    {
                        "username": "shrishailgouragond",
                        "content": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>(10000, new Comparator<ListNode>(){\n            @Override\n             public int compare(ListNode a , ListNode b)\n            {\n                return a.val - b.val;\n            }\n        } );\n        ListNode dummyHead = new ListNode() ;\n        ListNode dummy = dummyHead;\n        for(int i=0;i<lists.length;i++)\n        {\n            if(lists[i]!=null) pq.add(lists[i]);\n        }\n\n        while(!pq.isEmpty())\n        {\n            dummy.next = pq.peek();\n            dummy = dummy.next;\n            ListNode temp = pq.poll();\n\n            if(temp.next!=null)\n            {\n                pq.add(temp.next);\n            }\n        }\n\n        dummy.next = null;\n\n        return dummyHead.next;\n\n    }\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation; \\nhttps://youtu.be/OIesl0ioVKw"
                    },
                    {
                        "username": "JRN803",
                        "content": "I have an approach where I am merging two lists at a time and then using that merged list and merging it with the next list but it fails on the 132/133 test case due to time limit exceeded. Conceptually this approach is O(k+m) where k is the number of lists and m is the average length of the lists. Any ideas?\n\n<img width=\"400\" src=\"file:///var/folders/g4/qz5krndj59lbx5djgg6r0gb40000gn/T/TemporaryItems/NSIRD_screencaptureui_Fj9QdV/Screen%20Shot%202022-12-30%20at%202.49.37%20AM.png\">\n\n<img width=\"400\" src=\"file:///var/folders/g4/qz5krndj59lbx5djgg6r0gb40000gn/T/TemporaryItems/NSIRD_screencaptureui_7meJDs/Screen%20Shot%202022-12-30%20at%202.49.54%20AM.png\">\n"
                    },
                    {
                        "username": "Sandeep9491",
                        "content": "This code should run in O(n * log(k)) time, where n is the total number of nodes in all the input lists and k is the number of input lists. This is because each node is added to and extracted from the heap log(k) times, for a total of n * log(k) heap operations. The heapify function also takes O(k) time to initialize the heap."
                    },
                    {
                        "username": "avibharti",
                        "content": " In Scala  easy solution can achieved with Monoid (typeclass) algebraic property.  \n\nimport cats.implicits._\n\nval lists = List(List(1, 4, 5), List(1, 3, 4), List(2, 6))\n\nval answer = List(1, 1, 2, 3, 4, 4, 5, 6)\n\nval initList: List[Int] = List()\nlists.foldLeft(initList) { _ |+| _ }.sorted \n"
                    },
                    {
                        "username": "alperkaya0",
                        "content": "This should be an easy question but not complaining tho cause i have one more hard question to show on my profile"
                    },
                    {
                        "username": "SHRAVAN3246",
                        "content": "hii everyone how to get the each linked list head node in this problem .\\n \\ni understood the problem but it gives error if i use lists[0].\\nplease reply \\nthanks in advance"
                    },
                    {
                        "username": "alperkaya0",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "reshmithaa",
                        "content": "runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\ndont know the reason why im getting lik this \\nalthough my code is crt \\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* merge2List(ListNode* l1,ListNode* l2){\\n        ListNode* result=NULL,*curr=NULL;\\n        while (l1!=NULL && l2!=NULL){\\n            if (l1->val < l2->val){\\n                if (result==NULL){\\n                    result=l1;\\n                    curr=result;\\n                }\\n                else{\\n                    curr->next=l1;\\n                    curr=curr->next;\\n                }\\n                l1=l1->next;\\n            }\\n            else{\\n                if (result==NULL){\\n                    result=l2;\\n                    curr=result;\\n                }\\n                else{\\n                    curr->next=l2;\\n                    curr=curr->next;\\n                }  \\n                l2=l2->next;  \\n            }\\n        }\\n        while(!l1){\\n            if (result==NULL){\\n                result=l1;\\n                curr=result;\\n            }\\n            else{\\n                curr->next=l1;\\n                curr=curr->next;\\n            }\\n            l1=l1->next;\\n        }\\n        while(!l2){\\n            if (result==NULL){\\n                result=l2;\\n                curr=result;\\n            }\\n            else{\\n                curr->next=l2;\\n                curr=curr->next;\\n            }  \\n            if (l2->next!=NULL)  \\n                l2=l2->next;\\n            else{\\n                break;\\n            }\\n        }\\n        return result;\\n    }\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* result = lists[0];\\n        for (int i=1;i<lists.size();i++){\\n            result=merge2List(result,lists[i]);\\n        }\\n        return result;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1727169,
                "content": [
                    {
                        "username": "shrishailgouragond",
                        "content": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>(10000, new Comparator<ListNode>(){\n            @Override\n             public int compare(ListNode a , ListNode b)\n            {\n                return a.val - b.val;\n            }\n        } );\n        ListNode dummyHead = new ListNode() ;\n        ListNode dummy = dummyHead;\n        for(int i=0;i<lists.length;i++)\n        {\n            if(lists[i]!=null) pq.add(lists[i]);\n        }\n\n        while(!pq.isEmpty())\n        {\n            dummy.next = pq.peek();\n            dummy = dummy.next;\n            ListNode temp = pq.poll();\n\n            if(temp.next!=null)\n            {\n                pq.add(temp.next);\n            }\n        }\n\n        dummy.next = null;\n\n        return dummyHead.next;\n\n    }\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation; \\nhttps://youtu.be/OIesl0ioVKw"
                    },
                    {
                        "username": "JRN803",
                        "content": "I have an approach where I am merging two lists at a time and then using that merged list and merging it with the next list but it fails on the 132/133 test case due to time limit exceeded. Conceptually this approach is O(k+m) where k is the number of lists and m is the average length of the lists. Any ideas?\n\n<img width=\"400\" src=\"file:///var/folders/g4/qz5krndj59lbx5djgg6r0gb40000gn/T/TemporaryItems/NSIRD_screencaptureui_Fj9QdV/Screen%20Shot%202022-12-30%20at%202.49.37%20AM.png\">\n\n<img width=\"400\" src=\"file:///var/folders/g4/qz5krndj59lbx5djgg6r0gb40000gn/T/TemporaryItems/NSIRD_screencaptureui_7meJDs/Screen%20Shot%202022-12-30%20at%202.49.54%20AM.png\">\n"
                    },
                    {
                        "username": "Sandeep9491",
                        "content": "This code should run in O(n * log(k)) time, where n is the total number of nodes in all the input lists and k is the number of input lists. This is because each node is added to and extracted from the heap log(k) times, for a total of n * log(k) heap operations. The heapify function also takes O(k) time to initialize the heap."
                    },
                    {
                        "username": "avibharti",
                        "content": " In Scala  easy solution can achieved with Monoid (typeclass) algebraic property.  \n\nimport cats.implicits._\n\nval lists = List(List(1, 4, 5), List(1, 3, 4), List(2, 6))\n\nval answer = List(1, 1, 2, 3, 4, 4, 5, 6)\n\nval initList: List[Int] = List()\nlists.foldLeft(initList) { _ |+| _ }.sorted \n"
                    },
                    {
                        "username": "alperkaya0",
                        "content": "This should be an easy question but not complaining tho cause i have one more hard question to show on my profile"
                    },
                    {
                        "username": "SHRAVAN3246",
                        "content": "hii everyone how to get the each linked list head node in this problem .\\n \\ni understood the problem but it gives error if i use lists[0].\\nplease reply \\nthanks in advance"
                    },
                    {
                        "username": "alperkaya0",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "reshmithaa",
                        "content": "runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\ndont know the reason why im getting lik this \\nalthough my code is crt \\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* merge2List(ListNode* l1,ListNode* l2){\\n        ListNode* result=NULL,*curr=NULL;\\n        while (l1!=NULL && l2!=NULL){\\n            if (l1->val < l2->val){\\n                if (result==NULL){\\n                    result=l1;\\n                    curr=result;\\n                }\\n                else{\\n                    curr->next=l1;\\n                    curr=curr->next;\\n                }\\n                l1=l1->next;\\n            }\\n            else{\\n                if (result==NULL){\\n                    result=l2;\\n                    curr=result;\\n                }\\n                else{\\n                    curr->next=l2;\\n                    curr=curr->next;\\n                }  \\n                l2=l2->next;  \\n            }\\n        }\\n        while(!l1){\\n            if (result==NULL){\\n                result=l1;\\n                curr=result;\\n            }\\n            else{\\n                curr->next=l1;\\n                curr=curr->next;\\n            }\\n            l1=l1->next;\\n        }\\n        while(!l2){\\n            if (result==NULL){\\n                result=l2;\\n                curr=result;\\n            }\\n            else{\\n                curr->next=l2;\\n                curr=curr->next;\\n            }  \\n            if (l2->next!=NULL)  \\n                l2=l2->next;\\n            else{\\n                break;\\n            }\\n        }\\n        return result;\\n    }\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* result = lists[0];\\n        for (int i=1;i<lists.size();i++){\\n            result=merge2List(result,lists[i]);\\n        }\\n        return result;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1725520,
                "content": [
                    {
                        "username": "shrishailgouragond",
                        "content": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>(10000, new Comparator<ListNode>(){\n            @Override\n             public int compare(ListNode a , ListNode b)\n            {\n                return a.val - b.val;\n            }\n        } );\n        ListNode dummyHead = new ListNode() ;\n        ListNode dummy = dummyHead;\n        for(int i=0;i<lists.length;i++)\n        {\n            if(lists[i]!=null) pq.add(lists[i]);\n        }\n\n        while(!pq.isEmpty())\n        {\n            dummy.next = pq.peek();\n            dummy = dummy.next;\n            ListNode temp = pq.poll();\n\n            if(temp.next!=null)\n            {\n                pq.add(temp.next);\n            }\n        }\n\n        dummy.next = null;\n\n        return dummyHead.next;\n\n    }\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation; \\nhttps://youtu.be/OIesl0ioVKw"
                    },
                    {
                        "username": "JRN803",
                        "content": "I have an approach where I am merging two lists at a time and then using that merged list and merging it with the next list but it fails on the 132/133 test case due to time limit exceeded. Conceptually this approach is O(k+m) where k is the number of lists and m is the average length of the lists. Any ideas?\n\n<img width=\"400\" src=\"file:///var/folders/g4/qz5krndj59lbx5djgg6r0gb40000gn/T/TemporaryItems/NSIRD_screencaptureui_Fj9QdV/Screen%20Shot%202022-12-30%20at%202.49.37%20AM.png\">\n\n<img width=\"400\" src=\"file:///var/folders/g4/qz5krndj59lbx5djgg6r0gb40000gn/T/TemporaryItems/NSIRD_screencaptureui_7meJDs/Screen%20Shot%202022-12-30%20at%202.49.54%20AM.png\">\n"
                    },
                    {
                        "username": "Sandeep9491",
                        "content": "This code should run in O(n * log(k)) time, where n is the total number of nodes in all the input lists and k is the number of input lists. This is because each node is added to and extracted from the heap log(k) times, for a total of n * log(k) heap operations. The heapify function also takes O(k) time to initialize the heap."
                    },
                    {
                        "username": "avibharti",
                        "content": " In Scala  easy solution can achieved with Monoid (typeclass) algebraic property.  \n\nimport cats.implicits._\n\nval lists = List(List(1, 4, 5), List(1, 3, 4), List(2, 6))\n\nval answer = List(1, 1, 2, 3, 4, 4, 5, 6)\n\nval initList: List[Int] = List()\nlists.foldLeft(initList) { _ |+| _ }.sorted \n"
                    },
                    {
                        "username": "alperkaya0",
                        "content": "This should be an easy question but not complaining tho cause i have one more hard question to show on my profile"
                    },
                    {
                        "username": "SHRAVAN3246",
                        "content": "hii everyone how to get the each linked list head node in this problem .\\n \\ni understood the problem but it gives error if i use lists[0].\\nplease reply \\nthanks in advance"
                    },
                    {
                        "username": "alperkaya0",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "reshmithaa",
                        "content": "runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\ndont know the reason why im getting lik this \\nalthough my code is crt \\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* merge2List(ListNode* l1,ListNode* l2){\\n        ListNode* result=NULL,*curr=NULL;\\n        while (l1!=NULL && l2!=NULL){\\n            if (l1->val < l2->val){\\n                if (result==NULL){\\n                    result=l1;\\n                    curr=result;\\n                }\\n                else{\\n                    curr->next=l1;\\n                    curr=curr->next;\\n                }\\n                l1=l1->next;\\n            }\\n            else{\\n                if (result==NULL){\\n                    result=l2;\\n                    curr=result;\\n                }\\n                else{\\n                    curr->next=l2;\\n                    curr=curr->next;\\n                }  \\n                l2=l2->next;  \\n            }\\n        }\\n        while(!l1){\\n            if (result==NULL){\\n                result=l1;\\n                curr=result;\\n            }\\n            else{\\n                curr->next=l1;\\n                curr=curr->next;\\n            }\\n            l1=l1->next;\\n        }\\n        while(!l2){\\n            if (result==NULL){\\n                result=l2;\\n                curr=result;\\n            }\\n            else{\\n                curr->next=l2;\\n                curr=curr->next;\\n            }  \\n            if (l2->next!=NULL)  \\n                l2=l2->next;\\n            else{\\n                break;\\n            }\\n        }\\n        return result;\\n    }\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* result = lists[0];\\n        for (int i=1;i<lists.size();i++){\\n            result=merge2List(result,lists[i]);\\n        }\\n        return result;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1725479,
                "content": [
                    {
                        "username": "shrishailgouragond",
                        "content": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>(10000, new Comparator<ListNode>(){\n            @Override\n             public int compare(ListNode a , ListNode b)\n            {\n                return a.val - b.val;\n            }\n        } );\n        ListNode dummyHead = new ListNode() ;\n        ListNode dummy = dummyHead;\n        for(int i=0;i<lists.length;i++)\n        {\n            if(lists[i]!=null) pq.add(lists[i]);\n        }\n\n        while(!pq.isEmpty())\n        {\n            dummy.next = pq.peek();\n            dummy = dummy.next;\n            ListNode temp = pq.poll();\n\n            if(temp.next!=null)\n            {\n                pq.add(temp.next);\n            }\n        }\n\n        dummy.next = null;\n\n        return dummyHead.next;\n\n    }\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation; \\nhttps://youtu.be/OIesl0ioVKw"
                    },
                    {
                        "username": "JRN803",
                        "content": "I have an approach where I am merging two lists at a time and then using that merged list and merging it with the next list but it fails on the 132/133 test case due to time limit exceeded. Conceptually this approach is O(k+m) where k is the number of lists and m is the average length of the lists. Any ideas?\n\n<img width=\"400\" src=\"file:///var/folders/g4/qz5krndj59lbx5djgg6r0gb40000gn/T/TemporaryItems/NSIRD_screencaptureui_Fj9QdV/Screen%20Shot%202022-12-30%20at%202.49.37%20AM.png\">\n\n<img width=\"400\" src=\"file:///var/folders/g4/qz5krndj59lbx5djgg6r0gb40000gn/T/TemporaryItems/NSIRD_screencaptureui_7meJDs/Screen%20Shot%202022-12-30%20at%202.49.54%20AM.png\">\n"
                    },
                    {
                        "username": "Sandeep9491",
                        "content": "This code should run in O(n * log(k)) time, where n is the total number of nodes in all the input lists and k is the number of input lists. This is because each node is added to and extracted from the heap log(k) times, for a total of n * log(k) heap operations. The heapify function also takes O(k) time to initialize the heap."
                    },
                    {
                        "username": "avibharti",
                        "content": " In Scala  easy solution can achieved with Monoid (typeclass) algebraic property.  \n\nimport cats.implicits._\n\nval lists = List(List(1, 4, 5), List(1, 3, 4), List(2, 6))\n\nval answer = List(1, 1, 2, 3, 4, 4, 5, 6)\n\nval initList: List[Int] = List()\nlists.foldLeft(initList) { _ |+| _ }.sorted \n"
                    },
                    {
                        "username": "alperkaya0",
                        "content": "This should be an easy question but not complaining tho cause i have one more hard question to show on my profile"
                    },
                    {
                        "username": "SHRAVAN3246",
                        "content": "hii everyone how to get the each linked list head node in this problem .\\n \\ni understood the problem but it gives error if i use lists[0].\\nplease reply \\nthanks in advance"
                    },
                    {
                        "username": "alperkaya0",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "reshmithaa",
                        "content": "runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\ndont know the reason why im getting lik this \\nalthough my code is crt \\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* merge2List(ListNode* l1,ListNode* l2){\\n        ListNode* result=NULL,*curr=NULL;\\n        while (l1!=NULL && l2!=NULL){\\n            if (l1->val < l2->val){\\n                if (result==NULL){\\n                    result=l1;\\n                    curr=result;\\n                }\\n                else{\\n                    curr->next=l1;\\n                    curr=curr->next;\\n                }\\n                l1=l1->next;\\n            }\\n            else{\\n                if (result==NULL){\\n                    result=l2;\\n                    curr=result;\\n                }\\n                else{\\n                    curr->next=l2;\\n                    curr=curr->next;\\n                }  \\n                l2=l2->next;  \\n            }\\n        }\\n        while(!l1){\\n            if (result==NULL){\\n                result=l1;\\n                curr=result;\\n            }\\n            else{\\n                curr->next=l1;\\n                curr=curr->next;\\n            }\\n            l1=l1->next;\\n        }\\n        while(!l2){\\n            if (result==NULL){\\n                result=l2;\\n                curr=result;\\n            }\\n            else{\\n                curr->next=l2;\\n                curr=curr->next;\\n            }  \\n            if (l2->next!=NULL)  \\n                l2=l2->next;\\n            else{\\n                break;\\n            }\\n        }\\n        return result;\\n    }\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* result = lists[0];\\n        for (int i=1;i<lists.size();i++){\\n            result=merge2List(result,lists[i]);\\n        }\\n        return result;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1724056,
                "content": [
                    {
                        "username": "shrishailgouragond",
                        "content": "class Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        PriorityQueue<ListNode> pq = new PriorityQueue<>(10000, new Comparator<ListNode>(){\n            @Override\n             public int compare(ListNode a , ListNode b)\n            {\n                return a.val - b.val;\n            }\n        } );\n        ListNode dummyHead = new ListNode() ;\n        ListNode dummy = dummyHead;\n        for(int i=0;i<lists.length;i++)\n        {\n            if(lists[i]!=null) pq.add(lists[i]);\n        }\n\n        while(!pq.isEmpty())\n        {\n            dummy.next = pq.peek();\n            dummy = dummy.next;\n            ListNode temp = pq.poll();\n\n            if(temp.next!=null)\n            {\n                pq.add(temp.next);\n            }\n        }\n\n        dummy.next = null;\n\n        return dummyHead.next;\n\n    }\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation; \\nhttps://youtu.be/OIesl0ioVKw"
                    },
                    {
                        "username": "JRN803",
                        "content": "I have an approach where I am merging two lists at a time and then using that merged list and merging it with the next list but it fails on the 132/133 test case due to time limit exceeded. Conceptually this approach is O(k+m) where k is the number of lists and m is the average length of the lists. Any ideas?\n\n<img width=\"400\" src=\"file:///var/folders/g4/qz5krndj59lbx5djgg6r0gb40000gn/T/TemporaryItems/NSIRD_screencaptureui_Fj9QdV/Screen%20Shot%202022-12-30%20at%202.49.37%20AM.png\">\n\n<img width=\"400\" src=\"file:///var/folders/g4/qz5krndj59lbx5djgg6r0gb40000gn/T/TemporaryItems/NSIRD_screencaptureui_7meJDs/Screen%20Shot%202022-12-30%20at%202.49.54%20AM.png\">\n"
                    },
                    {
                        "username": "Sandeep9491",
                        "content": "This code should run in O(n * log(k)) time, where n is the total number of nodes in all the input lists and k is the number of input lists. This is because each node is added to and extracted from the heap log(k) times, for a total of n * log(k) heap operations. The heapify function also takes O(k) time to initialize the heap."
                    },
                    {
                        "username": "avibharti",
                        "content": " In Scala  easy solution can achieved with Monoid (typeclass) algebraic property.  \n\nimport cats.implicits._\n\nval lists = List(List(1, 4, 5), List(1, 3, 4), List(2, 6))\n\nval answer = List(1, 1, 2, 3, 4, 4, 5, 6)\n\nval initList: List[Int] = List()\nlists.foldLeft(initList) { _ |+| _ }.sorted \n"
                    },
                    {
                        "username": "alperkaya0",
                        "content": "This should be an easy question but not complaining tho cause i have one more hard question to show on my profile"
                    },
                    {
                        "username": "SHRAVAN3246",
                        "content": "hii everyone how to get the each linked list head node in this problem .\\n \\ni understood the problem but it gives error if i use lists[0].\\nplease reply \\nthanks in advance"
                    },
                    {
                        "username": "alperkaya0",
                        "content": "Why is this hard?"
                    },
                    {
                        "username": "reshmithaa",
                        "content": "runtime error: member access within null pointer of type \\'ListNode\\' (solution.cpp)\\ndont know the reason why im getting lik this \\nalthough my code is crt \\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* merge2List(ListNode* l1,ListNode* l2){\\n        ListNode* result=NULL,*curr=NULL;\\n        while (l1!=NULL && l2!=NULL){\\n            if (l1->val < l2->val){\\n                if (result==NULL){\\n                    result=l1;\\n                    curr=result;\\n                }\\n                else{\\n                    curr->next=l1;\\n                    curr=curr->next;\\n                }\\n                l1=l1->next;\\n            }\\n            else{\\n                if (result==NULL){\\n                    result=l2;\\n                    curr=result;\\n                }\\n                else{\\n                    curr->next=l2;\\n                    curr=curr->next;\\n                }  \\n                l2=l2->next;  \\n            }\\n        }\\n        while(!l1){\\n            if (result==NULL){\\n                result=l1;\\n                curr=result;\\n            }\\n            else{\\n                curr->next=l1;\\n                curr=curr->next;\\n            }\\n            l1=l1->next;\\n        }\\n        while(!l2){\\n            if (result==NULL){\\n                result=l2;\\n                curr=result;\\n            }\\n            else{\\n                curr->next=l2;\\n                curr=curr->next;\\n            }  \\n            if (l2->next!=NULL)  \\n                l2=l2->next;\\n            else{\\n                break;\\n            }\\n        }\\n        return result;\\n    }\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        ListNode* result = lists[0];\\n        for (int i=1;i<lists.size();i++){\\n            result=merge2List(result,lists[i]);\\n        }\\n        return result;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1718192,
                "content": [
                    {
                        "username": "JoshuaMorris95",
                        "content": "When I first saw this problem I originally considered various options. But I thought I could save time by using a Priority Queue. I haven't solved many hard problems so far, but I was really happy to see that using a Priority Queue was an official solution.\n\nFor any JS users, I used the in-built library Leetcode provides for implementing a Priority Queue: https://github.com/datastructures-js/priority-queue"
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Tip :\\n- There\\'re two ways (i can think of) to solve this problem\\n   - Build up correct order while processing nodes\\n   - Get all the nodes, sort them, and relink\\n- First can be optimized to nlog(m) where m is the size of list, Second is nlog(n) which is not too bad imo.\\n- If you take the first approach, know that the provided list are sorted, technically only the first node matters for each iteration.\\n- Handle one node at a time, and move on to the next node.\\n- Dont forget null checks\\n\\nGood luck\\n"
                    },
                    {
                        "username": "swet_rajput",
                        "content": "it\\'s way complicated then I thought of."
                    },
                    {
                        "username": "lampuiho",
                        "content": "This problem is basically asking you merge sort algorithm except that you start somewhere in the middle. So that by itself is a hint as to how to implement the algorithm than discovering it from nothing. I was asked to implement a sorting algorithm to sort unsigned integers. Couldn\\'t think of how merge sort works from blank so I implemented a count sort instead."
                    },
                    {
                        "username": "chandel0001",
                        "content": " class cmp\\n {   \\n     public:\\n     bool operator() (ListNode* a, ListNode* b)\\n     {\\n         return (a->val>b->val);\\n     }\\n };\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        priority_queue<ListNode*,vector<ListNode*>, cmp> q;\\n        ListNode* dummy = new ListNode(-1);\\n        ListNode* tail = dummy;\\n        for(int i=0;i<lists.size();i++)\\n        {\\n            if(lists[i]!=NULL)\\n            {\\n                q.push(lists[i]);\\n            }\\n        }\\n        while(q.size())\\n        {\\n            ListNode *temp = q.top();\\n            q.pop();\\n            tail->next = temp;\\n            tail = temp;\\n            if(temp->next!=NULL) q.push(temp->next); \\n        }\\n        return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#Python\\nclass Solution:\\n    def mergeKLists(self, lists):\\n        if len(lists) > 0:\\n            l = lists[0]\\n            for i in lists[1:]:\\n                l.extend(i)\\n            return sorted(l)\\n        else:\\n            return lists"
                    },
                    {
                        "username": "JoshuaCastelino",
                        "content": " `   \nfor list in lists:  \nprint(list)\n`\n`print(lists[0].val)`\n\n\nI have been having some issues with indexing, so I tried this out just to see what was happening. I am still getting\n\n IndexError: list index out of range\n    print(lists[0].val)\n\nWhat is going on?\n"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\n[https://www.gyangav.com/2022/11/leetcode-merge-k-sorted-lists-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-merge-k-sorted-lists-problem-solution.html)"
                    },
                    {
                        "username": "sd98754",
                        "content": "Is there any way or method in java Collection framework through which we can sort a singly Linked list directly as we do with lists. ex Collections.sort(lists);\\n\\nSingly Linked List 5-->4-->3-->2-->1\\nsort it is ascending order 1-->2-->3-->4-->5\\n"
                    },
                    {
                        "username": "Md-Ashik-Ali",
                        "content": "### **The Problem is very simple and it can be solved very easily with straight forward solution. Therefore this problem shoulbe be in *Easy* Category.**"
                    }
                ]
            },
            {
                "id": 1711099,
                "content": [
                    {
                        "username": "JoshuaMorris95",
                        "content": "When I first saw this problem I originally considered various options. But I thought I could save time by using a Priority Queue. I haven't solved many hard problems so far, but I was really happy to see that using a Priority Queue was an official solution.\n\nFor any JS users, I used the in-built library Leetcode provides for implementing a Priority Queue: https://github.com/datastructures-js/priority-queue"
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Tip :\\n- There\\'re two ways (i can think of) to solve this problem\\n   - Build up correct order while processing nodes\\n   - Get all the nodes, sort them, and relink\\n- First can be optimized to nlog(m) where m is the size of list, Second is nlog(n) which is not too bad imo.\\n- If you take the first approach, know that the provided list are sorted, technically only the first node matters for each iteration.\\n- Handle one node at a time, and move on to the next node.\\n- Dont forget null checks\\n\\nGood luck\\n"
                    },
                    {
                        "username": "swet_rajput",
                        "content": "it\\'s way complicated then I thought of."
                    },
                    {
                        "username": "lampuiho",
                        "content": "This problem is basically asking you merge sort algorithm except that you start somewhere in the middle. So that by itself is a hint as to how to implement the algorithm than discovering it from nothing. I was asked to implement a sorting algorithm to sort unsigned integers. Couldn\\'t think of how merge sort works from blank so I implemented a count sort instead."
                    },
                    {
                        "username": "chandel0001",
                        "content": " class cmp\\n {   \\n     public:\\n     bool operator() (ListNode* a, ListNode* b)\\n     {\\n         return (a->val>b->val);\\n     }\\n };\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        priority_queue<ListNode*,vector<ListNode*>, cmp> q;\\n        ListNode* dummy = new ListNode(-1);\\n        ListNode* tail = dummy;\\n        for(int i=0;i<lists.size();i++)\\n        {\\n            if(lists[i]!=NULL)\\n            {\\n                q.push(lists[i]);\\n            }\\n        }\\n        while(q.size())\\n        {\\n            ListNode *temp = q.top();\\n            q.pop();\\n            tail->next = temp;\\n            tail = temp;\\n            if(temp->next!=NULL) q.push(temp->next); \\n        }\\n        return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#Python\\nclass Solution:\\n    def mergeKLists(self, lists):\\n        if len(lists) > 0:\\n            l = lists[0]\\n            for i in lists[1:]:\\n                l.extend(i)\\n            return sorted(l)\\n        else:\\n            return lists"
                    },
                    {
                        "username": "JoshuaCastelino",
                        "content": " `   \nfor list in lists:  \nprint(list)\n`\n`print(lists[0].val)`\n\n\nI have been having some issues with indexing, so I tried this out just to see what was happening. I am still getting\n\n IndexError: list index out of range\n    print(lists[0].val)\n\nWhat is going on?\n"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\n[https://www.gyangav.com/2022/11/leetcode-merge-k-sorted-lists-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-merge-k-sorted-lists-problem-solution.html)"
                    },
                    {
                        "username": "sd98754",
                        "content": "Is there any way or method in java Collection framework through which we can sort a singly Linked list directly as we do with lists. ex Collections.sort(lists);\\n\\nSingly Linked List 5-->4-->3-->2-->1\\nsort it is ascending order 1-->2-->3-->4-->5\\n"
                    },
                    {
                        "username": "Md-Ashik-Ali",
                        "content": "### **The Problem is very simple and it can be solved very easily with straight forward solution. Therefore this problem shoulbe be in *Easy* Category.**"
                    }
                ]
            },
            {
                "id": 1707291,
                "content": [
                    {
                        "username": "JoshuaMorris95",
                        "content": "When I first saw this problem I originally considered various options. But I thought I could save time by using a Priority Queue. I haven't solved many hard problems so far, but I was really happy to see that using a Priority Queue was an official solution.\n\nFor any JS users, I used the in-built library Leetcode provides for implementing a Priority Queue: https://github.com/datastructures-js/priority-queue"
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Tip :\\n- There\\'re two ways (i can think of) to solve this problem\\n   - Build up correct order while processing nodes\\n   - Get all the nodes, sort them, and relink\\n- First can be optimized to nlog(m) where m is the size of list, Second is nlog(n) which is not too bad imo.\\n- If you take the first approach, know that the provided list are sorted, technically only the first node matters for each iteration.\\n- Handle one node at a time, and move on to the next node.\\n- Dont forget null checks\\n\\nGood luck\\n"
                    },
                    {
                        "username": "swet_rajput",
                        "content": "it\\'s way complicated then I thought of."
                    },
                    {
                        "username": "lampuiho",
                        "content": "This problem is basically asking you merge sort algorithm except that you start somewhere in the middle. So that by itself is a hint as to how to implement the algorithm than discovering it from nothing. I was asked to implement a sorting algorithm to sort unsigned integers. Couldn\\'t think of how merge sort works from blank so I implemented a count sort instead."
                    },
                    {
                        "username": "chandel0001",
                        "content": " class cmp\\n {   \\n     public:\\n     bool operator() (ListNode* a, ListNode* b)\\n     {\\n         return (a->val>b->val);\\n     }\\n };\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        priority_queue<ListNode*,vector<ListNode*>, cmp> q;\\n        ListNode* dummy = new ListNode(-1);\\n        ListNode* tail = dummy;\\n        for(int i=0;i<lists.size();i++)\\n        {\\n            if(lists[i]!=NULL)\\n            {\\n                q.push(lists[i]);\\n            }\\n        }\\n        while(q.size())\\n        {\\n            ListNode *temp = q.top();\\n            q.pop();\\n            tail->next = temp;\\n            tail = temp;\\n            if(temp->next!=NULL) q.push(temp->next); \\n        }\\n        return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#Python\\nclass Solution:\\n    def mergeKLists(self, lists):\\n        if len(lists) > 0:\\n            l = lists[0]\\n            for i in lists[1:]:\\n                l.extend(i)\\n            return sorted(l)\\n        else:\\n            return lists"
                    },
                    {
                        "username": "JoshuaCastelino",
                        "content": " `   \nfor list in lists:  \nprint(list)\n`\n`print(lists[0].val)`\n\n\nI have been having some issues with indexing, so I tried this out just to see what was happening. I am still getting\n\n IndexError: list index out of range\n    print(lists[0].val)\n\nWhat is going on?\n"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\n[https://www.gyangav.com/2022/11/leetcode-merge-k-sorted-lists-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-merge-k-sorted-lists-problem-solution.html)"
                    },
                    {
                        "username": "sd98754",
                        "content": "Is there any way or method in java Collection framework through which we can sort a singly Linked list directly as we do with lists. ex Collections.sort(lists);\\n\\nSingly Linked List 5-->4-->3-->2-->1\\nsort it is ascending order 1-->2-->3-->4-->5\\n"
                    },
                    {
                        "username": "Md-Ashik-Ali",
                        "content": "### **The Problem is very simple and it can be solved very easily with straight forward solution. Therefore this problem shoulbe be in *Easy* Category.**"
                    }
                ]
            },
            {
                "id": 1703410,
                "content": [
                    {
                        "username": "JoshuaMorris95",
                        "content": "When I first saw this problem I originally considered various options. But I thought I could save time by using a Priority Queue. I haven't solved many hard problems so far, but I was really happy to see that using a Priority Queue was an official solution.\n\nFor any JS users, I used the in-built library Leetcode provides for implementing a Priority Queue: https://github.com/datastructures-js/priority-queue"
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Tip :\\n- There\\'re two ways (i can think of) to solve this problem\\n   - Build up correct order while processing nodes\\n   - Get all the nodes, sort them, and relink\\n- First can be optimized to nlog(m) where m is the size of list, Second is nlog(n) which is not too bad imo.\\n- If you take the first approach, know that the provided list are sorted, technically only the first node matters for each iteration.\\n- Handle one node at a time, and move on to the next node.\\n- Dont forget null checks\\n\\nGood luck\\n"
                    },
                    {
                        "username": "swet_rajput",
                        "content": "it\\'s way complicated then I thought of."
                    },
                    {
                        "username": "lampuiho",
                        "content": "This problem is basically asking you merge sort algorithm except that you start somewhere in the middle. So that by itself is a hint as to how to implement the algorithm than discovering it from nothing. I was asked to implement a sorting algorithm to sort unsigned integers. Couldn\\'t think of how merge sort works from blank so I implemented a count sort instead."
                    },
                    {
                        "username": "chandel0001",
                        "content": " class cmp\\n {   \\n     public:\\n     bool operator() (ListNode* a, ListNode* b)\\n     {\\n         return (a->val>b->val);\\n     }\\n };\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        priority_queue<ListNode*,vector<ListNode*>, cmp> q;\\n        ListNode* dummy = new ListNode(-1);\\n        ListNode* tail = dummy;\\n        for(int i=0;i<lists.size();i++)\\n        {\\n            if(lists[i]!=NULL)\\n            {\\n                q.push(lists[i]);\\n            }\\n        }\\n        while(q.size())\\n        {\\n            ListNode *temp = q.top();\\n            q.pop();\\n            tail->next = temp;\\n            tail = temp;\\n            if(temp->next!=NULL) q.push(temp->next); \\n        }\\n        return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#Python\\nclass Solution:\\n    def mergeKLists(self, lists):\\n        if len(lists) > 0:\\n            l = lists[0]\\n            for i in lists[1:]:\\n                l.extend(i)\\n            return sorted(l)\\n        else:\\n            return lists"
                    },
                    {
                        "username": "JoshuaCastelino",
                        "content": " `   \nfor list in lists:  \nprint(list)\n`\n`print(lists[0].val)`\n\n\nI have been having some issues with indexing, so I tried this out just to see what was happening. I am still getting\n\n IndexError: list index out of range\n    print(lists[0].val)\n\nWhat is going on?\n"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\n[https://www.gyangav.com/2022/11/leetcode-merge-k-sorted-lists-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-merge-k-sorted-lists-problem-solution.html)"
                    },
                    {
                        "username": "sd98754",
                        "content": "Is there any way or method in java Collection framework through which we can sort a singly Linked list directly as we do with lists. ex Collections.sort(lists);\\n\\nSingly Linked List 5-->4-->3-->2-->1\\nsort it is ascending order 1-->2-->3-->4-->5\\n"
                    },
                    {
                        "username": "Md-Ashik-Ali",
                        "content": "### **The Problem is very simple and it can be solved very easily with straight forward solution. Therefore this problem shoulbe be in *Easy* Category.**"
                    }
                ]
            },
            {
                "id": 1683079,
                "content": [
                    {
                        "username": "JoshuaMorris95",
                        "content": "When I first saw this problem I originally considered various options. But I thought I could save time by using a Priority Queue. I haven't solved many hard problems so far, but I was really happy to see that using a Priority Queue was an official solution.\n\nFor any JS users, I used the in-built library Leetcode provides for implementing a Priority Queue: https://github.com/datastructures-js/priority-queue"
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Tip :\\n- There\\'re two ways (i can think of) to solve this problem\\n   - Build up correct order while processing nodes\\n   - Get all the nodes, sort them, and relink\\n- First can be optimized to nlog(m) where m is the size of list, Second is nlog(n) which is not too bad imo.\\n- If you take the first approach, know that the provided list are sorted, technically only the first node matters for each iteration.\\n- Handle one node at a time, and move on to the next node.\\n- Dont forget null checks\\n\\nGood luck\\n"
                    },
                    {
                        "username": "swet_rajput",
                        "content": "it\\'s way complicated then I thought of."
                    },
                    {
                        "username": "lampuiho",
                        "content": "This problem is basically asking you merge sort algorithm except that you start somewhere in the middle. So that by itself is a hint as to how to implement the algorithm than discovering it from nothing. I was asked to implement a sorting algorithm to sort unsigned integers. Couldn\\'t think of how merge sort works from blank so I implemented a count sort instead."
                    },
                    {
                        "username": "chandel0001",
                        "content": " class cmp\\n {   \\n     public:\\n     bool operator() (ListNode* a, ListNode* b)\\n     {\\n         return (a->val>b->val);\\n     }\\n };\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        priority_queue<ListNode*,vector<ListNode*>, cmp> q;\\n        ListNode* dummy = new ListNode(-1);\\n        ListNode* tail = dummy;\\n        for(int i=0;i<lists.size();i++)\\n        {\\n            if(lists[i]!=NULL)\\n            {\\n                q.push(lists[i]);\\n            }\\n        }\\n        while(q.size())\\n        {\\n            ListNode *temp = q.top();\\n            q.pop();\\n            tail->next = temp;\\n            tail = temp;\\n            if(temp->next!=NULL) q.push(temp->next); \\n        }\\n        return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#Python\\nclass Solution:\\n    def mergeKLists(self, lists):\\n        if len(lists) > 0:\\n            l = lists[0]\\n            for i in lists[1:]:\\n                l.extend(i)\\n            return sorted(l)\\n        else:\\n            return lists"
                    },
                    {
                        "username": "JoshuaCastelino",
                        "content": " `   \nfor list in lists:  \nprint(list)\n`\n`print(lists[0].val)`\n\n\nI have been having some issues with indexing, so I tried this out just to see what was happening. I am still getting\n\n IndexError: list index out of range\n    print(lists[0].val)\n\nWhat is going on?\n"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\n[https://www.gyangav.com/2022/11/leetcode-merge-k-sorted-lists-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-merge-k-sorted-lists-problem-solution.html)"
                    },
                    {
                        "username": "sd98754",
                        "content": "Is there any way or method in java Collection framework through which we can sort a singly Linked list directly as we do with lists. ex Collections.sort(lists);\\n\\nSingly Linked List 5-->4-->3-->2-->1\\nsort it is ascending order 1-->2-->3-->4-->5\\n"
                    },
                    {
                        "username": "Md-Ashik-Ali",
                        "content": "### **The Problem is very simple and it can be solved very easily with straight forward solution. Therefore this problem shoulbe be in *Easy* Category.**"
                    }
                ]
            },
            {
                "id": 1679976,
                "content": [
                    {
                        "username": "JoshuaMorris95",
                        "content": "When I first saw this problem I originally considered various options. But I thought I could save time by using a Priority Queue. I haven't solved many hard problems so far, but I was really happy to see that using a Priority Queue was an official solution.\n\nFor any JS users, I used the in-built library Leetcode provides for implementing a Priority Queue: https://github.com/datastructures-js/priority-queue"
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Tip :\\n- There\\'re two ways (i can think of) to solve this problem\\n   - Build up correct order while processing nodes\\n   - Get all the nodes, sort them, and relink\\n- First can be optimized to nlog(m) where m is the size of list, Second is nlog(n) which is not too bad imo.\\n- If you take the first approach, know that the provided list are sorted, technically only the first node matters for each iteration.\\n- Handle one node at a time, and move on to the next node.\\n- Dont forget null checks\\n\\nGood luck\\n"
                    },
                    {
                        "username": "swet_rajput",
                        "content": "it\\'s way complicated then I thought of."
                    },
                    {
                        "username": "lampuiho",
                        "content": "This problem is basically asking you merge sort algorithm except that you start somewhere in the middle. So that by itself is a hint as to how to implement the algorithm than discovering it from nothing. I was asked to implement a sorting algorithm to sort unsigned integers. Couldn\\'t think of how merge sort works from blank so I implemented a count sort instead."
                    },
                    {
                        "username": "chandel0001",
                        "content": " class cmp\\n {   \\n     public:\\n     bool operator() (ListNode* a, ListNode* b)\\n     {\\n         return (a->val>b->val);\\n     }\\n };\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        priority_queue<ListNode*,vector<ListNode*>, cmp> q;\\n        ListNode* dummy = new ListNode(-1);\\n        ListNode* tail = dummy;\\n        for(int i=0;i<lists.size();i++)\\n        {\\n            if(lists[i]!=NULL)\\n            {\\n                q.push(lists[i]);\\n            }\\n        }\\n        while(q.size())\\n        {\\n            ListNode *temp = q.top();\\n            q.pop();\\n            tail->next = temp;\\n            tail = temp;\\n            if(temp->next!=NULL) q.push(temp->next); \\n        }\\n        return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#Python\\nclass Solution:\\n    def mergeKLists(self, lists):\\n        if len(lists) > 0:\\n            l = lists[0]\\n            for i in lists[1:]:\\n                l.extend(i)\\n            return sorted(l)\\n        else:\\n            return lists"
                    },
                    {
                        "username": "JoshuaCastelino",
                        "content": " `   \nfor list in lists:  \nprint(list)\n`\n`print(lists[0].val)`\n\n\nI have been having some issues with indexing, so I tried this out just to see what was happening. I am still getting\n\n IndexError: list index out of range\n    print(lists[0].val)\n\nWhat is going on?\n"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\n[https://www.gyangav.com/2022/11/leetcode-merge-k-sorted-lists-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-merge-k-sorted-lists-problem-solution.html)"
                    },
                    {
                        "username": "sd98754",
                        "content": "Is there any way or method in java Collection framework through which we can sort a singly Linked list directly as we do with lists. ex Collections.sort(lists);\\n\\nSingly Linked List 5-->4-->3-->2-->1\\nsort it is ascending order 1-->2-->3-->4-->5\\n"
                    },
                    {
                        "username": "Md-Ashik-Ali",
                        "content": "### **The Problem is very simple and it can be solved very easily with straight forward solution. Therefore this problem shoulbe be in *Easy* Category.**"
                    }
                ]
            },
            {
                "id": 1673501,
                "content": [
                    {
                        "username": "JoshuaMorris95",
                        "content": "When I first saw this problem I originally considered various options. But I thought I could save time by using a Priority Queue. I haven't solved many hard problems so far, but I was really happy to see that using a Priority Queue was an official solution.\n\nFor any JS users, I used the in-built library Leetcode provides for implementing a Priority Queue: https://github.com/datastructures-js/priority-queue"
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Tip :\\n- There\\'re two ways (i can think of) to solve this problem\\n   - Build up correct order while processing nodes\\n   - Get all the nodes, sort them, and relink\\n- First can be optimized to nlog(m) where m is the size of list, Second is nlog(n) which is not too bad imo.\\n- If you take the first approach, know that the provided list are sorted, technically only the first node matters for each iteration.\\n- Handle one node at a time, and move on to the next node.\\n- Dont forget null checks\\n\\nGood luck\\n"
                    },
                    {
                        "username": "swet_rajput",
                        "content": "it\\'s way complicated then I thought of."
                    },
                    {
                        "username": "lampuiho",
                        "content": "This problem is basically asking you merge sort algorithm except that you start somewhere in the middle. So that by itself is a hint as to how to implement the algorithm than discovering it from nothing. I was asked to implement a sorting algorithm to sort unsigned integers. Couldn\\'t think of how merge sort works from blank so I implemented a count sort instead."
                    },
                    {
                        "username": "chandel0001",
                        "content": " class cmp\\n {   \\n     public:\\n     bool operator() (ListNode* a, ListNode* b)\\n     {\\n         return (a->val>b->val);\\n     }\\n };\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        priority_queue<ListNode*,vector<ListNode*>, cmp> q;\\n        ListNode* dummy = new ListNode(-1);\\n        ListNode* tail = dummy;\\n        for(int i=0;i<lists.size();i++)\\n        {\\n            if(lists[i]!=NULL)\\n            {\\n                q.push(lists[i]);\\n            }\\n        }\\n        while(q.size())\\n        {\\n            ListNode *temp = q.top();\\n            q.pop();\\n            tail->next = temp;\\n            tail = temp;\\n            if(temp->next!=NULL) q.push(temp->next); \\n        }\\n        return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#Python\\nclass Solution:\\n    def mergeKLists(self, lists):\\n        if len(lists) > 0:\\n            l = lists[0]\\n            for i in lists[1:]:\\n                l.extend(i)\\n            return sorted(l)\\n        else:\\n            return lists"
                    },
                    {
                        "username": "JoshuaCastelino",
                        "content": " `   \nfor list in lists:  \nprint(list)\n`\n`print(lists[0].val)`\n\n\nI have been having some issues with indexing, so I tried this out just to see what was happening. I am still getting\n\n IndexError: list index out of range\n    print(lists[0].val)\n\nWhat is going on?\n"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\n[https://www.gyangav.com/2022/11/leetcode-merge-k-sorted-lists-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-merge-k-sorted-lists-problem-solution.html)"
                    },
                    {
                        "username": "sd98754",
                        "content": "Is there any way or method in java Collection framework through which we can sort a singly Linked list directly as we do with lists. ex Collections.sort(lists);\\n\\nSingly Linked List 5-->4-->3-->2-->1\\nsort it is ascending order 1-->2-->3-->4-->5\\n"
                    },
                    {
                        "username": "Md-Ashik-Ali",
                        "content": "### **The Problem is very simple and it can be solved very easily with straight forward solution. Therefore this problem shoulbe be in *Easy* Category.**"
                    }
                ]
            },
            {
                "id": 1671278,
                "content": [
                    {
                        "username": "JoshuaMorris95",
                        "content": "When I first saw this problem I originally considered various options. But I thought I could save time by using a Priority Queue. I haven't solved many hard problems so far, but I was really happy to see that using a Priority Queue was an official solution.\n\nFor any JS users, I used the in-built library Leetcode provides for implementing a Priority Queue: https://github.com/datastructures-js/priority-queue"
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Tip :\\n- There\\'re two ways (i can think of) to solve this problem\\n   - Build up correct order while processing nodes\\n   - Get all the nodes, sort them, and relink\\n- First can be optimized to nlog(m) where m is the size of list, Second is nlog(n) which is not too bad imo.\\n- If you take the first approach, know that the provided list are sorted, technically only the first node matters for each iteration.\\n- Handle one node at a time, and move on to the next node.\\n- Dont forget null checks\\n\\nGood luck\\n"
                    },
                    {
                        "username": "swet_rajput",
                        "content": "it\\'s way complicated then I thought of."
                    },
                    {
                        "username": "lampuiho",
                        "content": "This problem is basically asking you merge sort algorithm except that you start somewhere in the middle. So that by itself is a hint as to how to implement the algorithm than discovering it from nothing. I was asked to implement a sorting algorithm to sort unsigned integers. Couldn\\'t think of how merge sort works from blank so I implemented a count sort instead."
                    },
                    {
                        "username": "chandel0001",
                        "content": " class cmp\\n {   \\n     public:\\n     bool operator() (ListNode* a, ListNode* b)\\n     {\\n         return (a->val>b->val);\\n     }\\n };\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        priority_queue<ListNode*,vector<ListNode*>, cmp> q;\\n        ListNode* dummy = new ListNode(-1);\\n        ListNode* tail = dummy;\\n        for(int i=0;i<lists.size();i++)\\n        {\\n            if(lists[i]!=NULL)\\n            {\\n                q.push(lists[i]);\\n            }\\n        }\\n        while(q.size())\\n        {\\n            ListNode *temp = q.top();\\n            q.pop();\\n            tail->next = temp;\\n            tail = temp;\\n            if(temp->next!=NULL) q.push(temp->next); \\n        }\\n        return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#Python\\nclass Solution:\\n    def mergeKLists(self, lists):\\n        if len(lists) > 0:\\n            l = lists[0]\\n            for i in lists[1:]:\\n                l.extend(i)\\n            return sorted(l)\\n        else:\\n            return lists"
                    },
                    {
                        "username": "JoshuaCastelino",
                        "content": " `   \nfor list in lists:  \nprint(list)\n`\n`print(lists[0].val)`\n\n\nI have been having some issues with indexing, so I tried this out just to see what was happening. I am still getting\n\n IndexError: list index out of range\n    print(lists[0].val)\n\nWhat is going on?\n"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\n[https://www.gyangav.com/2022/11/leetcode-merge-k-sorted-lists-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-merge-k-sorted-lists-problem-solution.html)"
                    },
                    {
                        "username": "sd98754",
                        "content": "Is there any way or method in java Collection framework through which we can sort a singly Linked list directly as we do with lists. ex Collections.sort(lists);\\n\\nSingly Linked List 5-->4-->3-->2-->1\\nsort it is ascending order 1-->2-->3-->4-->5\\n"
                    },
                    {
                        "username": "Md-Ashik-Ali",
                        "content": "### **The Problem is very simple and it can be solved very easily with straight forward solution. Therefore this problem shoulbe be in *Easy* Category.**"
                    }
                ]
            },
            {
                "id": 1629408,
                "content": [
                    {
                        "username": "JoshuaMorris95",
                        "content": "When I first saw this problem I originally considered various options. But I thought I could save time by using a Priority Queue. I haven't solved many hard problems so far, but I was really happy to see that using a Priority Queue was an official solution.\n\nFor any JS users, I used the in-built library Leetcode provides for implementing a Priority Queue: https://github.com/datastructures-js/priority-queue"
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Tip :\\n- There\\'re two ways (i can think of) to solve this problem\\n   - Build up correct order while processing nodes\\n   - Get all the nodes, sort them, and relink\\n- First can be optimized to nlog(m) where m is the size of list, Second is nlog(n) which is not too bad imo.\\n- If you take the first approach, know that the provided list are sorted, technically only the first node matters for each iteration.\\n- Handle one node at a time, and move on to the next node.\\n- Dont forget null checks\\n\\nGood luck\\n"
                    },
                    {
                        "username": "swet_rajput",
                        "content": "it\\'s way complicated then I thought of."
                    },
                    {
                        "username": "lampuiho",
                        "content": "This problem is basically asking you merge sort algorithm except that you start somewhere in the middle. So that by itself is a hint as to how to implement the algorithm than discovering it from nothing. I was asked to implement a sorting algorithm to sort unsigned integers. Couldn\\'t think of how merge sort works from blank so I implemented a count sort instead."
                    },
                    {
                        "username": "chandel0001",
                        "content": " class cmp\\n {   \\n     public:\\n     bool operator() (ListNode* a, ListNode* b)\\n     {\\n         return (a->val>b->val);\\n     }\\n };\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        priority_queue<ListNode*,vector<ListNode*>, cmp> q;\\n        ListNode* dummy = new ListNode(-1);\\n        ListNode* tail = dummy;\\n        for(int i=0;i<lists.size();i++)\\n        {\\n            if(lists[i]!=NULL)\\n            {\\n                q.push(lists[i]);\\n            }\\n        }\\n        while(q.size())\\n        {\\n            ListNode *temp = q.top();\\n            q.pop();\\n            tail->next = temp;\\n            tail = temp;\\n            if(temp->next!=NULL) q.push(temp->next); \\n        }\\n        return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#Python\\nclass Solution:\\n    def mergeKLists(self, lists):\\n        if len(lists) > 0:\\n            l = lists[0]\\n            for i in lists[1:]:\\n                l.extend(i)\\n            return sorted(l)\\n        else:\\n            return lists"
                    },
                    {
                        "username": "JoshuaCastelino",
                        "content": " `   \nfor list in lists:  \nprint(list)\n`\n`print(lists[0].val)`\n\n\nI have been having some issues with indexing, so I tried this out just to see what was happening. I am still getting\n\n IndexError: list index out of range\n    print(lists[0].val)\n\nWhat is going on?\n"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\n[https://www.gyangav.com/2022/11/leetcode-merge-k-sorted-lists-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-merge-k-sorted-lists-problem-solution.html)"
                    },
                    {
                        "username": "sd98754",
                        "content": "Is there any way or method in java Collection framework through which we can sort a singly Linked list directly as we do with lists. ex Collections.sort(lists);\\n\\nSingly Linked List 5-->4-->3-->2-->1\\nsort it is ascending order 1-->2-->3-->4-->5\\n"
                    },
                    {
                        "username": "Md-Ashik-Ali",
                        "content": "### **The Problem is very simple and it can be solved very easily with straight forward solution. Therefore this problem shoulbe be in *Easy* Category.**"
                    }
                ]
            },
            {
                "id": 1576407,
                "content": [
                    {
                        "username": "JoshuaMorris95",
                        "content": "When I first saw this problem I originally considered various options. But I thought I could save time by using a Priority Queue. I haven't solved many hard problems so far, but I was really happy to see that using a Priority Queue was an official solution.\n\nFor any JS users, I used the in-built library Leetcode provides for implementing a Priority Queue: https://github.com/datastructures-js/priority-queue"
                    },
                    {
                        "username": "Zhe_FunCoding",
                        "content": "Tip :\\n- There\\'re two ways (i can think of) to solve this problem\\n   - Build up correct order while processing nodes\\n   - Get all the nodes, sort them, and relink\\n- First can be optimized to nlog(m) where m is the size of list, Second is nlog(n) which is not too bad imo.\\n- If you take the first approach, know that the provided list are sorted, technically only the first node matters for each iteration.\\n- Handle one node at a time, and move on to the next node.\\n- Dont forget null checks\\n\\nGood luck\\n"
                    },
                    {
                        "username": "swet_rajput",
                        "content": "it\\'s way complicated then I thought of."
                    },
                    {
                        "username": "lampuiho",
                        "content": "This problem is basically asking you merge sort algorithm except that you start somewhere in the middle. So that by itself is a hint as to how to implement the algorithm than discovering it from nothing. I was asked to implement a sorting algorithm to sort unsigned integers. Couldn\\'t think of how merge sort works from blank so I implemented a count sort instead."
                    },
                    {
                        "username": "chandel0001",
                        "content": " class cmp\\n {   \\n     public:\\n     bool operator() (ListNode* a, ListNode* b)\\n     {\\n         return (a->val>b->val);\\n     }\\n };\\nclass Solution {\\npublic:\\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\\n        priority_queue<ListNode*,vector<ListNode*>, cmp> q;\\n        ListNode* dummy = new ListNode(-1);\\n        ListNode* tail = dummy;\\n        for(int i=0;i<lists.size();i++)\\n        {\\n            if(lists[i]!=NULL)\\n            {\\n                q.push(lists[i]);\\n            }\\n        }\\n        while(q.size())\\n        {\\n            ListNode *temp = q.top();\\n            q.pop();\\n            tail->next = temp;\\n            tail = temp;\\n            if(temp->next!=NULL) q.push(temp->next); \\n        }\\n        return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Sergii_Beshliaga",
                        "content": "#Python\\nclass Solution:\\n    def mergeKLists(self, lists):\\n        if len(lists) > 0:\\n            l = lists[0]\\n            for i in lists[1:]:\\n                l.extend(i)\\n            return sorted(l)\\n        else:\\n            return lists"
                    },
                    {
                        "username": "JoshuaCastelino",
                        "content": " `   \nfor list in lists:  \nprint(list)\n`\n`print(lists[0].val)`\n\n\nI have been having some issues with indexing, so I tried this out just to see what was happening. I am still getting\n\n IndexError: list index out of range\n    print(lists[0].val)\n\nWhat is going on?\n"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\n[https://www.gyangav.com/2022/11/leetcode-merge-k-sorted-lists-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-merge-k-sorted-lists-problem-solution.html)"
                    },
                    {
                        "username": "sd98754",
                        "content": "Is there any way or method in java Collection framework through which we can sort a singly Linked list directly as we do with lists. ex Collections.sort(lists);\\n\\nSingly Linked List 5-->4-->3-->2-->1\\nsort it is ascending order 1-->2-->3-->4-->5\\n"
                    },
                    {
                        "username": "Md-Ashik-Ali",
                        "content": "### **The Problem is very simple and it can be solved very easily with straight forward solution. Therefore this problem shoulbe be in *Easy* Category.**"
                    }
                ]
            }
        ]
    },
    {
        "title": "Best Time to Buy and Sell Stock III",
        "question_content": "<p>You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>i<sup>th</sup></code> day.</p>\n\n<p>Find the maximum profit you can achieve. You may complete <strong>at most two transactions</strong>.</p>\n\n<p><strong>Note:</strong> You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> prices = [3,3,5,0,0,3,1,4]\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\nThen buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> prices = [1,2,3,4,5]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nNote that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> prices = [7,6,4,3,1]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> In this case, no transaction is done, i.e. max profit = 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= prices.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= prices[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 135704,
                "title": "detail-explanation-of-dp-solution",
                "content": "It\\'s not difficult to get the DP recursive formula:\\n```\\ndp[k, i] = max(dp[k, i-1], prices[i] - prices[j] + dp[k-1, j-1]), j=[0..i-1]\\n```\\nFor k transactions, on i-th day, \\nif we don\\'t trade then the profit is same as previous day dp[k, i-1]; \\nand if we bought the share on j-th day where j=[0..i-1], then sell the share on i-th day then the profit is prices[i] - prices[j] + dp[k-1, j-1] .\\nActually j can be i as well. When j is i, the one more extra item prices[i] - prices[j] + dp[k-1, j] = dp[k-1, i] looks like we just lose one chance of transaction.\\n\\nI see someone else use the formula dp[k, i] = max(dp[k, i-1], prices[i] - prices[j] + dp[k-1, j]), where the last one is dp[k-1, j] instead of dp[k-1, j-1]. It\\'s not the direct sense, as if the share was bought on j-th day, then the total profit of previous transactions should be done on (j-1)th day. However, the result based on that formula is also correct, because if the share was sold on j-th day and then bought again, it is the same if we didn\\'t trade on that day.\\n\\nSo the straigtforward implementation is:\\n```\\n        public int MaxProfitDp(int[] prices) {\\n            if (prices.Length == 0) return 0;\\n            var dp = new int[3, prices.Length];\\n            for (int k = 1; k <= 2; k++)  {\\n                for (int i = 1; i < prices.Length; i++) {\\n                    int min = prices[0];\\n                    for (int j = 1; j <= i; j++)\\n                        min = Math.Min(min, prices[j] - dp[k-1, j-1]);\\n                    dp[k, i] = Math.Max(dp[k, i-1], prices[i] - min);\\n                }\\n            }\\n\\n            return dp[2, prices.Length - 1];\\n        }\\n```\\nTime complexity is O(kn^2), space complexity is O(kn).\\nIn the above code, min is repeated calculated. It can be easily improved as:\\n```\\n        public int MaxProfitDpCompact1(int[] prices) {\\n            if (prices.Length == 0) return 0;\\n            var dp = new int[3, prices.Length];\\n            for (int k = 1; k <= 2; k++) {\\n                int min = prices[0];\\n                for (int i = 1; i < prices.Length; i++) {\\n                    min = Math.Min(min, prices[i] - dp[k-1, i-1]);\\n                    dp[k, i] = Math.Max(dp[k, i-1], prices[i] - min);\\n                }\\n            }\\n\\n            return dp[2, prices.Length - 1];\\n        }\\n```\\nTime complexity is O(kn), space complexity is O(kn).\\nIf we slight swap the two \\'for\\' loops:\\n```\\n        public int MaxProfitDpCompact1T(int[] prices) {\\n            if (prices.Length == 0) return 0;\\n            var dp = new int[3, prices.Length];\\n            var min = new int[3];\\n            Array.Fill(min, prices[0]);\\n            for (int i = 1; i < prices.Length; i++) {\\n                for (int k = 1; k <= 2; k++) {\\n                    min[k] = Math.Min(min[k], prices[i] - dp[k-1, i-1]);\\n                    dp[k, i] = Math.Max(dp[k, i-1], prices[i] - min[k]);\\n                }\\n            }\\n\\n            return dp[2, prices.Length - 1];\\n        }\\n```\\t\\t\\t\\t\\nWe need to save min for each transaction, so there are k \\'min\\'.\\nWe can find the second dimension (variable i) is only dependent on the previous one (i-1), so we can compact this dimension. (We can choose the first dimension (variable k) as well since it is also only dependent on its previous one k-1, but can\\'t compact both.)\\n```\\n        public int MaxProfitDpCompact2(int[] prices) {\\n            if (prices.Length == 0) return 0;\\n            var dp = new int[3];\\n            var min = new int[3];\\n            Array.Fill(min, prices[0]);\\n            for (int i = 1; i < prices.Length; i++)  {\\n                for (int k = 1; k <= 2; k++) {\\n                    min[k] = Math.Min(min[k], prices[i] - dp[k-1]);\\n                    dp[k] = Math.Max(dp[k], prices[i] - min[k]);\\n                }\\n            }\\n\\n            return dp[2];\\n        }\\n```\\nSo time complexity is O(kn), space complexity becomes O(k).\\nIn this case, K is 2. We can expand the array to all named variables:\\n```\\n        public int MaxProfitDpCompactFinal(int[] prices)  {\\n            int buy1 = int.MaxValue, buy2 = int.MaxValue;\\n            int sell1 = 0, sell2 = 0;\\n\\n            for (int i = 0; i < prices.Length; i++) {\\n                buy1 = Math.Min(buy1, prices[i]);\\n                sell1 = Math.Max(sell1, prices[i] - buy1);\\n                buy2 = Math.Min(buy2, prices[i] - sell1);\\n                sell2 = Math.Max(sell2, prices[i] - buy2);\\n            }\\n\\n            return sell2;\\n        }\\n```\\nWe can also explain the above codes in other words. On every day, we buy the share with the price as low as we can, and sell the share with price as high as we can. For the second transaction, we integrate the profit of first transaction into the cost of the second buy, then the profit of the second sell will be the total profit of two transactions.\\n",
                "solutionTags": [],
                "code": "```\\ndp[k, i] = max(dp[k, i-1], prices[i] - prices[j] + dp[k-1, j-1]), j=[0..i-1]\\n```\n```\\n        public int MaxProfitDp(int[] prices) {\\n            if (prices.Length == 0) return 0;\\n            var dp = new int[3, prices.Length];\\n            for (int k = 1; k <= 2; k++)  {\\n                for (int i = 1; i < prices.Length; i++) {\\n                    int min = prices[0];\\n                    for (int j = 1; j <= i; j++)\\n                        min = Math.Min(min, prices[j] - dp[k-1, j-1]);\\n                    dp[k, i] = Math.Max(dp[k, i-1], prices[i] - min);\\n                }\\n            }\\n\\n            return dp[2, prices.Length - 1];\\n        }\\n```\n```\\n        public int MaxProfitDpCompact1(int[] prices) {\\n            if (prices.Length == 0) return 0;\\n            var dp = new int[3, prices.Length];\\n            for (int k = 1; k <= 2; k++) {\\n                int min = prices[0];\\n                for (int i = 1; i < prices.Length; i++) {\\n                    min = Math.Min(min, prices[i] - dp[k-1, i-1]);\\n                    dp[k, i] = Math.Max(dp[k, i-1], prices[i] - min);\\n                }\\n            }\\n\\n            return dp[2, prices.Length - 1];\\n        }\\n```\n```\\n        public int MaxProfitDpCompact1T(int[] prices) {\\n            if (prices.Length == 0) return 0;\\n            var dp = new int[3, prices.Length];\\n            var min = new int[3];\\n            Array.Fill(min, prices[0]);\\n            for (int i = 1; i < prices.Length; i++) {\\n                for (int k = 1; k <= 2; k++) {\\n                    min[k] = Math.Min(min[k], prices[i] - dp[k-1, i-1]);\\n                    dp[k, i] = Math.Max(dp[k, i-1], prices[i] - min[k]);\\n                }\\n            }\\n\\n            return dp[2, prices.Length - 1];\\n        }\\n```\n```\\n        public int MaxProfitDpCompact2(int[] prices) {\\n            if (prices.Length == 0) return 0;\\n            var dp = new int[3];\\n            var min = new int[3];\\n            Array.Fill(min, prices[0]);\\n            for (int i = 1; i < prices.Length; i++)  {\\n                for (int k = 1; k <= 2; k++) {\\n                    min[k] = Math.Min(min[k], prices[i] - dp[k-1]);\\n                    dp[k] = Math.Max(dp[k], prices[i] - min[k]);\\n                }\\n            }\\n\\n            return dp[2];\\n        }\\n```\n```\\n        public int MaxProfitDpCompactFinal(int[] prices)  {\\n            int buy1 = int.MaxValue, buy2 = int.MaxValue;\\n            int sell1 = 0, sell2 = 0;\\n\\n            for (int i = 0; i < prices.Length; i++) {\\n                buy1 = Math.Min(buy1, prices[i]);\\n                sell1 = Math.Max(sell1, prices[i] - buy1);\\n                buy2 = Math.Min(buy2, prices[i] - sell1);\\n                sell2 = Math.Max(sell2, prices[i] - buy2);\\n            }\\n\\n            return sell2;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 39611,
                "title": "is-it-best-solution-with-o-n-o-1",
                "content": "The thinking is simple and is inspired by the best solution from Single Number II (I read through the discussion after I use DP). \\nAssume we only have 0 money at first;\\n4 Variables to maintain some interested 'ceilings' so far:\\nThe maximum of if we've just buy 1st stock, if we've just sold 1nd stock, if we've just buy  2nd stock, if we've just sold 2nd stock.\\nVery simple code too and work well. I have to say the logic is simple than those in Single Number II.\\n\\n    public class Solution {\\n        public int maxProfit(int[] prices) {\\n            int hold1 = Integer.MIN_VALUE, hold2 = Integer.MIN_VALUE;\\n            int release1 = 0, release2 = 0;\\n            for(int i:prices){                              // Assume we only have 0 money at first\\n                release2 = Math.max(release2, hold2+i);     // The maximum if we've just sold 2nd stock so far.\\n                hold2    = Math.max(hold2,    release1-i);  // The maximum if we've just buy  2nd stock so far.\\n                release1 = Math.max(release1, hold1+i);     // The maximum if we've just sold 1nd stock so far.\\n                hold1    = Math.max(hold1,    -i);          // The maximum if we've just buy  1st stock so far. \\n            }\\n            return release2; ///Since release1 is initiated as 0, so release2 will always higher than release1.\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int maxProfit(int[] prices) {\\n            int hold1 = Integer.MIN_VALUE, hold2 = Integer.MIN_VALUE;\\n            int release1 = 0, release2 = 0;\\n            for(int i:prices){                              // Assume we only have 0 money at first\\n                release2 = Math.max(release2, hold2+i);     // The maximum if we've just sold 2nd stock so far.\\n                hold2    = Math.max(hold2,    release1-i);  // The maximum if we've just buy  2nd stock so far.\\n                release1 = Math.max(release1, hold1+i);     // The maximum if we've just sold 1nd stock so far.\\n                hold1    = Math.max(hold1,    -i);          // The maximum if we've just buy  1st stock so far. \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 39608,
                "title": "a-clean-dp-solution-which-generalizes-to-k-transactions",
                "content": "Solution is commented in the code. Time complexity is O(k*n), space complexity can be O(n) because this DP only uses the result from last step. But for cleaness this solution still used O(k*n) space complexity to preserve similarity to the equations in the comments.\\n\\n    class Solution {\\n    public:\\n        int maxProfit(vector<int> &prices) {\\n            // f[k, ii] represents the max profit up until prices[ii] (Note: NOT ending with prices[ii]) using at most k transactions. \\n            // f[k, ii] = max(f[k, ii-1], prices[ii] - prices[jj] + f[k-1, jj]) { jj in range of [0, ii-1] }\\n            //          = max(f[k, ii-1], prices[ii] + max(f[k-1, jj] - prices[jj]))\\n            // f[0, ii] = 0; 0 times transation makes 0 profit\\n            // f[k, 0] = 0; if there is only one price data point you can't make any money no matter how many times you can trade\\n            if (prices.size() <= 1) return 0;\\n            else {\\n                int K = 2; // number of max transation allowed\\n                int maxProf = 0;\\n                vector<vector<int>> f(K+1, vector<int>(prices.size(), 0));\\n                for (int kk = 1; kk <= K; kk++) {\\n                    int tmpMax = f[kk-1][0] - prices[0];\\n                    for (int ii = 1; ii < prices.size(); ii++) {\\n                        f[kk][ii] = max(f[kk][ii-1], prices[ii] + tmpMax);\\n                        tmpMax = max(tmpMax, f[kk-1][ii] - prices[ii]);\\n                        maxProf = max(f[kk][ii], maxProf);\\n                    }\\n                }\\n                return maxProf;\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maxProfit(vector<int> &prices) {\\n            // f[k, ii] represents the max profit up until prices[ii] (Note: NOT ending with prices[ii]) using at most k transactions. \\n            // f[k, ii] = max(f[k, ii-1], prices[ii] - prices[jj] + f[k-1, jj]) { jj in range of [0, ii-1] }",
                "codeTag": "Java"
            },
            {
                "id": 149383,
                "title": "easy-dp-solution-using-state-machine-o-n-time-complexity-o-1-space-complexity",
                "content": "**O(n) time complexity, O(1) space solution using State Machine and DP**\\n\\nThis approach can be used for all the problems based on stock prices.\\n\\nThe idea is to design a state machine that correctly describes the problem statement. \\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/shetty4l/image_1531523120.png)\\n\\n**Intuition behind the state diagram:**\\nWe begin at state `0`, where we can either rest (i.e. do nothing) or buy stock at a given price. \\n* If we choose to rest, we remain in state `0`\\n* If we buy, we spend some money (price of the stock on that day) and go to state `1`\\n\\nFrom state `1`, we can once again choose to do nothing or we can sell our stock.\\n* If we choose to rest, we remain in state `1`\\n* If we sell, we earn some money (price of the stock on that day) and go to state `2`\\n\\nThis completes one transaction for us. Remember, we can only do _atmost_ 2 transactions.\\n\\nFrom state `2`, we can choose to do nothing or buy more stock.\\n* If we choose to rest, we remain in state `2`\\n* If we buy, we go to state `3`\\n\\nFrom state `3`, we can once again choose to do nothing or we can sell our stock for the last time.\\n* If we choose to rest, we remain in state `3`\\n* If we sell, we have utilized our allowed transactions and reach the final state `4`\\n\\n**Going from the state diagram to code**\\n```cpp\\n// Assume we are in state S\\n// If we buy, we are spending money but we can also choose to do nothing\\n// Doing nothing means going from S->S\\n// Buying means going from some state X->S, losing some money in the process\\nS = max(S, X-prices[i])\\n\\n// Similarly, for selling a stock\\nS = max(S, X+prices[i])\\n```\\n\\n**Code:**\\n```cpp\\nint maxProfit(vector<int>& prices) {\\n\\tif(prices.empty()) return 0;\\n\\tint s1=-prices[0],s2=INT_MIN,s3=INT_MIN,s4=INT_MIN;\\n        \\n\\tfor(int i=1;i<prices.size();++i) {            \\n\\t\\ts1 = max(s1, -prices[i]);\\n\\t\\ts2 = max(s2, s1+prices[i]);\\n\\t\\ts3 = max(s3, s2-prices[i]);\\n\\t\\ts4 = max(s4, s3+prices[i]);\\n\\t}\\n\\treturn max(0,s4);\\n}\\n```\\n\\nWe can create 4 variables, one for each state excluding the initial state since that\\'s always 0, initializing `s1` to `-prices[0]` and the rest to `INT_MIN` since they will get overwritten later.\\n\\nTo reach `s1`, we either stay in `s1` or we buy stock for the first time.\\nTo reach `s2`, we either stay in `s2` or we sell from `s1` and come to `s2`\\nSimilarly for `s3` and `s4`.\\n\\nIn the end, we return `s4` or more accurately, `max(0,s4)` since we initialize `s4` to `INT_MIN`.\\n\\nThis idea works for all problems on stocks, as long as our state diagram is correct, we can code it up like this.\\n\\nSide Note: Technically, this is a dynammic programming approach and we should actually be doing `s2[i] = max(s2[i-1], s1[i-1]+prices[i])` but we can be rest assured that the overwritten value of `s1` will always be better than the previous one and hence we do not need temporary variables.",
                "solutionTags": [],
                "code": "```cpp\\n// Assume we are in state S\\n// If we buy, we are spending money but we can also choose to do nothing\\n// Doing nothing means going from S->S\\n// Buying means going from some state X->S, losing some money in the process\\nS = max(S, X-prices[i])\\n\\n// Similarly, for selling a stock\\nS = max(S, X+prices[i])\\n```\n```cpp\\nint maxProfit(vector<int>& prices) {\\n\\tif(prices.empty()) return 0;\\n\\tint s1=-prices[0],s2=INT_MIN,s3=INT_MIN,s4=INT_MIN;\\n        \\n\\tfor(int i=1;i<prices.size();++i) {            \\n\\t\\ts1 = max(s1, -prices[i]);\\n\\t\\ts2 = max(s2, s1+prices[i]);\\n\\t\\ts3 = max(s3, s2-prices[i]);\\n\\t\\ts4 = max(s4, s3+prices[i]);\\n\\t}\\n\\treturn max(0,s4);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 39615,
                "title": "my-explanation-for-o-n-solution",
                "content": "First assume that we have no money, so buy1 means that we have to borrow money from others,  we want to borrow less so that we have to make our balance as max as we can(because this is negative).\\n\\nsell1 means we decide to sell the stock, after selling it we have price[i] money and we have to give back the money we owed, so we have price[i] - |buy1| = prices[i ] + buy1, we want to make this max.\\n\\nbuy2 means we want to buy another stock, we already have sell1 money, so after buying stock2 we have buy2 = sell1 - price[i] money left, we want more money left, so we make it max\\n\\nsell2 means we want to sell stock2, we can have price[i] money after selling it, and we have buy2 money left before, so sell2 = buy2 + prices[i], we make this max.\\n\\nSo sell2 is the most money we can have.\\n\\nHope it is helpful and welcome quesions!\\n\\n    public int maxProfit(int[] prices) {\\n    \\t\\tint sell1 = 0, sell2 = 0, buy1 = Integer.MIN_VALUE, buy2 = Integer.MIN_VALUE;\\n    \\t\\tfor (int i = 0; i < prices.length; i++) {\\n    \\t\\t\\tbuy1 = Math.max(buy1, -prices[i]);\\n    \\t\\t\\tsell1 = Math.max(sell1, buy1 + prices[i]);\\n    \\t\\t\\tbuy2 = Math.max(buy2, sell1 - prices[i]);\\n    \\t\\t\\tsell2 = Math.max(sell2, buy2 + prices[i]);\\n    \\t\\t}\\n    \\t\\treturn sell2;\\n    \\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "First assume that we have no money, so buy1 means that we have to borrow money from others,  we want to borrow less so that we have to make our balance as max as we can(because this is negative).\\n\\nsell1 means we decide to sell the stock, after selling it we have price[i] money and we have to give back the money we owed, so we have price[i] - |buy1| = prices[i ] + buy1, we want to make this max.\\n\\nbuy2 means we want to buy another stock, we already have sell1 money, so after buying stock2 we have buy2 = sell1 - price[i] money left, we want more money left, so we make it max\\n\\nsell2 means we want to sell stock2, we can have price[i] money after selling it, and we have buy2 money left before, so sell2 = buy2 + prices[i], we make this max.\\n\\nSo sell2 is the most money we can have.\\n\\nHope it is helpful and welcome quesions!\\n\\n    public int maxProfit(int[] prices) {\\n    \\t\\tint sell1 = 0, sell2 = 0, buy1 = Integer.MIN_VALUE, buy2 = Integer.MIN_VALUE;\\n    \\t\\tfor (int i = 0; i < prices.length; i++) {\\n    \\t\\t\\tbuy1 = Math.max(buy1, -prices[i]);\\n    \\t\\t\\tsell1 = Math.max(sell1, buy1 + prices[i]);\\n    \\t\\t\\tbuy2 = Math.max(buy2, sell1 - prices[i]);\\n    \\t\\t\\tsell2 = Math.max(sell2, buy2 + prices[i]);\\n    \\t\\t}\\n    \\t\\treturn sell2;\\n    \\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 796990,
                "title": "c-worst-to-best-solution-explained-for-dummies-like-me",
                "content": "**Approach 1** (Recursion+Memo): [199/200 CASES PASSED, TLE] \\nThe most intuitive approach is to explore all choices, if we haven\\'t bought a stock yet, we either buy it or skip it. Similarly we have two choices for selling also. We also keep a track of number of transactions completed so that we stop after 2 transactions. This way we end up exploring all possibilties and return the optimal combination. Here\\'s the code:\\n```\\n    unordered_map<string, int> memo;\\n    int profit(vector<int> prices, int i, int isBuy, int k){\\n        if(i == prices.size() || k == 2)     // return if two transactions are completed\\n            return 0;\\n        string key = to_string(i) + \"-\" + to_string(isBuy) + \"-\" + to_string(k);\\n        if(memo.find(key)!=memo.end())\\n            return memo[key];\\n        int a,b;\\n        if(isBuy){                           // if isBuy is 1, we have a choice to purchase the stock\\n            a = profit(prices, i + 1, 1, k);                       // do not buy\\n            b = profit(prices, i + 1, 0, k) - prices[i];           // buy and add the cost \\n        }  \\n        else{                                // if isBuy is 0, we can only sell as we have already bought\\n            a = profit(prices, i + 1, 0, k);                       // do not sell\\n            b = profit(prices, i + 1, 1, k + 1) + prices[i];       // sell and add the profit\\n        }   \\n        return memo[key] = max(a, b);        // best choice among trading and skipping\\n    }\\n    \\n    int maxProfit(vector<int>& prices) {\\n        return profit(prices, 0, 1, 0);\\n    }\\n```\\n---\\n**Approach 2** (Setting break points, O(N) TIME and SPACE): [ACCEPTED]\\nThe idea here is to set a break point before which we have completed the first transaction and will complete the second transaction in the remaining days. There are N -1 such break points. Instead of explicitly setting break points and computing the profit for the left part and right part, we precompute the profit for every break point. Starting from the left, for every element we check the least price in the array to its left and check if the selling at current price can make us a larger profit than skipping it. Similarly, starting from the right, for every element, we check the array to the right of it and find an element larger to the current; and check if buying at current price makes us a larger profit than skipping it. This will be clear with the example mentioned below:\\n```\\nint maxProfit(vector<int>& prices) {\\n        if(!prices.size())\\n            return 0;\\n        int n = prices.size();\\n        int left[n], right[n];\\n        int leftmin = prices[0], rightmax = prices[n-1], maxprofit = 0;\\n        left[0] = 0; right[n - 1] = 0;                                     // because we can\\'t make any profit with just 1 element\\n        int i,j;\\n        for(i = 1, j = n-2; i < n, j >= 0; i++, j--){\\n            leftmin  = min(leftmin, prices[i]);                            // find the minimum price till now\\n            left[i]  = max(left[i - 1], prices[i] - leftmin);              // max of selling today or skipping (previous max profit)\\n            rightmax = max(rightmax, prices[j]);                           // find the maximum price to the right\\n            right[j] = max(right[j + 1], rightmax - prices[j]);            // max of buying today or skipping\\n        }\\n        for(int i = 0; i < n; i++){\\n            maxprofit = max(maxprofit, left[i] + right[i]);\\n        }\\n        return maxprofit;\\n    }\\n    \\n    // EG: PRICES = [3,3,5,0,0,3,1,4]\\n    //     LEFT   = [0,0,2,2,2,2,2,3]\\n    //     RIGHT  = [2,2,4,4,4,1,0,0]\\n    //     SUM    = [2,2,6,6,6,3,2,3] \\n\\t//     MAX PROFIT = 6\\n```\\n---\\n\\n**Approach 3** (O(N) time O(1) space) [ACCEPTED]\\nSuppose you make some profit **p1** by doing your first transaction in the stock market. Now you are excited to purchase another stock to earn more profit. Suppose the price of the second stock you aim to buy is **x**. Now, for you, the net effective price that you are spending from your pocket for this stock will be **x-p1**, because you already have **p1** bucks in your hand. Now, if you sell the second stock at price **y** your net profit **p2** will be **p2 = y - (x-p1)**. You have to do nothing but maximize this profit **p2**. Here\\'s the code:\\n```\\nint maxProfit(vector<int>& prices) {\\n        if(!prices.size())\\n            return 0;\\n        int buy1    = INT_MAX;\\n        int profit1 = INT_MIN;\\n        int buy2    = INT_MAX;\\n        int profit2 = INT_MIN;\\n        for(int i = 0; i < prices.size(); i++){\\n            buy1    = min(buy1, prices[i]);\\n            profit1 = max(profit1, prices[i] - buy1);\\n            buy2    = min(buy2, prices[i] - profit1);\\n            profit2 = max(profit2, prices[i] - buy2);\\n        }\\n        return profit2;\\n    }\\n```\\nHope it helps! Please upvote if you understood.\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    unordered_map<string, int> memo;\\n    int profit(vector<int> prices, int i, int isBuy, int k){\\n        if(i == prices.size() || k == 2)     // return if two transactions are completed\\n            return 0;\\n        string key = to_string(i) + \"-\" + to_string(isBuy) + \"-\" + to_string(k);\\n        if(memo.find(key)!=memo.end())\\n            return memo[key];\\n        int a,b;\\n        if(isBuy){                           // if isBuy is 1, we have a choice to purchase the stock\\n            a = profit(prices, i + 1, 1, k);                       // do not buy\\n            b = profit(prices, i + 1, 0, k) - prices[i];           // buy and add the cost \\n        }  \\n        else{                                // if isBuy is 0, we can only sell as we have already bought\\n            a = profit(prices, i + 1, 0, k);                       // do not sell\\n            b = profit(prices, i + 1, 1, k + 1) + prices[i];       // sell and add the profit\\n        }   \\n        return memo[key] = max(a, b);        // best choice among trading and skipping\\n    }\\n    \\n    int maxProfit(vector<int>& prices) {\\n        return profit(prices, 0, 1, 0);\\n    }\\n```\n```\\nint maxProfit(vector<int>& prices) {\\n        if(!prices.size())\\n            return 0;\\n        int n = prices.size();\\n        int left[n], right[n];\\n        int leftmin = prices[0], rightmax = prices[n-1], maxprofit = 0;\\n        left[0] = 0; right[n - 1] = 0;                                     // because we can\\'t make any profit with just 1 element\\n        int i,j;\\n        for(i = 1, j = n-2; i < n, j >= 0; i++, j--){\\n            leftmin  = min(leftmin, prices[i]);                            // find the minimum price till now\\n            left[i]  = max(left[i - 1], prices[i] - leftmin);              // max of selling today or skipping (previous max profit)\\n            rightmax = max(rightmax, prices[j]);                           // find the maximum price to the right\\n            right[j] = max(right[j + 1], rightmax - prices[j]);            // max of buying today or skipping\\n        }\\n        for(int i = 0; i < n; i++){\\n            maxprofit = max(maxprofit, left[i] + right[i]);\\n        }\\n        return maxprofit;\\n    }\\n    \\n    // EG: PRICES = [3,3,5,0,0,3,1,4]\\n    //     LEFT   = [0,0,2,2,2,2,2,3]\\n    //     RIGHT  = [2,2,4,4,4,1,0,0]\\n    //     SUM    = [2,2,6,6,6,3,2,3] \\n\\t//     MAX PROFIT = 6\\n```\n```\\nint maxProfit(vector<int>& prices) {\\n        if(!prices.size())\\n            return 0;\\n        int buy1    = INT_MAX;\\n        int profit1 = INT_MIN;\\n        int buy2    = INT_MAX;\\n        int profit2 = INT_MIN;\\n        for(int i = 0; i < prices.size(); i++){\\n            buy1    = min(buy1, prices[i]);\\n            profit1 = max(profit1, prices[i] - buy1);\\n            buy2    = min(buy2, prices[i] - profit1);\\n            profit2 = max(profit2, prices[i] - buy2);\\n        }\\n        return profit2;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1523723,
                "title": "c-four-solutions-recursion-memoization-dp-with-o-n-space-dp-with-o-1-space",
                "content": "# Approach : \\n* ###  We just to need to build the recursive solution after that *recursive -> iterative conversion* and *optimisations* can be done easily.\\n* ### Everyday, We have two choices : Buy/Sell this stock *OR* ignore and move to the next one. \\n* ### Along with day, we also need to maintain a transactionsLeft variable which will tell us how many transactions are remaining and it will be of which type (Buy or Sell) and According to that we will make recursive calls and calculate the answer \\n* ### We can do atmost 4 transactions (Buy, Sell, Buy, Sell) in this order.\\n\\n* ### // No transaction today : \\n```\\n\\tans1 = solve(day + 1, transactionsLeft); \\n```\\n\\n* ### // transaction today : \\n```\\n   bool buy = (transactionsLeft % 2 == 0);\\n\\tif(buy == true) {\\n\\t\\tans2 = -prices[day] + solve(day + 1, transactionsLeft - 1);\\n\\t}else{\\n\\t\\tans2 = prices[day] + solve(day + 1, transactionsLeft - 1);\\n\\t}\\n```\\n\\n* ### Now Choosing the best one among them and returning the required answer.\\n\\n* ### We will stop the recursion when *day >= prices.size()* or *transactionsLeft == 0* and *return 0.* \\n\\n\\n# Recursive Solution\\n```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<int>&prices, int day, int transactionsLeft){\\n        \\n        if(day == prices.size()){\\n            return 0;\\n        }\\n        \\n        if(transactionsLeft == 0){\\n            return 0;\\n        }\\n        \\n        // choice 1\\n        // no transaction today\\n        int ans1 = solve(prices, day + 1, transactionsLeft);\\n        \\n        \\n        // choice 2\\n        // doing the possible transaction today     \\n        int ans2 = 0;\\n        bool buy = (transactionsLeft % 2 == 0);\\n        \\n        if(buy == true){ // buy\\n            ans2 = -prices[day] + solve(prices, day + 1, transactionsLeft - 1);\\n        }else{ // sell\\n            ans2 = prices[day] + solve(prices, day + 1, transactionsLeft - 1);\\n        }\\n        \\n        return max(ans1, ans2);\\n        \\n        \\n    }\\n    \\n    \\n    int maxProfit(vector<int>& prices) {\\n        \\n        int ans = solve(prices, 0, 4); // starting with day 0 and max 4 transactions can be done\\n        return ans;\\n        \\n    }\\n};\\n```\\n* ### Time Complexity : O(2^N)\\n* ### Space Complexity : O(N)\\n* #### As you have guessed it, It will give TLE (Time Limit Exceeded) verdict.\\n\\n# Memoization Solution\\n* ### Exact same code as above just store the answer of all states to avoid solving subproblems that have already been solved \\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<int>&prices, int day, int transactionsLeft, vector<vector<int>> &Memo){\\n        \\n        if(day == prices.size()){\\n            return 0;\\n        }\\n        \\n        if(transactionsLeft == 0){\\n            return 0;\\n        }\\n        \\n        int &ans = Memo[day][transactionsLeft]; \\n        \\n        if(ans != -1){ // if problem has already been solved \\n            return ans;\\n        }\\n        \\n        // choice 1\\n        // no transaction today\\n        int ans1 = solve(prices, day + 1, transactionsLeft, Memo);\\n        \\n        \\n        // choice 2\\n        // doing the possible transaction today     \\n        int ans2 = 0;\\n        bool buy = (transactionsLeft % 2 == 0);\\n        \\n        if(buy == true){ // buy\\n            ans2 = -prices[day] + solve(prices, day + 1, transactionsLeft - 1, Memo);\\n        }else{ // sell\\n            ans2 = prices[day] + solve(prices, day + 1, transactionsLeft - 1, Memo);\\n        }\\n        \\n        return ans = max(ans1, ans2); // store ans in memo before returning\\n        \\n        \\n    }\\n    \\n    \\n    int maxProfit(vector<int>& prices) {\\n        \\n        vector<vector<int>> Memo(prices.size(), vector<int>(5, -1));\\n        int ans = solve(prices, 0, 4, Memo);\\n        return ans;\\n        \\n    }\\n};\\n```\\n* ### Time Complexity : O(N)\\n* ### Space Complexity : O(N)\\n* #### Accepted \\n\\n# DP solution with O(N) space\\n* ### Converting the recursive solution to iterative, Again exact same code just reverse the direction.\\n```\\nclass Solution {\\npublic:\\n    \\n    int maxProfit(vector<int>& prices) {\\n        \\n        int dp[prices.size() + 1][5];\\n        \\n        \\n        for(int day = (int) prices.size();day >= 0;day--){\\n            \\n            for(int transactionsLeft = 0;transactionsLeft <= 4;transactionsLeft++){\\n                \\n                int &ans = dp[day][transactionsLeft];\\n                \\n                if(day == prices.size()){\\n                    ans = 0;\\n                }else if(transactionsLeft == 0){\\n                    ans = 0;\\n                }else{\\n                    \\n                    // choice 1\\n                    // no transaction today\\n                    int ans1 = dp[day + 1][transactionsLeft];\\n                    \\n                    // choice 2\\n                    // doing the possible transaction today     \\n                    int ans2 = 0;\\n                    bool buy = (transactionsLeft % 2 == 0);\\n\\n                    if(buy == true){ // buy\\n                        ans2 = -prices[day] + dp[day + 1][transactionsLeft - 1];\\n                    }else{ // sell\\n                        ans2 = prices[day] + dp[day + 1][transactionsLeft - 1];\\n                    }\\n\\n                    ans = max(ans1, ans2);\\n\\n                }\\n                \\n            }\\n        }\\n        return dp[0][4];\\n        \\n    }\\n};\\n```\\n* ### Time Complexity : O(N)\\n* ### Space Complexity : O(N)\\n* #### Accepted \\n\\n# DP solution with O(1) space\\n* ### Observation : For any day we just need the answers of the next day (day + 1) => Optimising it further to O(1) space \\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int maxProfit(vector<int>& prices) {\\n        \\n        int dp[2][5];\\n        \\n        \\n        for(int day = (int) prices.size();day >= 0;day--){\\n            \\n            for(int transactionsLeft = 0;transactionsLeft <= 4;transactionsLeft++){\\n                \\n                \\n                int &ans = dp[day % 2][transactionsLeft];\\n                \\n                if(day == prices.size()){\\n                    ans = 0;\\n                }else if(transactionsLeft == 0){\\n                    ans = 0;\\n                }else{\\n                    \\n                    // choice 1\\n                    // no transaction today\\n                    int ans1 = dp[(day + 1) % 2][transactionsLeft];\\n                    \\n                    // choice 2\\n                    // doing the possible transaction today     \\n                    int ans2 = 0;\\n                    bool buy = (transactionsLeft % 2 == 0);\\n\\n                    if(buy == true){ // buy\\n                        ans2 = -prices[day] + dp[(day + 1) % 2][transactionsLeft - 1];\\n                    }else{ // sell\\n                        ans2 = prices[day] + dp[(day + 1) % 2][transactionsLeft - 1];\\n                    }\\n\\n                    ans = max(ans1, ans2);\\n\\n                }\\n                \\n            }\\n        }\\n        return dp[0][4];\\n        \\n    }\\n};\\n```\\n\\n* ### Time Complexity : O(N)\\n* ### Space Complexity : O(1)\\n* #### Accepted \\n\\n<hr>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n\\tans1 = solve(day + 1, transactionsLeft); \\n```\n```\\n   bool buy = (transactionsLeft % 2 == 0);\\n\\tif(buy == true) {\\n\\t\\tans2 = -prices[day] + solve(day + 1, transactionsLeft - 1);\\n\\t}else{\\n\\t\\tans2 = prices[day] + solve(day + 1, transactionsLeft - 1);\\n\\t}\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<int>&prices, int day, int transactionsLeft){\\n        \\n        if(day == prices.size()){\\n            return 0;\\n        }\\n        \\n        if(transactionsLeft == 0){\\n            return 0;\\n        }\\n        \\n        // choice 1\\n        // no transaction today\\n        int ans1 = solve(prices, day + 1, transactionsLeft);\\n        \\n        \\n        // choice 2\\n        // doing the possible transaction today     \\n        int ans2 = 0;\\n        bool buy = (transactionsLeft % 2 == 0);\\n        \\n        if(buy == true){ // buy\\n            ans2 = -prices[day] + solve(prices, day + 1, transactionsLeft - 1);\\n        }else{ // sell\\n            ans2 = prices[day] + solve(prices, day + 1, transactionsLeft - 1);\\n        }\\n        \\n        return max(ans1, ans2);\\n        \\n        \\n    }\\n    \\n    \\n    int maxProfit(vector<int>& prices) {\\n        \\n        int ans = solve(prices, 0, 4); // starting with day 0 and max 4 transactions can be done\\n        return ans;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<int>&prices, int day, int transactionsLeft, vector<vector<int>> &Memo){\\n        \\n        if(day == prices.size()){\\n            return 0;\\n        }\\n        \\n        if(transactionsLeft == 0){\\n            return 0;\\n        }\\n        \\n        int &ans = Memo[day][transactionsLeft]; \\n        \\n        if(ans != -1){ // if problem has already been solved \\n            return ans;\\n        }\\n        \\n        // choice 1\\n        // no transaction today\\n        int ans1 = solve(prices, day + 1, transactionsLeft, Memo);\\n        \\n        \\n        // choice 2\\n        // doing the possible transaction today     \\n        int ans2 = 0;\\n        bool buy = (transactionsLeft % 2 == 0);\\n        \\n        if(buy == true){ // buy\\n            ans2 = -prices[day] + solve(prices, day + 1, transactionsLeft - 1, Memo);\\n        }else{ // sell\\n            ans2 = prices[day] + solve(prices, day + 1, transactionsLeft - 1, Memo);\\n        }\\n        \\n        return ans = max(ans1, ans2); // store ans in memo before returning\\n        \\n        \\n    }\\n    \\n    \\n    int maxProfit(vector<int>& prices) {\\n        \\n        vector<vector<int>> Memo(prices.size(), vector<int>(5, -1));\\n        int ans = solve(prices, 0, 4, Memo);\\n        return ans;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int maxProfit(vector<int>& prices) {\\n        \\n        int dp[prices.size() + 1][5];\\n        \\n        \\n        for(int day = (int) prices.size();day >= 0;day--){\\n            \\n            for(int transactionsLeft = 0;transactionsLeft <= 4;transactionsLeft++){\\n                \\n                int &ans = dp[day][transactionsLeft];\\n                \\n                if(day == prices.size()){\\n                    ans = 0;\\n                }else if(transactionsLeft == 0){\\n                    ans = 0;\\n                }else{\\n                    \\n                    // choice 1\\n                    // no transaction today\\n                    int ans1 = dp[day + 1][transactionsLeft];\\n                    \\n                    // choice 2\\n                    // doing the possible transaction today     \\n                    int ans2 = 0;\\n                    bool buy = (transactionsLeft % 2 == 0);\\n\\n                    if(buy == true){ // buy\\n                        ans2 = -prices[day] + dp[day + 1][transactionsLeft - 1];\\n                    }else{ // sell\\n                        ans2 = prices[day] + dp[day + 1][transactionsLeft - 1];\\n                    }\\n\\n                    ans = max(ans1, ans2);\\n\\n                }\\n                \\n            }\\n        }\\n        return dp[0][4];\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int maxProfit(vector<int>& prices) {\\n        \\n        int dp[2][5];\\n        \\n        \\n        for(int day = (int) prices.size();day >= 0;day--){\\n            \\n            for(int transactionsLeft = 0;transactionsLeft <= 4;transactionsLeft++){\\n                \\n                \\n                int &ans = dp[day % 2][transactionsLeft];\\n                \\n                if(day == prices.size()){\\n                    ans = 0;\\n                }else if(transactionsLeft == 0){\\n                    ans = 0;\\n                }else{\\n                    \\n                    // choice 1\\n                    // no transaction today\\n                    int ans1 = dp[(day + 1) % 2][transactionsLeft];\\n                    \\n                    // choice 2\\n                    // doing the possible transaction today     \\n                    int ans2 = 0;\\n                    bool buy = (transactionsLeft % 2 == 0);\\n\\n                    if(buy == true){ // buy\\n                        ans2 = -prices[day] + dp[(day + 1) % 2][transactionsLeft - 1];\\n                    }else{ // sell\\n                        ans2 = prices[day] + dp[(day + 1) % 2][transactionsLeft - 1];\\n                    }\\n\\n                    ans = max(ans1, ans2);\\n\\n                }\\n                \\n            }\\n        }\\n        return dp[0][4];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39743,
                "title": "python-dp-solution-120ms",
                "content": "Two passes through the list, O(n) time, O(n) space:\\n\\n     \\n    def maxProfit(self, prices):\\n        if not prices:\\n            return 0\\n        \\n        # forward traversal, profits record the max profit \\n        # by the ith day, this is the first transaction\\n        profits = []\\n        max_profit = 0\\n        current_min = prices[0]\\n        for price in prices:\\n            current_min = min(current_min, price)\\n            max_profit = max(max_profit, price - current_min)\\n            profits.append(max_profit)\\n        \\n        # backward traversal, max_profit records the max profit\\n        # after the ith day, this is the second transaction \\n        total_max = 0    \\n        max_profit = 0\\n        current_max = prices[-1]\\n        for i in range(len(prices) - 1, -1, -1):\\n            current_max = max(current_max, prices[i])\\n            max_profit = max(max_profit, current_max - prices[i])\\n            total_max = max(total_max, max_profit + profits[i])\\n            \\n        return total_max",
                "solutionTags": [
                    "Python"
                ],
                "code": "Two passes through the list, O(n) time, O(n) space:\\n\\n     \\n    def maxProfit(self, prices):\\n        if not prices:\\n            return 0\\n        \\n        # forward traversal, profits record the max profit \\n        # by the ith day, this is the first transaction\\n        profits = []\\n        max_profit = 0\\n        current_min = prices[0]\\n        for price in prices:\\n            current_min = min(current_min, price)\\n            max_profit = max(max_profit, price - current_min)\\n            profits.append(max_profit)\\n        \\n        # backward traversal, max_profit records the max profit\\n        # after the ith day, this is the second transaction \\n        total_max = 0    \\n        max_profit = 0\\n        current_max = prices[-1]\\n        for i in range(len(prices) - 1, -1, -1):\\n            current_max = max(current_max, prices[i])\\n            max_profit = max(max_profit, current_max - prices[i])\\n            total_max = max(total_max, max_profit + profits[i])\\n            \\n        return total_max",
                "codeTag": "Python3"
            },
            {
                "id": 39613,
                "title": "my-c-solution-o-n-time-o-1-space-8ms",
                "content": "It is similar to other buy/sell problems. just do DP and define an array of states to track the current maximum profits at different stages. For example, in the below code\\n\\n - states[][0]: one buy\\n - states[][1]: one buy, one sell\\n - states[][2]: two buys, one sell\\n - states[][3]: two buy, two sells\\n\\nThe states transistions occurs when buy/sell operations are executed. For example, state[][0] can move to state[][1] via one sell operation. \\n\\n    class Solution {\\n    public:\\n        int maxProfit(vector<int>& prices) {\\n            int states[2][4] = {INT_MIN, 0, INT_MIN, 0}; // 0: 1 buy, 1: one buy/sell, 2: 2 buys/1 sell, 3, 2 buys/sells\\n            int len = prices.size(), i, cur = 0, next =1;\\n            for(i=0; i<len; ++i)\\n            {\\n                states[next][0] = max(states[cur][0], -prices[i]);\\n                states[next][1] = max(states[cur][1], states[cur][0]+prices[i]);\\n                states[next][2] = max(states[cur][2], states[cur][1]-prices[i]);\\n                states[next][3] = max(states[cur][3], states[cur][2]+prices[i]);\\n                swap(next, cur);\\n            }\\n            return max(states[cur][1], states[cur][3]);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maxProfit(vector<int>& prices) {\\n            int states[2][4] = {INT_MIN, 0, INT_MIN, 0}",
                "codeTag": "Java"
            },
            {
                "id": 1326824,
                "title": "complete-explanation-of-the-buy-and-sell-stock-problems-using-dp",
                "content": "I will be going over what I have learned while trying to solve these problems. I was initially using `Kadane\\'s algorithm` to do these problems. Infact, completed the first, second, and third **Buy and Sell Stock problems** using Kadane\\'s but the fourth problem gave me a concussion so, I embarked on a journey to learn a framework using which I can solve the complete set of these problems and handle any tweaks that an interviewer might throw at me in the future. I visited a number of resources, watched a number of videos and here is the culmination of everything I have picked so far.\\n\\nThese are all the problems we have in the Buy and Sell Stock set.\\n1. [Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)\\n2. [Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/)\\n3. [Best Time to Buy and Sell Stock III](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/)\\n4. [Best Time to Buy and Sell Stock IV](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/)\\n5. [Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)\\n6. [Best Time to Buy and Sell Stock with Transaction Fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)\\n\\nFirst, we will see how we can come up with a framework which we can apply for all the above problems. A framework which is flexible enough to accomodate any tweaks an interviewer might throw at us in the future. *A framework which exhausts all the possible outcomes and then come up with the best solution*. A recursive solution would be exhaustive but we will use \"states\" for exhaustion in these problems. **We will consider each day and see how many possible \"states\" do we have for each day and then find \"choices\" corresponding to each state.**\\n\\n**Let\\'s talk about the constraints first.**\\n1. `Sell` must be after `Buy`.\\n2. `Buy` must be after `Sell`.\\n3.  Limit on the number of transaction(k), `k>0`.\\n\\n**For each day we have three choices.**\\n1. `Buy`.\\n2. `Sell`.\\n3. `Rest`. Which further has two states.\\n\\t a. `Rest after buy`. Here we are holding the stock. We are not selling or buying. We are just resting.\\n\\t b. `Rest after selling`. Here we are not holding any stocks. We are not selling or buying. We are just resting.\\n\\n**Let\\'s talk about the states now.**\\n1. The day we are on i.e `i`.\\n2. The maximum number of allowed transactions i.e `k`.\\n3. The holding state i.e the resting state we talked about before. This is either `1(holding stock)` or `0(not holding stock)`.\\n\\nNow, we can put all the combinations of these states in a 3D matrix like so :\\n\\n```\\nfor 0 <= i <= n:             // n is the number of days\\n\\tfor i <= k <= k:        // k is the maximum number of transactions\\n\\t\\tfor s in {1,0}:    // s is the rest state\\n\\t\\t\\t\\tdp[i][k][s] = max(buy,sell,rest)\\n```\\n\\n\\n***For every problem we have to find the `dp[n-1][k][0]`, which is the maximum profit for the maximum number of transactions allowed on the last day.***\\n\\nOne important observation. Why didn\\'t we say **`dp[n-1][k][1]`** instead of saying **`dp[n-1][k][0]`**? because if the resting state `S` is 1, it means we are still holding a stock and the profit cannot be maximum until and unless we are done selling all the stocks we have.\\n\\n\\n\\n\\nNow, let\\'s think about what choices do we have for each state and how we can update the \"state\". Let\\'s write our state transition equations. They will be something like this.\\n\\n`dp[i][k][0] = Max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]) // prices is the array of stocks`\\n\\n***This equation corresponds to when you are not holding a stock. You are not holding a stock today because perhaps you didn\\'t have any stocks yesterday which we could sell today or maybe you have stocks that you want to sell today, so at the end of the day we will not be holding any stocks.***\\n\\n`dp[i][k][1] = Max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])`\\n\\n***This equation corresponds to when you are holding a stock. You are holding a stock today because perhaps you had stocks yesterday or maybe you want to buy stocks today, so at the end of the day we will be holding stocks.***\\n\\n***This explanation should be clear. If you buy, you need to subtract prices[i] from the profit, and if you sell, you need to increase prices[i] to the profit.***\\n\\n\\nNow, let\\'s talk about the base cases.\\n\\n1. `dp[-1][k][0]  = 0`     **// Because the day starts with 0 and here i is -1**\\n2. `dp[-1][k][1] = -Infinity`  **// Because we can\\'t hold any stocks before the first day**\\n3. `dp[i][0][0] = 0`  **// Because k = 0. There won\\'t be any transactions so the profit will be zero** \\n4. `dp[i][0][1] = -Infinity`  **// Because k = 0. We can\\'t hold any stocks without starting a transaction** \\n\\n\\nSo, to summarize the above base conditions and state transition equations\\n\\n```\\nbase case\\uFF1A\\ndp[-1][k][0] = dp[i][0][0] = 0\\ndp[-1][k][1] = dp[i][0][1] = -infinity\\n\\nstate transition equation\\uFF1A\\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])\\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])\\n```\\n\\n\\nNow, let\\'s begin with the problems.\\n\\n1. ***When k = 1***\\n\\nWe will put k = 1 directly in the state transition equations and see for ourselves.\\n\\n```\\ndp[i][1][0] = Max(dp[i-1][1][0], dp[i-1][1][1] + prices[i];\\ndp[i][1][1] = Max(dp[i-1][1][1], dp[i-1][0][0] - prices[i];\\n\\t        = Max(dp[i-1][1][1], 0 - prices[i];  // from the above base case when k is 0\\n```\\n\\nWe can also see that the presence of k when it is 1 does not change the state in any way so, we can simply ignore it.\\n\\n```\\ndp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\ndp[i][1] = max(dp[i-1][1], -prices[i])\\n```\\n\\nWe can write the solution for it like so:\\n\\n```\\nvar maxProfit = function(prices){\\n  let n = prices.length;\\n  let dp = [];\\n  \\n  for(let i=0; i<n; i++){\\n    dp[i] = [];\\n    if(i-1 === -1){\\n      dp[i][0] = 0; \\n        // Explanation\\uFF1A\\n        //   dp[i][0] \\n        // = max(dp[-1][0], dp[-1][1] + prices[i])\\n        // = max(0, -infinity + prices[i]) = 0\\n      dp[i][1] = -prices[i];\\n        // Explanation\\uFF1A\\n        //   dp[i][1] \\n        // = max(dp[-1][1], dp[-1][0] - prices[i])\\n        // = max(-infinity, 0 - prices[i]) \\n        // = -prices[i]\\n      continue;\\n    }\\n    dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);\\n    dp[i][1] = Math.max(dp[i-1][1],  -prices[i])\\n  }\\n  return dp[n-1][0];\\n}\\n```\\n\\n***We can reduce the Space complexity to 0(1) by not constructing the DP matrix as the new state is only related to an adjacent state. So, instead of the DP matrix we can store the states in a single variable. One variable for not holding and one for holding.***\\n\\nCode for that would look something like :\\n\\n```\\nvar maxProfit = function(prices){\\n  let d_i10 = 0;\\n  let d_i11 = -Infinity;\\n  \\n  for(let i=0; i<prices.length;i++){\\n    d_i10 = Math.max(d_i10, d_i11 + prices[i]);\\n    d_i11 = Math.max(d_i11, 0 - prices[i]);\\n  }\\n  return d_i10;\\n}\\n```\\n\\n2. ***When k = + Infinity***\\n\\nWhen k is Infinity, k and k-1 are practically the same. We will use that in our state transition equations.\\n\\n\\n```\\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])\\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])\\n            = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i]) // k and k-1 are the same\\n```\\n\\nSince, the presence of k is not really impacting the states, we will ignore it.\\n\\n```\\ndp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\ndp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])\\n```\\n\\nAnd the solution would look like this : \\n\\n```\\nvar maxProfit = function(prices){\\n  let d_ik0 = 0;\\n  let d_ik1 = -Infinity;\\n  \\n  for(let i=0;i<prices.length;i++){\\n    d_ik0 = Math.max(d_ik0 , d_ik1 + prices[i]);\\n    d_ik1 = Math.max(d_ik1, d_ik0 - prices[i]);\\n  }\\n  return d_ik0;\\n}\\n```\\n\\n\\n3. ***When k = 2***\\n\\nNow, we need to exhaust the value of k as well. Before this we were ignoring k because it was not impacting our states. We need to hold the states for the second transaction as well along with the first transaction. \\n\\n```\\ndp[i][2][0] = max(dp[i-1][2][0], dp[i-1][2][1] + prices[i])\\ndp[i][2][1] = max(dp[i-1][2][1], dp[i-1][1][0] - prices[i])\\ndp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])\\ndp[i][1][1] = max(dp[i-1][1][1], -prices[i])\\n```\\n\\nThe solution would look like this :\\n\\n```\\nvar maxProfit = function(prices){\\n  let d_i20 = 0;\\n  let d_i21 = -Infinity; // base case for second transaction\\n  let d_i10 = 0;\\n  let d_i11 = -Infinity; //base case for second transaction\\n  \\n  for(let i=0; i<prices.length; i++){\\n    d_i10 = Math.max(d_i10, d_i11 + prices[i]);\\n    d_i11 = Math.max(d_i11,  0 - prices[i]);\\n    d_i20 = Math.max(d_i20, d_i21 + prices[i]);\\n    d_i21 = Math.max(d_i21, d_i10 - prices[i]);\\n   \\n  }\\n  return d_i20\\n}\\n```\\n\\n\\n4. ***When k = + interger***\\n\\n**Important observation** : A transaction consists of buying and selling, which takes atleast 2 days. Therefore, the effective limit k should not exceed n/2( n is the number of days). If it exceeds, there is no contraint effect which makes k equivalent to +Infinity.\\n\\nThis is the only problem from this set which is a little difficult.\\n\\nSolution would look like this \\n```\\nvar maxProfit = function(k, prices) {\\n    if(prices.length == 0) return 0;\\n    \\n    // When k becomes so much larger than the number of prices we can make transactions whenever.\\n    if(k > (prices.length / 2) ){\\n      let d_ik0 = 0;\\n      let d_ik1 =  -Infinity;\\n      for(let i =0; i<prices.length;i++){\\n        d_ik0 = Math.max(d_ik0, d_ik1 + prices[i]);\\n        d_ik1 = Math.max(d_ik1, d_ik0 - prices[i]);\\n      }\\n      return d_ik0\\n    }\\n    else{\\n        let dp = [];\\n        let size = prices.length;\\n        for(let i=0; i<size; i++){\\n          dp[i] = [];\\n          for(let j=0; j<=k; j++){\\n            dp[i][j] = []\\n            if(i-1 === -1 || j-1 === -1){\\n              dp[i][j][0] = 0;\\n              dp[i][j][1] = -prices[i];\\n              continue;\\n            }\\n            dp[i][j][0] = Math.max(dp[i-1][j][0], dp[i-1][j][1] + prices[i]);\\n            dp[i][j][1] = Math.max(dp[i-1][j][1], dp[i-1][j-1][0] - prices[i])\\n          }\\n        }\\n      return dp[size-1][k][0]\\n    }\\n};\\n```\\n\\n5. ***When k = +Infinity with cooldown***\\n\\nWe must wait one day after selling a stock to continue trading. We can write the state transition equations as :\\n\\n```\\ndp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\ndp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i])\\nExplanation: When we choose to buy on day i, the state of i-2 should be transferred instead of i-1\\n```\\n\\nCode would look like \\n\\n```\\nvar maxProfit = function(prices){\\n  let d_ik0 = 0;\\n  let d_ik1 = -Infinity;\\n  let d_ik0_pre = 0;\\n  \\n  for(let i=0;i<prices.length;i++){\\n    let d_ik0_old = d_ik0; \\n    d_ik0 = Math.max(d_ik0 , d_ik1 + prices[i]);\\n    d_ik1 = Math.max(d_ik1, d_ik0_pre - prices[i]);\\n    d_ik0_pre = d_ik0_old;\\n  }\\n  return d_ik0;\\n}\\n```\\n\\n\\n\\n6. ***When k = +Infinity with transaction fee***\\n\\nSince now we need to pay some fee for each transaction made, the profit after buying or selling the stock on the i-th day should be subtracted by this amount, therefore the new recurrence relations will be either\\n\\n```\\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])\\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i] - fee)\\n\\nor\\n\\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i] - fee)\\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i])\\n```\\n\\nCode can we written as  :\\n\\n```\\nvar maxProfit = function(prices, fee){\\n  let d_ik0 = 0;\\n  let d_ik1 = -Infinity;\\n  \\n  for(let i=0;i<prices.length;i++){\\n    d_ik0 = Math.max(d_ik0 , d_ik1 + prices[i]);\\n    d_ik1 = Math.max(d_ik1, d_ik0 - prices[i] - fee);\\n  }\\n  return d_ik0;\\n}\\n```\\n\\n\\nI hope you enjoyed this post.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfor 0 <= i <= n:             // n is the number of days\\n\\tfor i <= k <= k:        // k is the maximum number of transactions\\n\\t\\tfor s in {1,0}:    // s is the rest state\\n\\t\\t\\t\\tdp[i][k][s] = max(buy,sell,rest)\\n```\n```\\nbase case\\uFF1A\\ndp[-1][k][0] = dp[i][0][0] = 0\\ndp[-1][k][1] = dp[i][0][1] = -infinity\\n\\nstate transition equation\\uFF1A\\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])\\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])\\n```\n```\\ndp[i][1][0] = Max(dp[i-1][1][0], dp[i-1][1][1] + prices[i];\\ndp[i][1][1] = Max(dp[i-1][1][1], dp[i-1][0][0] - prices[i];\\n\\t        = Max(dp[i-1][1][1], 0 - prices[i];  // from the above base case when k is 0\\n```\n```\\ndp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\ndp[i][1] = max(dp[i-1][1], -prices[i])\\n```\n```\\nvar maxProfit = function(prices){\\n  let n = prices.length;\\n  let dp = [];\\n  \\n  for(let i=0; i<n; i++){\\n    dp[i] = [];\\n    if(i-1 === -1){\\n      dp[i][0] = 0; \\n        // Explanation\\uFF1A\\n        //   dp[i][0] \\n        // = max(dp[-1][0], dp[-1][1] + prices[i])\\n        // = max(0, -infinity + prices[i]) = 0\\n      dp[i][1] = -prices[i];\\n        // Explanation\\uFF1A\\n        //   dp[i][1] \\n        // = max(dp[-1][1], dp[-1][0] - prices[i])\\n        // = max(-infinity, 0 - prices[i]) \\n        // = -prices[i]\\n      continue;\\n    }\\n    dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);\\n    dp[i][1] = Math.max(dp[i-1][1],  -prices[i])\\n  }\\n  return dp[n-1][0];\\n}\\n```\n```\\nvar maxProfit = function(prices){\\n  let d_i10 = 0;\\n  let d_i11 = -Infinity;\\n  \\n  for(let i=0; i<prices.length;i++){\\n    d_i10 = Math.max(d_i10, d_i11 + prices[i]);\\n    d_i11 = Math.max(d_i11, 0 - prices[i]);\\n  }\\n  return d_i10;\\n}\\n```\n```\\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])\\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])\\n            = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i]) // k and k-1 are the same\\n```\n```\\ndp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\ndp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])\\n```\n```\\nvar maxProfit = function(prices){\\n  let d_ik0 = 0;\\n  let d_ik1 = -Infinity;\\n  \\n  for(let i=0;i<prices.length;i++){\\n    d_ik0 = Math.max(d_ik0 , d_ik1 + prices[i]);\\n    d_ik1 = Math.max(d_ik1, d_ik0 - prices[i]);\\n  }\\n  return d_ik0;\\n}\\n```\n```\\ndp[i][2][0] = max(dp[i-1][2][0], dp[i-1][2][1] + prices[i])\\ndp[i][2][1] = max(dp[i-1][2][1], dp[i-1][1][0] - prices[i])\\ndp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])\\ndp[i][1][1] = max(dp[i-1][1][1], -prices[i])\\n```\n```\\nvar maxProfit = function(prices){\\n  let d_i20 = 0;\\n  let d_i21 = -Infinity; // base case for second transaction\\n  let d_i10 = 0;\\n  let d_i11 = -Infinity; //base case for second transaction\\n  \\n  for(let i=0; i<prices.length; i++){\\n    d_i10 = Math.max(d_i10, d_i11 + prices[i]);\\n    d_i11 = Math.max(d_i11,  0 - prices[i]);\\n    d_i20 = Math.max(d_i20, d_i21 + prices[i]);\\n    d_i21 = Math.max(d_i21, d_i10 - prices[i]);\\n   \\n  }\\n  return d_i20\\n}\\n```\n```\\nvar maxProfit = function(k, prices) {\\n    if(prices.length == 0) return 0;\\n    \\n    // When k becomes so much larger than the number of prices we can make transactions whenever.\\n    if(k > (prices.length / 2) ){\\n      let d_ik0 = 0;\\n      let d_ik1 =  -Infinity;\\n      for(let i =0; i<prices.length;i++){\\n        d_ik0 = Math.max(d_ik0, d_ik1 + prices[i]);\\n        d_ik1 = Math.max(d_ik1, d_ik0 - prices[i]);\\n      }\\n      return d_ik0\\n    }\\n    else{\\n        let dp = [];\\n        let size = prices.length;\\n        for(let i=0; i<size; i++){\\n          dp[i] = [];\\n          for(let j=0; j<=k; j++){\\n            dp[i][j] = []\\n            if(i-1 === -1 || j-1 === -1){\\n              dp[i][j][0] = 0;\\n              dp[i][j][1] = -prices[i];\\n              continue;\\n            }\\n            dp[i][j][0] = Math.max(dp[i-1][j][0], dp[i-1][j][1] + prices[i]);\\n            dp[i][j][1] = Math.max(dp[i-1][j][1], dp[i-1][j-1][0] - prices[i])\\n          }\\n        }\\n      return dp[size-1][k][0]\\n    }\\n};\\n```\n```\\ndp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])\\ndp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i])\\nExplanation: When we choose to buy on day i, the state of i-2 should be transferred instead of i-1\\n```\n```\\nvar maxProfit = function(prices){\\n  let d_ik0 = 0;\\n  let d_ik1 = -Infinity;\\n  let d_ik0_pre = 0;\\n  \\n  for(let i=0;i<prices.length;i++){\\n    let d_ik0_old = d_ik0; \\n    d_ik0 = Math.max(d_ik0 , d_ik1 + prices[i]);\\n    d_ik1 = Math.max(d_ik1, d_ik0_pre - prices[i]);\\n    d_ik0_pre = d_ik0_old;\\n  }\\n  return d_ik0;\\n}\\n```\n```\\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])\\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i] - fee)\\n\\nor\\n\\ndp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i] - fee)\\ndp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i])\\n```\n```\\nvar maxProfit = function(prices, fee){\\n  let d_ik0 = 0;\\n  let d_ik1 = -Infinity;\\n  \\n  for(let i=0;i<prices.length;i++){\\n    d_ik0 = Math.max(d_ik0 , d_ik1 + prices[i]);\\n    d_ik1 = Math.max(d_ik1, d_ik0 - prices[i] - fee);\\n  }\\n  return d_ik0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 39653,
                "title": "2ms-java-dp-solution",
                "content": "Sorry for my poor English\\n\\n    public int maxProfit(int[] prices) {\\n        // these four variables represent your profit after executing corresponding transaction\\n        // in the beginning, your profit is 0. \\n        // when you buy a stock ,the profit will be deducted of the price of stock.\\n        int firstBuy = Integer.MIN_VALUE, firstSell = 0;\\n        int secondBuy = Integer.MIN_VALUE, secondSell = 0;\\n\\n        for (int curPrice : prices) {\\n            if (firstBuy < -curPrice) firstBuy = -curPrice; // the max profit after you buy first stock\\n            if (firstSell < firstBuy + curPrice) firstSell = firstBuy + curPrice; // the max profit after you sell it\\n            if (secondBuy < firstSell - curPrice) secondBuy = firstSell - curPrice; // the max profit after you buy the second stock\\n            if (secondSell < secondBuy + curPrice) secondSell = secondBuy + curPrice; // the max profit after you sell the second stock\\n        }\\n        \\n        return secondSell; // secondSell will be the max profit after passing the prices\\n    }",
                "solutionTags": [],
                "code": "Sorry for my poor English\\n\\n    public int maxProfit(int[] prices) {\\n        // these four variables represent your profit after executing corresponding transaction\\n        // in the beginning, your profit is 0. \\n        // when you buy a stock ,the profit will be deducted of the price of stock.\\n        int firstBuy = Integer.MIN_VALUE, firstSell = 0;\\n        int secondBuy = Integer.MIN_VALUE, secondSell = 0;\\n\\n        for (int curPrice : prices) {\\n            if (firstBuy < -curPrice) firstBuy = -curPrice; // the max profit after you buy first stock\\n            if (firstSell < firstBuy + curPrice) firstSell = firstBuy + curPrice; // the max profit after you sell it\\n            if (secondBuy < firstSell - curPrice) secondBuy = firstSell - curPrice; // the max profit after you buy the second stock\\n            if (secondSell < secondBuy + curPrice) secondSell = secondBuy + curPrice; // the max profit after you sell the second stock\\n        }\\n        \\n        return secondSell; // secondSell will be the max profit after passing the prices\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 39665,
                "title": "java-solution-with-just-two-traverses",
                "content": "Go from left to right and calculate max profit for each index (i). Go from right to left and calculate max profit  for (i). Add max right profit for (i) and max left profit for (i-1) and check if it's max profit.\\n\\n    public int maxProfit(int[] prices) {\\n\\t\\tif (prices == null || prices.length == 0) return 0;\\n\\t\\tint lenght = prices.length;\\n\\t\\t\\n\\t\\tint[] leftProfit = new int[lenght];\\n\\t\\tint leftMaxProfit = 0;\\n\\t\\tint leftMin = prices[0];\\n        for (int i=0; i<lenght; i++) {\\n        \\tif (prices[i] < leftMin) leftMin = prices[i];\\n        \\tif (prices[i] - leftMin > leftMaxProfit) leftMaxProfit = prices[i]-leftMin;\\n        \\tleftProfit[i] = leftMaxProfit;\\n        }\\n        \\n        int maxProfit = 0;\\n        int rightMaxProfit = 0;\\n\\t\\tint rightMax = prices[lenght-1];\\n\\t\\tfor (int i=lenght-1; i>=0; i--) {\\n        \\tif (prices[i] > rightMax) rightMax = prices[i];\\n        \\tif (rightMax - prices[i] > rightMaxProfit) rightMaxProfit = rightMax - prices[i];\\n        \\tint currentProfit = rightMaxProfit + (i>0 ? leftProfit[i-1] : 0);\\n        \\tif (currentProfit > maxProfit) {\\n        \\t\\tmaxProfit = currentProfit;\\n        \\t}\\n        }\\n\\t\\t\\n        return maxProfit;\\n    }",
                "solutionTags": [],
                "code": "Go from left to right and calculate max profit for each index (i). Go from right to left and calculate max profit  for (i). Add max right profit for (i) and max left profit for (i-1) and check if it's max profit.\\n\\n    public int maxProfit(int[] prices) {\\n\\t\\tif (prices == null || prices.length == 0) return 0;\\n\\t\\tint lenght = prices.length;\\n\\t\\t\\n\\t\\tint[] leftProfit = new int[lenght];\\n\\t\\tint leftMaxProfit = 0;\\n\\t\\tint leftMin = prices[0];\\n        for (int i=0; i<lenght; i++) {\\n        \\tif (prices[i] < leftMin) leftMin = prices[i];\\n        \\tif (prices[i] - leftMin > leftMaxProfit) leftMaxProfit = prices[i]-leftMin;\\n        \\tleftProfit[i] = leftMaxProfit;\\n        }\\n        \\n        int maxProfit = 0;\\n        int rightMaxProfit = 0;\\n\\t\\tint rightMax = prices[lenght-1];\\n\\t\\tfor (int i=lenght-1; i>=0; i--) {\\n        \\tif (prices[i] > rightMax) rightMax = prices[i];\\n        \\tif (rightMax - prices[i] > rightMaxProfit) rightMaxProfit = rightMax - prices[i];\\n        \\tint currentProfit = rightMaxProfit + (i>0 ? leftProfit[i-1] : 0);\\n        \\tif (currentProfit > maxProfit) {\\n        \\t\\tmaxProfit = currentProfit;\\n        \\t}\\n        }\\n\\t\\t\\n        return maxProfit;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 39690,
                "title": "a-solution-not-so-dynamic-programming",
                "content": "I think the most difficult part is how to connect the first transaction to the second transaction. The final target is to get the maximum value of profit2. You must try to get money as much as possible after you buy the stock second time. Then after the second time of sell, with the as high as possible price, you get the maximum profit. \\n\\n    class Solution {\\n    public:\\n        int maxProfit(vector<int>& prices) {\\n            int size=prices.size();\\n            int profit1=0;\\n            int profit2=0;\\n            int o1=INT_MAX;\\n            int o2=INT_MIN;\\n            for(int i=0; i<size; ++i){\\n                o1=min(o1, prices[i]);\\n                profit1=max(profit1, prices[i]-o1);\\n                o2=max(o2, profit1-prices[i]);\\n                profit2=max(profit2, prices[i]+o2);\\n            }\\n            return profit2;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maxProfit(vector<int>& prices) {\\n            int size=prices.size();\\n            int profit1=0;\\n            int profit2=0;\\n            int o1=INT_MAX;\\n            int o2=INT_MIN;\\n            for(int i=0; i<size; ++i){\\n                o1=min(o1, prices[i]);\\n                profit1=max(profit1, prices[i]-o1);\\n                o2=max(o2, profit1-prices[i]);\\n                profit2=max(profit2, prices[i]+o2);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 794633,
                "title": "python-o-n-solution-with-optimization-explained",
                "content": "This problem is a special case of problem **188. Best Time to Buy and Sell Stock IV**. The following solution works for both problems. The only difference is that here we have `k = 2` transactions and in problem 188 we can have different `k`.\\n\\nMy way to solve this problem is to first evaluate matrix `B` of differences and then what is asked is to find the maximum sum of **two(k)** contiguous subarrays. We can also make optimization `if k > len(prices)//2: return sum(x for x in B if x > 0)`, which will help us, if `k` is big (in this problem it is equal to `2`, so you can remove this line, but you need it for problem 188). If `k` is more than half of length of `prices`, we can just choose all positive elements, we will have enough trancastions to do it.\\n\\nLet us create `dp` array with size `k+1` by `n-1`, where `dp[i][j]` is the maximum gain, where already made `j` transactions, that is choose `j` contiguous subarrays and used all elements before our equal number `i`. Also, `mp[i][j] = max(dp[0][j], ..., dp[i][j])`. We take `k+1` size, because we start with `0` transactions, which will be filled with zeros. We take `n-1` size, because original size is `n`, and size of differences is `n-1`. Also we start with `dp[0][1] = B[0]`, because we need to choose one contiguous subarray which ends with element `B[0]`, which is `B[0]` itself. Also we put `mp[0][1] = B[0]` for the same logic.\\n\\nNow, about updates: we iterate over all `i` from `1` to `n-2` inclusive and `j` from `1` to `k` inclusive and:\\n1. Update `dp[i][j] = max(mp[i-1][j-1], dp[i-1][j]) + B[i]`. By definition we need to take `B[i]`. We can either say, that we add it to the last contiguous subarray: `dp[i-1][j] + B[i]`, or we say that it is new contiguous subarray: `mp[i-1][j-1] + B[i]`. Note, here we use `mp`, because we actually have `max(dp[0][j-1], ... , dp[i-1][j-1])`.\\n2. Update `mp[i][j] = max(dp[i][j], mp[i-1][j])`.\\n3. Finally, return maximum from the `mp[-1]`, we need to choose maximum, because optimal solution can be with less than `k` transactions.\\n\\n**Complexity**: Time complexity is `O(nk) = O(n)`, because here `k = 2`. Space complexity is also `O(nk) = O(n)`.\\n\\n```\\nclass Solution:\\n    def maxProfit(self, prices):\\n        if len(prices) <= 1: return 0\\n        n, k = len(prices), 2\\n\\n        B = [prices[i+1] - prices[i] for i in range(len(prices) - 1)]\\n        if k > len(prices)//2: return sum(x for x in B if x > 0)\\n        \\n        dp = [[0]*(k+1) for _ in range(n-1)] \\n        mp = [[0]*(k+1) for _ in range(n-1)] \\n\\n        dp[0][1], mp[0][1] = B[0], B[0]\\n\\n        for i in range(1, n-1):\\n            for j in range(1, k+1):\\n                dp[i][j] = max(mp[i-1][j-1], dp[i-1][j]) + B[i]\\n                mp[i][j] = max(dp[i][j], mp[i-1][j])\\n\\n        return max(mp[-1])\\n```\\n\\n### Optimization:\\n\\nNote, that if we have array like `[1,5,7, -7, -4, -3, 10, 2, 7, -4, -8, 13, 15]`, then we can work in fact with smaller array `[1+5+7, -7-4-3, 10+2+7, -4-8, 13+15] = [13,-14,19,-12,28]`. So, instead of `B = [prices[i+1] - prices[i] for i in range(len(prices) - 1)]`, we can evaluate:\\n\\n```\\ndelta = [prices[i+1]-prices[i] for i in range (len(prices)-1)]\\nB=[sum(delta) for _, delta in groupby(delta, key=lambda x: x < 0)]\\nn, k = len(B) + 1, 2\\n```\\nWhen used this code, I have `132ms` to `64`ms improvement (which is faster than 99%).\\nThanks `user2349` for providing shorter version of code!\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices):\\n        if len(prices) <= 1: return 0\\n        n, k = len(prices), 2\\n\\n        B = [prices[i+1] - prices[i] for i in range(len(prices) - 1)]\\n        if k > len(prices)//2: return sum(x for x in B if x > 0)\\n        \\n        dp = [[0]*(k+1) for _ in range(n-1)] \\n        mp = [[0]*(k+1) for _ in range(n-1)] \\n\\n        dp[0][1], mp[0][1] = B[0], B[0]\\n\\n        for i in range(1, n-1):\\n            for j in range(1, k+1):\\n                dp[i][j] = max(mp[i-1][j-1], dp[i-1][j]) + B[i]\\n                mp[i][j] = max(dp[i][j], mp[i-1][j])\\n\\n        return max(mp[-1])\\n```\n```\\ndelta = [prices[i+1]-prices[i] for i in range (len(prices)-1)]\\nB=[sum(delta) for _, delta in groupby(delta, key=lambda x: x < 0)]\\nn, k = len(B) + 1, 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 802372,
                "title": "python-o-n-by-dp-reduction-w-visualization",
                "content": "Python sol by DP and state machine\\n\\n---\\n\\n**State machine diagram**\\n\\n![image](https://assets.leetcode.com/users/images/6e4b8580-8d3a-4e1a-a637-2f5540977767_1597934613.01551.png)\\n\\n---\\n\\n**Implementation** by DP:\\n\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n\\t\\t\\'\\'\\'\\n\\t\\tdp_2_hold: max profit with 2 transactions, and in hold state\\n\\t\\tdp_2_not_hold: max profit with 2 transactions, and not in hold state\\n    \\n\\t\\tdp_1_hold: max profit with 1 transaction, and in hold state\\n\\t\\tdp_1_not_hold: max profit with 1 transaction, and not in hold state\\n\\t\\t\\n\\t\\tNote: it is impossible to have stock in hand and sell on first day, therefore -infinity is set as initial profit value for hold state\\n\\t\\t\\'\\'\\'\\n\\t\\t\\n\\t\\tdp_2_hold, dp_2_not_hold = -float(\\'inf\\'), 0\\n        dp_1_hold, dp_1_not_hold = -float(\\'inf\\'), 0\\n        \\n        for stock_price in prices:\\n            \\n\\t\\t\\t# either keep being in not-hold state, or sell with stock price today\\n            dp_2_not_hold = max( dp_2_not_hold, dp_2_hold + stock_price )\\n\\t\\t\\t\\n\\t\\t\\t# either keep being in hold state, or just buy with stock price today ( add one more transaction )\\n            dp_2_hold = max( dp_2_hold, dp_1_not_hold - stock_price )\\n            \\n\\t\\t\\t# either keep being in not-hold state, or sell with stock price today\\n            dp_1_not_hold = max( dp_1_not_hold, dp_1_hold + stock_price )\\n\\t\\t\\t\\n\\t\\t\\t# either keep being in hold state, or just buy with stock price today ( add one more transaction )\\n            dp_1_hold = max( dp_1_hold, 0 - stock_price )\\n            \\n        \\n        return dp_2_not_hold\\n```\\n\\n---\\n\\nor, we can use **reduction** from ( general template Leetcode #188 ) **Trade at most k times** with k=2  to solve this problem.\\n\\nReduction from [Leetcode #188 Best Time to Buy and Sell Stock IV](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/)\\n<details>\\n<summary>Click to show source code</summary>\\n\\n```\\nclass Solution:\\n\\tdef maxProfit(self, prices: List[int]) -> int:\\n\\t\\t\\n\\t\\t# Reduction from Leetcode #188 Best Time to Buy and Sell Stock IV\\n\\t\\tdef trade_at_most_k_times( k: int, prices: List[int]) -> int:\\n\\n\\t\\t\\tn = len(prices)\\n\\n\\t\\t\\tif n == 0:\\n\\n\\t\\t\\t\\t## Base case:\\n\\t\\t\\t\\t# Price sequence is empty, we can do nothing : )\\n\\t\\t\\t\\treturn 0\\n\\n\\n\\t\\t\\t## General case:\\n\\n\\t\\t\\t# DP[ k ][ d ] = max profit on k, d\\n\\t\\t\\t# where k stands for k-th transaction, d stands for d-th trading day.\\n\\t\\t\\tdp = [ [ 0 for _ in range(n)] for _ in range(k+1) ]\\n\\n\\n\\t\\t\\t# Update by each transction as well as each trading day\\n\\t\\t\\tfor trans_k in range(1, k+1):\\n\\n\\t\\t\\t\\t# Balance before 1st transaction must be zero\\n\\t\\t\\t\\t# Buy stock on first day means -prices[0]\\n\\t\\t\\t\\tcur_balance_with_buy = 0 - prices[0]\\n\\n\\t\\t\\t\\tfor day_d in range(1, n):\\n\\n\\t\\t\\t\\t\\t# Either we have finished all k transactions before, or just finished k-th transaction today\\n\\t\\t\\t\\t\\tdp[trans_k][day_d] = max( dp[trans_k][day_d-1], cur_balance_with_buy + prices[day_d] )\\n\\n\\t\\t\\t\\t\\t# Either keep holding the stock we bought before, or just buy in today\\n\\t\\t\\t\\t\\tcur_balance_with_buy = max(cur_balance_with_buy, dp[trans_k-1][day_d-1] - prices[day_d] )\\n\\n\\t\\t\\treturn dp[k][n-1]\\n\\t\\t# --------------------------------------------\\n\\t\\treturn trade_at_most_k_times(k=2, prices=prices)\\n```\\n</br>\\n</details>\\n\\n\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #121 Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock)\\n\\n[Leetcode #122 Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii)\\n\\n[Leetcode #123 Best Time to Buy and Sell Stock III ](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii)\\n\\n[Leetcode #188 Best Time to Buy and Sell Stock IV  ](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv)\\n\\n[Leetcode #309 Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown)\\n\\n[Leetcode #714 Best Time to Buy and Sell Stock with Transaction Fee  ](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee) \\n\\n---",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n\\t\\t\\'\\'\\'\\n\\t\\tdp_2_hold: max profit with 2 transactions, and in hold state\\n\\t\\tdp_2_not_hold: max profit with 2 transactions, and not in hold state\\n    \\n\\t\\tdp_1_hold: max profit with 1 transaction, and in hold state\\n\\t\\tdp_1_not_hold: max profit with 1 transaction, and not in hold state\\n\\t\\t\\n\\t\\tNote: it is impossible to have stock in hand and sell on first day, therefore -infinity is set as initial profit value for hold state\\n\\t\\t\\'\\'\\'\\n\\t\\t\\n\\t\\tdp_2_hold, dp_2_not_hold = -float(\\'inf\\'), 0\\n        dp_1_hold, dp_1_not_hold = -float(\\'inf\\'), 0\\n        \\n        for stock_price in prices:\\n            \\n\\t\\t\\t# either keep being in not-hold state, or sell with stock price today\\n            dp_2_not_hold = max( dp_2_not_hold, dp_2_hold + stock_price )\\n\\t\\t\\t\\n\\t\\t\\t# either keep being in hold state, or just buy with stock price today ( add one more transaction )\\n            dp_2_hold = max( dp_2_hold, dp_1_not_hold - stock_price )\\n            \\n\\t\\t\\t# either keep being in not-hold state, or sell with stock price today\\n            dp_1_not_hold = max( dp_1_not_hold, dp_1_hold + stock_price )\\n\\t\\t\\t\\n\\t\\t\\t# either keep being in hold state, or just buy with stock price today ( add one more transaction )\\n            dp_1_hold = max( dp_1_hold, 0 - stock_price )\\n            \\n        \\n        return dp_2_not_hold\\n```\n```\\nclass Solution:\\n\\tdef maxProfit(self, prices: List[int]) -> int:\\n\\t\\t\\n\\t\\t# Reduction from Leetcode #188 Best Time to Buy and Sell Stock IV\\n\\t\\tdef trade_at_most_k_times( k: int, prices: List[int]) -> int:\\n\\n\\t\\t\\tn = len(prices)\\n\\n\\t\\t\\tif n == 0:\\n\\n\\t\\t\\t\\t## Base case:\\n\\t\\t\\t\\t# Price sequence is empty, we can do nothing : )\\n\\t\\t\\t\\treturn 0\\n\\n\\n\\t\\t\\t## General case:\\n\\n\\t\\t\\t# DP[ k ][ d ] = max profit on k, d\\n\\t\\t\\t# where k stands for k-th transaction, d stands for d-th trading day.\\n\\t\\t\\tdp = [ [ 0 for _ in range(n)] for _ in range(k+1) ]\\n\\n\\n\\t\\t\\t# Update by each transction as well as each trading day\\n\\t\\t\\tfor trans_k in range(1, k+1):\\n\\n\\t\\t\\t\\t# Balance before 1st transaction must be zero\\n\\t\\t\\t\\t# Buy stock on first day means -prices[0]\\n\\t\\t\\t\\tcur_balance_with_buy = 0 - prices[0]\\n\\n\\t\\t\\t\\tfor day_d in range(1, n):\\n\\n\\t\\t\\t\\t\\t# Either we have finished all k transactions before, or just finished k-th transaction today\\n\\t\\t\\t\\t\\tdp[trans_k][day_d] = max( dp[trans_k][day_d-1], cur_balance_with_buy + prices[day_d] )\\n\\n\\t\\t\\t\\t\\t# Either keep holding the stock we bought before, or just buy in today\\n\\t\\t\\t\\t\\tcur_balance_with_buy = max(cur_balance_with_buy, dp[trans_k-1][day_d-1] - prices[day_d] )\\n\\n\\t\\t\\treturn dp[k][n-1]\\n\\t\\t# --------------------------------------------\\n\\t\\treturn trade_at_most_k_times(k=2, prices=prices)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39675,
                "title": "clear-c-solution",
                "content": "    int maxProfit(vector<int>& prices) {\\n        //It's wrong if you choose the minimum price for buy2 , but you can maximize the left money.\\n        //\\n        int buy1 = INT_MIN, sale1 = 0, buy2 = INT_MIN, sale2 = 0;\\n        for(int i=0; i<prices.size(); i++){                      //the more money left, the happier you will be\\n            buy1 = max(buy1, -prices[i]);                        //left money after buy1\\n            sale1 = max(sale1, prices[i] + buy1);                //left money after sale1\\n            buy2 = max(buy2, sale1 - prices[i]);                 //left money after buy2\\n            sale2 = max(sale2, prices[i] + buy2);                //left money after sale2\\n        }\\n        return sale2;\\n    }",
                "solutionTags": [],
                "code": "    int maxProfit(vector<int>& prices) {\\n        //It's wrong if you choose the minimum price for buy2 , but you can maximize the left money.\\n        //\\n        int buy1 = INT_MIN, sale1 = 0, buy2 = INT_MIN, sale2 = 0;\\n        for(int i=0; i<prices.size(); i++){                      //the more money left, the happier you will be\\n            buy1 = max(buy1, -prices[i]);                        //left money after buy1\\n            sale1 = max(sale1, prices[i] + buy1);                //left money after sale1\\n            buy2 = max(buy2, sale1 - prices[i]);                 //left money after buy2\\n            sale2 = max(sale2, prices[i] + buy2);                //left money after sale2\\n        }\\n        return sale2;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 794761,
                "title": "all-variants-of-best-time-to-buy-and-sell-stock-problems",
                "content": "\\n1. Atmost 1 Transaction      [Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/) Easy \\n2. Infinite Transactions        [Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/) Easy \\n3. Atmost K Transactions \\n\\t\\ti.    [Best Time to Buy and Sell Stock III](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/) Hard\\n\\t\\tii. [Best Time to Buy and Sell Stock IV](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/) Hard\\n\\t\\t\\n.\\n1. **Atmost 1 Transaction - Kadane\\'s algorithm**\\n\\n```\\n public int maxProfit(int[] prices) {\\n        int maxEndingHere = 0;\\n\\t\\tint maxSoFar = 0;\\n\\t\\tfor (int i = 1; i < prices.length; i++) {\\n\\t\\t\\tmaxEndingHere = Math.max(0, maxEndingHere+prices[i] - prices[i - 1]);\\n\\t\\t\\tmaxSoFar = Math.max(maxSoFar, maxEndingHere);\\n\\t\\t}\\n\\t\\treturn maxSoFar;\\n    }\\n```\\nTime : O(n)\\nSpace: O(1)\\n\\n**2. Infinite Transactions**\\n\\tIf you have increase in price compared to previous price, add it to profit\\n```\\n public int maxProfit(int[] prices) {\\n        int profit = 0;\\n\\t\\tfor (int i = 0; i < prices.length - 1; i++) {\\n\\t\\t\\tif (prices[i + 1] > prices[i]) {\\n\\t\\t\\t\\tprofit += prices[i+1] - prices[i];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn profit;\\n    }\\n```\\nTime : O(n)\\nSpace: O(1)\\n\\n**3. Atmost K Transactions**\\nThe third & fourth requires DP & are almost the same. If you solve for generic K, you can use the same for specfic K=2.\\n\\nI would recommend to watch this video.\\nhttps://www.youtube.com/watch?v=oDhu5uGq_ic\\n\\n```\\nDP: \\ndp[i][j] = Max(dp[i][j-1],prices[j]-prices[m]+dp[i-1][m])\\nm = 0..j-1\\n\\ndp[i][j-1]                     -> if you are not making a transaction on day j\\nprices[j]-prices[m]+dp[i-1][m] -> if you are making a transaction on day j, find the m th day to buy the stock \\ni = no of transactions\\nj = prices.length\\n\\nTime: O(k * n * n) \\nSpace: O(k * n) \\nk = K transactions\\nn = prices.length\\n```\\n**Optimized DP** \\n```\\nmaxDiff = Max(maxDiff,dp[i-1][j-1] - prices[j-1])\\ndp[i][j] = Max(dp[i][j-1],prices[j]+maxDiff)\\n\\ndp[i][j-1]                     -> if you are not making a transaction on day j\\nprices[j]-prices[m]+dp[i-1][m] -> if you are making a transaction on day j, compute the maxDiff from 0 ..j-1. In other words, we are reusing the maxDiff computed before. This reduces O(n) time complexity \\n\\nTime: O(k * n) \\nSpace: O(k * n) \\nk = K transactions\\nn = prices.length\\n```\\n**Best Time to Buy and Sell Stock III : Atmost 2 transactions**\\n\\n```\\n public int maxProfit(int[] prices) {\\n       if(prices.length ==0)\\n            return 0;\\n       int k=2;\\n       int dp[][] = new int[k + 1][prices.length];\\n\\t\\tfor (int i = 1; i < dp.length; i++) {\\n\\t\\t\\tint maxDiff = -prices[0];\\n\\t\\t\\tfor (int j = 1; j < dp[0].length; j++) {\\n\\t\\t\\t\\tmaxDiff = Math.max(maxDiff, dp[i - 1][j - 1] - prices[j - 1]);\\n\\t\\t\\t\\tdp[i][j] = Math.max(dp[i][j - 1], prices[j] + maxDiff);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[k][prices.length - 1];\\n    }\\n```\\nTime: O(k * n) \\nSpace: O(k * n) \\nk = K transactions\\nn = prices.length\\n\\n**Best Time to Buy and Sell Stock IV :**\\n```\\n\\tpublic int maxProfit(int k, int[] prices) {\\n\\t\\tif (k >= prices.length / 2)\\n\\t\\t\\treturn maxProfit(prices); // This is to avoid Memory Limit Exceeded for one of the test cases. In other words, you can make infinite transactions. Using variant 2 logic. \\n\\t\\tint dp[][] = new int[k + 1][prices.length];\\n\\t\\tfor (int i = 1; i < dp.length; i++) {\\n\\t\\t\\tint maxDiff = -prices[0];\\n\\t\\t\\tfor (int j = 1; j < dp[0].length; j++) {\\n\\t\\t\\t\\tmaxDiff = Math.max(maxDiff, dp[i - 1][j - 1] - prices[j - 1]);\\n\\t\\t\\t\\tdp[i][j] = Math.max(dp[i][j - 1], prices[j] + maxDiff);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[k][prices.length - 1];\\n\\t}\\n\\n\\tprivate int maxProfit(int[] prices) {\\n        int profit = 0;\\n\\t\\tfor (int i = 0; i < prices.length - 1; i++) {\\n\\t\\t\\tif (prices[i + 1] > prices[i]) {\\n\\t\\t\\t\\tprofit += prices[i+1] - prices[i];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn profit;\\n    }\\n```\\nTime: O(k * n) \\nSpace: O(k * n) \\nk = K transactions\\nn = prices.length",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n public int maxProfit(int[] prices) {\\n        int maxEndingHere = 0;\\n\\t\\tint maxSoFar = 0;\\n\\t\\tfor (int i = 1; i < prices.length; i++) {\\n\\t\\t\\tmaxEndingHere = Math.max(0, maxEndingHere+prices[i] - prices[i - 1]);\\n\\t\\t\\tmaxSoFar = Math.max(maxSoFar, maxEndingHere);\\n\\t\\t}\\n\\t\\treturn maxSoFar;\\n    }\\n```\n```\\n public int maxProfit(int[] prices) {\\n        int profit = 0;\\n\\t\\tfor (int i = 0; i < prices.length - 1; i++) {\\n\\t\\t\\tif (prices[i + 1] > prices[i]) {\\n\\t\\t\\t\\tprofit += prices[i+1] - prices[i];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn profit;\\n    }\\n```\n```\\nDP: \\ndp[i][j] = Max(dp[i][j-1],prices[j]-prices[m]+dp[i-1][m])\\nm = 0..j-1\\n\\ndp[i][j-1]                     -> if you are not making a transaction on day j\\nprices[j]-prices[m]+dp[i-1][m] -> if you are making a transaction on day j, find the m th day to buy the stock \\ni = no of transactions\\nj = prices.length\\n\\nTime: O(k * n * n) \\nSpace: O(k * n) \\nk = K transactions\\nn = prices.length\\n```\n```\\nmaxDiff = Max(maxDiff,dp[i-1][j-1] - prices[j-1])\\ndp[i][j] = Max(dp[i][j-1],prices[j]+maxDiff)\\n\\ndp[i][j-1]                     -> if you are not making a transaction on day j\\nprices[j]-prices[m]+dp[i-1][m] -> if you are making a transaction on day j, compute the maxDiff from 0 ..j-1. In other words, we are reusing the maxDiff computed before. This reduces O(n) time complexity \\n\\nTime: O(k * n) \\nSpace: O(k * n) \\nk = K transactions\\nn = prices.length\\n```\n```\\n public int maxProfit(int[] prices) {\\n       if(prices.length ==0)\\n            return 0;\\n       int k=2;\\n       int dp[][] = new int[k + 1][prices.length];\\n\\t\\tfor (int i = 1; i < dp.length; i++) {\\n\\t\\t\\tint maxDiff = -prices[0];\\n\\t\\t\\tfor (int j = 1; j < dp[0].length; j++) {\\n\\t\\t\\t\\tmaxDiff = Math.max(maxDiff, dp[i - 1][j - 1] - prices[j - 1]);\\n\\t\\t\\t\\tdp[i][j] = Math.max(dp[i][j - 1], prices[j] + maxDiff);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[k][prices.length - 1];\\n    }\\n```\n```\\n\\tpublic int maxProfit(int k, int[] prices) {\\n\\t\\tif (k >= prices.length / 2)\\n\\t\\t\\treturn maxProfit(prices); // This is to avoid Memory Limit Exceeded for one of the test cases. In other words, you can make infinite transactions. Using variant 2 logic. \\n\\t\\tint dp[][] = new int[k + 1][prices.length];\\n\\t\\tfor (int i = 1; i < dp.length; i++) {\\n\\t\\t\\tint maxDiff = -prices[0];\\n\\t\\t\\tfor (int j = 1; j < dp[0].length; j++) {\\n\\t\\t\\t\\tmaxDiff = Math.max(maxDiff, dp[i - 1][j - 1] - prices[j - 1]);\\n\\t\\t\\t\\tdp[i][j] = Math.max(dp[i][j - 1], prices[j] + maxDiff);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn dp[k][prices.length - 1];\\n\\t}\\n\\n\\tprivate int maxProfit(int[] prices) {\\n        int profit = 0;\\n\\t\\tfor (int i = 0; i < prices.length - 1; i++) {\\n\\t\\t\\tif (prices[i + 1] > prices[i]) {\\n\\t\\t\\t\\tprofit += prices[i+1] - prices[i];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn profit;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2557395,
                "title": "java-no-dp",
                "content": "### Please Upvote :D\\n``` java []\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int minPrice1 = Integer. MAX_VALUE, minPrice2 = Integer. MAX_VALUE;\\n        int profit1 = 0, profit2 = 0;\\n\\n        for (int currPrice : prices) {\\n            minPrice1 = Math.min(currPrice, minPrice1);\\n            profit1 = Math.max(profit1, currPrice - minPrice1);\\n\\n            minPrice2 = Math.min(minPrice2, currPrice - profit1);\\n            profit2 = Math.max(profit2, currPrice - minPrice2);\\n\\n        }\\n\\n        return profit2;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int minPrice1 = Integer. MAX_VALUE, minPrice2 = Integer. MAX_VALUE;\\n        int profit1 = 0, profit2 = 0;\\n\\n        for (int currPrice : prices) {\\n            minPrice1 = Math.min(currPrice, minPrice1);\\n            profit1 = Math.max(profit1, currPrice - minPrice1);\\n\\n            minPrice2 = Math.min(minPrice2, currPrice - profit1);\\n            profit2 = Math.max(profit2, currPrice - minPrice2);\\n\\n        }\\n\\n        return profit2;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794590,
                "title": "java-o-4-space-2-ms-runtime-using-state-machine-explained",
                "content": "\\nThe idea behind using a state machine.\\n\\nTo find the profit each transaction has 2 states\\n\\nState 1 -> Buying\\nState 2 -> Selling\\n\\nWhen we buying, we use the profit. So profit = profit - stock price\\nWhen we selling, we add the earning into profit. So profit = profit + stock price\\n\\nUsing the above idea we create a state machine to find profit from at most 2 transactions (4 states).\\n\\nState machine will look like:\\n\\n```\\ntransaction1 :- buy1 = max(buy1, 0 - stock) // for the 1st buy profit is 0\\n\\t\\t\\t\\tsell1 = max(sell1, buy1 + stock)\\n```\\nFor 2nd trasaction we use the profit accumulated from 1st transaction\\n```\\ntransaction2 :- buy2 = max(buy2, sell1 - stock)\\n\\t\\t\\t\\tsell2 = max(sell2, buy2 + stock)\\n```\\nSolution:\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if(prices == null || prices.length < 1) return 0;\\n        int buy1 = -prices[0], sell1 = 0, buy2 = -prices[0], sell2 = 0;\\n        for(int i = 1; i < prices.length; i++) {\\n            buy1 = Math.max(buy1, -prices[i]);\\n            sell1 = Math.max(sell1, buy1 + prices[i]);\\n            buy2 = Math.max(buy2, sell1 - prices[i]);\\n            sell2 = Math.max(sell2, buy2 + prices[i]);\\n        }\\n        return sell2;\\n    }\\n}\\n```\\nFor any doubt feel free to drop the question. If you like the solution please **UpVote!**",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\ntransaction1 :- buy1 = max(buy1, 0 - stock) // for the 1st buy profit is 0\\n\\t\\t\\t\\tsell1 = max(sell1, buy1 + stock)\\n```\n```\\ntransaction2 :- buy2 = max(buy2, sell1 - stock)\\n\\t\\t\\t\\tsell2 = max(sell2, buy2 + stock)\\n```\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if(prices == null || prices.length < 1) return 0;\\n        int buy1 = -prices[0], sell1 = 0, buy2 = -prices[0], sell2 = 0;\\n        for(int i = 1; i < prices.length; i++) {\\n            buy1 = Math.max(buy1, -prices[i]);\\n            sell1 = Math.max(sell1, buy1 + prices[i]);\\n            buy2 = Math.max(buy2, sell1 - prices[i]);\\n            sell2 = Math.max(sell2, buy2 + prices[i]);\\n        }\\n        return sell2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 192322,
                "title": "c-2-dp-solutions",
                "content": "# Naive Solution\\nThis solution is based on the [Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/) where you track the global min price and max profit. It\\'s easier to come up with, but requires extra memory.\\n\\n- Go left to right, and store the best profit for each day individually in ```left```\\n  - ```left[i]``` shows the max profit for days ```[1, i]``` \\n- Go right to left, store best profit in ```right```\\n  - ```right[i]``` shows the max profit for days ```[i + 1, n]```\\n- The maximum profit is the maximum of ```left[i] + right[i]```\\n```\\nint maxProfit(vector<int>& prices) {\\n  int n = prices.size(), min_l = INT_MAX, max_r = 0, res = 0;\\n  vector<int> left(n + 1), right(n + 1);\\n  for (auto i = 0; i < n; ++i) {\\n    auto price_l = prices[i], price_r = prices[n - i - 1];\\n    min_l = min(min_l, price_l);\\n    max_r = max(max_r, price_r);\\n    left[i + 1] = max(left[i], price_l - min_l);\\n    right[n - i - 1] = max(right[n - i], max_r - price_r);\\n  }\\n  for (auto i = 0; i <= n; ++i) res = max(res, left[i] + right[i]);\\n  return res;\\n}\\n```\\n## Complexity Analysis\\nRuntime: *O(n)*\\nMemory: *O(n)*\\n# O(1) Memory Solution\\nThroughout the trading days, our balance changes as follows:\\n-\\tDrops after we buy stock first time (```- p1```)\\n-\\tRises after we sell it (```+ p2```)\\n-\\tDips after we buy stock second time (```- p3```)\\n-\\tHikes after we sell it (```+ p4```)\\n\\nIn the solution below, we just track the maximum balance after we perform each of the four operations:\\n```\\nint maxProfit(vector<int>& prices) {\\n  auto buy1 = INT_MIN, buy2 = INT_MIN, sell1 = 0, sell2 = 0;\\n  for (auto p : prices) {\\n    buy1 = max(buy1, -p);\\n    sell1 = max(sell1, buy1 + p);\\n    buy2 = max(buy2, sell1 - p);\\n    sell2 = max(sell2, buy2 + p);\\n  }\\n  return sell2;\\n}\\n```\\n## Complexity Analysis\\nRuntime: *O(n)*\\nMemory: *O(1)*",
                "solutionTags": [],
                "code": "```left```\n```left[i]```\n```[1, i]```\n```right```\n```right[i]```\n```[i + 1, n]```\n```left[i] + right[i]```\n```\\nint maxProfit(vector<int>& prices) {\\n  int n = prices.size(), min_l = INT_MAX, max_r = 0, res = 0;\\n  vector<int> left(n + 1), right(n + 1);\\n  for (auto i = 0; i < n; ++i) {\\n    auto price_l = prices[i], price_r = prices[n - i - 1];\\n    min_l = min(min_l, price_l);\\n    max_r = max(max_r, price_r);\\n    left[i + 1] = max(left[i], price_l - min_l);\\n    right[n - i - 1] = max(right[n - i], max_r - price_r);\\n  }\\n  for (auto i = 0; i <= n; ++i) res = max(res, left[i] + right[i]);\\n  return res;\\n}\\n```\n```- p1```\n```+ p2```\n```- p3```\n```+ p4```\n```\\nint maxProfit(vector<int>& prices) {\\n  auto buy1 = INT_MIN, buy2 = INT_MIN, sell1 = 0, sell2 = 0;\\n  for (auto p : prices) {\\n    buy1 = max(buy1, -p);\\n    sell1 = max(sell1, buy1 + p);\\n    buy2 = max(buy2, sell1 - p);\\n    sell2 = max(sell2, buy2 + p);\\n  }\\n  return sell2;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 39680,
                "title": "o-n-time-o-1-space-very-elegant-solution-with-comments",
                "content": "    class Solution {\\n    public:\\n        int maxProfit(vector<int>& prices) {\\n            vector<int> res(4, 0);\\n            res[0] = INT_MIN;\\n            res[2] = INT_MIN;\\n            for(int i = 0; i < prices.size(); ++i) {\\n                res[3] = max(res[3], res[2] + prices[i]);  // Transaction 2: sell\\n                res[2] = max(res[2], res[1] - prices[i]);  // Transaction 2: buy\\n                res[1] = max(res[1], res[0] + prices[i]);  // Transaction 1: sell\\n                res[0] = max(res[0], -prices[i]);          // Transaction 1: buy\\n            }\\n            return max(res[1], res[3]);\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int maxProfit(vector<int>& prices) {\\n            vector<int> res(4, 0);\\n            res[0] = INT_MIN;\\n            res[2] = INT_MIN;\\n            for(int i = 0; i < prices.size(); ++i) {\\n                res[3] = max(res[3], res[2] + prices[i]);  // Transaction 2: sell\\n                res[2] = max(res[2], res[1] - prices[i]);  // Transaction 2: buy\\n                res[1] = max(res[1], res[0] + prices[i]);  // Transaction 1: sell\\n                res[0] = max(res[0], -prices[i]);          // Transaction 1: buy\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 39693,
                "title": "python-o-n-solution-using-forward-and-backward-phases",
                "content": "    def maxProfit(prices):\\n        max_total_profit = 0\\n        first_profits = [0]*len(prices)\\n        min_price = float('inf')\\n        \\n        # Forward phase\\n        for i in range(len(prices)):\\n            min_price = min(min_price, prices[i])\\n            profit = prices[i] - min_price\\n            max_total_profit = max(max_total_profit, profit)\\n            first_profits[i] = max_total_profit\\n        \\n        max_price = float('-inf')\\n        \\n        # Backward phase\\n        for j in range(len(prices)-1,0,-1):\\n            max_price = max(max_price, prices[j])\\n            profit = max_price - prices[j]\\n            max_total_profit = max(max_total_profit, first_profits[j-1] + profit)\\n        \\n        return max_total_profit",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def maxProfit(prices):\\n        max_total_profit = 0\\n        first_profits = [0]*len(prices)\\n        min_price = float('inf')\\n        \\n        # Forward phase\\n        for i in range(len(prices)):\\n            min_price = min(min_price, prices[i])\\n            profit = prices[i] - min_price\\n            max_total_profit = max(max_total_profit, profit)\\n            first_profits[i] = max_total_profit\\n        \\n        max_price = float('-inf')\\n        \\n        # Backward phase\\n        for j in range(len(prices)-1,0,-1):\\n            max_price = max(max_price, prices[j])\\n            profit = max_price - prices[j]\\n            max_total_profit = max(max_total_profit, first_profits[j-1] + profit)\\n        \\n        return max_total_profit",
                "codeTag": "Python3"
            },
            {
                "id": 39727,
                "title": "a-clear-o-n-time-and-space-java-solution",
                "content": "    public class Solution { \\n        public int maxProfit(int[] prices) {\\n            int len = prices.length;\\n            if (len < 2)\\n                return 0;\\n            int [] maxBefore = new int[len];\\n            int min = prices[0];\\n            for(int i=1; i<len; i++)\\n            {\\n                maxBefore[i] = Math.max(maxBefore[i-1], prices[i] - min);\\n                min = Math.min(min, prices[i]);\\n            }\\n            int max = prices[len-1];\\n            int ret = 0;\\n            for (int i=len-2; i>=0; i--)\\n            {\\n                max = Math.max(prices[i], max);\\n                ret = Math.max(ret, max - prices[i] + maxBefore[i]);   \\n            }\\n            return ret;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution { \\n        public int maxProfit(int[] prices) {\\n            int len = prices.length;\\n            if (len < 2)\\n                return 0;\\n            int [] maxBefore = new int[len];\\n            int min = prices[0];\\n            for(int i=1; i<len; i++)\\n            {\\n                maxBefore[i] = Math.max(maxBefore[i-1], prices[i] - min);\\n                min = Math.min(min, prices[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3195880,
                "title": "with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe basic idea is to iterate over the array of stock prices and update four variables:\\n\\nbuy1 - the minimum price seen so far for the first transaction\\nsell1 - the maximum profit seen so far for the first transaction\\nbuy2 - the minimum price seen so far for the second transaction, taking into account the profit from the first transaction\\nsell2 - the maximum profit seen so far for the second transaction\\nAt the end of the iteration, the value of sell2 is returned as the maximum profit achievable with two transactions.\\n\\nThe if not prices check is included to handle the edge case where the input array is empty.\\n\\nHere\\'s how the algorithm works step by step for the input [3,3,5,0,0,3,1,4]:\\n\\n1. Initialize buy1, buy2, sell1, and sell2 to inf, inf, 0, and 0, respectively.\\n2. For the first price of 3, update buy1 to 3, sell1 to 0, buy2 to -3, and sell2 to 0.\\n3. For the second price of 3, update buy1 to 3, sell1 to 0, buy2 to -3, and sell2 to 0 (no change).\\n4. For the third price of 5, update buy1 to 3, sell1 to 2, buy2 to -1, and sell2 to 2.\\n5. For the fourth price of 0, update buy1 to 0, sell1 to 2, buy2 to -1, and sell2 to 2 (no change).\\n6. For the fifth price of 0, update buy1 to 0, sell1 to 2, buy2 to -2, and sell2 to 2 (no change).\\n7. For the sixth price of 3, update buy1 to 0, sell1 to 3, buy2 to 0, and sell2 to 3.\\n8. For the seventh price of 1, update buy1 to 0, sell1 to 3, buy2 to -3, and sell2 to 3 (no change).\\n9. For the eighth price of 4, update buy1 to 0, sell1 to 4, buy2 to 0, and sell2 to 4\\n# Complexity\\n- Time complexity:\\nBeats\\n88.20%\\n\\n- Space complexity:\\nBeats\\n91.19%\\n\\n# Code\\n```\\nclass Solution:\\n  def maxProfit(self, prices: List[int]) -> int:\\n    if not prices:\\n        return 0\\n\\n    # initialize variables for first buy, first sell, second buy, and second sell\\n    buy1, buy2 = float(\\'inf\\'), float(\\'inf\\')\\n    sell1, sell2 = 0, 0\\n\\n    # iterate over prices to update buy and sell values\\n    for price in prices:\\n        # update first buy and sell values\\n        buy1 = min(buy1, price)\\n        sell1 = max(sell1, price - buy1)\\n        # update second buy and sell values\\n        buy2 = min(buy2, price - sell1)\\n        sell2 = max(sell2, price - buy2)\\n\\n    return sell2\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n  def maxProfit(self, prices: List[int]) -> int:\\n    if not prices:\\n        return 0\\n\\n    # initialize variables for first buy, first sell, second buy, and second sell\\n    buy1, buy2 = float(\\'inf\\'), float(\\'inf\\')\\n    sell1, sell2 = 0, 0\\n\\n    # iterate over prices to update buy and sell values\\n    for price in prices:\\n        # update first buy and sell values\\n        buy1 = min(buy1, price)\\n        sell1 = max(sell1, price - buy1)\\n        # update second buy and sell values\\n        buy2 = min(buy2, price - sell1)\\n        sell2 = max(sell2, price - buy2)\\n\\n    return sell2\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2391981,
                "title": "c-solution-with-explanation-representation-recursion-dp-space-optimisation",
                "content": "\\n****\\n***Please upvote if it helps.....***\\n****\\n***Solution :***\\n****\\nEvery day, we will have two choices, either to do nothing and move to the next day or to buy/sell (based on the last transaction and the number of transactions left) and find out the profit. Therefore we need to generate all the choices in order to compare the profit. As we need to try out all the possible choices, we will use recursion.\\n****\\n****\\n***Steps to form the recursive solution:*** \\n****\\n\\n***Step 1:*** Express the problem in terms of indexes.\\n\\nWe need to think in the terms of the number of days, therefore one variable will be the array index( say ind). Next, we need to respect the condition that we can\\u2019t buy a stock again, that is we need to first sell a stock, and then we can buy that again. Therefore we need a second variable \\u2018buy\\u2019 which tells us on a particular day whether we can buy or sell the stock. Next, we have a cap on the number of transactions that we can make. Here the initial cap is 2. We need to always keep in mind this constraint. We can generalize the function as :\\n![image](https://assets.leetcode.com/users/images/b5286616-f810-4eb5-b38f-abf1b3086bd3_1659858371.5456293.png)\\n\\n\\n\\n***Step 2:*** Try out all possible choices at a given index.\\n\\nEvery day, we have two choices:\\n\\n* To either buy/sell the stock(based on the buy variable\\u2019s value and if \\u2018cap\\u2019 > 0). \\n* To do nothing and move on to the next day.\\n\\n***Case 1:*** When buy == 0, we can buy the stock.\\n\\nIf we can buy the stock on a particular day, we have two options:\\n\\n* Option 1: To do no transaction and move to the next day. In this case, the net profit earned will be 0 from the current transaction, and to calculate the maximum profit starting from the next day, we will recursively call f(ind+1,0, cap). As we have not bought the stock, the \\u2018buy\\u2019 variable value will still remain 0, indicating that we can buy the stock the next day. And the \\u2018cap\\u2019 variable will remain the same as if no transaction took place.\\n* Option 2: The other option is to buy the stock on the current day. In this case, the net profit earned from the current transaction will be -Arr[i]. As we are buying the stock, we are giving money out of our pocket, therefore the profit we earn is negative. To calculate the maximum profit starting from the next day, we will recursively call f(ind+1,1, cap). As we have bought the stock, the \\u2018buy\\u2019 variable value will change to 1, indicating that we can\\u2019t buy and only sell the stock the next day. As we have only bought the stock and not sold it the transaction remains incomplete and the \\u2018cap\\u2019 variable value remains unchanged.\\n\\n***Case 2:*** When buy == 1, we can sell the stock.\\n\\nIf we can buy the stock on a particular day, we have two options:\\n\\n* Option 1: To do no transaction and move to the next day. In this case, the net profit earned will be 0 from the current transaction, and to calculate the maximum profit starting from the next day, we will recursively call f(ind+1,1, cap). As we have not bought the stock, the \\u2018buy\\u2019 variable value will still remain at 1, indicating that we can\\u2019t buy and only sell the stock the next day. And the \\u2018cap\\u2019 variable will remain the same as if no transaction took place.\\n* Option 2: The other option is to sell the stock on the current day. In this case, the net profit earned from the current transaction will be +Arr[i]. As we are selling the stock, we are putting the money into our pocket, therefore the profit we earn is positive. To calculate the maximum profit starting from the next day, we will recursively call f(ind+1,0,cap-1). As we have sold the stock, the \\u2018buy\\u2019 variable value will change to 0, indicating that we can buy the stock the next day. As we have sold the earlier bought stock, we make one complete transaction, therefore now we update the \\u2018cap\\u2019 variable\\u2019s value to cap-1.\\n\\n***Note:*** Buying and selling a stock together counts as one complete transaction.\\n\\nThe figure below gives us the summary:\\n![image](https://assets.leetcode.com/users/images/8a9b58a0-de8b-478f-a2b2-dbf286b96959_1659858527.7326622.png)\\n\\n![image](https://assets.leetcode.com/users/images/75609612-e377-4678-b10b-2ec827bd1dcf_1659858535.2465227.png)\\n\\n***Step 3:***  Return the maximum \\n\\nAs we are looking to maximize the profit earned, we will return the maximum value in both cases.\\n****\\n***Base Cases:***\\n****\\n* If ind==n, it means we have finished trading on all days, and there is no more money that we can get, therefore we simply return 0.\\n* If cap==0, it means that we cannot make any more transactions. Therefore we return 0.\\n\\nThe final pseudocode after steps 1, 2, and 3:\\n\\n![image](https://assets.leetcode.com/users/images/6beea6c7-827f-42fb-beed-74852396c06e_1659858582.8190408.png)\\n****\\n****\\n\\n***Steps to memoize a recursive solution:***\\n****\\nIf we draw the recursion tree, we will see that there are overlapping subproblems. In order to convert a recursive solution the following steps will be taken:\\n\\n1. Create a dp array of size [n][2][3]. The size of the input array is \\u2018n\\u2019, so the index will always lie between \\u20180\\u2019 and \\u2018n-1\\u2019. The \\u2018buy\\u2019  variable can take only two values: 0 and 1 and the \\u2018cap\\u2019 variable can only take three variables 0, 1, and 2. Therefore we take the dp array as dp[n][2][3].\\n1. We initialize the dp array to -1.\\n1. Whenever we want to find the answer of particular parameters (say f(ind,buy,cap)), we first check whether the answer is already calculated using the dp array(i.e dp[ind][buy][cap]!= -1 ). If yes, simply return the value from the dp array.\\n1. If not, then we are finding the answer for the given value for the first time, we will use the recursive relation as usual but before returning from the function, we will set dp[ind][buy][cap] to the solution we get.\\n****\\n****\\n***C++ Code:***\\n****\\n```\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nint getAns(vector<int>& Arr, int n, int ind, int buy, int cap, vector<vector<vector<int>>>& dp ){\\n\\n    if(ind==n || cap==0) return 0; //base case\\n    \\n    if(dp[ind][buy][cap]!=-1)\\n        return dp[ind][buy][cap];\\n        \\n    int profit;\\n    \\n    if(buy==0){// We can buy the stock\\n        profit = max(0+getAns(Arr,n,ind+1,0,cap,dp), \\n                    -Arr[ind] + getAns(Arr,n,ind+1,1,cap,dp));\\n    }\\n    \\n    if(buy==1){// We can sell the stock\\n        profit = max(0+getAns(Arr,n,ind+1,1,cap,dp),\\n                    Arr[ind] + getAns(Arr,n,ind+1,0,cap-1,dp));\\n    }\\n    \\n    return dp[ind][buy][cap] = profit;\\n}\\n\\n\\nint maxProfit(vector<int>& prices, int n)\\n{\\n    // Creating a 3d - dp of size [n][2][3]\\n    vector<vector<vector<int>>> dp(n,\\n                                    vector<vector<int>> \\n                                            (2,vector<int>(3,-1)));\\n    \\n    return getAns(prices,n,0,0,2,dp);\\n   \\n}\\n\\nint main() {\\n\\n  vector<int> prices = {3,3,5,0,0,3,1,4};\\n  int n = prices.size();\\n                                 \\n  cout<<\"The maximum profit that can be generated is \"<<maxProfit(prices, n);\\n}\\n```\\n****\\n***Output:***\\n****\\nThe maximum profit that can be generated is 6\\n****\\n***Time Complexity: O(Nx2x3)*** \\n\\nReason: There are N*2*3 states therefore at max \\u2018N*2*3\\u2019 new problems will be solved.\\n\\n***Space Complexity: O(Nx2x3) + O(N)***\\n\\nReason: We are using a recursion stack space(O(N)) and a 3D array ( O(N*2*3)).\\n****\\n****\\n***Steps to convert Recursive Solution to Tabulation one.***\\n\\nTo convert the memoization approach to a tabulation one, create a dp array with the size [N+1][2][3].\\n\\n***Handling the base case:***\\n\\nNow, what the base condition in the recursive relation is:\\n\\n***if( ind == n || cap == 0) return 0***\\n\\nWe handle this in the following way:\\n\\n* ind == n\\n\\nWhen ind == n, the other two variables: cap and buy can take any value, therefore we can set the following two loops and set dp[n][buy][cap] = 0\\n\\n![image](https://assets.leetcode.com/users/images/134b4d13-271a-4f74-a0c8-50213cfe0603_1659858821.4577162.png)\\n\\n\\n* cap == 0\\nWhen cap == 0, the other two variables: ind and cap can take any value, therefore we can set the following two loops and set dp[ind][buy][0] = 0.\\n\\n![image](https://assets.leetcode.com/users/images/0e29e65d-3113-4d1d-af1e-6f46f002a46d_1659858832.8191407.png)\\n\\n\\nAnother hack is to initialize the entire 3D DP Array as 0. In this case, we need not worry about explicitly setting the base cases.\\n\\n* First, we declare the dp array of size [n+1][2][3] as zero.\\n* As we have initialized the array as 0, we have automatically set the base condition as explained above.\\n* Now, traverse the array in the opposite direction of that of the memoization technique. We will start from ind = n-1 -> ind =0.\\n* In every iteration copy the recursive code logic.\\n* At last dp[0][0][2] ( maximum profit generated on ith day, when we can buy the stock on 0th day and can have a total 2 transactions) gives us the final answer.\\n****\\n****\\n***C++ Code:***\\n****\\n```\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\n\\nint maxProfit(vector<int>& Arr, int n)\\n{\\n    // Creating a 3d - dp of size [n+1][2][3] initialized to 0\\n    vector<vector<vector<int>>> dp(n+1,\\n                                    vector<vector<int>> \\n                                            (2,vector<int>(3,0)));\\n                                            \\n    // As dp array is intialized to 0, we have already covered the base case\\n    \\n    for(int ind = n-1; ind>=0; ind--){\\n        for(int buy = 0; buy<=1; buy++){\\n            for(int cap=1; cap<=2; cap++){\\n                \\n                if(buy==0){// We can buy the stock\\n                    dp[ind][buy][cap] = max(0+dp[ind+1][0][cap], \\n                                -Arr[ind] + dp[ind+1][1][cap]);\\n                 }\\n    \\n                if(buy==1){// We can sell the stock\\n                    dp[ind][buy][cap] = max(0+dp[ind+1][1][cap],\\n                                Arr[ind] + dp[ind+1][0][cap-1]);\\n                }\\n            }\\n        }\\n    }\\n    \\n    \\n    return dp[0][0][2];\\n   \\n}\\n\\nint main() {\\n\\n  vector<int> prices = {3,3,5,0,0,3,1,4};\\n  int n = prices.size();\\n                                 \\n  cout<<\"The maximum profit that can be generated is \"<<maxProfit(prices, n);\\n}\\n```\\n****\\n***Output:***\\n\\nThe maximum profit that can be generated is 6\\n****\\n***Time Complexity: O(Nx2x3)***\\n\\nReason: There are three nested loops that account for O(Nx2x3) complexity.\\n\\n***Space Complexity: O(Nx2x3)***\\n\\nReason: We are using an external array of size \\u2018Nx2x3\\u2019. Stack Space is eliminated.\\n****\\n****\\n***Part 3: Space Optimization***\\n****\\nIf we closely look at the relation,\\n\\n***dp[ind][buy][cap] = max( dp[ind+1][buy][cap] , max( dp[ind+1][!buy][cap])***\\n\\nWe see that to calculate a value of a cell of the dp array, we need only the next row values(say ahead of ind+1). So, we don\\u2019t need to store an entire 2-D array. Hence we can space optimize it.\\n\\n![image](https://assets.leetcode.com/users/images/be971eac-74b1-4330-a473-3ff49a407ee3_1659859002.6638644.png)\\n\\n\\n* We set a 2D vector ahead initialized to 0 (base condition) and another 2D\\n* Then we set three nested loops to calculate the cur array\\u2019s values.\\n* We replace dp[ind] with cur and dp[ind+1] with ahead in our tabulation code.\\n* After the inner loop execution, we set ahead as cur for the next outer loop iteration.\\n* At last, we return ahead[0][2] as our answer.\\n****\\n****\\n***C++ Code:***\\n****\\n```\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\n\\nint maxProfit(vector<int>& Arr, int n)\\n{\\n    \\n    vector<vector<int>> ahead(2,vector<int> (3,0));\\n    \\n    vector<vector<int>> cur(2,vector<int> (3,0));\\n    \\n    \\n    for(int ind = n-1; ind>=0; ind--){\\n        for(int buy = 0; buy<=1; buy++){\\n            for(int cap=1; cap<=2; cap++){\\n                \\n                if(buy==0){// We can buy the stock\\n                    cur[buy][cap] = max(0+ahead[0][cap], \\n                                -Arr[ind] + ahead[1][cap]);\\n                 }\\n    \\n                if(buy==1){// We can sell the stock\\n                    cur[buy][cap] = max(0+ahead[1][cap],\\n                                Arr[ind] + ahead[0][cap-1]);\\n                }\\n            }\\n        }\\n        ahead = cur;\\n    }\\n    \\n    return ahead[0][2];\\n   \\n}\\n\\nint main() {\\n\\n  vector<int> prices = {3,3,5,0,0,3,1,4};\\n  int n = prices.size();\\n                                 \\n  cout<<\"The maximum profit that can be generated is \"<<maxProfit(prices, n);\\n}\\n```\\n****\\n***Output:***\\n\\nThe maximum profit that can be generated is 6\\n****\\n****\\n***Time Complexity: O(Nx2x3)***\\n\\nReason: There are three nested loops that account for O(Nx2x3) complexity.\\n\\n***Space Complexity: O(1)***\\n\\nReason: We are using two external arrays of size \\u20182x3\\u2019.\\n****\\n****\\n***Please upvote if it helps.....***\\n****",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\nint getAns(vector<int>& Arr, int n, int ind, int buy, int cap, vector<vector<vector<int>>>& dp ){\\n\\n    if(ind==n || cap==0) return 0; //base case\\n    \\n    if(dp[ind][buy][cap]!=-1)\\n        return dp[ind][buy][cap];\\n        \\n    int profit;\\n    \\n    if(buy==0){// We can buy the stock\\n        profit = max(0+getAns(Arr,n,ind+1,0,cap,dp), \\n                    -Arr[ind] + getAns(Arr,n,ind+1,1,cap,dp));\\n    }\\n    \\n    if(buy==1){// We can sell the stock\\n        profit = max(0+getAns(Arr,n,ind+1,1,cap,dp),\\n                    Arr[ind] + getAns(Arr,n,ind+1,0,cap-1,dp));\\n    }\\n    \\n    return dp[ind][buy][cap] = profit;\\n}\\n\\n\\nint maxProfit(vector<int>& prices, int n)\\n{\\n    // Creating a 3d - dp of size [n][2][3]\\n    vector<vector<vector<int>>> dp(n,\\n                                    vector<vector<int>> \\n                                            (2,vector<int>(3,-1)));\\n    \\n    return getAns(prices,n,0,0,2,dp);\\n   \\n}\\n\\nint main() {\\n\\n  vector<int> prices = {3,3,5,0,0,3,1,4};\\n  int n = prices.size();\\n                                 \\n  cout<<\"The maximum profit that can be generated is \"<<maxProfit(prices, n);\\n}\\n```\n```\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\n\\nint maxProfit(vector<int>& Arr, int n)\\n{\\n    // Creating a 3d - dp of size [n+1][2][3] initialized to 0\\n    vector<vector<vector<int>>> dp(n+1,\\n                                    vector<vector<int>> \\n                                            (2,vector<int>(3,0)));\\n                                            \\n    // As dp array is intialized to 0, we have already covered the base case\\n    \\n    for(int ind = n-1; ind>=0; ind--){\\n        for(int buy = 0; buy<=1; buy++){\\n            for(int cap=1; cap<=2; cap++){\\n                \\n                if(buy==0){// We can buy the stock\\n                    dp[ind][buy][cap] = max(0+dp[ind+1][0][cap], \\n                                -Arr[ind] + dp[ind+1][1][cap]);\\n                 }\\n    \\n                if(buy==1){// We can sell the stock\\n                    dp[ind][buy][cap] = max(0+dp[ind+1][1][cap],\\n                                Arr[ind] + dp[ind+1][0][cap-1]);\\n                }\\n            }\\n        }\\n    }\\n    \\n    \\n    return dp[0][0][2];\\n   \\n}\\n\\nint main() {\\n\\n  vector<int> prices = {3,3,5,0,0,3,1,4};\\n  int n = prices.size();\\n                                 \\n  cout<<\"The maximum profit that can be generated is \"<<maxProfit(prices, n);\\n}\\n```\n```\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\n\\nint maxProfit(vector<int>& Arr, int n)\\n{\\n    \\n    vector<vector<int>> ahead(2,vector<int> (3,0));\\n    \\n    vector<vector<int>> cur(2,vector<int> (3,0));\\n    \\n    \\n    for(int ind = n-1; ind>=0; ind--){\\n        for(int buy = 0; buy<=1; buy++){\\n            for(int cap=1; cap<=2; cap++){\\n                \\n                if(buy==0){// We can buy the stock\\n                    cur[buy][cap] = max(0+ahead[0][cap], \\n                                -Arr[ind] + ahead[1][cap]);\\n                 }\\n    \\n                if(buy==1){// We can sell the stock\\n                    cur[buy][cap] = max(0+ahead[1][cap],\\n                                Arr[ind] + ahead[0][cap-1]);\\n                }\\n            }\\n        }\\n        ahead = cur;\\n    }\\n    \\n    return ahead[0][2];\\n   \\n}\\n\\nint main() {\\n\\n  vector<int> prices = {3,3,5,0,0,3,1,4};\\n  int n = prices.size();\\n                                 \\n  cout<<\"The maximum profit that can be generated is \"<<maxProfit(prices, n);\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2040316,
                "title": "o-n-time-beats-99-97-memory-speed-0ms-may-2022",
                "content": "```\\n```\\n\\n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 38.2MB*** (beats 92.04% / 24.00%).\\n* ***Java***\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if(prices == null || prices.length < 1) return 0;\\n        int buy1 = -prices[0], sell1 = 0, buy2 = -prices[0], sell2 = 0;\\n        for(int i = 1; i < prices.length; i++) {\\n            buy1 = Math.max(buy1, -prices[i]);\\n            sell1 = Math.max(sell1, buy1 + prices[i]);\\n            buy2 = Math.max(buy2, sell1 - prices[i]);\\n            sell2 = Math.max(sell2, buy2 + prices[i]);\\n        }\\n        return sell2;\\n    }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 7.0MB*** (beats 100.00% / 100.00%).\\n* ***C++***\\n```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<int>&prices, int day, int transactionsLeft){\\n        \\n        if(day == prices.size()){\\n            return 0;\\n        }\\n        \\n        if(transactionsLeft == 0){\\n            return 0;\\n        }\\n        \\n        // choice 1\\n        // no transaction today\\n        int ans1 = solve(prices, day + 1, transactionsLeft);\\n        \\n        \\n        // choice 2\\n        // doing the possible transaction today     \\n        int ans2 = 0;\\n        bool buy = (transactionsLeft % 2 == 0);\\n        \\n        if(buy == true){ // buy\\n            ans2 = -prices[day] + solve(prices, day + 1, transactionsLeft - 1);\\n        }else{ // sell\\n            ans2 = prices[day] + solve(prices, day + 1, transactionsLeft - 1);\\n        }\\n        \\n        return max(ans1, ans2);\\n        \\n        \\n    }\\n    \\n    \\n    int maxProfit(vector<int>& prices) {\\n        \\n        int ans = solve(prices, 0, 4); // starting with day 0 and max 4 transactions can be done\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n\\nThe best result for the code below is ***26ms / 12.2MB*** (beats 95.42% / 82.32%).\\n* ***Python***\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        buy, sell = [inf]*2, [0]*2\\n        for x in prices:\\n            for i in range(2): \\n                if i: buy[i] = min(buy[i], x - sell[i-1])\\n                else: buy[i] = min(buy[i], x)\\n                sell[i] = max(sell[i], x - buy[i])\\n        return sell[1]\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***51ms / 34.2MB*** (beats 100.00% / 84.12%).\\n* ***JavaScript***\\n```\\nvar maxProfit = function(prices) {\\n  if(prices.length == 0) return 0\\n  \\n  let dp = new Array(prices.length).fill(0);\\n  let min = prices[0];\\n  let max = 0;\\n  for (let i = 1; i < prices.length; i++) {\\n    min = Math.min(min, prices[i]);  // or Math.min(min, prices[i] - dp[i]) , FYI: dp[i] is 0\\n    max = Math.max(max, prices[i] - min);\\n    dp[i] = max;\\n  }\\n  \\n  // 1st run dp = [0,0,2,2,2,3,3,4];\\n  \\n  min = prices[0];\\n  max = 0;\\n  for (let i = 1; i < prices.length; i++) {\\n    min = Math.min(min, prices[i] - dp[i]); // substract dp[i]  = current price - what profit we made during 1st run.\\n    max = Math.max(max, prices[i] - min);\\n    dp[i] = max;\\n  }\\n  \\n  // 2nd run dp = [0,0,2,2,2,5,5,6];\\n  \\n  return dp.pop();\\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***68ms / 44.2MB*** (beats 100.00% / 45.25%).\\n* ***C***\\n```\\nint maxProfit(int* prices, int pricesSize){\\n    int *s1 = (int *)malloc(sizeof(int) * pricesSize);\\n    int *s2 = (int *)malloc(sizeof(int) * pricesSize);\\n    \\n    memset(s1, 0, sizeof(int) * pricesSize);\\n    memset(s2, 0, sizeof(int) * pricesSize);\\n    \\n    int max = INT_MIN, min= prices[0];\\n\\n    for(int i=1; i<pricesSize-1; i++){\\n        if(min > prices[i]) min = prices[i]; \\n        \\n        if(max < (prices[i]- min)) max = prices[i] - min;\\n        s1[i] = max;\\n    }//for i\\n   \\n    min= INT_MIN, max=prices[pricesSize-1];\\n    s2[pricesSize-1] = 0;\\n\\n    for(int i=pricesSize-2; i>=0; i--){\\n        if(prices[i] > max) max = prices[i]; \\n        if(min < (max- prices[i])) min = max - prices[i];\\n    \\n        s2[i] = min;\\n    }//for i\\n    \\n    max=INT_MIN;\\n    for(int i=0;i<pricesSize;i++){\\n        max = max < (s1[i] + s2[i]) ?  (s1[i] + s2[i]) : max;\\n    }\\n\\n    return max;\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***12ms / 32.2MB*** (beats 95% / 84%).\\n* ***Swift***\\n```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of the prices.\\n    //   - space: O(1), only constant space is used.\\n\\n    func maxProfit(_ prices: [Int]) -> Int {\\n        var buy1 = Int.max\\n        var buy2 = Int.max\\n        var sell1 = 0\\n        var sell2 = 0\\n\\n        for price in prices {\\n            buy1 = min(buy1, price)\\n            sell1 = max(sell1, price - buy1)\\n\\n            buy2 = min(buy2, price - sell1)\\n            sell2 = max(sell2, price - buy2)\\n        }\\n\\n        return sell2\\n    }\\n\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n***\"Open your eyes. Expect us.\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin"
                ],
                "code": "```\\n```\n```\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if(prices == null || prices.length < 1) return 0;\\n        int buy1 = -prices[0], sell1 = 0, buy2 = -prices[0], sell2 = 0;\\n        for(int i = 1; i < prices.length; i++) {\\n            buy1 = Math.max(buy1, -prices[i]);\\n            sell1 = Math.max(sell1, buy1 + prices[i]);\\n            buy2 = Math.max(buy2, sell1 - prices[i]);\\n            sell2 = Math.max(sell2, buy2 + prices[i]);\\n        }\\n        return sell2;\\n    }\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<int>&prices, int day, int transactionsLeft){\\n        \\n        if(day == prices.size()){\\n            return 0;\\n        }\\n        \\n        if(transactionsLeft == 0){\\n            return 0;\\n        }\\n        \\n        // choice 1\\n        // no transaction today\\n        int ans1 = solve(prices, day + 1, transactionsLeft);\\n        \\n        \\n        // choice 2\\n        // doing the possible transaction today     \\n        int ans2 = 0;\\n        bool buy = (transactionsLeft % 2 == 0);\\n        \\n        if(buy == true){ // buy\\n            ans2 = -prices[day] + solve(prices, day + 1, transactionsLeft - 1);\\n        }else{ // sell\\n            ans2 = prices[day] + solve(prices, day + 1, transactionsLeft - 1);\\n        }\\n        \\n        return max(ans1, ans2);\\n        \\n        \\n    }\\n    \\n    \\n    int maxProfit(vector<int>& prices) {\\n        \\n        int ans = solve(prices, 0, 4); // starting with day 0 and max 4 transactions can be done\\n        return ans;\\n        \\n    }\\n};\\n```\n```\\n```\n```\\n```\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        buy, sell = [inf]*2, [0]*2\\n        for x in prices:\\n            for i in range(2): \\n                if i: buy[i] = min(buy[i], x - sell[i-1])\\n                else: buy[i] = min(buy[i], x)\\n                sell[i] = max(sell[i], x - buy[i])\\n        return sell[1]\\n```\n```\\n```\n```\\n```\n```\\nvar maxProfit = function(prices) {\\n  if(prices.length == 0) return 0\\n  \\n  let dp = new Array(prices.length).fill(0);\\n  let min = prices[0];\\n  let max = 0;\\n  for (let i = 1; i < prices.length; i++) {\\n    min = Math.min(min, prices[i]);  // or Math.min(min, prices[i] - dp[i]) , FYI: dp[i] is 0\\n    max = Math.max(max, prices[i] - min);\\n    dp[i] = max;\\n  }\\n  \\n  // 1st run dp = [0,0,2,2,2,3,3,4];\\n  \\n  min = prices[0];\\n  max = 0;\\n  for (let i = 1; i < prices.length; i++) {\\n    min = Math.min(min, prices[i] - dp[i]); // substract dp[i]  = current price - what profit we made during 1st run.\\n    max = Math.max(max, prices[i] - min);\\n    dp[i] = max;\\n  }\\n  \\n  // 2nd run dp = [0,0,2,2,2,5,5,6];\\n  \\n  return dp.pop();\\n};\\n```\n```\\n```\n```\\n```\n```\\nint maxProfit(int* prices, int pricesSize){\\n    int *s1 = (int *)malloc(sizeof(int) * pricesSize);\\n    int *s2 = (int *)malloc(sizeof(int) * pricesSize);\\n    \\n    memset(s1, 0, sizeof(int) * pricesSize);\\n    memset(s2, 0, sizeof(int) * pricesSize);\\n    \\n    int max = INT_MIN, min= prices[0];\\n\\n    for(int i=1; i<pricesSize-1; i++){\\n        if(min > prices[i]) min = prices[i]; \\n        \\n        if(max < (prices[i]- min)) max = prices[i] - min;\\n        s1[i] = max;\\n    }//for i\\n   \\n    min= INT_MIN, max=prices[pricesSize-1];\\n    s2[pricesSize-1] = 0;\\n\\n    for(int i=pricesSize-2; i>=0; i--){\\n        if(prices[i] > max) max = prices[i]; \\n        if(min < (max- prices[i])) min = max - prices[i];\\n    \\n        s2[i] = min;\\n    }//for i\\n    \\n    max=INT_MIN;\\n    for(int i=0;i<pricesSize;i++){\\n        max = max < (s1[i] + s2[i]) ?  (s1[i] + s2[i]) : max;\\n    }\\n\\n    return max;\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of the prices.\\n    //   - space: O(1), only constant space is used.\\n\\n    func maxProfit(_ prices: [Int]) -> Int {\\n        var buy1 = Int.max\\n        var buy2 = Int.max\\n        var sell1 = 0\\n        var sell2 = 0\\n\\n        for price in prices {\\n            buy1 = min(buy1, price)\\n            sell1 = max(sell1, price - buy1)\\n\\n            buy2 = min(buy2, price - sell1)\\n            sell2 = max(sell2, price - buy2)\\n        }\\n\\n        return sell2\\n    }\\n\\n}\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39700,
                "title": "don-t-need-dp-to-solve-it-within-o-n",
                "content": "Don't need DP to solve this problem. It is still O(n) and basically use the same algorithm solving \"Stock I\" four times. \\n\\n1. Get the max profit with one transaction to the **full array**. Keep down the start and end positions.\\n2. the start and end positions will be included in the result of two transaction. It falls into two categories:\\nA) it is one full transaction, B) they belong to two separate transactions(start belongs to first transaction and end belongs to second transaction).\\n\\n3. if A)-- get max profit with one transaction to subarray from **0 to start** ; get max profit with one transaction to subarray from **end to prices.length**.\\n\\n4. if B)-- get the max profit with one transaction within ****start and end** in **reverse order****\\n\\n5. return the max profit in those cases.",
                "solutionTags": [],
                "code": "Don't need DP to solve this problem. It is still O(n) and basically use the same algorithm solving \"Stock I\" four times. \\n\\n1. Get the max profit with one transaction to the **full array**. Keep down the start and end positions.\\n2. the start and end positions will be included in the result of two transaction. It falls into two categories:\\nA) it is one full transaction, B) they belong to two separate transactions(start belongs to first transaction and end belongs to second transaction).\\n\\n3. if A)-- get max profit with one transaction to subarray from **0 to start** ; get max profit with one transaction to subarray from **end to prices.length**.\\n\\n4. if B)-- get the max profit with one transaction within ****start and end** in **reverse order****\\n\\n5. return the max profit in those cases.",
                "codeTag": "Unknown"
            },
            {
                "id": 1524086,
                "title": "easy-to-understand-with-picture-c-greedy-solution",
                "content": "I\\'ve made some storyline, so that, we can easily consume what\\'s going on by solving in a greedy approach...essentially we are making transactions, one after another.\\n\\n![image](https://assets.leetcode.com/users/images/4e043e08-c0dc-406b-840c-a8c9f3cc5e12_1634396097.6639118.png)\\n![image](https://assets.leetcode.com/users/images/72e57f1a-d201-48aa-a105-3217435a9799_1634396117.1940877.png)\\n![image](https://assets.leetcode.com/users/images/6a820f6f-1f98-4b4c-9d0b-ea001535df98_1634416632.08219.jpeg)\\n\\nCode:\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int firstBuy = INT_MAX, secondBuy = INT_MAX, firstProfit = 0, secondProfit = 0;\\n        for(int currPrice: prices) {\\n            firstBuy = min(firstBuy, currPrice);\\n            firstProfit = max(firstProfit, currPrice - firstBuy);\\n            secondBuy = min(secondBuy, currPrice - firstProfit);\\n            secondProfit = max(secondProfit, currPrice - secondBuy);\\n        }\\n        return secondProfit;\\n    }\\n};\\n\\n```\\n\\nFor multiple transactions..\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        int buy[k+1],profit[k+1];\\n        std::fill_n(buy, k+1, INT_MAX);\\n        std::fill_n(profit, k+1, 0);\\n        \\n        for(int currPrice: prices) {\\n            for(int i=1;i<k+1;i++){\\n                buy[i] = min(buy[i], currPrice-profit[i-1]);\\n                profit[i] = max(profit[i], currPrice - buy[i]);\\n            }    \\n        }\\n        return profit[k];\\n    }\\n};\\n```\\n\\n*like it? upvote if you can..!*\\n\\n",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int firstBuy = INT_MAX, secondBuy = INT_MAX, firstProfit = 0, secondProfit = 0;\\n        for(int currPrice: prices) {\\n            firstBuy = min(firstBuy, currPrice);\\n            firstProfit = max(firstProfit, currPrice - firstBuy);\\n            secondBuy = min(secondBuy, currPrice - firstProfit);\\n            secondProfit = max(secondProfit, currPrice - secondBuy);\\n        }\\n        return secondProfit;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(int k, vector<int>& prices) {\\n        int buy[k+1],profit[k+1];\\n        std::fill_n(buy, k+1, INT_MAX);\\n        std::fill_n(profit, k+1, 0);\\n        \\n        for(int currPrice: prices) {\\n            for(int i=1;i<k+1;i++){\\n                buy[i] = min(buy[i], currPrice-profit[i-1]);\\n                profit[i] = max(profit[i], currPrice - buy[i]);\\n            }    \\n        }\\n        return profit[k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 539127,
                "title": "detailed-explanation-of-dp-solution-inspired-by-meng789987",
                "content": "See more in repo [LeetCode](https://github.com/lzl124631x/LeetCode).\\n\\nIn case this post gets outdated, you can see my latest update [here](https://github.com/lzl124631x/LeetCode/tree/master/leetcode/123.%20Best%20Time%20to%20Buy%20and%20Sell%20Stock%20III)\\n\\n## Solution 1. DP\\n\\nReference: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/discuss/135704/Detail-explanation-of-DP-solution\\n\\nLet `dp[k][i]` be the maximum profit using at most `k` transactions, on `i`-th day.\\n\\nIf we don\\'t trade on `i`-th day, `dp[k][i] = dp[k][i - 1]`\\n\\nOtherwise, there must be some `j`-th day (`j` is in range `[0, i-1]`) that we maximize our profit by buying on `j`-th day and sell on `i`-th day. So `dp[k][i] = max(dp[k-1][j-1] + prices[i] - prices[j] | 0 <= j < i)`.\\n\\nSince `prices[i]` is a constant given `i`, we can make it `dp[k][i] = prices[i] + max(dp[k-1][j-1] - prices[j] | 0 <= j < i`)\\n\\n```\\ndp[k][i] = max(\\n                dp[k][i - 1],\\n                prices[i] + max( dp[k - 1][j - 1] - prices[j] | 0 <= j < i )\\n              )\\n           where i >= 1\\n\\ndp[i][0] = dp[0][i] = 0\\n```\\n\\nSo we can use the following solution. But it will get TLE.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii\\n// Author: github.com/lzl124631x\\n// Time: O(KN^2)\\n// Space: O(KN)\\n// NOTE: this will get TLE\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& A) {\\n        if (A.empty()) return 0;\\n        int N = A.size();\\n        vector<vector<int>> dp(3, vector<int>(N + 1));\\n        for (int k = 1; k < 3; ++k) {\\n            for (int i = 1; i < N; ++i) {\\n                int maxVal = INT_MIN;\\n                for (int j = 0; j < i; ++j) maxVal = max(maxVal, dp[k - 1][j] - A[j]);\\n                dp[k][i + 1] = max(dp[k][i], A[i] + maxVal);\\n            }\\n        }\\n        return dp[2][N];\\n    }\\n};\\n```\\n\\nWe can optimize the `maxVal` part by not repetitively computing the `maxVal`.\\n\\nLet `m[k][i] = max( dp[k - 1][j - 1] - prices[j] | 0 <= j < i )`.\\n\\n```\\nm[k][i] = max(\\n               - prices[0],\\n    dp[k-1][0] - prices[1],\\n    dp[k-1][1] - prices[2],\\n    ...\\n    dp[k-1][i-2] - prices[i-1]\\n)\\n```\\n\\nWe have `m[k][i] = max(m[k][i - 1], dp[k - 1][i - 2] - prices[i - 1])` where `i >= 1`.\\n\\nSo:\\n\\n```\\ndp[k][i] = max(dp[k][i - 1], prices[i] + m[k][i])\\n\\nwhere m[k][i] = max(m[k][i - 1], dp[k - 1][i - 2] - A[i - 1])\\n    and i >= 1\\n\\ndp[i][0] = dp[0][i] = 0\\n```\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii\\n// Author: github.com/lzl124631x\\n// Time: O(KN)\\n// Space: O(KN)\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& A) {\\n        if (A.empty()) return 0;\\n        int N = A.size();\\n        vector<vector<int>> dp(3, vector<int>(N + 1));\\n        for (int k = 1; k < 3; ++k) {\\n            int maxVal = INT_MIN;\\n            for (int i = 1; i < N; ++i) {\\n                maxVal = max(maxVal, dp[k - 1][i - 1] - A[i - 1]);\\n                dp[k][i + 1] = max(dp[k][i], A[i] + maxVal);\\n            }\\n        }\\n        return dp[2][N];\\n    }\\n};\\n```\\n\\nThe following change is totally optional which just simplify the code a tiny bit.\\n\\nIn equation `dp[k][i] = prices[i] + max(dp[k-1][j-1] - prices[j] | 0 <= j < i)`, we can also make the case where `j == i`, so that it becomes:\\n\\n```\\ndp[k][i] = prices[i] + max(dp[k-1][j-1] - prices[j] | 0 <= j <= i)\\n```\\n\\nThis works because buying and selling at the same `i`-th day is effectively the same as not trading at `i`-th day.\\n\\nLet `m[k][i] = max( dp[k - 1][j - 1] - prices[j] | 0 <= j <= i )`.\\n\\nWe have `m[k][i] = max(m[k][i - 1], dp[k - 1][i - 1] - prices[i])` where `i >= 0` and `m[k][-1] == -INF`.\\n\\nSo:\\n\\n```\\ndp[k][i] = max(dp[k][i - 1], prices[i] + m[k][i])\\n\\nwhere m[k][i] = max(m[k][i - 1], dp[k - 1][i - 1] - A[i])\\n    and i >= 0\\n\\nm[k][-1] = -INF\\ndp[i][0] = dp[0][i] = 0\\n```\\n\\nFor each `k`, we can store `m[k][i]` in a single variable `maxVal` using the relationship `m[k][i] = max(m[k][i - 1], dp[k - 1][i - 1] - prices[i])`.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii\\n// Author: github.com/lzl124631x\\n// Time: O(KN)\\n// Space: O(KN)\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& A) {\\n        if (A.empty()) return 0;\\n        int N = A.size();\\n        vector<vector<int>> dp(3, vector<int>(N + 1));\\n        for (int k = 1; k < 3; ++k) {\\n            int maxVal = INT_MIN;\\n            for (int i = 0; i < N; ++i) {\\n                maxVal = max(maxVal, dp[k - 1][i] - A[i]);\\n                dp[k][i + 1] = max(dp[k][i], A[i] + maxVal);\\n            }\\n        }\\n        return dp[2][N];\\n    }\\n};\\n```\\n\\n## Solution 2. DP Space Optimization\\n\\nIn this formula \\n\\n```\\ndp[k][i] = max(dp[k][i - 1], prices[i] + m[k][i])\\n\\nwhere m[k][i] = max(m[k][i - 1], dp[k - 1][i - 1] - A[i])\\n    and i >= 0\\n\\nm[k][-1] = -INF\\ndp[i][0] = dp[0][i] = 0\\n```\\n\\n`dp[k][i]` is dependent on `dp[k][i-1]` and `dp[k-1][i-1]`.\\n\\nIf we flip `k` and `i`, we have:\\n\\n```\\ndp[i][k] = max(dp[i - 1][k], prices[i] + m[i][k])\\n\\nwhere m[i][k] = max(m[i - 1][k], dp[i - 1][k - 1] - A[i])\\n    and i >= 0\\n\\nm[-1][k] = -INF\\ndp[i][0] = dp[0][i] = 0\\n```\\n\\nBe cautious that, unlike that we can save `m[k][i]` using a single variable previously, we need to save the `m[i][k]` for each `k`.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii\\n// Author: github.com/lzl124631x\\n// Time: O(KN)\\n// Space: O(KN)\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& A) {\\n        if (A.empty()) return 0;\\n        int N = A.size();\\n        vector<vector<int>> dp(N + 1, vector<int>(3));\\n        vector<int> maxVal(3, INT_MIN);\\n        for (int i = 0; i < N; ++i) {\\n            for (int k = 1; k < 3; ++k) {\\n                maxVal[k] = max(maxVal[k], dp[i][k - 1] - A[i]);\\n                dp[i + 1][k] = max(dp[i][k], A[i] + maxVal[k]);\\n            }\\n        }\\n        return dp[N][2];\\n    }\\n};\\n```\\n\\nNow, `dp[i][k]` is dependent on `dp[i-1][k]` and `m[i][k]`. And because `m[i][k]` is dependent on `dp[i-1][k-1]`, it **seems like** `dp[i][k]` is dependent on `dp[i-1][k-1]` as well, we must loop backwards from `k` to `1`.\\n\\n```\\n// This dependency can actually be loosen considering `m[i][k]` is stored separatly\\n\\ndp[i-1][k-1]      dp[i-1][k]\\n\\n              \\\\        |\\n              \\n                  dp[i][k]\\n```\\n\\nNevertheless, we can use an array of length `2 * K` to solve it.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii\\n// Author: github.com/lzl124631x\\n// Time: O(KN)\\n// Space: O(K)\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& A) {\\n        if (A.empty()) return 0;\\n        int N = A.size();\\n        vector<vector<int>> dp(2, vector<int>(3));\\n        vector<int> maxVal(3, INT_MIN);\\n        for (int i = 0; i < N; ++i) {\\n            for (int k = 1; k < 3; ++k) {\\n                maxVal[k] = max(maxVal[k], dp[i % 2][k - 1] - A[i]);\\n                dp[(i + 1) % 2][k] = max(dp[i % 2][k], A[i] + maxVal[k]);\\n            }\\n        }\\n        return dp[N % 2][2];\\n    }\\n};\\n```\\n\\nBut because `m[i][k]` is stored separately, `dp[i][k]` is actually not dependent on `dp[i-1][k-1]`.\\n\\n```\\n\\ndp[i-1][k]\\n\\n     |\\n             \\n  dp[i][k]\\n```\\n\\nand\\n\\n```\\ndp[i-1][k-1]\\n\\n    |\\n\\n  m[i][k]\\n```\\n\\nSo `dp[i][k]` is only dependent on the `dp[i-1][k]` which is in the previous row! We don\\'t have to loop `k` from `K` to `1`, we can do it **in either direction**.\\n\\nNow we can optimize the space complexity of the DP array from `O(NK)` to `O(K)`.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii\\n// Author: github.com/lzl124631x\\n// Time: O(KN)\\n// Space: O(K)\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& A) {\\n        if (A.empty()) return 0;\\n        int N = A.size();\\n        vector<int> dp(3);\\n        vector<int> maxVal(3, INT_MIN);\\n        for (int i = 0; i < N; ++i) {\\n            for (int k = 1; k < 3; ++k) {\\n                maxVal[k] = max(maxVal[k], dp[k - 1] - A[i]);\\n                dp[k] = max(dp[k], A[i] + maxVal[k]);\\n            }\\n        }\\n        return dp[2];\\n    }\\n};\\n```\\n\\n## Solution 3. DP for K = 2\\n\\nSince in this problem `k = 2`, we can simply use 4 variables to store the `dp` and `maxVal`.\\n\\nConsider `m[i][k] = max( dp[j - 1][k - 1] - prices[j] | 0 <= j <= i )`.\\n\\n```\\nm[i][k] = max(\\n               - prices[0],\\n    dp[0][k-1] - prices[1],\\n    dp[1][k-1] - prices[2],\\n    ...\\n    dp[i-1][k-1] - prices[i]\\n)\\n```\\n\\n`dp[i-1][k-1]` is the max profit we can get with at most `k-1` transactions at `i-1`-th day. And we can regard the `-prices[i]` part as \"trying to buy at `i`-th day\" which adds `-prices[i]` to my profit.\\n\\nSo we can regard `m[i][k]` as \"the max profit if we buy at `i`-th day using at most `k` tractions\" where the last `k`-th transaction contains only buying.\\n\\nThus, we can name `m[i][k]` as `buy[i][k]` and name `dp[i][k]` as `sell[i][k]`, i.e. the max profit if we buy/sell at `i`-th day using `k` transactions.\\n\\nSince `k = 2`, we just need 4 variables.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\n// Ref: https://discuss.leetcode.com/topic/5934/is-it-best-solution-with-o-n-o-1\\nclass Solution {\\npublic:\\n  int maxProfit(vector<int>& prices) {\\n    int buy1 = INT_MIN, sell1 = 0, buy2 = INT_MIN, sell2 = 0;\\n    for (int p : prices) {\\n      buy1 = max(buy1, -p);\\n      sell1 = max(sell1, buy1 + p);\\n      buy2 = max(buy2, sell1 - p);\\n      sell2 = max(sell2, buy2 + p);\\n    }\\n    return sell2;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ndp[k][i] = max(\\n                dp[k][i - 1],\\n                prices[i] + max( dp[k - 1][j - 1] - prices[j] | 0 <= j < i )\\n              )\\n           where i >= 1\\n\\ndp[i][0] = dp[0][i] = 0\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii\\n// Author: github.com/lzl124631x\\n// Time: O(KN^2)\\n// Space: O(KN)\\n// NOTE: this will get TLE\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& A) {\\n        if (A.empty()) return 0;\\n        int N = A.size();\\n        vector<vector<int>> dp(3, vector<int>(N + 1));\\n        for (int k = 1; k < 3; ++k) {\\n            for (int i = 1; i < N; ++i) {\\n                int maxVal = INT_MIN;\\n                for (int j = 0; j < i; ++j) maxVal = max(maxVal, dp[k - 1][j] - A[j]);\\n                dp[k][i + 1] = max(dp[k][i], A[i] + maxVal);\\n            }\\n        }\\n        return dp[2][N];\\n    }\\n};\\n```\n```\\nm[k][i] = max(\\n               - prices[0],\\n    dp[k-1][0] - prices[1],\\n    dp[k-1][1] - prices[2],\\n    ...\\n    dp[k-1][i-2] - prices[i-1]\\n)\\n```\n```\\ndp[k][i] = max(dp[k][i - 1], prices[i] + m[k][i])\\n\\nwhere m[k][i] = max(m[k][i - 1], dp[k - 1][i - 2] - A[i - 1])\\n    and i >= 1\\n\\ndp[i][0] = dp[0][i] = 0\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii\\n// Author: github.com/lzl124631x\\n// Time: O(KN)\\n// Space: O(KN)\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& A) {\\n        if (A.empty()) return 0;\\n        int N = A.size();\\n        vector<vector<int>> dp(3, vector<int>(N + 1));\\n        for (int k = 1; k < 3; ++k) {\\n            int maxVal = INT_MIN;\\n            for (int i = 1; i < N; ++i) {\\n                maxVal = max(maxVal, dp[k - 1][i - 1] - A[i - 1]);\\n                dp[k][i + 1] = max(dp[k][i], A[i] + maxVal);\\n            }\\n        }\\n        return dp[2][N];\\n    }\\n};\\n```\n```\\ndp[k][i] = prices[i] + max(dp[k-1][j-1] - prices[j] | 0 <= j <= i)\\n```\n```\\ndp[k][i] = max(dp[k][i - 1], prices[i] + m[k][i])\\n\\nwhere m[k][i] = max(m[k][i - 1], dp[k - 1][i - 1] - A[i])\\n    and i >= 0\\n\\nm[k][-1] = -INF\\ndp[i][0] = dp[0][i] = 0\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii\\n// Author: github.com/lzl124631x\\n// Time: O(KN)\\n// Space: O(KN)\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& A) {\\n        if (A.empty()) return 0;\\n        int N = A.size();\\n        vector<vector<int>> dp(3, vector<int>(N + 1));\\n        for (int k = 1; k < 3; ++k) {\\n            int maxVal = INT_MIN;\\n            for (int i = 0; i < N; ++i) {\\n                maxVal = max(maxVal, dp[k - 1][i] - A[i]);\\n                dp[k][i + 1] = max(dp[k][i], A[i] + maxVal);\\n            }\\n        }\\n        return dp[2][N];\\n    }\\n};\\n```\n```\\ndp[k][i] = max(dp[k][i - 1], prices[i] + m[k][i])\\n\\nwhere m[k][i] = max(m[k][i - 1], dp[k - 1][i - 1] - A[i])\\n    and i >= 0\\n\\nm[k][-1] = -INF\\ndp[i][0] = dp[0][i] = 0\\n```\n```\\ndp[i][k] = max(dp[i - 1][k], prices[i] + m[i][k])\\n\\nwhere m[i][k] = max(m[i - 1][k], dp[i - 1][k - 1] - A[i])\\n    and i >= 0\\n\\nm[-1][k] = -INF\\ndp[i][0] = dp[0][i] = 0\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii\\n// Author: github.com/lzl124631x\\n// Time: O(KN)\\n// Space: O(KN)\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& A) {\\n        if (A.empty()) return 0;\\n        int N = A.size();\\n        vector<vector<int>> dp(N + 1, vector<int>(3));\\n        vector<int> maxVal(3, INT_MIN);\\n        for (int i = 0; i < N; ++i) {\\n            for (int k = 1; k < 3; ++k) {\\n                maxVal[k] = max(maxVal[k], dp[i][k - 1] - A[i]);\\n                dp[i + 1][k] = max(dp[i][k], A[i] + maxVal[k]);\\n            }\\n        }\\n        return dp[N][2];\\n    }\\n};\\n```\n```\\n// This dependency can actually be loosen considering `m[i][k]` is stored separatly\\n\\ndp[i-1][k-1]      dp[i-1][k]\\n\\n              \\\\        |\\n              \\n                  dp[i][k]\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii\\n// Author: github.com/lzl124631x\\n// Time: O(KN)\\n// Space: O(K)\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& A) {\\n        if (A.empty()) return 0;\\n        int N = A.size();\\n        vector<vector<int>> dp(2, vector<int>(3));\\n        vector<int> maxVal(3, INT_MIN);\\n        for (int i = 0; i < N; ++i) {\\n            for (int k = 1; k < 3; ++k) {\\n                maxVal[k] = max(maxVal[k], dp[i % 2][k - 1] - A[i]);\\n                dp[(i + 1) % 2][k] = max(dp[i % 2][k], A[i] + maxVal[k]);\\n            }\\n        }\\n        return dp[N % 2][2];\\n    }\\n};\\n```\n```\\n\\ndp[i-1][k]\\n\\n     |\\n             \\n  dp[i][k]\\n```\n```\\ndp[i-1][k-1]\\n\\n    |\\n\\n  m[i][k]\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii\\n// Author: github.com/lzl124631x\\n// Time: O(KN)\\n// Space: O(K)\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& A) {\\n        if (A.empty()) return 0;\\n        int N = A.size();\\n        vector<int> dp(3);\\n        vector<int> maxVal(3, INT_MIN);\\n        for (int i = 0; i < N; ++i) {\\n            for (int k = 1; k < 3; ++k) {\\n                maxVal[k] = max(maxVal[k], dp[k - 1] - A[i]);\\n                dp[k] = max(dp[k], A[i] + maxVal[k]);\\n            }\\n        }\\n        return dp[2];\\n    }\\n};\\n```\n```\\nm[i][k] = max(\\n               - prices[0],\\n    dp[0][k-1] - prices[1],\\n    dp[1][k-1] - prices[2],\\n    ...\\n    dp[i-1][k-1] - prices[i]\\n)\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\n// Ref: https://discuss.leetcode.com/topic/5934/is-it-best-solution-with-o-n-o-1\\nclass Solution {\\npublic:\\n  int maxProfit(vector<int>& prices) {\\n    int buy1 = INT_MIN, sell1 = 0, buy2 = INT_MIN, sell2 = 0;\\n    for (int p : prices) {\\n      buy1 = max(buy1, -p);\\n      sell1 = max(sell1, buy1 + p);\\n      buy2 = max(buy2, sell1 - p);\\n      sell2 = max(sell2, buy2 + p);\\n    }\\n    return sell2;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39691,
                "title": "simple-dp-8ms-solution-for-best-time-to-buy-and-sell-stock-iii",
                "content": " \\n        int maxProfit(vector<int>& prices) {\\n        int size = prices.size();\\n        if(size==0 || size ==1) return 0;\\n        int profit[size];\\n        int profit1[size];\\n        int local_min=prices[0];\\n        int local_max = prices[size-1];\\n        int j = size-2;\\n        int result=0;\\n        profit[0]=0;\\n        profit1[size-1] = 0;\\n        for(int i = 1;i<size+1 && j >=0;i++,j--)\\n        {\\n            profit[i] = max(profit[i-1],prices[i]-local_min);\\n            local_min= min(local_min,prices[i]);\\n            profit1[j] = max(profit1[j+1],local_max-prices[j]);\\n            local_max = max(local_max,prices[j]);\\n        }\\n        for(int i = 1; i<size; i++)\\n        {\\n            result = max(result,profit[i]+profit1[i]);\\n        }\\n        return result;\\n    }\\n};",
                "solutionTags": [],
                "code": " \\n        int maxProfit(vector<int>& prices) {\\n        int size = prices.size();\\n        if(size==0 || size ==1) return 0;\\n        int profit[size];\\n        int profit1[size];\\n        int local_min=prices[0];\\n        int local_max = prices[size-1];\\n        int j = size-2;\\n        int result=0;\\n        profit[0]=0;\\n        profit1[size-1] = 0;\\n        for(int i = 1;i<size+1 && j >=0;i++,j--)\\n        {\\n            profit[i] = max(profit[i-1],prices[i]-local_min);\\n            local_min= min(local_min,prices[i]);\\n            profit1[j] = max(profit1[j+1],local_max-prices[j]);\\n            local_max = max(local_max,prices[j]);\\n        }\\n        for(int i = 1; i<size; i++)\\n        {\\n            result = max(result,profit[i]+profit1[i]);\\n        }\\n        return result;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3529289,
                "title": "c-3d-dp-recursion-memoization-tabulation-space-optimization",
                "content": "\\u27A1\\uFE0F Recursion\\n\\n```\\nint solve(int index,int buy,int limits,vector<int>&prices){\\n         if(index==prices.size()) return 0;\\n         if(limits==0) return 0;\\n         int profit=0;\\n         if(buy){\\n             int sellkaro=(-prices[index])+solve(index+1,0,limits,prices);\\n             int skipkaro=0+solve(index+1,1,limits,prices);\\n             profit=max(sellkaro,skipkaro);\\n         }else{\\n             int buykaro=(prices[index])+solve(index+1,1,limits-1,prices);\\n             int skipkaro=0+solve(index+1,0,limits,prices);\\n             profit=max(buykaro,skipkaro);\\n         }\\n         return profit;\\n    }\\n\\tint maxProfit(vector<int>& prices) {\\n        return solve(0,1,2,prices);\\n    }\\n```\\n\\u27A1\\uFE0F Memoization\\n\\n```\\nint solveMem(int index,int buy,int limits,vector<int>&prices,vector<vector<vector<int>>>&dp){\\n         if(index==prices.size()) return 0;\\n         if(limits==0) return 0;\\n         if(dp[index][buy][limits]!=-1) return dp[index][buy][limits];\\n         int profit=0;\\n         if(buy){\\n             int sellkaro=(-prices[index])+solveMem(index+1,0,limits,prices,dp);\\n             int skipkaro=0+solveMem(index+1,1,limits,prices,dp);\\n             profit=max(sellkaro,skipkaro);\\n         }else{\\n             int buykaro=(prices[index])+solveMem(index+1,1,limits-1,prices,dp);\\n             int skipkaro=0+solveMem(index+1,0,limits,prices,dp);\\n             profit=max(buykaro,skipkaro);\\n         }\\n         return dp[index][buy][limits]=profit;\\n    }\\n\\tint maxProfit(vector<int>& prices) {\\n        int n=prices.size();\\n        vector<vector<vector<int>>>dp(n,vector<vector<int>>(2,vector<int>(3,-1)));\\n        return solveMem(0,1,2,prices,dp);\\n    }\\n```\\n\\u27A1\\uFE0F Tabulation\\n\\n```\\nint solveTab(vector<int>& prices){\\n        int n=prices.size();\\n        vector<vector<vector<int>>>dp(n+1,vector<vector<int>>(2,vector<int>(3,0)));\\n        for(int index=n-1;index>=0;index--){\\n            for(int buy=0;buy<=1;buy++){\\n                for(int limits=1;limits<=2;limits++){\\n                  int profit=0;\\n                  if(buy){\\n                     int sellkaro=(-prices[index])+dp[index+1][0][limits];\\n                     int skipkaro=0+dp[index+1][1][limits];\\n                     profit=max(sellkaro,skipkaro);\\n                  }else{\\n                     int buykaro=(prices[index])+dp[index+1][1][limits-1];\\n                     int skipkaro=0+dp[index+1][0][limits];\\n                     profit=max(buykaro,skipkaro);\\n                  }\\n                 dp[index][buy][limits]=profit;\\n                }\\n            }\\n        }\\n        return dp[0][1][2];\\n    }\\n\\tint maxProfit(vector<int>& prices) {\\n        return solveTab(prices);\\n    }\\n```\\n\\u27A1\\uFE0F Space Optimization\\n\\n```\\nint solveOpt(vector<int>& prices){\\n        int n=prices.size();\\n        //vector<vector<vector<int>>>dp(n+1,vector<vector<int>>(2,vector<int>(3,0)));\\n        vector<vector<int>>curr(2,vector<int>(3,0));\\n        vector<vector<int>>next(2,vector<int>(3,0));\\n        for(int index=n-1;index>=0;index--){\\n            for(int buy=0;buy<=1;buy++){\\n                for(int limits=1;limits<=2;limits++){\\n                  int profit=0;\\n                  if(buy){\\n                     int sellkaro=(-prices[index])+next[0][limits];\\n                     int skipkaro=0+next[1][limits];\\n                     profit=max(sellkaro,skipkaro);\\n                  }else{\\n                     int buykaro=(prices[index])+next[1][limits-1];\\n                     int skipkaro=0+next[0][limits];\\n                     profit=max(buykaro,skipkaro);\\n                  }\\n                 curr[buy][limits]=profit;\\n                }\\n            }\\n            next=curr;\\n        }\\n        return next[1][2];\\n    }\\n\\tint maxProfit(vector<int>& prices) {\\n        return solveOpt(prices);\\n    }\\n```\\n**Don\\'t forget to upvote this post if it has helped you!!!**",
                "solutionTags": [],
                "code": "```\\nint solve(int index,int buy,int limits,vector<int>&prices){\\n         if(index==prices.size()) return 0;\\n         if(limits==0) return 0;\\n         int profit=0;\\n         if(buy){\\n             int sellkaro=(-prices[index])+solve(index+1,0,limits,prices);\\n             int skipkaro=0+solve(index+1,1,limits,prices);\\n             profit=max(sellkaro,skipkaro);\\n         }else{\\n             int buykaro=(prices[index])+solve(index+1,1,limits-1,prices);\\n             int skipkaro=0+solve(index+1,0,limits,prices);\\n             profit=max(buykaro,skipkaro);\\n         }\\n         return profit;\\n    }\\n\\tint maxProfit(vector<int>& prices) {\\n        return solve(0,1,2,prices);\\n    }\\n```\n```\\nint solveMem(int index,int buy,int limits,vector<int>&prices,vector<vector<vector<int>>>&dp){\\n         if(index==prices.size()) return 0;\\n         if(limits==0) return 0;\\n         if(dp[index][buy][limits]!=-1) return dp[index][buy][limits];\\n         int profit=0;\\n         if(buy){\\n             int sellkaro=(-prices[index])+solveMem(index+1,0,limits,prices,dp);\\n             int skipkaro=0+solveMem(index+1,1,limits,prices,dp);\\n             profit=max(sellkaro,skipkaro);\\n         }else{\\n             int buykaro=(prices[index])+solveMem(index+1,1,limits-1,prices,dp);\\n             int skipkaro=0+solveMem(index+1,0,limits,prices,dp);\\n             profit=max(buykaro,skipkaro);\\n         }\\n         return dp[index][buy][limits]=profit;\\n    }\\n\\tint maxProfit(vector<int>& prices) {\\n        int n=prices.size();\\n        vector<vector<vector<int>>>dp(n,vector<vector<int>>(2,vector<int>(3,-1)));\\n        return solveMem(0,1,2,prices,dp);\\n    }\\n```\n```\\nint solveTab(vector<int>& prices){\\n        int n=prices.size();\\n        vector<vector<vector<int>>>dp(n+1,vector<vector<int>>(2,vector<int>(3,0)));\\n        for(int index=n-1;index>=0;index--){\\n            for(int buy=0;buy<=1;buy++){\\n                for(int limits=1;limits<=2;limits++){\\n                  int profit=0;\\n                  if(buy){\\n                     int sellkaro=(-prices[index])+dp[index+1][0][limits];\\n                     int skipkaro=0+dp[index+1][1][limits];\\n                     profit=max(sellkaro,skipkaro);\\n                  }else{\\n                     int buykaro=(prices[index])+dp[index+1][1][limits-1];\\n                     int skipkaro=0+dp[index+1][0][limits];\\n                     profit=max(buykaro,skipkaro);\\n                  }\\n                 dp[index][buy][limits]=profit;\\n                }\\n            }\\n        }\\n        return dp[0][1][2];\\n    }\\n\\tint maxProfit(vector<int>& prices) {\\n        return solveTab(prices);\\n    }\\n```\n```\\nint solveOpt(vector<int>& prices){\\n        int n=prices.size();\\n        //vector<vector<vector<int>>>dp(n+1,vector<vector<int>>(2,vector<int>(3,0)));\\n        vector<vector<int>>curr(2,vector<int>(3,0));\\n        vector<vector<int>>next(2,vector<int>(3,0));\\n        for(int index=n-1;index>=0;index--){\\n            for(int buy=0;buy<=1;buy++){\\n                for(int limits=1;limits<=2;limits++){\\n                  int profit=0;\\n                  if(buy){\\n                     int sellkaro=(-prices[index])+next[0][limits];\\n                     int skipkaro=0+next[1][limits];\\n                     profit=max(sellkaro,skipkaro);\\n                  }else{\\n                     int buykaro=(prices[index])+next[1][limits-1];\\n                     int skipkaro=0+next[0][limits];\\n                     profit=max(buykaro,skipkaro);\\n                  }\\n                 curr[buy][limits]=profit;\\n                }\\n            }\\n            next=curr;\\n        }\\n        return next[1][2];\\n    }\\n\\tint maxProfit(vector<int>& prices) {\\n        return solveOpt(prices);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 39630,
                "title": "easy-to-understand-dp-solution",
                "content": "This problem seems not easy to implement quickly. \\n\\nWhere is the difficulty of the problem?  \\n\\n          forward[i] : record the max-profit of [0,i] , end at most at pos i\\n          \\n          backward[i] : record the max-profit of [i,len], start at most at pos i\\n          \\nCode:\\n\\n    class Solution {\\n    public:\\n        int maxProfit(vector<int>& prices) {\\n            if(prices.size()<=1)  return 0;\\n            int len=prices.size();\\n            \\n            /** forward[i] : record the max-profit of [0,i] **/\\n            vector<int> forward(len);\\n            forward[0]=0;\\n            int min_buy=prices[0];\\n            for(int i=1; i<len; i++){\\n                forward[i]=max(forward[i-1], prices[i]-min_buy);\\n                min_buy=min(min_buy, prices[i]);\\n            }\\n            \\n            /** backward[i] : record the max-profit of [i,len]**/\\n            vector<int> backward(len);\\n            backward[len-1]=0;\\n            int max_sell=prices[len-1];\\n            for(int i=len-2; i>=0; i--){\\n                backward[i]=max(backward[i+1], max_sell-prices[i]);\\n                max_sell=max(max_sell, prices[i]);\\n            }\\n            \\n            /** when i=0, we get the max-profit of doing one transaction */\\n            int result=0;\\n            for(int i=0; i<len; i++){\\n                result=max(result, forward[i]+backward[i]);\\n            }\\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maxProfit(vector<int>& prices) {\\n            if(prices.size()<=1)  return 0;\\n            int len=prices.size();\\n            \\n            /** forward[i] : record the max-profit of [0,i] **/\\n            vector<int> forward(len);\\n            forward[0]=0;\\n            int min_buy=prices[0];\\n            for(int i=1; i<len; i++){\\n                forward[i]=max(forward[i-1], prices[i]-min_buy);\\n                min_buy=min(min_buy, prices[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3057692,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int buy1=INT_MAX, buy2=INT_MAX, sell1=INT_MIN, sell2=INT_MIN;\\n        for(int i=0;i<prices.size();i++)\\n        {\\n            buy1 = min(buy1, prices[i]);\\n            sell1 = max(sell1, prices[i]-buy1);\\n            buy2 = min(buy2, prices[i]-sell1);\\n            sell2=max(sell2, prices[i]-buy2);\\n        }\\n        return sell2;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int buy1=INT_MAX, buy2=INT_MAX, sell1=INT_MIN, sell2=INT_MIN;\\n        for(int i=0;i<prices.size();i++)\\n        {\\n            buy1 = min(buy1, prices[i]);\\n            sell1 = max(sell1, prices[i]-buy1);\\n            buy2 = min(buy2, prices[i]-sell1);\\n            sell2=max(sell2, prices[i]-buy2);\\n        }\\n        return sell2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1167127,
                "title": "c-solution-to-all-the-stock-problems-using-dynamic-programming",
                "content": "## Related Questions\\n\\n1. [Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)\\n2. [Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/)\\n3. [Best Time to Buy and Sell Stock with Transaction Fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)\\n4. [Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)\\n5. [Best Time to Buy and Sell Stock III](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/)\\n6. [Best Time to Buy and Sell Stock IV](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/)\\n\\n#### Best Time to Buy and Sell Stock\\nO(N) Time, O(N) Space ( Can be made O(1) Space by tracking only the previous buy sell values )\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int buy[prices.size()], sell[prices.size()];\\n        memset(buy,0,sizeof(buy));\\n        memset(sell,0,sizeof(sell));\\n        buy[0] = -prices[0];\\n        for(int i=1; i<prices.size(); i++) {\\n            buy[i] = max(buy[i-1],-prices[i]);\\n            sell[i] = max(sell[i-1],prices[i] + buy[i-1]);\\n        }\\n        return max(buy[prices.size()-1],sell[prices.size()-1]);\\n    }\\n};\\n```\\n\\n#### Best Time to Buy and Sell Stock II\\nO(N) Time, O(N) Space ( Can be made O(1) Space by tracking only the previous buy sell values )\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int sell[prices.size()];\\n        int buy[prices.size()];\\n        memset(sell,0,sizeof(sell));\\n        memset(buy,0,sizeof(buy));\\n        buy[0] = -prices[0];\\n        for(int i=1; i<prices.size();i++) {\\n            buy[i] = max(buy[i-1], sell[i-1] - prices[i]);\\n            sell[i] = max(sell[i-1],prices[i] + buy[i-1]);\\n        }\\n        return max(buy[prices.size()-1],sell[prices.size()-1]);\\n    }\\n};\\n```\\n\\n#### Best Time to Buy and Sell Stock with Transaction Fee\\nO(N) Time, O(N) Space ( Can be made O(1) Space by tracking only the previous buy sell values )\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int sell[prices.size()];\\n        int buy[prices.size()];\\n        memset(sell,0,sizeof(sell));\\n        memset(buy,0,sizeof(buy));\\n        buy[0] = -prices[0];\\n        for(int i=1; i<prices.size();i++) {\\n            buy[i] = max(buy[i-1], sell[i-1] - prices[i]);\\n            sell[i] = max(sell[i-1],prices[i] + buy[i-1] - fee);\\n        }\\n        return max(buy[prices.size()-1],sell[prices.size()-1]);\\n    }\\n};\\n```\\n\\n#### Best Time to Buy and Sell Stock with Cooldown ( Generalised for k cooldown period )\\nO(N) Time, O(N) Space\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int cooldown = 1) {\\n        int buy[prices.size()];\\n        int sell[prices.size()];\\n        memset(buy, 0, sizeof(buy));\\n        memset(sell, 0, sizeof(sell));\\n        buy[0] = -prices[0];\\n        for(int i=1; i<prices.size(); i++) {\\n            buy[i] = max(buy[i-1], (i-cooldown-1 >= 0 ? sell[i-cooldown-1] : 0) - prices[i]);\\n            sell[i] = max(sell[i-1],prices[i] + buy[i-1]);\\n        }\\n        return max(sell[prices.size()-1], buy[prices.size()-1]);\\n    }\\n};\\n```\\n\\n#### Best Time to Buy and Sell Stock III ( Generalised for atmost k transactions )\\nO(Nk) Time, O(Nk) Space ( Can be made O(k) Space by tracking only the previous buy sell values )\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int transactions = 2) {\\n        if(transactions == 0) return 0;\\n        int buy[transactions][prices.size()];\\n        int sell[transactions][prices.size()];\\n        memset(buy,0,sizeof(buy));\\n        memset(sell,0,sizeof(sell));\\n        for(int i=0; i<transactions;i++) buy[i][0] = -prices[0];\\n        for(int i=1; i<prices.size(); i++) {\\n            int prevInvestment = 0;\\n            for(int j=0; j<transactions; j++) {\\n                buy[j][i] = max(buy[j][i-1], -prices[i] + prevInvestment);\\n                sell[j][i] = max(sell[j][i-1], buy[j][i-1] + prices[i]);\\n                prevInvestment = sell[j][i];\\n            }\\n        }\\n        int ret = 0;\\n        for(int i=0; i<transactions; i++) {\\n            ret = max(ret,sell[i][prices.size()-1]);\\n        }\\n        return ret;\\n    }\\n};\\n```\\n\\n#### Best Time to Buy and Sell Stock IV\\nO(Nk) Time, O(Nk) Space ( Can be made O(k) Space by tracking only the previous buy sell values )\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(int transactions, vector<int>& prices) {\\n        if(transactions == 0 || prices.size() <= 1) return 0;\\n        int buy[transactions][prices.size()];\\n        int sell[transactions][prices.size()];\\n        memset(buy,0,sizeof(buy));\\n        memset(sell,0,sizeof(sell));\\n        for(int i=0; i<transactions;i++) buy[i][0] = -prices[0];\\n        for(int i=1; i<prices.size(); i++) {\\n            int prevInvestment = 0;\\n            for(int j=0; j<transactions; j++) {\\n                buy[j][i] = max(buy[j][i-1], -prices[i] + prevInvestment);\\n                sell[j][i] = max(sell[j][i-1], buy[j][i-1] + prices[i]);\\n                prevInvestment = sell[j][i];\\n            }\\n        }\\n        int ret = 0;\\n        for(int i=0; i<transactions; i++) {\\n            ret = max(ret,sell[i][prices.size()-1]);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int buy[prices.size()], sell[prices.size()];\\n        memset(buy,0,sizeof(buy));\\n        memset(sell,0,sizeof(sell));\\n        buy[0] = -prices[0];\\n        for(int i=1; i<prices.size(); i++) {\\n            buy[i] = max(buy[i-1],-prices[i]);\\n            sell[i] = max(sell[i-1],prices[i] + buy[i-1]);\\n        }\\n        return max(buy[prices.size()-1],sell[prices.size()-1]);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int sell[prices.size()];\\n        int buy[prices.size()];\\n        memset(sell,0,sizeof(sell));\\n        memset(buy,0,sizeof(buy));\\n        buy[0] = -prices[0];\\n        for(int i=1; i<prices.size();i++) {\\n            buy[i] = max(buy[i-1], sell[i-1] - prices[i]);\\n            sell[i] = max(sell[i-1],prices[i] + buy[i-1]);\\n        }\\n        return max(buy[prices.size()-1],sell[prices.size()-1]);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int fee) {\\n        int sell[prices.size()];\\n        int buy[prices.size()];\\n        memset(sell,0,sizeof(sell));\\n        memset(buy,0,sizeof(buy));\\n        buy[0] = -prices[0];\\n        for(int i=1; i<prices.size();i++) {\\n            buy[i] = max(buy[i-1], sell[i-1] - prices[i]);\\n            sell[i] = max(sell[i-1],prices[i] + buy[i-1] - fee);\\n        }\\n        return max(buy[prices.size()-1],sell[prices.size()-1]);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int cooldown = 1) {\\n        int buy[prices.size()];\\n        int sell[prices.size()];\\n        memset(buy, 0, sizeof(buy));\\n        memset(sell, 0, sizeof(sell));\\n        buy[0] = -prices[0];\\n        for(int i=1; i<prices.size(); i++) {\\n            buy[i] = max(buy[i-1], (i-cooldown-1 >= 0 ? sell[i-cooldown-1] : 0) - prices[i]);\\n            sell[i] = max(sell[i-1],prices[i] + buy[i-1]);\\n        }\\n        return max(sell[prices.size()-1], buy[prices.size()-1]);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices, int transactions = 2) {\\n        if(transactions == 0) return 0;\\n        int buy[transactions][prices.size()];\\n        int sell[transactions][prices.size()];\\n        memset(buy,0,sizeof(buy));\\n        memset(sell,0,sizeof(sell));\\n        for(int i=0; i<transactions;i++) buy[i][0] = -prices[0];\\n        for(int i=1; i<prices.size(); i++) {\\n            int prevInvestment = 0;\\n            for(int j=0; j<transactions; j++) {\\n                buy[j][i] = max(buy[j][i-1], -prices[i] + prevInvestment);\\n                sell[j][i] = max(sell[j][i-1], buy[j][i-1] + prices[i]);\\n                prevInvestment = sell[j][i];\\n            }\\n        }\\n        int ret = 0;\\n        for(int i=0; i<transactions; i++) {\\n            ret = max(ret,sell[i][prices.size()-1]);\\n        }\\n        return ret;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(int transactions, vector<int>& prices) {\\n        if(transactions == 0 || prices.size() <= 1) return 0;\\n        int buy[transactions][prices.size()];\\n        int sell[transactions][prices.size()];\\n        memset(buy,0,sizeof(buy));\\n        memset(sell,0,sizeof(sell));\\n        for(int i=0; i<transactions;i++) buy[i][0] = -prices[0];\\n        for(int i=1; i<prices.size(); i++) {\\n            int prevInvestment = 0;\\n            for(int j=0; j<transactions; j++) {\\n                buy[j][i] = max(buy[j][i-1], -prices[i] + prevInvestment);\\n                sell[j][i] = max(sell[j][i-1], buy[j][i-1] + prices[i]);\\n                prevInvestment = sell[j][i];\\n            }\\n        }\\n        int ret = 0;\\n        for(int i=0; i<transactions; i++) {\\n            ret = max(ret,sell[i][prices.size()-1]);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39711,
                "title": "another-accepted-java-solution-scan-from-left-and-right",
                "content": "    public class Solution {\\n        public int maxProfit(int[] prices) {\\n            if (prices == null || prices.length == 0) \\n                return 0;\\n            \\n            int n = prices.length;\\n            int profit = 0;\\n            \\n            // scan from left\\n            // left[i] keeps the max profit from 0 to i\\n            int[] left = new int[n];\\n            int min = prices[0];\\n            \\n            for (int i = 1; i < n; i++) {\\n                left[i] = Math.max(left[i - 1], prices[i] - min);\\n                min = Math.min(min, prices[i]);\\n            }\\n            \\n            // scan from right\\n            // right[i] keeps the max profit from i to n - 1\\n            int[] right = new int[n];\\n            int max = prices[n - 1];\\n            \\n            for (int i = n - 2; i >= 0; i--) {\\n                right[i] = Math.max(right[i + 1], max - prices[i]);\\n                max = Math.max(max, prices[i]);\\n                \\n                profit = Math.max(profit, left[i] + right[i]);\\n            }\\n            \\n            return profit;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int maxProfit(int[] prices) {\\n            if (prices == null || prices.length == 0) \\n                return 0;\\n            \\n            int n = prices.length;\\n            int profit = 0;\\n            \\n            // scan from left\\n            // left[i] keeps the max profit from 0 to i\\n            int[] left = new int[n];\\n            int min = prices[0];\\n            \\n            for (int i = 1; i < n; i++) {\\n                left[i] = Math.max(left[i - 1], prices[i] - min);\\n                min = Math.min(min, prices[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1611448,
                "title": "python-top-down-dp-with-memoization",
                "content": "```python\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        @lru_cache(maxsize=None)\\n        def dp(i, t, bought):\\n            if i >= len(prices) or t == 0:\\n                return 0\\n            \\n            # Skip\\n            profit = dp(i + 1, t, bought);\\n\\n            # Sell\\n            if bought:\\n                profit = max(profit, dp(i + 1, t - 1, not bought) + prices[i])\\n            # Buy\\n            else:\\n                profit = max(profit, dp(i + 1, t, not bought) - prices[i])\\n\\n            return profit\\n        \\n        return dp(0, 2, False)\\n        \\n\\'\\'\\'\\nApproach: top-down recursive with memoization. On each day, we have three options: buy, sell, or skip (do nothing). In practice,\\nthe recursion tree for this program will only have two branches because we can represent the choice to skip by not decrementing the number of transactions we can still make.\\nT: O(n), S: O(n)\\n\\'\\'\\'\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```python\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        @lru_cache(maxsize=None)\\n        def dp(i, t, bought):\\n            if i >= len(prices) or t == 0:\\n                return 0\\n            \\n            # Skip\\n            profit = dp(i + 1, t, bought);\\n\\n            # Sell\\n            if bought:\\n                profit = max(profit, dp(i + 1, t - 1, not bought) + prices[i])\\n            # Buy\\n            else:\\n                profit = max(profit, dp(i + 1, t, not bought) - prices[i])\\n\\n            return profit\\n        \\n        return dp(0, 2, False)\\n        \\n\\'\\'\\'\\nApproach: top-down recursive with memoization. On each day, we have three options: buy, sell, or skip (do nothing). In practice,\\nthe recursion tree for this program will only have two branches because we can represent the choice to skip by not decrementing the number of transactions we can still make.\\nT: O(n), S: O(n)\\n\\'\\'\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 734258,
                "title": "recursive-dp-with-explanation-easy-to-understand-not-optimal",
                "content": "The intuition is - at each position in the price array we can either buy the stock (if we aren\\'t holding any), or we can sell it (if we are), or we can skip the current position.\\nMoreover, we are constrained to only 2 transactions in total.\\n\\nOne transaction consists of 1 act of buying a stock, and 1 act of selling the stock. So in total we are constrained by 4 actions.\\nWe can model that by introducing the variable `n`, which stands for the number of actions left - it\\'s initially set to 4, and each time we buy or sell we decrement it. Once `n == 0`, even if we haven\\'t reached the end of the price array, we know that there is no more profit to be made and can return immediately - this is one of the base cases of the recursive function.\\n\\nThe other base case for recursion is reaching the end of the `prices` array - pretty straightforward.\\n```\\ndef max_profit(prices, i, n, can_sell, mem):\\n    if i >= len(prices) or n == 0: \\n        # We have reached the end of the prices array, or can\\'t perform any more transactions\\n        # Our profit from this point on is 0 in this case\\n        return 0\\n    elif (i, n, can_sell) in mem:\\n        # This state was previously encountered - return the memorized value\\n        return mem[(i, n, can_sell)]\\n    \\n    # Buy the stock if we aren\\'t holding any, or sell it otherwise\\n    do = max_profit(prices, i+1, n-1, not can_sell, mem) + (prices[i] if can_sell else -prices[i])\\n    # Skip the position without buying/selling\\n    skip = max_profit(prices, i+1, n, can_sell, mem)\\n    \\n    mem[(i, n, can_sell)] = max(do, skip)\\n    return mem[(i, n, can_sell)]\\n\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        return max_profit(prices, 0, 4, False, {})\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\ndef max_profit(prices, i, n, can_sell, mem):\\n    if i >= len(prices) or n == 0: \\n        # We have reached the end of the prices array, or can\\'t perform any more transactions\\n        # Our profit from this point on is 0 in this case\\n        return 0\\n    elif (i, n, can_sell) in mem:\\n        # This state was previously encountered - return the memorized value\\n        return mem[(i, n, can_sell)]\\n    \\n    # Buy the stock if we aren\\'t holding any, or sell it otherwise\\n    do = max_profit(prices, i+1, n-1, not can_sell, mem) + (prices[i] if can_sell else -prices[i])\\n    # Skip the position without buying/selling\\n    skip = max_profit(prices, i+1, n, can_sell, mem)\\n    \\n    mem[(i, n, can_sell)] = max(do, skip)\\n    return mem[(i, n, can_sell)]\\n\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        return max_profit(prices, 0, 4, False, {})\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39712,
                "title": "java-solution-one-iteration-o-n-time-constant-space-with-explanation",
                "content": "    public int maxProfit(int[] prices) {\\n        int len = prices.length;\\n        if(len <= 1) return 0;\\n        int a, b, c, d;\\n        d = Math.max(prices[len-1], prices[len-2]);\\n        c = Math.max(prices[len-1] - prices[len-2], 0);\\n        b = d;\\n        a = c;\\n        for(int i=len-3; i>=0; i--) {\\n            a = Math.max(b - prices[i], a);\\n            b = Math.max(prices[i] + c, b);\\n            c = Math.max(d - prices[i], c);\\n            d = Math.max(prices[i], d);\\n        }\\n        return a;\\n    }\\n\\nd is the value in the case when you have made a transaction before and you have a share at hand, that's basically the max from i to len.\\n\\nc is the value in the case when you can make one transaction from days i to len. So c is updated only if you buy a share on that day and sell afterward.\\n\\nb is the value in the case when you have a share at hand, and you can make one more transaction. So if you sell it on day i, it's prices[i] + c, otherwise it doesn't change.\\n\\na is the value in the case when you can make two transactions.",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "    public int maxProfit(int[] prices) {\\n        int len = prices.length;\\n        if(len <= 1) return 0;\\n        int a, b, c, d;\\n        d = Math.max(prices[len-1], prices[len-2]);\\n        c = Math.max(prices[len-1] - prices[len-2], 0);\\n        b = d;\\n        a = c;\\n        for(int i=len-3; i>=0; i--) {\\n            a = Math.max(b - prices[i], a);\\n            b = Math.max(prices[i] + c, b);\\n            c = Math.max(d - prices[i], c);\\n            d = Math.max(prices[i], d);\\n        }\\n        return a;\\n    }\\n\\nd is the value in the case when you have made a transaction before and you have a share at hand, that's basically the max from i to len.\\n\\nc is the value in the case when you can make one transaction from days i to len. So c is updated only if you buy a share on that day and sell afterward.\\n\\nb is the value in the case when you have a share at hand, and you can make one more transaction. So if you sell it on day i, it's prices[i] + c, otherwise it doesn't change.\\n\\na is the value in the case when you can make two transactions.",
                "codeTag": "Unknown"
            },
            {
                "id": 39673,
                "title": "o-n-time-and-o-n-space-solution-intuative-and-easy-to-understand-cpp",
                "content": "Idea is to find the best profit in the forward direction and in reverse direction.\\nthen we look for a point where max of forward part and max of reverse part meet.\\n\\neg if given array is 1 2 4 2 5 7 2 4 9 0\\nand forward will be 0 1 3 1 4 6 1 3 8 0\\nreverse will be 8 7 5 7 4 2 7 5 0 0\\n\\nnow we will find the cumulative max of both array in respective direction. \\nnow forward will be 0 1 3 3 4 6 6 6 8 8 and reverse will be 8 7 7 7 7 7 7 5 0 0\\n\\nso now we have to find a place where forward[i]+reverse[i+1] is maximum to get the desire value..\\n\\nat last step we are taking care of the base cases like when only 2 elements are given in the array..\\n\\n\\n \\n\\n     class Solution {\\n        public:\\n            int maxProfit(vector<int>& prices) {\\n                if(prices.size()<=1) return 0;\\n                int n=prices.size();\\n                int lr[n];\\n                int rl[n];\\n                lr[0]=0;\\n                rl[n-1]=0;\\n                int minYet=prices[0];\\n                int maxYet=prices[n-1];\\n                for(int i=1;i<n;i++)\\n                {\\n                    if(prices[i]>minYet) lr[i]=prices[i]-minYet;\\n                    else \\n                    {\\n                        minYet=prices[i];\\n                        lr[i]=0;\\n                    }\\n                }\\n                for(int i=n-2;i>=0;i--)\\n                {\\n                    if(prices[i]<maxYet) rl[i]=maxYet-prices[i];\\n                    else\\n                    {\\n                        maxYet=prices[i];\\n                        rl[i]=0;\\n                    }\\n                }\\n                maxYet=lr[0];\\n                for(int i=1;i<n;i++)\\n                {\\n                    maxYet=max(maxYet,lr[i]);\\n                    lr[i]=maxYet;\\n                }\\n                maxYet=rl[n-1];\\n                for(int i=n-2;i>=0;i--)\\n                {\\n                    maxYet=max(maxYet,rl[i]);\\n                    rl[i]=maxYet;\\n                }\\n                int res=0;\\n                for(int i=0;i<n-1;i++)\\n                {\\n                    res=max(res,lr[i]+rl[i+1]);\\n                }\\n                if(lr[n-1]>res) res=lr[n-1];\\n                if(res<rl[0]) res=rl[0];\\n                return res;\\n                \\n            }\\n        };",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n        public:\\n            int maxProfit(vector<int>& prices) {\\n                if(prices.size()<=1) return 0;\\n                int n=prices.size();\\n                int lr[n];\\n                int rl[n];\\n                lr[0]=0;\\n                rl[n-1]=0;\\n                int minYet=prices[0];\\n                int maxYet=prices[n-1];\\n                for(int i=1;i<n;i++)\\n                {\\n                    if(prices[i]>minYet) lr[i]=prices[i]-minYet;\\n                    else \\n                    {\\n                        minYet=prices[i];\\n                        lr[i]=0;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1935326,
                "title": "100-fastest-swift-solution-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of the prices.\\n    //   - space: O(1), only constant space is used.\\n\\n    func maxProfit(_ prices: [Int]) -> Int {\\n        var buy1 = Int.max\\n        var buy2 = Int.max\\n        var sell1 = 0\\n        var sell2 = 0\\n\\n        for price in prices {\\n            buy1 = min(buy1, price)\\n            sell1 = max(sell1, price - buy1)\\n\\n            buy2 = min(buy2, price - sell1)\\n            sell2 = max(sell2, price - buy2)\\n        }\\n\\n        return sell2\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of the prices.\\n    //   - space: O(1), only constant space is used.\\n\\n    func maxProfit(_ prices: [Int]) -> Int {\\n        var buy1 = Int.max\\n        var buy2 = Int.max\\n        var sell1 = 0\\n        var sell2 = 0\\n\\n        for price in prices {\\n            buy1 = min(buy1, price)\\n            sell1 = max(sell1, price - buy1)\\n\\n            buy2 = min(buy2, price - sell1)\\n            sell2 = max(sell2, price - buy2)\\n        }\\n\\n        return sell2\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1702461,
                "title": "c-simple-approach-tc-o-n-sc-o-1",
                "content": "```\\nint maxProfit(vector<int>& prices)\\n{\\n    int buy1=INT_MAX,profit1=0,buy2=INT_MAX,profit2=0;\\n    for(int i=0; i<prices.size(); i++)\\n    {\\n        buy1=min(buy1,prices[i]);\\n        profit1=max(profit1,prices[i]-buy1);\\n\\n        buy2=min(buy2,prices[i]-profit1);\\n        profit2=max(profit2,prices[i]-buy2);\\n    }\\n    return profit2;\\n}\\n```\\n\\n`VoTe plz...`",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint maxProfit(vector<int>& prices)\\n{\\n    int buy1=INT_MAX,profit1=0,buy2=INT_MAX,profit2=0;\\n    for(int i=0; i<prices.size(); i++)\\n    {\\n        buy1=min(buy1,prices[i]);\\n        profit1=max(profit1,prices[i]-buy1);\\n\\n        buy2=min(buy2,prices[i]-profit1);\\n        profit2=max(profit2,prices[i]-buy2);\\n    }\\n    return profit2;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1523169,
                "title": "simple-dp-java-solution-with-explanation-tle-to-accepted",
                "content": "Before we solve this problem, we can arrive at some conclusion\\n\\n1. You can make atmost 2 transactions\\n2. You should make maximum profit\\n3. You should not engage in multiple transactions simultaneously.(You should sell it before buying it again).\\n\\nWe can solve this using DP.\\n\\nLets assume T[i][j] is max profit in ith transaction at jth day.\\n\\nT[2][6] means max profit you can achieve by selling at 6th day in 2nd transaction.\\n\\nT[i][j] can be written as follow\\n\\n`T[i][j] = Max(T[i][j-1], prices[j] - prices[k] + T[i-1][k])` where k = 0.. j-1\\n\\n`T[i][j-1]` => you are not doing any transaction on jth day so whatever the profit on previous day\\n`prices[j] - prices[k] + T[i-1][k]` => If I am buying at day k then, profit is `prices[j] - prices[k]` and we need to add what\\'s the profit at kth day in previous transaction(T[i-1][k]).\\n\\nYou can write the code as follow\\n\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int N = prices.length;\\n        \\n        int T[][] = new int[3][N];\\n        \\n        for(int i = 1; i < 3; i++) {\\n            for(int j = 1; j < N; j++) {\\n                for(int k = 0; k < j; k++) {\\n                    T[i][j] = Math.max(T[i][j], prices[j] + T[i-1][k] - prices[k]);\\n                }\\n                T[i][j] = Math.max(T[i][j], T[i][j-1]);\\n            }\\n        }\\n        \\n        return T[2][N-1];\\n    }\\n}\\n```\\n\\nI was getting TLE. We can optimize this further. If you look at the k loop, we are trying to find kth day to buy which is less than jth day.\\n\\n`T[i-1][k] - prices[k]` should be maximum so that k will be selected. if we can keep the maximum in a variable instead of computing again, we can avoid a loop.\\n\\n\\n```\\n// Time Complexity: O(n)\\n// Space Complexity: O(n)\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int N = prices.length;\\n        int T[][] = new int[3][N];\\n        \\n        for(int i = 1; i <= 2; i++) {\\n            int maxDiff = T[i-1][0] - prices[0];\\n            for(int j = 1; j < N; j++) {\\n                T[i][j] = Math.max(T[i][j-1], prices[j] + maxDiff);\\n                maxDiff = Math.max(maxDiff, T[i-1][j] - prices[j]);\\n            }\\n        }\\n        \\n        return T[2][N-1];\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int N = prices.length;\\n        \\n        int T[][] = new int[3][N];\\n        \\n        for(int i = 1; i < 3; i++) {\\n            for(int j = 1; j < N; j++) {\\n                for(int k = 0; k < j; k++) {\\n                    T[i][j] = Math.max(T[i][j], prices[j] + T[i-1][k] - prices[k]);\\n                }\\n                T[i][j] = Math.max(T[i][j], T[i][j-1]);\\n            }\\n        }\\n        \\n        return T[2][N-1];\\n    }\\n}\\n```\n```\\n// Time Complexity: O(n)\\n// Space Complexity: O(n)\\n\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int N = prices.length;\\n        int T[][] = new int[3][N];\\n        \\n        for(int i = 1; i <= 2; i++) {\\n            int maxDiff = T[i-1][0] - prices[0];\\n            for(int j = 1; j < N; j++) {\\n                T[i][j] = Math.max(T[i][j-1], prices[j] + maxDiff);\\n                maxDiff = Math.max(maxDiff, T[i-1][j] - prices[j]);\\n            }\\n        }\\n        \\n        return T[2][N-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1477485,
                "title": "well-explained-98-faster-clean-concise",
                "content": "## IDEA:\\n\\n\\uD83D\\uDC49 *We may complete at most two transactions and must sell the stock before we buy again.\\n\\uD83D\\uDC49 Suppose we make two transactions at (prices[i], prices[j]) and (prices[p], prices[q]), there is no overlapped parts between prices[i:j+1] and prices[p:q+1].\\n\\uD83D\\uDC49 If no overlapped part, why not dividing the prices into two non-overalpped array and calculate the maximum summation.\\n\\uD83D\\uDC49 First we traverse from left to right, calculate the maximum profit we can earn before prices[i].\\n\\uD83D\\uDC49 Then we traverse from right to left, calculate the maximum profit we can earn after prices[j].*\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n        n = len(prices)\\n        profit = [0]*n\\n        \\n        global_min = prices[0]\\n        for i in range(1,n):\\n            global_min = min(global_min,prices[i])\\n            profit[i] = max(profit[i-1],prices[i]-global_min)\\n        \\n        res = max(profit[-1],0)\\n        global_max = 0\\n        for i in range(n-1,0,-1):\\n            global_max = max(global_max,prices[i])\\n            res = max(res,profit[i-1]+global_max-prices[i])\\n        \\n        return res\\n\\n**Feel free to ask if you have any doubt.** \\uD83E\\uDD17\\n**If you got any help please do Upvote. \\uD83E\\uDD1E\\nThanks**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "## IDEA:\\n\\n\\uD83D\\uDC49 *We may complete at most two transactions and must sell the stock before we buy again.\\n\\uD83D\\uDC49 Suppose we make two transactions at (prices[i], prices[j]) and (prices[p], prices[q]), there is no overlapped parts between prices[i:j+1] and prices[p:q+1].\\n\\uD83D\\uDC49 If no overlapped part, why not dividing the prices into two non-overalpped array and calculate the maximum summation.\\n\\uD83D\\uDC49 First we traverse from left to right, calculate the maximum profit we can earn before prices[i].\\n\\uD83D\\uDC49 Then we traverse from right to left, calculate the maximum profit we can earn after prices[j].*\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        \\n        n = len(prices)\\n        profit = [0]*n\\n        \\n        global_min = prices[0]\\n        for i in range(1,n):\\n            global_min = min(global_min,prices[i])\\n            profit[i] = max(profit[i-1],prices[i]-global_min)\\n        \\n        res = max(profit[-1],0)\\n        global_max = 0\\n        for i in range(n-1,0,-1):\\n            global_max = max(global_max,prices[i])\\n            res = max(res,profit[i-1]+global_max-prices[i])\\n        \\n        return res\\n\\n**Feel free to ask if you have any doubt.** \\uD83E\\uDD17\\n**If you got any help please do Upvote. \\uD83E\\uDD1E\\nThanks**",
                "codeTag": "Java"
            },
            {
                "id": 331592,
                "title": "python-easy-to-understand",
                "content": "```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        \"\"\"\\n        :type prices: List[int]\\n        :rtype: int\\n        \"\"\"\\n        sell1 = 0\\n        sell2 = 0\\n        buy1 = float(\\'inf\\')\\n        buy2 = float(\\'inf\\')\\n        \\n        for p in prices:\\n            \\n            buy1 = min(buy1,p)\\n            sell1 = max(sell1,p-buy1)\\n            buy2 = min(buy2,p-sell1)\\n            sell2 = max(sell2,p-buy2)\\n            \\n        return sell2",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        \"\"\"\\n        :type prices: List[int]\\n        :rtype: int\\n        \"\"\"\\n        sell1 = 0\\n        sell2 = 0\\n        buy1 = float(\\'inf\\')\\n        buy2 = float(\\'inf\\')\\n        \\n        for p in prices:\\n            \\n            buy1 = min(buy1,p)\\n            sell1 = max(sell1,p-buy1)\\n            buy2 = min(buy2,p-sell1)\\n            sell2 = max(sell2,p-buy2)\\n            \\n        return sell2",
                "codeTag": "Java"
            },
            {
                "id": 166484,
                "title": "a-generalized-ac-solution-with-state-machine",
                "content": "Idea borrowed from [309](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/discuss/75928/Share-my-DP-solution-(By-State-Machine-Thinking))  by npvinhphat. \\n\\nWe can construct a state graph for this problem:\\n\\n<img src=\"https://s3-lc-upload.s3.amazonaws.com/users/realnikesi/image_1536000430.png\" style=\"height:480px;\">\\n\\nThere are 5 states\\n- S0[i] is the maximum profit when we never trade\\n- S1[i] is the maximum profit when we buy the stock for the first time at price[i]\\n- S2[i] is the maximum profit when we sell the the stock for the first time at price[i]\\n- S3[i] is the maximum profit when we buy the stock for the second time at price[i]\\n- S4[i] is the maximum profit when we sell the stock for the second time at price[i]\\n\\n`Rest` means we do nothing on price[i].\\n\\nThus we have the following relationships:\\n```\\ns0 = [0,...,0]\\ns1[i] = max(s1[i-1], -prices[i])\\ns2[i] = max(s2[i-1], s1[i-1] + prices[i])\\ns3[i] = max(s3[i-1], s2[i-1] - prices[i])\\ns4[i] = max(s4[i-1], s3[i-1] + prices[i])\\n```\\n\\nHow should we initialize them?\\n- `s0` is always zero (pretty self-explaining).\\n- `s1[0] = -prices[0]` because we are assumed to have 0 money, so buying the stock a `price[0]` cost us that much. \\n- `s2[0] = -infinity` because we don\\'t have stock initially, so giving it `-infinity` restricts it from overflow\\n- `s3[0] = -infinity` same reason\\n- `s4[0] = -infinity` same reason\\n\\nHere is the accepted code:\\n```\\nclass Solution:\\n    def maxProfit(self, prices):\\n        \"\"\"\\n        :type prices: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if len(prices) < 2: return 0\\n        s0 = [0] * len(prices)\\n        s1 = [-prices[0]]\\n        s2 = [float(\\'-inf\\')]\\n        s3 = [float(\\'-inf\\')]\\n        s4 = [float(\\'-inf\\')]\\n        for i in range(1, len(prices)):\\n            s1 += [max(s1[i-1], -prices[i])]\\n            s2 += [max(s2[i-1], s1[i-1] + prices[i])]\\n            s3 += [max(s3[i-1], s2[i-1] - prices[i])]\\n            s4 += [max(s4[i-1], s3[i-1] + prices[i])]\\n        return max(s0[-1], s1[-1], s2[-1], s3[-1], s4[-1])\\n```\\n\\nPersonally I find this method of thinking really easy and clean, and one can come up with it really quickly during interview.",
                "solutionTags": [],
                "code": "```\\ns0 = [0,...,0]\\ns1[i] = max(s1[i-1], -prices[i])\\ns2[i] = max(s2[i-1], s1[i-1] + prices[i])\\ns3[i] = max(s3[i-1], s2[i-1] - prices[i])\\ns4[i] = max(s4[i-1], s3[i-1] + prices[i])\\n```\n```\\nclass Solution:\\n    def maxProfit(self, prices):\\n        \"\"\"\\n        :type prices: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if len(prices) < 2: return 0\\n        s0 = [0] * len(prices)\\n        s1 = [-prices[0]]\\n        s2 = [float(\\'-inf\\')]\\n        s3 = [float(\\'-inf\\')]\\n        s4 = [float(\\'-inf\\')]\\n        for i in range(1, len(prices)):\\n            s1 += [max(s1[i-1], -prices[i])]\\n            s2 += [max(s2[i-1], s1[i-1] + prices[i])]\\n            s3 += [max(s3[i-1], s2[i-1] - prices[i])]\\n            s4 += [max(s4[i-1], s3[i-1] + prices[i])]\\n        return max(s0[-1], s1[-1], s2[-1], s3[-1], s4[-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39722,
                "title": "any-solutions-better-than-o-n-2",
                "content": "My idea:\\n\\n **1)** Find all valley and peek pairs (buy at valley point and sell at peek point) . ( in O(n) time)\\n\\n> input: 6 1 3 2 4 7  6  10 15\\n\\n> output of this step: (1, 3), (2,7), (6, 15)\\n\\n **2)** Find the split point that maximize profit, since we can complete at most two transactions. (in O(m^2), m is the number of pairs generated in step 1)\\n\\n> total_profit = 0\\n\\n> for i =0 to m-1:\\n\\n>      first transaction complete before pair[i] ( include pair[i])\\n>         compute max profit of the first transaction in O(i)\\n>      second transaction complete after pair[i] (exclude pair[i])\\n>         compute max profit of the second transaction in O(m-i)\\n>      total_profit = max( total_profit, first + second)\\n\\nmy accepted code:\\n\\n    int maxProfit(vector<int> &prices) {\\n            // step 1, find pairs\\n            vector<int> lows;  // local low points\\n            vector<int> highs; // local peek points\\n            \\n            int n = prices.size();\\n            int i = 0;\\n            while(i < n) {\\n                while(i+1<n && prices[i+1] <= prices[i]) ++i;\\n                lows.push_back(prices[i]);\\n                \\n                while(i+1<n && prices[i+1] >= prices[i]) ++i;\\n                highs.push_back(prices[i]);\\n                \\n                ++i;\\n            }\\n            \\n            // step 2: split\\n            int total_profit = 0;\\n            n = lows.size();\\n            for (i = 0; i < n; ++i) {\\n                int j = 0;\\n                int low = INT_MAX;\\n                int high = 0;\\n                int first = 0;   // max profit of the first transaction\\n                int second = 0;  // max profit of the second transaction\\n                while (j <= i) {\\n                    low = min(low, lows[j]);\\n                    high = highs[j];\\n                    first = max(first, high-low);\\n                    ++j;\\n                }\\n                \\n                low = INT_MAX;\\n                high = 0;\\n                j = i+1;\\n                while (j < n) {\\n                    low = min(low, lows[j]);\\n                    high = highs[j];\\n                    second = max(second, high - low);\\n                    ++j;\\n                }\\n                total_profit = max(total_profit, first + second);\\n            }\\n            \\n            return total_profit;\\n        }\\n\\n\\n**I think there are better solutions, but I haven't got it - -\\nAnybody has one to share ?**",
                "solutionTags": [],
                "code": "My idea:\\n\\n **1)** Find all valley and peek pairs (buy at valley point and sell at peek point) . ( in O(n) time)\\n\\n> input: 6 1 3 2 4 7  6  10 15\\n\\n> output of this step: (1, 3), (2,7), (6, 15)\\n\\n **2)** Find the split point that maximize profit, since we can complete at most two transactions. (in O(m^2), m is the number of pairs generated in step 1)\\n\\n> total_profit = 0\\n\\n> for i =0 to m-1:\\n\\n>      first transaction complete before pair[i] ( include pair[i])\\n>         compute max profit of the first transaction in O(i)\\n>      second transaction complete after pair[i] (exclude pair[i])\\n>         compute max profit of the second transaction in O(m-i)\\n>      total_profit = max( total_profit, first + second)\\n\\nmy accepted code:\\n\\n    int maxProfit(vector<int> &prices) {\\n            // step 1, find pairs\\n            vector<int> lows;  // local low points\\n            vector<int> highs; // local peek points\\n            \\n            int n = prices.size();\\n            int i = 0;\\n            while(i < n) {\\n                while(i+1<n && prices[i+1] <= prices[i]) ++i;\\n                lows.push_back(prices[i]);\\n                \\n                while(i+1<n && prices[i+1] >= prices[i]) ++i;\\n                highs.push_back(prices[i]);\\n                \\n                ++i;\\n            }\\n            \\n            // step 2: split\\n            int total_profit = 0;\\n            n = lows.size();\\n            for (i = 0; i < n; ++i) {\\n                int j = 0;\\n                int low = INT_MAX;\\n                int high = 0;\\n                int first = 0;   // max profit of the first transaction\\n                int second = 0;  // max profit of the second transaction\\n                while (j <= i) {\\n                    low = min(low, lows[j]);\\n                    high = highs[j];\\n                    first = max(first, high-low);\\n                    ++j;\\n                }\\n                \\n                low = INT_MAX;\\n                high = 0;\\n                j = i+1;\\n                while (j < n) {\\n                    low = min(low, lows[j]);\\n                    high = highs[j];\\n                    second = max(second, high - low);\\n                    ++j;\\n                }\\n                total_profit = max(total_profit, first + second);\\n            }\\n            \\n            return total_profit;\\n        }\\n\\n\\n**I think there are better solutions, but I haven't got it - -\\nAnybody has one to share ?**",
                "codeTag": "Unknown"
            },
            {
                "id": 1523164,
                "title": "5-lines-in-python",
                "content": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        s0 = 0\\n        h1 = s1 = h2 = s2 = float(\\'-inf\\')\\n        for p in prices:\\n            h1, s1, h2, s2 = max(h1, s0 - p), max(s1, h1 + p), max(h2, s1 - p), max(s2, h2 + p)\\n        return max(s0, s1, s2)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        s0 = 0\\n        h1 = s1 = h2 = s2 = float(\\'-inf\\')\\n        for p in prices:\\n            h1, s1, h2, s2 = max(h1, s0 - p), max(s1, h1 + p), max(h2, s1 - p), max(s2, h2 + p)\\n        return max(s0, s1, s2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 846227,
                "title": "3-solution-3-different-approaches-must-check",
                "content": "```\\n// https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/\\n\\n/*\\nSolution 1: Recursion + Memoization(Not a best solution, But you will get idea about optimize solution)\\n(Pass 201/214 test cases, Give TLE)\\n\\nThree States :\\n1. Buy a share of stock\\n2. Sell a share of stock\\n3. Do nothing\\n\\nGoal :\\nBuy at minimum possible price and sell at maximum posible price.\\n\\nTime Complexity - O(K*N*N), Space Complexity - O(K*3*N) (here k = 2)\\n*/\\nclass Solution\\n{\\npublic:\\n    vector<vector<vector<int>>> memo;\\n    int solve(vector<int> &prices, int pos, int tran, bool isBought)\\n    {\\n        //Base Case\\n        if (pos >= n || t == 0)\\n            return 0;\\n\\n        if (memo[isBought][tran][pos] != -1)\\n            return memo[isBought][tran][pos];\\n\\n        int result = solve(prices, pos + 1, tran, isBought); //Skip(Do nothing)\\n        if (isBought)\\n            result = max(result, solve(prices, pos + 1, tran - 1, false) + prices[pos]); // Sell the share\\n        else\\n            result = max(result, solve(prices, pos + 1, tran, true) - prices[pos]); // Buy the share\\n\\n        return result;\\n    }\\n    int maxProfit(vector<int> &prices)\\n    {\\n        memo.resize(2, vector<vector<int>>(3, vector<int>(n, -1)));\\n        return solve(prices, 0, 2, false);\\n    }\\n};\\n\\n/* Solution 2:Using DP \\n\\ndp[k][i] = max(dp[k][i-1], prices[i] - prices[j] + dp[k-1][j-1]), j=[0..i-1]\\n\\nFor k transactions, on i-th day,if we don\\'t trade then the profit is same as previous day dp[k, i-1];\\nand if we bought the share on j-th day where j=[0..i-1], then sell the share on i-th day then the profit is\\nprices[i] - prices[j] + dp[k-1, j-1].\\nActually j can be i as well. When j is i, the one more extra item prices[i] - prices[j] + dp[k-1, j] = dp[k-1, i] looks like we just lose one chance of transaction.\\n*/\\nclass Solution\\n{\\npublic:\\n    int maxProfit(vector<int> &prices)\\n    {\\n        int n = prices.size();\\n        if (n == 0)\\n            return 0;\\n\\n        vector<vector<int>> dp(3, vector<int>(n, 0));\\n        for (int k = 1; k <= 2; k++)\\n        {\\n            int minPrice = prices[0];\\n            for (int i = 1; i < n; i++)\\n            {\\n                minPrice = min(minPrice, prices[i] - dp[k - 1][i - 1]);\\n                dp[k][i] = max(dp[k][i - 1], prices[i] - minPrice);\\n            }\\n        }\\n        return dp[2][n - 1];\\n    }\\n};\\n\\n/*\\nSolution 3: Divide and Conquor Algorithm (Only for k=2)\\nI will add more explation later...\\n\\nTime Complexity - O(N), Space Complexity - O(N)\\n*/\\nclass Solution\\n{\\npublic:\\n    int maxProfit(vector<int> &prices)\\n    {\\n        int n = n;\\n        if (n <= 1)\\n            return 0;\\n\\n        vector<int> left(n, 0), right(n, 0);\\n\\n        // For 1st transactions\\n        int leftMin = prices[0]; //Also known as Best buying price\\n        for (int i = 1; i < n; ++i)\\n        {\\n            left[i] = max(left[i - 1], prices[i] - leftMin);\\n            leftMin = min(leftMin, prices[i]);\\n        }\\n\\n        // For 2nd transactions\\n        int rightMax = prices[n - 1]; //also known as best selling price\\n        for (int i = n - 2; i >= 0; --i)\\n        {\\n            right[i] = max(right[i + 1], rightMax - prices[i]);\\n            rightMax = max(rightMax, prices[i]);\\n        }\\n\\n        int Profit = right[0];\\n        for (int i = 1; i < n; i++)\\n            Profit = max(Profit, left[i - 1] + right[i]);\\n\\n        return Profit;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n// https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/\\n\\n/*\\nSolution 1: Recursion + Memoization(Not a best solution, But you will get idea about optimize solution)\\n(Pass 201/214 test cases, Give TLE)\\n\\nThree States :\\n1. Buy a share of stock\\n2. Sell a share of stock\\n3. Do nothing\\n\\nGoal :\\nBuy at minimum possible price and sell at maximum posible price.\\n\\nTime Complexity - O(K*N*N), Space Complexity - O(K*3*N) (here k = 2)\\n*/\\nclass Solution\\n{\\npublic:\\n    vector<vector<vector<int>>> memo;\\n    int solve(vector<int> &prices, int pos, int tran, bool isBought)\\n    {\\n        //Base Case\\n        if (pos >= n || t == 0)\\n            return 0;\\n\\n        if (memo[isBought][tran][pos] != -1)\\n            return memo[isBought][tran][pos];\\n\\n        int result = solve(prices, pos + 1, tran, isBought); //Skip(Do nothing)\\n        if (isBought)\\n            result = max(result, solve(prices, pos + 1, tran - 1, false) + prices[pos]); // Sell the share\\n        else\\n            result = max(result, solve(prices, pos + 1, tran, true) - prices[pos]); // Buy the share\\n\\n        return result;\\n    }\\n    int maxProfit(vector<int> &prices)\\n    {\\n        memo.resize(2, vector<vector<int>>(3, vector<int>(n, -1)));\\n        return solve(prices, 0, 2, false);\\n    }\\n};\\n\\n/* Solution 2:Using DP \\n\\ndp[k][i] = max(dp[k][i-1], prices[i] - prices[j] + dp[k-1][j-1]), j=[0..i-1]\\n\\nFor k transactions, on i-th day,if we don\\'t trade then the profit is same as previous day dp[k, i-1];\\nand if we bought the share on j-th day where j=[0..i-1], then sell the share on i-th day then the profit is\\nprices[i] - prices[j] + dp[k-1, j-1].\\nActually j can be i as well. When j is i, the one more extra item prices[i] - prices[j] + dp[k-1, j] = dp[k-1, i] looks like we just lose one chance of transaction.\\n*/\\nclass Solution\\n{\\npublic:\\n    int maxProfit(vector<int> &prices)\\n    {\\n        int n = prices.size();\\n        if (n == 0)\\n            return 0;\\n\\n        vector<vector<int>> dp(3, vector<int>(n, 0));\\n        for (int k = 1; k <= 2; k++)\\n        {\\n            int minPrice = prices[0];\\n            for (int i = 1; i < n; i++)\\n            {\\n                minPrice = min(minPrice, prices[i] - dp[k - 1][i - 1]);\\n                dp[k][i] = max(dp[k][i - 1], prices[i] - minPrice);\\n            }\\n        }\\n        return dp[2][n - 1];\\n    }\\n};\\n\\n/*\\nSolution 3: Divide and Conquor Algorithm (Only for k=2)\\nI will add more explation later...\\n\\nTime Complexity - O(N), Space Complexity - O(N)\\n*/\\nclass Solution\\n{\\npublic:\\n    int maxProfit(vector<int> &prices)\\n    {\\n        int n = n;\\n        if (n <= 1)\\n            return 0;\\n\\n        vector<int> left(n, 0), right(n, 0);\\n\\n        // For 1st transactions\\n        int leftMin = prices[0]; //Also known as Best buying price\\n        for (int i = 1; i < n; ++i)\\n        {\\n            left[i] = max(left[i - 1], prices[i] - leftMin);\\n            leftMin = min(leftMin, prices[i]);\\n        }\\n\\n        // For 2nd transactions\\n        int rightMax = prices[n - 1]; //also known as best selling price\\n        for (int i = n - 2; i >= 0; --i)\\n        {\\n            right[i] = max(right[i + 1], rightMax - prices[i]);\\n            rightMax = max(rightMax, prices[i]);\\n        }\\n\\n        int Profit = right[0];\\n        for (int i = 1; i < n; i++)\\n            Profit = max(Profit, left[i - 1] + right[i]);\\n\\n        return Profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 299506,
                "title": "make-it-a-story-with-explanation-o-n-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    //dp + greedy\\n    //time: o(n)\\n    //space: o(1)\\n    int maxProfit(vector<int>& prices) {\\n        if(prices.size() < 2)\\n            return 0;\\n        \\n        int one_buy_profit = INT_MIN;//assume we borrow money to buy stock, so one_buy = INT_MIN. becaue we may lose money.\\n        int one_buy_one_sell_profit = 0;//inint one_buy_one_sell_profit = 0, because there is no profit at all.\\n        int two_buy_profit = INT_MIN;//the same as one_buy_profit.\\n        int two_buy_two_sell_profit = 0;//the same as one_buy_one_sell_profit.\\n        for(auto& cur_price : prices) {\\n            one_buy_profit = std::max(one_buy_profit, 0 - cur_price);//0 means the inintial profit is zero, so one buy profit is negative.\\n            one_buy_one_sell_profit = std::max(one_buy_one_sell_profit, one_buy_profit + cur_price);//one sell = one buy + cur_price;\\n            two_buy_profit = std::max(two_buy_profit, one_buy_one_sell_profit - cur_price);//two buy profit = earned profit(there is one sell) - cur_price;\\n            two_buy_two_sell_profit = std::max(two_buy_two_sell_profit, two_buy_profit + cur_price);//two sell = two buy + cur_price;\\n        }\\n        \\n        return std::max(one_buy_one_sell_profit, two_buy_two_sell_profit);//if one buy can reach the max profit, two_buy_two_sell_profit will be set to one_buy_one_sell_profit.\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    //dp + greedy\\n    //time: o(n)\\n    //space: o(1)\\n    int maxProfit(vector<int>& prices) {\\n        if(prices.size() < 2)\\n            return 0;\\n        \\n        int one_buy_profit = INT_MIN;//assume we borrow money to buy stock, so one_buy = INT_MIN. becaue we may lose money.\\n        int one_buy_one_sell_profit = 0;//inint one_buy_one_sell_profit = 0, because there is no profit at all.\\n        int two_buy_profit = INT_MIN;//the same as one_buy_profit.\\n        int two_buy_two_sell_profit = 0;//the same as one_buy_one_sell_profit.\\n        for(auto& cur_price : prices) {\\n            one_buy_profit = std::max(one_buy_profit, 0 - cur_price);//0 means the inintial profit is zero, so one buy profit is negative.\\n            one_buy_one_sell_profit = std::max(one_buy_one_sell_profit, one_buy_profit + cur_price);//one sell = one buy + cur_price;\\n            two_buy_profit = std::max(two_buy_profit, one_buy_one_sell_profit - cur_price);//two buy profit = earned profit(there is one sell) - cur_price;\\n            two_buy_two_sell_profit = std::max(two_buy_two_sell_profit, two_buy_profit + cur_price);//two sell = two buy + cur_price;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 39618,
                "title": "why-don-t-we-make-our-life-easier",
                "content": "The idea is very basic. At most two transactions means we can break at any time point and compute the max revenue before this time point and after this time point. For every possible time point, we choose the maximum.\\n\\nNote that right_max start from the last time point, which is just like a mirror algorithm from the Best Time to Buy and Sell Stock I\\n\\n    int maxProfit(vector<int>& prices) {\\n        vector<int> left_max;\\n        vector<int> right_max;\\n        int n = prices.size();\\n        if(n == 0){\\n            return 0;\\n        }\\n        int cur_min = prices[0];\\n        int max_r = 0;\\n        for(int i = 0; i < n; i++){\\n            max_r = max(max_r, prices[i] - cur_min);\\n            left_max.push_back(max_r);\\n            cur_min = min(cur_min, prices[i]);\\n        }\\n        int cur_max = prices[n-1];\\n        max_r = 0;\\n        for(int i = n-1; i >= 0; i--){\\n            max_r = max(max_r, cur_max - prices[i]);\\n            right_max.insert(right_max.begin(), max_r);\\n            cur_max = max(cur_max, prices[i]);\\n        }\\n        int sum_max = 0;\\n        for(int i = 0; i < n; i++){\\n            sum_max = max(sum_max, left_max[i] + right_max[i]);\\n        }\\n        return sum_max;\\n    }",
                "solutionTags": [],
                "code": "The idea is very basic. At most two transactions means we can break at any time point and compute the max revenue before this time point and after this time point. For every possible time point, we choose the maximum.\\n\\nNote that right_max start from the last time point, which is just like a mirror algorithm from the Best Time to Buy and Sell Stock I\\n\\n    int maxProfit(vector<int>& prices) {\\n        vector<int> left_max;\\n        vector<int> right_max;\\n        int n = prices.size();\\n        if(n == 0){\\n            return 0;\\n        }\\n        int cur_min = prices[0];\\n        int max_r = 0;\\n        for(int i = 0; i < n; i++){\\n            max_r = max(max_r, prices[i] - cur_min);\\n            left_max.push_back(max_r);\\n            cur_min = min(cur_min, prices[i]);\\n        }\\n        int cur_max = prices[n-1];\\n        max_r = 0;\\n        for(int i = n-1; i >= 0; i--){\\n            max_r = max(max_r, cur_max - prices[i]);\\n            right_max.insert(right_max.begin(), max_r);\\n            cur_max = max(cur_max, prices[i]);\\n        }\\n        int sum_max = 0;\\n        for(int i = 0; i < n; i++){\\n            sum_max = max(sum_max, left_max[i] + right_max[i]);\\n        }\\n        return sum_max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1707212,
                "title": "divide-and-conquer-method-c-solution-with-full-explanation-in-o-n-time-complexity",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Here we\\u2019ve solved using ***Divide and Concorde method.***\\n- We take 2 array to keep the profit: one from left to right another from right to left.\\n- For ***left array*** we keep ***mn*** to keep track minimum & calculate the max profit form left to till that position in ***left[i].***\\n- Similarly, for ***right array*** we keep ***mx*** which keep the height selling price and iterate from last to begin and store it in ***right[i].***\\n- Finally, find the profit with 2 transaction, take 1 from left & another from right array. Iterate right array and add the last day profit from left array, take the max in profit.\\n- **Time complexity:** O(n).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();  \\n        vector <int> left(n), right(n);\\n        \\n        int mn = prices[0], mx = prices[n-1];\\n        \\n        for(int i=1; i<n; i++){\\n            left[i] = max(left[i-1], prices[i]-mn);\\n            mn = min(mn, prices[i]);\\n        }\\n        \\n        for(int i=n-2; i>=0; i--){\\n            \\n            right[i] = max(right[i+1], mx-prices[i]);\\n            mx = max(mx, prices[i]);\\n        }\\n        \\n        int profit = right[0];\\n        \\n        for(int i=1; i<n; i++)\\n            profit = max(profit, left[i-1]+right[i]);\\n        \\n        return profit;\\n    }\\n};**\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();  \\n        vector <int> left(n), right(n);\\n        \\n        int mn = prices[0], mx = prices[n-1];\\n        \\n        for(int i=1; i<n; i++){\\n            left[i] = max(left[i-1], prices[i]-mn);\\n            mn = min(mn, prices[i]);\\n        }\\n        \\n        for(int i=n-2; i>=0; i--){\\n            \\n            right[i] = max(right[i+1], mx-prices[i]);\\n            mx = max(mx, prices[i]);\\n        }\\n        \\n        int profit = right[0];\\n        \\n        for(int i=1; i<n; i++)\\n            profit = max(profit, left[i-1]+right[i]);\\n        \\n        return profit;\\n    }\\n};**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1586270,
                "title": "java-clean-and-detailed-dp-tabulation-solution-with-handwritten-notes",
                "content": "Time Complexity - O(2*N)\\nSpace Complexity - O(2*N)\\nRuntime - 3ms - Faster than 99.22%\\n\\n```\\nclass Solution {\\n    public int maxProfit(int[] arr) {\\n        int n = arr.length;\\n        int[] before = new int[n];\\n    \\tint min = arr[0];\\n    \\tint high = 0;\\n    \\tfor(int i=0; i<n; i++){\\n    \\t\\tif(arr[i] < min){\\n    \\t\\t\\tmin = arr[i];\\n    \\t\\t}\\n    \\t\\tif(arr[i] - min > high){\\n    \\t\\t\\thigh = arr[i] - min;\\n    \\t\\t}\\n\\t\\t\\tbefore[i] = high;\\n    \\t}\\n    \\t\\n    \\tint[] after = new int[n];\\n    \\tint max = arr[n-1];\\n    \\thigh = 0;\\n    \\tfor(int i = n-1; i>=0; i--){\\n    \\t\\tif(arr[i] > max){\\n    \\t\\t\\tmax = arr[i];\\n    \\t\\t}\\n    \\t\\tif(max - arr[i] > high){\\n    \\t\\t\\thigh = max - arr[i];\\n    \\t\\t}\\n    \\t\\tafter[i] = high;\\n    \\t}\\n    \\t\\n    \\tint mp = 0;\\n    \\tfor(int i=0; i<n; i++){\\n    \\t\\tif(before[i] + after[i] > mp)\\n    \\t\\t\\tmp = before[i] + after[i];\\n    \\t}\\n        \\n    \\treturn mp;\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/cd7548b8-c9cc-4b3a-8762-cc308c13449d_1637317702.8568325.jpeg)\\n.\\n![image](https://assets.leetcode.com/users/images/4c12b727-0ebc-422f-8777-5fd3cba381c2_1637317713.5058212.jpeg)\\n\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] arr) {\\n        int n = arr.length;\\n        int[] before = new int[n];\\n    \\tint min = arr[0];\\n    \\tint high = 0;\\n    \\tfor(int i=0; i<n; i++){\\n    \\t\\tif(arr[i] < min){\\n    \\t\\t\\tmin = arr[i];\\n    \\t\\t}\\n    \\t\\tif(arr[i] - min > high){\\n    \\t\\t\\thigh = arr[i] - min;\\n    \\t\\t}\\n\\t\\t\\tbefore[i] = high;\\n    \\t}\\n    \\t\\n    \\tint[] after = new int[n];\\n    \\tint max = arr[n-1];\\n    \\thigh = 0;\\n    \\tfor(int i = n-1; i>=0; i--){\\n    \\t\\tif(arr[i] > max){\\n    \\t\\t\\tmax = arr[i];\\n    \\t\\t}\\n    \\t\\tif(max - arr[i] > high){\\n    \\t\\t\\thigh = max - arr[i];\\n    \\t\\t}\\n    \\t\\tafter[i] = high;\\n    \\t}\\n    \\t\\n    \\tint mp = 0;\\n    \\tfor(int i=0; i<n; i++){\\n    \\t\\tif(before[i] + after[i] > mp)\\n    \\t\\t\\tmp = before[i] + after[i];\\n    \\t}\\n        \\n    \\treturn mp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 795456,
                "title": "python-simple-solution-fully-explained-video-code-image",
                "content": "[](https://www.youtube.com/watch?v=1zxgH-YVBbw)\\nhttps://www.youtube.com/watch?v=1zxgH-YVBbw\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if not prices:\\n            return 0\\n        \\n        A = -prices[0]\\n        B = float(\\'-inf\\')\\n        C = float(\\'-inf\\')\\n        D = float(\\'-inf\\')\\n        \\n        for price in prices:\\n            A = max(A, -price)\\n            B = max(B, A + price)\\n            C = max(C, B - price)\\n            D = max(D, C + price)\\n            \\n        return D\\n```\\n![image](https://assets.leetcode.com/users/images/2c7da692-b21a-4b45-b47b-704983d8a8c7_1597597025.834179.png)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if not prices:\\n            return 0\\n        \\n        A = -prices[0]\\n        B = float(\\'-inf\\')\\n        C = float(\\'-inf\\')\\n        D = float(\\'-inf\\')\\n        \\n        for price in prices:\\n            A = max(A, -price)\\n            B = max(B, A + price)\\n            C = max(C, B - price)\\n            D = max(D, C + price)\\n            \\n        return D\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39681,
                "title": "generalized-dp-solution-in-java",
                "content": "    Idea is simple : Keep track of the minimum value till previous day and \\n    check how much maximum profit can be obtained for current day.\\n\\n\\n    public int maxProfit(int[] prices) {\\n            if(prices.length == 0)\\n                return 0;\\n    \\t\\tint trans = 2;\\n    \\t\\tint dp[][] = new int[trans + 1][prices.length];\\n    \\t\\t\\n    \\t\\tfor(int i = 1; i <= trans; i++) {\\n    \\t\\t\\tint min = Integer.MAX_VALUE;\\n    \\t\\t\\tfor(int j = 1; j < prices.length; j++) {\\n    \\t\\t\\t\\tmin = Math.min(min, prices[j - 1] - dp[i - 1][j - 1]);\\n    \\t\\t\\t\\tdp[i][j] = Math.max(dp[i][j - 1], prices[j] - min);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn dp[trans][prices.length - 1];\\n    \\t}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "    Idea is simple : Keep track of the minimum value till previous day and \\n    check how much maximum profit can be obtained for current day.\\n\\n\\n    public int maxProfit(int[] prices) {\\n            if(prices.length == 0)\\n                return 0;\\n    \\t\\tint trans = 2;\\n    \\t\\tint dp[][] = new int[trans + 1][prices.length];\\n    \\t\\t\\n    \\t\\tfor(int i = 1; i <= trans; i++) {\\n    \\t\\t\\tint min = Integer.MAX_VALUE;\\n    \\t\\t\\tfor(int j = 1; j < prices.length; j++) {\\n    \\t\\t\\t\\tmin = Math.min(min, prices[j - 1] - dp[i - 1][j - 1]);\\n    \\t\\t\\t\\tdp[i][j] = Math.max(dp[i][j - 1], prices[j] - min);\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn dp[trans][prices.length - 1];\\n    \\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2480095,
                "title": "python-o-n-2-3-all-easy-soln-easy-approch",
                "content": "# Recursive- Memoisation : TLE\\n```\\nclass Solution:\\n    def f(self,ind,buy,cap,n,price,dp):\\n        if ind==n:\\n            return 0\\n        if cap==0:\\n            return 0\\n        if dp[ind][buy][cap]!=-1:\\n            return dp[ind][buy][cap]\\n        if buy:\\n            profit=max(-price[ind]+self.f(ind+1,0,cap,n,price,dp),0+self.f(ind+1,1,cap,n,price,dp))\\n        else:\\n            profit=max(price[ind]+self.f(ind+1,1,cap-1,n,price,dp),0+self.f(ind+1,0,cap,n,price,dp))\\n        dp[ind][buy][cap]=profit\\n        return dp[ind][buy][cap]\\n    \\n    def maxProfit(self, prices: List[int]) -> int:\\n        n=len(prices)\\n        dp=[[[-1 for i in range(3)]for j in range(2)]for k in range(n)]\\n        return self.f(0,1,2,n,prices,dp)\\n```\\n# Tabulation :\\n```\\ndef maxProfit(prices, n):\\n    dp=[[[0 for i in range(3)]for j in range(2)]for k in range(n+1)]\\n    for ind in range(n-1,-1,-1):\\n        for buy in range(2):\\n            for cap in range(1,3):\\n                if buy==1:\\n                    dp[ind][buy][cap]=max(-prices[ind]+dp[ind+1][0][cap],0+dp[ind+1][1][cap])\\n                else:\\n                    dp[ind][buy][cap]=max(prices[ind]+dp[ind+1][1][cap-1],0+dp[ind+1][0][cap])\\n    return dp[0][1][2]\\n```\\n# Tabulation : Space Optimisation O(Nx2x3) Accepted\\n\\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n=len(prices)\\n        after=[[0 for i in range(3)]for j in range(2)]\\n        curr=[[0 for i in range(3)]for j in range(2)]\\n        for buy in range(2):          #Base case 1\\n            for cap in range(3):\\n                curr[buy][cap]=0\\n        for ind in range(n):          #Base case 2\\n            for buy in range(2):\\n                curr[buy][0]=0\\n\\n        for ind in range(n-1,-1,-1):\\n            for buy in range(2):\\n                for cap in range(1,3):\\n                    if buy==1:\\n                        curr[buy][cap]=max(-prices[ind]+after[0][cap],0+after[1][cap])\\n                    else:\\n                        curr[buy][cap]=max(prices[ind]+after[1][cap-1],0+after[0][cap])\\n            after=curr\\n        return after[1][2]\\n```\\n\\n\\n\\n# Upvote If You Liked my Solution . Thanks for visit",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def f(self,ind,buy,cap,n,price,dp):\\n        if ind==n:\\n            return 0\\n        if cap==0:\\n            return 0\\n        if dp[ind][buy][cap]!=-1:\\n            return dp[ind][buy][cap]\\n        if buy:\\n            profit=max(-price[ind]+self.f(ind+1,0,cap,n,price,dp),0+self.f(ind+1,1,cap,n,price,dp))\\n        else:\\n            profit=max(price[ind]+self.f(ind+1,1,cap-1,n,price,dp),0+self.f(ind+1,0,cap,n,price,dp))\\n        dp[ind][buy][cap]=profit\\n        return dp[ind][buy][cap]\\n    \\n    def maxProfit(self, prices: List[int]) -> int:\\n        n=len(prices)\\n        dp=[[[-1 for i in range(3)]for j in range(2)]for k in range(n)]\\n        return self.f(0,1,2,n,prices,dp)\\n```\n```\\ndef maxProfit(prices, n):\\n    dp=[[[0 for i in range(3)]for j in range(2)]for k in range(n+1)]\\n    for ind in range(n-1,-1,-1):\\n        for buy in range(2):\\n            for cap in range(1,3):\\n                if buy==1:\\n                    dp[ind][buy][cap]=max(-prices[ind]+dp[ind+1][0][cap],0+dp[ind+1][1][cap])\\n                else:\\n                    dp[ind][buy][cap]=max(prices[ind]+dp[ind+1][1][cap-1],0+dp[ind+1][0][cap])\\n    return dp[0][1][2]\\n```\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n=len(prices)\\n        after=[[0 for i in range(3)]for j in range(2)]\\n        curr=[[0 for i in range(3)]for j in range(2)]\\n        for buy in range(2):          #Base case 1\\n            for cap in range(3):\\n                curr[buy][cap]=0\\n        for ind in range(n):          #Base case 2\\n            for buy in range(2):\\n                curr[buy][0]=0\\n\\n        for ind in range(n-1,-1,-1):\\n            for buy in range(2):\\n                for cap in range(1,3):\\n                    if buy==1:\\n                        curr[buy][cap]=max(-prices[ind]+after[0][cap],0+after[1][cap])\\n                    else:\\n                        curr[buy][cap]=max(prices[ind]+after[1][cap-1],0+after[0][cap])\\n            after=curr\\n        return after[1][2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1687104,
                "title": "c-simple-approach-complete-explanation-o-n",
                "content": "The idea is to find the max profit possible upto a particular index and max possible profit after a particular index(including that index itself).\\n\\nNow if we start traversing the array from the beginning we can store the minimum value we have encountered .And for every element we will check if, difference between the current element and minimum value upto that element, is maximum.Thus in this way we can calculate max profit possible upto a particular index provided only one transaction is done.\\nSimilarly,we can traverse the array from back and keep on storing max value we have encountered till now.And difference between max value and current element might give us the maximum profit if we do exactly one transaction beginning from that particular element.Thus by following this process we will be able to find max profit possible between the current element and last element.\\n\\nNow for every index we have got max profit upto that index(if only one transaction is done before that index) and max profit after that index(if only one transaction is done after the current index).\\nNow simply we will check for max profit possible on left of an index and max possible profit on the right of the index.Sum of these two profits can possibly fetch us the max profit possible if two transactions are to be done.So for every index we will  follow this process and whichever index  will give us max profit that will be our required answer.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices)\\n    {\\n          int mx=0,mn=INT_MAX,n=prices.size();\\n        \\n          vector <int> f(n),b(n);\\n          f[0]=0;\\n        \\n          //f vector stores the maximum possible profit until ith index if we perform exactly one transaction upto ith index\\n          for(int i=0;i<n;i++)\\n          {\\n             f[i]=max(mx,prices[i]-mn); \\n             mn=min(mn,prices[i]);\\n             mx=max(mx,f[i]);\\n          }\\n          //b vector stores the maximum possible profit after ith index if we perform exactly one transaction after ith index(ith index included)\\n          mx=0;\\n          int mxx=0,ans=0;\\n        //b[i]+f[i-1] will give us the maximum profit if we do exactly one transaction before ith index and exactly one transaction after ith index(including ith index)\\n        \\n        //ans variable will store the overall maximum profit \\n          for(int i=n-1;i>=0;i--)\\n          {\\n              b[i]=max(mx,mxx-prices[i]);\\n              mxx=max(mxx,prices[i]);\\n              mx=max(mx,b[i]);\\n              \\n              if(i>0)\\n              ans=max(b[i]+f[i-1],ans);\\n          }\\n          \\n         ans=max(b[0],ans);\\n          return ans;\\n    }\\n};\\n\\n```\\n\\nHappy Coding!\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices)\\n    {\\n          int mx=0,mn=INT_MAX,n=prices.size();\\n        \\n          vector <int> f(n),b(n);\\n          f[0]=0;\\n        \\n          //f vector stores the maximum possible profit until ith index if we perform exactly one transaction upto ith index\\n          for(int i=0;i<n;i++)\\n          {\\n             f[i]=max(mx,prices[i]-mn); \\n             mn=min(mn,prices[i]);\\n             mx=max(mx,f[i]);\\n          }\\n          //b vector stores the maximum possible profit after ith index if we perform exactly one transaction after ith index(ith index included)\\n          mx=0;\\n          int mxx=0,ans=0;\\n        //b[i]+f[i-1] will give us the maximum profit if we do exactly one transaction before ith index and exactly one transaction after ith index(including ith index)\\n        \\n        //ans variable will store the overall maximum profit \\n          for(int i=n-1;i>=0;i--)\\n          {\\n              b[i]=max(mx,mxx-prices[i]);\\n              mxx=max(mxx,prices[i]);\\n              mx=max(mx,b[i]);\\n              \\n              if(i>0)\\n              ans=max(b[i]+f[i-1],ans);\\n          }\\n          \\n         ans=max(b[0],ans);\\n          return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 795938,
                "title": "heavily-commented-javascript-solution-o-n-no-dp",
                "content": "```\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\nvar maxProfit = function(prices) {\\n    /* Wasn\\'t feeling a good solution out of my own, so went to discuss\\n    but that wasn\\'t triggering an \"aha\" moment. went to youtube, and this\\n    video seems ok: https://www.youtube.com/watch?v=0FKn0FSIQYE\\n    \\n    Tactic is first to understand how you\\'d do one transaction:\\n    Loop, keep track of \\n    A) the lowest number you\\'ve seen: Pmin\\n    B) the best sell you can make with the numbers after that: Profit\\n        - OR - the best profit you\\'ve seen so far\\n    \\n    For [3,3,5,0,0,3,1,4]\\n    you\\'ll end up with\\n    \\n    Input: [3,3,5,0,0,3,1,4]\\n    Pmin : [3,3,3,0,0,0,0,0] // again, simply the lowest hnumber\\n    Profit:[0,0,2,2,2,3,3,4] // (input - Pmin) OR the best profit you had so far\\n    \\n    That\\'s how we do it for 1 (see https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)\\n    \\n    ----------- you with me still? ------------\\n    \\n    Now instead of throwing that array we worked on away, we save that profit array.\\n    \\n    and then we do the same effort but backwards. Why? Because a 2nd buy and sell\\n    will come completely after the first buy and sell.\\n    \\n    Because it\\'s backwards, we now use Pmax instead of min. \\n    Read the following from the back to front\\n    \\n    Input: [3,3,5,0,0,3,1,4]\\n    Pmax : [5,5,5,4,4,4,4,4] // highest number from the back\\n    Profit:[4,4,4,4,4,3,3,0] // (Pmax - input) OR the best profit we\\'ve seen.\\n    \\n    Again, we store the profit in an array\\n    \\n    So now, in two passes of O(n) we have 2 profit arrays:\\n    \\n    profit1: [0,0,2,2,2,3,3,4]\\n    profit2: [4,4,4,4,4,3,3,0]\\n    \\n    So what\\'s our max profit? What kind of profit is even possible?\\n    Add the two? from the same day? or different days? \\n    \\n    What we want to pick is the number as deep as possible in profit1\\n    and as early as possible in profit2. Check that you follow why.\\n    \\n    We also know this: Any profit we pick from profit1, the number we then pick from profit 2 has to be _after_ that.\\n    \\n    At first I thought it would be profit1[i] + \\n    the max of (profit2[i+1], ..., profit2[n]) \\n    But since profit2 is always descending, you do want that number closest to i, \\n    which is i+1.\\n    \\n    So if we just loop over the array and sum profit1[i] + profit2[i+1], we will\\n    get the best profit. We just need to mind that we don\\'t get out of bounds\\n    for profit2\\'s index; For that we can just add a 0 to the profit2 array.\\n    \\n    That works for the sample input!\\n    \\n    Going to check discuss for some other inputs.\\n    Some people struggled with [1,2,4,2,5,7,2,4,9,0], but my code does well with it\\n    \\n    */\\n    \\n    // Step 1: get me that profit array for 1 buy and sell  \\n    \\n    var i, l;\\n    var Pmin = Infinity;\\n    var profit1 = [];\\n    var profitMax = 0;\\n    \\n    for (i = 0, l = prices.length; i < l; i++) {\\n        if (Pmin > prices[i]) {\\n            Pmin = prices[i];\\n        }\\n        \\n        profitMax = Math.max(profitMax, prices[i] - Pmin);\\n        profit1.push(profitMax);\\n    }\\n    \\n    // Step 2: do the same, but different (ha!) : we loop backwards and keep track of \\n    // pmax now. Note the unshift vs push above\\n    \\n    var Pmax = -Infinity;\\n    var profit2 = []; \\n    var profitMax2 = 0;\\n    \\n    for (i = prices.length - 1; i > -1; i--) {\\n        if (Pmax < prices[i]) {\\n            Pmax = prices[i];\\n        }\\n        \\n        profitMax2 = Math.max(profitMax2, Pmax - prices[i]);        \\n        profit2.unshift(profitMax2);\\n    }\\n    \\n    // little trick to help with out of bounds looping in step 3\\n    profit2.push(0);\\n    \\n    // verify our work\\n    // console.log(\\'profit1\\', profit1);\\n    // console.log(\\'profit2\\', profit2);\\n    \\n    // Step 3: loop over our profit arrays to find the max:    \\n    var totalProfit = 0;\\n    \\n    for (i = 0, l = profit1.length; i < l; i++) {\\n        totalProfit = Math.max(totalProfit, profit1[i] + profit2[i+1]);\\n    }\\n    \\n    return totalProfit;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} prices\\n * @return {number}\\n */\\nvar maxProfit = function(prices) {\\n    /* Wasn\\'t feeling a good solution out of my own, so went to discuss\\n    but that wasn\\'t triggering an \"aha\" moment. went to youtube, and this\\n    video seems ok: https://www.youtube.com/watch?v=0FKn0FSIQYE\\n    \\n    Tactic is first to understand how you\\'d do one transaction:\\n    Loop, keep track of \\n    A) the lowest number you\\'ve seen: Pmin\\n    B) the best sell you can make with the numbers after that: Profit\\n        - OR - the best profit you\\'ve seen so far\\n    \\n    For [3,3,5,0,0,3,1,4]\\n    you\\'ll end up with\\n    \\n    Input: [3,3,5,0,0,3,1,4]\\n    Pmin : [3,3,3,0,0,0,0,0] // again, simply the lowest hnumber\\n    Profit:[0,0,2,2,2,3,3,4] // (input - Pmin) OR the best profit you had so far\\n    \\n    That\\'s how we do it for 1 (see https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)\\n    \\n    ----------- you with me still? ------------\\n    \\n    Now instead of throwing that array we worked on away, we save that profit array.\\n    \\n    and then we do the same effort but backwards. Why? Because a 2nd buy and sell\\n    will come completely after the first buy and sell.\\n    \\n    Because it\\'s backwards, we now use Pmax instead of min. \\n    Read the following from the back to front\\n    \\n    Input: [3,3,5,0,0,3,1,4]\\n    Pmax : [5,5,5,4,4,4,4,4] // highest number from the back\\n    Profit:[4,4,4,4,4,3,3,0] // (Pmax - input) OR the best profit we\\'ve seen.\\n    \\n    Again, we store the profit in an array\\n    \\n    So now, in two passes of O(n) we have 2 profit arrays:\\n    \\n    profit1: [0,0,2,2,2,3,3,4]\\n    profit2: [4,4,4,4,4,3,3,0]\\n    \\n    So what\\'s our max profit? What kind of profit is even possible?\\n    Add the two? from the same day? or different days? \\n    \\n    What we want to pick is the number as deep as possible in profit1\\n    and as early as possible in profit2. Check that you follow why.\\n    \\n    We also know this: Any profit we pick from profit1, the number we then pick from profit 2 has to be _after_ that.\\n    \\n    At first I thought it would be profit1[i] + \\n    the max of (profit2[i+1], ..., profit2[n]) \\n    But since profit2 is always descending, you do want that number closest to i, \\n    which is i+1.\\n    \\n    So if we just loop over the array and sum profit1[i] + profit2[i+1], we will\\n    get the best profit. We just need to mind that we don\\'t get out of bounds\\n    for profit2\\'s index; For that we can just add a 0 to the profit2 array.\\n    \\n    That works for the sample input!\\n    \\n    Going to check discuss for some other inputs.\\n    Some people struggled with [1,2,4,2,5,7,2,4,9,0], but my code does well with it\\n    \\n    */\\n    \\n    // Step 1: get me that profit array for 1 buy and sell  \\n    \\n    var i, l;\\n    var Pmin = Infinity;\\n    var profit1 = [];\\n    var profitMax = 0;\\n    \\n    for (i = 0, l = prices.length; i < l; i++) {\\n        if (Pmin > prices[i]) {\\n            Pmin = prices[i];\\n        }\\n        \\n        profitMax = Math.max(profitMax, prices[i] - Pmin);\\n        profit1.push(profitMax);\\n    }\\n    \\n    // Step 2: do the same, but different (ha!) : we loop backwards and keep track of \\n    // pmax now. Note the unshift vs push above\\n    \\n    var Pmax = -Infinity;\\n    var profit2 = []; \\n    var profitMax2 = 0;\\n    \\n    for (i = prices.length - 1; i > -1; i--) {\\n        if (Pmax < prices[i]) {\\n            Pmax = prices[i];\\n        }\\n        \\n        profitMax2 = Math.max(profitMax2, Pmax - prices[i]);        \\n        profit2.unshift(profitMax2);\\n    }\\n    \\n    // little trick to help with out of bounds looping in step 3\\n    profit2.push(0);\\n    \\n    // verify our work\\n    // console.log(\\'profit1\\', profit1);\\n    // console.log(\\'profit2\\', profit2);\\n    \\n    // Step 3: loop over our profit arrays to find the max:    \\n    var totalProfit = 0;\\n    \\n    for (i = 0, l = profit1.length; i < l; i++) {\\n        totalProfit = Math.max(totalProfit, profit1[i] + profit2[i+1]);\\n    }\\n    \\n    return totalProfit;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 741658,
                "title": "java-clean-1-line-solution-o-n-time-and-o-1-space",
                "content": "No need for fancy DP stuffs. Just a few more lines added on question 121. The idea is to regard the second transaction as the result of the first transaction. The idea is a bit hard to come up with. Once figuring out the relationship between this qustion and question 121, this solution should be pretty easy to reach.\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices)  {\\n        int low1 = Integer.MAX_VALUE;\\n        int low2 = Integer.MAX_VALUE;\\n        int gap1 = 0;\\n        int gap2 = 0;\\n\\n        for (int price : prices) {\\n            low1 = Math.min(low1, price);\\n            gap1 = Math.max(gap1, price - low1);\\n            low2 = Math.min(low2, price - gap1);\\n            gap2 = Math.max(gap2, price - low2);\\n        }\\n\\n        return gap2;\\n    }\\n}\\n```\\n\\nPlease do upvote if you find my solution helpful!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices)  {\\n        int low1 = Integer.MAX_VALUE;\\n        int low2 = Integer.MAX_VALUE;\\n        int gap1 = 0;\\n        int gap2 = 0;\\n\\n        for (int price : prices) {\\n            low1 = Math.min(low1, price);\\n            gap1 = Math.max(gap1, price - low1);\\n            low2 = Math.min(low2, price - gap1);\\n            gap2 = Math.max(gap2, price - low2);\\n        }\\n\\n        return gap2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 723215,
                "title": "c-intuitive-recursive-solution-memoization-top-down-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    // state 0 -> can buy\\n    // state 1 -> can sell\\n    // count -> how many transactions till now 0/1/2\\n    vector<int>a;\\n    int n;\\n    int dp[100000][2][3] ;\\n    int f(int i , int state , int count) {\\n        if(i==n) {\\n            return 0;\\n        }\\n        if(count==2) {\\n            return 0;\\n        }\\n        int &ans = dp[i][state][count] ;\\n        if(ans!=-1){\\n            return ans ;\\n        }\\n        if(state ==  0) {\\n            int op1 = f(i+1 , 0 , count ) ;\\n            int op2 = f(i+1 , 1 , count ) - a[i] ;\\n            return ans =  max(op1,op2);\\n        }\\n        if(state == 1) {\\n            int op1 = f(i+1 , 1 , count) ;\\n            int op2 = a[i] + f(i+1 , 0 , count + 1 ) ;\\n            return ans =  max(op1,op2);\\n        }\\n        return  -1;\\n    }\\n    int maxProfit(vector<int>& a) {\\n        this->a=a;\\n        n=a.size();\\n        memset(dp,-1,sizeof dp);\\n        return f(0,0,0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // state 0 -> can buy\\n    // state 1 -> can sell\\n    // count -> how many transactions till now 0/1/2\\n    vector<int>a;\\n    int n;\\n    int dp[100000][2][3] ;\\n    int f(int i , int state , int count) {\\n        if(i==n) {\\n            return 0;\\n        }\\n        if(count==2) {\\n            return 0;\\n        }\\n        int &ans = dp[i][state][count] ;\\n        if(ans!=-1){\\n            return ans ;\\n        }\\n        if(state ==  0) {\\n            int op1 = f(i+1 , 0 , count ) ;\\n            int op2 = f(i+1 , 1 , count ) - a[i] ;\\n            return ans =  max(op1,op2);\\n        }\\n        if(state == 1) {\\n            int op1 = f(i+1 , 1 , count) ;\\n            int op2 = a[i] + f(i+1 , 0 , count + 1 ) ;\\n            return ans =  max(op1,op2);\\n        }\\n        return  -1;\\n    }\\n    int maxProfit(vector<int>& a) {\\n        this->a=a;\\n        n=a.size();\\n        memset(dp,-1,sizeof dp);\\n        return f(0,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 405165,
                "title": "python-method-dynamic-programming-keep-clean",
                "content": "Actually I try to explain in my own way. If you have better explanation, please feel free to leave comments.\\n```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        # dynamic programming\\n        fb, fs, sb, ss = float(\\'inf\\'), 0, float(\\'inf\\'), 0\\n        for price in prices:\\n            fb = min(fb, price)  # keep minimal\\n            fs = max(fs, price-fb)  # maximum if one transaction\\n            sb = min(sb, price-fs)  # total drop volume level\\n            ss = max(ss, price-sb)  # maximum if sum of two transactions\\n        return ss\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        # dynamic programming\\n        fb, fs, sb, ss = float(\\'inf\\'), 0, float(\\'inf\\'), 0\\n        for price in prices:\\n            fb = min(fb, price)  # keep minimal\\n            fs = max(fs, price-fb)  # maximum if one transaction\\n            sb = min(sb, price-fs)  # total drop volume level\\n            ss = max(ss, price-sb)  # maximum if sum of two transactions\\n        return ss\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39624,
                "title": "c-dp-solution-12ms-with-explanation-and-example",
                "content": "    class Solution {\\n    public:\\n     int maxProfit(vector<int>& prices) {\\n        if(prices.size()<=1) return 0;\\n        int *dpLeft = new int[prices.size()+1]; dpLeft[0] = 0;\\n        int tmp = prices[0];\\n        for(int i = 1; i<prices.size(); i++){\\n            tmp = min(tmp, prices[i]);\\n            dpLeft[i] = max(dpLeft[i-1], prices[i]-tmp);\\n        }\\n        int *dpRight = new int[prices.size()]; dpRight[prices.size()-1] = 0;\\n        tmp = prices[prices.size()-1];\\n        for(int i = prices.size()-2; i>=0; i--){\\n            tmp = max(tmp, prices[i]);\\n            dpRight[i] = max(dpRight[i+1], tmp-prices[i]);\\n        }\\n        tmp = 0;\\n        for(int i = 0; i<prices.size()-1; i++){\\n            tmp = max(tmp, dpLeft[i]+dpRight[i+1]);\\n        }\\n        tmp = max(tmp, dpLeft[prices.size()-1]);\\n        return tmp;\\n    }\\n    };\\n\\n\\n - We can combine DP solution and Divide And Conquer Solution here. I will explain this with a simple example.Assume the stock is: 5,4,6,3,4,2,1,6. It is easy to understand that the max profit is 2(6-4)+5(6-1)=7.\\n - here, I use two array to cache profit, dpLeft and dpRight.\\n - dpLeft: cache the profit from left to right, the stock [5,4,6,3,4,2,1,6] generate dpLeft:[0,0,2,2,2,2,2,5]\\n - dpRight: cache the profit from right to left,  stock [5,4,6,3,4,2,1,6] generate dpRight:[5,5,5,5,5,5,5,0]\\n - then, we use divide and conquer, the stock[5,4,6,3,4,2,1,6] , we compute profit from i = 0 to i = 7, and the maxProfit = max(maxProfit, dpLeft[i]+dpRight[i+1])\\n - finally, we finish this computation, the result is 7. the complexity is O(3n)=O(n)",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n     int maxProfit(vector<int>& prices) {\\n        if(prices.size()<=1) return 0;\\n        int *dpLeft = new int[prices.size()+1]; dpLeft[0] = 0;\\n        int tmp = prices[0];\\n        for(int i = 1; i<prices.size(); i++){\\n            tmp = min(tmp, prices[i]);\\n            dpLeft[i] = max(dpLeft[i-1], prices[i]-tmp);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2772186,
                "title": "c-solutions-easy-cpp",
                "content": "```\\nclass Solution {\\n    // recursion + memorization\\n     int solve(int index , int buy, vector<int>& prices,vector<vector<vector<int >>>& dp , int limit){\\n        if(index == prices.size()) return 0;\\n         \\n        if(limit == 0) return 0;\\n        \\n        int profit =0;\\n        if(dp[index][buy][limit] != -1) return dp[index][buy][limit] ;\\n        if(buy){\\n            int buyed = (-prices[index] + solve(index+1,0,prices,dp,limit));\\n            int skiped = (0 + solve(index+1 , 1 , prices,dp,limit));\\n            profit = max(buyed , skiped);\\n        }\\n        else{\\n            int selled = (prices[index] + solve(index+1 ,1, prices,dp,limit-1));\\n            int skiped = (0 + solve(index+1 ,0,prices,dp,limit));\\n            profit = max(selled , skiped);\\n        }\\n        return dp[index][buy][limit] = profit;\\n    }\\n    // tabulation or bottom up\\n    int solvetab(vector<int>& prices){\\n     int n = prices.size();   \\n     vector<vector<vector<int >>> dp( n+1, vector<vector<int >> (2, vector<int> (3,0)));\\n        for(int index = n-1; index>=0; index--){\\n            for(int buy = 0; buy<=1; buy++ ){\\n                for(int limit = 1; limit <=2; limit++){\\n                     int profit =0;\\n            if(buy){\\n            int buyed = -prices[index] + dp[index+1][0][limit];\\n            int skiped = 0 + dp[index+1][1][limit];\\n            profit = max(buyed , skiped);\\n        }\\n        else{\\n            int selled = prices[index] + dp[index+1][1][limit-1];\\n            int skiped = 0 + dp[index+1][0][limit];\\n            profit = max(selled , skiped);\\n        }\\n                dp[index][buy][limit] = profit;\\n                }\\n            }\\n        }\\n    return dp[0][1][2];\\n    }\\n    // tabulation + space optimization\\n    int solvetabpro(vector<int>& prices){\\n     int n = prices.size();   \\n     //vector<vector<vector<int >>> dp( n+1, vector<vector<int >> (2, vector<int> (3,0)));\\n      vector<vector<int>> curr(2,vector<int>(3,0));\\n      vector<vector<int>> next(2,vector<int>(3,0)); \\n        for(int index = n-1; index>=0; index--){\\n            for(int buy = 0; buy<=1; buy++ ){\\n                for(int limit = 1; limit <=2; limit++){\\n                     int profit =0;\\n            if(buy){\\n            int buyed = -prices[index] + next[0][limit];\\n            int skiped = 0 + next[1][limit];\\n            profit = max(buyed , skiped);\\n        }\\n        else{\\n            int selled = prices[index] + next[1][limit-1];\\n            int skiped = 0 + next[0][limit];\\n            profit = max(selled , skiped);\\n        }\\n                curr[buy][limit] = profit;\\n                }\\n            }\\n            next = curr;\\n        }\\n    return next[1][2];\\n    }\\n    \\n    \\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        return solvetabpro(prices);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    // recursion + memorization\\n     int solve(int index , int buy, vector<int>& prices,vector<vector<vector<int >>>& dp , int limit){\\n        if(index == prices.size()) return 0;\\n         \\n        if(limit == 0) return 0;\\n        \\n        int profit =0;\\n        if(dp[index][buy][limit] != -1) return dp[index][buy][limit] ;\\n        if(buy){\\n            int buyed = (-prices[index] + solve(index+1,0,prices,dp,limit));\\n            int skiped = (0 + solve(index+1 , 1 , prices,dp,limit));\\n            profit = max(buyed , skiped);\\n        }\\n        else{\\n            int selled = (prices[index] + solve(index+1 ,1, prices,dp,limit-1));\\n            int skiped = (0 + solve(index+1 ,0,prices,dp,limit));\\n            profit = max(selled , skiped);\\n        }\\n        return dp[index][buy][limit] = profit;\\n    }\\n    // tabulation or bottom up\\n    int solvetab(vector<int>& prices){\\n     int n = prices.size();   \\n     vector<vector<vector<int >>> dp( n+1, vector<vector<int >> (2, vector<int> (3,0)));\\n        for(int index = n-1; index>=0; index--){\\n            for(int buy = 0; buy<=1; buy++ ){\\n                for(int limit = 1; limit <=2; limit++){\\n                     int profit =0;\\n            if(buy){\\n            int buyed = -prices[index] + dp[index+1][0][limit];\\n            int skiped = 0 + dp[index+1][1][limit];\\n            profit = max(buyed , skiped);\\n        }\\n        else{\\n            int selled = prices[index] + dp[index+1][1][limit-1];\\n            int skiped = 0 + dp[index+1][0][limit];\\n            profit = max(selled , skiped);\\n        }\\n                dp[index][buy][limit] = profit;\\n                }\\n            }\\n        }\\n    return dp[0][1][2];\\n    }\\n    // tabulation + space optimization\\n    int solvetabpro(vector<int>& prices){\\n     int n = prices.size();   \\n     //vector<vector<vector<int >>> dp( n+1, vector<vector<int >> (2, vector<int> (3,0)));\\n      vector<vector<int>> curr(2,vector<int>(3,0));\\n      vector<vector<int>> next(2,vector<int>(3,0)); \\n        for(int index = n-1; index>=0; index--){\\n            for(int buy = 0; buy<=1; buy++ ){\\n                for(int limit = 1; limit <=2; limit++){\\n                     int profit =0;\\n            if(buy){\\n            int buyed = -prices[index] + next[0][limit];\\n            int skiped = 0 + next[1][limit];\\n            profit = max(buyed , skiped);\\n        }\\n        else{\\n            int selled = prices[index] + next[1][limit-1];\\n            int skiped = 0 + next[0][limit];\\n            profit = max(selled , skiped);\\n        }\\n                curr[buy][limit] = profit;\\n                }\\n            }\\n            next = curr;\\n        }\\n    return next[1][2];\\n    }\\n    \\n    \\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        return solvetabpro(prices);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846219,
                "title": "easy-c-time-o-n-and-space-o-1-explained",
                "content": "At every instant (or every element of array), one of the 4 events can happen. We can use the following 4 variables to denote these:\\n\\n* **firstBuy** to be the minimum between its current value and currPrice;\\n* **firstSell** to be the maximum between its current value and currPrice - firstBuy;\\n* **secondBuy** to be the minimum between its current value and currPrice - firstSell;\\n* **secondSell** to be the maximum between its current value and currPrice - secondBuy;\\n\\nMinimise the buying prices and maximise the profit at each and every stock price (for each element of array).\\n \\n```\\n int maxProfit(vector<int>& prices) {\\n \\n        int firstBuy=INT_MAX,firstSell=0,secondBuy=INT_MAX,secondSell=0;\\n\\t\\t\\n        for(int currPrice : prices)\\n        {\\n            firstBuy=min(firstBuy,currPrice);                    // minimum price for 1st buy\\n            firstSell=max(firstSell,currPrice-firstBuy);         // maximum profit after 1st sell\\n            secondBuy=min(secondBuy,currPrice-firstSell);        // minimum price for 2nd buy after removing profit from 1st sell\\n            secondSell=max(secondSell,currPrice-secondBuy);      // maximum profit after 2nd sell\\n           \\n        return secondSell;\\n        \\n    }\\n```\\n\\nTry a few mental/pen and paper examples, it will help you to understand better.\\n\\n\\nDo upvote, if it helped. :)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n int maxProfit(vector<int>& prices) {\\n \\n        int firstBuy=INT_MAX,firstSell=0,secondBuy=INT_MAX,secondSell=0;\\n\\t\\t\\n        for(int currPrice : prices)\\n        {\\n            firstBuy=min(firstBuy,currPrice);                    // minimum price for 1st buy\\n            firstSell=max(firstSell,currPrice-firstBuy);         // maximum profit after 1st sell\\n            secondBuy=min(secondBuy,currPrice-firstSell);        // minimum price for 2nd buy after removing profit from 1st sell\\n            secondSell=max(secondSell,currPrice-secondBuy);      // maximum profit after 2nd sell\\n           \\n        return secondSell;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 795424,
                "title": "c-simple-dp-w-detailed-explanations-o-n-time-o-1-space-faster-than-98",
                "content": "We are using dynamic-programming, as follows:\\nLet\\'s say we have a table of size 4*len(prices) (each row represents a transaction), we fill it in diagonals the following way:\\nIn each cell (i,j) we write: max(table[i,j-1] , table[i-1,j-1] +/- prices(i) ) (\\'-\\' for first and third rows, and \\'+\\' for second and fourth rows).\\nThe max of the last column will be our result.\\nBut, instead of using a full-sized table, we can just keep four variables and update them each iteration, which makes it O(1) space complexity!\\n(The \"if\"s in the loop are because we fill the table in diagonals, the index goes out of range.... so we have to check it)\\n\\n**Like it? please upvote...**\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        if (prices.size() < 2) return 0; // edge case of nothing to buy and sell\\n        if (prices.size() == 2) return max(0, prices[1] - prices[0]); // edge case of only two days\\n        int one = INT_MIN, two = 0, three = INT_MIN, four = 0, i = 0;\\n        while (i < prices.size())\\n        {\\n            one = max(one, -prices[i]);\\n            two = i>=prices.size()-1 ? two : max(two, one + prices[i+1]);\\n            three = i>=prices.size()-2 ? three : max(three, two - prices[i+2]);\\n            four = i>=prices.size()-3 ? four : max(four, three + prices[i+3]);\\n            i++;\\n        }\\n        return max(two, four);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        if (prices.size() < 2) return 0; // edge case of nothing to buy and sell\\n        if (prices.size() == 2) return max(0, prices[1] - prices[0]); // edge case of only two days\\n        int one = INT_MIN, two = 0, three = INT_MIN, four = 0, i = 0;\\n        while (i < prices.size())\\n        {\\n            one = max(one, -prices[i]);\\n            two = i>=prices.size()-1 ? two : max(two, one + prices[i+1]);\\n            three = i>=prices.size()-2 ? three : max(three, two - prices[i+2]);\\n            four = i>=prices.size()-3 ? four : max(four, three + prices[i+3]);\\n            i++;\\n        }\\n        return max(two, four);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 432710,
                "title": "easy-to-understand-variable-names-and-comment-java-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int buyOne = Integer.MAX_VALUE;\\n\\t\\tint ProfitOne = 0;               // Profit gained after selling 1st share.\\n        int buyTwo = Integer.MAX_VALUE;\\n        int ProfitTwo = 0;               // Profit gained after selling 2nd share.\\n        for(int p : prices) {\\n            buyOne = Math.min(buyOne, p);\\n            ProfitOne = Math.max(ProfitOne, p - buyOne);\\n            buyTwo = Math.min(buyTwo, p - ProfitOne);     // If I made $100 profit in 1st trans\\'. Then the 2nd Stock(maybe $300) I buy is actually $300 - $100 = $200 for me. \\n            ProfitTwo = Math.max(ProfitTwo, p - buyTwo);   // And finally The maximum profit I make with the 2nd trans\\' is my actuall profit with 2 transaction. \\n        }\\n        return ProfitTwo;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int buyOne = Integer.MAX_VALUE;\\n\\t\\tint ProfitOne = 0;               // Profit gained after selling 1st share.\\n        int buyTwo = Integer.MAX_VALUE;\\n        int ProfitTwo = 0;               // Profit gained after selling 2nd share.\\n        for(int p : prices) {\\n            buyOne = Math.min(buyOne, p);\\n            ProfitOne = Math.max(ProfitOne, p - buyOne);\\n            buyTwo = Math.min(buyTwo, p - ProfitOne);     // If I made $100 profit in 1st trans\\'. Then the 2nd Stock(maybe $300) I buy is actually $300 - $100 = $200 for me. \\n            ProfitTwo = Math.max(ProfitTwo, p - buyTwo);   // And finally The maximum profit I make with the 2nd trans\\' is my actuall profit with 2 transaction. \\n        }\\n        return ProfitTwo;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 328262,
                "title": "simple-python",
                "content": "O(n) time, O(1) space\\n```\\n    def maxProfit(self, prices: List[int]) -> int:\\n        one_buy = two_buy =   sys.maxsize\\n        one_profit = two_profit = 0\\n        for p in prices:\\n            one_buy = min(one_buy,p)\\n            one_profit = max(one_profit,p - one_buy)\\n            two_buy = min(two_buy,p - one_profit)\\n            two_profit = max(two_profit,p - two_buy)\\n        return two_profit\\n```",
                "solutionTags": [],
                "code": "```\\n    def maxProfit(self, prices: List[int]) -> int:\\n        one_buy = two_buy =   sys.maxsize\\n        one_profit = two_profit = 0\\n        for p in prices:\\n            one_buy = min(one_buy,p)\\n            one_profit = max(one_profit,p - one_buy)\\n            two_buy = min(two_buy,p - one_profit)\\n            two_profit = max(two_profit,p - two_buy)\\n        return two_profit\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 111150,
                "title": "how-to-achieve-best-solution-with-o-n-o-1-step-by-step",
                "content": "The highest vote with O(n) time and O(1) space is no doubt best but it's hard to think of this solution at the first time. I was inspired by the dp solution given kth transaction, and improve the code step by step until achieving the best solution.\\n### 1. the most straightforward solution\\nFollowing the logic of <a href = https://leetcode.com/problems/best-time-to-buy-and-sell-stock/description/>Best Time to Buy and Sell Stock</a>, we can easily construct an array that stores the maximum profit at day i, oneProfit[]. oneProfit[0] == 0 because we can make no profit on day 1. At day i, we have two choices,  either do nothing, in which case profit should be the same as the previous day(oneProfit(i - 1)), or we can sell the stock. If we choose to sell the stock at day i, it means we must have bought the stock any day prior to day i. The question is, on which day should we buy stock that we can make the most money selling it on day i? The answer is simple, buy it on the day with lowest price. So we keep tracking minimum price before selling day(prices[i] - minSoFar). oneProfit[i] = oneProfit[i] = Math.max(oneProfit[i - 1], prices[i] - minSoFar); We also need to update minimum price up to day i. \\nWhen it comes to two transaction, the logic is similar. We use an array that stores the maximum profit at day i given at most two transactions are allowed up to this day, twoProfit[]. twoProfit[0] == 0 because we can make no profit on day 1. Similarly, we have two choices on day i, either do nothing, then the maximum profit on day i would be the same as maximum profit on day i -1. Or we can sell it on day i. If so, we need to find the day when we bought this stock. This day can be any day from the first day to the day before day i. Suppose we buy it on day j, it leaves us only one chance to transact up to day j, so the maximum we can make by buying on day j and selling on day i should be prices[i] - prices[j] + oneProfit[j]. We find the day before day i on which we buy the stock that we can make the most profit by iterating through day 0 to day i - 1.  twoProfit[i] = max(profit made doing nothing, profit made selling today);\\n\\n```java\\npublic int maxProfit(int[] prices) {\\n        if(prices == null || prices.length == 0) return 0;\\n        int length = prices.length;\\n        int[] oneProfit = new int[length];\\n   \\n        //minimum value from 0 to i(included)\\n        int minSoFar = prices[0];\\n        for(int i = 1; i < length; i++){\\n            oneProfit[i] = Math.max(oneProfit[i - 1], prices[i] - minSoFar);\\n            minSoFar = Math.min(minSoFar, prices[i]);\\n        }\\n        \\n        int[] twoProfit = new int[length];\\n        \\n        for(int i = 1; i < length; i++){\\n            int max = twoProfit[i - 1];\\n            for(int j = 0; j < i; j++){\\n                max = Math.max(max, prices[i] - prices[j] + oneProfit[j]);\\n            }\\n            twoProfit[i] = max;\\n        }\\n        return twoProfit[length - 1];\\n       \\n    }\\n```\\n### 2. Improve time complexity from O(n^2) to O(n)\\nThe time complexity of previous solution is O(n^2) because it checks all days before day i when constructing twoProfit. But it can be reduced to O(n). We need maximum value of prices[i] - prices[j] + oneProfit[j] for each j before i. It's equivalent to prices[i] - (prices[j] - oneProfit[j]), prices[i] is the same, so what we need is actually the minimum value of prices[j] - oneProfit[j]) (j = 0... i -1). Instead of repeatedly calculating prices[j] - oneProfit[j]), we can use a variable to store the minimum value before the day(just like we use minsofar to store the minimum value of the price before day i).\\n\\n```java\\npublic int maxProfit(int[] prices) {\\n        \\n        if(prices == null || prices.length == 0) return 0;\\n        int length = prices.length;\\n        int[] oneProfit = new int[length];\\n       \\n        //min from 0 to i(included)\\n        int minSoFar = prices[0];\\n        for(int i = 1; i < length; i++){\\n            oneProfit[i] = Math.max(oneProfit[i - 1], prices[i] - minSoFar);\\n            minSoFar = Math.min(minSoFar, prices[i]);\\n        }\\n        \\n        int[] twoProfit = new int[length];\\n        \\n        int mindiff = prices[0];\\n        \\n        for(int i = 1; i < length; i++){\\n            twoProfit[i] = Math.max(twoProfit[i - 1], prices[i] - mindiff);\\n            mindiff = Math.min(mindiff, prices[i] - oneProfit[i]);\\n            \\n        }\\n        \\n        return twoProfit[length - 1];\\n }\\n```\\n### 3. reduce space complexity from O(n) to O(1);\\n\\nWhen we examine oneProfit[i] and twoProfit[i], we actually only care about oneProfit[i - 1], twoProfit[i - 1], minimum price so far and minimum value of difference between prices[i] and oneProfit[i]. So after move to next day, we can get rid off all values except the day before the day to be visited. \\n\\n```java\\npublic int maxProfit(int[] prices) {\\n        \\n        if(prices == null || prices.length == 0) return 0;\\n        int length = prices.length;\\n       \\n        //min from 0 to i(included)\\n        int minSoFar = prices[0];\\n        \\n        //min value of(prices[i] - oneProfit) from 0 to i(included)\\n        int mindiff = prices[0];\\n        \\n        //max profit at day i if at most one transaction is allowed up to the day\\n        int oneProfit = 0;\\n        \\n        //max profit at day i if at most two transaction is allowed up to the day\\n        int twoProfit = 0;\\n        for(int i = 1; i < length; i++){\\n            oneProfit = Math.max(oneProfit, prices[i] - minSoFar);\\n            minSoFar = Math.min(minSoFar, prices[i]);\\n            twoProfit = Math.max(twoProfit, prices[i] - mindiff);\\n            mindiff = Math.min(mindiff, prices[i] - oneProfit);\\n        }\\n             \\n        return twoProfit;\\n}\\n```\\n\\nHere is a great link on Youtube on this problem. https://www.youtube.com/watch?v=oDhu5uGq_ic.",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```java\\npublic int maxProfit(int[] prices) {\\n        if(prices == null || prices.length == 0) return 0;\\n        int length = prices.length;\\n        int[] oneProfit = new int[length];\\n   \\n        //minimum value from 0 to i(included)\\n        int minSoFar = prices[0];\\n        for(int i = 1; i < length; i++){\\n            oneProfit[i] = Math.max(oneProfit[i - 1], prices[i] - minSoFar);\\n            minSoFar = Math.min(minSoFar, prices[i]);\\n        }\\n        \\n        int[] twoProfit = new int[length];\\n        \\n        for(int i = 1; i < length; i++){\\n            int max = twoProfit[i - 1];\\n            for(int j = 0; j < i; j++){\\n                max = Math.max(max, prices[i] - prices[j] + oneProfit[j]);\\n            }\\n            twoProfit[i] = max;\\n        }\\n        return twoProfit[length - 1];\\n       \\n    }\\n```\n```java\\npublic int maxProfit(int[] prices) {\\n        \\n        if(prices == null || prices.length == 0) return 0;\\n        int length = prices.length;\\n        int[] oneProfit = new int[length];\\n       \\n        //min from 0 to i(included)\\n        int minSoFar = prices[0];\\n        for(int i = 1; i < length; i++){\\n            oneProfit[i] = Math.max(oneProfit[i - 1], prices[i] - minSoFar);\\n            minSoFar = Math.min(minSoFar, prices[i]);\\n        }\\n        \\n        int[] twoProfit = new int[length];\\n        \\n        int mindiff = prices[0];\\n        \\n        for(int i = 1; i < length; i++){\\n            twoProfit[i] = Math.max(twoProfit[i - 1], prices[i] - mindiff);\\n            mindiff = Math.min(mindiff, prices[i] - oneProfit[i]);\\n            \\n        }\\n        \\n        return twoProfit[length - 1];\\n }\\n```\n```java\\npublic int maxProfit(int[] prices) {\\n        \\n        if(prices == null || prices.length == 0) return 0;\\n        int length = prices.length;\\n       \\n        //min from 0 to i(included)\\n        int minSoFar = prices[0];\\n        \\n        //min value of(prices[i] - oneProfit) from 0 to i(included)\\n        int mindiff = prices[0];\\n        \\n        //max profit at day i if at most one transaction is allowed up to the day\\n        int oneProfit = 0;\\n        \\n        //max profit at day i if at most two transaction is allowed up to the day\\n        int twoProfit = 0;\\n        for(int i = 1; i < length; i++){\\n            oneProfit = Math.max(oneProfit, prices[i] - minSoFar);\\n            minSoFar = Math.min(minSoFar, prices[i]);\\n            twoProfit = Math.max(twoProfit, prices[i] - mindiff);\\n            mindiff = Math.min(mindiff, prices[i] - oneProfit);\\n        }\\n             \\n        return twoProfit;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 39625,
                "title": "7-liner-in-python-beats-99",
                "content": "```\\nclass Solution(object):\\n    def maxProfit(self, p):\\n        if not p: return 0\\n        sell, buyd, n, minp, maxp = [0], [0], len(p), p[0], p[-1]\\n        for i in range(1, n):\\n            minp, maxp = min(minp, p[i]), max(maxp, p[n-i-1])\\n            sell.append(max(sell[i-1], p[i] - minp))\\n            buyd.append(max(buyd[i-1], maxp - p[n-i-1]))\\n        return max(sell[i] + buyd[n-i-1] for i in range(n))\\n\\n\\n# 198 / 198 test cases passed.\\n# Status: Accepted\\n# Runtime: 56 ms\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxProfit(self, p):\\n        if not p: return 0\\n        sell, buyd, n, minp, maxp = [0], [0], len(p), p[0], p[-1]\\n        for i in range(1, n):\\n            minp, maxp = min(minp, p[i]), max(maxp, p[n-i-1])\\n            sell.append(max(sell[i-1], p[i] - minp))\\n            buyd.append(max(buyd[i-1], maxp - p[n-i-1]))\\n        return max(sell[i] + buyd[n-i-1] for i in range(n))\\n\\n\\n# 198 / 198 test cases passed.\\n# Status: Accepted\\n# Runtime: 56 ms\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39705,
                "title": "java-solution-dynamic-programming-method-with-explanation",
                "content": "The idea is based on the solution of \"Best Time to Buy and Sell Stock I\" problem and dynamic programming. \\n\\n1. We need to solve the \"Best Time to Buy and Sell Stock I\" problem twice from each end. (Actually, you can merge them to one pass) \\n2. DP requires that the intermediate max profit of two transactions been stored in two arrays: one[] and two[]. \\n3. Return value is the max sum of one[i] + two[i].\\n\\n> \\n\\n    public int maxProfit(int[] P) {\\n        if(P.length<2) return 0;\\n        \\n        // First, solve the \"Best Time to Buy and Sell Stock I\" problem from left end;\\n        int[] one = new int[P.length]; // DP: store the max profit for the 1st transaction;\\n        int minP = P[0];\\n        for(int i=1; i<P.length; i++) {\\n            if(P[i]<minP) { minP = P[i]; }\\n            one[i] = Math.max(one[i-1], P[i]-minP);\\n        }\\n        \\n        // Second, solve the \"Best Time to Buy and Sell Stock I\" problem from right end;\\n        int[] two = new int[P.length]; // DP: store the max profit for the 2nd transaction;\\n        int maxP = P[P.length-1];\\n        for(int i=P.length-2; i>=0; i--) {\\n            if(P[i]>maxP) { maxP = P[i]; }\\n            two[i] = Math.max(two[i+1], maxP-P[i]);\\n        }\\n        \\n        // Third, get the max one[i]+two[i] value;\\n        int result = Integer.MIN_VALUE;\\n        for(int i=0; i<P.length; i++) {\\n            result = Math.max(result, one[i]+two[i]);\\n        }\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "The idea is based on the solution of \"Best Time to Buy and Sell Stock I\" problem and dynamic programming. \\n\\n1. We need to solve the \"Best Time to Buy and Sell Stock I\" problem twice from each end. (Actually, you can merge them to one pass) \\n2. DP requires that the intermediate max profit of two transactions been stored in two arrays: one[] and two[]. \\n3. Return value is the max sum of one[i] + two[i].\\n\\n> \\n\\n    public int maxProfit(int[] P) {\\n        if(P.length<2) return 0;\\n        \\n        // First, solve the \"Best Time to Buy and Sell Stock I\" problem from left end;\\n        int[] one = new int[P.length]; // DP: store the max profit for the 1st transaction;\\n        int minP = P[0];\\n        for(int i=1; i<P.length; i++) {\\n            if(P[i]<minP) { minP = P[i]; }\\n            one[i] = Math.max(one[i-1], P[i]-minP);\\n        }\\n        \\n        // Second, solve the \"Best Time to Buy and Sell Stock I\" problem from right end;\\n        int[] two = new int[P.length]; // DP: store the max profit for the 2nd transaction;\\n        int maxP = P[P.length-1];\\n        for(int i=P.length-2; i>=0; i--) {\\n            if(P[i]>maxP) { maxP = P[i]; }\\n            two[i] = Math.max(two[i+1], maxP-P[i]);\\n        }\\n        \\n        // Third, get the max one[i]+two[i] value;\\n        int result = Integer.MIN_VALUE;\\n        for(int i=0; i<P.length; i++) {\\n            result = Math.max(result, one[i]+two[i]);\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3717410,
                "title": "superb-dynamic-logic",
                "content": "# Dynamic programming\\n```\\nclass Solution:\\n    def maxProfit(self, A: List[int]) -> int:\\n        N=len(A)\\n        sell=[0]*N\\n        for _ in range(2):\\n            buy=-A[0]\\n            profit=0\\n            for i in range(1,N):\\n                buy=max(buy,sell[i]-A[i])\\n                profit=max(profit,A[i]+buy)\\n                sell[i]=profit\\n        return sell[-1]\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, A: List[int]) -> int:\\n        N=len(A)\\n        sell=[0]*N\\n        for _ in range(2):\\n            buy=-A[0]\\n            profit=0\\n            for i in range(1,N):\\n                buy=max(buy,sell[i]-A[i])\\n                profit=max(profit,A[i]+buy)\\n                sell[i]=profit\\n        return sell[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1488579,
                "title": "c-o-n-time-o-1-space-detailed-explanation",
                "content": "At every instant (or index i of the array), one of the 4 events can happen. We can use the following 4 variables to denote these:\\n\\n1) firstBuy = price of 1st buy\\n2) secondBuy = price of 2nd buy\\n\\n3) firstProfit = Profit after selling the first share\\n4) secondProfit = profit after selling the second share\\n\\nClearly we want to minimise the buying prices and maximise the profit at each and every price instant (for each element of array)\\n\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxProfit(vector<int>& prices) {\\n\\t\\t\\tint firstBuy = INT_MAX;\\n\\t\\t\\tint secondBuy = INT_MAX;\\n\\n\\t\\t\\tint firstProfit = INT_MIN;\\n\\t\\t\\tint secondProfit = INT_MIN;\\n\\n\\t\\t\\tfor(int i=0;i<prices.size();i++){\\n\\t\\t\\t\\t// Minimize the first buy price\\n\\t\\t\\t\\tfirstBuy = min(firstBuy, prices[i]);\\n\\t\\t\\t\\t// Maximise the profit when we sell at prices[i]. (Selling price - buying price = profit)\\n\\t\\t\\t\\tfirstProfit = max(firstProfit, prices[i]-firstBuy);\\n\\t\\t\\t\\t// Now minimize the second buy price to see if buying at prices[i] price is minimum.\\n\\t\\t\\t\\t// prices[i]-firstProfit is the net expense in buying it.\\n\\t\\t\\t\\tsecondBuy = min(secondBuy, prices[i]-firstProfit);\\n\\t\\t\\t\\t// Now maximise the final profit after selling both shares.\\n\\t\\t\\t\\tsecondProfit = max(secondProfit, prices[i]-secondBuy);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn secondProfit;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint maxProfit(vector<int>& prices) {\\n\\t\\t\\tint firstBuy = INT_MAX;\\n\\t\\t\\tint secondBuy = INT_MAX;\\n\\n\\t\\t\\tint firstProfit = INT_MIN;\\n\\t\\t\\tint secondProfit = INT_MIN;\\n\\n\\t\\t\\tfor(int i=0;i<prices.size();i++){\\n\\t\\t\\t\\t// Minimize the first buy price\\n\\t\\t\\t\\tfirstBuy = min(firstBuy, prices[i]);\\n\\t\\t\\t\\t// Maximise the profit when we sell at prices[i]. (Selling price - buying price = profit)\\n\\t\\t\\t\\tfirstProfit = max(firstProfit, prices[i]-firstBuy);\\n\\t\\t\\t\\t// Now minimize the second buy price to see if buying at prices[i] price is minimum.\\n\\t\\t\\t\\t// prices[i]-firstProfit is the net expense in buying it.\\n\\t\\t\\t\\tsecondBuy = min(secondBuy, prices[i]-firstProfit);\\n\\t\\t\\t\\t// Now maximise the final profit after selling both shares.\\n\\t\\t\\t\\tsecondProfit = max(secondProfit, prices[i]-secondBuy);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 794872,
                "title": "python-dynamic-programming-detailed-explanations-simple-and-short-o-n-time-o-1-space",
                "content": "We are using dynamic-programming, as follows:\\nLet\\'s say we have a table of size 4*len(prices) (each row represents a transaction), we fill it in diagonals the following way:\\nIn each cell (i,j) we write: max(table[i,j-1] , table[i-1,j-1] +/- prices(i) ) (\\'-\\' for first and third rows, and \\'+\\' for second and fourth rows).\\nThe max of the last column will be our result.\\nBut, instead of using a full-sized table, we can just keep four variables and update them each iteration, which makes it O(1) space complexity!\\n(The \"if\"s in the loop are because we fill the table in diagonals, the index goes out of range.... so we have to check it)\\n\\n**Like it? please upvote...**\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        # edge case of nothing to buy and sell\\n        if len(prices) < 2:\\n            return 0\\n        # edge case of only two days\\n        if len(prices) == 2:\\n            return max(0, prices[1] - prices[0])\\n        \\n        one = -sys.maxsize-1\\n        two = 0\\n        three = -sys.maxsize-1\\n        four = 0\\n        i = 0\\n        while i < len(prices):\\n            one = max(one, -prices[i])\\n            two = two if i>=len(prices)-1 else max(two, one + prices[i+1])\\n            three = three if i>=len(prices)-2 else max(three, two - prices[i+2])\\n            four = four if i>=len(prices)-3 else max(four, three + prices[i+3])\\n            i+=1\\n        \\n        return max(two, four)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        # edge case of nothing to buy and sell\\n        if len(prices) < 2:\\n            return 0\\n        # edge case of only two days\\n        if len(prices) == 2:\\n            return max(0, prices[1] - prices[0])\\n        \\n        one = -sys.maxsize-1\\n        two = 0\\n        three = -sys.maxsize-1\\n        four = 0\\n        i = 0\\n        while i < len(prices):\\n            one = max(one, -prices[i])\\n            two = two if i>=len(prices)-1 else max(two, one + prices[i+1])\\n            three = three if i>=len(prices)-2 else max(three, two - prices[i+2])\\n            four = four if i>=len(prices)-3 else max(four, three + prices[i+3])\\n            i+=1\\n        \\n        return max(two, four)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 466862,
                "title": "python-dp-o-n-o-1-with-explanation-in-detail",
                "content": "```\\n\\'\\'\\'\\nDP\\nThere are 5 states: before 1st buy -> after 1st buy -> after 1st sell -> after 2nd buy -> after 2nd sell\\n                    Not Hold stock ->  Hold stock   -> Not Hold stock ->   Hold stock  -> Not Hold stock\\n                          NH0      ->      H0       ->     NH1        ->      H1       ->     NH2\\nUses NH0[i], H0[i], NH1[i], H1[i] and NH2[i] to denote the max profit for these 5 states at day i\\nReturn max (NH0[i], NH1[i], NH2[i]) with i = len(prices)-1\\n\\nInput [3,3,5,0,0,3,1,4]\\nidx  0  1  2  3  4  5  6  7\\np    3  3  5  0  0  3  1  4\\nNH0  0  0  0  0  0  0  0  0\\nH0  -3 -3 -3  0  0  0  0  0\\nNH1  *  0  2  2  2  3  3  4\\nH1   *  * -5  2  2  2  2  2\\nNH2  *  *  * -5  2  5  5  6\\n\\nNH0[i] is always 0\\nH0[i] is max(  0     -price[i], H0[i-1])\\nNH1[i] is max(H0[i-1]+price[i], NH1[i-1])\\nH1[i] is max(NH1[i-1]-price[i], H1[i-1])\\nNH2[i] is max(H1[i-1]+price[i], NH2[i-1])\\n* is invalid state, which is set to -infinity\\nSince every state at i only depends on states at i-1, using cur_xxx and pre_xxx is enough.\\n\\nIterate from 0 to len(prices)-1. At day i, calculate H0, NH1, H1 and NH2 with price[i] and pre_H0, pre_NH1, pre_H1 and pre_NH2\\nTime: O(n)\\nSpace: O(1)\\n\\'\\'\\'\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if not prices or len(prices) < 2:\\n            return 0\\n        \\n        pre_H0 = pre_NH1 = pre_H1 = pre_NH2 = -float(\\'inf\\')\\n        for p in prices:\\n            cur_H0 = max(-p, pre_H0)\\n            cur_NH1 = max(pre_H0 + p, pre_NH1)\\n            cur_H1 = max(pre_NH1 - p, pre_H1) \\n            cur_NH2 = max(pre_H1 + p, pre_NH2)\\n            pre_H0 = cur_H0\\n            pre_NH1 = cur_NH1\\n            pre_H1 = cur_H1\\n            pre_NH2 = cur_NH2\\n            # You may use one line below to do all the work above :)\\n\\t\\t\\t# pre_H0, pre_NH1, pre_H1, pre_NH2 = max(-p, pre_H0), max(pre_H0 + p, pre_NH1), max(pre_NH1 - p, pre_H1), max(pre_H1 + p, pre_NH2)\\n        return max(0, pre_NH1, pre_NH2)\\n```\\nDiscuss for similar problems:\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/discuss/466862/Python-DP-O(n)-O(1)-with-explanation-in-detail\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/discuss/467030/Python-DP-with-detailed-explanation\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/discuss/466271/Python-DP-beat-99-with-detail-explanation\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/467507/Short-Python-DP-O(n)-O(1)-with-explanation",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n\\'\\'\\'\\nDP\\nThere are 5 states: before 1st buy -> after 1st buy -> after 1st sell -> after 2nd buy -> after 2nd sell\\n                    Not Hold stock ->  Hold stock   -> Not Hold stock ->   Hold stock  -> Not Hold stock\\n                          NH0      ->      H0       ->     NH1        ->      H1       ->     NH2\\nUses NH0[i], H0[i], NH1[i], H1[i] and NH2[i] to denote the max profit for these 5 states at day i\\nReturn max (NH0[i], NH1[i], NH2[i]) with i = len(prices)-1\\n\\nInput [3,3,5,0,0,3,1,4]\\nidx  0  1  2  3  4  5  6  7\\np    3  3  5  0  0  3  1  4\\nNH0  0  0  0  0  0  0  0  0\\nH0  -3 -3 -3  0  0  0  0  0\\nNH1  *  0  2  2  2  3  3  4\\nH1   *  * -5  2  2  2  2  2\\nNH2  *  *  * -5  2  5  5  6\\n\\nNH0[i] is always 0\\nH0[i] is max(  0     -price[i], H0[i-1])\\nNH1[i] is max(H0[i-1]+price[i], NH1[i-1])\\nH1[i] is max(NH1[i-1]-price[i], H1[i-1])\\nNH2[i] is max(H1[i-1]+price[i], NH2[i-1])\\n* is invalid state, which is set to -infinity\\nSince every state at i only depends on states at i-1, using cur_xxx and pre_xxx is enough.\\n\\nIterate from 0 to len(prices)-1. At day i, calculate H0, NH1, H1 and NH2 with price[i] and pre_H0, pre_NH1, pre_H1 and pre_NH2\\nTime: O(n)\\nSpace: O(1)\\n\\'\\'\\'\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if not prices or len(prices) < 2:\\n            return 0\\n        \\n        pre_H0 = pre_NH1 = pre_H1 = pre_NH2 = -float(\\'inf\\')\\n        for p in prices:\\n            cur_H0 = max(-p, pre_H0)\\n            cur_NH1 = max(pre_H0 + p, pre_NH1)\\n            cur_H1 = max(pre_NH1 - p, pre_H1) \\n            cur_NH2 = max(pre_H1 + p, pre_NH2)\\n            pre_H0 = cur_H0\\n            pre_NH1 = cur_NH1\\n            pre_H1 = cur_H1\\n            pre_NH2 = cur_NH2\\n            # You may use one line below to do all the work above :)\\n\\t\\t\\t# pre_H0, pre_NH1, pre_H1, pre_NH2 = max(-p, pre_H0), max(pre_H0 + p, pre_NH1), max(pre_NH1 - p, pre_H1), max(pre_H1 + p, pre_NH2)\\n        return max(0, pre_NH1, pre_NH2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 435022,
                "title": "java-simple-solution-99-8-time-100-space",
                "content": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if (prices == null || prices.length == 0)\\n            return 0;\\n        int n = prices.length;\\n\\t\\t\\n\\t\\t/* we compute the max possible single transaction value b/w 0th and the \\'i\\'th day moving from left to right \\'ltor\\'*/\\n        int[] ltor = new int[n];\\n        int min = prices[0];\\n        for (int i = 1; i < n; i++) {\\n            ltor[i] = Math.max(prices[i] - min, ltor[i - 1]);\\n            if (prices[i] <= min)\\n                min = prices[i];\\n        }\\n        \\n\\t\\t/* we compute the max possible single transaction value b/w \\'i\\'th and the last day  moving from right to left \\'rtol\\'*/\\n        int[] rtol = new int[n];\\n        int max = prices[n - 1];\\n        for (int i = n - 2; i >= 0; i--) {\\n            rtol[i] = Math.max(max - prices[i], rtol[i + 1]);\\n            if (prices[i] >= max)\\n                max = prices[i];\\n        }\\n        \\n\\t\\t/* Now we just need to find the max possible sum for 0th till \\'i\\'th transaction and the \\'i + 1\\'th till \\'n\\'th transaction */\\n        int ans = 0;\\n        for (int i = 1; i <= n - 2; i++) {\\n            int sum = ltor[i] + rtol[i+1];\\n            if (ans < sum)\\n                ans = sum;\\n        }\\n        \\n        /* Since a single transaction could be more than sum of 2 transaction, we could look at either the last element of ltoi or\\n        first element of rtol to make sure that is not more than 2 transaction. Those are essentially the max possible value we\\n        can get from a single transaction */\\n        return Math.max(ans, rtol[0]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if (prices == null || prices.length == 0)\\n            return 0;\\n        int n = prices.length;\\n\\t\\t\\n\\t\\t/* we compute the max possible single transaction value b/w 0th and the \\'i\\'th day moving from left to right \\'ltor\\'*/\\n        int[] ltor = new int[n];\\n        int min = prices[0];\\n        for (int i = 1; i < n; i++) {\\n            ltor[i] = Math.max(prices[i] - min, ltor[i - 1]);\\n            if (prices[i] <= min)\\n                min = prices[i];\\n        }\\n        \\n\\t\\t/* we compute the max possible single transaction value b/w \\'i\\'th and the last day  moving from right to left \\'rtol\\'*/\\n        int[] rtol = new int[n];\\n        int max = prices[n - 1];\\n        for (int i = n - 2; i >= 0; i--) {\\n            rtol[i] = Math.max(max - prices[i], rtol[i + 1]);\\n            if (prices[i] >= max)\\n                max = prices[i];\\n        }\\n        \\n\\t\\t/* Now we just need to find the max possible sum for 0th till \\'i\\'th transaction and the \\'i + 1\\'th till \\'n\\'th transaction */\\n        int ans = 0;\\n        for (int i = 1; i <= n - 2; i++) {\\n            int sum = ltor[i] + rtol[i+1];\\n            if (ans < sum)\\n                ans = sum;\\n        }\\n        \\n        /* Since a single transaction could be more than sum of 2 transaction, we could look at either the last element of ltoi or\\n        first element of rtol to make sure that is not more than 2 transaction. Those are essentially the max possible value we\\n        can get from a single transaction */\\n        return Math.max(ans, rtol[0]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 321626,
                "title": "c-fastest-99-beat-o-n-linear-solution-radically-awesome-programming",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        \\n        if (prices.size() <= 1) { return 0; }\\n        \\n        int aBuy1 = prices[0];\\n        int aSell1 = 0;\\n        int aBuy2 = prices[0];\\n        int aSell2 = 0;\\n        \\n        for (int i=1;i<prices.size();i++) {\\n            aBuy1 = min(aBuy1, prices[i]);\\n            aSell1 = max(aSell1, prices[i] - aBuy1);\\n            aBuy2 = min(aBuy2, prices[i] - aSell1);\\n            aSell2 = max(aSell2, prices[i] - aBuy2);\\n        }\\n        \\n        return aSell2;\\n    }\\n};\\n```\\n\\nBuy is the minimum price you can \"buy\" at, which may me negative for #2. Sell is the $ you can make...\\n\\n\\nDraw it out on paper.\\n\\n\\n\\nArr:\\n[2, 2, 1, 4, 5, 3, 2, 4, 3, 6, 5, 2]\\n\\nBuy1 is easy, this is just the minimum value we have encountered so far.\\n\\nBuy1:\\n[2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\\n\\nSell1 is easy, this is the maximum value we have encountered so far minus the minimum value we have encountered so far.\\n\\nSell1:\\n[0, 0, 0, 3, 4, 4, 4, 4, 4, 5, 5, 5]\\n\\nBuy2 is the theoretical minimum value we have, factoring out the first transaction. This way we \"add\" the first transaction into sell2, however, the amount we \"add\" is trimmed based on our theoretical floor.\\n\\nBuy2:  [2, 2,1, 1, 1, -1, -2, -2, -2, -2, -2, -3]\\nArr:     [2, 2, 1, 4, 5,  3,  2,   4,  3,   6,   5,   2]\\n\\n(You\\'ll see that Buy2 first goes below Buy1 when the price list has climbed, and then dropped for the first time.\\n\\nSell2 is computed the same as Sell1, except we use Buy2 as the \"minimum\" we have encountered so far.\\n\\nSell2:  [0, 0, 0, 3, 4,  4,  4,   6,  6,   8,   8,   8]\\nArr:     [2, 2, 1, 4, 5,  3,  2,   4,  3,   6,   5,   2]\\n\\n(You\\'ll see that Sell2 first goes positive when we encounter our second \"hump\") Then as we hump more and more, we arrive at the correct solution.\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        \\n        if (prices.size() <= 1) { return 0; }\\n        \\n        int aBuy1 = prices[0];\\n        int aSell1 = 0;\\n        int aBuy2 = prices[0];\\n        int aSell2 = 0;\\n        \\n        for (int i=1;i<prices.size();i++) {\\n            aBuy1 = min(aBuy1, prices[i]);\\n            aSell1 = max(aSell1, prices[i] - aBuy1);\\n            aBuy2 = min(aBuy2, prices[i] - aSell1);\\n            aSell2 = max(aSell2, prices[i] - aBuy2);\\n        }\\n        \\n        return aSell2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39687,
                "title": "easy-understanding-c-solution",
                "content": "    class Solution {\\n    public:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        if(n == 0) return 0;\\n        vector<int> min_p(n), max_p(n);\\n        min_p[0] = prices[0];\\n        for(int i = 1; i < n; i ++) min_p[i] = min(min_p[i-1], prices[i]);\\n        max_p[n-1] = prices[n-1];\\n        for(int i = n - 2; i >= 0; i --) max_p[i] = max(max_p[i+1], prices[i]);\\n        \\n        int ret = 0;\\n        int tmp = 0;\\n        for(int i = 0; i < n; i ++){\\n            tmp = max(tmp, prices[i] - min_p[i]);\\n            ret = max(ret, tmp + max_p[i] - prices[i]);\\n        }\\n        return ret;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        if(n == 0) return 0;\\n        vector<int> min_p(n), max_p(n);\\n        min_p[0] = prices[0];\\n        for(int i = 1; i < n; i ++) min_p[i] = min(min_p[i-1], prices[i]);\\n        max_p[n-1] = prices[n-1];\\n        for(int i = n - 2; i >= 0; i --) max_p[i] = max(max_p[i+1], prices[i]);\\n        \\n        int ret = 0;\\n        int tmp = 0;\\n        for(int i = 0; i < n; i ++){\\n            tmp = max(tmp, prices[i] - min_p[i]);\\n            ret = max(ret, tmp + max_p[i] - prices[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 39747,
                "title": "solution-sharing-commented-code-o-n-time-and-o-n-space",
                "content": "    public class Solution {\\n        public int maxProfit(int[] prices) {\\n            if (prices.length < 2) return 0;//one of zero days, cannot sell\\n            // break the problem in to subproblems, what is the max profit if i decide to buy and sell one stock on or before day i\\n            // and the other stock after day i\\n            \\n            int[] left = new int[prices.length];//store the max profit so far for day [0,i] for i from 0 to n\\n            int[] right = new int[prices.length];//store the max profit so far for the days [i,n] for i from 0 to n\\n            int minl,maxprofit,maxr,profit;\\n            maxprofit = 0;//lower bound on profit\\n            minl = Integer.MAX_VALUE;//minimum price so far for populating left array\\n            for(int i = 0; i < left.length; i++){\\n                if (prices[i] < minl) minl = prices[i];//check if this price is the minimum price so far\\n                profit = prices[i] - minl;//get the profit of selling at current price having bought at min price so far\\n                if (profit > maxprofit) maxprofit = profit;//if the profit is greater than the profit so far, update the max profit\\n                left[i] = maxprofit;\\n            }\\n            maxprofit = 0;//reset maxprofit to its lower bound\\n            maxr = Integer.MIN_VALUE;//maximum price so far for populating the right array\\n            //same line of reasoning as the above\\n            for(int i = left.length - 1; i >= 0; i--){\\n                if (prices[i] > maxr) maxr = prices[i];\\n                profit = maxr - prices[i];\\n                if (profit > maxprofit) maxprofit = profit;\\n                right[i] = maxprofit;\\n            }\\n            //get the best by combining the subproblems as described above\\n            int best = 0;\\n            for(int i = 0; i < prices.length - 1; i++){\\n                if (left[i] + right[i+1] > best) best = left[i] + right[i+1];\\n            }\\n            best = best > maxprofit ? best : maxprofit;\\n            // in total 3 passes required and 2 extra arrays of size n\\n            return best;\\n            \\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int maxProfit(int[] prices) {\\n            if (prices.length < 2) return 0;//one of zero days, cannot sell\\n            // break the problem in to subproblems, what is the max profit if i decide to buy and sell one stock on or before day i\\n            // and the other stock after day i\\n            \\n            int[] left = new int[prices.length];//store the max profit so far for day [0,i] for i from 0 to n\\n            int[] right = new int[prices.length];//store the max profit so far for the days [i,n] for i from 0 to n\\n            int minl,maxprofit,maxr,profit;\\n            maxprofit = 0;//lower bound on profit\\n            minl = Integer.MAX_VALUE;//minimum price so far for populating left array\\n            for(int i = 0; i < left.length; i++){\\n                if (prices[i] < minl) minl = prices[i];//check if this price is the minimum price so far\\n                profit = prices[i] - minl;//get the profit of selling at current price having bought at min price so far\\n                if (profit > maxprofit) maxprofit = profit;//if the profit is greater than the profit so far, update the max profit\\n                left[i] = maxprofit;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3667563,
                "title": "c-memoization",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int i,int &n,vector<int> &v,int k,vector<vector<int>> &dp){\\n        if(i>=n||k<=0)return 0;\\n        if(dp[i][k] != -1)return dp[i][k];\\n        int ans1 = solve(i+1,n,v,k,dp);\\n        int ans2 = 0;\\n        if(!(k%2)){\\n            ans2 = -v[i]+solve(i+1,n,v,k-1,dp);\\n        }else{\\n            ans2  = v[i]+solve(i+1,n,v,k-1,dp);\\n        }\\n        return dp[i][k] = max(ans1,ans2);\\n    }\\n    int maxProfit(vector<int>& v) {\\n        int n = v.size();\\n        int k = 4;\\n        vector<vector<int>> dp(n,vector<int>(k+1,-1));\\n        return solve(0,n,v,k,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,int &n,vector<int> &v,int k,vector<vector<int>> &dp){\\n        if(i>=n||k<=0)return 0;\\n        if(dp[i][k] != -1)return dp[i][k];\\n        int ans1 = solve(i+1,n,v,k,dp);\\n        int ans2 = 0;\\n        if(!(k%2)){\\n            ans2 = -v[i]+solve(i+1,n,v,k-1,dp);\\n        }else{\\n            ans2  = v[i]+solve(i+1,n,v,k-1,dp);\\n        }\\n        return dp[i][k] = max(ans1,ans2);\\n    }\\n    int maxProfit(vector<int>& v) {\\n        int n = v.size();\\n        int k = 4;\\n        vector<vector<int>> dp(n,vector<int>(k+1,-1));\\n        return solve(0,n,v,k,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369001,
                "title": "best-o-n-solution",
                "content": "# Approach 1\\nRecursion (TLE)\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int solve(int idx, int buy, int cap, vector<int>& prices, int n) {\\n        if (cap == 0 || idx == n)\\n            return 0;\\n        if (buy == 1) \\n            return max (-prices[idx] + solve(idx+1, 0, cap, prices, n),\\n                        0 + solve(idx+1, 1, cap, prices, n));\\n        return max (prices[idx] + solve(idx+1, 1, cap-1, prices, n),\\n                    0 + solve(idx+1, 0, cap, prices, n));  \\n    }  \\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        return solve(0, 1, 2, prices, n);\\n    }\\n};\\n```\\n\\n# Approach 2\\nDP (Top Down Approach)\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int solve(int idx, int buy, int cap, vector<int>& prices, vector<vector<vector<int>>>& dp, int n) {\\n        if (cap == 0 || idx == n)\\n            return 0;\\n            if (dp[idx][buy][cap] != -1)\\n                return dp[idx][buy][cap];\\n        if (buy == 1) \\n            return dp[idx][buy][cap] = max (-prices[idx] + solve(idx+1, 0, cap, prices, dp, n),\\n                        0 + solve(idx+1, 1, cap, prices, dp, n));\\n        return dp[idx][buy][cap] = max (prices[idx] + solve(idx+1, 1, cap-1, prices, dp, n),\\n                    0 + solve(idx+1, 0, cap, prices, dp, n));  \\n    }  \\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        vector<vector<vector<int>>> dp(n+1, vector<vector<int>>(2, vector<int>(3, -1)));\\n        return solve(0, 1, 2, prices, dp, n);\\n    }\\n};\\n```\\n\\n# Approach 3\\nDP (Bottom Up Approach)\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        vector<vector<vector<int>>> dp(n+1, vector<vector<int>>(2, vector<int>(3, 0)));\\n        for (int idx = n-1; idx >= 0; idx--) {\\n            for (int buy = 0; buy <= 1; buy++) {\\n                for (int cap = 1; cap <= 2; cap++) {\\n                    if (buy == 1) \\n                        dp[idx][buy][cap] = max (-prices[idx] + dp[idx+1][0][cap], 0 + dp[idx+1][1][cap]);\\n                    else    \\n                        dp[idx][buy][cap] = max (prices[idx] + dp[idx+1][1][cap-1], 0 + dp[idx+1][0][cap]);  \\n                }\\n            }\\n        }\\n        return dp[0][1][2];        \\n    }\\n};\\n```\\n\\n# Approach 4\\nDP (Bottom Up Approach) + Space Optimization\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        vector<vector<int>> ahead(2, vector<int>(3, 0)), cur(2, vector<int>(3, 0));\\n        for (int idx = n-1; idx >= 0; idx--) {\\n            for (int buy = 0; buy <= 1; buy++) {\\n                for (int cap = 1; cap <= 2; cap++) {\\n                    if (buy == 1) \\n                        cur[buy][cap] = max (-prices[idx] + ahead[0][cap], 0 + ahead[1][cap]);\\n                    else    \\n                        cur[buy][cap] = max (prices[idx] + ahead[1][cap-1], 0 + ahead[0][cap]);  \\n                }\\n            }\\n            ahead = cur;\\n        }\\n        return ahead[1][2];        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int solve(int idx, int buy, int cap, vector<int>& prices, int n) {\\n        if (cap == 0 || idx == n)\\n            return 0;\\n        if (buy == 1) \\n            return max (-prices[idx] + solve(idx+1, 0, cap, prices, n),\\n                        0 + solve(idx+1, 1, cap, prices, n));\\n        return max (prices[idx] + solve(idx+1, 1, cap-1, prices, n),\\n                    0 + solve(idx+1, 0, cap, prices, n));  \\n    }  \\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        return solve(0, 1, 2, prices, n);\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    int solve(int idx, int buy, int cap, vector<int>& prices, vector<vector<vector<int>>>& dp, int n) {\\n        if (cap == 0 || idx == n)\\n            return 0;\\n            if (dp[idx][buy][cap] != -1)\\n                return dp[idx][buy][cap];\\n        if (buy == 1) \\n            return dp[idx][buy][cap] = max (-prices[idx] + solve(idx+1, 0, cap, prices, dp, n),\\n                        0 + solve(idx+1, 1, cap, prices, dp, n));\\n        return dp[idx][buy][cap] = max (prices[idx] + solve(idx+1, 1, cap-1, prices, dp, n),\\n                    0 + solve(idx+1, 0, cap, prices, dp, n));  \\n    }  \\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        vector<vector<vector<int>>> dp(n+1, vector<vector<int>>(2, vector<int>(3, -1)));\\n        return solve(0, 1, 2, prices, dp, n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        vector<vector<vector<int>>> dp(n+1, vector<vector<int>>(2, vector<int>(3, 0)));\\n        for (int idx = n-1; idx >= 0; idx--) {\\n            for (int buy = 0; buy <= 1; buy++) {\\n                for (int cap = 1; cap <= 2; cap++) {\\n                    if (buy == 1) \\n                        dp[idx][buy][cap] = max (-prices[idx] + dp[idx+1][0][cap], 0 + dp[idx+1][1][cap]);\\n                    else    \\n                        dp[idx][buy][cap] = max (prices[idx] + dp[idx+1][1][cap-1], 0 + dp[idx+1][0][cap]);  \\n                }\\n            }\\n        }\\n        return dp[0][1][2];        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        vector<vector<int>> ahead(2, vector<int>(3, 0)), cur(2, vector<int>(3, 0));\\n        for (int idx = n-1; idx >= 0; idx--) {\\n            for (int buy = 0; buy <= 1; buy++) {\\n                for (int cap = 1; cap <= 2; cap++) {\\n                    if (buy == 1) \\n                        cur[buy][cap] = max (-prices[idx] + ahead[0][cap], 0 + ahead[1][cap]);\\n                    else    \\n                        cur[buy][cap] = max (prices[idx] + ahead[1][cap-1], 0 + ahead[0][cap]);  \\n                }\\n            }\\n            ahead = cur;\\n        }\\n        return ahead[1][2];        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2148232,
                "title": "well-explained-with-4-different-approaches-easy",
                "content": "# **Code**\\nThree Approaches has been used -> \\n1. Simple Recursion\\n2. Memoization\\n3. Tabulation\\n4. Optimization\\n\\n\\n**Simple Recursion**\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        return find(0, 1, 2, prices);\\n    }\\n    \\n    private int find(int i, int buy, int c, int[] arr){\\n        if(i == arr.length || c == 0)  return 0;\\n        if(buy == 1){\\n\\t\\t\\treturn dp[i][buy][c] = Math.max(-arr[i] + find(i+1, 0, c, arr), find(i+1, 1, c, arr));     // Here we have choice to whether choose that element or not, and after that, the part giving maximum profit after buying(be that negative) is taken\\n        }\\n        else{\\n            return dp[i][buy][c] = Math.max(arr[i] + find(i+1, 1, c-1, arr), find(i+1, 0, c, arr));   // Same as above but the only change is that profit added is positive because we are selling this time.\\n        }\\n    }   \\n}\\n```\\n\\n\\n**Memoization**\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int[][][] dp = new int[prices.length][2][3];    // As in recursion we can see that it has many overlapping sub problems, thus DP is a better solution\\n        for(int[][] a: dp){\\n            for(int[] b: a) Arrays.fill(b, -1);\\n        }\\n        return find(0, 1, 2, prices, dp);\\n    }\\n    \\n    private int find(int i, int buy, int c, int[] arr, int[][][] dp){\\n        if(i == arr.length || c == 0)  return 0;\\n        if(dp[i][buy][c] != -1) return dp[i][buy][c];\\n        if(buy == 1){\\n            return dp[i][buy][c] = Math.max(-arr[i] + find(i+1, 0, c, arr, dp), find(i+1, 1, c, arr, dp));   // The only change here is that we store the result of the subproblems into a data structure and can be used further, thus reduces time complexity from O(2^n) to O(6*n)\\n        }\\n        else{\\n            return dp[i][buy][c] = Math.max(arr[i] + find(i+1, 1, c-1, arr, dp), find(i+1, 0, c, arr, dp));\\n        }\\n    }   \\n}\\n```\\n\\n\\n**Tabulation**\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n = prices.length;\\n        int[][][] dp = new int[n+1][2][3];\\n\\t\\t\\n        for(int i=0; i<dp.length; i++){\\n            for(int j=0; j<2; j++){\\n                dp[i][j][0] = 0;\\n            }\\n        }\\n        \\n        for(int j=0; j<2; j++){\\n            for(int k=0; k<3; k++){\\n                dp[n][j][k] = 0;\\n            }\\n        }\\n        \\n        for(int i=n-1; i>=0; i--){\\n            for(int buy=0; buy<=1; buy++){\\n                for(int c=1; c<=2; c++){\\n                    if(buy == 1){\\n                        dp[i][buy][c] = Math.max(-prices[i] + dp[i+1][0][c], dp[i+1][1][c]);    // In this we used tabulation, to remove the auxilary space complexity of O(n), and core part of code is exactly same as above\\n                    }\\n                    else{\\n                        dp[i][buy][c] = Math.max(prices[i] + dp[i+1][1][c-1], dp[i+1][0][c]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0][1][2];\\n    }\\n}\\n```\\n\\n\\n**Optimization**\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n = prices.length;\\n        int[][] after = new int[2][3];\\n        int[][] curr = new int[2][3];\\n        \\n        for(int i=n-1; i>=0; i--){\\n            for(int buy=0; buy<=1; buy++){\\n                for(int c=1; c<=2; c++){\\n                    if(buy == 1){\\n\\t\\t\\t\\t\\t\\tcurr[buy][c] = Math.max(-prices[i] + after[0][c], after[1][c]);    // This approach requires O(1) space because we identified that the current state only depends on previous state so its not necessary to store whole 3D array\\n\\t\\t\\t\\t\\t// We only require two 2x3 matrix to store these states\\n                    }\\n                    else{\\n                        curr[buy][c] = Math.max(prices[i] + after[1][c-1], after[0][c]);\\n                    }\\n                }\\n            }\\n            after = curr;\\n        }\\n        return curr[1][2];\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        return find(0, 1, 2, prices);\\n    }\\n    \\n    private int find(int i, int buy, int c, int[] arr){\\n        if(i == arr.length || c == 0)  return 0;\\n        if(buy == 1){\\n\\t\\t\\treturn dp[i][buy][c] = Math.max(-arr[i] + find(i+1, 0, c, arr), find(i+1, 1, c, arr));     // Here we have choice to whether choose that element or not, and after that, the part giving maximum profit after buying(be that negative) is taken\\n        }\\n        else{\\n            return dp[i][buy][c] = Math.max(arr[i] + find(i+1, 1, c-1, arr), find(i+1, 0, c, arr));   // Same as above but the only change is that profit added is positive because we are selling this time.\\n        }\\n    }   \\n}\\n```\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int[][][] dp = new int[prices.length][2][3];    // As in recursion we can see that it has many overlapping sub problems, thus DP is a better solution\\n        for(int[][] a: dp){\\n            for(int[] b: a) Arrays.fill(b, -1);\\n        }\\n        return find(0, 1, 2, prices, dp);\\n    }\\n    \\n    private int find(int i, int buy, int c, int[] arr, int[][][] dp){\\n        if(i == arr.length || c == 0)  return 0;\\n        if(dp[i][buy][c] != -1) return dp[i][buy][c];\\n        if(buy == 1){\\n            return dp[i][buy][c] = Math.max(-arr[i] + find(i+1, 0, c, arr, dp), find(i+1, 1, c, arr, dp));   // The only change here is that we store the result of the subproblems into a data structure and can be used further, thus reduces time complexity from O(2^n) to O(6*n)\\n        }\\n        else{\\n            return dp[i][buy][c] = Math.max(arr[i] + find(i+1, 1, c-1, arr, dp), find(i+1, 0, c, arr, dp));\\n        }\\n    }   \\n}\\n```\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n = prices.length;\\n        int[][][] dp = new int[n+1][2][3];\\n\\t\\t\\n        for(int i=0; i<dp.length; i++){\\n            for(int j=0; j<2; j++){\\n                dp[i][j][0] = 0;\\n            }\\n        }\\n        \\n        for(int j=0; j<2; j++){\\n            for(int k=0; k<3; k++){\\n                dp[n][j][k] = 0;\\n            }\\n        }\\n        \\n        for(int i=n-1; i>=0; i--){\\n            for(int buy=0; buy<=1; buy++){\\n                for(int c=1; c<=2; c++){\\n                    if(buy == 1){\\n                        dp[i][buy][c] = Math.max(-prices[i] + dp[i+1][0][c], dp[i+1][1][c]);    // In this we used tabulation, to remove the auxilary space complexity of O(n), and core part of code is exactly same as above\\n                    }\\n                    else{\\n                        dp[i][buy][c] = Math.max(prices[i] + dp[i+1][1][c-1], dp[i+1][0][c]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0][1][2];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1793856,
                "title": "solution-swift-best-time-to-buy-and-sell-stock-iii",
                "content": "```swift\\nclass Solution {\\n    func maxProfit(_ prices: [Int]) -> Int {\\n        let len = prices.count\\n        guard len > 1 else { return 0 }\\n        \\n        var profit = 0, maxVals: [Int] = []\\n        \\n        var maxVal = 0 {\\n            didSet { maxVals.append(maxVal) }\\n        }\\n        \\n        var first = prices.first!\\n        \\n        for price in prices {\\n            maxVal = max(price - first, maxVal)\\n            first = min(price, first)\\n        }\\n        \\n        maxVal = 0\\n        \\n        var last = prices.last!\\n        \\n        for i in (0..<len).reversed() {\\n            let price = prices[i]\\n            maxVal = max(last - price, maxVal)\\n            last = max(price, last)\\n            profit = max(profit, maxVal + maxVals[i])\\n        }\\n        return profit\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<pre>\\nResult: Executed 3 tests, with 0 failures (0 unexpected) in 0.044 (0.046) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\\n    // Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.\\n    func test0() {\\n        let value = solution.maxProfit([3,3,5,0,0,3,1,4])\\n        XCTAssertEqual(value, 6)\\n    }\\n    \\n    // Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\\n    // Note that you cannot buy on day 1, buy on day 2 and sell them later, as you\\n    // are engaging multiple transactions at the same time. You must sell before buying again.\\n    func test1() {\\n        let value = solution.maxProfit([1,2,3,4,5])\\n        XCTAssertEqual(value, 4)\\n    }\\n    \\n    // In this case, no transaction is done, i.e. max profit = 0.\\n    func test2() {\\n        let value = solution.maxProfit([7,6,4,3,1])\\n        XCTAssertEqual(value, 0)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func maxProfit(_ prices: [Int]) -> Int {\\n        let len = prices.count\\n        guard len > 1 else { return 0 }\\n        \\n        var profit = 0, maxVals: [Int] = []\\n        \\n        var maxVal = 0 {\\n            didSet { maxVals.append(maxVal) }\\n        }\\n        \\n        var first = prices.first!\\n        \\n        for price in prices {\\n            maxVal = max(price - first, maxVal)\\n            first = min(price, first)\\n        }\\n        \\n        maxVal = 0\\n        \\n        var last = prices.last!\\n        \\n        for i in (0..<len).reversed() {\\n            let price = prices[i]\\n            maxVal = max(last - price, maxVal)\\n            last = max(price, last)\\n            profit = max(profit, maxVal + maxVals[i])\\n        }\\n        return profit\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\\n    // Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.\\n    func test0() {\\n        let value = solution.maxProfit([3,3,5,0,0,3,1,4])\\n        XCTAssertEqual(value, 6)\\n    }\\n    \\n    // Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\\n    // Note that you cannot buy on day 1, buy on day 2 and sell them later, as you\\n    // are engaging multiple transactions at the same time. You must sell before buying again.\\n    func test1() {\\n        let value = solution.maxProfit([1,2,3,4,5])\\n        XCTAssertEqual(value, 4)\\n    }\\n    \\n    // In this case, no transaction is done, i.e. max profit = 0.\\n    func test2() {\\n        let value = solution.maxProfit([7,6,4,3,1])\\n        XCTAssertEqual(value, 0)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1364335,
                "title": "java-simple-greedy-solution-linear-time-constant-space-solution",
                "content": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if(prices==null || prices.length==0) return 0;\\n        \\n        int fb=Integer.MIN_VALUE;\\n        int sb=Integer.MIN_VALUE;\\n        int fs=0;\\n        int ss=0;\\n        \\n        for(int i=0;i<prices.length;i++){\\n            fb=Math.max(fb,-prices[i]);\\n            fs=Math.max(fs,fb+prices[i]);\\n            \\n            sb=Math.max(sb,fs-prices[i]);\\n            ss=Math.max(ss,sb+prices[i]);\\n        }\\n        return ss;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if(prices==null || prices.length==0) return 0;\\n        \\n        int fb=Integer.MIN_VALUE;\\n        int sb=Integer.MIN_VALUE;\\n        int fs=0;\\n        int ss=0;\\n        \\n        for(int i=0;i<prices.length;i++){\\n            fb=Math.max(fb,-prices[i]);\\n            fs=Math.max(fs,fb+prices[i]);\\n            \\n            sb=Math.max(sb,fs-prices[i]);\\n            ss=Math.max(ss,sb+prices[i]);\\n        }\\n        return ss;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1005542,
                "title": "c-dynamic-programming-case-study-choose-dp-first-always",
                "content": "Jan. 6, 2020\\n\\nThis solution is based on the Best Time to Buy and Sell Stock (Easy level) where you track the global minimum price and maximum profit. At most two trades are considered, so the important task is to divide the array into two areas. \\n\\nGo left to right, and store the best profit for each day individually in left.\\nleft[i] shows the max profit for days [1, i]\\n\\nGo right to left, store best profit in right\\nright[i] shows the max profit for days [i + 1, n]\\n\\nThe maximum profit is the maximum of left[i] + right[i] for i = 0 to n - 1. \\n\\n**Case study**\\nInput: prices = [3,3,5,0,0,3,1,4]\\nOutput: 6\\n\\nThe idea is to find at most two trades to make maximum profit. The array interval can be divided into two intervals. There are at most n ways to divide. \\n\\nIt is to think about dynamic programming way to use exisitng calculated solution. \\nFor example, two partitions, first one is [3, 3, 5], second one is the rest of the array. \\n[3, 3, 5], how to calculate the maximum profit for one trade in the interval, last index is 2, value 5, only need to find minimum value in previous interval. \\nleft[2] = Math.Max(left[1], 5 - minPrice[i - 1]). \\n\\nJust consider current price 5 to calculate it\\'s maximum profit value. \\n\\n[0,0,3,1,4] \\nthis one is to work from right to left iteration order. Index position is 4, value 0, the maximum profit to purchast at index = 4 is to find maximum profit in right side of the index = 4. \\n\\n**Follow up on Dec. 26, 2021 | Premimum version | Unlocked solution written by Leetcode**\\nI spent 10 minutes to read unlocked solution written for Leetcode premium. I strongly advise to get premium version and then learn from premium solution. \\n\\n\\nThe following C# code passes Leetcode online judge. \\n\\n\\n```\\npublic class Solution {\\n    // at most two trades - maximum profit\\n        // dynamic programming solution\\n        // \\n        public int MaxProfit(int[] prices) \\n        {\\n            var n = prices.Length;\\n\\n            var minLeft = Int32.MaxValue;\\n            var maxRight = 0;\\n            var maxProfit = 0;\\n\\n            var left  = new int[n + 1]; \\n            var right = new int[n + 1];\\n\\n            // interval from [0, i]\\n            for (int i = 0; i < n; ++i) \\n            {\\n                var price  = prices[i];                \\n\\n                minLeft     = Math.Min(minLeft, price);                \\n                left[i + 1] = Math.Max(left[i], price - minLeft);                \\n            }\\n\\n            // interval from [n - i - 1, n)\\n            for (int i = 0; i < n; ++i)\\n            {                \\n                var price = prices[n - i - 1];\\n                \\n                maxRight = Math.Max(maxRight, price);               \\n                right[n - i - 1] = Math.Max(right[n - i], maxRight - price);\\n            }\\n\\n            // at most two trades\\n            for (int i = 0; i < n; i++ )\\n            {\\n                maxProfit = Math.Max(maxProfit, left[i] + right[i]);\\n            }\\n            \\n            return maxProfit;            \\n        }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    // at most two trades - maximum profit\\n        // dynamic programming solution\\n        // \\n        public int MaxProfit(int[] prices) \\n        {\\n            var n = prices.Length;\\n\\n            var minLeft = Int32.MaxValue;\\n            var maxRight = 0;\\n            var maxProfit = 0;\\n\\n            var left  = new int[n + 1]; \\n            var right = new int[n + 1];\\n\\n            // interval from [0, i]\\n            for (int i = 0; i < n; ++i) \\n            {\\n                var price  = prices[i];                \\n\\n                minLeft     = Math.Min(minLeft, price);                \\n                left[i + 1] = Math.Max(left[i], price - minLeft);                \\n            }\\n\\n            // interval from [n - i - 1, n)\\n            for (int i = 0; i < n; ++i)\\n            {                \\n                var price = prices[n - i - 1];\\n                \\n                maxRight = Math.Max(maxRight, price);               \\n                right[n - i - 1] = Math.Max(right[n - i], maxRight - price);\\n            }\\n\\n            // at most two trades\\n            for (int i = 0; i < n; i++ )\\n            {\\n                maxProfit = Math.Max(maxProfit, left[i] + right[i]);\\n            }\\n            \\n            return maxProfit;            \\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794877,
                "title": "best-time-to-buy-and-sell-c-track-states-of-two-transactions-o-n-o-1",
                "content": "Keep tracking the two transactions. Both consist of buying and selling, so it comes down to tracking 4 states.\\nThe Solution is short. Going few times through it by hand will make it clear.\\n\\nSubtract the value at current index ```i``` when buying, and add that value to the previous state when selling.\\nSince it is always taking the maximum, you will always end up with the optimal transactions.\\n\\n```\\nclass Solution {\\npublic:\\n\\tint maxProfit(vector<int>& nums) {\\n\\t\\tint firstBuy = INT_MIN, secondBuy = INT_MIN, firstSold = 0, secondSold = 0;\\n\\t\\tfor (int i = 0; i < nums.size(); i++) {\\n\\t\\t\\tfirstBuy = max(firstBuy, -nums[i]);\\n\\t\\t\\tfirstSold = max(firstSold, firstBuy + nums[i]);\\n\\t\\t\\tsecondBuy = max(secondBuy, firstSold - nums[i]);\\n\\t\\t\\tsecondSold = max(secondSold, secondBuy + nums[i]);\\n\\t\\t}\\n\\t\\treturn secondSold;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```i```\n```\\nclass Solution {\\npublic:\\n\\tint maxProfit(vector<int>& nums) {\\n\\t\\tint firstBuy = INT_MIN, secondBuy = INT_MIN, firstSold = 0, secondSold = 0;\\n\\t\\tfor (int i = 0; i < nums.size(); i++) {\\n\\t\\t\\tfirstBuy = max(firstBuy, -nums[i]);\\n\\t\\t\\tfirstSold = max(firstSold, firstBuy + nums[i]);\\n\\t\\t\\tsecondBuy = max(secondBuy, firstSold - nums[i]);\\n\\t\\t\\tsecondSold = max(secondSold, secondBuy + nums[i]);\\n\\t\\t}\\n\\t\\treturn secondSold;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 707896,
                "title": "easy-and-clear-to-understand",
                "content": "```\\npublic int maxProfit(int[] prices) {\\n        int buyOne = Integer.MAX_VALUE;\\n        int ProfitOne = 0;\\n        int buyTwo = Integer.MAX_VALUE;\\n        int ProfitTwo = 0;\\n        for(int p : prices) {\\n            buyOne = Math.min(buyOne, p);\\n            ProfitOne = Math.max(ProfitOne, p - buyOne);\\n            buyTwo = Math.min(buyTwo, p - ProfitOne);     // If I made $100 profit in 1st trans\\'. Then the 2nd Stock(maybe $300) I buy is actually $300 - $100 = $200 for me. \\n            ProfitTwo = Math.max(ProfitTwo, p - buyTwo);   // And finally The maximum profit I make with the 2nd trans\\' is my actuall profit with 2 transaction. \\n        }\\n        return ProfitTwo;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int maxProfit(int[] prices) {\\n        int buyOne = Integer.MAX_VALUE;\\n        int ProfitOne = 0;\\n        int buyTwo = Integer.MAX_VALUE;\\n        int ProfitTwo = 0;\\n        for(int p : prices) {\\n            buyOne = Math.min(buyOne, p);\\n            ProfitOne = Math.max(ProfitOne, p - buyOne);\\n            buyTwo = Math.min(buyTwo, p - ProfitOne);     // If I made $100 profit in 1st trans\\'. Then the 2nd Stock(maybe $300) I buy is actually $300 - $100 = $200 for me. \\n            ProfitTwo = Math.max(ProfitTwo, p - buyTwo);   // And finally The maximum profit I make with the 2nd trans\\' is my actuall profit with 2 transaction. \\n        }\\n        return ProfitTwo;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 676682,
                "title": "java-with-picture",
                "content": "\\n\\nThanks [@han35](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/discuss/39615/My-explanation-for-O(N)-solution!)  and [@shetty4l](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/discuss/149383/Easy-DP-solution-using-state-machine-O(n)-time-complexity-O(1)-space-complexity)\\n\\n\\n![](https://yyc-images.oss-cn-beijing.aliyuncs.com/leetcode_123_using_dp.png)  \\n\\n\\n\\n``` java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int b1 = Integer.MIN_VALUE, s1 = 0;\\n        int b2 = Integer.MIN_VALUE, s2 = 0;\\n        \\n        for (int i = 0; i < prices.length; i++){\\n            int cur = prices[i];\\n            b1 = Math.max(b1, -cur);\\n            s1 = Math.max(s1, b1 + cur);\\n            b2 = Math.max(b2, s1 - cur);\\n            s2 = Math.max(s2, b2 + cur);\\n        }\\n        return s2;\\n    }\\n}\\n```\\n\\n`Enjoy it ! `",
                "solutionTags": [],
                "code": "``` java\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int b1 = Integer.MIN_VALUE, s1 = 0;\\n        int b2 = Integer.MIN_VALUE, s2 = 0;\\n        \\n        for (int i = 0; i < prices.length; i++){\\n            int cur = prices[i];\\n            b1 = Math.max(b1, -cur);\\n            s1 = Math.max(s1, b1 + cur);\\n            b2 = Math.max(b2, s1 - cur);\\n            s2 = Math.max(s2, b2 + cur);\\n        }\\n        return s2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 417564,
                "title": "python3-java-simple-to-code-with-one-loop",
                "content": "### Java\\n\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int buy1 = Integer.MAX_VALUE, buy2 = Integer.MAX_VALUE;\\n        int profit1 = 0, profit2 = 0;\\n\\n        for (int price : prices) {\\n            buy1 = Math.min(buy1, price);\\n            profit1 = Math.max(profit1, price - buy1);\\n            buy2 = Math.min(buy2, price - profit1);\\n            profit2 = Math.max(profit2, price - buy2);\\n        }\\n\\n        return profit2;\\n    }\\n}\\n```\\n\\n### Python\\n\\n```\\nclass Solution:\\n    def maxProfit(self, prices):\\n        buy1, buy2 = float(\\'inf\\'), float(\\'inf\\')\\n        profit1, profit2 = 0, 0\\n        for price in prices:\\n            buy1 = min(buy1, price)\\n            profit1 = max(profit1, price - buy1)\\n            buy2 = min(buy2, price - profit1)\\n            profit2 = max(profit2, price - buy2)\\n\\n        return profit2\\n```\\n\\n-----------\\n\\n### More readable\\n\\n```\\ndef max_profit_ii_1(prices: List[int]) -> int:\\n    first_buy, second_buy, first_profit, second_profit = 1e9,1e9, 0, 0\\n\\n    for price in prices:\\n        first_buy = min(first_buy, price)\\n        first_profit = max(first_profit, price - first_buy)\\n        second_buy = min(second_buy, price - first_profit)\\n        second_profit = max(second_profit, price - second_buy)\\n    return second_profit\\n```\\n\\nIn this solution, since we would want to calculate the max profit, our buys have to be with `min()` and our sells have to be with `max()`. \\n\\nIn the second buy, we would thus deduct the `first_profit` from the current price and look for the minimum from the previous `second_buy` and `price - first_profit`.\\n\\nThis process would have continued if there was a third or fourth stock purchase:\\n\\n\\n```\\ndef max_profit_ii_2(prices: List[int]) -> int:\\n    first_buy, second_buy, thrid_buy, first_profit, second_profit, third_profit = 1e9, 1e9, 1e9, 0, 0, 0\\n    for price in prices:\\n        first_buy = min(first_buy, price)\\n        first_profit = max(first_profit, price - first_buy)\\n        second_buy = min(second_buy, price - first_profit)\\n        second_profit = max(second_profit, price - second_buy)\\n        third_buy = min(third_buy, price - second_profit)\\n        third_profit = max(third_profit, price - third_buy)\\n    return third_profit\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int buy1 = Integer.MAX_VALUE, buy2 = Integer.MAX_VALUE;\\n        int profit1 = 0, profit2 = 0;\\n\\n        for (int price : prices) {\\n            buy1 = Math.min(buy1, price);\\n            profit1 = Math.max(profit1, price - buy1);\\n            buy2 = Math.min(buy2, price - profit1);\\n            profit2 = Math.max(profit2, price - buy2);\\n        }\\n\\n        return profit2;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def maxProfit(self, prices):\\n        buy1, buy2 = float(\\'inf\\'), float(\\'inf\\')\\n        profit1, profit2 = 0, 0\\n        for price in prices:\\n            buy1 = min(buy1, price)\\n            profit1 = max(profit1, price - buy1)\\n            buy2 = min(buy2, price - profit1)\\n            profit2 = max(profit2, price - buy2)\\n\\n        return profit2\\n```\n```\\ndef max_profit_ii_1(prices: List[int]) -> int:\\n    first_buy, second_buy, first_profit, second_profit = 1e9,1e9, 0, 0\\n\\n    for price in prices:\\n        first_buy = min(first_buy, price)\\n        first_profit = max(first_profit, price - first_buy)\\n        second_buy = min(second_buy, price - first_profit)\\n        second_profit = max(second_profit, price - second_buy)\\n    return second_profit\\n```\n```\\ndef max_profit_ii_2(prices: List[int]) -> int:\\n    first_buy, second_buy, thrid_buy, first_profit, second_profit, third_profit = 1e9, 1e9, 1e9, 0, 0, 0\\n    for price in prices:\\n        first_buy = min(first_buy, price)\\n        first_profit = max(first_profit, price - first_buy)\\n        second_buy = min(second_buy, price - first_profit)\\n        second_profit = max(second_profit, price - second_buy)\\n        third_buy = min(third_buy, price - second_profit)\\n        third_profit = max(third_profit, price - third_buy)\\n    return third_profit\\n```",
                "codeTag": "Java"
            },
            {
                "id": 327818,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int sell1=0,sell2=0;\\n        int buy1=Integer.MAX_VALUE,buy2=Integer.MAX_VALUE;\\n        for(int price:prices){\\n            buy1=Math.min(buy1,price);\\n            sell1=Math.max(sell1,price-buy1);\\n            buy2=Math.min(buy2,price-sell1);\\n            sell2=Math.max(sell2,price-buy2);\\n        }\\n        return sell2;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int sell1=0,sell2=0;\\n        int buy1=Integer.MAX_VALUE,buy2=Integer.MAX_VALUE;\\n        for(int price:prices){\\n            buy1=Math.min(buy1,price);\\n            sell1=Math.max(sell1,price-buy1);\\n            buy2=Math.min(buy2,price-sell1);\\n            sell2=Math.max(sell2,price-buy2);\\n        }\\n        return sell2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39634,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Best Time to Buy and Sell Stock III** https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/\\n\\n**Linear Solution**\\n* Consider day i. Say we know maximum profit possible from day 0 to day i. Say we also know the maximum profit from day i+1 to day N-1. Let us call day[i] = forward[i] + backward[i+1]. Backward[i+1] will give us the maximum profit from day i+1 to N-1.\\n* Clearly then, the solution will be max(day[i]).\\n* Now forward[i] is Best Stock 1 problem. \\n* Backward[j[ can also be modelled as the forward[i] problem from j = i+1 to N-1. However this will make it an O(N^2) operation. Can we do it in O(N)?\\n* How about we start from last index and move to 0? Backward[i] is now the reverse problem - start from end, update the highest value as sell value as you move left, and keep updating maximum profit.\\n* Now we will find the cumulative max of both array in respective direction.\\n* Array: [1,2,4,2,5,7,2,4,9,0]\\n* forward: [0, 1, 3, 3, 4, 6, 6, 6, 8, 8]\\n* reverse: [8, 7, 7, 7, 7, 7, 7, 5, 0, 0]\\nhttps://discuss.leetcode.com/topic/24929/o-n-time-and-o-n-space-solution-intuative-and-easy-to-understand-cpp\\n\\n```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        \"\"\"\\n        :type prices: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if prices == []:\\n            return 0\\n        N = len(prices)\\n        forward, backward = [0]*N, [0]*N\\n\\n        max_so_far, buy = 0, prices[0]\\n        for i in range(N):\\n            forward[i] = max(max_so_far, prices[i]-buy)\\n            max_so_far = max(max_so_far, forward[i])\\n            buy = min(buy, prices[i])\\n        \\n        max_so_far, sell = 0, prices[-1]\\n        for i in range(N-1, -1,-1):\\n            backward[i] = max(max_so_far, sell-prices[i])\\n            max_so_far = max(max_so_far, backward[i])\\n            sell = max(sell, prices[i])        \\n        \\n        max_profit = 0\\n        for i in range(N):\\n            max_profit_day_i = forward[i]+backward[i+1] if i < N-1 else forward[i]\\n            max_profit = max(max_profit, max_profit_day_i)\\n            \\n        return max_profit\\n```\\n\\n**Recursive DP Memoization Solution**\\n* f[k, i] represents the max profit up until prices[i] (Note: NOT ending with prices[i]) using at most k transactions.\\n* f[k, i] = max(f[k, i-1], price[i]-price[j] + f[k-1, j-1]) (j in the range of 0 to i-1)\\n* f[k, i] = max(f[k, i-1], price[i] + max( f[k-1, j-1]--price[j])) (j in the range of 0 to i-1)\\n* f[0,i] = 0 (0 times transaction makes 0 profit)\\n* f[k,0] = 0 (if there is only one price data point you can't make any money no matter how many times you can trade)\\n\\n```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        \"\"\"\\n        :type prices: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if not prices:\\n            return 0\\n        N, K = len(prices), 2\\n        max_profit = -1\\n        dp = [[0]*N for _ in range(K+1)]\\n        for k in range(1, K+1):\\n            tmpMax = dp[k-1][0] - prices[0]\\n            for i in range(1, N):\\n                dp[k][i] = max(dp[k][i-1], prices[i] + tmpMax)\\n                tmpMax = max(tmpMax, dp[k-1][i] - prices[i])\\n                max_profit = max(max_profit, dp[k][i])\\n        return dp[K][N-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        \"\"\"\\n        :type prices: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if prices == []:\\n            return 0\\n        N = len(prices)\\n        forward, backward = [0]*N, [0]*N\\n\\n        max_so_far, buy = 0, prices[0]\\n        for i in range(N):\\n            forward[i] = max(max_so_far, prices[i]-buy)\\n            max_so_far = max(max_so_far, forward[i])\\n            buy = min(buy, prices[i])\\n        \\n        max_so_far, sell = 0, prices[-1]\\n        for i in range(N-1, -1,-1):\\n            backward[i] = max(max_so_far, sell-prices[i])\\n            max_so_far = max(max_so_far, backward[i])\\n            sell = max(sell, prices[i])        \\n        \\n        max_profit = 0\\n        for i in range(N):\\n            max_profit_day_i = forward[i]+backward[i+1] if i < N-1 else forward[i]\\n            max_profit = max(max_profit, max_profit_day_i)\\n            \\n        return max_profit\\n```\n```\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        \"\"\"\\n        :type prices: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if not prices:\\n            return 0\\n        N, K = len(prices), 2\\n        max_profit = -1\\n        dp = [[0]*N for _ in range(K+1)]\\n        for k in range(1, K+1):\\n            tmpMax = dp[k-1][0] - prices[0]\\n            for i in range(1, N):\\n                dp[k][i] = max(dp[k][i-1], prices[i] + tmpMax)\\n                tmpMax = max(tmpMax, dp[k-1][i] - prices[i])\\n                max_profit = max(max_profit, dp[k][i])\\n        return dp[K][N-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39683,
                "title": "o-n-solution-in-java-with-good-readability-i-think",
                "content": "        public int maxProfit(int[] prices) {\\n        int n = prices.length;\\n        if(n<2) return 0;\\n\\n        //first transaction's max profit\\n        int[] fmp = new int[n];\\n        fmp[0] = 0;\\n        int minPrice = prices[0];\\n        for(int i=1; i<n; i++){\\n            minPrice = Math.min(minPrice, prices[i]);\\n            fmp[i] = Math.max(fmp[i-1], prices[i]-minPrice);\\n        }\\n\\n        //second transaction's max profit\\n        int[] smp = new int[n];\\n        smp[n-1] = 0;\\n        int maxPrice = prices[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            maxPrice = Math.max(maxPrice, prices[i]);\\n            smp[i] = Math.max(smp[i+1], maxPrice-prices[i]);\\n        }\\n\\n        int profix = 0;\\n        for(int i=0; i<n; i++){\\n            profix = Math.max(profix, fmp[i]+smp[i]);\\n        }\\n\\n        return profix;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "        public int maxProfit(int[] prices) {\\n        int n = prices.length;\\n        if(n<2) return 0;\\n\\n        //first transaction's max profit\\n        int[] fmp = new int[n];\\n        fmp[0] = 0;\\n        int minPrice = prices[0];\\n        for(int i=1; i<n; i++){\\n            minPrice = Math.min(minPrice, prices[i]);\\n            fmp[i] = Math.max(fmp[i-1], prices[i]-minPrice);\\n        }\\n\\n        //second transaction's max profit\\n        int[] smp = new int[n];\\n        smp[n-1] = 0;\\n        int maxPrice = prices[n-1];\\n        for(int i=n-2; i>=0; i--){\\n            maxPrice = Math.max(maxPrice, prices[i]);\\n            smp[i] = Math.max(smp[i+1], maxPrice-prices[i]);\\n        }\\n\\n        int profix = 0;\\n        for(int i=0; i<n; i++){\\n            profix = Math.max(profix, fmp[i]+smp[i]);\\n        }\\n\\n        return profix;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3897443,
                "title": "100-beat-easiest-to-understand-most-readable-javascript-solution-here-with-simple-explanation",
                "content": "# RUNTIME:\\n![image.png](https://assets.leetcode.com/users/images/baa9295d-fe58-465d-98c3-97ffaf91e90a_1691949990.0968132.png)\\n\\n\\n# EXPLANATION (in plain english)\\n\\nThis is not as confusing once we identify and break down the problem. In a way, this is just a variant of a super easy difficulty problem [Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/) where you just find out the most profitable single trade. You can use min max to find this.\\n\\nThis leetcode is something very similar, you just have to do it twice each time. You have to find the best way to slice the given `prices` array into two. And then solve them like you would with [Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/) then add the two. Repeat untill we find max profit.\\n\\nOkay, this is easy to understand, but how can we actually do this without computing every way you can buy and sell two trades in the given `prices` ?\\n\\nWhat if as you iterate from beginning to the end of `prices`, and know (lets say the current iterating index is `i`) what the max profit a trade can make for the left side of `i` and same for the right side of `i`.\\n\\nThats it! its that simple!\\n\\n# **Now how do you do this?**\\n\\nThere are many ways to do this, but they all fundamentally does same thing which is why you see multiple versions of this(mostly unreadable for people who don\\'t understand this problem) on here. But for this explanation, let\\'s use my solution as an example.\\n\\nEssentially, I iterate through the array backwards starting from the end to populate an array with same length as `prices`, fill it up with max profit IF the `prices` is cut off at the iterating index, representing max profit from the index to the end(right side). After I fill this profit array, I iterate forwards from the beginning of `prices`, calculating the max profit on the left side if it were to start from the beginning and cut off at the iterating index.\\n\\nNOW, you might already realize, that by doing this, I have both the max profit on the left side and the right side, for EVERY INDEX as I iterate through, since I already recorded the right side in the new array. \\n\\nFrom here, you just add the left side and right side and find the highest amount of money you can make. \\n\\neasy.\\n\\nIf this helped, even a simple \"thx\" comment would be appreciated! I really tried to explain this in plain english instead of throwing around words that might intimidate beginners. \\n\\n#### Time Complexity\\nO(n). More specifically O(2n) \\n\\n\\n# Solutions \\n\\n#### Version #1 (Easier to understand)\\n```\\nvar maxProfit = function(prices) {\\n    let maxReverse = 0;\\n    let maxProfitReverse = 0;\\n    let maxProfitReverseArray = new Array(prices.length).fill(0);\\n\\n    let min = Infinity;\\n    let maxProfit = 0;\\n    let maxTotalProfit = 0;\\n\\n    //iterating backwards to fill up \"maxProfitReverseArray\" with right side profit for each index\\n    for (let i = prices.length - 1; i >= 0; i--) {\\n        let currentPrice = prices[i];\\n        if (currentPrice > maxReverse) {\\n            maxReverse = currentPrice;\\n        }\\n        let profit = maxReverse - currentPrice;\\n        if (profit > maxProfitReverse) {\\n            maxProfitReverse = profit;\\n        }\\n        maxProfitReverseArray[i] = maxProfitReverse;\\n    }\\n    //iterating forwardsto calculate max profit on the left side and then adding right side, returning maximum possible sum as answer.\\n    for (let k = 0; k < prices.length; k++) {\\n        let currentPrice = prices[k];\\n        if (currentPrice < min) {\\n            min = currentPrice;\\n        }\\n        let profit = currentPrice - min;\\n        if (profit > maxProfit) {\\n            maxProfit = profit;\\n        }\\n        let totalProfit = maxProfit + maxProfitReverseArray[k];\\n        if (totalProfit > maxTotalProfit) {\\n            maxTotalProfit = totalProfit;\\n        }\\n    }\\n\\n    return maxTotalProfit;\\n};\\n```\\n\\n\\n#### Version #2 (Concise)\\n```\\nvar maxProfit = function(prices) {\\n    let maxReverse = 0;\\n    let minReverse = Infinity;\\n    let maxProfitReverse = 0;\\n    let maxProfitReverseArray = new Array(prices.length).fill(0);\\n    \\n    let max = 0;\\n    let min = Infinity;\\n    let maxProfit = 0;\\n    let maxTotalProfit = 0;\\n    \\n    //iterating backwards to fill up \"maxProfitReverseArray\" with right side profit for each index.\\n    for (let i = prices.length - 1; i >= 0; i--) {\\n        let currentPrice = prices[i];\\n        maxReverse = Math.max(maxReverse, currentPrice);\\n        maxProfitReverse = Math.max(maxProfitReverse, maxReverse - currentPrice);\\n        maxProfitReverseArray[i] = maxProfitReverse;\\n    }\\n\\n    //iterating forwards to calculate max profit on the left side and then adding right side, returning maximum possible sum as answer.\\n    for (let k = 0; k < prices.length; k++) {\\n        let currentPrice = prices[k];\\n        min = Math.min(min, currentPrice);\\n        maxProfit = Math.max(maxProfit, currentPrice - min);\\n        maxTotalProfit = Math.max(maxTotalProfit, maxProfit + maxProfitReverseArray[k]);\\n    }\\n\\n    return maxTotalProfit;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nvar maxProfit = function(prices) {\\n    let maxReverse = 0;\\n    let maxProfitReverse = 0;\\n    let maxProfitReverseArray = new Array(prices.length).fill(0);\\n\\n    let min = Infinity;\\n    let maxProfit = 0;\\n    let maxTotalProfit = 0;\\n\\n    //iterating backwards to fill up \"maxProfitReverseArray\" with right side profit for each index\\n    for (let i = prices.length - 1; i >= 0; i--) {\\n        let currentPrice = prices[i];\\n        if (currentPrice > maxReverse) {\\n            maxReverse = currentPrice;\\n        }\\n        let profit = maxReverse - currentPrice;\\n        if (profit > maxProfitReverse) {\\n            maxProfitReverse = profit;\\n        }\\n        maxProfitReverseArray[i] = maxProfitReverse;\\n    }\\n    //iterating forwardsto calculate max profit on the left side and then adding right side, returning maximum possible sum as answer.\\n    for (let k = 0; k < prices.length; k++) {\\n        let currentPrice = prices[k];\\n        if (currentPrice < min) {\\n            min = currentPrice;\\n        }\\n        let profit = currentPrice - min;\\n        if (profit > maxProfit) {\\n            maxProfit = profit;\\n        }\\n        let totalProfit = maxProfit + maxProfitReverseArray[k];\\n        if (totalProfit > maxTotalProfit) {\\n            maxTotalProfit = totalProfit;\\n        }\\n    }\\n\\n    return maxTotalProfit;\\n};\\n```\n```\\nvar maxProfit = function(prices) {\\n    let maxReverse = 0;\\n    let minReverse = Infinity;\\n    let maxProfitReverse = 0;\\n    let maxProfitReverseArray = new Array(prices.length).fill(0);\\n    \\n    let max = 0;\\n    let min = Infinity;\\n    let maxProfit = 0;\\n    let maxTotalProfit = 0;\\n    \\n    //iterating backwards to fill up \"maxProfitReverseArray\" with right side profit for each index.\\n    for (let i = prices.length - 1; i >= 0; i--) {\\n        let currentPrice = prices[i];\\n        maxReverse = Math.max(maxReverse, currentPrice);\\n        maxProfitReverse = Math.max(maxProfitReverse, maxReverse - currentPrice);\\n        maxProfitReverseArray[i] = maxProfitReverse;\\n    }\\n\\n    //iterating forwards to calculate max profit on the left side and then adding right side, returning maximum possible sum as answer.\\n    for (let k = 0; k < prices.length; k++) {\\n        let currentPrice = prices[k];\\n        min = Math.min(min, currentPrice);\\n        maxProfit = Math.max(maxProfit, currentPrice - min);\\n        maxTotalProfit = Math.max(maxTotalProfit, maxProfit + maxProfitReverseArray[k]);\\n    }\\n\\n    return maxTotalProfit;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3722781,
                "title": "it-is-the-most-optimal-approach-tc-o-n-4-and-sc-o-1-striver-s-homework-completed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst of all thanks to Striver bhaiya. In his video solution he give us a homework to do this problem in O(N*4) TC and ~O(1) SC. From his video I am able to code this. I code this problem in its all possible solution. i.e., Recursive --> Memoization --> Tabulation --> Space Optimization. You can find all the codes below (commented)\\n\\nSince we have upper bound of only two stocks , \\nso in order to do this , we can maintain a transaction id which keep check on whether we are going to buy the stock or not && whether we are going to sell the stock or not.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n[B, S, B, S] here we are maintaining transaction ID (even for Buying the stock and odd for selling the stock)\\n\\nIf this code helps you, I request you to please upvote it.\\n\\n# Complexity\\n- Time complexity: ~$$O(N*4)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: ~$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        // using 3d-dp of Nx2x3 [TC = O(Nx2x3), SC = O(Nx2x3)] for tabulation \\n        // Recursive --> Memoization --> Tabulation --> Space optimization\\n        // int after[][] = new int[2][3];\\n        // int curr[][] =  new int[2][3];\\n        // int n = prices.length;\\n        // for(int i = n-1; i>=0; i--){\\n        //     for(int buy =0; buy<=1; buy++){\\n        //         for(int cap = 1; cap<=2; cap++){\\n        //             if(buy == 0){ // whether to buy the stock or not;\\n        //                 curr[buy][cap] = Math.max(-prices[i] + after[1][cap], 0 + after[0][cap]);\\n        //             }\\n\\n        //             if(buy == 1){ // whether to sell the stock or not;\\n        //                 curr[buy][cap] = Math.max(prices[i] + after[0][cap-1], 0 + after[1][cap]);\\n        //             }\\n        //         }\\n        //     }\\n        //     after = curr;\\n        // }\\n        // return after[0][2];\\n\\n        // ############# Striver\\'s Home Work ######################\\n        // using 2d-dp of Nx4 [TC = O(Nx4), SC = O(4)] [B, S, B, S] here we are maintaining transaction ID (even for Buying the stock and odd for selling the stock) Let\\'s Code this :)\\n        // Recursive --> Memoization --> Tabulation --> Space optimization  \\n        int n = prices.length;\\n        // int dp[][] = new int[n+1][5];\\n        // for(int []row : dp){\\n        //     Arrays.fill(row, -1);\\n        // }\\n        // return fun(0, 0,n, prices, dp); --> Memoization , \\n\\n        // Here I am going to convert below code into tabulation    \\n        // .. base cases are on changing variable index and trnsaction_id  if we initialize dp defalut by 0, then it handel already\\n        \\n        // Tabulation with TC = O(Nx4), SC = O(Nx4)\\n        // for(int ind = n-1; ind>=0; ind--){\\n        //     for (int tid = 0; tid<4; tid++){\\n        //         if( tid % 2 == 0){\\n        //             dp[ind][tid] = Math.max(-prices[ind] + dp[ind+1][tid+1], 0 +  dp[ind+1][tid]);\\n        //         }\\n        //         else{\\n        //             dp[ind][tid] = Math.max(prices[ind] + dp[ind+1][tid+1], 0 +  dp[ind+1][tid]);\\n        //         }\\n        //     }\\n        // }\\n        // return dp[0][0];\\n\\n        // ... next task is to do space optimization in above code. \\n        int after[] = new int[5];\\n        int curr[] = new int[5];\\n        for(int ind = n-1; ind>=0; ind--){\\n            for (int tid = 0; tid<4; tid++){\\n                if( tid % 2 == 0){\\n                    curr[tid] = Math.max(-prices[ind] + after[tid+1], 0 +  after[tid]);\\n                }\\n                else{\\n                    curr[tid] = Math.max(prices[ind] + after[tid+1], 0 +  after[tid]);\\n                }\\n            }\\n            after = curr;\\n        }\\n        return after[0];\\n    }\\n    // Memoization with TC = O(Nx4), SC = O(Nx4) + O(N)\\n    public int fun(int ind, int tid, int n, int[] prices, int[][] dp){\\n        if( ind == n || tid == 4) return 0;\\n        int profit = 0;\\n        if(dp[ind][tid] != -1) return dp[ind][tid];\\n        if( tid % 2 == 0){\\n            profit = Math.max(-prices[ind] + fun(ind+1, tid+1,n,prices,dp), 0 +  fun(ind+1, tid,n,prices, dp));\\n        }\\n        else{\\n            profit = Math.max(prices[ind] + fun(ind+1, tid+1,n,prices, dp), 0 +  fun(ind+1, tid,n,prices, dp));\\n        }\\n        return dp[ind][tid] = profit;\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        // using 3d-dp of Nx2x3 [TC = O(Nx2x3), SC = O(Nx2x3)] for tabulation \\n        // Recursive --> Memoization --> Tabulation --> Space optimization\\n        // int after[][] = new int[2][3];\\n        // int curr[][] =  new int[2][3];\\n        // int n = prices.length;\\n        // for(int i = n-1; i>=0; i--){\\n        //     for(int buy =0; buy<=1; buy++){\\n        //         for(int cap = 1; cap<=2; cap++){\\n        //             if(buy == 0){ // whether to buy the stock or not;\\n        //                 curr[buy][cap] = Math.max(-prices[i] + after[1][cap], 0 + after[0][cap]);\\n        //             }\\n\\n        //             if(buy == 1){ // whether to sell the stock or not;\\n        //                 curr[buy][cap] = Math.max(prices[i] + after[0][cap-1], 0 + after[1][cap]);\\n        //             }\\n        //         }\\n        //     }\\n        //     after = curr;\\n        // }\\n        // return after[0][2];\\n\\n        // ############# Striver\\'s Home Work ######################\\n        // using 2d-dp of Nx4 [TC = O(Nx4), SC = O(4)] [B, S, B, S] here we are maintaining transaction ID (even for Buying the stock and odd for selling the stock) Let\\'s Code this :)\\n        // Recursive --> Memoization --> Tabulation --> Space optimization  \\n        int n = prices.length;\\n        // int dp[][] = new int[n+1][5];\\n        // for(int []row : dp){\\n        //     Arrays.fill(row, -1);\\n        // }\\n        // return fun(0, 0,n, prices, dp); --> Memoization , \\n\\n        // Here I am going to convert below code into tabulation    \\n        // .. base cases are on changing variable index and trnsaction_id  if we initialize dp defalut by 0, then it handel already\\n        \\n        // Tabulation with TC = O(Nx4), SC = O(Nx4)\\n        // for(int ind = n-1; ind>=0; ind--){\\n        //     for (int tid = 0; tid<4; tid++){\\n        //         if( tid % 2 == 0){\\n        //             dp[ind][tid] = Math.max(-prices[ind] + dp[ind+1][tid+1], 0 +  dp[ind+1][tid]);\\n        //         }\\n        //         else{\\n        //             dp[ind][tid] = Math.max(prices[ind] + dp[ind+1][tid+1], 0 +  dp[ind+1][tid]);\\n        //         }\\n        //     }\\n        // }\\n        // return dp[0][0];\\n\\n        // ... next task is to do space optimization in above code. \\n        int after[] = new int[5];\\n        int curr[] = new int[5];\\n        for(int ind = n-1; ind>=0; ind--){\\n            for (int tid = 0; tid<4; tid++){\\n                if( tid % 2 == 0){\\n                    curr[tid] = Math.max(-prices[ind] + after[tid+1], 0 +  after[tid]);\\n                }\\n                else{\\n                    curr[tid] = Math.max(prices[ind] + after[tid+1], 0 +  after[tid]);\\n                }\\n            }\\n            after = curr;\\n        }\\n        return after[0];\\n    }\\n    // Memoization with TC = O(Nx4), SC = O(Nx4) + O(N)\\n    public int fun(int ind, int tid, int n, int[] prices, int[][] dp){\\n        if( ind == n || tid == 4) return 0;\\n        int profit = 0;\\n        if(dp[ind][tid] != -1) return dp[ind][tid];\\n        if( tid % 2 == 0){\\n            profit = Math.max(-prices[ind] + fun(ind+1, tid+1,n,prices,dp), 0 +  fun(ind+1, tid,n,prices, dp));\\n        }\\n        else{\\n            profit = Math.max(prices[ind] + fun(ind+1, tid+1,n,prices, dp), 0 +  fun(ind+1, tid,n,prices, dp));\\n        }\\n        return dp[ind][tid] = profit;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2277045,
                "title": "state-machine-solution-with-diagram",
                "content": "To draw the state machine we have to look at the conditions given in the questions:\\n1) There should be **at most** two transactions, it means possibilities are 0,1,2 \\n2) You cannot buy 2 stocks at same time, you have to sell one stock before buying a new.\\n\\nNow I will suggest you to read my solution for buy and sell stock II to understand the following NFA.\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/discuss/2271744/Best-Explanation-Using-State-Machine-with-diagram.\\n\\n![image](https://assets.leetcode.com/users/images/443a2cfd-f10e-4784-adc4-a718bc3e4831_1657725067.233356.png)\\n\\n\\nThe state equation for each node:\\n**x[i]=x[i-1];\\ny[i]=max(x[i-1]-prices[i], y[i-1]);\\nz[i]=max(y[i-1]+prices[i],z[i-1]);\\na[i]=max(a[i-1],z[i-1]-prices[i]);\\nb[i]=max(a[i-1]+prices[i],b[i-1]);**\\n\\nC++ code with O(n) space:\\n```\\n  int maxProfit(vector<int>& prices) {\\n\\t\\tint n=prices.size();\\n        vector<int> x(n),y(n),z(n),a(n),b(n);\\n        y[0]=-prices[0];\\n        a[0]=-prices[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            x[i]=x[i-1];\\n            y[i]=max(x[i-1]-prices[i], y[i-1]);\\n            z[i]=max(y[i-1]+prices[i],z[i-1]);\\n            a[i]=max(a[i-1],z[i-1]-prices[i]);\\n            b[i]=max(a[i-1]+prices[i],b[i-1]);\\n            \\n        }\\n        return max(x[n-1],max(y[n-1],max(z[n-1],max(a[n-1],b[n-1]))));\\n\\t\\t}\\n```\\nAnd with little tweaking in O(1) space:\\n```\\nint maxProfit(vector<int>& prices) {\\n\\n        int n=prices.size();\\n        int x=0,y=-prices[0],z=0,a=-prices[0],b=0;\\n        int y_last=y,z_last=0,a_last=a;\\n        for(int i=1;i<n;i++)\\n        {\\n            y=max(y_last,-prices[i]);\\n            z=max(z_last,y_last+prices[i]);\\n            a=max(a_last,z_last-prices[i]);\\n            b=max(b,a_last+prices[i]);\\n            y_last=y,z_last=z,a_last=a;\\n        }\\n        \\n        return max(x,max(y,max(z,max(a,b))));\\n    }\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n  int maxProfit(vector<int>& prices) {\\n\\t\\tint n=prices.size();\\n        vector<int> x(n),y(n),z(n),a(n),b(n);\\n        y[0]=-prices[0];\\n        a[0]=-prices[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            x[i]=x[i-1];\\n            y[i]=max(x[i-1]-prices[i], y[i-1]);\\n            z[i]=max(y[i-1]+prices[i],z[i-1]);\\n            a[i]=max(a[i-1],z[i-1]-prices[i]);\\n            b[i]=max(a[i-1]+prices[i],b[i-1]);\\n            \\n        }\\n        return max(x[n-1],max(y[n-1],max(z[n-1],max(a[n-1],b[n-1]))));\\n\\t\\t}\\n```\n```\\nint maxProfit(vector<int>& prices) {\\n\\n        int n=prices.size();\\n        int x=0,y=-prices[0],z=0,a=-prices[0],b=0;\\n        int y_last=y,z_last=0,a_last=a;\\n        for(int i=1;i<n;i++)\\n        {\\n            y=max(y_last,-prices[i]);\\n            z=max(z_last,y_last+prices[i]);\\n            a=max(a_last,z_last-prices[i]);\\n            b=max(b,a_last+prices[i]);\\n            y_last=y,z_last=z,a_last=a;\\n        }\\n        \\n        return max(x,max(y,max(z,max(a,b))));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1664548,
                "title": "c-dp-solution-o-n",
                "content": "class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n    \\n        int n = prices.size();\\n        vector<int> profits(n, 0);\\n        int buy_price = -1, j = 0, ans = 0, max_profit = 0;\\n        \\n        for(auto i : prices)\\n        {\\n            if(buy_price == -1)\\n            {\\n                buy_price = i;\\n                j++;\\n                continue;\\n            }\\n            \\n            if(buy_price < i)\\n                max_profit = profits[j] = max(max_profit, i - buy_price);\\n            else\\n                buy_price = i, profits[j] = max_profit;\\n            \\n            j++;\\n        }\\n        \\n        vector<int> r_max(n);\\n        r_max[n - 1] = prices[n - 1];\\n        j = n - 1;\\n        while(j--)\\n            r_max[j] = max(r_max[j + 1], prices[j]);\\n        \\n        j = n;\\n        while(j--)\\n            ans = max(profits[j] + r_max[j] - prices[j], ans);\\n          \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n    \\n        int n = prices.size();\\n        vector<int> profits(n, 0);\\n        int buy_price = -1, j = 0, ans = 0, max_profit = 0;\\n        \\n        for(auto i : prices)\\n        {\\n            if(buy_price == -1)\\n            {\\n                buy_price = i;\\n                j++;\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1529380,
                "title": "c-o-n-prefix-sufix",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n**Approach:**\\n\\n1.We can get max profit either by 1 or 2 transactions:\\n2.If we consider two transactions, we need to find 2 Non-Overlapping transactions.\\n\\n```\\nclass Solution {\\npublic:\\n\\n    int maxProfit(vector<int>& a) {\\n        int n=a.size();\\n        if(n<2) return 0;\\n        \\n        int left[n]; // max profit if sell at ith index\\n        left[0]=0;\\n        int minl=a[0]; \\n        for(int i=1;i<n;i++){\\n            left[i]=max(left[i-1],a[i]-minl);\\n            minl=min(minl,a[i]); // minimum stock price we encounter in [0,i] index\\n        }\\n        \\n        int right[n]; // max profit if buy at ith index\\n        right[n-1]=0;\\n        int maxr=a[n-1];\\n        for(int i=n-2;i>=0;i--){\\n            right[i]=max(right[i+1],maxr-a[i]);\\n            maxr=max(maxr,a[i]); // maximum stock price we encounter in [i,n-1] index\\n        }\\n        \\n        int ans=0;\\n        for(int i=0;i<n-1;i++){\\n            ans=max(ans,left[i]+right[i+1]); // considering 2 possible transactions\\n            ans=max(ans,max(left[i],right[i])); // considering 1 transaction\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int maxProfit(vector<int>& a) {\\n        int n=a.size();\\n        if(n<2) return 0;\\n        \\n        int left[n]; // max profit if sell at ith index\\n        left[0]=0;\\n        int minl=a[0]; \\n        for(int i=1;i<n;i++){\\n            left[i]=max(left[i-1],a[i]-minl);\\n            minl=min(minl,a[i]); // minimum stock price we encounter in [0,i] index\\n        }\\n        \\n        int right[n]; // max profit if buy at ith index\\n        right[n-1]=0;\\n        int maxr=a[n-1];\\n        for(int i=n-2;i>=0;i--){\\n            right[i]=max(right[i+1],maxr-a[i]);\\n            maxr=max(maxr,a[i]); // maximum stock price we encounter in [i,n-1] index\\n        }\\n        \\n        int ans=0;\\n        for(int i=0;i<n-1;i++){\\n            ans=max(ans,left[i]+right[i+1]); // considering 2 possible transactions\\n            ans=max(ans,max(left[i],right[i])); // considering 1 transaction\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1526557,
                "title": "java-similar-to-largest-area-histogram",
                "content": "iteration 1(left to right) : finding maxprofit if sold today or any previous day .\\niteration 2(right to left) : finding maxprofit if bought and sold stocks today or any other day in the future.\\n```\\nclass Solution {\\n    public int maxProfit(int[] a) {\\n        int[] dp1 = new int[a.length];\\n        int cmax = 0, least = a[0];\\n        //finding maximum profit if sold today or any other prevoius day\\n        for(int i = 1; i < dp1.length; i++){\\n            cmax = Math.max(cmax, a[i] - least);\\n            dp1[i] = cmax;\\n            least = Math.min(least, a[i]);\\n        }\\n        int[] dp2 = new int[a.length];\\n        dp2[dp2.length - 1] = 0;\\n        int cmax1 = 0, max = a[a.length - 1];\\n        //finding maximum profit if stocks are bought and sold today or any other day in the future\\n        for(int i = dp2.length - 2; i >= 0; i--){\\n            cmax1 = Math.max(cmax1, max - a[i]);\\n            dp2[i] = cmax1;\\n            max = Math.max(max, a[i]);\\n        }\\n        int ans = 0;\\n        // both are non-overlapping so adding adding respective values and finding the max(ans)\\n        for(int i = 0; i < a.length; i++){\\n            ans = Math.max(ans, dp1[i] + dp2[i]);\\n        }\\n        return ans;\\n    }\\n}\\n\\n/*\\n        dp1 0 0 2 2 2 3 3 4     max_profit if sold today or on any prev_day \\n            3 3 5 0 0 3 1 4\\n        dp2 4 4 4 4 4 3 3 0     max_profit if bought and sold today or in future\\n  ans = max(4 4 6 6 6 6 6 4) = 6\\n*/\\n```\\noptimization : we can remove the second dp ```dp2``` and change the values of dp1 by simply adding cmax1",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] a) {\\n        int[] dp1 = new int[a.length];\\n        int cmax = 0, least = a[0];\\n        //finding maximum profit if sold today or any other prevoius day\\n        for(int i = 1; i < dp1.length; i++){\\n            cmax = Math.max(cmax, a[i] - least);\\n            dp1[i] = cmax;\\n            least = Math.min(least, a[i]);\\n        }\\n        int[] dp2 = new int[a.length];\\n        dp2[dp2.length - 1] = 0;\\n        int cmax1 = 0, max = a[a.length - 1];\\n        //finding maximum profit if stocks are bought and sold today or any other day in the future\\n        for(int i = dp2.length - 2; i >= 0; i--){\\n            cmax1 = Math.max(cmax1, max - a[i]);\\n            dp2[i] = cmax1;\\n            max = Math.max(max, a[i]);\\n        }\\n        int ans = 0;\\n        // both are non-overlapping so adding adding respective values and finding the max(ans)\\n        for(int i = 0; i < a.length; i++){\\n            ans = Math.max(ans, dp1[i] + dp2[i]);\\n        }\\n        return ans;\\n    }\\n}\\n\\n/*\\n        dp1 0 0 2 2 2 3 3 4     max_profit if sold today or on any prev_day \\n            3 3 5 0 0 3 1 4\\n        dp2 4 4 4 4 4 3 3 0     max_profit if bought and sold today or in future\\n  ans = max(4 4 6 6 6 6 6 4) = 6\\n*/\\n```\n```dp2```",
                "codeTag": "Java"
            },
            {
                "id": 1523914,
                "title": "python-explained-one-pass-o-1-space-2-lines",
                "content": "Please feel free to ask questions or give suggestions. Please **upvote** if you like the solution.\\n**Idea**:\\n* At the end of each day, there are 4 scenarios:\\n\\t* We\\'re holding the 1st stock we\\'ve bought\\n\\t* We\\'ve bought and sold 1 stock\\n\\t* We\\'re holding the 2nd stock we\\'ve bought\\n\\t* We sold 2 stocks\\n* The ways we could end up at each scenario respectively are:\\n\\t* We held 1st stock or just bought our first\\n\\t* We had sold our 1st stock or we held it and just sold it\\n\\t* We were holding our 2nd stock or we had sold 1 and just bought 2nd\\n\\t* We had sold 2 stocks, or we had sold 1, held 2nd, and then just sold it\\n* For each scenario, we keep the max profit we could have made while ending up that way. We iterate through the prices list keeping track of these 4 for the last day seen so far.\\n\\n**Recommended Solution**: One-pass, O(1) space\\n```\\ndef maxProfit(self, prices: List[int]) -> int:\\n\\tdef day_end(a, p):\\n\\t\\t\"\"\" Returns max profit when ending up at each of the 4 possible scenarios based on previous day maxes and the price on this day.\\n\\t\\ta: tuple of maxes for scenarios (holding 1st stock, sold 1 stock, holding 2nd stock, sold 2 stocks)\\n\\t\\tp: price on that day\\n\\t\\t\"\"\"\\n\\t\\t# max(held 1, bought 1st), max(sold 1, held 1 and just sold), max(held 2nd, sold 1 and just bought 2nd), max(sold 2, held 2nd and just sold 2nd)\\n\\t\\treturn max(a[0], -p), max(a[1], a[0] + p), max(a[2], a[1] - p), max(a[3], a[2] + p)\\n\\n\\t_, s1, _, s2 = reduce(day_end, prices, (-prices[0], 0, -prices[0], 0))\\n\\treturn max(s1, s2)\\n```\\nIf you don\\'t know what reduce does, do check the docs: https://docs.python.org/3/library/functools.html.\\n**Equivalent unoptimized code**:\\n```\\ndef maxProfit(self, prices: List[int]) -> int:\\n\\t# h is for holding\\n\\th1 = h2 = -prices[0]\\n\\t# s is for sold\\n\\ts1 = s2 = 0\\n\\n\\t# Move forward day by day\\n\\tfor p in prices:\\n\\t\\t# max(held 1, bought 1st), max(sold 1, held 1 and just sold), max(held 2nd, sold 1 and just bought 2nd), max(sold 2, held 2nd and just sold 2nd)\\n\\t\\th1, s1, h2, s2 = max(h1, -p), max(s1, h1+p), max(h2, s1-p), max(s2, h2+p)\\n\\n\\treturn max(s1, s2)\\n```\\n**FAQ**\\nQ. I\\'ve read it a few times and still can\\'t comprehend exactly how it works.\\nA. Try and think of this as a problem where you have a bunch of finite states you could be in (how many stocks you\\'ve bought and sold) and buying or selling on a day makes you transition between these states. (formally called a finite state automata if you want to read further).\\n\\nI\\'d recommend we start with the loop version. All of these states represent natural steps you would take in the problem. Initially you have no stock. When you buy 1, you move to h1. When you sell this, you move to s1. When you buy another, you move to h2. When you sell this second stock, you move to s2. These are the second parameters passed to our max function. h1 = max(..., -p), s1 = max(..., h1+p), h2 = max(..., s1-p), s2 = max(.., h2+p).\\n\\nWhen you\\'re transitioning, you either have to spend price or you get price. If you don\\'t do either, you say in the same state. If you observe the maxes in the loop, the first value passed is whatever the max value was in the original state i.e. h1 = max(h1, ...), s1 = max(s1, ...), h2 = max(h2, ...), max(s2, ...). \\n\\n(Only for the sake of the problem :) )At the end of a day, all that matters is what state we\\'re in and how much money we\\'ve accumulated so far. If we know these 2 things, we can keep moving through the days, figuring out what the max possible values that would lead to us being in those states are.\\n\\nAll that\\'s left is the initialization. h1 and h2 have both been set to -price on the first day. This is just setting up for when we can actually have a holding after having figured out the rest of the logic. At the end of the first day, our h1 and h2 need to be -price and s1, s2 need to be 0.\\n\\nHope this helps.",
                "solutionTags": [],
                "code": "```\\ndef maxProfit(self, prices: List[int]) -> int:\\n\\tdef day_end(a, p):\\n\\t\\t\"\"\" Returns max profit when ending up at each of the 4 possible scenarios based on previous day maxes and the price on this day.\\n\\t\\ta: tuple of maxes for scenarios (holding 1st stock, sold 1 stock, holding 2nd stock, sold 2 stocks)\\n\\t\\tp: price on that day\\n\\t\\t\"\"\"\\n\\t\\t# max(held 1, bought 1st), max(sold 1, held 1 and just sold), max(held 2nd, sold 1 and just bought 2nd), max(sold 2, held 2nd and just sold 2nd)\\n\\t\\treturn max(a[0], -p), max(a[1], a[0] + p), max(a[2], a[1] - p), max(a[3], a[2] + p)\\n\\n\\t_, s1, _, s2 = reduce(day_end, prices, (-prices[0], 0, -prices[0], 0))\\n\\treturn max(s1, s2)\\n```\n```\\ndef maxProfit(self, prices: List[int]) -> int:\\n\\t# h is for holding\\n\\th1 = h2 = -prices[0]\\n\\t# s is for sold\\n\\ts1 = s2 = 0\\n\\n\\t# Move forward day by day\\n\\tfor p in prices:\\n\\t\\t# max(held 1, bought 1st), max(sold 1, held 1 and just sold), max(held 2nd, sold 1 and just bought 2nd), max(sold 2, held 2nd and just sold 2nd)\\n\\t\\th1, s1, h2, s2 = max(h1, -p), max(s1, h1+p), max(h2, s1-p), max(s2, h2+p)\\n\\n\\treturn max(s1, s2)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1523302,
                "title": "c-recursive-memoization-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[100001][3][2];\\n    int solve(vector<int>& prices, int pos, int k, bool hold){\\n        if(pos>=prices.size()) return 0;\\n        if(dp[pos][k][hold]!=-1) return dp[pos][k][hold];\\n        int buy=0,notbuy=0,sell=0,notsell=0;\\n\\t\\t//if k>0 and you don\\'t have pending transaction \\n        if(!hold and k) buy = solve(prices,pos+1,k-1,!hold) - prices[pos];\\n\\t\\t//if you don\\'t want to buy \\n        notbuy = solve(prices,pos+1,k,hold);\\n\\t\\t//if you have a pending transaction than only you can sell the stock\\n        if(hold) sell = solve(prices,pos+1,k,!hold) + prices[pos];\\n\\t\\t//if you don\\'t want to sell\\n        notsell = solve(prices,pos+1,k,hold);\\n        return dp[pos][k][hold] = max(max(buy,notbuy),max(sell,notsell));\\n    }\\n    \\n    int maxProfit(vector<int>& prices) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(prices,0,2,false);\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[100001][3][2];\\n    int solve(vector<int>& prices, int pos, int k, bool hold){\\n        if(pos>=prices.size()) return 0;\\n        if(dp[pos][k][hold]!=-1) return dp[pos][k][hold];\\n        int buy=0,notbuy=0,sell=0,notsell=0;\\n\\t\\t//if k>0 and you don\\'t have pending transaction \\n        if(!hold and k) buy = solve(prices,pos+1,k-1,!hold) - prices[pos];\\n\\t\\t//if you don\\'t want to buy \\n        notbuy = solve(prices,pos+1,k,hold);\\n\\t\\t//if you have a pending transaction than only you can sell the stock\\n        if(hold) sell = solve(prices,pos+1,k,!hold) + prices[pos];\\n\\t\\t//if you don\\'t want to sell\\n        notsell = solve(prices,pos+1,k,hold);\\n        return dp[pos][k][hold] = max(max(buy,notbuy),max(sell,notsell));\\n    }\\n    \\n    int maxProfit(vector<int>& prices) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(prices,0,2,false);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1340181,
                "title": "c-o-n-time-and-o-1-space",
                "content": "This comment helped me understand how to approach the problem. https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/discuss/39611/Is-it-Best-Solution-with-O(n)-O(1)./242914\\n```\\nint maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        if (n == 0) return 0;\\n        int oneBuy = INT_MAX, twoBuy = INT_MAX, oneBuyOneSell = 0, twoBuyTwoSell = 0;\\n        for (int i = 0; i<n; i++) {\\n            int price = prices[i];\\n            oneBuy = min(oneBuy, price);\\n            oneBuyOneSell = max(oneBuyOneSell, price - oneBuy);\\n            twoBuy = min(twoBuy, price-oneBuyOneSell);\\n            twoBuyTwoSell = max(twoBuyTwoSell, price-twoBuy);\\n        }\\n        return twoBuyTwoSell;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        if (n == 0) return 0;\\n        int oneBuy = INT_MAX, twoBuy = INT_MAX, oneBuyOneSell = 0, twoBuyTwoSell = 0;\\n        for (int i = 0; i<n; i++) {\\n            int price = prices[i];\\n            oneBuy = min(oneBuy, price);\\n            oneBuyOneSell = max(oneBuyOneSell, price - oneBuy);\\n            twoBuy = min(twoBuy, price-oneBuyOneSell);\\n            twoBuyTwoSell = max(twoBuyTwoSell, price-twoBuy);\\n        }\\n        return twoBuyTwoSell;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1335204,
                "title": "simple-c-solution-using-prefix-and-suffix-arrays",
                "content": "**Special Mention: Sumeet Malik (Pepcoding on Youtube)**\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& arr) {\\n        int n = arr.size();\\n        int mini = arr[0];\\n        int maxi = arr[n-1];\\n        int profit = 0;\\n        \\n        vector<int> prefix(n);\\n        vector<int> suffix(n);\\n        \\n        //max profit if sold upto today from left\\n        for(int i = 1; i < n; i++) {\\n            prefix[i] = max(prefix[i-1], arr[i] - mini);\\n            mini = min(mini, arr[i]);\\n        }\\n        \\n        //max profit if bought upto today from right\\n        for(int i = n-2; i >= 0; i--) {\\n            suffix[i] = max(suffix[i+1], maxi - arr[i]);\\n            maxi = max(maxi, arr[i]);\\n        }\\n        \\n        for(int i = 0; i < n; i++) \\n            profit = max(profit, prefix[i] + suffix[i]);\\n        \\n        return profit;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& arr) {\\n        int n = arr.size();\\n        int mini = arr[0];\\n        int maxi = arr[n-1];\\n        int profit = 0;\\n        \\n        vector<int> prefix(n);\\n        vector<int> suffix(n);\\n        \\n        //max profit if sold upto today from left\\n        for(int i = 1; i < n; i++) {\\n            prefix[i] = max(prefix[i-1], arr[i] - mini);\\n            mini = min(mini, arr[i]);\\n        }\\n        \\n        //max profit if bought upto today from right\\n        for(int i = n-2; i >= 0; i--) {\\n            suffix[i] = max(suffix[i+1], maxi - arr[i]);\\n            maxi = max(maxi, arr[i]);\\n        }\\n        \\n        for(int i = 0; i < n; i++) \\n            profit = max(profit, prefix[i] + suffix[i]);\\n        \\n        return profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1185413,
                "title": "python-solution-with-explanation-faster-than-98",
                "content": "* We may complete at most two transactions and must sell the stock before we buy again.\\n* Suppose we make two transactions at (prices[i], prices[j]) and (prices[p], prices[q]), there is no overlapped parts between prices[i:j+1] and prices[p:q+1]\\n* If no overlapped part, why not dividing the prices into two non-overalpped array and calculate the maximum summation\\n* First we traverse from left to right, calculate the maximum profit we can earn before prices[i]\\n* Then we traverse from right to left, calculate the maximum profit we can earn after prices[j]\\n\\nclass Solution:\\n\\n    def maxProfit(self, prices: List[int]) -> int:\\n        curr_min = float(\"inf\")\\n        dp = [0]*(len(prices)+1)\\n        for i in range(len(prices)):\\n            curr_min = min(curr_min ,prices[i])\\n            dp[i+1] = max(prices[i]-curr_min, dp[i])\\n        \\n        ans = max(dp[-1], 0)\\n        curr_max = 0\\n        for j in range(len(prices)-1,0,-1):\\n            curr_max = max(curr_max, prices[j])\\n            ans = max(ans, dp[j] + curr_max - prices[j])\\n        return ans\\n\\t\\t\\n\\t\\t\\n* You may add if-else to make it faster\\n\\nclass Solution:\\n\\n    def maxProfit(self, prices: List[int]) -> int:\\n        curr_min = float(\"inf\")\\n        dp = [0]*(len(prices)+1)\\n        for i in range(len(prices)):\\n            if curr_min>prices[i]:\\n                curr_min = prices[i]\\n            dp[i+1] = max(prices[i]-curr_min, dp[i])\\n        \\n        ans = max(dp[-1], 0)\\n        curr_max = 0\\n        for j in range(len(prices)-1,0,-1):\\n            if curr_max<prices[j]:\\n                curr_max =  prices[j]\\n            ans = max(ans, dp[j] + curr_max - prices[j])\\n        return ans",
                "solutionTags": [
                    "Python"
                ],
                "code": "* We may complete at most two transactions and must sell the stock before we buy again.\\n* Suppose we make two transactions at (prices[i], prices[j]) and (prices[p], prices[q]), there is no overlapped parts between prices[i:j+1] and prices[p:q+1]\\n* If no overlapped part, why not dividing the prices into two non-overalpped array and calculate the maximum summation\\n* First we traverse from left to right, calculate the maximum profit we can earn before prices[i]\\n* Then we traverse from right to left, calculate the maximum profit we can earn after prices[j]\\n\\nclass Solution:\\n\\n    def maxProfit(self, prices: List[int]) -> int:\\n        curr_min = float(\"inf\")\\n        dp = [0]*(len(prices)+1)\\n        for i in range(len(prices)):\\n            curr_min = min(curr_min ,prices[i])\\n            dp[i+1] = max(prices[i]-curr_min, dp[i])\\n        \\n        ans = max(dp[-1], 0)\\n        curr_max = 0\\n        for j in range(len(prices)-1,0,-1):\\n            curr_max = max(curr_max, prices[j])\\n            ans = max(ans, dp[j] + curr_max - prices[j])\\n        return ans\\n\\t\\t\\n\\t\\t\\n* You may add if-else to make it faster\\n\\nclass Solution:\\n\\n    def maxProfit(self, prices: List[int]) -> int:\\n        curr_min = float(\"inf\")\\n        dp = [0]*(len(prices)+1)\\n        for i in range(len(prices)):\\n            if curr_min>prices[i]:\\n                curr_min = prices[i]\\n            dp[i+1] = max(prices[i]-curr_min, dp[i])\\n        \\n        ans = max(dp[-1], 0)\\n        curr_max = 0\\n        for j in range(len(prices)-1,0,-1):\\n            if curr_max<prices[j]:\\n                curr_max =  prices[j]\\n            ans = max(ans, dp[j] + curr_max - prices[j])\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 981360,
                "title": "java-short-solution-without-dp",
                "content": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int b1 = Integer.MAX_VALUE;\\n        int b2 = Integer.MAX_VALUE;\\n        int p1=0, p2=0;\\n        for(int i=0;i<prices.length;i++){\\n            b1 = Math.min(b1,prices[i]);\\n            p1 = Math.max(p1,prices[i]-b1);\\n            b2 = Math.min(b2,prices[i]-p1);\\n            p2 = Math.max(p2,prices[i]-b2);\\n        }\\n        return p2;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxProfit(int[] prices) {\\n        int b1 = Integer.MAX_VALUE;\\n        int b2 = Integer.MAX_VALUE;\\n        int p1=0, p2=0;\\n        for(int i=0;i<prices.length;i++){\\n            b1 = Math.min(b1,prices[i]);\\n            p1 = Math.max(p1,prices[i]-b1);\\n            b2 = Math.min(b2,prices[i]-p1);\\n            p2 = Math.max(p2,prices[i]-b2);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 937778,
                "title": "c-full-explained-code-video-o-n",
                "content": "[https://www.youtube.com/watch?v=AvXYvSPvYrk](http://)\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // Read the notes for better understanding\\n    \\n    int maxProfit(vector<int>& prices) {\\n        \\n        int n = prices.size();\\n        \\n        if(n <=1 )\\n            return 0;\\n        \\n        int mini[n] , maxi[n];\\n        \\n        int left_profit[n] , right_profit[n];\\n        int ans = 0;\\n        \\n        mini[0] = prices[0];\\n        maxi[n-1] = prices[n-1];\\n        \\n        left_profit[0] = 0;\\n        right_profit[n-1] = 0 ;\\n        \\n        // precomputing the minimum till current index form begining\\n        for(int i = 1 ;i < n ;i ++){\\n            mini[i] = min(prices[i] , mini[i-1]);\\n        }\\n        \\n        // precomputing the maximum till the current index from last\\n        for(int i = n-2 ;i >=0 ;i--){\\n            maxi[i] = max(prices[i] ,maxi[i+1]);\\n        }\\n        \\n        //computing the profit from the first transaction that is in the left part.\\n        for(int i = 1 ;i < n ;i++){\\n            left_profit[i] = max(left_profit[i-1] , prices[i] - mini[i]);\\n        }\\n        //computing the profit form the last transactio(2nd) i.e. in the right part.\\n        for(int i = n-2 ;i >= 0 ; i--){\\n            right_profit[i] = max(right_profit[i+1] , maxi[i] - prices[i]);\\n        }\\n        \\n        // Now Computing the final ans by taking the max \\n        //from all the possible additon profits from the left and rihgt part\\'s profits\\n        for(int i = 0 ;i < n ; i++)\\n            ans = max(ans , left_profit[i] + right_profit[i]);\\n        \\n            return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    // Read the notes for better understanding\\n    \\n    int maxProfit(vector<int>& prices) {\\n        \\n        int n = prices.size();\\n        \\n        if(n <=1 )\\n            return 0;\\n        \\n        int mini[n] , maxi[n];\\n        \\n        int left_profit[n] , right_profit[n];\\n        int ans = 0;\\n        \\n        mini[0] = prices[0];\\n        maxi[n-1] = prices[n-1];\\n        \\n        left_profit[0] = 0;\\n        right_profit[n-1] = 0 ;\\n        \\n        // precomputing the minimum till current index form begining\\n        for(int i = 1 ;i < n ;i ++){\\n            mini[i] = min(prices[i] , mini[i-1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 926165,
                "title": "easy-to-understand-java-solution-with-video-explanation",
                "content": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int buy1 = -prices[0], buy2 = -prices[0];\\n        int profit1 = 0, total_profit = 0;\\n        \\n        for (int price : prices) {\\n            buy1 = Math.max(buy1, -price);\\n            profit1 = Math.max(profit1, price + buy1);\\n            buy2 = Math.max(buy2, profit1 - price);\\n            total_profit = Math.max(total_profit, price + buy2);\\n        }\\n        return total_profit;\\n    }\\n}\\n```\\n\\nMy video explanation:\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/B3t3QioYKmo\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int buy1 = -prices[0], buy2 = -prices[0];\\n        int profit1 = 0, total_profit = 0;\\n        \\n        for (int price : prices) {\\n            buy1 = Math.max(buy1, -price);\\n            profit1 = Math.max(profit1, price + buy1);\\n            buy2 = Math.max(buy2, profit1 - price);\\n            total_profit = Math.max(total_profit, price + buy2);\\n        }\\n        return total_profit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796216,
                "title": "c-best-time-to-buy-and-sell-stock-iii-dp-memoization",
                "content": "DP Memoized (200/200)\\n```\\nclass Solution {\\npublic:\\n    \\n    int maxPUtil(vector<int> &prices, int i, int buyOrSell, int k, unordered_map<string, int> &dp){\\n        if(i>=prices.size() || k==0)\\n            return 0;\\n        string key=to_string(i)+to_string(buyOrSell)+to_string(k);\\n        if(dp.find(key)!=dp.end()) return dp[key];\\n        int res=0;\\n        if(buyOrSell==0){\\n            int buy=maxPUtil(prices, i+1, 1, k, dp)-prices[i];\\n            int noBuy=maxPUtil(prices, i+1, 0, k, dp);\\n            res+=max(buy, noBuy);\\n        } else {\\n            int sell=maxPUtil(prices, i+1, 0, k-1, dp)+prices[i];\\n            int noSell=maxPUtil(prices, i+1, 1, k, dp);\\n            res+=max(sell, noSell);\\n        }\\n        dp[key]=res;\\n        return res;\\n    }\\n    \\n    int maxProfit(vector<int>& prices) {\\n        unordered_map<string, int> dp;\\n        return maxPUtil(prices, 0, 0, 2, dp);  // <prices, i, buyOrSell, k, dp>     buy-->0   sell-->1 \\n    }\\n};\\n```\\n\\nRecursive (TLE) (198/200)\\n```\\nclass Solution {\\npublic:\\n    \\n    int maxPUtil(vector<int> &prices, int i, int buyOrSell, int k){\\n        if(i>=prices.size() || k==0)\\n            return 0;\\n        int res=0;\\n        if(buyOrSell==0){\\n            int buy=maxPUtil(prices, i+1, 1, k)-prices[i];\\n            int noBuy=maxPUtil(prices, i+1, 0, k);\\n            res+=max(buy, noBuy);\\n        } else {\\n            int sell=maxPUtil(prices, i+1, 0, k-1)+prices[i];\\n            int noSell=maxPUtil(prices, i+1, 1, k);\\n            res+=max(sell, noSell);\\n        }\\n        return res;\\n    }\\n    \\n    int maxProfit(vector<int>& prices) {\\n        return maxPUtil(prices, 0, 0, 2);  // <prices, i, buyOrSell, k>     buy-->0   sell-->1 \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int maxPUtil(vector<int> &prices, int i, int buyOrSell, int k, unordered_map<string, int> &dp){\\n        if(i>=prices.size() || k==0)\\n            return 0;\\n        string key=to_string(i)+to_string(buyOrSell)+to_string(k);\\n        if(dp.find(key)!=dp.end()) return dp[key];\\n        int res=0;\\n        if(buyOrSell==0){\\n            int buy=maxPUtil(prices, i+1, 1, k, dp)-prices[i];\\n            int noBuy=maxPUtil(prices, i+1, 0, k, dp);\\n            res+=max(buy, noBuy);\\n        } else {\\n            int sell=maxPUtil(prices, i+1, 0, k-1, dp)+prices[i];\\n            int noSell=maxPUtil(prices, i+1, 1, k, dp);\\n            res+=max(sell, noSell);\\n        }\\n        dp[key]=res;\\n        return res;\\n    }\\n    \\n    int maxProfit(vector<int>& prices) {\\n        unordered_map<string, int> dp;\\n        return maxPUtil(prices, 0, 0, 2, dp);  // <prices, i, buyOrSell, k, dp>     buy-->0   sell-->1 \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int maxPUtil(vector<int> &prices, int i, int buyOrSell, int k){\\n        if(i>=prices.size() || k==0)\\n            return 0;\\n        int res=0;\\n        if(buyOrSell==0){\\n            int buy=maxPUtil(prices, i+1, 1, k)-prices[i];\\n            int noBuy=maxPUtil(prices, i+1, 0, k);\\n            res+=max(buy, noBuy);\\n        } else {\\n            int sell=maxPUtil(prices, i+1, 0, k-1)+prices[i];\\n            int noSell=maxPUtil(prices, i+1, 1, k);\\n            res+=max(sell, noSell);\\n        }\\n        return res;\\n    }\\n    \\n    int maxProfit(vector<int>& prices) {\\n        return maxPUtil(prices, 0, 0, 2);  // <prices, i, buyOrSell, k>     buy-->0   sell-->1 \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794892,
                "title": "best-recursion-solution-with-explanation-memoization-c",
                "content": "At any given postion we can either buy or sell state but we can also choose to ignore. I\\'ve taken `flag`  as `0` for buy state and `1` for sell state and I\\'ve taken `count` to keep track of number to sales.\\n\\nRead comments for furthure explanation.\\n\\n```\\npublic class Solution {\\n    public int MaxProfit(int[] prices) {\\n        int[,,] dp = new int[prices.Length, 2, 3]; // 2 is for the two states (`flag`) and 3 is for `count`\\n        \\n        for(int i = 0; i < prices.Length; i++) {\\n            for(int j = 0; j < 2; j++) {\\n                for(int k = 0; k < 3; k++) {\\n                    dp[i,j,k] = -1;\\n                }\\n            }\\n        }\\n        \\n        return MaxProfitUtil(dp, prices, 0, 0, 2);\\n    }\\n    \\n    private int MaxProfitUtil(int[,,] dp, int[] prices, int flag, int index, int count) {\\n        if(index >= prices.Length || count == 0) // two transaction completed or index outta range\\n            return 0;\\n        \\n        if(dp[index, flag, count] != -1) // value calculated previously\\n            return dp[index, flag, count];\\n        \\n        if(flag == 1) // bought\\n            dp[index, flag, count] = Math.Max(MaxProfitUtil(dp, prices, 0, index + 1, count - 1) + prices[index], // sell\\n                            MaxProfitUtil(dp, prices, flag, index + 1, count)); // ignore\\n        else\\n            dp[index, flag, count] = Math.Max(MaxProfitUtil(dp, prices, 1, index + 1, count) - prices[index], // buy\\n                            MaxProfitUtil(dp, prices, flag, index + 1, count)); // ignore\\n        \\n        return dp[index, flag, count];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxProfit(int[] prices) {\\n        int[,,] dp = new int[prices.Length, 2, 3]; // 2 is for the two states (`flag`) and 3 is for `count`\\n        \\n        for(int i = 0; i < prices.Length; i++) {\\n            for(int j = 0; j < 2; j++) {\\n                for(int k = 0; k < 3; k++) {\\n                    dp[i,j,k] = -1;\\n                }\\n            }\\n        }\\n        \\n        return MaxProfitUtil(dp, prices, 0, 0, 2);\\n    }\\n    \\n    private int MaxProfitUtil(int[,,] dp, int[] prices, int flag, int index, int count) {\\n        if(index >= prices.Length || count == 0) // two transaction completed or index outta range\\n            return 0;\\n        \\n        if(dp[index, flag, count] != -1) // value calculated previously\\n            return dp[index, flag, count];\\n        \\n        if(flag == 1) // bought\\n            dp[index, flag, count] = Math.Max(MaxProfitUtil(dp, prices, 0, index + 1, count - 1) + prices[index], // sell\\n                            MaxProfitUtil(dp, prices, flag, index + 1, count)); // ignore\\n        else\\n            dp[index, flag, count] = Math.Max(MaxProfitUtil(dp, prices, 1, index + 1, count) - prices[index], // buy\\n                            MaxProfitUtil(dp, prices, flag, index + 1, count)); // ignore\\n        \\n        return dp[index, flag, count];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794850,
                "title": "java-top-down",
                "content": "The answer is pretty straight forward where we need to generate all to the max possibility to buy stock. But in this case, we need 2 key for memoization \\nwhere the first one is the index of the stock and the second is how many stocks have you bought.\\n\\n```\\npublic static int maxProfit(int[] prices) {\\n        return maxProfitHelper(prices, 0, 0, new Integer[prices.length+1][3]);\\n    }\\n\\n    public static int maxProfitHelper(int [] prices, int count, int index, Integer [][]memo){\\n        if (index == prices.length || count==2)\\n            return 0;\\n\\n        if (memo[index][count] != null)\\n            return memo[index][count];\\n\\n        int current = 0;\\n        for (int x = index+1; x<prices.length;x++){\\n            if (prices[index] < prices[x]){\\n                int price = prices[x] - prices[index];\\n                int recur = maxProfitHelper(prices, count + 1, x + 1, memo);\\n                current = Math.max(current, price + recur);\\n            }\\n        }\\n        current = Math.max(maxProfitHelper(prices, count, index + 1, memo), current);\\n        memo[index][count] = current;\\n        return memo[index][count];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic static int maxProfit(int[] prices) {\\n        return maxProfitHelper(prices, 0, 0, new Integer[prices.length+1][3]);\\n    }\\n\\n    public static int maxProfitHelper(int [] prices, int count, int index, Integer [][]memo){\\n        if (index == prices.length || count==2)\\n            return 0;\\n\\n        if (memo[index][count] != null)\\n            return memo[index][count];\\n\\n        int current = 0;\\n        for (int x = index+1; x<prices.length;x++){\\n            if (prices[index] < prices[x]){\\n                int price = prices[x] - prices[index];\\n                int recur = maxProfitHelper(prices, count + 1, x + 1, memo);\\n                current = Math.max(current, price + recur);\\n            }\\n        }\\n        current = Math.max(maxProfitHelper(prices, count, index + 1, memo), current);\\n        memo[index][count] = current;\\n        return memo[index][count];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 787083,
                "title": "simple-dp-solution-with-explaination",
                "content": "here idea is first get profit from buying and selling one stock and then from this profit buy another stock (subtract cost of buying price from current profit) and then sell it to get more profit.\\n\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if len(prices)==0:return 0\\n        total_profit = itmd_profit = 0\\n        b1 = prices[0]       \\n        b2 = float(\\'inf\\')\\n        \\n        for i in range(1,len(prices)):\\n            b1 = min(b1,prices[i])\\n            itmd_profit = max(itmd_profit,prices[i]-b1)\\n            b2 = min(b2,prices[i]-itmd_profit)\\n            total_profit = max(total_profit,prices[i]-b2)\\n        return total_profit\\n\\t\\t\\n\\t\\t# if you understood this then please appreciate it",
                "solutionTags": [],
                "code": "here idea is first get profit from buying and selling one stock and then from this profit buy another stock (subtract cost of buying price from current profit) and then sell it to get more profit.\\n\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if len(prices)==0:return 0\\n        total_profit = itmd_profit = 0\\n        b1 = prices[0]       \\n        b2 = float(\\'inf\\')\\n        \\n        for i in range(1,len(prices)):\\n            b1 = min(b1,prices[i])\\n            itmd_profit = max(itmd_profit,prices[i]-b1)\\n            b2 = min(b2,prices[i]-itmd_profit)\\n            total_profit = max(total_profit,prices[i]-b2)\\n        return total_profit\\n\\t\\t\\n\\t\\t# if you understood this then please appreciate it",
                "codeTag": "Java"
            },
            {
                "id": 564239,
                "title": "simple-2-pass-java-explanatory-code",
                "content": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        if(prices.length < 2) return 0;\\n        \\n        //Check if the combination of 2 transactions is greater than 1\\n        //Gather highest profit for 1 transaction\\n        int[] maxProfitTillHere = new int[prices.length];\\n        int minPrice = Integer.MAX_VALUE; \\n        int maxProfit = 0;\\n        for(int i = 0; i < prices.length; i++) {\\n            minPrice = Math.min(minPrice, prices[i]);\\n            maxProfit = Math.max(maxProfit, prices[i] - minPrice);\\n            maxProfitTillHere[i] = maxProfit;\\n        }\\n        \\n        int higestPriceFromEnd = prices[prices.length - 1];\\n        for(int i = prices.length - 1; i >= 0; i--) {\\n            higestPriceFromEnd = Math.max(higestPriceFromEnd, prices[i]);\\n            maxProfit = Math.max(maxProfit, higestPriceFromEnd - prices[i] + maxProfitTillHere[i]);\\n        }\\n        \\n        return maxProfit;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxProfit(int[] prices) {\\n        if(prices.length < 2) return 0;\\n        \\n        //Check if the combination of 2 transactions is greater than 1\\n        //Gather highest profit for 1 transaction\\n        int[] maxProfitTillHere = new int[prices.length];\\n        int minPrice = Integer.MAX_VALUE; \\n        int maxProfit = 0;\\n        for(int i = 0; i < prices.length; i++) {\\n            minPrice = Math.min(minPrice, prices[i]);\\n            maxProfit = Math.max(maxProfit, prices[i] - minPrice);\\n            maxProfitTillHere[i] = maxProfit;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 359431,
                "title": "c-o-1-space-and-o-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        \\n        \\n        int x = prices.size();\\n        if(x==0){\\n            return 0;\\n        }\\n        int n = min(2,x);\\n        vector<int> buy(n,INT_MAX);\\n        vector<int> sell(n,INT_MIN);\\n        \\n        for(auto &price: prices) {\\n            for(int i=0; i<n; i++) {\\n                buy[i] = min(buy[i], (i==0?price:price-sell[i-1]));\\n                sell[i] = max(sell[i], price-buy[i]);\\n            }\\n        }\\n        \\n        return sell[n-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        \\n        \\n        int x = prices.size();\\n        if(x==0){\\n            return 0;\\n        }\\n        int n = min(2,x);\\n        vector<int> buy(n,INT_MAX);\\n        vector<int> sell(n,INT_MIN);\\n        \\n        for(auto &price: prices) {\\n            for(int i=0; i<n; i++) {\\n                buy[i] = min(buy[i], (i==0?price:price-sell[i-1]));\\n                sell[i] = max(sell[i], price-buy[i]);\\n            }\\n        }\\n        \\n        return sell[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 350323,
                "title": "c-dp-evolution-from-tle-to-100",
                "content": "The idea for solving this problem using DP is to figure out on which days do we sell. For generality, I will use ```tmax``` to represent the number of maximum transactions. For this problem it is ```2```. \\n\\n**Naive DP (TLE for last test case)**\\n\\nThe DP relation can be written as:\\n\\n```dp[i][j] = max(dp[i][j-1], prices[j] - prices[k] + dp[i-1][k-1]; for k = [0 ... j-1]```\\n\\n```i``` is the ```i```th transaction, starting from ```0```. ```j``` is the day we choose to **sell** the ```i```th stock. ```dp[i][j]``` is the maximum money we can make by at most ```i```th transaction on the ```j```th day. This DP expression can be translated as:\\n\\n**The most money we can make in ```i``` transactions with the ```i```th transaction up to the  ```j```th day is the maximum of:**\\n**1. The maximum amount of money we can make by ```j-1```th day\\n2. The maximum amount of money we can make if we sold the stock on the ```j``` day.**\\n\\n**1** Is straight forward. It is just ```dp[i][j-1]```. **2** Can be calculated. If we sold on the ```j```th day, then that must means we _bought_ stock on some day ```k``` where ```k <= j-1```, since we cannot buy and sell on the same day. Furthermore, if we bought stock on the ```k```th day, then that implies we can make at most ```dp[i-1][k-1]``` amount of money from the previous transactions. Thus, the total amount of money is ```prices[j] - prices[k] + dp[i-1][k-1]```. Obviously we want the maximum amount, so we need to go through ```k = [0, j-1]``` to figure out which ```k``` gives the max amount.  This completes the DP.\\n\\n**Implementation Details**\\n1. Notice that for ```k = 0```, ```dp[i-1][k-1]``` is out of bounds. However, by intuition we know that if we start the ```i```th transaction by buying on day 0, then we cannot buy using ```0 ... i-1```th transaction, since they would have to be completed before day 0, which is not possible. Thus, the maximum amount of money is simply ```prices[j] - prices[0]```. since ```dp[i-1][k-1] = 0```. Thus, we can skip ```k=0```, and set initial money to ```prices[j] - prices[0]``` to avoid the out of bounds.\\n\\n2. We want to start ```j``` at 1, because we cannot sell on day 0 (cannot sell and buy on same day).\\n\\n3. We initiate transaction 0 as a vector of zeros, since no money can be made without a transaction.\\n\\n**Issues**\\n1. Unfortunately, we get TLE for the last test case. This is because the complexity of this solution is ```O(kn^2)```.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int tmax = 2, size = prices.size();\\n        if(size < 2) return 0;\\n        vector<vector<int>> dp(tmax+1, vector<int>(size, 0));\\n        for(int i = 1; i <= tmax; ++i) {\\n            for(int j = 1; j < size; ++j) {\\n                int maxMoney = prices[j]-prices[0];\\n                for(int k = 1; k < j; ++k) {\\n                    maxMoney = max(maxMoney, prices[j] - prices[k] + dp[i-1][k-1]);\\n                }\\n                dp[i][j] = max(dp[i][j-1], maxMoney);\\n            }\\n        }   \\n        return dp[tmax][size-1];\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```\\n\\n______________________________________________________________________________________________\\n\\n\\n**Improved DP (98%)**\\n\\nTo avoid TLE, we must improve our run-time. If we look at our inner-loop calculating ```prices[j] - prices[k] + dp[i-1][k-1]```, we can split that into two parts; ```prices[j]``` and ```-prices[k] + dp[i-1][k-1]```. To maximize ```prices[j] - prices[k] + dp[i-1][k-1]```, we only need to look for the maximum ```-prices[k] + dp[i-1][k-1]```. If we look at the second loop, we will iterate through ```j = [0, size-1]```. Thus, for ```j = 1```, we would calculate the maximum of ```-prices[k] + dp[i-1][k-1]``` for ```k = 0``` only, and for ```j = 2``` we would calculate ```-prices[k] + dp[i-1][k-1]``` for ```k = [0, 1]``` only, etc. From this it is clear that:\\n\\n**for any ```j```, ```max(-prices[k] + dp[i-1][k-1]) for k = [0 ... j-1] = max(max(-prices[k] + dp[i-1][k-1]) for k = [0 ... j-2]), -prices[j-1] + dp[i-1][j-2])```**\\n\\nIn other words, we can start by directly plugging in maximum value of ```-prices[k] + dp[i-1][j-1]``` as ```-prices[0]``` for ```j = 1```, and then for ```j = 2,```  ```maxMoney = max(maxMoney, -prices[j] + dp[i-1][j-1])```, etc. until ```j = size-1```. Then, ```dp[i][j] = max(dp[i][j-1], prices[j] + maxMoney)```. This way, we can avoid the inner loop, which saves ```O(n)``` time, making the run-time ```O(kn)```.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int tmax = 2, size = prices.size();\\n        if(size < 2) return 0;\\n        vector<vector<int>> dp(tmax+1, vector<int>(size, 0));\\n        for(int i = 1; i <= tmax; ++i) {\\n            int maxMoney = -prices[0];\\n            for(int j = 1; j < size; ++j) {\\n                maxMoney = max(maxMoney, -prices[j] + dp[i-1][j-1]);\\n                dp[i][j] = max(dp[i][j-1], prices[j] + maxMoney);\\n            }\\n        }   \\n        return dp[tmax][size-1];\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```\\n\\n______________________________________________________________________________________________\\n\\n**Improved DP w/ space optimization (100%)**\\n\\nBecause we only need ```dp[i-1][j-1]``` and ```dp[i][j-1]```, we only need to save ```dp[i-1][j-1]``` for ```dp[i][j]```. Thus, we can reduce space complexity from ```O(kn)``` to ```O(n)``` by using a single vector. Before overwriting ```dp[i][j]```, we save it using a ```tmp``` variable, and recall it later for ```dp[i][j+1]```, which would require ```dp[i-1][j]```, which is the value we saved in ```tmp```.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int tmax = 2, size = prices.size();\\n        if(size < 2) return 0;\\n        vector<int> dp(size, 0);\\n        for(int i = 1; i <= tmax; ++i) {\\n            int maxMoney = -prices[0], tmp = dp[0];\\n            for(int j = 1; j < size; ++j) {\\n                maxMoney = max(maxMoney, -prices[j] + tmp);\\n                tmp = dp[j];\\n                dp[j] = max(dp[j-1], prices[j] + maxMoney);\\n            }\\n        }   \\n        return dp[size-1];\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```\\n\\n_______________________________________________________________________________________________________\\n\\n**Improved DP with O(k) space optimization 100% time, 98% space** \\n\\nFor this problem, to get ```i, j``` we need ```i-1, j-1``` and ```i, j-1```. Thus, we can actually fill in the DP matrix by columns. Thus, we swap the order of the for loops. Because we need to record a max value for ```-prices[j] + prices[i-1][j-1]```, we will need a vector of size ```k``` to save the max values for each ```i```th transaction.\\n\\nBecause to get ```i, j``` we only need ```i-1, j-1``` and ```i, j-1```, we can actually eliminate the column dimension, by going over ```i``` in reverse. This way, we reduce the total space usage to ```O(k)```.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int tmax = 2, size = prices.size();\\n        if(size < 2) return 0;\\n        vector<int> dp(tmax+1, 0);\\n        vector<int> maxMoney(tmax+1, -prices[0]);\\n        \\n        for(int j = 1; j < size; ++j) {\\n            for(int i = tmax; i >= 1; --i) {\\n                maxMoney[i] = max(maxMoney[i], -prices[j] + dp[i-1]);\\n                dp[i] = max(dp[i], prices[j] + maxMoney[i]);\\n            }\\n        }   \\n        return dp[tmax];\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n\\n```",
                "solutionTags": [],
                "code": "```tmax```\n```2```\n```dp[i][j] = max(dp[i][j-1], prices[j] - prices[k] + dp[i-1][k-1]; for k = [0 ... j-1]```\n```i```\n```i```\n```0```\n```j```\n```i```\n```dp[i][j]```\n```i```\n```j```\n```i```\n```i```\n```j```\n```j-1```\n```j```\n```dp[i][j-1]```\n```j```\n```k```\n```k <= j-1```\n```k```\n```dp[i-1][k-1]```\n```prices[j] - prices[k] + dp[i-1][k-1]```\n```k = [0, j-1]```\n```k```\n```k = 0```\n```dp[i-1][k-1]```\n```i```\n```0 ... i-1```\n```prices[j] - prices[0]```\n```dp[i-1][k-1] = 0```\n```k=0```\n```prices[j] - prices[0]```\n```j```\n```O(kn^2)```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int tmax = 2, size = prices.size();\\n        if(size < 2) return 0;\\n        vector<vector<int>> dp(tmax+1, vector<int>(size, 0));\\n        for(int i = 1; i <= tmax; ++i) {\\n            for(int j = 1; j < size; ++j) {\\n                int maxMoney = prices[j]-prices[0];\\n                for(int k = 1; k < j; ++k) {\\n                    maxMoney = max(maxMoney, prices[j] - prices[k] + dp[i-1][k-1]);\\n                }\\n                dp[i][j] = max(dp[i][j-1], maxMoney);\\n            }\\n        }   \\n        return dp[tmax][size-1];\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```\n```prices[j] - prices[k] + dp[i-1][k-1]```\n```prices[j]```\n```-prices[k] + dp[i-1][k-1]```\n```prices[j] - prices[k] + dp[i-1][k-1]```\n```-prices[k] + dp[i-1][k-1]```\n```j = [0, size-1]```\n```j = 1```\n```-prices[k] + dp[i-1][k-1]```\n```k = 0```\n```j = 2```\n```-prices[k] + dp[i-1][k-1]```\n```k = [0, 1]```\n```j```\n```max(-prices[k] + dp[i-1][k-1]) for k = [0 ... j-1] = max(max(-prices[k] + dp[i-1][k-1]) for k = [0 ... j-2]), -prices[j-1] + dp[i-1][j-2])```\n```-prices[k] + dp[i-1][j-1]```\n```-prices[0]```\n```j = 1```\n```j = 2,```\n```maxMoney = max(maxMoney, -prices[j] + dp[i-1][j-1])```\n```j = size-1```\n```dp[i][j] = max(dp[i][j-1], prices[j] + maxMoney)```\n```O(n)```\n```O(kn)```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int tmax = 2, size = prices.size();\\n        if(size < 2) return 0;\\n        vector<vector<int>> dp(tmax+1, vector<int>(size, 0));\\n        for(int i = 1; i <= tmax; ++i) {\\n            int maxMoney = -prices[0];\\n            for(int j = 1; j < size; ++j) {\\n                maxMoney = max(maxMoney, -prices[j] + dp[i-1][j-1]);\\n                dp[i][j] = max(dp[i][j-1], prices[j] + maxMoney);\\n            }\\n        }   \\n        return dp[tmax][size-1];\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```\n```dp[i-1][j-1]```\n```dp[i][j-1]```\n```dp[i-1][j-1]```\n```dp[i][j]```\n```O(kn)```\n```O(n)```\n```dp[i][j]```\n```tmp```\n```dp[i][j+1]```\n```dp[i-1][j]```\n```tmp```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int tmax = 2, size = prices.size();\\n        if(size < 2) return 0;\\n        vector<int> dp(size, 0);\\n        for(int i = 1; i <= tmax; ++i) {\\n            int maxMoney = -prices[0], tmp = dp[0];\\n            for(int j = 1; j < size; ++j) {\\n                maxMoney = max(maxMoney, -prices[j] + tmp);\\n                tmp = dp[j];\\n                dp[j] = max(dp[j-1], prices[j] + maxMoney);\\n            }\\n        }   \\n        return dp[size-1];\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```\n```i, j```\n```i-1, j-1```\n```i, j-1```\n```-prices[j] + prices[i-1][j-1]```\n```k```\n```i```\n```i, j```\n```i-1, j-1```\n```i, j-1```\n```i```\n```O(k)```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int tmax = 2, size = prices.size();\\n        if(size < 2) return 0;\\n        vector<int> dp(tmax+1, 0);\\n        vector<int> maxMoney(tmax+1, -prices[0]);\\n        \\n        for(int j = 1; j < size; ++j) {\\n            for(int i = tmax; i >= 1; --i) {\\n                maxMoney[i] = max(maxMoney[i], -prices[j] + dp[i-1]);\\n                dp[i] = max(dp[i], prices[j] + maxMoney[i]);\\n            }\\n        }   \\n        return dp[tmax];\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 321044,
                "title": "c-85-99-9-beat-linear-o-n-solution-fast-track",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        \\n        if (prices.size() <= 0) { return 0; }\\n        \\n        int aBuy2 = -prices[0];\\n        int aSell2 = 0;\\n        int aBuy1 = -prices[0];\\n        int aSell1 = 0;\\n        \\n        for (int i=1;i<prices.size();i++) {\\n            aSell2 = max(aSell2, aBuy2 + prices[i]);\\n            aBuy2 = max(aBuy2, aSell1 - prices[i]);\\n            aSell1 = max(aSell1, aBuy1 + prices[i]);\\n            aBuy1 = max(aBuy1, -prices[i]);\\n        }   \\n        return aSell2;\\n    }\\n};\\n```\\n\\nI am still learning why this works. Does the same logic extend to 3 days?",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        \\n        if (prices.size() <= 0) { return 0; }\\n        \\n        int aBuy2 = -prices[0];\\n        int aSell2 = 0;\\n        int aBuy1 = -prices[0];\\n        int aSell1 = 0;\\n        \\n        for (int i=1;i<prices.size();i++) {\\n            aSell2 = max(aSell2, aBuy2 + prices[i]);\\n            aBuy2 = max(aBuy2, aSell1 - prices[i]);\\n            aSell1 = max(aSell1, aBuy1 + prices[i]);\\n            aBuy1 = max(aBuy1, -prices[i]);\\n        }   \\n        return aSell2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 39651,
                "title": "c-3ms-o-n-time-o-1-space",
                "content": "This solution is based on the [Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/), the one which allows at most one transaction. If we handle one additional special case, then we can use the same approach to figure out the two most profitable transactions also.\\n\\n1. First the non-special simple use case. For example -- Consider the stock prices {3, 2, 3, 5, 8, 3, 8, 2, 6}, the best transaction is (8 - 2) and the second best is (8 - 3) which is incidentally after the best one. So just run two iterative searches and we have the solution.\\n\\n2. Now the special case: Here the most profitable transaction might involve splitting of the one best transaction into two. For example, consider the set {1, 2, 4, 2, 5, 7, 2, 4, 9, 0}. One best transaction would be (9 - 1), but the two best transactions would involve dividing that into two separate trades -- (7 - 1) & (9 - 2). To figure out this split we should look for the maximum loss making transaction within this (1 - 9) range. Basic idea is that the most loss making transaction would be flanked by the two most profitable ones!!! \\n\\n![alt text](https://tekrants.files.wordpress.com/2016/10/lossprofit.jpg)\\n \\n\\nC implementation with comments is given below. This method may not be that elegant, but seems easier to grasp.\\n\\n```\\nint maxProfit(int* p, int pSize)\\n{\\n    int min_d, max_d, dummy1, dummy2;\\n    int p1, p2, p3, p4, l;\\n\\n    /* 1. Find the transaction with the maximum profit */\\n    p1 = MaxProfit(p, 0, pSize - 1, &max_d, &min_d);\\n\\n    /* 2. Now find max profit on both sides of the above range\\n          (min_d to max_d) */\\n    p2 = MaxProfit(p, 0, min_d - 1, &dummy1, &dummy2);\\n    p3 = MaxProfit(p, max_d + 1, pSize - 1, &dummy1, &dummy2);\\n\\n    /* 3. Find the maximum loss making transaction within the range\\n       min_d to max_d. The idea is that the transactions on both sides\\n       of the maximum loss making fall would add up to maximum profit. */\\n    l = MaxLoss(p, min_d, max_d, &dummy1, &dummy2);\\n    p4 = p1 - l + (l * 2); // calculate the profit\\n\\n    /* Now return the larger combination. */\\n    p1 = (p1 + p2 > p1 + p3) ?  p1 + p2 : p1 + p3;\\n    return p1 > p4 ? p1 : p4;\\n}\\n\\nint MaxProfit(int *p, int start, int end, int *max_d, int *min_d)\\n{\\n    int i, maxp = 0, minp = start;\\n\\n    *max_d = *min_d = start; // initialize dates to start\\n\\n    for (i = start + 1; i <= end; ++i) {\\n        if (maxp < p[i] - p[minp]) { // update sell date to maximize profit\\n            maxp = p[i] - p[minp];\\n            *max_d = i;\\n            *min_d = minp;\\n        }\\n        minp = (p[minp] >= p[i]) ? i : minp; // update possible buy date\\n    }\\n    /* Return the value */\\n    return p[*max_d] - p[*min_d];\\n}\\n\\nint MaxLoss(int *p, int start, int end, int *max_d, int *min_d)\\n{\\n    int i, maxp = 0, mp = start;\\n    *max_d = *min_d = start; // initialize dates to start\\n\\n    for (i = start + 1; i <= end; ++i) {\\n        if (maxp < p[mp] - p[i]) { // update sell date to maximize loss\\n            maxp = p[mp] - p[i];\\n            *max_d = mp;\\n            *min_d = i;\\n        }\\n        mp = (p[mp] <= p[i]) ? i : mp; // update possible buy date\\n    }\\n\\n    /* Return the max loss */\\n    return p[*max_d] - p[*min_d];\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint maxProfit(int* p, int pSize)\\n{\\n    int min_d, max_d, dummy1, dummy2;\\n    int p1, p2, p3, p4, l;\\n\\n    /* 1. Find the transaction with the maximum profit */\\n    p1 = MaxProfit(p, 0, pSize - 1, &max_d, &min_d);\\n\\n    /* 2. Now find max profit on both sides of the above range\\n          (min_d to max_d) */\\n    p2 = MaxProfit(p, 0, min_d - 1, &dummy1, &dummy2);\\n    p3 = MaxProfit(p, max_d + 1, pSize - 1, &dummy1, &dummy2);\\n\\n    /* 3. Find the maximum loss making transaction within the range\\n       min_d to max_d. The idea is that the transactions on both sides\\n       of the maximum loss making fall would add up to maximum profit. */\\n    l = MaxLoss(p, min_d, max_d, &dummy1, &dummy2);\\n    p4 = p1 - l + (l * 2); // calculate the profit\\n\\n    /* Now return the larger combination. */\\n    p1 = (p1 + p2 > p1 + p3) ?  p1 + p2 : p1 + p3;\\n    return p1 > p4 ? p1 : p4;\\n}\\n\\nint MaxProfit(int *p, int start, int end, int *max_d, int *min_d)\\n{\\n    int i, maxp = 0, minp = start;\\n\\n    *max_d = *min_d = start; // initialize dates to start\\n\\n    for (i = start + 1; i <= end; ++i) {\\n        if (maxp < p[i] - p[minp]) { // update sell date to maximize profit\\n            maxp = p[i] - p[minp];\\n            *max_d = i;\\n            *min_d = minp;\\n        }\\n        minp = (p[minp] >= p[i]) ? i : minp; // update possible buy date\\n    }\\n    /* Return the value */\\n    return p[*max_d] - p[*min_d];\\n}\\n\\nint MaxLoss(int *p, int start, int end, int *max_d, int *min_d)\\n{\\n    int i, maxp = 0, mp = start;\\n    *max_d = *min_d = start; // initialize dates to start\\n\\n    for (i = start + 1; i <= end; ++i) {\\n        if (maxp < p[mp] - p[i]) { // update sell date to maximize loss\\n            maxp = p[mp] - p[i];\\n            *max_d = mp;\\n            *min_d = i;\\n        }\\n        mp = (p[mp] <= p[i]) ? i : mp; // update possible buy date\\n    }\\n\\n    /* Return the max loss */\\n    return p[*max_d] - p[*min_d];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3676305,
                "title": "easy-solution-dp-o-n",
                "content": "# Intuition \\nThe problem clearly says that there can be only \\'BSBS\\'. We can\\'t do \\'BBSS\\'.\\nso, my intution was to find :\\n1. The Best buying point if selling point is today or before.\\n2. Best selling point, if the buying point is today or after that. \\n\\nAnd store the maximum profit at that particular point. i.e. sum of max. profit if it is consider selling point and max. profit if it is consider buying point.\\n\\n= max(selling point profit) + max(buying point profit)\\n\\n# Approach\\nHere, I have taken 2 dp arrays. the first dp array is treating every point as selling point. here, we are taking buying point as minimum of all the previous values. profit is max((minimum of all prev. prices)- prices[i]). similarly, the second dp is treating every point as buying point and for this we have to move in reverse direction i.e. from last to first. here profit would be max(prices[i]- (maximum of all last. prices)).\\n\\nOnce, we have obtained these 2 values we have to find the maximum sum of these two values across all points.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n    \\n    int len = prices.size();\\n    int dp1[len];\\n    int profit1 = 0;\\n    int minima = prices[0];\\n    dp1[0] = 0;\\n\\n\\n    for(int i = 1; i<prices.size(); i++){\\n    if(prices[i] < minima){\\n    minima = prices[i];\\n    }\\n    profit1 = prices[i]-minima;\\n    if(profit1 > dp1[i-1]){\\n    dp1[i] = profit1;\\n    }else{\\n    dp1[i] = dp1[i-1];\\n    }\\n    }\\n\\n    int dp2[len];\\n    int profit2 = 0;\\n    dp2[len-1] = 0;\\n    int maxima = prices[len-1];\\n\\n    for(int j = len-2; j>=0; j--){\\n    if(prices[j] > maxima){\\n    maxima = prices[j];\\n    }\\n    profit2 = maxima - prices[j];\\n    if(profit2 > dp2[j+1]){\\n    dp2[j] = profit2;\\n    }\\n    else{\\n    dp2[j] = dp2[j+1];\\n    }\\n    }\\n    int maxima_profit = 0;\\n    for(int i = 0; i<prices.size(); i++){\\n        if(dp1[i]+dp2[i]>maxima_profit){\\n        maxima_profit = dp1[i]+dp2[i];\\n        }\\n    }\\n    return maxima_profit;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n    \\n    int len = prices.size();\\n    int dp1[len];\\n    int profit1 = 0;\\n    int minima = prices[0];\\n    dp1[0] = 0;\\n\\n\\n    for(int i = 1; i<prices.size(); i++){\\n    if(prices[i] < minima){\\n    minima = prices[i];\\n    }\\n    profit1 = prices[i]-minima;\\n    if(profit1 > dp1[i-1]){\\n    dp1[i] = profit1;\\n    }else{\\n    dp1[i] = dp1[i-1];\\n    }\\n    }\\n\\n    int dp2[len];\\n    int profit2 = 0;\\n    dp2[len-1] = 0;\\n    int maxima = prices[len-1];\\n\\n    for(int j = len-2; j>=0; j--){\\n    if(prices[j] > maxima){\\n    maxima = prices[j];\\n    }\\n    profit2 = maxima - prices[j];\\n    if(profit2 > dp2[j+1]){\\n    dp2[j] = profit2;\\n    }\\n    else{\\n    dp2[j] = dp2[j+1];\\n    }\\n    }\\n    int maxima_profit = 0;\\n    for(int i = 0; i<prices.size(); i++){\\n        if(dp1[i]+dp2[i]>maxima_profit){\\n        maxima_profit = dp1[i]+dp2[i];\\n        }\\n    }\\n    return maxima_profit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3673937,
                "title": "c-dp-recursion-memoization",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int c(int buy,int m,vector<int>&p,int i,vector<vector<vector<int>>>&dp){\\n        if(i>=p.size() || m<=0){\\n            return 0;\\n        }\\n        if(dp[i][buy][m]!=-1)return dp[i][buy][m];\\n        int ans=c(buy,m,p,i+1,dp);\\n        if(buy){\\n            ans = max (ans , -p[i] + c(1-buy,m,p,i+1,dp));\\n        }\\n        else{\\n            ans = max(ans, p[i] + c(1-buy,m-1,p,i+1,dp));\\n        }\\n        return dp[i][buy][m]=ans;\\n    }\\n    int maxProfit(vector<int>& p) {\\n        vector<vector<vector<int>>>dp(p.size(),vector<vector<int>>(2,vector<int>(3,-1)));\\n     return c(1,2,p,0,dp);   \\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/79df51b9-619f-4eab-85d4-786325b73cd2_1687531191.8378255.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int c(int buy,int m,vector<int>&p,int i,vector<vector<vector<int>>>&dp){\\n        if(i>=p.size() || m<=0){\\n            return 0;\\n        }\\n        if(dp[i][buy][m]!=-1)return dp[i][buy][m];\\n        int ans=c(buy,m,p,i+1,dp);\\n        if(buy){\\n            ans = max (ans , -p[i] + c(1-buy,m,p,i+1,dp));\\n        }\\n        else{\\n            ans = max(ans, p[i] + c(1-buy,m-1,p,i+1,dp));\\n        }\\n        return dp[i][buy][m]=ans;\\n    }\\n    int maxProfit(vector<int>& p) {\\n        vector<vector<vector<int>>>dp(p.size(),vector<vector<int>>(2,vector<int>(3,-1)));\\n     return c(1,2,p,0,dp);   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3390531,
                "title": "unique-solution-memoization-dp-c",
                "content": "# Intuition\\nWe will be using 5 different states for the buy variable which will tell us what to do in that situation.\\n\\n# Approach\\nInitial state = 4\\nFinal state = 0\\nX = Move not possible\\n\\nFor different Values of the Buy variable, we will be making decisions according to the diagram drawn below :-\\n\\n![2023-04-07 (2).png](https://assets.leetcode.com/users/images/2847b855-ebbc-486c-8c9c-ba14dbb636e7_1680875400.0707452.png)\\n\\nSince I can only buy and sell the stock at most two times.\\n\\n1.) When Buy=4 => (I don\\'t hold any stock) => I can only buy\\n2.) When Buy=3 => (I already have a stock) => I can only sell\\n3.) When Buy=2 => (I don\\'t hold any stock again) => I can only buy\\n4.) When Buy=1 => (I already have a stock) => I can only sell\\n5.) When Buy=0 => I cann\\'t do anything here (No buying/selling is possible)\\n\\nSee the Below Code which is easily understandable.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N*5) = O(N)\\n\\n- Space complexity:\\nO(N*5) = O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>&prices, int index,int buy,vector<vector<int>>&dp)\\n    {\\n        // Base Case\\n        if(index>=prices.size() || buy==0) return 0;\\n\\n        int ans=INT_MIN;\\n\\n        if(dp[index][buy]!=-1) return dp[index][buy];\\n\\n        // Choice Diagram  \\n        if(buy==4)\\n        {\\n            // I can only buy in this state\\n\\n            // I decide to buy\\n            ans=max(ans,-prices[index]+solve(prices,index+1,3,dp));\\n\\n            // Decide not to buy\\n            ans=max(ans,solve(prices,index+1,4,dp));\\n        }\\n\\n        else if(buy==3)\\n        {\\n            // I can only sell in this state\\n\\n            // I decide to sell\\n            ans=max(ans,prices[index]+solve(prices,index+1,2,dp));\\n\\n            // Decide not to sell\\n            ans=max(ans,solve(prices,index+1,3,dp));\\n        }\\n\\n        else if(buy==2)\\n        {\\n            // I can only buy in this state\\n\\n            // I decide to buy\\n            ans=max(ans,-prices[index]+solve(prices,index+1,1,dp));\\n\\n            // Decide not to buy\\n            ans=max(ans,solve(prices,index+1,2,dp));\\n            \\n        }\\n\\n        else if(buy==1)\\n        {\\n            // I can only sell in this state\\n\\n            // I decide to sell\\n            ans=max(ans,prices[index]+solve(prices,index+1,0,dp));\\n\\n            // Decide not to sell\\n            ans=max(ans,solve(prices,index+1,1,dp));\\n        } \\n\\n        return dp[index][buy]=ans;\\n\\n    }\\n    int maxProfit(vector<int>& prices) \\n    {\\n        vector<vector<int>>dp(prices.size(),vector<int>(5,-1));\\n        return solve(prices,0,4,dp);\\n    }\\n};\\n```\\n\\nPLEASE HIT THE UPVOTE BUTTON, IT MAKES ME HAPPY !!!!!!!!!!\\uD83D\\uDE09\\n\\n![image.png](https://assets.leetcode.com/users/images/9930a7b5-57c1-4787-9fd3-f63e370fccbe_1680875810.0868616.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>&prices, int index,int buy,vector<vector<int>>&dp)\\n    {\\n        // Base Case\\n        if(index>=prices.size() || buy==0) return 0;\\n\\n        int ans=INT_MIN;\\n\\n        if(dp[index][buy]!=-1) return dp[index][buy];\\n\\n        // Choice Diagram  \\n        if(buy==4)\\n        {\\n            // I can only buy in this state\\n\\n            // I decide to buy\\n            ans=max(ans,-prices[index]+solve(prices,index+1,3,dp));\\n\\n            // Decide not to buy\\n            ans=max(ans,solve(prices,index+1,4,dp));\\n        }\\n\\n        else if(buy==3)\\n        {\\n            // I can only sell in this state\\n\\n            // I decide to sell\\n            ans=max(ans,prices[index]+solve(prices,index+1,2,dp));\\n\\n            // Decide not to sell\\n            ans=max(ans,solve(prices,index+1,3,dp));\\n        }\\n\\n        else if(buy==2)\\n        {\\n            // I can only buy in this state\\n\\n            // I decide to buy\\n            ans=max(ans,-prices[index]+solve(prices,index+1,1,dp));\\n\\n            // Decide not to buy\\n            ans=max(ans,solve(prices,index+1,2,dp));\\n            \\n        }\\n\\n        else if(buy==1)\\n        {\\n            // I can only sell in this state\\n\\n            // I decide to sell\\n            ans=max(ans,prices[index]+solve(prices,index+1,0,dp));\\n\\n            // Decide not to sell\\n            ans=max(ans,solve(prices,index+1,1,dp));\\n        } \\n\\n        return dp[index][buy]=ans;\\n\\n    }\\n    int maxProfit(vector<int>& prices) \\n    {\\n        vector<vector<int>>dp(prices.size(),vector<int>(5,-1));\\n        return solve(prices,0,4,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225777,
                "title": "python3-easy-solution-with-comments",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        buy1 = buy2 = float(\"inf\")\\n        profit1 = profit2 = 0\\n        \\n        # Iterate through the prices and update the maximum profits\\n        for price in prices:\\n            # Update the price at which we should buy the first stock\\n            buy1 = min(buy1, price)\\n            # Update the profit we can make if we sell the first stock at this price\\n            profit1 = max(profit1, price - buy1)\\n            # Update the price at which we should buy the second stock\\n            buy2 = min(buy2, price - profit1)\\n            # Update the profit we can make if we sell the second stock at this price\\n            profit2 = max(profit2, price - buy2)\\n        \\n        # Return the maximum profit we can achieve after the second transaction\\n        return profit2\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        buy1 = buy2 = float(\"inf\")\\n        profit1 = profit2 = 0\\n        \\n        # Iterate through the prices and update the maximum profits\\n        for price in prices:\\n            # Update the price at which we should buy the first stock\\n            buy1 = min(buy1, price)\\n            # Update the profit we can make if we sell the first stock at this price\\n            profit1 = max(profit1, price - buy1)\\n            # Update the price at which we should buy the second stock\\n            buy2 = min(buy2, price - profit1)\\n            # Update the profit we can make if we sell the second stock at this price\\n            profit2 = max(profit2, price - buy2)\\n        \\n        # Return the maximum profit we can achieve after the second transaction\\n        return profit2\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3016006,
                "title": "c-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int firstBuy = INT_MAX, secondBuy = INT_MAX, firstProfit = 0, secondProfit = 0;\\n        for(int x: prices) {\\n            firstBuy = min(firstBuy, x);\\n            firstProfit = max(firstProfit, x - firstBuy);\\n            secondBuy = min(secondBuy, x - firstProfit);\\n            secondProfit = max(secondProfit, x - secondBuy);\\n        }\\n        return secondProfit;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int firstBuy = INT_MAX, secondBuy = INT_MAX, firstProfit = 0, secondProfit = 0;\\n        for(int x: prices) {\\n            firstBuy = min(firstBuy, x);\\n            firstProfit = max(firstProfit, x - firstBuy);\\n            secondBuy = min(secondBuy, x - firstProfit);\\n            secondProfit = max(secondProfit, x - secondBuy);\\n        }\\n        return secondProfit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2743789,
                "title": "c-full-solution-from-brute-force-to-optimized-dp-clean-code-with-commented-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        //varitation of best time to buy and sell stock with atmost k transactions\\n        //first i will write the non-optimised approach\\n        //let dp[i][j] be the maximum profit we obtain on the jth day after doing atmost i transactions\\n        //so dp[i][j]=max(dp[i][j-1],price[j]- (\\u03A3price[k]+dp[i-1][k]));\\n        //where k ranges from 0 to j-1\\n        int k=2;\\n        int n=prices.size();\\n        int dp[k+1][n];\\n       /* for(int i=0;i<=k;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==0 or j==0){\\n                    dp[i][j]=0;\\n                }\\n                else{\\n                    dp[i][j]=dp[i][j-1];\\n                    for(int k=0;k<j;k++){\\n                        dp[i][j]=max(dp[i][j],prices[j]-prices[k]+dp[i-1][k]);\\n                    }        \\n                }\\n            }\\n        }\\n        return dp[k][n-1];\\n        */\\n        //now lets see the optimised version\\n        //price[j]-\\u03A3price[k]+dp[i-1][k];\\n        //price[j]+\\u03A3dp[i-1][k]-price[k]\\n        //so basically when we are iterating over j, we can keep track of max of the second term in the formula,i.e dp[i-1][k]-price[k],at each step in some var say prev_diff\\n        //so it will be price[j]+max(prev_diff,dp[i-1][j-1]-price[j-1]);\\n        //where prev_diff is maximum of \\u03A3dp[i-1][p]-price[p],where p ranges from 0 to j-2\\n        \\n        for(int i=0;i<=k;i++){\\n            int prev_diff=INT_MIN;\\n            for(int j=0;j<n;j++){\\n                if(i==0 or j==0){\\n                    dp[i][j]=0;\\n                }\\n                else{\\n                    prev_diff=max(prev_diff,dp[i-1][j-1]-prices[j-1]);\\n                    dp[i][j]=max(dp[i][j-1],prices[j]+prev_diff);\\n                }\\n            }\\n        }\\n        return dp[k][n-1];\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        //varitation of best time to buy and sell stock with atmost k transactions\\n        //first i will write the non-optimised approach\\n        //let dp[i][j] be the maximum profit we obtain on the jth day after doing atmost i transactions\\n        //so dp[i][j]=max(dp[i][j-1],price[j]- (\\u03A3price[k]+dp[i-1][k]));\\n        //where k ranges from 0 to j-1\\n        int k=2;\\n        int n=prices.size();\\n        int dp[k+1][n];\\n       /* for(int i=0;i<=k;i++){\\n            for(int j=0;j<n;j++){\\n                if(i==0 or j==0){\\n                    dp[i][j]=0;\\n                }\\n                else{\\n                    dp[i][j]=dp[i][j-1];\\n                    for(int k=0;k<j;k++){\\n                        dp[i][j]=max(dp[i][j],prices[j]-prices[k]+dp[i-1][k]);\\n                    }        \\n                }\\n            }\\n        }\\n        return dp[k][n-1];\\n        */\\n        //now lets see the optimised version\\n        //price[j]-\\u03A3price[k]+dp[i-1][k];\\n        //price[j]+\\u03A3dp[i-1][k]-price[k]\\n        //so basically when we are iterating over j, we can keep track of max of the second term in the formula,i.e dp[i-1][k]-price[k],at each step in some var say prev_diff\\n        //so it will be price[j]+max(prev_diff,dp[i-1][j-1]-price[j-1]);\\n        //where prev_diff is maximum of \\u03A3dp[i-1][p]-price[p],where p ranges from 0 to j-2\\n        \\n        for(int i=0;i<=k;i++){\\n            int prev_diff=INT_MIN;\\n            for(int j=0;j<n;j++){\\n                if(i==0 or j==0){\\n                    dp[i][j]=0;\\n                }\\n                else{\\n                    prev_diff=max(prev_diff,dp[i-1][j-1]-prices[j-1]);\\n                    dp[i][j]=max(dp[i][j-1],prices[j]+prev_diff);\\n                }\\n            }\\n        }\\n        return dp[k][n-1];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2223473,
                "title": "java-in-depth-explanation",
                "content": "This problem is not hard at all if you\\'ve completed **121. Best Time to Buy and Sell Stock**, **122. Best Time to Buy and Sell Stock II**, **309. Best Time to Buy and Sell Stock with Cooldown**, and **714. Best Time to Buy and Sell Stock with Transaction fee**.\\n  \\n  **Intuition**\\n    We have 4 variables here `t1Cost`, `t2Cost`, `t1Profit`, and `t2Profit`. They represents the minimum cost in each transaction and maximum profit we can have from each transaction.\\n\\t`t1Cost` and `t1Profit` are very easy to get. It\\'s exactly same as **121. Best Time to Buy and Sell Stock** so we skip it here. \\n\\tHow do we get `t2Cost` and `t2Profit` then? For `t2Cost`, we have to reinvest the profit we gain from the first transaction here so `t2Cost = Math.max(t2Cost, price - t1Profit)`. The prices of the second stock minus the max profit we have from first transaction is the minimum cost of second transaction. \\n\\t\\n```\\nclass Solution\\n{\\n    public int maxProfit(int[] prices) \\n    {\\n        // O(n) time | O(1) space\\n        if(prices == null || prices.length <= 1)    return 0;\\n        \\n        int t1Cost = Integer.MAX_VALUE, t2Cost = Integer.MAX_VALUE;\\n        int t1Profit = 0, t2Profit = 0;\\n        \\n        for(int price : prices)\\n        {\\n            // first transaction is as same as 121. Best Time to Buy and Sell Stock\\n            t1Cost = Math.min(t1Cost, price);\\n            t1Profit = Math.max(t1Profit, price - t1Cost);\\n            \\n            // reinvest the gained profit in the second transaction\\n            t2Cost = Math.min(t2Cost, price - t1Profit);\\n            t2Profit = Math.max(t2Profit, price - t2Cost);\\n        }\\n        return t2Profit;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int maxProfit(int[] prices) \\n    {\\n        // O(n) time | O(1) space\\n        if(prices == null || prices.length <= 1)    return 0;\\n        \\n        int t1Cost = Integer.MAX_VALUE, t2Cost = Integer.MAX_VALUE;\\n        int t1Profit = 0, t2Profit = 0;\\n        \\n        for(int price : prices)\\n        {\\n            // first transaction is as same as 121. Best Time to Buy and Sell Stock\\n            t1Cost = Math.min(t1Cost, price);\\n            t1Profit = Math.max(t1Profit, price - t1Cost);\\n            \\n            // reinvest the gained profit in the second transaction\\n            t2Cost = Math.min(t2Cost, price - t1Profit);\\n            t2Profit = Math.max(t2Profit, price - t2Cost);\\n        }\\n        return t2Profit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2019713,
                "title": "java-automata-tc-o-n-sc-1",
                "content": "DFA Diagram:\\n![image](https://assets.leetcode.com/users/images/46c85fbe-fdbc-4e88-9c43-b053565c5a67_1652017753.2339256.png)\\n\\n```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        /*\\n            Hold1[i] = Math.max(Hold1[i - 1], -prices[i]);\\n            Sold1[i] = Math.max(Sold1[i - 1], prices[i] + Hold1[i - 1]);\\n            Hold2[i] = Math.max(Hold2[i - 1], Sold1[i - 1] -prices[i]);\\n            Sold2[i] = Math.max(Sold2[i - 1], prices[i] + Hold2[i - 1])\\n        */\\n        int hold1 = Integer.MIN_VALUE;\\n        int sold1 = 0;\\n        int hold2 = Integer.MIN_VALUE;\\n        int sold2 = 0;\\n        for (int price: prices) {\\n            sold2 = Math.max(sold2, price + hold2);\\n            hold2 = Math.max(hold2, sold1 - price);\\n            sold1 = Math.max(sold1, price + hold1);\\n            hold1 = Math.max(hold1, -price);\\n        }\\n        return sold2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        /*\\n            Hold1[i] = Math.max(Hold1[i - 1], -prices[i]);\\n            Sold1[i] = Math.max(Sold1[i - 1], prices[i] + Hold1[i - 1]);\\n            Hold2[i] = Math.max(Hold2[i - 1], Sold1[i - 1] -prices[i]);\\n            Sold2[i] = Math.max(Sold2[i - 1], prices[i] + Hold2[i - 1])\\n        */\\n        int hold1 = Integer.MIN_VALUE;\\n        int sold1 = 0;\\n        int hold2 = Integer.MIN_VALUE;\\n        int sold2 = 0;\\n        for (int price: prices) {\\n            sold2 = Math.max(sold2, price + hold2);\\n            hold2 = Math.max(hold2, sold1 - price);\\n            sold1 = Math.max(sold1, price + hold1);\\n            hold1 = Math.max(hold1, -price);\\n        }\\n        return sold2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910634,
                "title": "hard-made-easy-c-easy-to-understand",
                "content": "###### I recommend you to first solve Best Time to BUY and Sell Stock 1 problem to understand a little bit of concept and question.\\n###### https://leetcode.com/problems/best-time-to-buy-and-sell-stock/\\n\\nHere is my simple C++ solution.\\nHere we are calculating two profits and returning the later one as per question.\\n\\n*We first check whether the given vector is empty or not. That\\'s our corner case.\\n*Then further we declare 4 variables that\\'ll help us store the answer.\\n*We must calculate the stock when first bought and first sold.\\n*Then we\\'ll calculate the stock when bought second time by subtracting the profit from first selling stock i.e. prices[i]-buy1\\n*Then at last we\\'ll calculate the max profit and return it as our answer.\\n\\n\\nIf any doubts, feel free to ask in comments:)\\n\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        if(!prices.size()) return 0;\\n        \\n        int buy1 = INT_MAX;\\n        int profit1 = INT_MIN;\\n        int buy2 = INT_MAX;\\n        int profit2 = INT_MIN;\\n        \\n        for(int i=0;i<prices.size();i++)\\n        {\\n            buy1 = min(buy1,prices[i]);\\n            profit1 = max(profit1,prices[i]-buy1);\\n            buy2 = min(buy2,prices[i]-profit1);\\n            profit2 = max(profit2,prices[i]-buy2);\\n        }\\n        return profit2;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        if(!prices.size()) return 0;\\n        \\n        int buy1 = INT_MAX;\\n        int profit1 = INT_MIN;\\n        int buy2 = INT_MAX;\\n        int profit2 = INT_MIN;\\n        \\n        for(int i=0;i<prices.size();i++)\\n        {\\n            buy1 = min(buy1,prices[i]);\\n            profit1 = max(profit1,prices[i]-buy1);\\n            buy2 = min(buy2,prices[i]-profit1);\\n            profit2 = max(profit2,prices[i]-buy2);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1758060,
                "title": "tle-ac-generalized-solution-with-comments",
                "content": "___\\n**\\uD83E\\uDDE0 Initial Thought:**\\nFirstly we need to think of different DP states/ variables needed here. These will be passed as a parameter to the recursive function.\\n1) Prices (input array)\\n2) Current index\\n3) Buy or sell flag\\n4) Trades completed\\n\\nWe will stop when 2 trades have been completed or Current index is end of the array  (Prices)\\n___\\n**\\u274CRECURSIVE CODE: [TLE]**\\n```\\nclass Solution \\n{\\npublic:\\n    // BUY/ SELL FLAGS:\\n    // isBuy = 1, need to buy, cannot sell\\n    // isBuy = 0, need to sell, cannot buy\\n    \\n    int profit(vector<int> prices, int index, int isBuy, int trades)\\n    {\\n        if(index == prices.size() || trades == 2)     // return 0, if two transactions are completed or end of array is reached\\n            return 0;\\n                      \\n        int ignore, buyORsell;\\n        \\n        if(isBuy)\\n        {   // if isBuy=1, we have a choice to purchase the stock or ignore and move on\\n            ignore    = profit(prices, index + 1, 1, trades);                       // do not buy\\n            buyORsell = profit(prices, index + 1, 0, trades) - prices[index];       // buy and subtract the cost to buy\\n        }\\n        \\n        else\\n        {   // if isBuy=0, we can only sell as we have already bought or ignore and move on\\n            ignore    = profit(prices, index + 1, 0, trades);                       // do not sell\\n            buyORsell = profit(prices, index + 1, 1, trades + 1) + prices[index];   // sell and add the profit\\n        }   \\n        return max(ignore, buyORsell); // best choice among trading and skipping\\n    }\\n    \\n    int maxProfit(vector<int>& prices) \\n    {\\n        return profit(prices, 0, 1, 0);\\n    }\\n};\\n```\\n**RESULT: TIME LIMIT EXCEEDED**\\n**IMPROVEMENT\\u2753: MEMOIZATION (TOP-DOWN DP)**\\n___\\n**TOP-DOWN DP (MEMOIZED VERSION):** inspired by @[anandthegreat](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/discuss/796990/C%2B%2B-Worst-to-Best-Solution-Explained-(for-dummies-like-me))\\n```\\nclass Solution \\n{\\npublic:\\n    unordered_map<int, int> memo; // global DP memoization, stores {key : price}\\n    // sample key: 110 => index+isBuy+trades\\n\\t// BUY/ SELL FLAGS:\\n    // isBuy = 1, need to buy, cannot sell\\n    // isBuy = 0, need to sell, cannot buy\\n    \\n    int profit(vector<int> prices, int index, int isBuy, int trades)\\n    {\\n        if(index == prices.size() || trades == 2)     // return 0, if two transactions are completed or end of array is reached\\n            return 0;\\n        \\n        int key = index*100 + isBuy*10 + trades; // form a 3 digit number as the key\\n        \\n        if(memo.find(key) != memo.end())\\n        {\\n            return memo[key]; // if sub-problem already solved, return the result from MEMO\\n        }\\n        \\n        int ignore, buyORsell;\\n        \\n        if(isBuy)\\n        {   // if isBuy=1, we have a choice to purchase the stock or ignore and move on\\n            ignore    = profit(prices, index + 1, 1, trades);                       // do not buy\\n            buyORsell = profit(prices, index + 1, 0, trades) - prices[index];       // buy and subtract the cost to buy\\n        }\\n        \\n        else\\n        {   // if isBuy=0, we can only sell as we have already bought or ignore and move on\\n            ignore    = profit(prices, index + 1, 0, trades);                       // do not sell\\n            buyORsell = profit(prices, index + 1, 1, trades + 1) + prices[index];   // sell and add the profit\\n        }   \\n        return memo[key] = max(ignore, buyORsell); // best choice among trading and skipping\\n    }\\n    \\n    int maxProfit(vector<int>& prices) \\n    {\\n        return profit(prices, 0, 1, 0);\\n    }\\n};\\n```\\n**RESULT: TIME LIMIT EXCEEDED**\\n___\\n\\n___\\n**Easiest to understand approach: Similar to Buy and Sell stock-I**\\nHere we need to keep the track of lowest buy price and profit (if bought at that price) of the stock, since we only deal with 2 transactions, we can directly track them using total 4 variables\\n```\\nint maxProfit(vector<int>& prices) \\n{\\n        if(prices.size()==0)  return 0;\\n\\t\\t\\n        int BuyPrice1 = INT_MAX;\\n        int Profit1 = INT_MIN;\\n\\t\\t\\n        int BuyPrice2 = INT_MAX;\\n        int Profit2 = INT_MIN;\\n\\t\\t\\n        for(int i = 0; i < prices.size(); i++)\\n\\t\\t{\\n\\t\\t    // select the minimum buy price for stock1, out of previous minimum prices and current price at ith-day\\n            BuyPrice1 = min(BuyPrice1, prices[i]);\\n\\t\\t\\t// select the maximum profit buy either selling the stock1 price of ith-day or moving on to next day\\n            Profit1 = max(Profit1, prices[i] - BuyPrice1);\\n\\t\\t\\t\\n\\t\\t\\t// select the minimum buy price for stock2, out of previous minimum prices and current price at ith-day\\n            BuyPrice2 = min(BuyPrice2, prices[i] - Profit1);\\n\\t\\t\\t// select the maximum profit buy either selling the stock2 at price of ith-day or moving on to next day\\n            Profit2 = max(Profit2, prices[i] - BuyPrice2);\\n        }\\n        return Profit2;\\n    }\\n```\\n___\\n**GENERALIZED CODE FOR AT-MOST K TRANSACTIONS**\\n```\\nint maxProfit(vector<int>& prices, int k = 2) \\n{\\n\\tint n = prices.size();\\n\\tif(k==0) return 0;\\n\\tvector<pair<int, int>> dp(k, {INT_MAX, 0});\\n\\tfor(int i=0; i<n; i++)\\n\\t{\\n\\t\\t// Choose the least Buy Price:\\n\\t\\tdp[0].first = min(dp[0].first, prices[i]);\\n\\t\\t// Max Profit:\\n\\t\\tdp[0].second = max(dp[0].second, prices[i] - dp[0].first);\\n\\n\\t\\tfor(int j=1; j<k ;j++)\\n\\t\\t{\\n\\t\\t\\t// Buy Price:\\n\\t\\t\\tdp[j].first = min(dp[j].first, prices[i]-dp[j-1].second);\\n\\t\\t\\tdp[j].second = max(dp[j].second, prices[i]-dp[j].first);\\n\\t\\t}\\n\\t}\\n\\treturn dp[k-1].second;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    // BUY/ SELL FLAGS:\\n    // isBuy = 1, need to buy, cannot sell\\n    // isBuy = 0, need to sell, cannot buy\\n    \\n    int profit(vector<int> prices, int index, int isBuy, int trades)\\n    {\\n        if(index == prices.size() || trades == 2)     // return 0, if two transactions are completed or end of array is reached\\n            return 0;\\n                      \\n        int ignore, buyORsell;\\n        \\n        if(isBuy)\\n        {   // if isBuy=1, we have a choice to purchase the stock or ignore and move on\\n            ignore    = profit(prices, index + 1, 1, trades);                       // do not buy\\n            buyORsell = profit(prices, index + 1, 0, trades) - prices[index];       // buy and subtract the cost to buy\\n        }\\n        \\n        else\\n        {   // if isBuy=0, we can only sell as we have already bought or ignore and move on\\n            ignore    = profit(prices, index + 1, 0, trades);                       // do not sell\\n            buyORsell = profit(prices, index + 1, 1, trades + 1) + prices[index];   // sell and add the profit\\n        }   \\n        return max(ignore, buyORsell); // best choice among trading and skipping\\n    }\\n    \\n    int maxProfit(vector<int>& prices) \\n    {\\n        return profit(prices, 0, 1, 0);\\n    }\\n};\\n```\n```\\nclass Solution \\n{\\npublic:\\n    unordered_map<int, int> memo; // global DP memoization, stores {key : price}\\n    // sample key: 110 => index+isBuy+trades\\n\\t// BUY/ SELL FLAGS:\\n    // isBuy = 1, need to buy, cannot sell\\n    // isBuy = 0, need to sell, cannot buy\\n    \\n    int profit(vector<int> prices, int index, int isBuy, int trades)\\n    {\\n        if(index == prices.size() || trades == 2)     // return 0, if two transactions are completed or end of array is reached\\n            return 0;\\n        \\n        int key = index*100 + isBuy*10 + trades; // form a 3 digit number as the key\\n        \\n        if(memo.find(key) != memo.end())\\n        {\\n            return memo[key]; // if sub-problem already solved, return the result from MEMO\\n        }\\n        \\n        int ignore, buyORsell;\\n        \\n        if(isBuy)\\n        {   // if isBuy=1, we have a choice to purchase the stock or ignore and move on\\n            ignore    = profit(prices, index + 1, 1, trades);                       // do not buy\\n            buyORsell = profit(prices, index + 1, 0, trades) - prices[index];       // buy and subtract the cost to buy\\n        }\\n        \\n        else\\n        {   // if isBuy=0, we can only sell as we have already bought or ignore and move on\\n            ignore    = profit(prices, index + 1, 0, trades);                       // do not sell\\n            buyORsell = profit(prices, index + 1, 1, trades + 1) + prices[index];   // sell and add the profit\\n        }   \\n        return memo[key] = max(ignore, buyORsell); // best choice among trading and skipping\\n    }\\n    \\n    int maxProfit(vector<int>& prices) \\n    {\\n        return profit(prices, 0, 1, 0);\\n    }\\n};\\n```\n```\\nint maxProfit(vector<int>& prices) \\n{\\n        if(prices.size()==0)  return 0;\\n\\t\\t\\n        int BuyPrice1 = INT_MAX;\\n        int Profit1 = INT_MIN;\\n\\t\\t\\n        int BuyPrice2 = INT_MAX;\\n        int Profit2 = INT_MIN;\\n\\t\\t\\n        for(int i = 0; i < prices.size(); i++)\\n\\t\\t{\\n\\t\\t    // select the minimum buy price for stock1, out of previous minimum prices and current price at ith-day\\n            BuyPrice1 = min(BuyPrice1, prices[i]);\\n\\t\\t\\t// select the maximum profit buy either selling the stock1 price of ith-day or moving on to next day\\n            Profit1 = max(Profit1, prices[i] - BuyPrice1);\\n\\t\\t\\t\\n\\t\\t\\t// select the minimum buy price for stock2, out of previous minimum prices and current price at ith-day\\n            BuyPrice2 = min(BuyPrice2, prices[i] - Profit1);\\n\\t\\t\\t// select the maximum profit buy either selling the stock2 at price of ith-day or moving on to next day\\n            Profit2 = max(Profit2, prices[i] - BuyPrice2);\\n        }\\n        return Profit2;\\n    }\\n```\n```\\nint maxProfit(vector<int>& prices, int k = 2) \\n{\\n\\tint n = prices.size();\\n\\tif(k==0) return 0;\\n\\tvector<pair<int, int>> dp(k, {INT_MAX, 0});\\n\\tfor(int i=0; i<n; i++)\\n\\t{\\n\\t\\t// Choose the least Buy Price:\\n\\t\\tdp[0].first = min(dp[0].first, prices[i]);\\n\\t\\t// Max Profit:\\n\\t\\tdp[0].second = max(dp[0].second, prices[i] - dp[0].first);\\n\\n\\t\\tfor(int j=1; j<k ;j++)\\n\\t\\t{\\n\\t\\t\\t// Buy Price:\\n\\t\\t\\tdp[j].first = min(dp[j].first, prices[i]-dp[j-1].second);\\n\\t\\t\\tdp[j].second = max(dp[j].second, prices[i]-dp[j].first);\\n\\t\\t}\\n\\t}\\n\\treturn dp[k-1].second;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1595994,
                "title": "c-dp-recursive-both-detailed-explaination",
                "content": "The first one is a Recursive Solution \\n\\n```\\nclass Solution {\\n\\n    int l;\\n\\n    vector<int> a;\\n    \\n    int recurse(int currentindex, bool bought, int count)\\n    {\\n\\t     //count is the count of transactions\\n    \\t//currentindex is the current position in the array, or current stock index\\n        if(currentindex>=l  || count>=2)\\n            return 0;\\n\\n        int donothing=recurse(currentindex+1, bought, count);\\n        // do something\\n        int dosomething=0;\\n\\t\\t\\n        if(!bought)\\n        { // we need to buy , count remains since we have bought and not sold yet\\n            dosomething= -a[currentindex]+recurse(currentindex+1, true, count);     \\n        }\\n        else{\\n            // bought is true. we need to sell and only increasing count when we have sold\\n            dosomething=  a[currentindex]+recurse(currentindex+1, false, count+1);      }        \\n       \\n        return max(donothing, dosomething);\\n    }\\n    \\n    \\n\\n\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n       \\n         a= prices;\\n         l= prices.size();\\n\\n        return recurse(0,0,0);\\n\\n    }\\n};\\n```\\n\\nSince the above solution was giving TLE, passing 204/214 test cases, therefore we have to either use recursion with memoization or dp!\\n\\n\\nGiven below is the DP solution - It passes all the test cases!\\n```\\nclass Solution {\\n\\n    vector<int> a;\\n    \\n\\n    int dpsolution()\\n    {\\n        int n= a.size();\\n         \\n\\t\\t //3 states of dp:\\n\\t\\t    //1. index\\n\\t\\t\\t//2. bought or not \\n\\t\\t\\t//3. count of transactions\\n\\t\\t\\t\\n    \\t//compare the dp states with the number of arguments in the recursive solution\\t\\n        int dp[n+1][2][4];\\n       \\n        memset(dp,0,sizeof(dp));\\n        \\n        for( int i=n-1;i>=0;i--)\\n        {\\n            //inner loop for bought or not bought state\\n            for(int j=2;j>=0;j--)\\n            {\\n                \\n          \\n            // do nothing\\n            int donothing=0;\\n            //dosomething\\n            int dosomething=0;\\n\\n            /* bought condition -> if already bought then donothing condition both latter states will be same, \\n\\t\\t\\t                       dosomething condition use memoized value, bought becomes not bought,\\n\\t\\t\\t                       count state remains same */\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   \\n            donothing=dp[i+1][1][j];\\n            dosomething=a[i]+dp[i+1][0][j];\\n            dp[i][1][j]=max(donothing, dosomething);\\n\\t\\t\\t\\n            \\n            /* not bought condition -> if not bought, then donothing conditin is same as before, \\n\\t\\t\\t                           dosomething entails that we need to sell, and increase the count */\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   \\n            donothing= dp[i+1][0][j];\\n            dosomething= -a[i]+dp[i+1][1][j+1];\\n            dp[i][0][j]= max(donothing, dosomething);\\n                \\n     }\\n\\n        }\\n        return dp[0][0][0];\\n    }\\n\\t\\n\\tpublic:\\n    int maxProfit(vector<int>& prices) {\\n       \\n         a= prices;\\n\\n        return dpsolution();\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n\\n    int l;\\n\\n    vector<int> a;\\n    \\n    int recurse(int currentindex, bool bought, int count)\\n    {\\n\\t     //count is the count of transactions\\n    \\t//currentindex is the current position in the array, or current stock index\\n        if(currentindex>=l  || count>=2)\\n            return 0;\\n\\n        int donothing=recurse(currentindex+1, bought, count);\\n        // do something\\n        int dosomething=0;\\n\\t\\t\\n        if(!bought)\\n        { // we need to buy , count remains since we have bought and not sold yet\\n            dosomething= -a[currentindex]+recurse(currentindex+1, true, count);     \\n        }\\n        else{\\n            // bought is true. we need to sell and only increasing count when we have sold\\n            dosomething=  a[currentindex]+recurse(currentindex+1, false, count+1);      }        \\n       \\n        return max(donothing, dosomething);\\n    }\\n    \\n    \\n\\n\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n       \\n         a= prices;\\n         l= prices.size();\\n\\n        return recurse(0,0,0);\\n\\n    }\\n};\\n```\n```\\nclass Solution {\\n\\n    vector<int> a;\\n    \\n\\n    int dpsolution()\\n    {\\n        int n= a.size();\\n         \\n\\t\\t //3 states of dp:\\n\\t\\t    //1. index\\n\\t\\t\\t//2. bought or not \\n\\t\\t\\t//3. count of transactions\\n\\t\\t\\t\\n    \\t//compare the dp states with the number of arguments in the recursive solution\\t\\n        int dp[n+1][2][4];\\n       \\n        memset(dp,0,sizeof(dp));\\n        \\n        for( int i=n-1;i>=0;i--)\\n        {\\n            //inner loop for bought or not bought state\\n            for(int j=2;j>=0;j--)\\n            {\\n                \\n          \\n            // do nothing\\n            int donothing=0;\\n            //dosomething\\n            int dosomething=0;\\n\\n            /* bought condition -> if already bought then donothing condition both latter states will be same, \\n\\t\\t\\t                       dosomething condition use memoized value, bought becomes not bought,\\n\\t\\t\\t                       count state remains same */\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   \\n            donothing=dp[i+1][1][j];\\n            dosomething=a[i]+dp[i+1][0][j];\\n            dp[i][1][j]=max(donothing, dosomething);\\n\\t\\t\\t\\n            \\n            /* not bought condition -> if not bought, then donothing conditin is same as before, \\n\\t\\t\\t                           dosomething entails that we need to sell, and increase the count */\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   \\n            donothing= dp[i+1][0][j];\\n            dosomething= -a[i]+dp[i+1][1][j+1];\\n            dp[i][0][j]= max(donothing, dosomething);\\n                \\n     }\\n\\n        }\\n        return dp[0][0][0];\\n    }\\n\\t\\n\\tpublic:\\n    int maxProfit(vector<int>& prices) {\\n       \\n         a= prices;\\n\\n        return dpsolution();\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1569193,
                "title": "c-easy-one-pass-solution-dp",
                "content": "The idea  is to keep track of the two transactions at the same time\\nTime complexity: O(N) \\nAuxiliary Space: O(1)\\n\\nCode:\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int buy1=INT_MAX, profit1=0, buy2=INT_MAX, profit2=0;\\n        \\n        for(int i=0;i<prices.size();i++){\\n            buy1 = min(buy1, prices[i]);  //buy on the day where the min most amount goes out from our pocket\\n            profit1 = max(profit1, prices[i]-buy1); //sell to make max profit\\n            \\n            buy2 = min(buy2, prices[i]-profit1); //buy with the profit you have on 1st purchase\\n            profit2 = max(profit2, prices[i]-buy2); //sell to max-profit again\\n        }\\n        return profit2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int buy1=INT_MAX, profit1=0, buy2=INT_MAX, profit2=0;\\n        \\n        for(int i=0;i<prices.size();i++){\\n            buy1 = min(buy1, prices[i]);  //buy on the day where the min most amount goes out from our pocket\\n            profit1 = max(profit1, prices[i]-buy1); //sell to make max profit\\n            \\n            buy2 = min(buy2, prices[i]-profit1); //buy with the profit you have on 1st purchase\\n            profit2 = max(profit2, prices[i]-buy2); //sell to max-profit again\\n        }\\n        return profit2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1533103,
                "title": "easy-single-pass-c-solution-no-extra-space",
                "content": "We can use profit gained by 1st transaction to buy stocks for second transaction.\\n\\n```\\nint maxProfit(vector<int>& prices) {\\n        int min_price1 = INT_MAX;\\n        int profit1 = 0;\\n        int min_price2 = INT_MAX;\\n        int profit2 = 0;\\n        \\n        for(int i=0;i<prices.size();i++){\\n            min_price1 = min(min_price1 , prices[i]);\\n            profit1 = max(profit1 , prices[i] - min_price1);\\n            \\n            min_price2 = min(min_price2 , prices[i] - profit1);\\n            profit2 = max(profit2 , prices[i] - min_price2);\\n        }\\n        return profit2;\\n    }\\n```\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(1)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint maxProfit(vector<int>& prices) {\\n        int min_price1 = INT_MAX;\\n        int profit1 = 0;\\n        int min_price2 = INT_MAX;\\n        int profit2 = 0;\\n        \\n        for(int i=0;i<prices.size();i++){\\n            min_price1 = min(min_price1 , prices[i]);\\n            profit1 = max(profit1 , prices[i] - min_price1);\\n            \\n            min_price2 = min(min_price2 , prices[i] - profit1);\\n            profit2 = max(profit2 , prices[i] - min_price2);\\n        }\\n        return profit2;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1523562,
                "title": "c-faster-than-97-26",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int maxProfit(vector<int> &prices)\\n    {\\n        int hold_1 = INT_MIN;\\n        int hold_2 = INT_MIN;\\n        int cont_1 = 0;\\n        int cont_2 = 0;\\n\\n        for (auto i : prices)\\n        {\\n            cont_2 = max(cont_2, hold_2 + i);\\n            hold_2 = max(hold_2, cont_1 - i);\\n\\n            cont_1 = max(cont_1, hold_1 + i);\\n            hold_1 = max(hold_1, -i);\\n        }\\n        return cont_2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int maxProfit(vector<int> &prices)\\n    {\\n        int hold_1 = INT_MIN;\\n        int hold_2 = INT_MIN;\\n        int cont_1 = 0;\\n        int cont_2 = 0;\\n\\n        for (auto i : prices)\\n        {\\n            cont_2 = max(cont_2, hold_2 + i);\\n            hold_2 = max(hold_2, cont_1 - i);\\n\\n            cont_1 = max(cont_1, hold_1 + i);\\n            hold_1 = max(hold_1, -i);\\n        }\\n        return cont_2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1523435,
                "title": "c-20-lines-of-code-with-prefix-and-suffix-easy-to-understand-shorter-simpler-code-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        int minn = prices[0],  maxx = prices[n-1], prev = 0, ans = 0;\\n        vector<int> pref(n, 0);\\n        \\n        for(int i = 1; i < n; i++) {\\n            pref[i] = max(pref[i-1], prices[i] - minn); // calculating profit upto ith day from the start\\n            minn = min(minn, prices[i]);\\n        }\\n\\n        for(int i = n-2; i >= 0; i--) {\\n            prev = max(prev, maxx - prices[i]); // calculating profit from ith day to last day\\n            ans = max(pref[i] + prev, ans); // calculating profit with 2 transactions with 1st before and 2nd after ith day\\n            maxx = max(maxx, prices[i]);   \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        int minn = prices[0],  maxx = prices[n-1], prev = 0, ans = 0;\\n        vector<int> pref(n, 0);\\n        \\n        for(int i = 1; i < n; i++) {\\n            pref[i] = max(pref[i-1], prices[i] - minn); // calculating profit upto ith day from the start\\n            minn = min(minn, prices[i]);\\n        }\\n\\n        for(int i = n-2; i >= 0; i--) {\\n            prev = max(prev, maxx - prices[i]); // calculating profit from ith day to last day\\n            ans = max(pref[i] + prev, ans); // calculating profit with 2 transactions with 1st before and 2nd after ith day\\n            maxx = max(maxx, prices[i]);   \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1394369,
                "title": "inspired-from-k-1-c",
                "content": "```\\n\\tint maxProfit(vector<int>& prices) {\\n      /*\\n      \\n      The main idea of this question is to do 2 transections only ,\\n      which means we need to find the max of two non overlapping \\n      buy sell buy sell transections, so if we know what is the \\n      max profit that I have at any point from left to right and\\n      right to left the max sum of these profits at any point will\\n      be the answer\\n      \\n      */\\n      \\n      int n=prices.size();\\n      vector<int> leftToRight(n,0);\\n      vector<int>rightToLeft(n,0);\\n      \\n      int maxProfit=0;\\n      int minFromLeft=prices[0];\\n      int maxFromRight=prices[n-1];\\n      \\n      for(int i=1;i<n;i++){\\n        maxProfit=max(maxProfit,prices[i]-minFromLeft);\\n        minFromLeft=min(minFromLeft,prices[i]);\\n        leftToRight[i]=maxProfit;\\n        \\n      }\\n      maxProfit=0;\\n      for(int j=n-2;j>=0;--j){\\n        maxProfit=max(maxProfit, maxFromRight-prices[j]);\\n        maxFromRight=max(maxFromRight, prices[j]);\\n        rightToLeft[j]=maxProfit;\\n        \\n      }\\n      maxProfit=0;\\n      for(int k=0;k<n;++k){\\n        maxProfit=max(maxProfit,leftToRight[k]+rightToLeft[k]);\\n      }\\n        \\n      return maxProfit;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n\\tint maxProfit(vector<int>& prices) {\\n      /*\\n      \\n      The main idea of this question is to do 2 transections only ,\\n      which means we need to find the max of two non overlapping \\n      buy sell buy sell transections, so if we know what is the \\n      max profit that I have at any point from left to right and\\n      right to left the max sum of these profits at any point will\\n      be the answer\\n      \\n      */\\n      \\n      int n=prices.size();\\n      vector<int> leftToRight(n,0);\\n      vector<int>rightToLeft(n,0);\\n      \\n      int maxProfit=0;\\n      int minFromLeft=prices[0];\\n      int maxFromRight=prices[n-1];\\n      \\n      for(int i=1;i<n;i++){\\n        maxProfit=max(maxProfit,prices[i]-minFromLeft);\\n        minFromLeft=min(minFromLeft,prices[i]);\\n        leftToRight[i]=maxProfit;\\n        \\n      }\\n      maxProfit=0;\\n      for(int j=n-2;j>=0;--j){\\n        maxProfit=max(maxProfit, maxFromRight-prices[j]);\\n        maxFromRight=max(maxFromRight, prices[j]);\\n        rightToLeft[j]=maxProfit;\\n        \\n      }\\n      maxProfit=0;\\n      for(int k=0;k<n;++k){\\n        maxProfit=max(maxProfit,leftToRight[k]+rightToLeft[k]);\\n      }\\n        \\n      return maxProfit;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1243694,
                "title": "python-o-kn-o-n-time-complexity-dp-solutions",
                "content": "1. Time Colmplexity: O(kn) \\n\\tSpace Complexity: O(kn)\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        dp = [[[0 for i in range(2)] for i in range(n)] for i in range(3)]\\n        \\n        for k in range(1,3):\\n            for i in range(n):\\n                if i == 0 and k == 1:\\n                    dp[k][i][1] = -prices[i]\\n                elif i == 0 and k == 2:\\n                    continue\\n                elif i == 1 and k == 2:\\n                    dp[k][i][0] = dp[k - 1][i][0]\\n                elif i == 2 and k == 2:\\n                    dp[k][i][1] = dp[k - 1][i - 1][0]-prices[i]\\n                    dp[k][i][0] = dp[k - 1][i][0]\\n                else:\\n                    dp[k][i][0] = max(dp[k][i - 1][1] + prices[i], max(dp[k - 1][i][0],dp[k][i - 1][0]))\\n                    dp[k][i][1] = max(dp[k][i - 1][1], dp[k - 1][i - 1][0] - prices[i])\\n        return dp[2][n - 1][0]\\n```\\n2. More clean and elegant version of above.\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        dp = [[0 for i in range(n)] for i in range(3)]          \\n        \\n        for k in range(1,3):\\n            buy = -999999\\n            for i in range(n):\\n                if i == 0:\\n                    buy = -prices[i]\\n                elif k == 2 and i == 1:\\n                    buy = max(buy, -prices[i])\\n                    dp[k][i] = dp[k - 1][i] if i > 0 else 0\\n                else:\\n                    dp[k][i] = max(buy + prices[i], max(dp[k - 1][i], dp[k][i - 1]))\\n                    buy = max(buy, dp[k - 1][i - 1] - prices[i])\\n        return dp[2][n - 1]\\n```\\n3. Time Complexity: O(n)\\n\\tSpace Complexity: O(1)\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n, buy1, buy2, sell1, sell2, temp = len(prices), 999999, 999999, 0, 0, 0\\n        \\n        for i in range(n):\\n            buy1 = min(buy1, prices[i])\\n            sell1 = max(prices[i] - buy1, sell1)\\n            buy2 = min(buy2, prices[i] - sell1)\\n            sell2 = max(prices[i] - buy2, sell2)\\n        return sell2 \\n```\\n**PS: Please upvote if you liked the solution.**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        dp = [[[0 for i in range(2)] for i in range(n)] for i in range(3)]\\n        \\n        for k in range(1,3):\\n            for i in range(n):\\n                if i == 0 and k == 1:\\n                    dp[k][i][1] = -prices[i]\\n                elif i == 0 and k == 2:\\n                    continue\\n                elif i == 1 and k == 2:\\n                    dp[k][i][0] = dp[k - 1][i][0]\\n                elif i == 2 and k == 2:\\n                    dp[k][i][1] = dp[k - 1][i - 1][0]-prices[i]\\n                    dp[k][i][0] = dp[k - 1][i][0]\\n                else:\\n                    dp[k][i][0] = max(dp[k][i - 1][1] + prices[i], max(dp[k - 1][i][0],dp[k][i - 1][0]))\\n                    dp[k][i][1] = max(dp[k][i - 1][1], dp[k - 1][i - 1][0] - prices[i])\\n        return dp[2][n - 1][0]\\n```\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n = len(prices)\\n        dp = [[0 for i in range(n)] for i in range(3)]          \\n        \\n        for k in range(1,3):\\n            buy = -999999\\n            for i in range(n):\\n                if i == 0:\\n                    buy = -prices[i]\\n                elif k == 2 and i == 1:\\n                    buy = max(buy, -prices[i])\\n                    dp[k][i] = dp[k - 1][i] if i > 0 else 0\\n                else:\\n                    dp[k][i] = max(buy + prices[i], max(dp[k - 1][i], dp[k][i - 1]))\\n                    buy = max(buy, dp[k - 1][i - 1] - prices[i])\\n        return dp[2][n - 1]\\n```\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        n, buy1, buy2, sell1, sell2, temp = len(prices), 999999, 999999, 0, 0, 0\\n        \\n        for i in range(n):\\n            buy1 = min(buy1, prices[i])\\n            sell1 = max(prices[i] - buy1, sell1)\\n            buy2 = min(buy2, prices[i] - sell1)\\n            sell2 = max(prices[i] - buy2, sell2)\\n        return sell2 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1234195,
                "title": "simple-solution-with-comments-java-6ms",
                "content": "```\\nclass Solution {\\n\\n    public int maxProfit(int[] prices) {\\n        // Max Profit on day =\\n        // Max Profit if I had bought and sold the stocks before or on this day +\\n        // Max Profit if I will buy the stock on this day or after and sell it later on the max Price\\n        // Note : these are non-overlapping\\n     \\n        int[] past = new int[prices.length];\\n        int[] future = new int[prices.length];\\n        \\n        // past to day ith\\n        // maximizing profit if I make a transaction before or upto day ith\\n        int cp = prices[0];  // cp : cost price\\n        past[0] = 0;\\n        \\n        for(int i=1; i<prices.length; i++)\\n        {\\n            past[i] = Math.max(prices[i] - cp, past[i-1]);\\n            cp = Math.min(cp, prices[i]);\\n        }\\n        \\n        // ith day to the future\\n        // maximizing profit if I make a transaction on or after ith day\\n        int sp = prices[prices.length - 1];  // sp : sell price\\n        future[prices.length - 1] = 0;\\n        \\n        for(int i=prices.length-2; i>=0; i--)\\n        {\\n            future[i] = Math.max(sp - prices[i], future[i+1]);\\n            sp = Math.max(sp, prices[i]);\\n        }\\n        \\n        // Now, our answer will be the max of the sum of the past and future profits\\n        // on the days from i=0 to i=prices.length-1\\n        \\n        int ans = 0;\\n        for(int i=0; i<prices.length; i++)\\n        {\\n            ans = Math.max(ans, past[i] + future[i]);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    public int maxProfit(int[] prices) {\\n        // Max Profit on day =\\n        // Max Profit if I had bought and sold the stocks before or on this day +\\n        // Max Profit if I will buy the stock on this day or after and sell it later on the max Price\\n        // Note : these are non-overlapping\\n     \\n        int[] past = new int[prices.length];\\n        int[] future = new int[prices.length];\\n        \\n        // past to day ith\\n        // maximizing profit if I make a transaction before or upto day ith\\n        int cp = prices[0];  // cp : cost price\\n        past[0] = 0;\\n        \\n        for(int i=1; i<prices.length; i++)\\n        {\\n            past[i] = Math.max(prices[i] - cp, past[i-1]);\\n            cp = Math.min(cp, prices[i]);\\n        }\\n        \\n        // ith day to the future\\n        // maximizing profit if I make a transaction on or after ith day\\n        int sp = prices[prices.length - 1];  // sp : sell price\\n        future[prices.length - 1] = 0;\\n        \\n        for(int i=prices.length-2; i>=0; i--)\\n        {\\n            future[i] = Math.max(sp - prices[i], future[i+1]);\\n            sp = Math.max(sp, prices[i]);\\n        }\\n        \\n        // Now, our answer will be the max of the sum of the past and future profits\\n        // on the days from i=0 to i=prices.length-1\\n        \\n        int ans = 0;\\n        for(int i=0; i<prices.length; i++)\\n        {\\n            ans = Math.max(ans, past[i] + future[i]);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1228322,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        \\n        int profit1 = 0, profit2 = 0;\\n        \\n        int min1 = INT_MAX, max1 = INT_MIN;\\n        \\n        vector<int>before, after(prices.size());\\n        \\n        for(auto p : prices)\\n        {\\n            min1 = min(min1, p);\\n            profit1 = max(profit1, p - min1);\\n            before.push_back(profit1);\\n        }\\n        \\n        for(int i=prices.size()-1; i>=0; i--)\\n        {\\n            max1 = max(max1, prices[i]);\\n            profit2 = max(profit2, max1 - prices[i]);\\n            after[i] = profit2;\\n        }\\n        \\n        int ans=0;\\n        \\n        for(int i=0; i<after.size(); i++)\\n            ans = max(ans, before[i] + after[i]);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        \\n        int profit1 = 0, profit2 = 0;\\n        \\n        int min1 = INT_MAX, max1 = INT_MIN;\\n        \\n        vector<int>before, after(prices.size());\\n        \\n        for(auto p : prices)\\n        {\\n            min1 = min(min1, p);\\n            profit1 = max(profit1, p - min1);\\n            before.push_back(profit1);\\n        }\\n        \\n        for(int i=prices.size()-1; i>=0; i--)\\n        {\\n            max1 = max(max1, prices[i]);\\n            profit2 = max(profit2, max1 - prices[i]);\\n            after[i] = profit2;\\n        }\\n        \\n        int ans=0;\\n        \\n        for(int i=0; i<after.size(); i++)\\n            ans = max(ans, before[i] + after[i]);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1227000,
                "title": "c-recur-memo-bottumup-easy-comments",
                "content": "```\\n/*\\n    Company Tags  : Amazon, Mu Sigma\\n    Leetcode Link : https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/submissions/\\n*/\\n\\n//Approach-1 (Recursion+Memoization) Time : O(n)\\nclass Solution {\\npublic:\\n    int t[100001][2][3];\\n    int maxProfitUtil(vector<int>& prices, int index, bool buy, int k) {\\n        if(index >= prices.size() || k == 0)\\n            return 0;\\n        if(t[index][buy][k] != -1)\\n            return t[index][buy][k];\\n        int max_profit = 0;\\n        if(buy) {\\n            int buys    = maxProfitUtil(prices, index+1, false, k) - prices[index];\\n            int no_buy  = maxProfitUtil(prices, index+1, true, k);\\n            max_profit  = max(buys, no_buy);\\n        } else {\\n            int sells    = maxProfitUtil(prices, index+1, true, k-1) + prices[index];\\n            int no_sell  = maxProfitUtil(prices, index+1, false, k);\\n            max_profit   = max(sells, no_sell);\\n        }\\n        return t[index][buy][k] = max_profit;\\n    }\\n    \\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        if(n <= 1)\\n            return 0;\\n        \\n        memset(t,-1,sizeof(t));\\n        return maxProfitUtil(prices, 0, true, 2);\\n    }\\n};\\n\\n//Approach-2 (DP) Time : O(n), Space : O(n)\\nclass Solution {\\npublic:\\n    int maxP(vector<int>& prices, int& n) {\\n        if(n <= 1)\\n            return 0;\\n        \\n        vector<int> profit1(n, 0);\\n        vector<int> profit2(n, 0);\\n        \\n        //calculating profit1 from left to right for first transaction\\n        int BuyMin = prices[0];\\n        profit1[0] = 0; //If there is only 1 day, you can\\'t buy, you\\'ll be in loss\\n        \\n        for(int i = 1; i<n; i++) {\\n            profit1[i] = max(profit1[i-1], prices[i]-BuyMin);\\n            BuyMin = min(BuyMin, prices[i]);\\n        }\\n        \\n        //calculating profit2 from right to left for second transaction\\n        /*\\n            Why right to left ?\\n            It will give the result in descending order\\n            Then finding max while adding (proft1[i] + profit2[i+1]) will be handy\\n        */\\n        int SellMax = prices[n-1];\\n        profit2[n-1] = 0; //You can\\'t sell without buying\\n        \\n        for(int i = n-2; i>=0; i--) {\\n            profit2[i] = max(profit2[i+1], SellMax-prices[i]);\\n            SellMax    = max(SellMax, prices[i]);\\n        }\\n        \\n        int maxProfit = 0;\\n        for(int i = 0; i<n; i++) {\\n            int first_tra  = profit1[i];\\n            int second_tra = i+1 < n ? profit2[i+1] : 0;\\n            \\n            maxProfit = max(maxProfit, first_tra + second_tra);\\n        }\\n        return maxProfit;\\n\\t\\t/*\\n\\t\\t\\tWhat we are doing is that we are dividing prices in two and finding the\\n\\t\\t\\tmaximum transacation from left half and from right half.\\n\\t\\t\\tAnd adding them to find maximum profit we can make.\\n\\t\\t*/\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        return maxP(prices, n);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n    Company Tags  : Amazon, Mu Sigma\\n    Leetcode Link : https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/submissions/\\n*/\\n\\n//Approach-1 (Recursion+Memoization) Time : O(n)\\nclass Solution {\\npublic:\\n    int t[100001][2][3];\\n    int maxProfitUtil(vector<int>& prices, int index, bool buy, int k) {\\n        if(index >= prices.size() || k == 0)\\n            return 0;\\n        if(t[index][buy][k] != -1)\\n            return t[index][buy][k];\\n        int max_profit = 0;\\n        if(buy) {\\n            int buys    = maxProfitUtil(prices, index+1, false, k) - prices[index];\\n            int no_buy  = maxProfitUtil(prices, index+1, true, k);\\n            max_profit  = max(buys, no_buy);\\n        } else {\\n            int sells    = maxProfitUtil(prices, index+1, true, k-1) + prices[index];\\n            int no_sell  = maxProfitUtil(prices, index+1, false, k);\\n            max_profit   = max(sells, no_sell);\\n        }\\n        return t[index][buy][k] = max_profit;\\n    }\\n    \\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        if(n <= 1)\\n            return 0;\\n        \\n        memset(t,-1,sizeof(t));\\n        return maxProfitUtil(prices, 0, true, 2);\\n    }\\n};\\n\\n//Approach-2 (DP) Time : O(n), Space : O(n)\\nclass Solution {\\npublic:\\n    int maxP(vector<int>& prices, int& n) {\\n        if(n <= 1)\\n            return 0;\\n        \\n        vector<int> profit1(n, 0);\\n        vector<int> profit2(n, 0);\\n        \\n        //calculating profit1 from left to right for first transaction\\n        int BuyMin = prices[0];\\n        profit1[0] = 0; //If there is only 1 day, you can\\'t buy, you\\'ll be in loss\\n        \\n        for(int i = 1; i<n; i++) {\\n            profit1[i] = max(profit1[i-1], prices[i]-BuyMin);\\n            BuyMin = min(BuyMin, prices[i]);\\n        }\\n        \\n        //calculating profit2 from right to left for second transaction\\n        /*\\n            Why right to left ?\\n            It will give the result in descending order\\n            Then finding max while adding (proft1[i] + profit2[i+1]) will be handy\\n        */\\n        int SellMax = prices[n-1];\\n        profit2[n-1] = 0; //You can\\'t sell without buying\\n        \\n        for(int i = n-2; i>=0; i--) {\\n            profit2[i] = max(profit2[i+1], SellMax-prices[i]);\\n            SellMax    = max(SellMax, prices[i]);\\n        }\\n        \\n        int maxProfit = 0;\\n        for(int i = 0; i<n; i++) {\\n            int first_tra  = profit1[i];\\n            int second_tra = i+1 < n ? profit2[i+1] : 0;\\n            \\n            maxProfit = max(maxProfit, first_tra + second_tra);\\n        }\\n        return maxProfit;\\n\\t\\t/*\\n\\t\\t\\tWhat we are doing is that we are dividing prices in two and finding the\\n\\t\\t\\tmaximum transacation from left half and from right half.\\n\\t\\t\\tAnd adding them to find maximum profit we can make.\\n\\t\\t*/\\n    }\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        return maxP(prices, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1114938,
                "title": "c-dp-well-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        if(n <= 1)\\n            return 0;\\n        //k is the number of transactions that are allowed\\n        int k = 2;\\n        //Make the DP array \\n        vector<vector<int>> dp(k+1, vector<int>(n,0));\\n        //dp[i][j] mean the max profit that can be made in the ith transaction\\n        //till the jth day\\n        //Read below for the recurrence relation explanation\\n        for(int i = 1; i<=k; i++)\\n        {\\n            int maxDiff = dp[i-1][0] - prices[0];\\n            for(int j=1; j<n; j++)\\n            {\\n                maxDiff= max(maxDiff, dp[i-1][j] - prices[j]);\\n                dp[i][j] = max(dp[i][j-1], prices[j]+maxDiff);\\n            }\\n        }\\n        return dp[k][n-1];\\n    }\\n};\\n/*\\nWe have two options for dp[i][j] ie on the jth day\\nEither dont buy anything then it is dp[i][j-1] or\\nsell in the jth day then we must have bought on a \\nprior day => (p[j]-p[m]) is the profit for this transaction\\nand we add the profit on the previous transaction till the day\\nthe share was bought ie dp[i-1][m], here m = [0,j).\\ndp[i][j] = max(dp[i][j-1], (p[j]-p[m])+dp[i-1][m])\\n\\nWe will need to calculate min value of (p[j]-p[m])+dp[i-1][m]\\nIt can arranged like p[j] + (dp[i-1][m] - p[m]) we have to maximise \\nthe values of the part in brackets.\\n*/\\n```\\nPlease upvote if you like the post.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& prices) {\\n        int n = prices.size();\\n        if(n <= 1)\\n            return 0;\\n        //k is the number of transactions that are allowed\\n        int k = 2;\\n        //Make the DP array \\n        vector<vector<int>> dp(k+1, vector<int>(n,0));\\n        //dp[i][j] mean the max profit that can be made in the ith transaction\\n        //till the jth day\\n        //Read below for the recurrence relation explanation\\n        for(int i = 1; i<=k; i++)\\n        {\\n            int maxDiff = dp[i-1][0] - prices[0];\\n            for(int j=1; j<n; j++)\\n            {\\n                maxDiff= max(maxDiff, dp[i-1][j] - prices[j]);\\n                dp[i][j] = max(dp[i][j-1], prices[j]+maxDiff);\\n            }\\n        }\\n        return dp[k][n-1];\\n    }\\n};\\n/*\\nWe have two options for dp[i][j] ie on the jth day\\nEither dont buy anything then it is dp[i][j-1] or\\nsell in the jth day then we must have bought on a \\nprior day => (p[j]-p[m]) is the profit for this transaction\\nand we add the profit on the previous transaction till the day\\nthe share was bought ie dp[i-1][m], here m = [0,j).\\ndp[i][j] = max(dp[i][j-1], (p[j]-p[m])+dp[i-1][m])\\n\\nWe will need to calculate min value of (p[j]-p[m])+dp[i-1][m]\\nIt can arranged like p[j] + (dp[i-1][m] - p[m]) we have to maximise \\nthe values of the part in brackets.\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1033242,
                "title": "2-approaches-of-c-code-with-o-n-time-both-and-o-1-o-n-space-complexity",
                "content": "O(n) time & O(n) Space\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& a) {\\n        int n = a.size(), ans = 0;\\n        if(n<=1) return 0;\\n        vector<int> left(n,0), right(n,0); //two arrays to get max profit from left and max profit from right direction\\n\\t\\t//to get max Profit moving from left direction, the leftmin till the current index should be a minima\\n\\t\\t//to get max Profit moving from right direction, the rightMax till the current index from right should be a maxima\\n        int leftmin=a[0], rightmax = a[n-1];\\n        \\n        for(int i=1, j=n-2; i<n && j>=0; i++, j--){\\n            left[i] = max(left[i-1], a[i]-leftmin);  //if the previous profit is more than the current selling than just copy or update the current profit to left index\\n            leftmin = min(leftmin, a[i]); //if current index is less than minimum from left\\n            right[j] = max(right[j+1], rightmax-a[j]);  \\n            rightmax = max(rightmax, a[j]); //if current index is more than maximum from right\\n        }\\n        \\n        for(int i=0;i<n;i++)    ans = max(ans, left[i]+right[i]); //get the index (partition) on which sum of profit from left part and right part should be maximum\\n        \\n        return ans;        \\n    }\\n};\\n```\\n----\\nThis is a simple buy selling approach, suppose, you are starting with 0 money, \\n1) you buy a stock of amount B1, then you are left with -B1 money (you are in debt)\\n2) then you sell this stock at S1, then the money left to you is S1-B1\\n3) Now if you again want to buy the stock of value B2, then the money left after buying is = money left (or gained) from previous buying and selling - current stock price, i.e. S1-B1-B2\\n4) then selling the stock at S2 will left (or gained) you with money = S1-B1-B2+S2\\n\\nO(n) time & O(1) Space\\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& a) {\\n        int n = a.size(), ans = 0;\\n        if(n<=1) return 0;\\n        int fb=INT_MIN, fs=0, sb = INT_MIN, ss = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            fb = max(fb, -a[i]);  //left on first buy\\n            fs = max(fs, fb+a[i]); //money you are with after selling that stock\\n            sb = max(sb, fs-a[i]); //you are again buying other stock with money fs, and left with money fs-a[i]\\n            ss = max(ss, sb+a[i]); //now selling that stock wll add up to the previous money left\\n        }\\n        return ss;        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& a) {\\n        int n = a.size(), ans = 0;\\n        if(n<=1) return 0;\\n        vector<int> left(n,0), right(n,0); //two arrays to get max profit from left and max profit from right direction\\n\\t\\t//to get max Profit moving from left direction, the leftmin till the current index should be a minima\\n\\t\\t//to get max Profit moving from right direction, the rightMax till the current index from right should be a maxima\\n        int leftmin=a[0], rightmax = a[n-1];\\n        \\n        for(int i=1, j=n-2; i<n && j>=0; i++, j--){\\n            left[i] = max(left[i-1], a[i]-leftmin);  //if the previous profit is more than the current selling than just copy or update the current profit to left index\\n            leftmin = min(leftmin, a[i]); //if current index is less than minimum from left\\n            right[j] = max(right[j+1], rightmax-a[j]);  \\n            rightmax = max(rightmax, a[j]); //if current index is more than maximum from right\\n        }\\n        \\n        for(int i=0;i<n;i++)    ans = max(ans, left[i]+right[i]); //get the index (partition) on which sum of profit from left part and right part should be maximum\\n        \\n        return ans;        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxProfit(vector<int>& a) {\\n        int n = a.size(), ans = 0;\\n        if(n<=1) return 0;\\n        int fb=INT_MIN, fs=0, sb = INT_MIN, ss = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            fb = max(fb, -a[i]);  //left on first buy\\n            fs = max(fs, fb+a[i]); //money you are with after selling that stock\\n            sb = max(sb, fs-a[i]); //you are again buying other stock with money fs, and left with money fs-a[i]\\n            ss = max(ss, sb+a[i]); //now selling that stock wll add up to the previous money left\\n        }\\n        return ss;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1004944,
                "title": "intuition-reformulation-of-approach-2-one-pass-simulation-python3",
                "content": "I tweaked the \"One-pass Simulation\" approach slightly to make it (in my opinion) much more intuitive, without affecting performance at all.\\n\\nYou want to make the most money that you can by completing two transactions. You can do this with one pass through the array. You have to keep track of three pieces of information:\\n1. If I completed the best transaction until this point, how much money would I make (i.e. the first problem in the series).\\n2. At which point can I acquire a second stock and keep the most money in my pocket. The money that I have will be firstProfit-secondPrice. (Note that this value could be negative, if the second stock costs more than you made from the first one. This is not a problem, as you will make that money back when you sell the second stock)\\n\\t\\t\\n\\tYou can solve the problem in one iteration through the array. The way to accomplish this is to ask: If I do the best transaction until now and buy the second stock at the current price, will I end up with more money in my pocket than I would have in a previous stage of the iteration.\\n\\t```\\n\\tmostMoneyInPocket = max(mostMoneyInPocket, firstTransactionProfit - currentPrice)\\n\\t```\\n3. What is the highest price that I can sell that second stock for? Since I already bought it all I have to do is find the highest price to sell it for.\\n\\n\\tAs you iterate, ask: if I sold it at the current price, would it make more money than selling it earlier?\\n\\t```\\n\\tprofitFromTwoTransactions = max(secondProfit, mostMoneyInPocket + currentPrice)\\n\\t```\\n\\n```\\nclass Solution:\\n\\tdef maxProfit(self, prices: List[int]) -> int:\\n\\t\\tfirstTransactionCost = prices[0]\\n\\t\\tfirstTransactionProfit = 0\\n\\n\\t\\tmostMoneyInPocket = -prices[0] \\n\\t\\tprofitFromTwoTransactions = 0 \\n\\n\\t\\tfor currentPrice in prices:\\n\\t\\t\\tfirstTransactionCost = min(firstTransactionCost, currentPrice) \\n\\t\\t\\tfirstTransactionProfit = max(firstTransactionProfit, currentPrice-firstTransactionCost)\\n\\n\\t\\t\\tmostMoneyInPocket = max(mostMoneyInPocket, firstTransactionProfit-currentPrice)\\n\\t\\t\\tprofitFromTwoTransactions = max(profitFromTwoTransactions, mostMoneyInPocket+currentPrice)\\n\\t\\treturn profitFromTwoTransactions\\n```",
                "solutionTags": [],
                "code": "```\\n\\tmostMoneyInPocket = max(mostMoneyInPocket, firstTransactionProfit - currentPrice)\\n\\t```\n```\\n\\tprofitFromTwoTransactions = max(secondProfit, mostMoneyInPocket + currentPrice)\\n\\t```\n```\\nclass Solution:\\n\\tdef maxProfit(self, prices: List[int]) -> int:\\n\\t\\tfirstTransactionCost = prices[0]\\n\\t\\tfirstTransactionProfit = 0\\n\\n\\t\\tmostMoneyInPocket = -prices[0] \\n\\t\\tprofitFromTwoTransactions = 0 \\n\\n\\t\\tfor currentPrice in prices:\\n\\t\\t\\tfirstTransactionCost = min(firstTransactionCost, currentPrice) \\n\\t\\t\\tfirstTransactionProfit = max(firstTransactionProfit, currentPrice-firstTransactionCost)\\n\\n\\t\\t\\tmostMoneyInPocket = max(mostMoneyInPocket, firstTransactionProfit-currentPrice)\\n\\t\\t\\tprofitFromTwoTransactions = max(profitFromTwoTransactions, mostMoneyInPocket+currentPrice)\\n\\t\\treturn profitFromTwoTransactions\\n```",
                "codeTag": "Java"
            },
            {
                "id": 954604,
                "title": "explained-js-solution",
                "content": "```\\n/*\\nleft[i] is the maximum possible profit via one transaction during first day to day i\\nright[i] is the maximum possible profit via one transaction during day i to last day\\nmaxProfit[i] is the maximum possible profit via two transactions, one during first day to day i and the other from day i+1 to last day\\n    maxProfit[i] = left[i] + right[i+1]\\n*/\\nvar maxProfit = function(prices) {\\n    if (prices === null || prices.length === 0) {\\n        return 0;\\n    }\\n    let left = new Array(prices.length);\\n    let right = new Array(prices.length);\\n    left[0] = 0;\\n    let buyingPrice = prices[0], profit = 0;\\n    for (let i = 1; i < prices.length; i++) {\\n        profit = Math.max(profit, prices[i] - buyingPrice);\\n        left[i] = profit;\\n        buyingPrice = Math.min(prices[i], buyingPrice);\\n    }\\n    \\n    profit = 0;\\n    right[prices.length-1] = 0;\\n    let sellingPrice = prices[prices.length - 1];\\n    for (let i = prices.length - 2; i >= 0; i--) {\\n        profit = Math.max(profit, sellingPrice - prices[i]);\\n        right[i] = profit;\\n        sellingPrice = Math.max(prices[i], sellingPrice);\\n    }\\n    \\n    let maxProfit = new Array(prices.length);\\n    maxProfit[prices.length-1] = left[prices.length-1];\\n    for (let i = 0; i < prices.length-1; i++) {\\n        maxProfit[i] = left[i] + right[i+1];\\n    }\\n    return Math.max(...maxProfit);\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/*\\nleft[i] is the maximum possible profit via one transaction during first day to day i\\nright[i] is the maximum possible profit via one transaction during day i to last day\\nmaxProfit[i] is the maximum possible profit via two transactions, one during first day to day i and the other from day i+1 to last day\\n    maxProfit[i] = left[i] + right[i+1]\\n*/\\nvar maxProfit = function(prices) {\\n    if (prices === null || prices.length === 0) {\\n        return 0;\\n    }\\n    let left = new Array(prices.length);\\n    let right = new Array(prices.length);\\n    left[0] = 0;\\n    let buyingPrice = prices[0], profit = 0;\\n    for (let i = 1; i < prices.length; i++) {\\n        profit = Math.max(profit, prices[i] - buyingPrice);\\n        left[i] = profit;\\n        buyingPrice = Math.min(prices[i], buyingPrice);\\n    }\\n    \\n    profit = 0;\\n    right[prices.length-1] = 0;\\n    let sellingPrice = prices[prices.length - 1];\\n    for (let i = prices.length - 2; i >= 0; i--) {\\n        profit = Math.max(profit, sellingPrice - prices[i]);\\n        right[i] = profit;\\n        sellingPrice = Math.max(prices[i], sellingPrice);\\n    }\\n    \\n    let maxProfit = new Array(prices.length);\\n    maxProfit[prices.length-1] = left[prices.length-1];\\n    for (let i = 0; i < prices.length-1; i++) {\\n        maxProfit[i] = left[i] + right[i+1];\\n    }\\n    return Math.max(...maxProfit);\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 880434,
                "title": "python-minsofar-maxsofar-clean-code-o-n",
                "content": "```python\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        n = len(prices)\\n        leftProfits = [0] * n\\n        rightProfits = [0] * n\\n        minSoFar = prices[0]\\n        maxSoFar = prices[-1]\\n        for i in range(1, n):\\n            leftProfits[i] = max(leftProfits[i-1], prices[i]-minSoFar)\\n            minSoFar = min(minSoFar, prices[i])\\n            \\n            j = n - i - 1\\n            rightProfits[j] = max(rightProfits[j+1], maxSoFar - prices[j])\\n            maxSoFar = max(maxSoFar, prices[j])\\n        \\n        maxProfit = leftProfits[n-1]\\n        for i in range(n-1):\\n            maxProfit = max(maxProfit, leftProfits[i] + rightProfits[i+1])\\n        return maxProfit\\n```\\nTime & Space: `O(N)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def maxProfit(self, prices):\\n        n = len(prices)\\n        leftProfits = [0] * n\\n        rightProfits = [0] * n\\n        minSoFar = prices[0]\\n        maxSoFar = prices[-1]\\n        for i in range(1, n):\\n            leftProfits[i] = max(leftProfits[i-1], prices[i]-minSoFar)\\n            minSoFar = min(minSoFar, prices[i])\\n            \\n            j = n - i - 1\\n            rightProfits[j] = max(rightProfits[j+1], maxSoFar - prices[j])\\n            maxSoFar = max(maxSoFar, prices[j])\\n        \\n        maxProfit = leftProfits[n-1]\\n        for i in range(n-1):\\n            maxProfit = max(maxProfit, leftProfits[i] + rightProfits[i+1])\\n        return maxProfit\\n```",
                "codeTag": "Java"
            },
            {
                "id": 795861,
                "title": "javascript-dp-o-n-2-loops-intuitive-solution-with-a-lot-of-explanations",
                "content": "I learn this from another O (n * n) solution, breaking this down makes everything so much easier to understand. This basically borrowed the concept from Best Time to Buy Sell Stock I. \\n\\nFirstly, calculate the max profit in the 1st run then we borrow the 1st run result during 2nd run.\\n\\nExample input:  [3,3,5,0,0,3,1,4]\\n1st run dp =  [0,0,2,2,2,3,3,4]; // 1st min = 3, profit = 2; 2nd min = 0, profit = 4;\\n2nd run dp = [0,0,2,2,2,5,5,6]; // 1st min = 3, profit = 2; 2nd min = 0 - dp[4] = 0 - 2, profit = 6 \\n\\nYou may wonder how does this solve the logic of 2nd buy before 1st sell. It is because dp[4] = 2 which is basically the cut off of the profit before end of day 4; Subract the current price, $0, with profit we make, we can think of the current price as $-2. \\n\\n```\\nvar maxProfit = function(prices) {\\n  if(prices.length == 0) return 0\\n  \\n  let dp = new Array(prices.length).fill(0);\\n  let min = prices[0];\\n  let max = 0;\\n  for (let i = 1; i < prices.length; i++) {\\n    min = Math.min(min, prices[i]);  // or Math.min(min, prices[i] - dp[i]) , FYI: dp[i] is 0\\n    max = Math.max(max, prices[i] - min);\\n    dp[i] = max;\\n  }\\n  \\n  // 1st run dp = [0,0,2,2,2,3,3,4];\\n  \\n  min = prices[0];\\n  max = 0;\\n  for (let i = 1; i < prices.length; i++) {\\n    min = Math.min(min, prices[i] - dp[i]); // substract dp[i]  = current price - what profit we made during 1st run.\\n    max = Math.max(max, prices[i] - min);\\n    dp[i] = max;\\n  }\\n  \\n  // 2nd run dp = [0,0,2,2,2,5,5,6];\\n  \\n  return dp.pop();\\n};\\n\\n```\\n\\nThen we now discuss the solution all over the discussion. \\nThis solution consolidates the above 2 dp results in one loop which is genius. If you print out sell1, you will see it\\'s the 1st-run dp result and sell2 is the 2nd-run dp result; \\n\\n```\\nvar maxProfit = function(prices) {\\n  let sell2 = 0, sell1 = 0, buy1 = -Infinity, buy2 = -Infinity;\\n  for (let i = 0; i < prices.length; i++) {\\n\\t\\tbuy1 = Math.max(buy1, -prices[i]);\\n    sell1 = Math.max(sell1, buy1 + prices[i]);\\n    buy2 = Math.max(buy2, sell1 - prices[i]);\\n    sell2 = Math.max(sell2, buy2 + prices[i]);\\n    console.log(`buy1: ${buy1} | sell1: ${sell1} | buy2: ${buy2} | sell2: ${sell2} | price: ${prices[i]}`);\\n  }\\n  return sell2;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar maxProfit = function(prices) {\\n  if(prices.length == 0) return 0\\n  \\n  let dp = new Array(prices.length).fill(0);\\n  let min = prices[0];\\n  let max = 0;\\n  for (let i = 1; i < prices.length; i++) {\\n    min = Math.min(min, prices[i]);  // or Math.min(min, prices[i] - dp[i]) , FYI: dp[i] is 0\\n    max = Math.max(max, prices[i] - min);\\n    dp[i] = max;\\n  }\\n  \\n  // 1st run dp = [0,0,2,2,2,3,3,4];\\n  \\n  min = prices[0];\\n  max = 0;\\n  for (let i = 1; i < prices.length; i++) {\\n    min = Math.min(min, prices[i] - dp[i]); // substract dp[i]  = current price - what profit we made during 1st run.\\n    max = Math.max(max, prices[i] - min);\\n    dp[i] = max;\\n  }\\n  \\n  // 2nd run dp = [0,0,2,2,2,5,5,6];\\n  \\n  return dp.pop();\\n};\\n\\n```\n```\\nvar maxProfit = function(prices) {\\n  let sell2 = 0, sell1 = 0, buy1 = -Infinity, buy2 = -Infinity;\\n  for (let i = 0; i < prices.length; i++) {\\n\\t\\tbuy1 = Math.max(buy1, -prices[i]);\\n    sell1 = Math.max(sell1, buy1 + prices[i]);\\n    buy2 = Math.max(buy2, sell1 - prices[i]);\\n    sell2 = Math.max(sell2, buy2 + prices[i]);\\n    console.log(`buy1: ${buy1} | sell1: ${sell1} | buy2: ${buy2} | sell2: ${sell2} | price: ${prices[i]}`);\\n  }\\n  return sell2;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 785175,
                "title": "c-simple-solution",
                "content": "```\\n int maxProfit(vector<int>& prices) \\n    {\\n        int firstbuy=INT_MIN;\\n        int firstsell=0;\\n        int secondbuy=INT_MIN;\\n        int secondsell=0;\\n        for(int i=0;i<prices.size();i++)\\n        {\\n            firstbuy=max(firstbuy,-prices[i]);//loss of money\\n            firstsell=max(firstsell,firstbuy+prices[i]);//gain of money\\n            secondbuy=max(secondbuy,firstsell-prices[i]);//loss of money\\n            secondsell=max(secondsell,secondbuy+prices[i]);//gain of money\\n        }\\n        return secondsell;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n int maxProfit(vector<int>& prices) \\n    {\\n        int firstbuy=INT_MIN;\\n        int firstsell=0;\\n        int secondbuy=INT_MIN;\\n        int secondsell=0;\\n        for(int i=0;i<prices.size();i++)\\n        {\\n            firstbuy=max(firstbuy,-prices[i]);//loss of money\\n            firstsell=max(firstsell,firstbuy+prices[i]);//gain of money\\n            secondbuy=max(secondbuy,firstsell-prices[i]);//loss of money\\n            secondsell=max(secondsell,secondbuy+prices[i]);//gain of money\\n        }\\n        return secondsell;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 703338,
                "title": "cpp-best-dp-solution-with-video-link",
                "content": "Hi Guys, \\nif you aren\\'t getting the code, no problem just watch this concept then come back and see I have attached the dp solution with space optimization as well and you will get that. If find helpful do upvote as this problem is very important so that others can find this too.\\n\\nhttps://www.youtube.com/watch?v=Pw6lrYANjz4\\n\\n**Also with some modifications you can submit this code, for the problem: 188. Best Time to Buy and Sell Stock IV**\\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/\\n\\n**happy to help, just if you find this helpful please upvote : )**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    // Generic here pass k = 2, meaning we can do at most 2 transactions\\n    // time complexity: O(nk)\\n    // space complexity: O(nk)\\n    int maxProfitWithKTransactions(vector<int> prices, int k) {\\n        if (prices.size() == 0) {\\n            return 0;\\n        }\\n\\n        // create the dp table\\n        int n = prices.size();\\n        vector<vector<int>> dp(k + 1, vector<int>(n, 0));\\n\\n        // As the base cases are already get filled since when we\\n        // initialized with 0 all cells\\n\\n        for (int t = 1; t < k + 1; t++) {\\n            int maxThusFar = INT_MIN;\\n            for (int d = 1; d < n; d++) {\\n                maxThusFar = max(maxThusFar, dp[t - 1][d - 1] - prices[d - 1]);\\n\\n                dp[t][d] = max(dp[t][d - 1], maxThusFar + prices[d]);\\n            }\\n        }\\n\\n        return dp[k][n - 1];\\n    }\\n    \\n    // Let\\'s optimize the space ---> O(2n) = O(n)\\n    // time complexity: O(nk)\\nint maxProfitWithKTransactions_optimized(vector<int> prices, int k) {\\n\\tif (prices.size() == 0) {\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tint n = prices.size();\\n\\tvector<vector<int>> profits(2, vector<int>(n, 0));\\n\\n\\tfor (int t = 1; t <= k; t++) {\\n\\t\\tint maxThusFar = INT_MIN;\\n\\t\\t// Now switching the right row to current profit and other one\\n\\t\\t// to previous one\\n\\t\\tint row = t % 2;\\n\\n\\t\\t// Now start the second loop\\n\\t\\tfor (int d = 1; d < n; d++) {\\n\\t\\t\\tint prev_row = (row + 1) % 2;\\n            // Like onw we did in circular loop array\\n\\t\\t\\tmaxThusFar = max(maxThusFar, profits[prev_row][d - 1] - prices[d - 1]);\\n\\t\\t\\tprofits[row][d] = max(profits[row][d - 1], maxThusFar + prices[d]);\\n\\t\\t}\\n\\t}\\n\\n\\treturn (k % 2 == 0) ? profits[0][n - 1] : profits[1][n - 1];\\n}\\n    \\n    int maxProfit(vector<int>& prices) {\\n        // return maxProfitWithKTransactions(prices, 2);\\n        \\n        // calling space opimized solution\\n        return maxProfitWithKTransactions_optimized(prices, 2);\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // Generic here pass k = 2, meaning we can do at most 2 transactions\\n    // time complexity: O(nk)\\n    // space complexity: O(nk)\\n    int maxProfitWithKTransactions(vector<int> prices, int k) {\\n        if (prices.size() == 0) {\\n            return 0;\\n        }\\n\\n        // create the dp table\\n        int n = prices.size();\\n        vector<vector<int>> dp(k + 1, vector<int>(n, 0));\\n\\n        // As the base cases are already get filled since when we\\n        // initialized with 0 all cells\\n\\n        for (int t = 1; t < k + 1; t++) {\\n            int maxThusFar = INT_MIN;\\n            for (int d = 1; d < n; d++) {\\n                maxThusFar = max(maxThusFar, dp[t - 1][d - 1] - prices[d - 1]);\\n\\n                dp[t][d] = max(dp[t][d - 1], maxThusFar + prices[d]);\\n            }\\n        }\\n\\n        return dp[k][n - 1];\\n    }\\n    \\n    // Let\\'s optimize the space ---> O(2n) = O(n)\\n    // time complexity: O(nk)\\nint maxProfitWithKTransactions_optimized(vector<int> prices, int k) {\\n\\tif (prices.size() == 0) {\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tint n = prices.size();\\n\\tvector<vector<int>> profits(2, vector<int>(n, 0));\\n\\n\\tfor (int t = 1; t <= k; t++) {\\n\\t\\tint maxThusFar = INT_MIN;\\n\\t\\t// Now switching the right row to current profit and other one\\n\\t\\t// to previous one\\n\\t\\tint row = t % 2;\\n\\n\\t\\t// Now start the second loop\\n\\t\\tfor (int d = 1; d < n; d++) {\\n\\t\\t\\tint prev_row = (row + 1) % 2;\\n            // Like onw we did in circular loop array\\n\\t\\t\\tmaxThusFar = max(maxThusFar, profits[prev_row][d - 1] - prices[d - 1]);\\n\\t\\t\\tprofits[row][d] = max(profits[row][d - 1], maxThusFar + prices[d]);\\n\\t\\t}\\n\\t}\\n\\n\\treturn (k % 2 == 0) ? profits[0][n - 1] : profits[1][n - 1];\\n}\\n    \\n    int maxProfit(vector<int>& prices) {\\n        // return maxProfitWithKTransactions(prices, 2);\\n        \\n        // calling space opimized solution\\n        return maxProfitWithKTransactions_optimized(prices, 2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 702602,
                "title": "python3-dp",
                "content": "Recall that in [121. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/discuss/695515/Python3-two-approaches), there are two approaches \\n1) buy low & sell high;\\n2) Kadane\\'s algorithm.\\n\\nBoth approaches could be generalized into cases with multiple transactions, say `K`. \\n\\n**Approach 1 -- buy low & sell high (`O(NK)` time & `O(1)` space)**\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        buy, sell = [inf]*2, [0]*2\\n        for x in prices:\\n            for i in range(2): \\n                if i: buy[i] = min(buy[i], x - sell[i-1])\\n                else: buy[i] = min(buy[i], x)\\n                sell[i] = max(sell[i], x - buy[i])\\n        return sell[1]\\n```\\n\\n**Approach 2 -- Kadane\\'s algo**\\nThe second approach is to extend Kadane\\'s algorithm to the cases with multiple transaction (`O(NK)` time & `O(N)` space)\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        pnl = [0]*len(prices)\\n        for _ in range(2):\\n            most = 0\\n            for i in range(1, len(prices)): \\n                most = max(pnl[i], most + prices[i] - prices[i-1])\\n                pnl[i] = max(pnl[i-1], most)\\n        return pnl[-1]\\n```\\n\\nApparently, Kadane\\'s algorithm in this setting has no advantage over \"buy low & sell high\" since its space usage `O(N)` can be significantly higher.\\n\\n**Reference**\\n[121. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/discuss/695515/Python3-two-approaches)\\n[122. Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/discuss/565654/Python3-greedy-and-dp)\\n[123. Best Time to Buy and Sell Stock III](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/discuss/702602/Python3-two-approaches)\\n[188. Best Time to Buy and Sell Stock IV](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/discuss/702612/Python3-two-approaches)\\n[309. Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/discuss/762801/Python3-dp)\\n[714. Best Time to Buy and Sell Stock with Transaction Fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/discuss/1532323/Python3-dp)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        buy, sell = [inf]*2, [0]*2\\n        for x in prices:\\n            for i in range(2): \\n                if i: buy[i] = min(buy[i], x - sell[i-1])\\n                else: buy[i] = min(buy[i], x)\\n                sell[i] = max(sell[i], x - buy[i])\\n        return sell[1]\\n```\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        pnl = [0]*len(prices)\\n        for _ in range(2):\\n            most = 0\\n            for i in range(1, len(prices)): \\n                most = max(pnl[i], most + prices[i] - prices[i-1])\\n                pnl[i] = max(pnl[i-1], most)\\n        return pnl[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 561296,
                "title": "java-o-n-o-1-with-self-explanatory-code",
                "content": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int onebuy = Integer.MAX_VALUE;\\n        int twobuy = Integer.MAX_VALUE;\\n        int twosell = 0;\\n        int onesell = 0;\\n        \\n        for(int i = 0 ; i < prices.length ; i++){\\n            onebuy = Math.min(onebuy,prices[i]);\\n            onesell = Math.max(onesell,prices[i]-onebuy);\\n            twobuy = Math.min(twobuy,prices[i]-onesell);\\n            twosell = Math.max(twosell,prices[i]-twobuy);\\n        }\\n        \\n        return Math.max(twosell,onesell);\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int onebuy = Integer.MAX_VALUE;\\n        int twobuy = Integer.MAX_VALUE;\\n        int twosell = 0;\\n        int onesell = 0;\\n        \\n        for(int i = 0 ; i < prices.length ; i++){\\n            onebuy = Math.min(onebuy,prices[i]);\\n            onesell = Math.max(onesell,prices[i]-onebuy);\\n            twobuy = Math.min(twobuy,prices[i]-onesell);\\n            twosell = Math.max(twosell,prices[i]-twobuy);\\n        }\\n        \\n        return Math.max(twosell,onesell);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531135,
                "title": "java-dp-solution",
                "content": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n = prices.length;\\n        if(n == 0) return 0;\\n        // phase 0: begin\\n        // phase 1: after first buy\\n        // phase 2: after first sell\\n        // phase 3: after second buy\\n        // phase 4: after second sell\\n        int[][] dp = new int[5][n];\\n        \\n        // initiate\\n        dp[0][0] = 0;\\n        dp[1][0] = -prices[0];\\n        dp[2][0] = 0;\\n        dp[3][0] = -prices[0];\\n        dp[4][0] = 0;\\n        \\n        // state transfer\\n        for(int i = 1; i < n; i++) {\\n            int price = prices[i];\\n            \\n            dp[0][i] = 0;\\n            dp[1][i] = Math.max(dp[1][i - 1], -price);\\n            dp[2][i] = Math.max(dp[2][i - 1], dp[1][i - 1] + price);\\n            dp[3][i] = Math.max(dp[3][i - 1], dp[2][i - 1] - price);\\n            dp[4][i] = Math.max(dp[4][i - 1], dp[3][i - 1] + price);\\n        }\\n        \\n        // get result\\n        return Math.max(dp[2][n - 1], dp[4][n - 1]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxProfit(int[] prices) {\\n        int n = prices.length;\\n        if(n == 0) return 0;\\n        // phase 0: begin\\n        // phase 1: after first buy\\n        // phase 2: after first sell\\n        // phase 3: after second buy\\n        // phase 4: after second sell\\n        int[][] dp = new int[5][n];\\n        \\n        // initiate\\n        dp[0][0] = 0;\\n        dp[1][0] = -prices[0];\\n        dp[2][0] = 0;\\n        dp[3][0] = -prices[0];\\n        dp[4][0] = 0;\\n        \\n        // state transfer\\n        for(int i = 1; i < n; i++) {\\n            int price = prices[i];\\n            \\n            dp[0][i] = 0;\\n            dp[1][i] = Math.max(dp[1][i - 1], -price);\\n            dp[2][i] = Math.max(dp[2][i - 1], dp[1][i - 1] + price);\\n            dp[3][i] = Math.max(dp[3][i - 1], dp[2][i - 1] - price);\\n            dp[4][i] = Math.max(dp[4][i - 1], dp[3][i - 1] + price);\\n        }\\n        \\n        // get result\\n        return Math.max(dp[2][n - 1], dp[4][n - 1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 529026,
                "title": "finite-state-machine",
                "content": "I see a lot of people referring to the O(1) space solution for this problem as dynamic programming. While that may technically fit in the definition of DP, to me it\\'s more helpful to think of it as a finite state machine.\\n\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if not prices:\\n            return 0\\n        \\n        sold1 = 0\\n        bought1 = -float(\\'inf\\')\\n        sold2 = 0\\n        bought2 = -float(\\'inf\\')\\n        \\n        for pr in prices:\\n            bought1 = max(bought1, -pr)\\n            sold1 = max(sold1, pr + bought1)\\n            bought2 = max(bought2, sold1 - pr)\\n            sold2 = max(sold2, pr + bought2)\\n            \\n        return sold2\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        if not prices:\\n            return 0\\n        \\n        sold1 = 0\\n        bought1 = -float(\\'inf\\')\\n        sold2 = 0\\n        bought2 = -float(\\'inf\\')\\n        \\n        for pr in prices:\\n            bought1 = max(bought1, -pr)\\n            sold1 = max(sold1, pr + bought1)\\n            bought2 = max(bought2, sold1 - pr)\\n            sold2 = max(sold2, pr + bought2)\\n            \\n        return sold2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 504181,
                "title": "c-easy-understanding-o-n-time-o-1-space-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxProfit(vector<int>& prices) {\\n\\t\\t\\tint oneBuy=INT_MIN/2;\\n\\t\\t\\tint oneBuyoneSell=INT_MIN/2;\\n\\t\\t\\tint secondBuy=INT_MIN/2;\\n\\t\\t\\tint secondBuysecondSell=INT_MIN/2;\\n\\t\\t\\tfor(int i=0;i<prices.size();i++){\\n\\t\\t\\t\\tint preoneBuy=oneBuy;\\n\\t\\t\\t\\tint preoneBuyoneSell=oneBuyoneSell;\\n\\t\\t\\t\\tint presecondBuy=secondBuy;\\n\\t\\t\\t\\toneBuy=max(oneBuy,-prices[i]);\\n\\t\\t\\t\\toneBuyoneSell=max(oneBuyoneSell,preoneBuy+prices[i]);\\n\\t\\t\\t\\tsecondBuy=max(secondBuy,preoneBuyoneSell-prices[i]);\\n\\t\\t\\t\\tsecondBuysecondSell=max(secondBuysecondSell,presecondBuy+prices[i]);\\n\\t\\t\\t}\\n\\t\\t\\treturn max(oneBuyoneSell,secondBuysecondSell) <0 ?   0:max(oneBuyoneSell,secondBuysecondSell);\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint maxProfit(vector<int>& prices) {\\n\\t\\t\\tint oneBuy=INT_MIN/2;\\n\\t\\t\\tint oneBuyoneSell=INT_MIN/2;\\n\\t\\t\\tint secondBuy=INT_MIN/2;\\n\\t\\t\\tint secondBuysecondSell=INT_MIN/2;\\n\\t\\t\\tfor(int i=0;i<prices.size();i++){\\n\\t\\t\\t\\tint preoneBuy=oneBuy;\\n\\t\\t\\t\\tint preoneBuyoneSell=oneBuyoneSell;\\n\\t\\t\\t\\tint presecondBuy=secondBuy;\\n\\t\\t\\t\\toneBuy=max(oneBuy,-prices[i]);\\n\\t\\t\\t\\toneBuyoneSell=max(oneBuyoneSell,preoneBuy+prices[i]);\\n\\t\\t\\t\\tsecondBuy=max(secondBuy,preoneBuyoneSell-prices[i]);\\n\\t\\t\\t\\tsecondBuysecondSell=max(secondBuysecondSell,presecondBuy+prices[i]);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 478218,
                "title": "c-simple-o-1-and-o-n-space-solutions-detailed-explanation",
                "content": "**Solution 1**\\nWe use state transition for this. Since there are two transactions, that means there are 4 states:\\n\\n**(Bought1)**---sell---->**(Sold1)**-----buy----->**(Bought2)**------sell----->**(Sold2)**\\n\\nAlso for each of the states, we can decide to not do anything, that would mean just using the\\ncurrent state.\\n**Time: O(N), Space: O(1)**\\n```\\n// Solution 1: Using state transitions\\nint maxProfit(vector<int>& prices) {\\n\\tif(prices.empty())\\n\\t\\treturn 0;\\n\\n\\t// All the variables below are in terms of profit we have \\n\\t// Bought for the first time\\n\\tint bought1 = -1 * prices[0];\\n\\t// Sold for the first time\\n\\tint sold1 = 0;\\n\\t// Bought for the second time\\n\\tint bought2 = INT_MIN;\\n\\t// Sold for the second time\\n\\tint sold2 = 0;\\n\\n\\tfor(int i = 1; i < prices.size(); i++) {\\n\\t\\tbought1 = max(bought1, -1 * prices[i]);\\n\\t\\tsold1 = max(sold1, bought1 + prices[i]);\\n\\t\\tbought2 = max(bought2, sold1 - prices[i]);\\n\\t\\tsold2 = max(sold2, bought2 + prices[i]);\\n\\t}\\n\\n\\treturn sold2;\\n}\\n```\\n\\n\\n**Solution 2**\\nWe keep track of maximum profit that can be made if a stock is sold on ith day.\\nThis can be done by tracking the min stock price till i-th day by traversing from left.\\nWe store the above info, then we start traversing from right side keeping track of max price and max profit.\\nMax right price till i-th day corresponds to share price at which any stock bought before\\nbefore i-th day can be sold. Also track the max profit of doing the second transaction.\\n\\nSo the day which gives the max combined profit for the above two will be the final answer.\\n\\n**Time: O(N), Space:O(N)**\\n\\n```\\n// Solution 2\\nint maxProfit2(vector<int>& prices) {\\n\\tif(prices.empty())\\n\\t\\treturn 0;\\n\\n\\t// i-th entry: max profit that can be made by selling stock that day\\n\\tvector<int> max_profit_today(prices.size(), 0);\\n\\tint min_stock_so_far = prices.front(), max_stock_after_this = prices.back();\\n\\tint max_profit = 0;\\n\\t// max profit that can be made by doing a transaction after current day\\n\\tint max_profit_after_this = 0;\\n\\n\\t// find the profit that can be made by doing first transaction\\n\\tfor(int i = 0; i < prices.size(); i++) {\\n\\t\\t// this is updated first so that we there is no stock with lower, price\\n\\t\\t// then profit stays 0 instead of selling at a loss\\n\\t\\tmin_stock_so_far = min(min_stock_so_far, prices[i]);\\n\\t\\tmax_profit_today[i] = prices[i] - min_stock_so_far;\\n\\t}\\n\\n\\t// profit that can be made by doing the second transaction\\n\\tfor(int i = prices.size() - 1; i >= 0; i--) {\\n\\t\\t// update max stock on right\\n\\t\\tmax_stock_after_this = max(max_stock_after_this, prices[i]);\\n\\t\\t// check if the current stock if bought and sold later can make the max profit for 2nd transaction\\n\\t\\tmax_profit_after_this = max(max_profit_after_this, \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t(max_stock_after_this - prices[i]));\\n\\t\\tmax_profit = max(max_profit,\\n\\t\\t\\t\\t\\t\\tmax_profit_today[i] + max_profit_after_this);\\n\\t}\\n\\n\\treturn max_profit;\\n}\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n// Solution 1: Using state transitions\\nint maxProfit(vector<int>& prices) {\\n\\tif(prices.empty())\\n\\t\\treturn 0;\\n\\n\\t// All the variables below are in terms of profit we have \\n\\t// Bought for the first time\\n\\tint bought1 = -1 * prices[0];\\n\\t// Sold for the first time\\n\\tint sold1 = 0;\\n\\t// Bought for the second time\\n\\tint bought2 = INT_MIN;\\n\\t// Sold for the second time\\n\\tint sold2 = 0;\\n\\n\\tfor(int i = 1; i < prices.size(); i++) {\\n\\t\\tbought1 = max(bought1, -1 * prices[i]);\\n\\t\\tsold1 = max(sold1, bought1 + prices[i]);\\n\\t\\tbought2 = max(bought2, sold1 - prices[i]);\\n\\t\\tsold2 = max(sold2, bought2 + prices[i]);\\n\\t}\\n\\n\\treturn sold2;\\n}\\n```\n```\\n// Solution 2\\nint maxProfit2(vector<int>& prices) {\\n\\tif(prices.empty())\\n\\t\\treturn 0;\\n\\n\\t// i-th entry: max profit that can be made by selling stock that day\\n\\tvector<int> max_profit_today(prices.size(), 0);\\n\\tint min_stock_so_far = prices.front(), max_stock_after_this = prices.back();\\n\\tint max_profit = 0;\\n\\t// max profit that can be made by doing a transaction after current day\\n\\tint max_profit_after_this = 0;\\n\\n\\t// find the profit that can be made by doing first transaction\\n\\tfor(int i = 0; i < prices.size(); i++) {\\n\\t\\t// this is updated first so that we there is no stock with lower, price\\n\\t\\t// then profit stays 0 instead of selling at a loss\\n\\t\\tmin_stock_so_far = min(min_stock_so_far, prices[i]);\\n\\t\\tmax_profit_today[i] = prices[i] - min_stock_so_far;\\n\\t}\\n\\n\\t// profit that can be made by doing the second transaction\\n\\tfor(int i = prices.size() - 1; i >= 0; i--) {\\n\\t\\t// update max stock on right\\n\\t\\tmax_stock_after_this = max(max_stock_after_this, prices[i]);\\n\\t\\t// check if the current stock if bought and sold later can make the max profit for 2nd transaction\\n\\t\\tmax_profit_after_this = max(max_profit_after_this, \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t(max_stock_after_this - prices[i]));\\n\\t\\tmax_profit = max(max_profit,\\n\\t\\t\\t\\t\\t\\tmax_profit_today[i] + max_profit_after_this);\\n\\t}\\n\\n\\treturn max_profit;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 414556,
                "title": "c-shortest-solution-o-n-with-explanation",
                "content": "If we have 1, 2, 3, 2, 5 we want to find the maximum profit moving forward (buy then sell).\\nWe also want to find the maximum profit moving backwards (sell then buy).\\nWe end up with a forward array and a backwards array.\\nForward max profit array:      0 1 2 2 4 \\nBackwards max profit array: 4 3 3 3 0\\n\\nRemember, each array represents cumulative max profit. Since you can only buy again after you\\'ve sold, you can\\nonly extract profit from the backwards array after you\\'ve locked in profit from the forward array.\\nIn other words, your maximum profit will be the maximum of forwardArray[i - 1] + backWardsArray[i];\\nSo in our example above, our maximum potential profit array is: 3 4 5 2 , and our maximum profit in that array is 5.\\n\\nThis array was created by doing: ForwardArray[0] + BackwardsArray[1], ForwardsArray[1] + BackwardsArray[2]....\\n\\nWe also have an edge case where the profit on the forward array is massive compared to on the backwards array. For instance, assume we have the following two arrays, forward and backwards\\n\\nForward: 0 1 2 20 1 1\\nBackwards: 0  0 5 0  0  0\\nIn this case, there is no point in doing F[i-1] + B[i] since the forward array has a profit point that out matches any potential forward and backwards combination  (20 > 7). Hence we only buy and sell once, yielding $20.\\n\\nIf this explanation helped you, please upvote so others can find it.\\n\\n```\\n    int maxProfit(vector<int>& prices) {\\n        if (prices.size() == 1) return 0;\\n\\n        int n = prices.size();\\n        vector<int> first_buy_and_sell(prices.size(), 0);\\n\\t\\n        int min_price_so_far = numeric_limits<int>::max();\\n        int first_buy_profit{};\\n\\n        for (int i{}; i < n; i++) {\\n            min_price_so_far = min(min_price_so_far, prices[i]);\\n            first_buy_profit = max(first_buy_profit, prices[i] - min_price_so_far);\\n            first_buy_and_sell[i] = first_buy_profit;\\n        }  // Find the maximum profit going forward, and keep a copy of it\\n\\n        int max_price_so_far = numeric_limits<int>::min();\\n        int max_profit{};\\n        for (int i = n - 1; i > 0; i--) {\\n            max_price_so_far = max(prices[i], max_price_so_far);\\n            max_profit = max(first_buy_and_sell[i],max(max_profit, max_price_so_far - prices[i] + first_buy_and_sell[i - 1]));\\n        } // We use two max functions above to account for the edge case detailed above.\\n        return max_profit;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "If we have 1, 2, 3, 2, 5 we want to find the maximum profit moving forward (buy then sell).\\nWe also want to find the maximum profit moving backwards (sell then buy).\\nWe end up with a forward array and a backwards array.\\nForward max profit array:      0 1 2 2 4 \\nBackwards max profit array: 4 3 3 3 0\\n\\nRemember, each array represents cumulative max profit. Since you can only buy again after you\\'ve sold, you can\\nonly extract profit from the backwards array after you\\'ve locked in profit from the forward array.\\nIn other words, your maximum profit will be the maximum of forwardArray[i - 1] + backWardsArray[i];\\nSo in our example above, our maximum potential profit array is: 3 4 5 2 , and our maximum profit in that array is 5.\\n\\nThis array was created by doing: ForwardArray[0] + BackwardsArray[1], ForwardsArray[1] + BackwardsArray[2]....\\n\\nWe also have an edge case where the profit on the forward array is massive compared to on the backwards array. For instance, assume we have the following two arrays, forward and backwards\\n\\nForward: 0 1 2 20 1 1\\nBackwards: 0  0 5 0  0  0\\nIn this case, there is no point in doing F[i-1] + B[i] since the forward array has a profit point that out matches any potential forward and backwards combination  (20 > 7). Hence we only buy and sell once, yielding $20.\\n\\nIf this explanation helped you, please upvote so others can find it.\\n\\n```\\n    int maxProfit(vector<int>& prices) {\\n        if (prices.size() == 1) return 0;\\n\\n        int n = prices.size();\\n        vector<int> first_buy_and_sell(prices.size(), 0);\\n\\t\\n        int min_price_so_far = numeric_limits<int>::max();\\n        int first_buy_profit{};\\n\\n        for (int i{}; i < n; i++) {\\n            min_price_so_far = min(min_price_so_far, prices[i]);\\n            first_buy_profit = max(first_buy_profit, prices[i] - min_price_so_far);\\n            first_buy_and_sell[i] = first_buy_profit;\\n        }  // Find the maximum profit going forward, and keep a copy of it\\n\\n        int max_price_so_far = numeric_limits<int>::min();\\n        int max_profit{};\\n        for (int i = n - 1; i > 0; i--) {\\n            max_price_so_far = max(prices[i], max_price_so_far);\\n            max_profit = max(first_buy_and_sell[i],max(max_profit, max_price_so_far - prices[i] + first_buy_and_sell[i - 1]));\\n        } // We use two max functions above to account for the edge case detailed above.\\n        return max_profit;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 404387,
                "title": "intuitive-python-o-n-time-and-o-1-space",
                "content": "max_p is simply extracts the max profit in an interval, but now also returns the index of buy and sell.\\nmax_p is called once on the whole list. once on the list previous up to the first purchase, and another on after the first purchase.\\nlast call on max_p is a little tricky in the sense that it is called on the interval of the first purchase of buy and sell reversed.\\n\\nan example is [6,8,7,10]. The first call will return very_low = 0, high = 3.\\nthere won\\'t be room to make a second transaction outside this interval. The max_p call on the middle interval finds the difference between the 8 and 7. This represents selling on 8 and buying on 7, which is a profitable transaction. \\n\\n```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        def max_p(ps):\\n            if not ps or len(ps) == 1:\\n                return 0, 0, 0\\n            very_low = 0\\n            low = 0\\n            high = 0\\n            profit = 0\\n\\n            for i, p in enumerate(ps):\\n                if p < ps[low]:\\n                    low = i\\n                elif p - ps[low] > profit:\\n                    high = i\\n                    very_low = low\\n                    profit = p - ps[low]\\n                    \\n            return very_low, high, profit\\n        \\n        low, high, profit = max_p(prices)\\n        _, _, profit_right = max_p(prices[0:low])\\n        _, _, profit_left = max_p(prices[high+1:])\\n        _, _, profit_middle = max_p(prices[low:high+1][::-1])\\n        \\n        return profit + max(profit_left, profit_middle, profit_right)\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxProfit(self, prices: List[int]) -> int:\\n        def max_p(ps):\\n            if not ps or len(ps) == 1:\\n                return 0, 0, 0\\n            very_low = 0\\n            low = 0\\n            high = 0\\n            profit = 0\\n\\n            for i, p in enumerate(ps):\\n                if p < ps[low]:\\n                    low = i\\n                elif p - ps[low] > profit:\\n                    high = i\\n                    very_low = low\\n                    profit = p - ps[low]\\n                    \\n            return very_low, high, profit\\n        \\n        low, high, profit = max_p(prices)\\n        _, _, profit_right = max_p(prices[0:low])\\n        _, _, profit_left = max_p(prices[high+1:])\\n        _, _, profit_middle = max_p(prices[low:high+1][::-1])\\n        \\n        return profit + max(profit_left, profit_middle, profit_right)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 352637,
                "title": "clean-code-to-see-the-recurrence-relation",
                "content": "Hi,\\nThis code might help you to see the recurrence relation. It passes 198/200 test cases. 2 test cases fail because of TLE.\\n\\n    int max = 0;\\n    public int maxProfit(int[] prices) {\\n        maxProfitRecurse(prices, 0, 0, 0);\\n        return max;    \\n    }\\n    private void maxProfitRecurse(int[] prices, int index, int bill, int transaction){\\n        max = Math.max(max, bill);\\n        if (index == prices.length || transaction >= 4){\\n            return;\\n        }\\n\\n        if(transaction % 2 == 0){\\n            maxProfitRecurse(prices, index+1, bill - prices[index], transaction + 1); //buy \\n            maxProfitRecurse(prices, index+1, bill, transaction); // skip\\n        } else{\\n            maxProfitRecurse(prices, index+1, bill + prices[index], transaction + 1); //sell \\n            maxProfitRecurse(prices, index+1, bill, transaction);\\n        }\\n    }",
                "solutionTags": [],
                "code": "Hi,\\nThis code might help you to see the recurrence relation. It passes 198/200 test cases. 2 test cases fail because of TLE.\\n\\n    int max = 0;\\n    public int maxProfit(int[] prices) {\\n        maxProfitRecurse(prices, 0, 0, 0);\\n        return max;    \\n    }\\n    private void maxProfitRecurse(int[] prices, int index, int bill, int transaction){\\n        max = Math.max(max, bill);\\n        if (index == prices.length || transaction >= 4){\\n            return;\\n        }\\n\\n        if(transaction % 2 == 0){\\n            maxProfitRecurse(prices, index+1, bill - prices[index], transaction + 1); //buy \\n            maxProfitRecurse(prices, index+1, bill, transaction); // skip\\n        } else{\\n            maxProfitRecurse(prices, index+1, bill + prices[index], transaction + 1); //sell \\n            maxProfitRecurse(prices, index+1, bill, transaction);\\n        }\\n    }",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1567201,
                "content": [
                    {
                        "username": "hongbin2",
                        "content": "We use DP to solve this problem by scan left from right and then right to left, and find out the max profits. \\nBut, what if transactions are 3 or more, how could we solve this problem?"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "Try solving Buy and Sell Stock IV"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@user9894br](/user9894br) yup \\n"
                    },
                    {
                        "username": "user9894br",
                        "content": "Seems like there should be a way solve it by recursion/DP - given any pair of dates for the first transaction you can then solve the 2-transaction problem on the date range in the future, etc."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Check this out, it explains really throughly every possible case.\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/75924/most-consistent-ways-of-dealing-with-the-series-of-stock-problems/"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "tell me what is 'two transactions'?\\nIf you buy real stock, you will be told a transaction means one buy OR one sell."
                    },
                    {
                        "username": "Ankit5ingh",
                        "content": "buy-> sell -> buy -> sell that\\'s it. max 2 transactions are allowed. one transaction means buy -> sell "
                    },
                    {
                        "username": "adherent____",
                        "content": "means you cannot buy sell more than 2 times,,,"
                    },
                    {
                        "username": "bapi007",
                        "content": "Example 1 output says 6 but I guess it should be 8.\\nBuy at 3 and sell at 5, profit 2\\nBuy at 0 and sell at 3, profit 3\\nBuy at 1 and sell at 4, profit 3\\nHence, total 8"
                    },
                    {
                        "username": "Dewanshdoley",
                        "content": "you cannot buy 2 stock at a time i.e u must sell before u buy and the traversal of day must be in continuous "
                    },
                    {
                        "username": "faisalasnari432",
                        "content": "[@nitishkamath89](/nitishkamath89) it is similar to the previous one but  where to put transaction condition "
                    },
                    {
                        "username": "nitishkamath89",
                        "content": "we are allowed  at max two transactions"
                    },
                    {
                        "username": "IvanSkl",
                        "content": "It gives an error on this test case:\\nInput:\\n[1,2,4,2,5,7,2,4,9,0]\\nOutput:\\n12\\nExpected:\\n13\\n\\nI\\'ve counted it by hand and it must be 12 as my program did. Buy on day 4 (price = 2) and sell on day 6 (price = 7), profit = 7-2 = 5. And buy on day 7 (price = 2) and sell on day 9 (price = 9), profit = 9-2 = 7. The output must be 12. But it expected 13. There is an error or I can\\'t undestand something?"
                    },
                    {
                        "username": "newtonkr",
                        "content": "[1,2,4,2,5,7] = 7-1 = 6\\n[2,4,9,0]= 9-2 = 7  (7+6 = 13)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "you should buy on day 1 (price=1) and sell on day 6(price=7), profit=7-1=6"
                    },
                    {
                        "username": "srivastavaanchal000",
                        "content": "buy on day 1(1) and sell on day 6(7) => profit = 6\\nbuy on day 7(2) and sell on day 9(9) => profit = 7\\ntotal profit = 6 + 7 = 13"
                    },
                    {
                        "username": "Saptarshi123123",
                        "content": "yes same problem!"
                    },
                    {
                        "username": "anto777",
                        "content": "You can view the solution here. This is my blog. If you find the content useful kindly upvote :)\\nYou can find the detailed explanation of the code in the link below :\\nhttps://cpexplanations.blogspot.com/2021/04/123-best-time-to-buy-and-sell-stock-iii.html"
                    },
                    {
                        "username": "codewarrior",
                        "content": "e.g. I buy on day 1, sell on day 2, and buy again on day 2, is that allowed or I must buy on day 3 (next day)?"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "If you buy on day 1, sell on day 2, buy again on day 2, and then sell on some day x, your overall profit will be = (prices[x]-prices[2])+(prices[2]-prices[1]) = prices[x]-prices[1]. Thus, the operation on day 2 made no difference- you might as well just skip that transaction and just sell later on day x directly. So, it doesn\\'t make sense to buy again on the same day as selling."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question is very intuitive and the optimisation makes it hard. I feel sad to see so many answers (almost all) which talk about dynamic programming approach straight from the formula without giving an intuition of the recursive -> top down approach, bringing the formula for iterative dp straight from thin air. The best way to solve a DP problem is first a recursive solution -> top down -> iterative DP."
                    },
                    {
                        "username": "user3965te",
                        "content": "\"find the best two opportunities to buy and sell the stock to maximize your profit\""
                    },
                    {
                        "username": "williamwjs",
                        "content": "We have solved the problem with one transaction, all transactions and two transactions. What if we can only make at most three? I think The method we use in III (i.e. use two arrays to scan from left and from right separately) can not solve the problem with 3. Any clue?"
                    },
                    {
                        "username": "letitbemini",
                        "content": "https://hashnode.com/post/best-time-to-buy-and-sell-stocks-a-comprehensive-guide-cko8xg43m0oz194s114kz71pn\\n\\nCheck out this article. It explains the approach of first four buy and sell problems along with working code."
                    }
                ]
            },
            {
                "id": 1566478,
                "content": [
                    {
                        "username": "hongbin2",
                        "content": "We use DP to solve this problem by scan left from right and then right to left, and find out the max profits. \\nBut, what if transactions are 3 or more, how could we solve this problem?"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "Try solving Buy and Sell Stock IV"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@user9894br](/user9894br) yup \\n"
                    },
                    {
                        "username": "user9894br",
                        "content": "Seems like there should be a way solve it by recursion/DP - given any pair of dates for the first transaction you can then solve the 2-transaction problem on the date range in the future, etc."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Check this out, it explains really throughly every possible case.\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/75924/most-consistent-ways-of-dealing-with-the-series-of-stock-problems/"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "tell me what is 'two transactions'?\\nIf you buy real stock, you will be told a transaction means one buy OR one sell."
                    },
                    {
                        "username": "Ankit5ingh",
                        "content": "buy-> sell -> buy -> sell that\\'s it. max 2 transactions are allowed. one transaction means buy -> sell "
                    },
                    {
                        "username": "adherent____",
                        "content": "means you cannot buy sell more than 2 times,,,"
                    },
                    {
                        "username": "bapi007",
                        "content": "Example 1 output says 6 but I guess it should be 8.\\nBuy at 3 and sell at 5, profit 2\\nBuy at 0 and sell at 3, profit 3\\nBuy at 1 and sell at 4, profit 3\\nHence, total 8"
                    },
                    {
                        "username": "Dewanshdoley",
                        "content": "you cannot buy 2 stock at a time i.e u must sell before u buy and the traversal of day must be in continuous "
                    },
                    {
                        "username": "faisalasnari432",
                        "content": "[@nitishkamath89](/nitishkamath89) it is similar to the previous one but  where to put transaction condition "
                    },
                    {
                        "username": "nitishkamath89",
                        "content": "we are allowed  at max two transactions"
                    },
                    {
                        "username": "IvanSkl",
                        "content": "It gives an error on this test case:\\nInput:\\n[1,2,4,2,5,7,2,4,9,0]\\nOutput:\\n12\\nExpected:\\n13\\n\\nI\\'ve counted it by hand and it must be 12 as my program did. Buy on day 4 (price = 2) and sell on day 6 (price = 7), profit = 7-2 = 5. And buy on day 7 (price = 2) and sell on day 9 (price = 9), profit = 9-2 = 7. The output must be 12. But it expected 13. There is an error or I can\\'t undestand something?"
                    },
                    {
                        "username": "newtonkr",
                        "content": "[1,2,4,2,5,7] = 7-1 = 6\\n[2,4,9,0]= 9-2 = 7  (7+6 = 13)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "you should buy on day 1 (price=1) and sell on day 6(price=7), profit=7-1=6"
                    },
                    {
                        "username": "srivastavaanchal000",
                        "content": "buy on day 1(1) and sell on day 6(7) => profit = 6\\nbuy on day 7(2) and sell on day 9(9) => profit = 7\\ntotal profit = 6 + 7 = 13"
                    },
                    {
                        "username": "Saptarshi123123",
                        "content": "yes same problem!"
                    },
                    {
                        "username": "anto777",
                        "content": "You can view the solution here. This is my blog. If you find the content useful kindly upvote :)\\nYou can find the detailed explanation of the code in the link below :\\nhttps://cpexplanations.blogspot.com/2021/04/123-best-time-to-buy-and-sell-stock-iii.html"
                    },
                    {
                        "username": "codewarrior",
                        "content": "e.g. I buy on day 1, sell on day 2, and buy again on day 2, is that allowed or I must buy on day 3 (next day)?"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "If you buy on day 1, sell on day 2, buy again on day 2, and then sell on some day x, your overall profit will be = (prices[x]-prices[2])+(prices[2]-prices[1]) = prices[x]-prices[1]. Thus, the operation on day 2 made no difference- you might as well just skip that transaction and just sell later on day x directly. So, it doesn\\'t make sense to buy again on the same day as selling."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question is very intuitive and the optimisation makes it hard. I feel sad to see so many answers (almost all) which talk about dynamic programming approach straight from the formula without giving an intuition of the recursive -> top down approach, bringing the formula for iterative dp straight from thin air. The best way to solve a DP problem is first a recursive solution -> top down -> iterative DP."
                    },
                    {
                        "username": "user3965te",
                        "content": "\"find the best two opportunities to buy and sell the stock to maximize your profit\""
                    },
                    {
                        "username": "williamwjs",
                        "content": "We have solved the problem with one transaction, all transactions and two transactions. What if we can only make at most three? I think The method we use in III (i.e. use two arrays to scan from left and from right separately) can not solve the problem with 3. Any clue?"
                    },
                    {
                        "username": "letitbemini",
                        "content": "https://hashnode.com/post/best-time-to-buy-and-sell-stocks-a-comprehensive-guide-cko8xg43m0oz194s114kz71pn\\n\\nCheck out this article. It explains the approach of first four buy and sell problems along with working code."
                    }
                ]
            },
            {
                "id": 1740202,
                "content": [
                    {
                        "username": "hongbin2",
                        "content": "We use DP to solve this problem by scan left from right and then right to left, and find out the max profits. \\nBut, what if transactions are 3 or more, how could we solve this problem?"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "Try solving Buy and Sell Stock IV"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@user9894br](/user9894br) yup \\n"
                    },
                    {
                        "username": "user9894br",
                        "content": "Seems like there should be a way solve it by recursion/DP - given any pair of dates for the first transaction you can then solve the 2-transaction problem on the date range in the future, etc."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Check this out, it explains really throughly every possible case.\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/75924/most-consistent-ways-of-dealing-with-the-series-of-stock-problems/"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "tell me what is 'two transactions'?\\nIf you buy real stock, you will be told a transaction means one buy OR one sell."
                    },
                    {
                        "username": "Ankit5ingh",
                        "content": "buy-> sell -> buy -> sell that\\'s it. max 2 transactions are allowed. one transaction means buy -> sell "
                    },
                    {
                        "username": "adherent____",
                        "content": "means you cannot buy sell more than 2 times,,,"
                    },
                    {
                        "username": "bapi007",
                        "content": "Example 1 output says 6 but I guess it should be 8.\\nBuy at 3 and sell at 5, profit 2\\nBuy at 0 and sell at 3, profit 3\\nBuy at 1 and sell at 4, profit 3\\nHence, total 8"
                    },
                    {
                        "username": "Dewanshdoley",
                        "content": "you cannot buy 2 stock at a time i.e u must sell before u buy and the traversal of day must be in continuous "
                    },
                    {
                        "username": "faisalasnari432",
                        "content": "[@nitishkamath89](/nitishkamath89) it is similar to the previous one but  where to put transaction condition "
                    },
                    {
                        "username": "nitishkamath89",
                        "content": "we are allowed  at max two transactions"
                    },
                    {
                        "username": "IvanSkl",
                        "content": "It gives an error on this test case:\\nInput:\\n[1,2,4,2,5,7,2,4,9,0]\\nOutput:\\n12\\nExpected:\\n13\\n\\nI\\'ve counted it by hand and it must be 12 as my program did. Buy on day 4 (price = 2) and sell on day 6 (price = 7), profit = 7-2 = 5. And buy on day 7 (price = 2) and sell on day 9 (price = 9), profit = 9-2 = 7. The output must be 12. But it expected 13. There is an error or I can\\'t undestand something?"
                    },
                    {
                        "username": "newtonkr",
                        "content": "[1,2,4,2,5,7] = 7-1 = 6\\n[2,4,9,0]= 9-2 = 7  (7+6 = 13)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "you should buy on day 1 (price=1) and sell on day 6(price=7), profit=7-1=6"
                    },
                    {
                        "username": "srivastavaanchal000",
                        "content": "buy on day 1(1) and sell on day 6(7) => profit = 6\\nbuy on day 7(2) and sell on day 9(9) => profit = 7\\ntotal profit = 6 + 7 = 13"
                    },
                    {
                        "username": "Saptarshi123123",
                        "content": "yes same problem!"
                    },
                    {
                        "username": "anto777",
                        "content": "You can view the solution here. This is my blog. If you find the content useful kindly upvote :)\\nYou can find the detailed explanation of the code in the link below :\\nhttps://cpexplanations.blogspot.com/2021/04/123-best-time-to-buy-and-sell-stock-iii.html"
                    },
                    {
                        "username": "codewarrior",
                        "content": "e.g. I buy on day 1, sell on day 2, and buy again on day 2, is that allowed or I must buy on day 3 (next day)?"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "If you buy on day 1, sell on day 2, buy again on day 2, and then sell on some day x, your overall profit will be = (prices[x]-prices[2])+(prices[2]-prices[1]) = prices[x]-prices[1]. Thus, the operation on day 2 made no difference- you might as well just skip that transaction and just sell later on day x directly. So, it doesn\\'t make sense to buy again on the same day as selling."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question is very intuitive and the optimisation makes it hard. I feel sad to see so many answers (almost all) which talk about dynamic programming approach straight from the formula without giving an intuition of the recursive -> top down approach, bringing the formula for iterative dp straight from thin air. The best way to solve a DP problem is first a recursive solution -> top down -> iterative DP."
                    },
                    {
                        "username": "user3965te",
                        "content": "\"find the best two opportunities to buy and sell the stock to maximize your profit\""
                    },
                    {
                        "username": "williamwjs",
                        "content": "We have solved the problem with one transaction, all transactions and two transactions. What if we can only make at most three? I think The method we use in III (i.e. use two arrays to scan from left and from right separately) can not solve the problem with 3. Any clue?"
                    },
                    {
                        "username": "letitbemini",
                        "content": "https://hashnode.com/post/best-time-to-buy-and-sell-stocks-a-comprehensive-guide-cko8xg43m0oz194s114kz71pn\\n\\nCheck out this article. It explains the approach of first four buy and sell problems along with working code."
                    }
                ]
            },
            {
                "id": 1575414,
                "content": [
                    {
                        "username": "hongbin2",
                        "content": "We use DP to solve this problem by scan left from right and then right to left, and find out the max profits. \\nBut, what if transactions are 3 or more, how could we solve this problem?"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "Try solving Buy and Sell Stock IV"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@user9894br](/user9894br) yup \\n"
                    },
                    {
                        "username": "user9894br",
                        "content": "Seems like there should be a way solve it by recursion/DP - given any pair of dates for the first transaction you can then solve the 2-transaction problem on the date range in the future, etc."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Check this out, it explains really throughly every possible case.\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/75924/most-consistent-ways-of-dealing-with-the-series-of-stock-problems/"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "tell me what is 'two transactions'?\\nIf you buy real stock, you will be told a transaction means one buy OR one sell."
                    },
                    {
                        "username": "Ankit5ingh",
                        "content": "buy-> sell -> buy -> sell that\\'s it. max 2 transactions are allowed. one transaction means buy -> sell "
                    },
                    {
                        "username": "adherent____",
                        "content": "means you cannot buy sell more than 2 times,,,"
                    },
                    {
                        "username": "bapi007",
                        "content": "Example 1 output says 6 but I guess it should be 8.\\nBuy at 3 and sell at 5, profit 2\\nBuy at 0 and sell at 3, profit 3\\nBuy at 1 and sell at 4, profit 3\\nHence, total 8"
                    },
                    {
                        "username": "Dewanshdoley",
                        "content": "you cannot buy 2 stock at a time i.e u must sell before u buy and the traversal of day must be in continuous "
                    },
                    {
                        "username": "faisalasnari432",
                        "content": "[@nitishkamath89](/nitishkamath89) it is similar to the previous one but  where to put transaction condition "
                    },
                    {
                        "username": "nitishkamath89",
                        "content": "we are allowed  at max two transactions"
                    },
                    {
                        "username": "IvanSkl",
                        "content": "It gives an error on this test case:\\nInput:\\n[1,2,4,2,5,7,2,4,9,0]\\nOutput:\\n12\\nExpected:\\n13\\n\\nI\\'ve counted it by hand and it must be 12 as my program did. Buy on day 4 (price = 2) and sell on day 6 (price = 7), profit = 7-2 = 5. And buy on day 7 (price = 2) and sell on day 9 (price = 9), profit = 9-2 = 7. The output must be 12. But it expected 13. There is an error or I can\\'t undestand something?"
                    },
                    {
                        "username": "newtonkr",
                        "content": "[1,2,4,2,5,7] = 7-1 = 6\\n[2,4,9,0]= 9-2 = 7  (7+6 = 13)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "you should buy on day 1 (price=1) and sell on day 6(price=7), profit=7-1=6"
                    },
                    {
                        "username": "srivastavaanchal000",
                        "content": "buy on day 1(1) and sell on day 6(7) => profit = 6\\nbuy on day 7(2) and sell on day 9(9) => profit = 7\\ntotal profit = 6 + 7 = 13"
                    },
                    {
                        "username": "Saptarshi123123",
                        "content": "yes same problem!"
                    },
                    {
                        "username": "anto777",
                        "content": "You can view the solution here. This is my blog. If you find the content useful kindly upvote :)\\nYou can find the detailed explanation of the code in the link below :\\nhttps://cpexplanations.blogspot.com/2021/04/123-best-time-to-buy-and-sell-stock-iii.html"
                    },
                    {
                        "username": "codewarrior",
                        "content": "e.g. I buy on day 1, sell on day 2, and buy again on day 2, is that allowed or I must buy on day 3 (next day)?"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "If you buy on day 1, sell on day 2, buy again on day 2, and then sell on some day x, your overall profit will be = (prices[x]-prices[2])+(prices[2]-prices[1]) = prices[x]-prices[1]. Thus, the operation on day 2 made no difference- you might as well just skip that transaction and just sell later on day x directly. So, it doesn\\'t make sense to buy again on the same day as selling."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question is very intuitive and the optimisation makes it hard. I feel sad to see so many answers (almost all) which talk about dynamic programming approach straight from the formula without giving an intuition of the recursive -> top down approach, bringing the formula for iterative dp straight from thin air. The best way to solve a DP problem is first a recursive solution -> top down -> iterative DP."
                    },
                    {
                        "username": "user3965te",
                        "content": "\"find the best two opportunities to buy and sell the stock to maximize your profit\""
                    },
                    {
                        "username": "williamwjs",
                        "content": "We have solved the problem with one transaction, all transactions and two transactions. What if we can only make at most three? I think The method we use in III (i.e. use two arrays to scan from left and from right separately) can not solve the problem with 3. Any clue?"
                    },
                    {
                        "username": "letitbemini",
                        "content": "https://hashnode.com/post/best-time-to-buy-and-sell-stocks-a-comprehensive-guide-cko8xg43m0oz194s114kz71pn\\n\\nCheck out this article. It explains the approach of first four buy and sell problems along with working code."
                    }
                ]
            },
            {
                "id": 1570412,
                "content": [
                    {
                        "username": "hongbin2",
                        "content": "We use DP to solve this problem by scan left from right and then right to left, and find out the max profits. \\nBut, what if transactions are 3 or more, how could we solve this problem?"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "Try solving Buy and Sell Stock IV"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@user9894br](/user9894br) yup \\n"
                    },
                    {
                        "username": "user9894br",
                        "content": "Seems like there should be a way solve it by recursion/DP - given any pair of dates for the first transaction you can then solve the 2-transaction problem on the date range in the future, etc."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Check this out, it explains really throughly every possible case.\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/75924/most-consistent-ways-of-dealing-with-the-series-of-stock-problems/"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "tell me what is 'two transactions'?\\nIf you buy real stock, you will be told a transaction means one buy OR one sell."
                    },
                    {
                        "username": "Ankit5ingh",
                        "content": "buy-> sell -> buy -> sell that\\'s it. max 2 transactions are allowed. one transaction means buy -> sell "
                    },
                    {
                        "username": "adherent____",
                        "content": "means you cannot buy sell more than 2 times,,,"
                    },
                    {
                        "username": "bapi007",
                        "content": "Example 1 output says 6 but I guess it should be 8.\\nBuy at 3 and sell at 5, profit 2\\nBuy at 0 and sell at 3, profit 3\\nBuy at 1 and sell at 4, profit 3\\nHence, total 8"
                    },
                    {
                        "username": "Dewanshdoley",
                        "content": "you cannot buy 2 stock at a time i.e u must sell before u buy and the traversal of day must be in continuous "
                    },
                    {
                        "username": "faisalasnari432",
                        "content": "[@nitishkamath89](/nitishkamath89) it is similar to the previous one but  where to put transaction condition "
                    },
                    {
                        "username": "nitishkamath89",
                        "content": "we are allowed  at max two transactions"
                    },
                    {
                        "username": "IvanSkl",
                        "content": "It gives an error on this test case:\\nInput:\\n[1,2,4,2,5,7,2,4,9,0]\\nOutput:\\n12\\nExpected:\\n13\\n\\nI\\'ve counted it by hand and it must be 12 as my program did. Buy on day 4 (price = 2) and sell on day 6 (price = 7), profit = 7-2 = 5. And buy on day 7 (price = 2) and sell on day 9 (price = 9), profit = 9-2 = 7. The output must be 12. But it expected 13. There is an error or I can\\'t undestand something?"
                    },
                    {
                        "username": "newtonkr",
                        "content": "[1,2,4,2,5,7] = 7-1 = 6\\n[2,4,9,0]= 9-2 = 7  (7+6 = 13)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "you should buy on day 1 (price=1) and sell on day 6(price=7), profit=7-1=6"
                    },
                    {
                        "username": "srivastavaanchal000",
                        "content": "buy on day 1(1) and sell on day 6(7) => profit = 6\\nbuy on day 7(2) and sell on day 9(9) => profit = 7\\ntotal profit = 6 + 7 = 13"
                    },
                    {
                        "username": "Saptarshi123123",
                        "content": "yes same problem!"
                    },
                    {
                        "username": "anto777",
                        "content": "You can view the solution here. This is my blog. If you find the content useful kindly upvote :)\\nYou can find the detailed explanation of the code in the link below :\\nhttps://cpexplanations.blogspot.com/2021/04/123-best-time-to-buy-and-sell-stock-iii.html"
                    },
                    {
                        "username": "codewarrior",
                        "content": "e.g. I buy on day 1, sell on day 2, and buy again on day 2, is that allowed or I must buy on day 3 (next day)?"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "If you buy on day 1, sell on day 2, buy again on day 2, and then sell on some day x, your overall profit will be = (prices[x]-prices[2])+(prices[2]-prices[1]) = prices[x]-prices[1]. Thus, the operation on day 2 made no difference- you might as well just skip that transaction and just sell later on day x directly. So, it doesn\\'t make sense to buy again on the same day as selling."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question is very intuitive and the optimisation makes it hard. I feel sad to see so many answers (almost all) which talk about dynamic programming approach straight from the formula without giving an intuition of the recursive -> top down approach, bringing the formula for iterative dp straight from thin air. The best way to solve a DP problem is first a recursive solution -> top down -> iterative DP."
                    },
                    {
                        "username": "user3965te",
                        "content": "\"find the best two opportunities to buy and sell the stock to maximize your profit\""
                    },
                    {
                        "username": "williamwjs",
                        "content": "We have solved the problem with one transaction, all transactions and two transactions. What if we can only make at most three? I think The method we use in III (i.e. use two arrays to scan from left and from right separately) can not solve the problem with 3. Any clue?"
                    },
                    {
                        "username": "letitbemini",
                        "content": "https://hashnode.com/post/best-time-to-buy-and-sell-stocks-a-comprehensive-guide-cko8xg43m0oz194s114kz71pn\\n\\nCheck out this article. It explains the approach of first four buy and sell problems along with working code."
                    }
                ]
            },
            {
                "id": 1569483,
                "content": [
                    {
                        "username": "hongbin2",
                        "content": "We use DP to solve this problem by scan left from right and then right to left, and find out the max profits. \\nBut, what if transactions are 3 or more, how could we solve this problem?"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "Try solving Buy and Sell Stock IV"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@user9894br](/user9894br) yup \\n"
                    },
                    {
                        "username": "user9894br",
                        "content": "Seems like there should be a way solve it by recursion/DP - given any pair of dates for the first transaction you can then solve the 2-transaction problem on the date range in the future, etc."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Check this out, it explains really throughly every possible case.\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/75924/most-consistent-ways-of-dealing-with-the-series-of-stock-problems/"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "tell me what is 'two transactions'?\\nIf you buy real stock, you will be told a transaction means one buy OR one sell."
                    },
                    {
                        "username": "Ankit5ingh",
                        "content": "buy-> sell -> buy -> sell that\\'s it. max 2 transactions are allowed. one transaction means buy -> sell "
                    },
                    {
                        "username": "adherent____",
                        "content": "means you cannot buy sell more than 2 times,,,"
                    },
                    {
                        "username": "bapi007",
                        "content": "Example 1 output says 6 but I guess it should be 8.\\nBuy at 3 and sell at 5, profit 2\\nBuy at 0 and sell at 3, profit 3\\nBuy at 1 and sell at 4, profit 3\\nHence, total 8"
                    },
                    {
                        "username": "Dewanshdoley",
                        "content": "you cannot buy 2 stock at a time i.e u must sell before u buy and the traversal of day must be in continuous "
                    },
                    {
                        "username": "faisalasnari432",
                        "content": "[@nitishkamath89](/nitishkamath89) it is similar to the previous one but  where to put transaction condition "
                    },
                    {
                        "username": "nitishkamath89",
                        "content": "we are allowed  at max two transactions"
                    },
                    {
                        "username": "IvanSkl",
                        "content": "It gives an error on this test case:\\nInput:\\n[1,2,4,2,5,7,2,4,9,0]\\nOutput:\\n12\\nExpected:\\n13\\n\\nI\\'ve counted it by hand and it must be 12 as my program did. Buy on day 4 (price = 2) and sell on day 6 (price = 7), profit = 7-2 = 5. And buy on day 7 (price = 2) and sell on day 9 (price = 9), profit = 9-2 = 7. The output must be 12. But it expected 13. There is an error or I can\\'t undestand something?"
                    },
                    {
                        "username": "newtonkr",
                        "content": "[1,2,4,2,5,7] = 7-1 = 6\\n[2,4,9,0]= 9-2 = 7  (7+6 = 13)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "you should buy on day 1 (price=1) and sell on day 6(price=7), profit=7-1=6"
                    },
                    {
                        "username": "srivastavaanchal000",
                        "content": "buy on day 1(1) and sell on day 6(7) => profit = 6\\nbuy on day 7(2) and sell on day 9(9) => profit = 7\\ntotal profit = 6 + 7 = 13"
                    },
                    {
                        "username": "Saptarshi123123",
                        "content": "yes same problem!"
                    },
                    {
                        "username": "anto777",
                        "content": "You can view the solution here. This is my blog. If you find the content useful kindly upvote :)\\nYou can find the detailed explanation of the code in the link below :\\nhttps://cpexplanations.blogspot.com/2021/04/123-best-time-to-buy-and-sell-stock-iii.html"
                    },
                    {
                        "username": "codewarrior",
                        "content": "e.g. I buy on day 1, sell on day 2, and buy again on day 2, is that allowed or I must buy on day 3 (next day)?"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "If you buy on day 1, sell on day 2, buy again on day 2, and then sell on some day x, your overall profit will be = (prices[x]-prices[2])+(prices[2]-prices[1]) = prices[x]-prices[1]. Thus, the operation on day 2 made no difference- you might as well just skip that transaction and just sell later on day x directly. So, it doesn\\'t make sense to buy again on the same day as selling."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question is very intuitive and the optimisation makes it hard. I feel sad to see so many answers (almost all) which talk about dynamic programming approach straight from the formula without giving an intuition of the recursive -> top down approach, bringing the formula for iterative dp straight from thin air. The best way to solve a DP problem is first a recursive solution -> top down -> iterative DP."
                    },
                    {
                        "username": "user3965te",
                        "content": "\"find the best two opportunities to buy and sell the stock to maximize your profit\""
                    },
                    {
                        "username": "williamwjs",
                        "content": "We have solved the problem with one transaction, all transactions and two transactions. What if we can only make at most three? I think The method we use in III (i.e. use two arrays to scan from left and from right separately) can not solve the problem with 3. Any clue?"
                    },
                    {
                        "username": "letitbemini",
                        "content": "https://hashnode.com/post/best-time-to-buy-and-sell-stocks-a-comprehensive-guide-cko8xg43m0oz194s114kz71pn\\n\\nCheck out this article. It explains the approach of first four buy and sell problems along with working code."
                    }
                ]
            },
            {
                "id": 1905005,
                "content": [
                    {
                        "username": "hongbin2",
                        "content": "We use DP to solve this problem by scan left from right and then right to left, and find out the max profits. \\nBut, what if transactions are 3 or more, how could we solve this problem?"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "Try solving Buy and Sell Stock IV"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@user9894br](/user9894br) yup \\n"
                    },
                    {
                        "username": "user9894br",
                        "content": "Seems like there should be a way solve it by recursion/DP - given any pair of dates for the first transaction you can then solve the 2-transaction problem on the date range in the future, etc."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Check this out, it explains really throughly every possible case.\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/75924/most-consistent-ways-of-dealing-with-the-series-of-stock-problems/"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "tell me what is 'two transactions'?\\nIf you buy real stock, you will be told a transaction means one buy OR one sell."
                    },
                    {
                        "username": "Ankit5ingh",
                        "content": "buy-> sell -> buy -> sell that\\'s it. max 2 transactions are allowed. one transaction means buy -> sell "
                    },
                    {
                        "username": "adherent____",
                        "content": "means you cannot buy sell more than 2 times,,,"
                    },
                    {
                        "username": "bapi007",
                        "content": "Example 1 output says 6 but I guess it should be 8.\\nBuy at 3 and sell at 5, profit 2\\nBuy at 0 and sell at 3, profit 3\\nBuy at 1 and sell at 4, profit 3\\nHence, total 8"
                    },
                    {
                        "username": "Dewanshdoley",
                        "content": "you cannot buy 2 stock at a time i.e u must sell before u buy and the traversal of day must be in continuous "
                    },
                    {
                        "username": "faisalasnari432",
                        "content": "[@nitishkamath89](/nitishkamath89) it is similar to the previous one but  where to put transaction condition "
                    },
                    {
                        "username": "nitishkamath89",
                        "content": "we are allowed  at max two transactions"
                    },
                    {
                        "username": "IvanSkl",
                        "content": "It gives an error on this test case:\\nInput:\\n[1,2,4,2,5,7,2,4,9,0]\\nOutput:\\n12\\nExpected:\\n13\\n\\nI\\'ve counted it by hand and it must be 12 as my program did. Buy on day 4 (price = 2) and sell on day 6 (price = 7), profit = 7-2 = 5. And buy on day 7 (price = 2) and sell on day 9 (price = 9), profit = 9-2 = 7. The output must be 12. But it expected 13. There is an error or I can\\'t undestand something?"
                    },
                    {
                        "username": "newtonkr",
                        "content": "[1,2,4,2,5,7] = 7-1 = 6\\n[2,4,9,0]= 9-2 = 7  (7+6 = 13)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "you should buy on day 1 (price=1) and sell on day 6(price=7), profit=7-1=6"
                    },
                    {
                        "username": "srivastavaanchal000",
                        "content": "buy on day 1(1) and sell on day 6(7) => profit = 6\\nbuy on day 7(2) and sell on day 9(9) => profit = 7\\ntotal profit = 6 + 7 = 13"
                    },
                    {
                        "username": "Saptarshi123123",
                        "content": "yes same problem!"
                    },
                    {
                        "username": "anto777",
                        "content": "You can view the solution here. This is my blog. If you find the content useful kindly upvote :)\\nYou can find the detailed explanation of the code in the link below :\\nhttps://cpexplanations.blogspot.com/2021/04/123-best-time-to-buy-and-sell-stock-iii.html"
                    },
                    {
                        "username": "codewarrior",
                        "content": "e.g. I buy on day 1, sell on day 2, and buy again on day 2, is that allowed or I must buy on day 3 (next day)?"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "If you buy on day 1, sell on day 2, buy again on day 2, and then sell on some day x, your overall profit will be = (prices[x]-prices[2])+(prices[2]-prices[1]) = prices[x]-prices[1]. Thus, the operation on day 2 made no difference- you might as well just skip that transaction and just sell later on day x directly. So, it doesn\\'t make sense to buy again on the same day as selling."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question is very intuitive and the optimisation makes it hard. I feel sad to see so many answers (almost all) which talk about dynamic programming approach straight from the formula without giving an intuition of the recursive -> top down approach, bringing the formula for iterative dp straight from thin air. The best way to solve a DP problem is first a recursive solution -> top down -> iterative DP."
                    },
                    {
                        "username": "user3965te",
                        "content": "\"find the best two opportunities to buy and sell the stock to maximize your profit\""
                    },
                    {
                        "username": "williamwjs",
                        "content": "We have solved the problem with one transaction, all transactions and two transactions. What if we can only make at most three? I think The method we use in III (i.e. use two arrays to scan from left and from right separately) can not solve the problem with 3. Any clue?"
                    },
                    {
                        "username": "letitbemini",
                        "content": "https://hashnode.com/post/best-time-to-buy-and-sell-stocks-a-comprehensive-guide-cko8xg43m0oz194s114kz71pn\\n\\nCheck out this article. It explains the approach of first four buy and sell problems along with working code."
                    }
                ]
            },
            {
                "id": 1806035,
                "content": [
                    {
                        "username": "hongbin2",
                        "content": "We use DP to solve this problem by scan left from right and then right to left, and find out the max profits. \\nBut, what if transactions are 3 or more, how could we solve this problem?"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "Try solving Buy and Sell Stock IV"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@user9894br](/user9894br) yup \\n"
                    },
                    {
                        "username": "user9894br",
                        "content": "Seems like there should be a way solve it by recursion/DP - given any pair of dates for the first transaction you can then solve the 2-transaction problem on the date range in the future, etc."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Check this out, it explains really throughly every possible case.\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/75924/most-consistent-ways-of-dealing-with-the-series-of-stock-problems/"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "tell me what is 'two transactions'?\\nIf you buy real stock, you will be told a transaction means one buy OR one sell."
                    },
                    {
                        "username": "Ankit5ingh",
                        "content": "buy-> sell -> buy -> sell that\\'s it. max 2 transactions are allowed. one transaction means buy -> sell "
                    },
                    {
                        "username": "adherent____",
                        "content": "means you cannot buy sell more than 2 times,,,"
                    },
                    {
                        "username": "bapi007",
                        "content": "Example 1 output says 6 but I guess it should be 8.\\nBuy at 3 and sell at 5, profit 2\\nBuy at 0 and sell at 3, profit 3\\nBuy at 1 and sell at 4, profit 3\\nHence, total 8"
                    },
                    {
                        "username": "Dewanshdoley",
                        "content": "you cannot buy 2 stock at a time i.e u must sell before u buy and the traversal of day must be in continuous "
                    },
                    {
                        "username": "faisalasnari432",
                        "content": "[@nitishkamath89](/nitishkamath89) it is similar to the previous one but  where to put transaction condition "
                    },
                    {
                        "username": "nitishkamath89",
                        "content": "we are allowed  at max two transactions"
                    },
                    {
                        "username": "IvanSkl",
                        "content": "It gives an error on this test case:\\nInput:\\n[1,2,4,2,5,7,2,4,9,0]\\nOutput:\\n12\\nExpected:\\n13\\n\\nI\\'ve counted it by hand and it must be 12 as my program did. Buy on day 4 (price = 2) and sell on day 6 (price = 7), profit = 7-2 = 5. And buy on day 7 (price = 2) and sell on day 9 (price = 9), profit = 9-2 = 7. The output must be 12. But it expected 13. There is an error or I can\\'t undestand something?"
                    },
                    {
                        "username": "newtonkr",
                        "content": "[1,2,4,2,5,7] = 7-1 = 6\\n[2,4,9,0]= 9-2 = 7  (7+6 = 13)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "you should buy on day 1 (price=1) and sell on day 6(price=7), profit=7-1=6"
                    },
                    {
                        "username": "srivastavaanchal000",
                        "content": "buy on day 1(1) and sell on day 6(7) => profit = 6\\nbuy on day 7(2) and sell on day 9(9) => profit = 7\\ntotal profit = 6 + 7 = 13"
                    },
                    {
                        "username": "Saptarshi123123",
                        "content": "yes same problem!"
                    },
                    {
                        "username": "anto777",
                        "content": "You can view the solution here. This is my blog. If you find the content useful kindly upvote :)\\nYou can find the detailed explanation of the code in the link below :\\nhttps://cpexplanations.blogspot.com/2021/04/123-best-time-to-buy-and-sell-stock-iii.html"
                    },
                    {
                        "username": "codewarrior",
                        "content": "e.g. I buy on day 1, sell on day 2, and buy again on day 2, is that allowed or I must buy on day 3 (next day)?"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "If you buy on day 1, sell on day 2, buy again on day 2, and then sell on some day x, your overall profit will be = (prices[x]-prices[2])+(prices[2]-prices[1]) = prices[x]-prices[1]. Thus, the operation on day 2 made no difference- you might as well just skip that transaction and just sell later on day x directly. So, it doesn\\'t make sense to buy again on the same day as selling."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question is very intuitive and the optimisation makes it hard. I feel sad to see so many answers (almost all) which talk about dynamic programming approach straight from the formula without giving an intuition of the recursive -> top down approach, bringing the formula for iterative dp straight from thin air. The best way to solve a DP problem is first a recursive solution -> top down -> iterative DP."
                    },
                    {
                        "username": "user3965te",
                        "content": "\"find the best two opportunities to buy and sell the stock to maximize your profit\""
                    },
                    {
                        "username": "williamwjs",
                        "content": "We have solved the problem with one transaction, all transactions and two transactions. What if we can only make at most three? I think The method we use in III (i.e. use two arrays to scan from left and from right separately) can not solve the problem with 3. Any clue?"
                    },
                    {
                        "username": "letitbemini",
                        "content": "https://hashnode.com/post/best-time-to-buy-and-sell-stocks-a-comprehensive-guide-cko8xg43m0oz194s114kz71pn\\n\\nCheck out this article. It explains the approach of first four buy and sell problems along with working code."
                    }
                ]
            },
            {
                "id": 1568938,
                "content": [
                    {
                        "username": "hongbin2",
                        "content": "We use DP to solve this problem by scan left from right and then right to left, and find out the max profits. \\nBut, what if transactions are 3 or more, how could we solve this problem?"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "Try solving Buy and Sell Stock IV"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@user9894br](/user9894br) yup \\n"
                    },
                    {
                        "username": "user9894br",
                        "content": "Seems like there should be a way solve it by recursion/DP - given any pair of dates for the first transaction you can then solve the 2-transaction problem on the date range in the future, etc."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Check this out, it explains really throughly every possible case.\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/75924/most-consistent-ways-of-dealing-with-the-series-of-stock-problems/"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "tell me what is 'two transactions'?\\nIf you buy real stock, you will be told a transaction means one buy OR one sell."
                    },
                    {
                        "username": "Ankit5ingh",
                        "content": "buy-> sell -> buy -> sell that\\'s it. max 2 transactions are allowed. one transaction means buy -> sell "
                    },
                    {
                        "username": "adherent____",
                        "content": "means you cannot buy sell more than 2 times,,,"
                    },
                    {
                        "username": "bapi007",
                        "content": "Example 1 output says 6 but I guess it should be 8.\\nBuy at 3 and sell at 5, profit 2\\nBuy at 0 and sell at 3, profit 3\\nBuy at 1 and sell at 4, profit 3\\nHence, total 8"
                    },
                    {
                        "username": "Dewanshdoley",
                        "content": "you cannot buy 2 stock at a time i.e u must sell before u buy and the traversal of day must be in continuous "
                    },
                    {
                        "username": "faisalasnari432",
                        "content": "[@nitishkamath89](/nitishkamath89) it is similar to the previous one but  where to put transaction condition "
                    },
                    {
                        "username": "nitishkamath89",
                        "content": "we are allowed  at max two transactions"
                    },
                    {
                        "username": "IvanSkl",
                        "content": "It gives an error on this test case:\\nInput:\\n[1,2,4,2,5,7,2,4,9,0]\\nOutput:\\n12\\nExpected:\\n13\\n\\nI\\'ve counted it by hand and it must be 12 as my program did. Buy on day 4 (price = 2) and sell on day 6 (price = 7), profit = 7-2 = 5. And buy on day 7 (price = 2) and sell on day 9 (price = 9), profit = 9-2 = 7. The output must be 12. But it expected 13. There is an error or I can\\'t undestand something?"
                    },
                    {
                        "username": "newtonkr",
                        "content": "[1,2,4,2,5,7] = 7-1 = 6\\n[2,4,9,0]= 9-2 = 7  (7+6 = 13)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "you should buy on day 1 (price=1) and sell on day 6(price=7), profit=7-1=6"
                    },
                    {
                        "username": "srivastavaanchal000",
                        "content": "buy on day 1(1) and sell on day 6(7) => profit = 6\\nbuy on day 7(2) and sell on day 9(9) => profit = 7\\ntotal profit = 6 + 7 = 13"
                    },
                    {
                        "username": "Saptarshi123123",
                        "content": "yes same problem!"
                    },
                    {
                        "username": "anto777",
                        "content": "You can view the solution here. This is my blog. If you find the content useful kindly upvote :)\\nYou can find the detailed explanation of the code in the link below :\\nhttps://cpexplanations.blogspot.com/2021/04/123-best-time-to-buy-and-sell-stock-iii.html"
                    },
                    {
                        "username": "codewarrior",
                        "content": "e.g. I buy on day 1, sell on day 2, and buy again on day 2, is that allowed or I must buy on day 3 (next day)?"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "If you buy on day 1, sell on day 2, buy again on day 2, and then sell on some day x, your overall profit will be = (prices[x]-prices[2])+(prices[2]-prices[1]) = prices[x]-prices[1]. Thus, the operation on day 2 made no difference- you might as well just skip that transaction and just sell later on day x directly. So, it doesn\\'t make sense to buy again on the same day as selling."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question is very intuitive and the optimisation makes it hard. I feel sad to see so many answers (almost all) which talk about dynamic programming approach straight from the formula without giving an intuition of the recursive -> top down approach, bringing the formula for iterative dp straight from thin air. The best way to solve a DP problem is first a recursive solution -> top down -> iterative DP."
                    },
                    {
                        "username": "user3965te",
                        "content": "\"find the best two opportunities to buy and sell the stock to maximize your profit\""
                    },
                    {
                        "username": "williamwjs",
                        "content": "We have solved the problem with one transaction, all transactions and two transactions. What if we can only make at most three? I think The method we use in III (i.e. use two arrays to scan from left and from right separately) can not solve the problem with 3. Any clue?"
                    },
                    {
                        "username": "letitbemini",
                        "content": "https://hashnode.com/post/best-time-to-buy-and-sell-stocks-a-comprehensive-guide-cko8xg43m0oz194s114kz71pn\\n\\nCheck out this article. It explains the approach of first four buy and sell problems along with working code."
                    }
                ]
            },
            {
                "id": 1567602,
                "content": [
                    {
                        "username": "hongbin2",
                        "content": "We use DP to solve this problem by scan left from right and then right to left, and find out the max profits. \\nBut, what if transactions are 3 or more, how could we solve this problem?"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "Try solving Buy and Sell Stock IV"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@user9894br](/user9894br) yup \\n"
                    },
                    {
                        "username": "user9894br",
                        "content": "Seems like there should be a way solve it by recursion/DP - given any pair of dates for the first transaction you can then solve the 2-transaction problem on the date range in the future, etc."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Check this out, it explains really throughly every possible case.\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/75924/most-consistent-ways-of-dealing-with-the-series-of-stock-problems/"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "tell me what is 'two transactions'?\\nIf you buy real stock, you will be told a transaction means one buy OR one sell."
                    },
                    {
                        "username": "Ankit5ingh",
                        "content": "buy-> sell -> buy -> sell that\\'s it. max 2 transactions are allowed. one transaction means buy -> sell "
                    },
                    {
                        "username": "adherent____",
                        "content": "means you cannot buy sell more than 2 times,,,"
                    },
                    {
                        "username": "bapi007",
                        "content": "Example 1 output says 6 but I guess it should be 8.\\nBuy at 3 and sell at 5, profit 2\\nBuy at 0 and sell at 3, profit 3\\nBuy at 1 and sell at 4, profit 3\\nHence, total 8"
                    },
                    {
                        "username": "Dewanshdoley",
                        "content": "you cannot buy 2 stock at a time i.e u must sell before u buy and the traversal of day must be in continuous "
                    },
                    {
                        "username": "faisalasnari432",
                        "content": "[@nitishkamath89](/nitishkamath89) it is similar to the previous one but  where to put transaction condition "
                    },
                    {
                        "username": "nitishkamath89",
                        "content": "we are allowed  at max two transactions"
                    },
                    {
                        "username": "IvanSkl",
                        "content": "It gives an error on this test case:\\nInput:\\n[1,2,4,2,5,7,2,4,9,0]\\nOutput:\\n12\\nExpected:\\n13\\n\\nI\\'ve counted it by hand and it must be 12 as my program did. Buy on day 4 (price = 2) and sell on day 6 (price = 7), profit = 7-2 = 5. And buy on day 7 (price = 2) and sell on day 9 (price = 9), profit = 9-2 = 7. The output must be 12. But it expected 13. There is an error or I can\\'t undestand something?"
                    },
                    {
                        "username": "newtonkr",
                        "content": "[1,2,4,2,5,7] = 7-1 = 6\\n[2,4,9,0]= 9-2 = 7  (7+6 = 13)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "you should buy on day 1 (price=1) and sell on day 6(price=7), profit=7-1=6"
                    },
                    {
                        "username": "srivastavaanchal000",
                        "content": "buy on day 1(1) and sell on day 6(7) => profit = 6\\nbuy on day 7(2) and sell on day 9(9) => profit = 7\\ntotal profit = 6 + 7 = 13"
                    },
                    {
                        "username": "Saptarshi123123",
                        "content": "yes same problem!"
                    },
                    {
                        "username": "anto777",
                        "content": "You can view the solution here. This is my blog. If you find the content useful kindly upvote :)\\nYou can find the detailed explanation of the code in the link below :\\nhttps://cpexplanations.blogspot.com/2021/04/123-best-time-to-buy-and-sell-stock-iii.html"
                    },
                    {
                        "username": "codewarrior",
                        "content": "e.g. I buy on day 1, sell on day 2, and buy again on day 2, is that allowed or I must buy on day 3 (next day)?"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "If you buy on day 1, sell on day 2, buy again on day 2, and then sell on some day x, your overall profit will be = (prices[x]-prices[2])+(prices[2]-prices[1]) = prices[x]-prices[1]. Thus, the operation on day 2 made no difference- you might as well just skip that transaction and just sell later on day x directly. So, it doesn\\'t make sense to buy again on the same day as selling."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question is very intuitive and the optimisation makes it hard. I feel sad to see so many answers (almost all) which talk about dynamic programming approach straight from the formula without giving an intuition of the recursive -> top down approach, bringing the formula for iterative dp straight from thin air. The best way to solve a DP problem is first a recursive solution -> top down -> iterative DP."
                    },
                    {
                        "username": "user3965te",
                        "content": "\"find the best two opportunities to buy and sell the stock to maximize your profit\""
                    },
                    {
                        "username": "williamwjs",
                        "content": "We have solved the problem with one transaction, all transactions and two transactions. What if we can only make at most three? I think The method we use in III (i.e. use two arrays to scan from left and from right separately) can not solve the problem with 3. Any clue?"
                    },
                    {
                        "username": "letitbemini",
                        "content": "https://hashnode.com/post/best-time-to-buy-and-sell-stocks-a-comprehensive-guide-cko8xg43m0oz194s114kz71pn\\n\\nCheck out this article. It explains the approach of first four buy and sell problems along with working code."
                    }
                ]
            },
            {
                "id": 1567201,
                "content": [
                    {
                        "username": "hongbin2",
                        "content": "We use DP to solve this problem by scan left from right and then right to left, and find out the max profits. \\nBut, what if transactions are 3 or more, how could we solve this problem?"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "Try solving Buy and Sell Stock IV"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@user9894br](/user9894br) yup \\n"
                    },
                    {
                        "username": "user9894br",
                        "content": "Seems like there should be a way solve it by recursion/DP - given any pair of dates for the first transaction you can then solve the 2-transaction problem on the date range in the future, etc."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Check this out, it explains really throughly every possible case.\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/75924/most-consistent-ways-of-dealing-with-the-series-of-stock-problems/"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "tell me what is 'two transactions'?\\nIf you buy real stock, you will be told a transaction means one buy OR one sell."
                    },
                    {
                        "username": "Ankit5ingh",
                        "content": "buy-> sell -> buy -> sell that\\'s it. max 2 transactions are allowed. one transaction means buy -> sell "
                    },
                    {
                        "username": "adherent____",
                        "content": "means you cannot buy sell more than 2 times,,,"
                    },
                    {
                        "username": "bapi007",
                        "content": "Example 1 output says 6 but I guess it should be 8.\\nBuy at 3 and sell at 5, profit 2\\nBuy at 0 and sell at 3, profit 3\\nBuy at 1 and sell at 4, profit 3\\nHence, total 8"
                    },
                    {
                        "username": "Dewanshdoley",
                        "content": "you cannot buy 2 stock at a time i.e u must sell before u buy and the traversal of day must be in continuous "
                    },
                    {
                        "username": "faisalasnari432",
                        "content": "[@nitishkamath89](/nitishkamath89) it is similar to the previous one but  where to put transaction condition "
                    },
                    {
                        "username": "nitishkamath89",
                        "content": "we are allowed  at max two transactions"
                    },
                    {
                        "username": "IvanSkl",
                        "content": "It gives an error on this test case:\\nInput:\\n[1,2,4,2,5,7,2,4,9,0]\\nOutput:\\n12\\nExpected:\\n13\\n\\nI\\'ve counted it by hand and it must be 12 as my program did. Buy on day 4 (price = 2) and sell on day 6 (price = 7), profit = 7-2 = 5. And buy on day 7 (price = 2) and sell on day 9 (price = 9), profit = 9-2 = 7. The output must be 12. But it expected 13. There is an error or I can\\'t undestand something?"
                    },
                    {
                        "username": "newtonkr",
                        "content": "[1,2,4,2,5,7] = 7-1 = 6\\n[2,4,9,0]= 9-2 = 7  (7+6 = 13)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "you should buy on day 1 (price=1) and sell on day 6(price=7), profit=7-1=6"
                    },
                    {
                        "username": "srivastavaanchal000",
                        "content": "buy on day 1(1) and sell on day 6(7) => profit = 6\\nbuy on day 7(2) and sell on day 9(9) => profit = 7\\ntotal profit = 6 + 7 = 13"
                    },
                    {
                        "username": "Saptarshi123123",
                        "content": "yes same problem!"
                    },
                    {
                        "username": "anto777",
                        "content": "You can view the solution here. This is my blog. If you find the content useful kindly upvote :)\\nYou can find the detailed explanation of the code in the link below :\\nhttps://cpexplanations.blogspot.com/2021/04/123-best-time-to-buy-and-sell-stock-iii.html"
                    },
                    {
                        "username": "codewarrior",
                        "content": "e.g. I buy on day 1, sell on day 2, and buy again on day 2, is that allowed or I must buy on day 3 (next day)?"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "If you buy on day 1, sell on day 2, buy again on day 2, and then sell on some day x, your overall profit will be = (prices[x]-prices[2])+(prices[2]-prices[1]) = prices[x]-prices[1]. Thus, the operation on day 2 made no difference- you might as well just skip that transaction and just sell later on day x directly. So, it doesn\\'t make sense to buy again on the same day as selling."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question is very intuitive and the optimisation makes it hard. I feel sad to see so many answers (almost all) which talk about dynamic programming approach straight from the formula without giving an intuition of the recursive -> top down approach, bringing the formula for iterative dp straight from thin air. The best way to solve a DP problem is first a recursive solution -> top down -> iterative DP."
                    },
                    {
                        "username": "user3965te",
                        "content": "\"find the best two opportunities to buy and sell the stock to maximize your profit\""
                    },
                    {
                        "username": "williamwjs",
                        "content": "We have solved the problem with one transaction, all transactions and two transactions. What if we can only make at most three? I think The method we use in III (i.e. use two arrays to scan from left and from right separately) can not solve the problem with 3. Any clue?"
                    },
                    {
                        "username": "letitbemini",
                        "content": "https://hashnode.com/post/best-time-to-buy-and-sell-stocks-a-comprehensive-guide-cko8xg43m0oz194s114kz71pn\\n\\nCheck out this article. It explains the approach of first four buy and sell problems along with working code."
                    }
                ]
            },
            {
                "id": 1566478,
                "content": [
                    {
                        "username": "hongbin2",
                        "content": "We use DP to solve this problem by scan left from right and then right to left, and find out the max profits. \\nBut, what if transactions are 3 or more, how could we solve this problem?"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "Try solving Buy and Sell Stock IV"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@user9894br](/user9894br) yup \\n"
                    },
                    {
                        "username": "user9894br",
                        "content": "Seems like there should be a way solve it by recursion/DP - given any pair of dates for the first transaction you can then solve the 2-transaction problem on the date range in the future, etc."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Check this out, it explains really throughly every possible case.\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/75924/most-consistent-ways-of-dealing-with-the-series-of-stock-problems/"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "tell me what is 'two transactions'?\\nIf you buy real stock, you will be told a transaction means one buy OR one sell."
                    },
                    {
                        "username": "Ankit5ingh",
                        "content": "buy-> sell -> buy -> sell that\\'s it. max 2 transactions are allowed. one transaction means buy -> sell "
                    },
                    {
                        "username": "adherent____",
                        "content": "means you cannot buy sell more than 2 times,,,"
                    },
                    {
                        "username": "bapi007",
                        "content": "Example 1 output says 6 but I guess it should be 8.\\nBuy at 3 and sell at 5, profit 2\\nBuy at 0 and sell at 3, profit 3\\nBuy at 1 and sell at 4, profit 3\\nHence, total 8"
                    },
                    {
                        "username": "Dewanshdoley",
                        "content": "you cannot buy 2 stock at a time i.e u must sell before u buy and the traversal of day must be in continuous "
                    },
                    {
                        "username": "faisalasnari432",
                        "content": "[@nitishkamath89](/nitishkamath89) it is similar to the previous one but  where to put transaction condition "
                    },
                    {
                        "username": "nitishkamath89",
                        "content": "we are allowed  at max two transactions"
                    },
                    {
                        "username": "IvanSkl",
                        "content": "It gives an error on this test case:\\nInput:\\n[1,2,4,2,5,7,2,4,9,0]\\nOutput:\\n12\\nExpected:\\n13\\n\\nI\\'ve counted it by hand and it must be 12 as my program did. Buy on day 4 (price = 2) and sell on day 6 (price = 7), profit = 7-2 = 5. And buy on day 7 (price = 2) and sell on day 9 (price = 9), profit = 9-2 = 7. The output must be 12. But it expected 13. There is an error or I can\\'t undestand something?"
                    },
                    {
                        "username": "newtonkr",
                        "content": "[1,2,4,2,5,7] = 7-1 = 6\\n[2,4,9,0]= 9-2 = 7  (7+6 = 13)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "you should buy on day 1 (price=1) and sell on day 6(price=7), profit=7-1=6"
                    },
                    {
                        "username": "srivastavaanchal000",
                        "content": "buy on day 1(1) and sell on day 6(7) => profit = 6\\nbuy on day 7(2) and sell on day 9(9) => profit = 7\\ntotal profit = 6 + 7 = 13"
                    },
                    {
                        "username": "Saptarshi123123",
                        "content": "yes same problem!"
                    },
                    {
                        "username": "anto777",
                        "content": "You can view the solution here. This is my blog. If you find the content useful kindly upvote :)\\nYou can find the detailed explanation of the code in the link below :\\nhttps://cpexplanations.blogspot.com/2021/04/123-best-time-to-buy-and-sell-stock-iii.html"
                    },
                    {
                        "username": "codewarrior",
                        "content": "e.g. I buy on day 1, sell on day 2, and buy again on day 2, is that allowed or I must buy on day 3 (next day)?"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "If you buy on day 1, sell on day 2, buy again on day 2, and then sell on some day x, your overall profit will be = (prices[x]-prices[2])+(prices[2]-prices[1]) = prices[x]-prices[1]. Thus, the operation on day 2 made no difference- you might as well just skip that transaction and just sell later on day x directly. So, it doesn\\'t make sense to buy again on the same day as selling."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question is very intuitive and the optimisation makes it hard. I feel sad to see so many answers (almost all) which talk about dynamic programming approach straight from the formula without giving an intuition of the recursive -> top down approach, bringing the formula for iterative dp straight from thin air. The best way to solve a DP problem is first a recursive solution -> top down -> iterative DP."
                    },
                    {
                        "username": "user3965te",
                        "content": "\"find the best two opportunities to buy and sell the stock to maximize your profit\""
                    },
                    {
                        "username": "williamwjs",
                        "content": "We have solved the problem with one transaction, all transactions and two transactions. What if we can only make at most three? I think The method we use in III (i.e. use two arrays to scan from left and from right separately) can not solve the problem with 3. Any clue?"
                    },
                    {
                        "username": "letitbemini",
                        "content": "https://hashnode.com/post/best-time-to-buy-and-sell-stocks-a-comprehensive-guide-cko8xg43m0oz194s114kz71pn\\n\\nCheck out this article. It explains the approach of first four buy and sell problems along with working code."
                    }
                ]
            },
            {
                "id": 1740202,
                "content": [
                    {
                        "username": "hongbin2",
                        "content": "We use DP to solve this problem by scan left from right and then right to left, and find out the max profits. \\nBut, what if transactions are 3 or more, how could we solve this problem?"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "Try solving Buy and Sell Stock IV"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@user9894br](/user9894br) yup \\n"
                    },
                    {
                        "username": "user9894br",
                        "content": "Seems like there should be a way solve it by recursion/DP - given any pair of dates for the first transaction you can then solve the 2-transaction problem on the date range in the future, etc."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Check this out, it explains really throughly every possible case.\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/75924/most-consistent-ways-of-dealing-with-the-series-of-stock-problems/"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "tell me what is 'two transactions'?\\nIf you buy real stock, you will be told a transaction means one buy OR one sell."
                    },
                    {
                        "username": "Ankit5ingh",
                        "content": "buy-> sell -> buy -> sell that\\'s it. max 2 transactions are allowed. one transaction means buy -> sell "
                    },
                    {
                        "username": "adherent____",
                        "content": "means you cannot buy sell more than 2 times,,,"
                    },
                    {
                        "username": "bapi007",
                        "content": "Example 1 output says 6 but I guess it should be 8.\\nBuy at 3 and sell at 5, profit 2\\nBuy at 0 and sell at 3, profit 3\\nBuy at 1 and sell at 4, profit 3\\nHence, total 8"
                    },
                    {
                        "username": "Dewanshdoley",
                        "content": "you cannot buy 2 stock at a time i.e u must sell before u buy and the traversal of day must be in continuous "
                    },
                    {
                        "username": "faisalasnari432",
                        "content": "[@nitishkamath89](/nitishkamath89) it is similar to the previous one but  where to put transaction condition "
                    },
                    {
                        "username": "nitishkamath89",
                        "content": "we are allowed  at max two transactions"
                    },
                    {
                        "username": "IvanSkl",
                        "content": "It gives an error on this test case:\\nInput:\\n[1,2,4,2,5,7,2,4,9,0]\\nOutput:\\n12\\nExpected:\\n13\\n\\nI\\'ve counted it by hand and it must be 12 as my program did. Buy on day 4 (price = 2) and sell on day 6 (price = 7), profit = 7-2 = 5. And buy on day 7 (price = 2) and sell on day 9 (price = 9), profit = 9-2 = 7. The output must be 12. But it expected 13. There is an error or I can\\'t undestand something?"
                    },
                    {
                        "username": "newtonkr",
                        "content": "[1,2,4,2,5,7] = 7-1 = 6\\n[2,4,9,0]= 9-2 = 7  (7+6 = 13)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "you should buy on day 1 (price=1) and sell on day 6(price=7), profit=7-1=6"
                    },
                    {
                        "username": "srivastavaanchal000",
                        "content": "buy on day 1(1) and sell on day 6(7) => profit = 6\\nbuy on day 7(2) and sell on day 9(9) => profit = 7\\ntotal profit = 6 + 7 = 13"
                    },
                    {
                        "username": "Saptarshi123123",
                        "content": "yes same problem!"
                    },
                    {
                        "username": "anto777",
                        "content": "You can view the solution here. This is my blog. If you find the content useful kindly upvote :)\\nYou can find the detailed explanation of the code in the link below :\\nhttps://cpexplanations.blogspot.com/2021/04/123-best-time-to-buy-and-sell-stock-iii.html"
                    },
                    {
                        "username": "codewarrior",
                        "content": "e.g. I buy on day 1, sell on day 2, and buy again on day 2, is that allowed or I must buy on day 3 (next day)?"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "If you buy on day 1, sell on day 2, buy again on day 2, and then sell on some day x, your overall profit will be = (prices[x]-prices[2])+(prices[2]-prices[1]) = prices[x]-prices[1]. Thus, the operation on day 2 made no difference- you might as well just skip that transaction and just sell later on day x directly. So, it doesn\\'t make sense to buy again on the same day as selling."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question is very intuitive and the optimisation makes it hard. I feel sad to see so many answers (almost all) which talk about dynamic programming approach straight from the formula without giving an intuition of the recursive -> top down approach, bringing the formula for iterative dp straight from thin air. The best way to solve a DP problem is first a recursive solution -> top down -> iterative DP."
                    },
                    {
                        "username": "user3965te",
                        "content": "\"find the best two opportunities to buy and sell the stock to maximize your profit\""
                    },
                    {
                        "username": "williamwjs",
                        "content": "We have solved the problem with one transaction, all transactions and two transactions. What if we can only make at most three? I think The method we use in III (i.e. use two arrays to scan from left and from right separately) can not solve the problem with 3. Any clue?"
                    },
                    {
                        "username": "letitbemini",
                        "content": "https://hashnode.com/post/best-time-to-buy-and-sell-stocks-a-comprehensive-guide-cko8xg43m0oz194s114kz71pn\\n\\nCheck out this article. It explains the approach of first four buy and sell problems along with working code."
                    }
                ]
            },
            {
                "id": 1575414,
                "content": [
                    {
                        "username": "hongbin2",
                        "content": "We use DP to solve this problem by scan left from right and then right to left, and find out the max profits. \\nBut, what if transactions are 3 or more, how could we solve this problem?"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "Try solving Buy and Sell Stock IV"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@user9894br](/user9894br) yup \\n"
                    },
                    {
                        "username": "user9894br",
                        "content": "Seems like there should be a way solve it by recursion/DP - given any pair of dates for the first transaction you can then solve the 2-transaction problem on the date range in the future, etc."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Check this out, it explains really throughly every possible case.\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/75924/most-consistent-ways-of-dealing-with-the-series-of-stock-problems/"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "tell me what is 'two transactions'?\\nIf you buy real stock, you will be told a transaction means one buy OR one sell."
                    },
                    {
                        "username": "Ankit5ingh",
                        "content": "buy-> sell -> buy -> sell that\\'s it. max 2 transactions are allowed. one transaction means buy -> sell "
                    },
                    {
                        "username": "adherent____",
                        "content": "means you cannot buy sell more than 2 times,,,"
                    },
                    {
                        "username": "bapi007",
                        "content": "Example 1 output says 6 but I guess it should be 8.\\nBuy at 3 and sell at 5, profit 2\\nBuy at 0 and sell at 3, profit 3\\nBuy at 1 and sell at 4, profit 3\\nHence, total 8"
                    },
                    {
                        "username": "Dewanshdoley",
                        "content": "you cannot buy 2 stock at a time i.e u must sell before u buy and the traversal of day must be in continuous "
                    },
                    {
                        "username": "faisalasnari432",
                        "content": "[@nitishkamath89](/nitishkamath89) it is similar to the previous one but  where to put transaction condition "
                    },
                    {
                        "username": "nitishkamath89",
                        "content": "we are allowed  at max two transactions"
                    },
                    {
                        "username": "IvanSkl",
                        "content": "It gives an error on this test case:\\nInput:\\n[1,2,4,2,5,7,2,4,9,0]\\nOutput:\\n12\\nExpected:\\n13\\n\\nI\\'ve counted it by hand and it must be 12 as my program did. Buy on day 4 (price = 2) and sell on day 6 (price = 7), profit = 7-2 = 5. And buy on day 7 (price = 2) and sell on day 9 (price = 9), profit = 9-2 = 7. The output must be 12. But it expected 13. There is an error or I can\\'t undestand something?"
                    },
                    {
                        "username": "newtonkr",
                        "content": "[1,2,4,2,5,7] = 7-1 = 6\\n[2,4,9,0]= 9-2 = 7  (7+6 = 13)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "you should buy on day 1 (price=1) and sell on day 6(price=7), profit=7-1=6"
                    },
                    {
                        "username": "srivastavaanchal000",
                        "content": "buy on day 1(1) and sell on day 6(7) => profit = 6\\nbuy on day 7(2) and sell on day 9(9) => profit = 7\\ntotal profit = 6 + 7 = 13"
                    },
                    {
                        "username": "Saptarshi123123",
                        "content": "yes same problem!"
                    },
                    {
                        "username": "anto777",
                        "content": "You can view the solution here. This is my blog. If you find the content useful kindly upvote :)\\nYou can find the detailed explanation of the code in the link below :\\nhttps://cpexplanations.blogspot.com/2021/04/123-best-time-to-buy-and-sell-stock-iii.html"
                    },
                    {
                        "username": "codewarrior",
                        "content": "e.g. I buy on day 1, sell on day 2, and buy again on day 2, is that allowed or I must buy on day 3 (next day)?"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "If you buy on day 1, sell on day 2, buy again on day 2, and then sell on some day x, your overall profit will be = (prices[x]-prices[2])+(prices[2]-prices[1]) = prices[x]-prices[1]. Thus, the operation on day 2 made no difference- you might as well just skip that transaction and just sell later on day x directly. So, it doesn\\'t make sense to buy again on the same day as selling."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question is very intuitive and the optimisation makes it hard. I feel sad to see so many answers (almost all) which talk about dynamic programming approach straight from the formula without giving an intuition of the recursive -> top down approach, bringing the formula for iterative dp straight from thin air. The best way to solve a DP problem is first a recursive solution -> top down -> iterative DP."
                    },
                    {
                        "username": "user3965te",
                        "content": "\"find the best two opportunities to buy and sell the stock to maximize your profit\""
                    },
                    {
                        "username": "williamwjs",
                        "content": "We have solved the problem with one transaction, all transactions and two transactions. What if we can only make at most three? I think The method we use in III (i.e. use two arrays to scan from left and from right separately) can not solve the problem with 3. Any clue?"
                    },
                    {
                        "username": "letitbemini",
                        "content": "https://hashnode.com/post/best-time-to-buy-and-sell-stocks-a-comprehensive-guide-cko8xg43m0oz194s114kz71pn\\n\\nCheck out this article. It explains the approach of first four buy and sell problems along with working code."
                    }
                ]
            },
            {
                "id": 1570412,
                "content": [
                    {
                        "username": "hongbin2",
                        "content": "We use DP to solve this problem by scan left from right and then right to left, and find out the max profits. \\nBut, what if transactions are 3 or more, how could we solve this problem?"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "Try solving Buy and Sell Stock IV"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@user9894br](/user9894br) yup \\n"
                    },
                    {
                        "username": "user9894br",
                        "content": "Seems like there should be a way solve it by recursion/DP - given any pair of dates for the first transaction you can then solve the 2-transaction problem on the date range in the future, etc."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Check this out, it explains really throughly every possible case.\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/75924/most-consistent-ways-of-dealing-with-the-series-of-stock-problems/"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "tell me what is 'two transactions'?\\nIf you buy real stock, you will be told a transaction means one buy OR one sell."
                    },
                    {
                        "username": "Ankit5ingh",
                        "content": "buy-> sell -> buy -> sell that\\'s it. max 2 transactions are allowed. one transaction means buy -> sell "
                    },
                    {
                        "username": "adherent____",
                        "content": "means you cannot buy sell more than 2 times,,,"
                    },
                    {
                        "username": "bapi007",
                        "content": "Example 1 output says 6 but I guess it should be 8.\\nBuy at 3 and sell at 5, profit 2\\nBuy at 0 and sell at 3, profit 3\\nBuy at 1 and sell at 4, profit 3\\nHence, total 8"
                    },
                    {
                        "username": "Dewanshdoley",
                        "content": "you cannot buy 2 stock at a time i.e u must sell before u buy and the traversal of day must be in continuous "
                    },
                    {
                        "username": "faisalasnari432",
                        "content": "[@nitishkamath89](/nitishkamath89) it is similar to the previous one but  where to put transaction condition "
                    },
                    {
                        "username": "nitishkamath89",
                        "content": "we are allowed  at max two transactions"
                    },
                    {
                        "username": "IvanSkl",
                        "content": "It gives an error on this test case:\\nInput:\\n[1,2,4,2,5,7,2,4,9,0]\\nOutput:\\n12\\nExpected:\\n13\\n\\nI\\'ve counted it by hand and it must be 12 as my program did. Buy on day 4 (price = 2) and sell on day 6 (price = 7), profit = 7-2 = 5. And buy on day 7 (price = 2) and sell on day 9 (price = 9), profit = 9-2 = 7. The output must be 12. But it expected 13. There is an error or I can\\'t undestand something?"
                    },
                    {
                        "username": "newtonkr",
                        "content": "[1,2,4,2,5,7] = 7-1 = 6\\n[2,4,9,0]= 9-2 = 7  (7+6 = 13)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "you should buy on day 1 (price=1) and sell on day 6(price=7), profit=7-1=6"
                    },
                    {
                        "username": "srivastavaanchal000",
                        "content": "buy on day 1(1) and sell on day 6(7) => profit = 6\\nbuy on day 7(2) and sell on day 9(9) => profit = 7\\ntotal profit = 6 + 7 = 13"
                    },
                    {
                        "username": "Saptarshi123123",
                        "content": "yes same problem!"
                    },
                    {
                        "username": "anto777",
                        "content": "You can view the solution here. This is my blog. If you find the content useful kindly upvote :)\\nYou can find the detailed explanation of the code in the link below :\\nhttps://cpexplanations.blogspot.com/2021/04/123-best-time-to-buy-and-sell-stock-iii.html"
                    },
                    {
                        "username": "codewarrior",
                        "content": "e.g. I buy on day 1, sell on day 2, and buy again on day 2, is that allowed or I must buy on day 3 (next day)?"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "If you buy on day 1, sell on day 2, buy again on day 2, and then sell on some day x, your overall profit will be = (prices[x]-prices[2])+(prices[2]-prices[1]) = prices[x]-prices[1]. Thus, the operation on day 2 made no difference- you might as well just skip that transaction and just sell later on day x directly. So, it doesn\\'t make sense to buy again on the same day as selling."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question is very intuitive and the optimisation makes it hard. I feel sad to see so many answers (almost all) which talk about dynamic programming approach straight from the formula without giving an intuition of the recursive -> top down approach, bringing the formula for iterative dp straight from thin air. The best way to solve a DP problem is first a recursive solution -> top down -> iterative DP."
                    },
                    {
                        "username": "user3965te",
                        "content": "\"find the best two opportunities to buy and sell the stock to maximize your profit\""
                    },
                    {
                        "username": "williamwjs",
                        "content": "We have solved the problem with one transaction, all transactions and two transactions. What if we can only make at most three? I think The method we use in III (i.e. use two arrays to scan from left and from right separately) can not solve the problem with 3. Any clue?"
                    },
                    {
                        "username": "letitbemini",
                        "content": "https://hashnode.com/post/best-time-to-buy-and-sell-stocks-a-comprehensive-guide-cko8xg43m0oz194s114kz71pn\\n\\nCheck out this article. It explains the approach of first four buy and sell problems along with working code."
                    }
                ]
            },
            {
                "id": 1569483,
                "content": [
                    {
                        "username": "hongbin2",
                        "content": "We use DP to solve this problem by scan left from right and then right to left, and find out the max profits. \\nBut, what if transactions are 3 or more, how could we solve this problem?"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "Try solving Buy and Sell Stock IV"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@user9894br](/user9894br) yup \\n"
                    },
                    {
                        "username": "user9894br",
                        "content": "Seems like there should be a way solve it by recursion/DP - given any pair of dates for the first transaction you can then solve the 2-transaction problem on the date range in the future, etc."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Check this out, it explains really throughly every possible case.\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/75924/most-consistent-ways-of-dealing-with-the-series-of-stock-problems/"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "tell me what is 'two transactions'?\\nIf you buy real stock, you will be told a transaction means one buy OR one sell."
                    },
                    {
                        "username": "Ankit5ingh",
                        "content": "buy-> sell -> buy -> sell that\\'s it. max 2 transactions are allowed. one transaction means buy -> sell "
                    },
                    {
                        "username": "adherent____",
                        "content": "means you cannot buy sell more than 2 times,,,"
                    },
                    {
                        "username": "bapi007",
                        "content": "Example 1 output says 6 but I guess it should be 8.\\nBuy at 3 and sell at 5, profit 2\\nBuy at 0 and sell at 3, profit 3\\nBuy at 1 and sell at 4, profit 3\\nHence, total 8"
                    },
                    {
                        "username": "Dewanshdoley",
                        "content": "you cannot buy 2 stock at a time i.e u must sell before u buy and the traversal of day must be in continuous "
                    },
                    {
                        "username": "faisalasnari432",
                        "content": "[@nitishkamath89](/nitishkamath89) it is similar to the previous one but  where to put transaction condition "
                    },
                    {
                        "username": "nitishkamath89",
                        "content": "we are allowed  at max two transactions"
                    },
                    {
                        "username": "IvanSkl",
                        "content": "It gives an error on this test case:\\nInput:\\n[1,2,4,2,5,7,2,4,9,0]\\nOutput:\\n12\\nExpected:\\n13\\n\\nI\\'ve counted it by hand and it must be 12 as my program did. Buy on day 4 (price = 2) and sell on day 6 (price = 7), profit = 7-2 = 5. And buy on day 7 (price = 2) and sell on day 9 (price = 9), profit = 9-2 = 7. The output must be 12. But it expected 13. There is an error or I can\\'t undestand something?"
                    },
                    {
                        "username": "newtonkr",
                        "content": "[1,2,4,2,5,7] = 7-1 = 6\\n[2,4,9,0]= 9-2 = 7  (7+6 = 13)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "you should buy on day 1 (price=1) and sell on day 6(price=7), profit=7-1=6"
                    },
                    {
                        "username": "srivastavaanchal000",
                        "content": "buy on day 1(1) and sell on day 6(7) => profit = 6\\nbuy on day 7(2) and sell on day 9(9) => profit = 7\\ntotal profit = 6 + 7 = 13"
                    },
                    {
                        "username": "Saptarshi123123",
                        "content": "yes same problem!"
                    },
                    {
                        "username": "anto777",
                        "content": "You can view the solution here. This is my blog. If you find the content useful kindly upvote :)\\nYou can find the detailed explanation of the code in the link below :\\nhttps://cpexplanations.blogspot.com/2021/04/123-best-time-to-buy-and-sell-stock-iii.html"
                    },
                    {
                        "username": "codewarrior",
                        "content": "e.g. I buy on day 1, sell on day 2, and buy again on day 2, is that allowed or I must buy on day 3 (next day)?"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "If you buy on day 1, sell on day 2, buy again on day 2, and then sell on some day x, your overall profit will be = (prices[x]-prices[2])+(prices[2]-prices[1]) = prices[x]-prices[1]. Thus, the operation on day 2 made no difference- you might as well just skip that transaction and just sell later on day x directly. So, it doesn\\'t make sense to buy again on the same day as selling."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question is very intuitive and the optimisation makes it hard. I feel sad to see so many answers (almost all) which talk about dynamic programming approach straight from the formula without giving an intuition of the recursive -> top down approach, bringing the formula for iterative dp straight from thin air. The best way to solve a DP problem is first a recursive solution -> top down -> iterative DP."
                    },
                    {
                        "username": "user3965te",
                        "content": "\"find the best two opportunities to buy and sell the stock to maximize your profit\""
                    },
                    {
                        "username": "williamwjs",
                        "content": "We have solved the problem with one transaction, all transactions and two transactions. What if we can only make at most three? I think The method we use in III (i.e. use two arrays to scan from left and from right separately) can not solve the problem with 3. Any clue?"
                    },
                    {
                        "username": "letitbemini",
                        "content": "https://hashnode.com/post/best-time-to-buy-and-sell-stocks-a-comprehensive-guide-cko8xg43m0oz194s114kz71pn\\n\\nCheck out this article. It explains the approach of first four buy and sell problems along with working code."
                    }
                ]
            },
            {
                "id": 1905005,
                "content": [
                    {
                        "username": "hongbin2",
                        "content": "We use DP to solve this problem by scan left from right and then right to left, and find out the max profits. \\nBut, what if transactions are 3 or more, how could we solve this problem?"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "Try solving Buy and Sell Stock IV"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@user9894br](/user9894br) yup \\n"
                    },
                    {
                        "username": "user9894br",
                        "content": "Seems like there should be a way solve it by recursion/DP - given any pair of dates for the first transaction you can then solve the 2-transaction problem on the date range in the future, etc."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Check this out, it explains really throughly every possible case.\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/75924/most-consistent-ways-of-dealing-with-the-series-of-stock-problems/"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "tell me what is 'two transactions'?\\nIf you buy real stock, you will be told a transaction means one buy OR one sell."
                    },
                    {
                        "username": "Ankit5ingh",
                        "content": "buy-> sell -> buy -> sell that\\'s it. max 2 transactions are allowed. one transaction means buy -> sell "
                    },
                    {
                        "username": "adherent____",
                        "content": "means you cannot buy sell more than 2 times,,,"
                    },
                    {
                        "username": "bapi007",
                        "content": "Example 1 output says 6 but I guess it should be 8.\\nBuy at 3 and sell at 5, profit 2\\nBuy at 0 and sell at 3, profit 3\\nBuy at 1 and sell at 4, profit 3\\nHence, total 8"
                    },
                    {
                        "username": "Dewanshdoley",
                        "content": "you cannot buy 2 stock at a time i.e u must sell before u buy and the traversal of day must be in continuous "
                    },
                    {
                        "username": "faisalasnari432",
                        "content": "[@nitishkamath89](/nitishkamath89) it is similar to the previous one but  where to put transaction condition "
                    },
                    {
                        "username": "nitishkamath89",
                        "content": "we are allowed  at max two transactions"
                    },
                    {
                        "username": "IvanSkl",
                        "content": "It gives an error on this test case:\\nInput:\\n[1,2,4,2,5,7,2,4,9,0]\\nOutput:\\n12\\nExpected:\\n13\\n\\nI\\'ve counted it by hand and it must be 12 as my program did. Buy on day 4 (price = 2) and sell on day 6 (price = 7), profit = 7-2 = 5. And buy on day 7 (price = 2) and sell on day 9 (price = 9), profit = 9-2 = 7. The output must be 12. But it expected 13. There is an error or I can\\'t undestand something?"
                    },
                    {
                        "username": "newtonkr",
                        "content": "[1,2,4,2,5,7] = 7-1 = 6\\n[2,4,9,0]= 9-2 = 7  (7+6 = 13)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "you should buy on day 1 (price=1) and sell on day 6(price=7), profit=7-1=6"
                    },
                    {
                        "username": "srivastavaanchal000",
                        "content": "buy on day 1(1) and sell on day 6(7) => profit = 6\\nbuy on day 7(2) and sell on day 9(9) => profit = 7\\ntotal profit = 6 + 7 = 13"
                    },
                    {
                        "username": "Saptarshi123123",
                        "content": "yes same problem!"
                    },
                    {
                        "username": "anto777",
                        "content": "You can view the solution here. This is my blog. If you find the content useful kindly upvote :)\\nYou can find the detailed explanation of the code in the link below :\\nhttps://cpexplanations.blogspot.com/2021/04/123-best-time-to-buy-and-sell-stock-iii.html"
                    },
                    {
                        "username": "codewarrior",
                        "content": "e.g. I buy on day 1, sell on day 2, and buy again on day 2, is that allowed or I must buy on day 3 (next day)?"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "If you buy on day 1, sell on day 2, buy again on day 2, and then sell on some day x, your overall profit will be = (prices[x]-prices[2])+(prices[2]-prices[1]) = prices[x]-prices[1]. Thus, the operation on day 2 made no difference- you might as well just skip that transaction and just sell later on day x directly. So, it doesn\\'t make sense to buy again on the same day as selling."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question is very intuitive and the optimisation makes it hard. I feel sad to see so many answers (almost all) which talk about dynamic programming approach straight from the formula without giving an intuition of the recursive -> top down approach, bringing the formula for iterative dp straight from thin air. The best way to solve a DP problem is first a recursive solution -> top down -> iterative DP."
                    },
                    {
                        "username": "user3965te",
                        "content": "\"find the best two opportunities to buy and sell the stock to maximize your profit\""
                    },
                    {
                        "username": "williamwjs",
                        "content": "We have solved the problem with one transaction, all transactions and two transactions. What if we can only make at most three? I think The method we use in III (i.e. use two arrays to scan from left and from right separately) can not solve the problem with 3. Any clue?"
                    },
                    {
                        "username": "letitbemini",
                        "content": "https://hashnode.com/post/best-time-to-buy-and-sell-stocks-a-comprehensive-guide-cko8xg43m0oz194s114kz71pn\\n\\nCheck out this article. It explains the approach of first four buy and sell problems along with working code."
                    }
                ]
            },
            {
                "id": 1806035,
                "content": [
                    {
                        "username": "hongbin2",
                        "content": "We use DP to solve this problem by scan left from right and then right to left, and find out the max profits. \\nBut, what if transactions are 3 or more, how could we solve this problem?"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "Try solving Buy and Sell Stock IV"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@user9894br](/user9894br) yup \\n"
                    },
                    {
                        "username": "user9894br",
                        "content": "Seems like there should be a way solve it by recursion/DP - given any pair of dates for the first transaction you can then solve the 2-transaction problem on the date range in the future, etc."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Check this out, it explains really throughly every possible case.\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/75924/most-consistent-ways-of-dealing-with-the-series-of-stock-problems/"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "tell me what is 'two transactions'?\\nIf you buy real stock, you will be told a transaction means one buy OR one sell."
                    },
                    {
                        "username": "Ankit5ingh",
                        "content": "buy-> sell -> buy -> sell that\\'s it. max 2 transactions are allowed. one transaction means buy -> sell "
                    },
                    {
                        "username": "adherent____",
                        "content": "means you cannot buy sell more than 2 times,,,"
                    },
                    {
                        "username": "bapi007",
                        "content": "Example 1 output says 6 but I guess it should be 8.\\nBuy at 3 and sell at 5, profit 2\\nBuy at 0 and sell at 3, profit 3\\nBuy at 1 and sell at 4, profit 3\\nHence, total 8"
                    },
                    {
                        "username": "Dewanshdoley",
                        "content": "you cannot buy 2 stock at a time i.e u must sell before u buy and the traversal of day must be in continuous "
                    },
                    {
                        "username": "faisalasnari432",
                        "content": "[@nitishkamath89](/nitishkamath89) it is similar to the previous one but  where to put transaction condition "
                    },
                    {
                        "username": "nitishkamath89",
                        "content": "we are allowed  at max two transactions"
                    },
                    {
                        "username": "IvanSkl",
                        "content": "It gives an error on this test case:\\nInput:\\n[1,2,4,2,5,7,2,4,9,0]\\nOutput:\\n12\\nExpected:\\n13\\n\\nI\\'ve counted it by hand and it must be 12 as my program did. Buy on day 4 (price = 2) and sell on day 6 (price = 7), profit = 7-2 = 5. And buy on day 7 (price = 2) and sell on day 9 (price = 9), profit = 9-2 = 7. The output must be 12. But it expected 13. There is an error or I can\\'t undestand something?"
                    },
                    {
                        "username": "newtonkr",
                        "content": "[1,2,4,2,5,7] = 7-1 = 6\\n[2,4,9,0]= 9-2 = 7  (7+6 = 13)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "you should buy on day 1 (price=1) and sell on day 6(price=7), profit=7-1=6"
                    },
                    {
                        "username": "srivastavaanchal000",
                        "content": "buy on day 1(1) and sell on day 6(7) => profit = 6\\nbuy on day 7(2) and sell on day 9(9) => profit = 7\\ntotal profit = 6 + 7 = 13"
                    },
                    {
                        "username": "Saptarshi123123",
                        "content": "yes same problem!"
                    },
                    {
                        "username": "anto777",
                        "content": "You can view the solution here. This is my blog. If you find the content useful kindly upvote :)\\nYou can find the detailed explanation of the code in the link below :\\nhttps://cpexplanations.blogspot.com/2021/04/123-best-time-to-buy-and-sell-stock-iii.html"
                    },
                    {
                        "username": "codewarrior",
                        "content": "e.g. I buy on day 1, sell on day 2, and buy again on day 2, is that allowed or I must buy on day 3 (next day)?"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "If you buy on day 1, sell on day 2, buy again on day 2, and then sell on some day x, your overall profit will be = (prices[x]-prices[2])+(prices[2]-prices[1]) = prices[x]-prices[1]. Thus, the operation on day 2 made no difference- you might as well just skip that transaction and just sell later on day x directly. So, it doesn\\'t make sense to buy again on the same day as selling."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question is very intuitive and the optimisation makes it hard. I feel sad to see so many answers (almost all) which talk about dynamic programming approach straight from the formula without giving an intuition of the recursive -> top down approach, bringing the formula for iterative dp straight from thin air. The best way to solve a DP problem is first a recursive solution -> top down -> iterative DP."
                    },
                    {
                        "username": "user3965te",
                        "content": "\"find the best two opportunities to buy and sell the stock to maximize your profit\""
                    },
                    {
                        "username": "williamwjs",
                        "content": "We have solved the problem with one transaction, all transactions and two transactions. What if we can only make at most three? I think The method we use in III (i.e. use two arrays to scan from left and from right separately) can not solve the problem with 3. Any clue?"
                    },
                    {
                        "username": "letitbemini",
                        "content": "https://hashnode.com/post/best-time-to-buy-and-sell-stocks-a-comprehensive-guide-cko8xg43m0oz194s114kz71pn\\n\\nCheck out this article. It explains the approach of first four buy and sell problems along with working code."
                    }
                ]
            },
            {
                "id": 1568938,
                "content": [
                    {
                        "username": "hongbin2",
                        "content": "We use DP to solve this problem by scan left from right and then right to left, and find out the max profits. \\nBut, what if transactions are 3 or more, how could we solve this problem?"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "Try solving Buy and Sell Stock IV"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@user9894br](/user9894br) yup \\n"
                    },
                    {
                        "username": "user9894br",
                        "content": "Seems like there should be a way solve it by recursion/DP - given any pair of dates for the first transaction you can then solve the 2-transaction problem on the date range in the future, etc."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Check this out, it explains really throughly every possible case.\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/75924/most-consistent-ways-of-dealing-with-the-series-of-stock-problems/"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "tell me what is 'two transactions'?\\nIf you buy real stock, you will be told a transaction means one buy OR one sell."
                    },
                    {
                        "username": "Ankit5ingh",
                        "content": "buy-> sell -> buy -> sell that\\'s it. max 2 transactions are allowed. one transaction means buy -> sell "
                    },
                    {
                        "username": "adherent____",
                        "content": "means you cannot buy sell more than 2 times,,,"
                    },
                    {
                        "username": "bapi007",
                        "content": "Example 1 output says 6 but I guess it should be 8.\\nBuy at 3 and sell at 5, profit 2\\nBuy at 0 and sell at 3, profit 3\\nBuy at 1 and sell at 4, profit 3\\nHence, total 8"
                    },
                    {
                        "username": "Dewanshdoley",
                        "content": "you cannot buy 2 stock at a time i.e u must sell before u buy and the traversal of day must be in continuous "
                    },
                    {
                        "username": "faisalasnari432",
                        "content": "[@nitishkamath89](/nitishkamath89) it is similar to the previous one but  where to put transaction condition "
                    },
                    {
                        "username": "nitishkamath89",
                        "content": "we are allowed  at max two transactions"
                    },
                    {
                        "username": "IvanSkl",
                        "content": "It gives an error on this test case:\\nInput:\\n[1,2,4,2,5,7,2,4,9,0]\\nOutput:\\n12\\nExpected:\\n13\\n\\nI\\'ve counted it by hand and it must be 12 as my program did. Buy on day 4 (price = 2) and sell on day 6 (price = 7), profit = 7-2 = 5. And buy on day 7 (price = 2) and sell on day 9 (price = 9), profit = 9-2 = 7. The output must be 12. But it expected 13. There is an error or I can\\'t undestand something?"
                    },
                    {
                        "username": "newtonkr",
                        "content": "[1,2,4,2,5,7] = 7-1 = 6\\n[2,4,9,0]= 9-2 = 7  (7+6 = 13)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "you should buy on day 1 (price=1) and sell on day 6(price=7), profit=7-1=6"
                    },
                    {
                        "username": "srivastavaanchal000",
                        "content": "buy on day 1(1) and sell on day 6(7) => profit = 6\\nbuy on day 7(2) and sell on day 9(9) => profit = 7\\ntotal profit = 6 + 7 = 13"
                    },
                    {
                        "username": "Saptarshi123123",
                        "content": "yes same problem!"
                    },
                    {
                        "username": "anto777",
                        "content": "You can view the solution here. This is my blog. If you find the content useful kindly upvote :)\\nYou can find the detailed explanation of the code in the link below :\\nhttps://cpexplanations.blogspot.com/2021/04/123-best-time-to-buy-and-sell-stock-iii.html"
                    },
                    {
                        "username": "codewarrior",
                        "content": "e.g. I buy on day 1, sell on day 2, and buy again on day 2, is that allowed or I must buy on day 3 (next day)?"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "If you buy on day 1, sell on day 2, buy again on day 2, and then sell on some day x, your overall profit will be = (prices[x]-prices[2])+(prices[2]-prices[1]) = prices[x]-prices[1]. Thus, the operation on day 2 made no difference- you might as well just skip that transaction and just sell later on day x directly. So, it doesn\\'t make sense to buy again on the same day as selling."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question is very intuitive and the optimisation makes it hard. I feel sad to see so many answers (almost all) which talk about dynamic programming approach straight from the formula without giving an intuition of the recursive -> top down approach, bringing the formula for iterative dp straight from thin air. The best way to solve a DP problem is first a recursive solution -> top down -> iterative DP."
                    },
                    {
                        "username": "user3965te",
                        "content": "\"find the best two opportunities to buy and sell the stock to maximize your profit\""
                    },
                    {
                        "username": "williamwjs",
                        "content": "We have solved the problem with one transaction, all transactions and two transactions. What if we can only make at most three? I think The method we use in III (i.e. use two arrays to scan from left and from right separately) can not solve the problem with 3. Any clue?"
                    },
                    {
                        "username": "letitbemini",
                        "content": "https://hashnode.com/post/best-time-to-buy-and-sell-stocks-a-comprehensive-guide-cko8xg43m0oz194s114kz71pn\\n\\nCheck out this article. It explains the approach of first four buy and sell problems along with working code."
                    }
                ]
            },
            {
                "id": 1567602,
                "content": [
                    {
                        "username": "hongbin2",
                        "content": "We use DP to solve this problem by scan left from right and then right to left, and find out the max profits. \\nBut, what if transactions are 3 or more, how could we solve this problem?"
                    },
                    {
                        "username": "aaryanman05",
                        "content": "Try solving Buy and Sell Stock IV"
                    },
                    {
                        "username": "manraj_singh_16447",
                        "content": "[@user9894br](/user9894br) yup \\n"
                    },
                    {
                        "username": "user9894br",
                        "content": "Seems like there should be a way solve it by recursion/DP - given any pair of dates for the first transaction you can then solve the 2-transaction problem on the date range in the future, etc."
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Check this out, it explains really throughly every possible case.\nhttps://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solutions/75924/most-consistent-ways-of-dealing-with-the-series-of-stock-problems/"
                    },
                    {
                        "username": "yangyangjuanjuan",
                        "content": "tell me what is 'two transactions'?\\nIf you buy real stock, you will be told a transaction means one buy OR one sell."
                    },
                    {
                        "username": "Ankit5ingh",
                        "content": "buy-> sell -> buy -> sell that\\'s it. max 2 transactions are allowed. one transaction means buy -> sell "
                    },
                    {
                        "username": "adherent____",
                        "content": "means you cannot buy sell more than 2 times,,,"
                    },
                    {
                        "username": "bapi007",
                        "content": "Example 1 output says 6 but I guess it should be 8.\\nBuy at 3 and sell at 5, profit 2\\nBuy at 0 and sell at 3, profit 3\\nBuy at 1 and sell at 4, profit 3\\nHence, total 8"
                    },
                    {
                        "username": "Dewanshdoley",
                        "content": "you cannot buy 2 stock at a time i.e u must sell before u buy and the traversal of day must be in continuous "
                    },
                    {
                        "username": "faisalasnari432",
                        "content": "[@nitishkamath89](/nitishkamath89) it is similar to the previous one but  where to put transaction condition "
                    },
                    {
                        "username": "nitishkamath89",
                        "content": "we are allowed  at max two transactions"
                    },
                    {
                        "username": "IvanSkl",
                        "content": "It gives an error on this test case:\\nInput:\\n[1,2,4,2,5,7,2,4,9,0]\\nOutput:\\n12\\nExpected:\\n13\\n\\nI\\'ve counted it by hand and it must be 12 as my program did. Buy on day 4 (price = 2) and sell on day 6 (price = 7), profit = 7-2 = 5. And buy on day 7 (price = 2) and sell on day 9 (price = 9), profit = 9-2 = 7. The output must be 12. But it expected 13. There is an error or I can\\'t undestand something?"
                    },
                    {
                        "username": "newtonkr",
                        "content": "[1,2,4,2,5,7] = 7-1 = 6\\n[2,4,9,0]= 9-2 = 7  (7+6 = 13)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "you should buy on day 1 (price=1) and sell on day 6(price=7), profit=7-1=6"
                    },
                    {
                        "username": "srivastavaanchal000",
                        "content": "buy on day 1(1) and sell on day 6(7) => profit = 6\\nbuy on day 7(2) and sell on day 9(9) => profit = 7\\ntotal profit = 6 + 7 = 13"
                    },
                    {
                        "username": "Saptarshi123123",
                        "content": "yes same problem!"
                    },
                    {
                        "username": "anto777",
                        "content": "You can view the solution here. This is my blog. If you find the content useful kindly upvote :)\\nYou can find the detailed explanation of the code in the link below :\\nhttps://cpexplanations.blogspot.com/2021/04/123-best-time-to-buy-and-sell-stock-iii.html"
                    },
                    {
                        "username": "codewarrior",
                        "content": "e.g. I buy on day 1, sell on day 2, and buy again on day 2, is that allowed or I must buy on day 3 (next day)?"
                    },
                    {
                        "username": "tayalaks2001",
                        "content": "If you buy on day 1, sell on day 2, buy again on day 2, and then sell on some day x, your overall profit will be = (prices[x]-prices[2])+(prices[2]-prices[1]) = prices[x]-prices[1]. Thus, the operation on day 2 made no difference- you might as well just skip that transaction and just sell later on day x directly. So, it doesn\\'t make sense to buy again on the same day as selling."
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question is very intuitive and the optimisation makes it hard. I feel sad to see so many answers (almost all) which talk about dynamic programming approach straight from the formula without giving an intuition of the recursive -> top down approach, bringing the formula for iterative dp straight from thin air. The best way to solve a DP problem is first a recursive solution -> top down -> iterative DP."
                    },
                    {
                        "username": "user3965te",
                        "content": "\"find the best two opportunities to buy and sell the stock to maximize your profit\""
                    },
                    {
                        "username": "williamwjs",
                        "content": "We have solved the problem with one transaction, all transactions and two transactions. What if we can only make at most three? I think The method we use in III (i.e. use two arrays to scan from left and from right separately) can not solve the problem with 3. Any clue?"
                    },
                    {
                        "username": "letitbemini",
                        "content": "https://hashnode.com/post/best-time-to-buy-and-sell-stocks-a-comprehensive-guide-cko8xg43m0oz194s114kz71pn\\n\\nCheck out this article. It explains the approach of first four buy and sell problems along with working code."
                    }
                ]
            },
            {
                "id": 1922296,
                "content": [
                    {
                        "username": "Ankit5ingh",
                        "content": "TLE test case \\n[397,6621,4997,7506,8918,1662,9187,3278,3890,514,18,9305,93,5508,3031,2692,6019,1134,1691,4949,5071,799,8953,7882,4273,302,6753,4657,8368,3942,1982,5117,563,3332,2623,9482,4994,8163,9112,5236,5029,5483,4542,1474,991,3925,4166,3362,5059,5857,4663,6482,3008,3616,4365,3634,270,1118,8291,4990,1413,273,107,1976,9957,9083,7810,4952,7246,3275,6540,2275,8758,7434,3750,6101,1359,4268,5815,2771,126,478,9253,9486,446,3618,3120,7068,1089,1411,2058,2502,8037,2165,830,7994,1248,4993,9298,4846,8268,2191,3474,3378,9625,7224,9479,985,1492,1646,3756,7970,8476,3009,7457,8922,2980,577,2342,4069,8341,4400,2923,2730,2917,105,724,518,5098,6375,5364,3366,8566,8838,3096,8191,2414,2575,5528,259,573,5636,4581,9049,4998,2038,4323,7978,8968,6665,8399,7309,7417,1322,6391,335,1427,7115,853,2878,9842,2569,2596,4760,7760,5693,9304,6526,8268,4832,6785,5194,6821,1367,4243,1819,9757,4919,6149,8725,7936,4548,2386,5354,2222,8777,2041,1,2245,9246,2879,8439,1815,5476,3200,5927,7521,2504,2454,5789,3688,9239,7335,6861,6958,7931,8680,3068,2850,1181,1793,7138,2081,532,2492,4303,5661,885,657,4258,131,9888,9050,1947,1716,2250,4226,9237,1106,6680,1379,1146,2272,8714,8008,9230,6645,3040,2298,5847,4222,444,2986,2655,7328,1830,6959,9341,2716,3968,9952,2847,3856,9002,1146,5573,1252,5373,1162,8710,2053,2541,9856,677,1256,4216,9908,4253,3609,8558,6453,4183,5354,9439,6838,2682,7621,149,8376,337,4117,8328,9537,4326,7330,683,9899,4934,2408,7413,9996,814,9955,9852,1491,7563,421,7751,1816,4030,2662,8269,8213,8016,4060,5051,7051,1682,5201,5427,8371,5670,3755,7908,9996,7437,4944,9895,2371,7352,3661,2367,4518,3616,8571,6010,1179,5344,113,9347,9374,2775,3969,3939,792,4381,8991,7843,2415,544,3270,787,6214,3377,8695,6211,814,9991,2458,9537,7344,6119,1904,8214,6087,6827,4224,7266,2172,690,2966,7898,3465,3287,1838,609,7668,829,8452,84,7725,8074,871,3939,7803,5918,6502,4969,5910,5313,4506,9606,1432,2762,7820,3872,9590,8397,1138,8114,9087,456,6012,8904,3743,7850,9514,7764,5031,4318,7848,9108,8745,5071,9400,2900,7341,5902,7870,3251,7567,2376,9209,9000,1491,7030,2872,7433,1779,362,5547,7218,7171,7911,2474,914,2114,8340,8678,3497,2659,2878,2606,7756,7949,2006,656,5291,4260,8526,4894,1828,7255,456,7180,8746,3838,6404,6179,5617,3118,8078,9187,289,5989,1661,1204,8103,2,6234,7953,9013,5465,559,6769,9766,2565,7425,1409,3177,2304,6304,5005,9559,6760,2185,4657,598,8589,836,2567,1708,5266,1754,8349,1255,9767,5905,5711,9769,8492,3664,5134,3957,575,1903,3723,3140,5681,5133,6317,4337,7789,7675,3896,4549,6212,8553,1499,1154,5741,418,9214,1007,2172,7563,8614,8291,3469,677,4413,1961,4341,9547,5918,4916,7803,9641,4408,3484,1126,7078,7821,8915,1105,8069,9816,7317,2974,1315,8471,8715,1733,7685,6074,257,5249,4688,8549,5070,5366,2962,7031,6059,8861,9301,7328,6664,5294,8088,6500,6421,1518,4321,5336,2623,8742,1505,9941,1716,2820,4764,6783,906,2450,2857,7515,4051,7546,2416,9121,9264,1730,6152,1675,592,1805,9003,7256,7099,3444,3757,9872,4962,4430,1561,7586,3173,3066,3879,1241,2238,8643,8025,3144,7445,882,7012,1496,4780,9428,617,396,1159,3121,2072,1751,4926,7427,5359,8378,871,5468,8250,5834,9899,9811,9772,9424,2877,3651,7017,5116,8646,5042,4612,6092,2277,1624,7588,3409,1053,8206,3806,8564,7679,2230,6667,8958,6009,2026,7336,6881,3847,5586,9067,98,1750,8839,9522,4627,8842,2891,6095,7488,7934,708,3580,6563,8684,7521,9972,6089,2079,130,4653,9758,2360,1320,8716,8370,9699,6052,1603,3546,7991,670,3644,6093,9509,9518,7072,4703,2409,3168,2191,6695,228,2124,3258,5264,9645,9583,1354,1724,9713,2359,1482,8426,3680,6551,3148,9731,8955,4751,9629,6946,5421,9625,9391,1282,5495,6464,5985,4256,5984,4528,952,6212,6652,562,1476,6297,145,9182,8021,6211,1542,5856,4637,1574,2407,7785,1305,1362,2536,934,4661,4309,559,4052,1943,2406,516,4280,6662,2852,8808,7614,9064,1813,4529,6893,8110,4674,2427,2484,7237,3969,8340,1874,5543,7099,6011,3200,8461,8547,486,9474,9208,7397,9879,7503,9803,6747,1783,6466,9600,6944,432,8664,8757,4961,1909,6867,5988,4337,5703,3225,4658,4043,1452,6554,1142,7463,9754,5956,2363,241,1782,7923,7638,1661,5427,3794,8409,7210,260,8009,4154,692,3025,9263,2006,4935,2483,7994,5624,8186,7571,282,8582,9023,6836,6076,6487,6591,2032,8850,3184,3815,3125,7174,5476,8552,968,3885,2115,7580,8246,2621,4625,1272,1885,6631,6207,4368,4625,8183,2554,8548,8465,1136,7572,1654,7213,411,4597,5597,5613,7781,5764,8738,1307,7593,7291,8628,7830,9406,6208,6077,2027,833,7349,3912,7464,9908,4632,8441,8091,7187,6990,2908,4675,914,4562,8240,1325,9159,190,6938,3292,5954,2028,4600,9899,9319,3228,7730,5077,9436,159,7105,6622,7508,7369,4086,3768,2002,8880,8211,5541,2222,1119,216,3136,5682,4809,813,1193,4999,4103,4486,7305,6131,9086,7205,5451,2314,1287,528,8102,1446,3985,4724,5306,1355,5163,9074,9709,4043,7285,5250,2617,4756,1818,2105,6790,6627,2918,7984,7978,7021,2470,1636,3152,7908,8841,4955,222,6480,5484,4676,7926,5821,9401,3232,7176,916,8658,3237,1311,5943,8487,3928,7051,306,6033,3842,3285,8951,1826,7616,2324,648,9252,5476,8556,4445,6784]"
                    },
                    {
                        "username": "Raju10",
                        "content": "[1, 2, 4, 2, 5, 7, 2, 4, 9, 0]\\ncan anyone tell how the expected output is 13 for the above test case input,\\ni think its 12, isn\\'t it??"
                    },
                    {
                        "username": "itaisir",
                        "content": "buy on day 1(1) and sell on day 6(7) => profit = 6\\nbuy on day 7(2) and sell on day 9(9) => profit = 7\\ntotal profit = 6 + 7 = 13"
                    },
                    {
                        "username": "anwendeng",
                        "content": "you should buy on day 1 (price=1) and sell on day 6(price=7), profit=7-1=6"
                    },
                    {
                        "username": "engineerNewYork",
                        "content": "You buy when the price is 1 and sell when the price 7 where your profit is 6. The next time, you buy when the price is 2 and then sell it when it increases to 9 with which you make a profit of 7. In total, you get 13. "
                    },
                    {
                        "username": "tibi01993",
                        "content": "Hi everyone,\\nCan anyone help to explain why this testcase return 13? \\n[1,2,4,2,5,7,2,4,9,0]\\nAs I have profits :\\n4 - 1 = 3\\n7 - 2 = 5 \\n9 - 2 = 7\\n-> MaxProfit with 2 transactions: 5 + 7 = 12"
                    },
                    {
                        "username": "itaisir",
                        "content": "buy on day 1(1) and sell on day 6(7) => profit = 6\\nbuy on day 7(2) and sell on day 9(9) => profit = 7\\ntotal profit = 6 + 7 = 13"
                    },
                    {
                        "username": "anwendeng",
                        "content": "you should buy on day 1 (price=1) and sell on day 6(price=7), profit=7-1=6\\n"
                    },
                    {
                        "username": "arqb",
                        "content": "[@Jim](/tibi01993) and [@Saptarshi123123](/Saptarshi123123) the 2 biggest transactions are : \n9-2 = 7\n7-1 = 6\n => 7+6 = 13"
                    },
                    {
                        "username": "Saptarshi123123",
                        "content": "yes same problem!\\n"
                    },
                    {
                        "username": "wibotwi",
                        "content": "The problem for me was in understanding other guys -> because they name variables in strange way. When they say \\'sell2\\' they actually mean \\'totalProfitAfterSecondSell\\'. After I realized that -> I understood the solution.\\n\\nLet\\'s assume task was: Buy stocks on one day only. (pay attention: no sell at all!)\\nThe solution would be: find minimum of a function \\'totalProfitAfterFirstBuy\\'.\\nWhich is just go through all days and search for minimum of \\'- currPrice\\'. (cause buying stock makes our profit negative, we had \"0\"$ and now we have \"-X\"$).\\n\\nLet\\'s add second operation. The one day buy/sell solution : find minimum of a function \\'totalProfitAfterSecondSellAfterFirstBuy\\'.\\nWe will continue minimizing \\'totalProfitAfterFirstBuy\\'. But at the same time we will be minimizing \\'totalProfitAfterSecondSellAfterFirstBuy = totalProfitAfterFirstBuy + currPrice\\'. (selling gives us positive, we earn money).\\n\\nNow this solution can be applied to any number of operations. Say we were asked to minimize operations: \"Buy, Buy, Buy, Sell, Sell\".\\nTo solve it we will be minimizing profits after each op: [profitAfterOp1, profitAfterOp2, profitAfterOp3, ...].\\n\\nHope this will make it clear for everybody!\\n\\n"
                    },
                    {
                        "username": "aditichoudhary",
                        "content": "[1,2,4,2,5,7,2,4,9,0] for this input how the expected output is 13......as sets of peak valley are(V-1 P-4, V-2 P-7,V-2 P-9)  maxprofit will be =(7-2)+(9-2)"
                    },
                    {
                        "username": "ABoyNamedCrow",
                        "content": "Does it mean you can buy once and sell once, or does it mean you can buy twice and sell twice?\\n\\nNaively it seems clear the meaning should be buy once and sell once, but looking at the test cases, the other meaning seems to be what the autograder wants. Really poorly worded."
                    },
                    {
                        "username": "zhnzhang61",
                        "content": "For some of the test cases, how can a stock be priced at 0????????\\n[2,1,2,0,1]"
                    },
                    {
                        "username": "belwalrohan",
                        "content": "https://github.com/belwalrohan/August-Leetcode-Challenge/blob/master/16thAug.cpp"
                    },
                    {
                        "username": "mls__",
                        "content": "**Example 2:**\\n`Buy on day 1 (price = 1)` and at same time `Note that you cannot buy on day 1`.\\nI\\'m confused. \\n\\n\\n"
                    },
                    {
                        "username": "krishnakumar780800",
                        "content": "for the arr [1,2,3,4,5] here we buy om 1st day and sell on 5th day so profit=4 ans buy on 2nd day and sell on 4th day so profit is 2 so total profit will be 4+2=6"
                    },
                    {
                        "username": "rawbeholder",
                        "content": "You must sell the stock before buying again , so you cannot buy the stock on the 2nd day since one stock is already purchased. You need to sell the stock before buying agian."
                    }
                ]
            },
            {
                "id": 1574919,
                "content": [
                    {
                        "username": "Ankit5ingh",
                        "content": "TLE test case \\n[397,6621,4997,7506,8918,1662,9187,3278,3890,514,18,9305,93,5508,3031,2692,6019,1134,1691,4949,5071,799,8953,7882,4273,302,6753,4657,8368,3942,1982,5117,563,3332,2623,9482,4994,8163,9112,5236,5029,5483,4542,1474,991,3925,4166,3362,5059,5857,4663,6482,3008,3616,4365,3634,270,1118,8291,4990,1413,273,107,1976,9957,9083,7810,4952,7246,3275,6540,2275,8758,7434,3750,6101,1359,4268,5815,2771,126,478,9253,9486,446,3618,3120,7068,1089,1411,2058,2502,8037,2165,830,7994,1248,4993,9298,4846,8268,2191,3474,3378,9625,7224,9479,985,1492,1646,3756,7970,8476,3009,7457,8922,2980,577,2342,4069,8341,4400,2923,2730,2917,105,724,518,5098,6375,5364,3366,8566,8838,3096,8191,2414,2575,5528,259,573,5636,4581,9049,4998,2038,4323,7978,8968,6665,8399,7309,7417,1322,6391,335,1427,7115,853,2878,9842,2569,2596,4760,7760,5693,9304,6526,8268,4832,6785,5194,6821,1367,4243,1819,9757,4919,6149,8725,7936,4548,2386,5354,2222,8777,2041,1,2245,9246,2879,8439,1815,5476,3200,5927,7521,2504,2454,5789,3688,9239,7335,6861,6958,7931,8680,3068,2850,1181,1793,7138,2081,532,2492,4303,5661,885,657,4258,131,9888,9050,1947,1716,2250,4226,9237,1106,6680,1379,1146,2272,8714,8008,9230,6645,3040,2298,5847,4222,444,2986,2655,7328,1830,6959,9341,2716,3968,9952,2847,3856,9002,1146,5573,1252,5373,1162,8710,2053,2541,9856,677,1256,4216,9908,4253,3609,8558,6453,4183,5354,9439,6838,2682,7621,149,8376,337,4117,8328,9537,4326,7330,683,9899,4934,2408,7413,9996,814,9955,9852,1491,7563,421,7751,1816,4030,2662,8269,8213,8016,4060,5051,7051,1682,5201,5427,8371,5670,3755,7908,9996,7437,4944,9895,2371,7352,3661,2367,4518,3616,8571,6010,1179,5344,113,9347,9374,2775,3969,3939,792,4381,8991,7843,2415,544,3270,787,6214,3377,8695,6211,814,9991,2458,9537,7344,6119,1904,8214,6087,6827,4224,7266,2172,690,2966,7898,3465,3287,1838,609,7668,829,8452,84,7725,8074,871,3939,7803,5918,6502,4969,5910,5313,4506,9606,1432,2762,7820,3872,9590,8397,1138,8114,9087,456,6012,8904,3743,7850,9514,7764,5031,4318,7848,9108,8745,5071,9400,2900,7341,5902,7870,3251,7567,2376,9209,9000,1491,7030,2872,7433,1779,362,5547,7218,7171,7911,2474,914,2114,8340,8678,3497,2659,2878,2606,7756,7949,2006,656,5291,4260,8526,4894,1828,7255,456,7180,8746,3838,6404,6179,5617,3118,8078,9187,289,5989,1661,1204,8103,2,6234,7953,9013,5465,559,6769,9766,2565,7425,1409,3177,2304,6304,5005,9559,6760,2185,4657,598,8589,836,2567,1708,5266,1754,8349,1255,9767,5905,5711,9769,8492,3664,5134,3957,575,1903,3723,3140,5681,5133,6317,4337,7789,7675,3896,4549,6212,8553,1499,1154,5741,418,9214,1007,2172,7563,8614,8291,3469,677,4413,1961,4341,9547,5918,4916,7803,9641,4408,3484,1126,7078,7821,8915,1105,8069,9816,7317,2974,1315,8471,8715,1733,7685,6074,257,5249,4688,8549,5070,5366,2962,7031,6059,8861,9301,7328,6664,5294,8088,6500,6421,1518,4321,5336,2623,8742,1505,9941,1716,2820,4764,6783,906,2450,2857,7515,4051,7546,2416,9121,9264,1730,6152,1675,592,1805,9003,7256,7099,3444,3757,9872,4962,4430,1561,7586,3173,3066,3879,1241,2238,8643,8025,3144,7445,882,7012,1496,4780,9428,617,396,1159,3121,2072,1751,4926,7427,5359,8378,871,5468,8250,5834,9899,9811,9772,9424,2877,3651,7017,5116,8646,5042,4612,6092,2277,1624,7588,3409,1053,8206,3806,8564,7679,2230,6667,8958,6009,2026,7336,6881,3847,5586,9067,98,1750,8839,9522,4627,8842,2891,6095,7488,7934,708,3580,6563,8684,7521,9972,6089,2079,130,4653,9758,2360,1320,8716,8370,9699,6052,1603,3546,7991,670,3644,6093,9509,9518,7072,4703,2409,3168,2191,6695,228,2124,3258,5264,9645,9583,1354,1724,9713,2359,1482,8426,3680,6551,3148,9731,8955,4751,9629,6946,5421,9625,9391,1282,5495,6464,5985,4256,5984,4528,952,6212,6652,562,1476,6297,145,9182,8021,6211,1542,5856,4637,1574,2407,7785,1305,1362,2536,934,4661,4309,559,4052,1943,2406,516,4280,6662,2852,8808,7614,9064,1813,4529,6893,8110,4674,2427,2484,7237,3969,8340,1874,5543,7099,6011,3200,8461,8547,486,9474,9208,7397,9879,7503,9803,6747,1783,6466,9600,6944,432,8664,8757,4961,1909,6867,5988,4337,5703,3225,4658,4043,1452,6554,1142,7463,9754,5956,2363,241,1782,7923,7638,1661,5427,3794,8409,7210,260,8009,4154,692,3025,9263,2006,4935,2483,7994,5624,8186,7571,282,8582,9023,6836,6076,6487,6591,2032,8850,3184,3815,3125,7174,5476,8552,968,3885,2115,7580,8246,2621,4625,1272,1885,6631,6207,4368,4625,8183,2554,8548,8465,1136,7572,1654,7213,411,4597,5597,5613,7781,5764,8738,1307,7593,7291,8628,7830,9406,6208,6077,2027,833,7349,3912,7464,9908,4632,8441,8091,7187,6990,2908,4675,914,4562,8240,1325,9159,190,6938,3292,5954,2028,4600,9899,9319,3228,7730,5077,9436,159,7105,6622,7508,7369,4086,3768,2002,8880,8211,5541,2222,1119,216,3136,5682,4809,813,1193,4999,4103,4486,7305,6131,9086,7205,5451,2314,1287,528,8102,1446,3985,4724,5306,1355,5163,9074,9709,4043,7285,5250,2617,4756,1818,2105,6790,6627,2918,7984,7978,7021,2470,1636,3152,7908,8841,4955,222,6480,5484,4676,7926,5821,9401,3232,7176,916,8658,3237,1311,5943,8487,3928,7051,306,6033,3842,3285,8951,1826,7616,2324,648,9252,5476,8556,4445,6784]"
                    },
                    {
                        "username": "Raju10",
                        "content": "[1, 2, 4, 2, 5, 7, 2, 4, 9, 0]\\ncan anyone tell how the expected output is 13 for the above test case input,\\ni think its 12, isn\\'t it??"
                    },
                    {
                        "username": "itaisir",
                        "content": "buy on day 1(1) and sell on day 6(7) => profit = 6\\nbuy on day 7(2) and sell on day 9(9) => profit = 7\\ntotal profit = 6 + 7 = 13"
                    },
                    {
                        "username": "anwendeng",
                        "content": "you should buy on day 1 (price=1) and sell on day 6(price=7), profit=7-1=6"
                    },
                    {
                        "username": "engineerNewYork",
                        "content": "You buy when the price is 1 and sell when the price 7 where your profit is 6. The next time, you buy when the price is 2 and then sell it when it increases to 9 with which you make a profit of 7. In total, you get 13. "
                    },
                    {
                        "username": "tibi01993",
                        "content": "Hi everyone,\\nCan anyone help to explain why this testcase return 13? \\n[1,2,4,2,5,7,2,4,9,0]\\nAs I have profits :\\n4 - 1 = 3\\n7 - 2 = 5 \\n9 - 2 = 7\\n-> MaxProfit with 2 transactions: 5 + 7 = 12"
                    },
                    {
                        "username": "itaisir",
                        "content": "buy on day 1(1) and sell on day 6(7) => profit = 6\\nbuy on day 7(2) and sell on day 9(9) => profit = 7\\ntotal profit = 6 + 7 = 13"
                    },
                    {
                        "username": "anwendeng",
                        "content": "you should buy on day 1 (price=1) and sell on day 6(price=7), profit=7-1=6\\n"
                    },
                    {
                        "username": "arqb",
                        "content": "[@Jim](/tibi01993) and [@Saptarshi123123](/Saptarshi123123) the 2 biggest transactions are : \n9-2 = 7\n7-1 = 6\n => 7+6 = 13"
                    },
                    {
                        "username": "Saptarshi123123",
                        "content": "yes same problem!\\n"
                    },
                    {
                        "username": "wibotwi",
                        "content": "The problem for me was in understanding other guys -> because they name variables in strange way. When they say \\'sell2\\' they actually mean \\'totalProfitAfterSecondSell\\'. After I realized that -> I understood the solution.\\n\\nLet\\'s assume task was: Buy stocks on one day only. (pay attention: no sell at all!)\\nThe solution would be: find minimum of a function \\'totalProfitAfterFirstBuy\\'.\\nWhich is just go through all days and search for minimum of \\'- currPrice\\'. (cause buying stock makes our profit negative, we had \"0\"$ and now we have \"-X\"$).\\n\\nLet\\'s add second operation. The one day buy/sell solution : find minimum of a function \\'totalProfitAfterSecondSellAfterFirstBuy\\'.\\nWe will continue minimizing \\'totalProfitAfterFirstBuy\\'. But at the same time we will be minimizing \\'totalProfitAfterSecondSellAfterFirstBuy = totalProfitAfterFirstBuy + currPrice\\'. (selling gives us positive, we earn money).\\n\\nNow this solution can be applied to any number of operations. Say we were asked to minimize operations: \"Buy, Buy, Buy, Sell, Sell\".\\nTo solve it we will be minimizing profits after each op: [profitAfterOp1, profitAfterOp2, profitAfterOp3, ...].\\n\\nHope this will make it clear for everybody!\\n\\n"
                    },
                    {
                        "username": "aditichoudhary",
                        "content": "[1,2,4,2,5,7,2,4,9,0] for this input how the expected output is 13......as sets of peak valley are(V-1 P-4, V-2 P-7,V-2 P-9)  maxprofit will be =(7-2)+(9-2)"
                    },
                    {
                        "username": "ABoyNamedCrow",
                        "content": "Does it mean you can buy once and sell once, or does it mean you can buy twice and sell twice?\\n\\nNaively it seems clear the meaning should be buy once and sell once, but looking at the test cases, the other meaning seems to be what the autograder wants. Really poorly worded."
                    },
                    {
                        "username": "zhnzhang61",
                        "content": "For some of the test cases, how can a stock be priced at 0????????\\n[2,1,2,0,1]"
                    },
                    {
                        "username": "belwalrohan",
                        "content": "https://github.com/belwalrohan/August-Leetcode-Challenge/blob/master/16thAug.cpp"
                    },
                    {
                        "username": "mls__",
                        "content": "**Example 2:**\\n`Buy on day 1 (price = 1)` and at same time `Note that you cannot buy on day 1`.\\nI\\'m confused. \\n\\n\\n"
                    },
                    {
                        "username": "krishnakumar780800",
                        "content": "for the arr [1,2,3,4,5] here we buy om 1st day and sell on 5th day so profit=4 ans buy on 2nd day and sell on 4th day so profit is 2 so total profit will be 4+2=6"
                    },
                    {
                        "username": "rawbeholder",
                        "content": "You must sell the stock before buying again , so you cannot buy the stock on the 2nd day since one stock is already purchased. You need to sell the stock before buying agian."
                    }
                ]
            },
            {
                "id": 1572884,
                "content": [
                    {
                        "username": "Ankit5ingh",
                        "content": "TLE test case \\n[397,6621,4997,7506,8918,1662,9187,3278,3890,514,18,9305,93,5508,3031,2692,6019,1134,1691,4949,5071,799,8953,7882,4273,302,6753,4657,8368,3942,1982,5117,563,3332,2623,9482,4994,8163,9112,5236,5029,5483,4542,1474,991,3925,4166,3362,5059,5857,4663,6482,3008,3616,4365,3634,270,1118,8291,4990,1413,273,107,1976,9957,9083,7810,4952,7246,3275,6540,2275,8758,7434,3750,6101,1359,4268,5815,2771,126,478,9253,9486,446,3618,3120,7068,1089,1411,2058,2502,8037,2165,830,7994,1248,4993,9298,4846,8268,2191,3474,3378,9625,7224,9479,985,1492,1646,3756,7970,8476,3009,7457,8922,2980,577,2342,4069,8341,4400,2923,2730,2917,105,724,518,5098,6375,5364,3366,8566,8838,3096,8191,2414,2575,5528,259,573,5636,4581,9049,4998,2038,4323,7978,8968,6665,8399,7309,7417,1322,6391,335,1427,7115,853,2878,9842,2569,2596,4760,7760,5693,9304,6526,8268,4832,6785,5194,6821,1367,4243,1819,9757,4919,6149,8725,7936,4548,2386,5354,2222,8777,2041,1,2245,9246,2879,8439,1815,5476,3200,5927,7521,2504,2454,5789,3688,9239,7335,6861,6958,7931,8680,3068,2850,1181,1793,7138,2081,532,2492,4303,5661,885,657,4258,131,9888,9050,1947,1716,2250,4226,9237,1106,6680,1379,1146,2272,8714,8008,9230,6645,3040,2298,5847,4222,444,2986,2655,7328,1830,6959,9341,2716,3968,9952,2847,3856,9002,1146,5573,1252,5373,1162,8710,2053,2541,9856,677,1256,4216,9908,4253,3609,8558,6453,4183,5354,9439,6838,2682,7621,149,8376,337,4117,8328,9537,4326,7330,683,9899,4934,2408,7413,9996,814,9955,9852,1491,7563,421,7751,1816,4030,2662,8269,8213,8016,4060,5051,7051,1682,5201,5427,8371,5670,3755,7908,9996,7437,4944,9895,2371,7352,3661,2367,4518,3616,8571,6010,1179,5344,113,9347,9374,2775,3969,3939,792,4381,8991,7843,2415,544,3270,787,6214,3377,8695,6211,814,9991,2458,9537,7344,6119,1904,8214,6087,6827,4224,7266,2172,690,2966,7898,3465,3287,1838,609,7668,829,8452,84,7725,8074,871,3939,7803,5918,6502,4969,5910,5313,4506,9606,1432,2762,7820,3872,9590,8397,1138,8114,9087,456,6012,8904,3743,7850,9514,7764,5031,4318,7848,9108,8745,5071,9400,2900,7341,5902,7870,3251,7567,2376,9209,9000,1491,7030,2872,7433,1779,362,5547,7218,7171,7911,2474,914,2114,8340,8678,3497,2659,2878,2606,7756,7949,2006,656,5291,4260,8526,4894,1828,7255,456,7180,8746,3838,6404,6179,5617,3118,8078,9187,289,5989,1661,1204,8103,2,6234,7953,9013,5465,559,6769,9766,2565,7425,1409,3177,2304,6304,5005,9559,6760,2185,4657,598,8589,836,2567,1708,5266,1754,8349,1255,9767,5905,5711,9769,8492,3664,5134,3957,575,1903,3723,3140,5681,5133,6317,4337,7789,7675,3896,4549,6212,8553,1499,1154,5741,418,9214,1007,2172,7563,8614,8291,3469,677,4413,1961,4341,9547,5918,4916,7803,9641,4408,3484,1126,7078,7821,8915,1105,8069,9816,7317,2974,1315,8471,8715,1733,7685,6074,257,5249,4688,8549,5070,5366,2962,7031,6059,8861,9301,7328,6664,5294,8088,6500,6421,1518,4321,5336,2623,8742,1505,9941,1716,2820,4764,6783,906,2450,2857,7515,4051,7546,2416,9121,9264,1730,6152,1675,592,1805,9003,7256,7099,3444,3757,9872,4962,4430,1561,7586,3173,3066,3879,1241,2238,8643,8025,3144,7445,882,7012,1496,4780,9428,617,396,1159,3121,2072,1751,4926,7427,5359,8378,871,5468,8250,5834,9899,9811,9772,9424,2877,3651,7017,5116,8646,5042,4612,6092,2277,1624,7588,3409,1053,8206,3806,8564,7679,2230,6667,8958,6009,2026,7336,6881,3847,5586,9067,98,1750,8839,9522,4627,8842,2891,6095,7488,7934,708,3580,6563,8684,7521,9972,6089,2079,130,4653,9758,2360,1320,8716,8370,9699,6052,1603,3546,7991,670,3644,6093,9509,9518,7072,4703,2409,3168,2191,6695,228,2124,3258,5264,9645,9583,1354,1724,9713,2359,1482,8426,3680,6551,3148,9731,8955,4751,9629,6946,5421,9625,9391,1282,5495,6464,5985,4256,5984,4528,952,6212,6652,562,1476,6297,145,9182,8021,6211,1542,5856,4637,1574,2407,7785,1305,1362,2536,934,4661,4309,559,4052,1943,2406,516,4280,6662,2852,8808,7614,9064,1813,4529,6893,8110,4674,2427,2484,7237,3969,8340,1874,5543,7099,6011,3200,8461,8547,486,9474,9208,7397,9879,7503,9803,6747,1783,6466,9600,6944,432,8664,8757,4961,1909,6867,5988,4337,5703,3225,4658,4043,1452,6554,1142,7463,9754,5956,2363,241,1782,7923,7638,1661,5427,3794,8409,7210,260,8009,4154,692,3025,9263,2006,4935,2483,7994,5624,8186,7571,282,8582,9023,6836,6076,6487,6591,2032,8850,3184,3815,3125,7174,5476,8552,968,3885,2115,7580,8246,2621,4625,1272,1885,6631,6207,4368,4625,8183,2554,8548,8465,1136,7572,1654,7213,411,4597,5597,5613,7781,5764,8738,1307,7593,7291,8628,7830,9406,6208,6077,2027,833,7349,3912,7464,9908,4632,8441,8091,7187,6990,2908,4675,914,4562,8240,1325,9159,190,6938,3292,5954,2028,4600,9899,9319,3228,7730,5077,9436,159,7105,6622,7508,7369,4086,3768,2002,8880,8211,5541,2222,1119,216,3136,5682,4809,813,1193,4999,4103,4486,7305,6131,9086,7205,5451,2314,1287,528,8102,1446,3985,4724,5306,1355,5163,9074,9709,4043,7285,5250,2617,4756,1818,2105,6790,6627,2918,7984,7978,7021,2470,1636,3152,7908,8841,4955,222,6480,5484,4676,7926,5821,9401,3232,7176,916,8658,3237,1311,5943,8487,3928,7051,306,6033,3842,3285,8951,1826,7616,2324,648,9252,5476,8556,4445,6784]"
                    },
                    {
                        "username": "Raju10",
                        "content": "[1, 2, 4, 2, 5, 7, 2, 4, 9, 0]\\ncan anyone tell how the expected output is 13 for the above test case input,\\ni think its 12, isn\\'t it??"
                    },
                    {
                        "username": "itaisir",
                        "content": "buy on day 1(1) and sell on day 6(7) => profit = 6\\nbuy on day 7(2) and sell on day 9(9) => profit = 7\\ntotal profit = 6 + 7 = 13"
                    },
                    {
                        "username": "anwendeng",
                        "content": "you should buy on day 1 (price=1) and sell on day 6(price=7), profit=7-1=6"
                    },
                    {
                        "username": "engineerNewYork",
                        "content": "You buy when the price is 1 and sell when the price 7 where your profit is 6. The next time, you buy when the price is 2 and then sell it when it increases to 9 with which you make a profit of 7. In total, you get 13. "
                    },
                    {
                        "username": "tibi01993",
                        "content": "Hi everyone,\\nCan anyone help to explain why this testcase return 13? \\n[1,2,4,2,5,7,2,4,9,0]\\nAs I have profits :\\n4 - 1 = 3\\n7 - 2 = 5 \\n9 - 2 = 7\\n-> MaxProfit with 2 transactions: 5 + 7 = 12"
                    },
                    {
                        "username": "itaisir",
                        "content": "buy on day 1(1) and sell on day 6(7) => profit = 6\\nbuy on day 7(2) and sell on day 9(9) => profit = 7\\ntotal profit = 6 + 7 = 13"
                    },
                    {
                        "username": "anwendeng",
                        "content": "you should buy on day 1 (price=1) and sell on day 6(price=7), profit=7-1=6\\n"
                    },
                    {
                        "username": "arqb",
                        "content": "[@Jim](/tibi01993) and [@Saptarshi123123](/Saptarshi123123) the 2 biggest transactions are : \n9-2 = 7\n7-1 = 6\n => 7+6 = 13"
                    },
                    {
                        "username": "Saptarshi123123",
                        "content": "yes same problem!\\n"
                    },
                    {
                        "username": "wibotwi",
                        "content": "The problem for me was in understanding other guys -> because they name variables in strange way. When they say \\'sell2\\' they actually mean \\'totalProfitAfterSecondSell\\'. After I realized that -> I understood the solution.\\n\\nLet\\'s assume task was: Buy stocks on one day only. (pay attention: no sell at all!)\\nThe solution would be: find minimum of a function \\'totalProfitAfterFirstBuy\\'.\\nWhich is just go through all days and search for minimum of \\'- currPrice\\'. (cause buying stock makes our profit negative, we had \"0\"$ and now we have \"-X\"$).\\n\\nLet\\'s add second operation. The one day buy/sell solution : find minimum of a function \\'totalProfitAfterSecondSellAfterFirstBuy\\'.\\nWe will continue minimizing \\'totalProfitAfterFirstBuy\\'. But at the same time we will be minimizing \\'totalProfitAfterSecondSellAfterFirstBuy = totalProfitAfterFirstBuy + currPrice\\'. (selling gives us positive, we earn money).\\n\\nNow this solution can be applied to any number of operations. Say we were asked to minimize operations: \"Buy, Buy, Buy, Sell, Sell\".\\nTo solve it we will be minimizing profits after each op: [profitAfterOp1, profitAfterOp2, profitAfterOp3, ...].\\n\\nHope this will make it clear for everybody!\\n\\n"
                    },
                    {
                        "username": "aditichoudhary",
                        "content": "[1,2,4,2,5,7,2,4,9,0] for this input how the expected output is 13......as sets of peak valley are(V-1 P-4, V-2 P-7,V-2 P-9)  maxprofit will be =(7-2)+(9-2)"
                    },
                    {
                        "username": "ABoyNamedCrow",
                        "content": "Does it mean you can buy once and sell once, or does it mean you can buy twice and sell twice?\\n\\nNaively it seems clear the meaning should be buy once and sell once, but looking at the test cases, the other meaning seems to be what the autograder wants. Really poorly worded."
                    },
                    {
                        "username": "zhnzhang61",
                        "content": "For some of the test cases, how can a stock be priced at 0????????\\n[2,1,2,0,1]"
                    },
                    {
                        "username": "belwalrohan",
                        "content": "https://github.com/belwalrohan/August-Leetcode-Challenge/blob/master/16thAug.cpp"
                    },
                    {
                        "username": "mls__",
                        "content": "**Example 2:**\\n`Buy on day 1 (price = 1)` and at same time `Note that you cannot buy on day 1`.\\nI\\'m confused. \\n\\n\\n"
                    },
                    {
                        "username": "krishnakumar780800",
                        "content": "for the arr [1,2,3,4,5] here we buy om 1st day and sell on 5th day so profit=4 ans buy on 2nd day and sell on 4th day so profit is 2 so total profit will be 4+2=6"
                    },
                    {
                        "username": "rawbeholder",
                        "content": "You must sell the stock before buying again , so you cannot buy the stock on the 2nd day since one stock is already purchased. You need to sell the stock before buying agian."
                    }
                ]
            },
            {
                "id": 1572807,
                "content": [
                    {
                        "username": "Ankit5ingh",
                        "content": "TLE test case \\n[397,6621,4997,7506,8918,1662,9187,3278,3890,514,18,9305,93,5508,3031,2692,6019,1134,1691,4949,5071,799,8953,7882,4273,302,6753,4657,8368,3942,1982,5117,563,3332,2623,9482,4994,8163,9112,5236,5029,5483,4542,1474,991,3925,4166,3362,5059,5857,4663,6482,3008,3616,4365,3634,270,1118,8291,4990,1413,273,107,1976,9957,9083,7810,4952,7246,3275,6540,2275,8758,7434,3750,6101,1359,4268,5815,2771,126,478,9253,9486,446,3618,3120,7068,1089,1411,2058,2502,8037,2165,830,7994,1248,4993,9298,4846,8268,2191,3474,3378,9625,7224,9479,985,1492,1646,3756,7970,8476,3009,7457,8922,2980,577,2342,4069,8341,4400,2923,2730,2917,105,724,518,5098,6375,5364,3366,8566,8838,3096,8191,2414,2575,5528,259,573,5636,4581,9049,4998,2038,4323,7978,8968,6665,8399,7309,7417,1322,6391,335,1427,7115,853,2878,9842,2569,2596,4760,7760,5693,9304,6526,8268,4832,6785,5194,6821,1367,4243,1819,9757,4919,6149,8725,7936,4548,2386,5354,2222,8777,2041,1,2245,9246,2879,8439,1815,5476,3200,5927,7521,2504,2454,5789,3688,9239,7335,6861,6958,7931,8680,3068,2850,1181,1793,7138,2081,532,2492,4303,5661,885,657,4258,131,9888,9050,1947,1716,2250,4226,9237,1106,6680,1379,1146,2272,8714,8008,9230,6645,3040,2298,5847,4222,444,2986,2655,7328,1830,6959,9341,2716,3968,9952,2847,3856,9002,1146,5573,1252,5373,1162,8710,2053,2541,9856,677,1256,4216,9908,4253,3609,8558,6453,4183,5354,9439,6838,2682,7621,149,8376,337,4117,8328,9537,4326,7330,683,9899,4934,2408,7413,9996,814,9955,9852,1491,7563,421,7751,1816,4030,2662,8269,8213,8016,4060,5051,7051,1682,5201,5427,8371,5670,3755,7908,9996,7437,4944,9895,2371,7352,3661,2367,4518,3616,8571,6010,1179,5344,113,9347,9374,2775,3969,3939,792,4381,8991,7843,2415,544,3270,787,6214,3377,8695,6211,814,9991,2458,9537,7344,6119,1904,8214,6087,6827,4224,7266,2172,690,2966,7898,3465,3287,1838,609,7668,829,8452,84,7725,8074,871,3939,7803,5918,6502,4969,5910,5313,4506,9606,1432,2762,7820,3872,9590,8397,1138,8114,9087,456,6012,8904,3743,7850,9514,7764,5031,4318,7848,9108,8745,5071,9400,2900,7341,5902,7870,3251,7567,2376,9209,9000,1491,7030,2872,7433,1779,362,5547,7218,7171,7911,2474,914,2114,8340,8678,3497,2659,2878,2606,7756,7949,2006,656,5291,4260,8526,4894,1828,7255,456,7180,8746,3838,6404,6179,5617,3118,8078,9187,289,5989,1661,1204,8103,2,6234,7953,9013,5465,559,6769,9766,2565,7425,1409,3177,2304,6304,5005,9559,6760,2185,4657,598,8589,836,2567,1708,5266,1754,8349,1255,9767,5905,5711,9769,8492,3664,5134,3957,575,1903,3723,3140,5681,5133,6317,4337,7789,7675,3896,4549,6212,8553,1499,1154,5741,418,9214,1007,2172,7563,8614,8291,3469,677,4413,1961,4341,9547,5918,4916,7803,9641,4408,3484,1126,7078,7821,8915,1105,8069,9816,7317,2974,1315,8471,8715,1733,7685,6074,257,5249,4688,8549,5070,5366,2962,7031,6059,8861,9301,7328,6664,5294,8088,6500,6421,1518,4321,5336,2623,8742,1505,9941,1716,2820,4764,6783,906,2450,2857,7515,4051,7546,2416,9121,9264,1730,6152,1675,592,1805,9003,7256,7099,3444,3757,9872,4962,4430,1561,7586,3173,3066,3879,1241,2238,8643,8025,3144,7445,882,7012,1496,4780,9428,617,396,1159,3121,2072,1751,4926,7427,5359,8378,871,5468,8250,5834,9899,9811,9772,9424,2877,3651,7017,5116,8646,5042,4612,6092,2277,1624,7588,3409,1053,8206,3806,8564,7679,2230,6667,8958,6009,2026,7336,6881,3847,5586,9067,98,1750,8839,9522,4627,8842,2891,6095,7488,7934,708,3580,6563,8684,7521,9972,6089,2079,130,4653,9758,2360,1320,8716,8370,9699,6052,1603,3546,7991,670,3644,6093,9509,9518,7072,4703,2409,3168,2191,6695,228,2124,3258,5264,9645,9583,1354,1724,9713,2359,1482,8426,3680,6551,3148,9731,8955,4751,9629,6946,5421,9625,9391,1282,5495,6464,5985,4256,5984,4528,952,6212,6652,562,1476,6297,145,9182,8021,6211,1542,5856,4637,1574,2407,7785,1305,1362,2536,934,4661,4309,559,4052,1943,2406,516,4280,6662,2852,8808,7614,9064,1813,4529,6893,8110,4674,2427,2484,7237,3969,8340,1874,5543,7099,6011,3200,8461,8547,486,9474,9208,7397,9879,7503,9803,6747,1783,6466,9600,6944,432,8664,8757,4961,1909,6867,5988,4337,5703,3225,4658,4043,1452,6554,1142,7463,9754,5956,2363,241,1782,7923,7638,1661,5427,3794,8409,7210,260,8009,4154,692,3025,9263,2006,4935,2483,7994,5624,8186,7571,282,8582,9023,6836,6076,6487,6591,2032,8850,3184,3815,3125,7174,5476,8552,968,3885,2115,7580,8246,2621,4625,1272,1885,6631,6207,4368,4625,8183,2554,8548,8465,1136,7572,1654,7213,411,4597,5597,5613,7781,5764,8738,1307,7593,7291,8628,7830,9406,6208,6077,2027,833,7349,3912,7464,9908,4632,8441,8091,7187,6990,2908,4675,914,4562,8240,1325,9159,190,6938,3292,5954,2028,4600,9899,9319,3228,7730,5077,9436,159,7105,6622,7508,7369,4086,3768,2002,8880,8211,5541,2222,1119,216,3136,5682,4809,813,1193,4999,4103,4486,7305,6131,9086,7205,5451,2314,1287,528,8102,1446,3985,4724,5306,1355,5163,9074,9709,4043,7285,5250,2617,4756,1818,2105,6790,6627,2918,7984,7978,7021,2470,1636,3152,7908,8841,4955,222,6480,5484,4676,7926,5821,9401,3232,7176,916,8658,3237,1311,5943,8487,3928,7051,306,6033,3842,3285,8951,1826,7616,2324,648,9252,5476,8556,4445,6784]"
                    },
                    {
                        "username": "Raju10",
                        "content": "[1, 2, 4, 2, 5, 7, 2, 4, 9, 0]\\ncan anyone tell how the expected output is 13 for the above test case input,\\ni think its 12, isn\\'t it??"
                    },
                    {
                        "username": "itaisir",
                        "content": "buy on day 1(1) and sell on day 6(7) => profit = 6\\nbuy on day 7(2) and sell on day 9(9) => profit = 7\\ntotal profit = 6 + 7 = 13"
                    },
                    {
                        "username": "anwendeng",
                        "content": "you should buy on day 1 (price=1) and sell on day 6(price=7), profit=7-1=6"
                    },
                    {
                        "username": "engineerNewYork",
                        "content": "You buy when the price is 1 and sell when the price 7 where your profit is 6. The next time, you buy when the price is 2 and then sell it when it increases to 9 with which you make a profit of 7. In total, you get 13. "
                    },
                    {
                        "username": "tibi01993",
                        "content": "Hi everyone,\\nCan anyone help to explain why this testcase return 13? \\n[1,2,4,2,5,7,2,4,9,0]\\nAs I have profits :\\n4 - 1 = 3\\n7 - 2 = 5 \\n9 - 2 = 7\\n-> MaxProfit with 2 transactions: 5 + 7 = 12"
                    },
                    {
                        "username": "itaisir",
                        "content": "buy on day 1(1) and sell on day 6(7) => profit = 6\\nbuy on day 7(2) and sell on day 9(9) => profit = 7\\ntotal profit = 6 + 7 = 13"
                    },
                    {
                        "username": "anwendeng",
                        "content": "you should buy on day 1 (price=1) and sell on day 6(price=7), profit=7-1=6\\n"
                    },
                    {
                        "username": "arqb",
                        "content": "[@Jim](/tibi01993) and [@Saptarshi123123](/Saptarshi123123) the 2 biggest transactions are : \n9-2 = 7\n7-1 = 6\n => 7+6 = 13"
                    },
                    {
                        "username": "Saptarshi123123",
                        "content": "yes same problem!\\n"
                    },
                    {
                        "username": "wibotwi",
                        "content": "The problem for me was in understanding other guys -> because they name variables in strange way. When they say \\'sell2\\' they actually mean \\'totalProfitAfterSecondSell\\'. After I realized that -> I understood the solution.\\n\\nLet\\'s assume task was: Buy stocks on one day only. (pay attention: no sell at all!)\\nThe solution would be: find minimum of a function \\'totalProfitAfterFirstBuy\\'.\\nWhich is just go through all days and search for minimum of \\'- currPrice\\'. (cause buying stock makes our profit negative, we had \"0\"$ and now we have \"-X\"$).\\n\\nLet\\'s add second operation. The one day buy/sell solution : find minimum of a function \\'totalProfitAfterSecondSellAfterFirstBuy\\'.\\nWe will continue minimizing \\'totalProfitAfterFirstBuy\\'. But at the same time we will be minimizing \\'totalProfitAfterSecondSellAfterFirstBuy = totalProfitAfterFirstBuy + currPrice\\'. (selling gives us positive, we earn money).\\n\\nNow this solution can be applied to any number of operations. Say we were asked to minimize operations: \"Buy, Buy, Buy, Sell, Sell\".\\nTo solve it we will be minimizing profits after each op: [profitAfterOp1, profitAfterOp2, profitAfterOp3, ...].\\n\\nHope this will make it clear for everybody!\\n\\n"
                    },
                    {
                        "username": "aditichoudhary",
                        "content": "[1,2,4,2,5,7,2,4,9,0] for this input how the expected output is 13......as sets of peak valley are(V-1 P-4, V-2 P-7,V-2 P-9)  maxprofit will be =(7-2)+(9-2)"
                    },
                    {
                        "username": "ABoyNamedCrow",
                        "content": "Does it mean you can buy once and sell once, or does it mean you can buy twice and sell twice?\\n\\nNaively it seems clear the meaning should be buy once and sell once, but looking at the test cases, the other meaning seems to be what the autograder wants. Really poorly worded."
                    },
                    {
                        "username": "zhnzhang61",
                        "content": "For some of the test cases, how can a stock be priced at 0????????\\n[2,1,2,0,1]"
                    },
                    {
                        "username": "belwalrohan",
                        "content": "https://github.com/belwalrohan/August-Leetcode-Challenge/blob/master/16thAug.cpp"
                    },
                    {
                        "username": "mls__",
                        "content": "**Example 2:**\\n`Buy on day 1 (price = 1)` and at same time `Note that you cannot buy on day 1`.\\nI\\'m confused. \\n\\n\\n"
                    },
                    {
                        "username": "krishnakumar780800",
                        "content": "for the arr [1,2,3,4,5] here we buy om 1st day and sell on 5th day so profit=4 ans buy on 2nd day and sell on 4th day so profit is 2 so total profit will be 4+2=6"
                    },
                    {
                        "username": "rawbeholder",
                        "content": "You must sell the stock before buying again , so you cannot buy the stock on the 2nd day since one stock is already purchased. You need to sell the stock before buying agian."
                    }
                ]
            },
            {
                "id": 1572622,
                "content": [
                    {
                        "username": "Ankit5ingh",
                        "content": "TLE test case \\n[397,6621,4997,7506,8918,1662,9187,3278,3890,514,18,9305,93,5508,3031,2692,6019,1134,1691,4949,5071,799,8953,7882,4273,302,6753,4657,8368,3942,1982,5117,563,3332,2623,9482,4994,8163,9112,5236,5029,5483,4542,1474,991,3925,4166,3362,5059,5857,4663,6482,3008,3616,4365,3634,270,1118,8291,4990,1413,273,107,1976,9957,9083,7810,4952,7246,3275,6540,2275,8758,7434,3750,6101,1359,4268,5815,2771,126,478,9253,9486,446,3618,3120,7068,1089,1411,2058,2502,8037,2165,830,7994,1248,4993,9298,4846,8268,2191,3474,3378,9625,7224,9479,985,1492,1646,3756,7970,8476,3009,7457,8922,2980,577,2342,4069,8341,4400,2923,2730,2917,105,724,518,5098,6375,5364,3366,8566,8838,3096,8191,2414,2575,5528,259,573,5636,4581,9049,4998,2038,4323,7978,8968,6665,8399,7309,7417,1322,6391,335,1427,7115,853,2878,9842,2569,2596,4760,7760,5693,9304,6526,8268,4832,6785,5194,6821,1367,4243,1819,9757,4919,6149,8725,7936,4548,2386,5354,2222,8777,2041,1,2245,9246,2879,8439,1815,5476,3200,5927,7521,2504,2454,5789,3688,9239,7335,6861,6958,7931,8680,3068,2850,1181,1793,7138,2081,532,2492,4303,5661,885,657,4258,131,9888,9050,1947,1716,2250,4226,9237,1106,6680,1379,1146,2272,8714,8008,9230,6645,3040,2298,5847,4222,444,2986,2655,7328,1830,6959,9341,2716,3968,9952,2847,3856,9002,1146,5573,1252,5373,1162,8710,2053,2541,9856,677,1256,4216,9908,4253,3609,8558,6453,4183,5354,9439,6838,2682,7621,149,8376,337,4117,8328,9537,4326,7330,683,9899,4934,2408,7413,9996,814,9955,9852,1491,7563,421,7751,1816,4030,2662,8269,8213,8016,4060,5051,7051,1682,5201,5427,8371,5670,3755,7908,9996,7437,4944,9895,2371,7352,3661,2367,4518,3616,8571,6010,1179,5344,113,9347,9374,2775,3969,3939,792,4381,8991,7843,2415,544,3270,787,6214,3377,8695,6211,814,9991,2458,9537,7344,6119,1904,8214,6087,6827,4224,7266,2172,690,2966,7898,3465,3287,1838,609,7668,829,8452,84,7725,8074,871,3939,7803,5918,6502,4969,5910,5313,4506,9606,1432,2762,7820,3872,9590,8397,1138,8114,9087,456,6012,8904,3743,7850,9514,7764,5031,4318,7848,9108,8745,5071,9400,2900,7341,5902,7870,3251,7567,2376,9209,9000,1491,7030,2872,7433,1779,362,5547,7218,7171,7911,2474,914,2114,8340,8678,3497,2659,2878,2606,7756,7949,2006,656,5291,4260,8526,4894,1828,7255,456,7180,8746,3838,6404,6179,5617,3118,8078,9187,289,5989,1661,1204,8103,2,6234,7953,9013,5465,559,6769,9766,2565,7425,1409,3177,2304,6304,5005,9559,6760,2185,4657,598,8589,836,2567,1708,5266,1754,8349,1255,9767,5905,5711,9769,8492,3664,5134,3957,575,1903,3723,3140,5681,5133,6317,4337,7789,7675,3896,4549,6212,8553,1499,1154,5741,418,9214,1007,2172,7563,8614,8291,3469,677,4413,1961,4341,9547,5918,4916,7803,9641,4408,3484,1126,7078,7821,8915,1105,8069,9816,7317,2974,1315,8471,8715,1733,7685,6074,257,5249,4688,8549,5070,5366,2962,7031,6059,8861,9301,7328,6664,5294,8088,6500,6421,1518,4321,5336,2623,8742,1505,9941,1716,2820,4764,6783,906,2450,2857,7515,4051,7546,2416,9121,9264,1730,6152,1675,592,1805,9003,7256,7099,3444,3757,9872,4962,4430,1561,7586,3173,3066,3879,1241,2238,8643,8025,3144,7445,882,7012,1496,4780,9428,617,396,1159,3121,2072,1751,4926,7427,5359,8378,871,5468,8250,5834,9899,9811,9772,9424,2877,3651,7017,5116,8646,5042,4612,6092,2277,1624,7588,3409,1053,8206,3806,8564,7679,2230,6667,8958,6009,2026,7336,6881,3847,5586,9067,98,1750,8839,9522,4627,8842,2891,6095,7488,7934,708,3580,6563,8684,7521,9972,6089,2079,130,4653,9758,2360,1320,8716,8370,9699,6052,1603,3546,7991,670,3644,6093,9509,9518,7072,4703,2409,3168,2191,6695,228,2124,3258,5264,9645,9583,1354,1724,9713,2359,1482,8426,3680,6551,3148,9731,8955,4751,9629,6946,5421,9625,9391,1282,5495,6464,5985,4256,5984,4528,952,6212,6652,562,1476,6297,145,9182,8021,6211,1542,5856,4637,1574,2407,7785,1305,1362,2536,934,4661,4309,559,4052,1943,2406,516,4280,6662,2852,8808,7614,9064,1813,4529,6893,8110,4674,2427,2484,7237,3969,8340,1874,5543,7099,6011,3200,8461,8547,486,9474,9208,7397,9879,7503,9803,6747,1783,6466,9600,6944,432,8664,8757,4961,1909,6867,5988,4337,5703,3225,4658,4043,1452,6554,1142,7463,9754,5956,2363,241,1782,7923,7638,1661,5427,3794,8409,7210,260,8009,4154,692,3025,9263,2006,4935,2483,7994,5624,8186,7571,282,8582,9023,6836,6076,6487,6591,2032,8850,3184,3815,3125,7174,5476,8552,968,3885,2115,7580,8246,2621,4625,1272,1885,6631,6207,4368,4625,8183,2554,8548,8465,1136,7572,1654,7213,411,4597,5597,5613,7781,5764,8738,1307,7593,7291,8628,7830,9406,6208,6077,2027,833,7349,3912,7464,9908,4632,8441,8091,7187,6990,2908,4675,914,4562,8240,1325,9159,190,6938,3292,5954,2028,4600,9899,9319,3228,7730,5077,9436,159,7105,6622,7508,7369,4086,3768,2002,8880,8211,5541,2222,1119,216,3136,5682,4809,813,1193,4999,4103,4486,7305,6131,9086,7205,5451,2314,1287,528,8102,1446,3985,4724,5306,1355,5163,9074,9709,4043,7285,5250,2617,4756,1818,2105,6790,6627,2918,7984,7978,7021,2470,1636,3152,7908,8841,4955,222,6480,5484,4676,7926,5821,9401,3232,7176,916,8658,3237,1311,5943,8487,3928,7051,306,6033,3842,3285,8951,1826,7616,2324,648,9252,5476,8556,4445,6784]"
                    },
                    {
                        "username": "Raju10",
                        "content": "[1, 2, 4, 2, 5, 7, 2, 4, 9, 0]\\ncan anyone tell how the expected output is 13 for the above test case input,\\ni think its 12, isn\\'t it??"
                    },
                    {
                        "username": "itaisir",
                        "content": "buy on day 1(1) and sell on day 6(7) => profit = 6\\nbuy on day 7(2) and sell on day 9(9) => profit = 7\\ntotal profit = 6 + 7 = 13"
                    },
                    {
                        "username": "anwendeng",
                        "content": "you should buy on day 1 (price=1) and sell on day 6(price=7), profit=7-1=6"
                    },
                    {
                        "username": "engineerNewYork",
                        "content": "You buy when the price is 1 and sell when the price 7 where your profit is 6. The next time, you buy when the price is 2 and then sell it when it increases to 9 with which you make a profit of 7. In total, you get 13. "
                    },
                    {
                        "username": "tibi01993",
                        "content": "Hi everyone,\\nCan anyone help to explain why this testcase return 13? \\n[1,2,4,2,5,7,2,4,9,0]\\nAs I have profits :\\n4 - 1 = 3\\n7 - 2 = 5 \\n9 - 2 = 7\\n-> MaxProfit with 2 transactions: 5 + 7 = 12"
                    },
                    {
                        "username": "itaisir",
                        "content": "buy on day 1(1) and sell on day 6(7) => profit = 6\\nbuy on day 7(2) and sell on day 9(9) => profit = 7\\ntotal profit = 6 + 7 = 13"
                    },
                    {
                        "username": "anwendeng",
                        "content": "you should buy on day 1 (price=1) and sell on day 6(price=7), profit=7-1=6\\n"
                    },
                    {
                        "username": "arqb",
                        "content": "[@Jim](/tibi01993) and [@Saptarshi123123](/Saptarshi123123) the 2 biggest transactions are : \n9-2 = 7\n7-1 = 6\n => 7+6 = 13"
                    },
                    {
                        "username": "Saptarshi123123",
                        "content": "yes same problem!\\n"
                    },
                    {
                        "username": "wibotwi",
                        "content": "The problem for me was in understanding other guys -> because they name variables in strange way. When they say \\'sell2\\' they actually mean \\'totalProfitAfterSecondSell\\'. After I realized that -> I understood the solution.\\n\\nLet\\'s assume task was: Buy stocks on one day only. (pay attention: no sell at all!)\\nThe solution would be: find minimum of a function \\'totalProfitAfterFirstBuy\\'.\\nWhich is just go through all days and search for minimum of \\'- currPrice\\'. (cause buying stock makes our profit negative, we had \"0\"$ and now we have \"-X\"$).\\n\\nLet\\'s add second operation. The one day buy/sell solution : find minimum of a function \\'totalProfitAfterSecondSellAfterFirstBuy\\'.\\nWe will continue minimizing \\'totalProfitAfterFirstBuy\\'. But at the same time we will be minimizing \\'totalProfitAfterSecondSellAfterFirstBuy = totalProfitAfterFirstBuy + currPrice\\'. (selling gives us positive, we earn money).\\n\\nNow this solution can be applied to any number of operations. Say we were asked to minimize operations: \"Buy, Buy, Buy, Sell, Sell\".\\nTo solve it we will be minimizing profits after each op: [profitAfterOp1, profitAfterOp2, profitAfterOp3, ...].\\n\\nHope this will make it clear for everybody!\\n\\n"
                    },
                    {
                        "username": "aditichoudhary",
                        "content": "[1,2,4,2,5,7,2,4,9,0] for this input how the expected output is 13......as sets of peak valley are(V-1 P-4, V-2 P-7,V-2 P-9)  maxprofit will be =(7-2)+(9-2)"
                    },
                    {
                        "username": "ABoyNamedCrow",
                        "content": "Does it mean you can buy once and sell once, or does it mean you can buy twice and sell twice?\\n\\nNaively it seems clear the meaning should be buy once and sell once, but looking at the test cases, the other meaning seems to be what the autograder wants. Really poorly worded."
                    },
                    {
                        "username": "zhnzhang61",
                        "content": "For some of the test cases, how can a stock be priced at 0????????\\n[2,1,2,0,1]"
                    },
                    {
                        "username": "belwalrohan",
                        "content": "https://github.com/belwalrohan/August-Leetcode-Challenge/blob/master/16thAug.cpp"
                    },
                    {
                        "username": "mls__",
                        "content": "**Example 2:**\\n`Buy on day 1 (price = 1)` and at same time `Note that you cannot buy on day 1`.\\nI\\'m confused. \\n\\n\\n"
                    },
                    {
                        "username": "krishnakumar780800",
                        "content": "for the arr [1,2,3,4,5] here we buy om 1st day and sell on 5th day so profit=4 ans buy on 2nd day and sell on 4th day so profit is 2 so total profit will be 4+2=6"
                    },
                    {
                        "username": "rawbeholder",
                        "content": "You must sell the stock before buying again , so you cannot buy the stock on the 2nd day since one stock is already purchased. You need to sell the stock before buying agian."
                    }
                ]
            },
            {
                "id": 1571829,
                "content": [
                    {
                        "username": "Ankit5ingh",
                        "content": "TLE test case \\n[397,6621,4997,7506,8918,1662,9187,3278,3890,514,18,9305,93,5508,3031,2692,6019,1134,1691,4949,5071,799,8953,7882,4273,302,6753,4657,8368,3942,1982,5117,563,3332,2623,9482,4994,8163,9112,5236,5029,5483,4542,1474,991,3925,4166,3362,5059,5857,4663,6482,3008,3616,4365,3634,270,1118,8291,4990,1413,273,107,1976,9957,9083,7810,4952,7246,3275,6540,2275,8758,7434,3750,6101,1359,4268,5815,2771,126,478,9253,9486,446,3618,3120,7068,1089,1411,2058,2502,8037,2165,830,7994,1248,4993,9298,4846,8268,2191,3474,3378,9625,7224,9479,985,1492,1646,3756,7970,8476,3009,7457,8922,2980,577,2342,4069,8341,4400,2923,2730,2917,105,724,518,5098,6375,5364,3366,8566,8838,3096,8191,2414,2575,5528,259,573,5636,4581,9049,4998,2038,4323,7978,8968,6665,8399,7309,7417,1322,6391,335,1427,7115,853,2878,9842,2569,2596,4760,7760,5693,9304,6526,8268,4832,6785,5194,6821,1367,4243,1819,9757,4919,6149,8725,7936,4548,2386,5354,2222,8777,2041,1,2245,9246,2879,8439,1815,5476,3200,5927,7521,2504,2454,5789,3688,9239,7335,6861,6958,7931,8680,3068,2850,1181,1793,7138,2081,532,2492,4303,5661,885,657,4258,131,9888,9050,1947,1716,2250,4226,9237,1106,6680,1379,1146,2272,8714,8008,9230,6645,3040,2298,5847,4222,444,2986,2655,7328,1830,6959,9341,2716,3968,9952,2847,3856,9002,1146,5573,1252,5373,1162,8710,2053,2541,9856,677,1256,4216,9908,4253,3609,8558,6453,4183,5354,9439,6838,2682,7621,149,8376,337,4117,8328,9537,4326,7330,683,9899,4934,2408,7413,9996,814,9955,9852,1491,7563,421,7751,1816,4030,2662,8269,8213,8016,4060,5051,7051,1682,5201,5427,8371,5670,3755,7908,9996,7437,4944,9895,2371,7352,3661,2367,4518,3616,8571,6010,1179,5344,113,9347,9374,2775,3969,3939,792,4381,8991,7843,2415,544,3270,787,6214,3377,8695,6211,814,9991,2458,9537,7344,6119,1904,8214,6087,6827,4224,7266,2172,690,2966,7898,3465,3287,1838,609,7668,829,8452,84,7725,8074,871,3939,7803,5918,6502,4969,5910,5313,4506,9606,1432,2762,7820,3872,9590,8397,1138,8114,9087,456,6012,8904,3743,7850,9514,7764,5031,4318,7848,9108,8745,5071,9400,2900,7341,5902,7870,3251,7567,2376,9209,9000,1491,7030,2872,7433,1779,362,5547,7218,7171,7911,2474,914,2114,8340,8678,3497,2659,2878,2606,7756,7949,2006,656,5291,4260,8526,4894,1828,7255,456,7180,8746,3838,6404,6179,5617,3118,8078,9187,289,5989,1661,1204,8103,2,6234,7953,9013,5465,559,6769,9766,2565,7425,1409,3177,2304,6304,5005,9559,6760,2185,4657,598,8589,836,2567,1708,5266,1754,8349,1255,9767,5905,5711,9769,8492,3664,5134,3957,575,1903,3723,3140,5681,5133,6317,4337,7789,7675,3896,4549,6212,8553,1499,1154,5741,418,9214,1007,2172,7563,8614,8291,3469,677,4413,1961,4341,9547,5918,4916,7803,9641,4408,3484,1126,7078,7821,8915,1105,8069,9816,7317,2974,1315,8471,8715,1733,7685,6074,257,5249,4688,8549,5070,5366,2962,7031,6059,8861,9301,7328,6664,5294,8088,6500,6421,1518,4321,5336,2623,8742,1505,9941,1716,2820,4764,6783,906,2450,2857,7515,4051,7546,2416,9121,9264,1730,6152,1675,592,1805,9003,7256,7099,3444,3757,9872,4962,4430,1561,7586,3173,3066,3879,1241,2238,8643,8025,3144,7445,882,7012,1496,4780,9428,617,396,1159,3121,2072,1751,4926,7427,5359,8378,871,5468,8250,5834,9899,9811,9772,9424,2877,3651,7017,5116,8646,5042,4612,6092,2277,1624,7588,3409,1053,8206,3806,8564,7679,2230,6667,8958,6009,2026,7336,6881,3847,5586,9067,98,1750,8839,9522,4627,8842,2891,6095,7488,7934,708,3580,6563,8684,7521,9972,6089,2079,130,4653,9758,2360,1320,8716,8370,9699,6052,1603,3546,7991,670,3644,6093,9509,9518,7072,4703,2409,3168,2191,6695,228,2124,3258,5264,9645,9583,1354,1724,9713,2359,1482,8426,3680,6551,3148,9731,8955,4751,9629,6946,5421,9625,9391,1282,5495,6464,5985,4256,5984,4528,952,6212,6652,562,1476,6297,145,9182,8021,6211,1542,5856,4637,1574,2407,7785,1305,1362,2536,934,4661,4309,559,4052,1943,2406,516,4280,6662,2852,8808,7614,9064,1813,4529,6893,8110,4674,2427,2484,7237,3969,8340,1874,5543,7099,6011,3200,8461,8547,486,9474,9208,7397,9879,7503,9803,6747,1783,6466,9600,6944,432,8664,8757,4961,1909,6867,5988,4337,5703,3225,4658,4043,1452,6554,1142,7463,9754,5956,2363,241,1782,7923,7638,1661,5427,3794,8409,7210,260,8009,4154,692,3025,9263,2006,4935,2483,7994,5624,8186,7571,282,8582,9023,6836,6076,6487,6591,2032,8850,3184,3815,3125,7174,5476,8552,968,3885,2115,7580,8246,2621,4625,1272,1885,6631,6207,4368,4625,8183,2554,8548,8465,1136,7572,1654,7213,411,4597,5597,5613,7781,5764,8738,1307,7593,7291,8628,7830,9406,6208,6077,2027,833,7349,3912,7464,9908,4632,8441,8091,7187,6990,2908,4675,914,4562,8240,1325,9159,190,6938,3292,5954,2028,4600,9899,9319,3228,7730,5077,9436,159,7105,6622,7508,7369,4086,3768,2002,8880,8211,5541,2222,1119,216,3136,5682,4809,813,1193,4999,4103,4486,7305,6131,9086,7205,5451,2314,1287,528,8102,1446,3985,4724,5306,1355,5163,9074,9709,4043,7285,5250,2617,4756,1818,2105,6790,6627,2918,7984,7978,7021,2470,1636,3152,7908,8841,4955,222,6480,5484,4676,7926,5821,9401,3232,7176,916,8658,3237,1311,5943,8487,3928,7051,306,6033,3842,3285,8951,1826,7616,2324,648,9252,5476,8556,4445,6784]"
                    },
                    {
                        "username": "Raju10",
                        "content": "[1, 2, 4, 2, 5, 7, 2, 4, 9, 0]\\ncan anyone tell how the expected output is 13 for the above test case input,\\ni think its 12, isn\\'t it??"
                    },
                    {
                        "username": "itaisir",
                        "content": "buy on day 1(1) and sell on day 6(7) => profit = 6\\nbuy on day 7(2) and sell on day 9(9) => profit = 7\\ntotal profit = 6 + 7 = 13"
                    },
                    {
                        "username": "anwendeng",
                        "content": "you should buy on day 1 (price=1) and sell on day 6(price=7), profit=7-1=6"
                    },
                    {
                        "username": "engineerNewYork",
                        "content": "You buy when the price is 1 and sell when the price 7 where your profit is 6. The next time, you buy when the price is 2 and then sell it when it increases to 9 with which you make a profit of 7. In total, you get 13. "
                    },
                    {
                        "username": "tibi01993",
                        "content": "Hi everyone,\\nCan anyone help to explain why this testcase return 13? \\n[1,2,4,2,5,7,2,4,9,0]\\nAs I have profits :\\n4 - 1 = 3\\n7 - 2 = 5 \\n9 - 2 = 7\\n-> MaxProfit with 2 transactions: 5 + 7 = 12"
                    },
                    {
                        "username": "itaisir",
                        "content": "buy on day 1(1) and sell on day 6(7) => profit = 6\\nbuy on day 7(2) and sell on day 9(9) => profit = 7\\ntotal profit = 6 + 7 = 13"
                    },
                    {
                        "username": "anwendeng",
                        "content": "you should buy on day 1 (price=1) and sell on day 6(price=7), profit=7-1=6\\n"
                    },
                    {
                        "username": "arqb",
                        "content": "[@Jim](/tibi01993) and [@Saptarshi123123](/Saptarshi123123) the 2 biggest transactions are : \n9-2 = 7\n7-1 = 6\n => 7+6 = 13"
                    },
                    {
                        "username": "Saptarshi123123",
                        "content": "yes same problem!\\n"
                    },
                    {
                        "username": "wibotwi",
                        "content": "The problem for me was in understanding other guys -> because they name variables in strange way. When they say \\'sell2\\' they actually mean \\'totalProfitAfterSecondSell\\'. After I realized that -> I understood the solution.\\n\\nLet\\'s assume task was: Buy stocks on one day only. (pay attention: no sell at all!)\\nThe solution would be: find minimum of a function \\'totalProfitAfterFirstBuy\\'.\\nWhich is just go through all days and search for minimum of \\'- currPrice\\'. (cause buying stock makes our profit negative, we had \"0\"$ and now we have \"-X\"$).\\n\\nLet\\'s add second operation. The one day buy/sell solution : find minimum of a function \\'totalProfitAfterSecondSellAfterFirstBuy\\'.\\nWe will continue minimizing \\'totalProfitAfterFirstBuy\\'. But at the same time we will be minimizing \\'totalProfitAfterSecondSellAfterFirstBuy = totalProfitAfterFirstBuy + currPrice\\'. (selling gives us positive, we earn money).\\n\\nNow this solution can be applied to any number of operations. Say we were asked to minimize operations: \"Buy, Buy, Buy, Sell, Sell\".\\nTo solve it we will be minimizing profits after each op: [profitAfterOp1, profitAfterOp2, profitAfterOp3, ...].\\n\\nHope this will make it clear for everybody!\\n\\n"
                    },
                    {
                        "username": "aditichoudhary",
                        "content": "[1,2,4,2,5,7,2,4,9,0] for this input how the expected output is 13......as sets of peak valley are(V-1 P-4, V-2 P-7,V-2 P-9)  maxprofit will be =(7-2)+(9-2)"
                    },
                    {
                        "username": "ABoyNamedCrow",
                        "content": "Does it mean you can buy once and sell once, or does it mean you can buy twice and sell twice?\\n\\nNaively it seems clear the meaning should be buy once and sell once, but looking at the test cases, the other meaning seems to be what the autograder wants. Really poorly worded."
                    },
                    {
                        "username": "zhnzhang61",
                        "content": "For some of the test cases, how can a stock be priced at 0????????\\n[2,1,2,0,1]"
                    },
                    {
                        "username": "belwalrohan",
                        "content": "https://github.com/belwalrohan/August-Leetcode-Challenge/blob/master/16thAug.cpp"
                    },
                    {
                        "username": "mls__",
                        "content": "**Example 2:**\\n`Buy on day 1 (price = 1)` and at same time `Note that you cannot buy on day 1`.\\nI\\'m confused. \\n\\n\\n"
                    },
                    {
                        "username": "krishnakumar780800",
                        "content": "for the arr [1,2,3,4,5] here we buy om 1st day and sell on 5th day so profit=4 ans buy on 2nd day and sell on 4th day so profit is 2 so total profit will be 4+2=6"
                    },
                    {
                        "username": "rawbeholder",
                        "content": "You must sell the stock before buying again , so you cannot buy the stock on the 2nd day since one stock is already purchased. You need to sell the stock before buying agian."
                    }
                ]
            },
            {
                "id": 1571255,
                "content": [
                    {
                        "username": "Ankit5ingh",
                        "content": "TLE test case \\n[397,6621,4997,7506,8918,1662,9187,3278,3890,514,18,9305,93,5508,3031,2692,6019,1134,1691,4949,5071,799,8953,7882,4273,302,6753,4657,8368,3942,1982,5117,563,3332,2623,9482,4994,8163,9112,5236,5029,5483,4542,1474,991,3925,4166,3362,5059,5857,4663,6482,3008,3616,4365,3634,270,1118,8291,4990,1413,273,107,1976,9957,9083,7810,4952,7246,3275,6540,2275,8758,7434,3750,6101,1359,4268,5815,2771,126,478,9253,9486,446,3618,3120,7068,1089,1411,2058,2502,8037,2165,830,7994,1248,4993,9298,4846,8268,2191,3474,3378,9625,7224,9479,985,1492,1646,3756,7970,8476,3009,7457,8922,2980,577,2342,4069,8341,4400,2923,2730,2917,105,724,518,5098,6375,5364,3366,8566,8838,3096,8191,2414,2575,5528,259,573,5636,4581,9049,4998,2038,4323,7978,8968,6665,8399,7309,7417,1322,6391,335,1427,7115,853,2878,9842,2569,2596,4760,7760,5693,9304,6526,8268,4832,6785,5194,6821,1367,4243,1819,9757,4919,6149,8725,7936,4548,2386,5354,2222,8777,2041,1,2245,9246,2879,8439,1815,5476,3200,5927,7521,2504,2454,5789,3688,9239,7335,6861,6958,7931,8680,3068,2850,1181,1793,7138,2081,532,2492,4303,5661,885,657,4258,131,9888,9050,1947,1716,2250,4226,9237,1106,6680,1379,1146,2272,8714,8008,9230,6645,3040,2298,5847,4222,444,2986,2655,7328,1830,6959,9341,2716,3968,9952,2847,3856,9002,1146,5573,1252,5373,1162,8710,2053,2541,9856,677,1256,4216,9908,4253,3609,8558,6453,4183,5354,9439,6838,2682,7621,149,8376,337,4117,8328,9537,4326,7330,683,9899,4934,2408,7413,9996,814,9955,9852,1491,7563,421,7751,1816,4030,2662,8269,8213,8016,4060,5051,7051,1682,5201,5427,8371,5670,3755,7908,9996,7437,4944,9895,2371,7352,3661,2367,4518,3616,8571,6010,1179,5344,113,9347,9374,2775,3969,3939,792,4381,8991,7843,2415,544,3270,787,6214,3377,8695,6211,814,9991,2458,9537,7344,6119,1904,8214,6087,6827,4224,7266,2172,690,2966,7898,3465,3287,1838,609,7668,829,8452,84,7725,8074,871,3939,7803,5918,6502,4969,5910,5313,4506,9606,1432,2762,7820,3872,9590,8397,1138,8114,9087,456,6012,8904,3743,7850,9514,7764,5031,4318,7848,9108,8745,5071,9400,2900,7341,5902,7870,3251,7567,2376,9209,9000,1491,7030,2872,7433,1779,362,5547,7218,7171,7911,2474,914,2114,8340,8678,3497,2659,2878,2606,7756,7949,2006,656,5291,4260,8526,4894,1828,7255,456,7180,8746,3838,6404,6179,5617,3118,8078,9187,289,5989,1661,1204,8103,2,6234,7953,9013,5465,559,6769,9766,2565,7425,1409,3177,2304,6304,5005,9559,6760,2185,4657,598,8589,836,2567,1708,5266,1754,8349,1255,9767,5905,5711,9769,8492,3664,5134,3957,575,1903,3723,3140,5681,5133,6317,4337,7789,7675,3896,4549,6212,8553,1499,1154,5741,418,9214,1007,2172,7563,8614,8291,3469,677,4413,1961,4341,9547,5918,4916,7803,9641,4408,3484,1126,7078,7821,8915,1105,8069,9816,7317,2974,1315,8471,8715,1733,7685,6074,257,5249,4688,8549,5070,5366,2962,7031,6059,8861,9301,7328,6664,5294,8088,6500,6421,1518,4321,5336,2623,8742,1505,9941,1716,2820,4764,6783,906,2450,2857,7515,4051,7546,2416,9121,9264,1730,6152,1675,592,1805,9003,7256,7099,3444,3757,9872,4962,4430,1561,7586,3173,3066,3879,1241,2238,8643,8025,3144,7445,882,7012,1496,4780,9428,617,396,1159,3121,2072,1751,4926,7427,5359,8378,871,5468,8250,5834,9899,9811,9772,9424,2877,3651,7017,5116,8646,5042,4612,6092,2277,1624,7588,3409,1053,8206,3806,8564,7679,2230,6667,8958,6009,2026,7336,6881,3847,5586,9067,98,1750,8839,9522,4627,8842,2891,6095,7488,7934,708,3580,6563,8684,7521,9972,6089,2079,130,4653,9758,2360,1320,8716,8370,9699,6052,1603,3546,7991,670,3644,6093,9509,9518,7072,4703,2409,3168,2191,6695,228,2124,3258,5264,9645,9583,1354,1724,9713,2359,1482,8426,3680,6551,3148,9731,8955,4751,9629,6946,5421,9625,9391,1282,5495,6464,5985,4256,5984,4528,952,6212,6652,562,1476,6297,145,9182,8021,6211,1542,5856,4637,1574,2407,7785,1305,1362,2536,934,4661,4309,559,4052,1943,2406,516,4280,6662,2852,8808,7614,9064,1813,4529,6893,8110,4674,2427,2484,7237,3969,8340,1874,5543,7099,6011,3200,8461,8547,486,9474,9208,7397,9879,7503,9803,6747,1783,6466,9600,6944,432,8664,8757,4961,1909,6867,5988,4337,5703,3225,4658,4043,1452,6554,1142,7463,9754,5956,2363,241,1782,7923,7638,1661,5427,3794,8409,7210,260,8009,4154,692,3025,9263,2006,4935,2483,7994,5624,8186,7571,282,8582,9023,6836,6076,6487,6591,2032,8850,3184,3815,3125,7174,5476,8552,968,3885,2115,7580,8246,2621,4625,1272,1885,6631,6207,4368,4625,8183,2554,8548,8465,1136,7572,1654,7213,411,4597,5597,5613,7781,5764,8738,1307,7593,7291,8628,7830,9406,6208,6077,2027,833,7349,3912,7464,9908,4632,8441,8091,7187,6990,2908,4675,914,4562,8240,1325,9159,190,6938,3292,5954,2028,4600,9899,9319,3228,7730,5077,9436,159,7105,6622,7508,7369,4086,3768,2002,8880,8211,5541,2222,1119,216,3136,5682,4809,813,1193,4999,4103,4486,7305,6131,9086,7205,5451,2314,1287,528,8102,1446,3985,4724,5306,1355,5163,9074,9709,4043,7285,5250,2617,4756,1818,2105,6790,6627,2918,7984,7978,7021,2470,1636,3152,7908,8841,4955,222,6480,5484,4676,7926,5821,9401,3232,7176,916,8658,3237,1311,5943,8487,3928,7051,306,6033,3842,3285,8951,1826,7616,2324,648,9252,5476,8556,4445,6784]"
                    },
                    {
                        "username": "Raju10",
                        "content": "[1, 2, 4, 2, 5, 7, 2, 4, 9, 0]\\ncan anyone tell how the expected output is 13 for the above test case input,\\ni think its 12, isn\\'t it??"
                    },
                    {
                        "username": "itaisir",
                        "content": "buy on day 1(1) and sell on day 6(7) => profit = 6\\nbuy on day 7(2) and sell on day 9(9) => profit = 7\\ntotal profit = 6 + 7 = 13"
                    },
                    {
                        "username": "anwendeng",
                        "content": "you should buy on day 1 (price=1) and sell on day 6(price=7), profit=7-1=6"
                    },
                    {
                        "username": "engineerNewYork",
                        "content": "You buy when the price is 1 and sell when the price 7 where your profit is 6. The next time, you buy when the price is 2 and then sell it when it increases to 9 with which you make a profit of 7. In total, you get 13. "
                    },
                    {
                        "username": "tibi01993",
                        "content": "Hi everyone,\\nCan anyone help to explain why this testcase return 13? \\n[1,2,4,2,5,7,2,4,9,0]\\nAs I have profits :\\n4 - 1 = 3\\n7 - 2 = 5 \\n9 - 2 = 7\\n-> MaxProfit with 2 transactions: 5 + 7 = 12"
                    },
                    {
                        "username": "itaisir",
                        "content": "buy on day 1(1) and sell on day 6(7) => profit = 6\\nbuy on day 7(2) and sell on day 9(9) => profit = 7\\ntotal profit = 6 + 7 = 13"
                    },
                    {
                        "username": "anwendeng",
                        "content": "you should buy on day 1 (price=1) and sell on day 6(price=7), profit=7-1=6\\n"
                    },
                    {
                        "username": "arqb",
                        "content": "[@Jim](/tibi01993) and [@Saptarshi123123](/Saptarshi123123) the 2 biggest transactions are : \n9-2 = 7\n7-1 = 6\n => 7+6 = 13"
                    },
                    {
                        "username": "Saptarshi123123",
                        "content": "yes same problem!\\n"
                    },
                    {
                        "username": "wibotwi",
                        "content": "The problem for me was in understanding other guys -> because they name variables in strange way. When they say \\'sell2\\' they actually mean \\'totalProfitAfterSecondSell\\'. After I realized that -> I understood the solution.\\n\\nLet\\'s assume task was: Buy stocks on one day only. (pay attention: no sell at all!)\\nThe solution would be: find minimum of a function \\'totalProfitAfterFirstBuy\\'.\\nWhich is just go through all days and search for minimum of \\'- currPrice\\'. (cause buying stock makes our profit negative, we had \"0\"$ and now we have \"-X\"$).\\n\\nLet\\'s add second operation. The one day buy/sell solution : find minimum of a function \\'totalProfitAfterSecondSellAfterFirstBuy\\'.\\nWe will continue minimizing \\'totalProfitAfterFirstBuy\\'. But at the same time we will be minimizing \\'totalProfitAfterSecondSellAfterFirstBuy = totalProfitAfterFirstBuy + currPrice\\'. (selling gives us positive, we earn money).\\n\\nNow this solution can be applied to any number of operations. Say we were asked to minimize operations: \"Buy, Buy, Buy, Sell, Sell\".\\nTo solve it we will be minimizing profits after each op: [profitAfterOp1, profitAfterOp2, profitAfterOp3, ...].\\n\\nHope this will make it clear for everybody!\\n\\n"
                    },
                    {
                        "username": "aditichoudhary",
                        "content": "[1,2,4,2,5,7,2,4,9,0] for this input how the expected output is 13......as sets of peak valley are(V-1 P-4, V-2 P-7,V-2 P-9)  maxprofit will be =(7-2)+(9-2)"
                    },
                    {
                        "username": "ABoyNamedCrow",
                        "content": "Does it mean you can buy once and sell once, or does it mean you can buy twice and sell twice?\\n\\nNaively it seems clear the meaning should be buy once and sell once, but looking at the test cases, the other meaning seems to be what the autograder wants. Really poorly worded."
                    },
                    {
                        "username": "zhnzhang61",
                        "content": "For some of the test cases, how can a stock be priced at 0????????\\n[2,1,2,0,1]"
                    },
                    {
                        "username": "belwalrohan",
                        "content": "https://github.com/belwalrohan/August-Leetcode-Challenge/blob/master/16thAug.cpp"
                    },
                    {
                        "username": "mls__",
                        "content": "**Example 2:**\\n`Buy on day 1 (price = 1)` and at same time `Note that you cannot buy on day 1`.\\nI\\'m confused. \\n\\n\\n"
                    },
                    {
                        "username": "krishnakumar780800",
                        "content": "for the arr [1,2,3,4,5] here we buy om 1st day and sell on 5th day so profit=4 ans buy on 2nd day and sell on 4th day so profit is 2 so total profit will be 4+2=6"
                    },
                    {
                        "username": "rawbeholder",
                        "content": "You must sell the stock before buying again , so you cannot buy the stock on the 2nd day since one stock is already purchased. You need to sell the stock before buying agian."
                    }
                ]
            },
            {
                "id": 1574222,
                "content": [
                    {
                        "username": "Ankit5ingh",
                        "content": "TLE test case \\n[397,6621,4997,7506,8918,1662,9187,3278,3890,514,18,9305,93,5508,3031,2692,6019,1134,1691,4949,5071,799,8953,7882,4273,302,6753,4657,8368,3942,1982,5117,563,3332,2623,9482,4994,8163,9112,5236,5029,5483,4542,1474,991,3925,4166,3362,5059,5857,4663,6482,3008,3616,4365,3634,270,1118,8291,4990,1413,273,107,1976,9957,9083,7810,4952,7246,3275,6540,2275,8758,7434,3750,6101,1359,4268,5815,2771,126,478,9253,9486,446,3618,3120,7068,1089,1411,2058,2502,8037,2165,830,7994,1248,4993,9298,4846,8268,2191,3474,3378,9625,7224,9479,985,1492,1646,3756,7970,8476,3009,7457,8922,2980,577,2342,4069,8341,4400,2923,2730,2917,105,724,518,5098,6375,5364,3366,8566,8838,3096,8191,2414,2575,5528,259,573,5636,4581,9049,4998,2038,4323,7978,8968,6665,8399,7309,7417,1322,6391,335,1427,7115,853,2878,9842,2569,2596,4760,7760,5693,9304,6526,8268,4832,6785,5194,6821,1367,4243,1819,9757,4919,6149,8725,7936,4548,2386,5354,2222,8777,2041,1,2245,9246,2879,8439,1815,5476,3200,5927,7521,2504,2454,5789,3688,9239,7335,6861,6958,7931,8680,3068,2850,1181,1793,7138,2081,532,2492,4303,5661,885,657,4258,131,9888,9050,1947,1716,2250,4226,9237,1106,6680,1379,1146,2272,8714,8008,9230,6645,3040,2298,5847,4222,444,2986,2655,7328,1830,6959,9341,2716,3968,9952,2847,3856,9002,1146,5573,1252,5373,1162,8710,2053,2541,9856,677,1256,4216,9908,4253,3609,8558,6453,4183,5354,9439,6838,2682,7621,149,8376,337,4117,8328,9537,4326,7330,683,9899,4934,2408,7413,9996,814,9955,9852,1491,7563,421,7751,1816,4030,2662,8269,8213,8016,4060,5051,7051,1682,5201,5427,8371,5670,3755,7908,9996,7437,4944,9895,2371,7352,3661,2367,4518,3616,8571,6010,1179,5344,113,9347,9374,2775,3969,3939,792,4381,8991,7843,2415,544,3270,787,6214,3377,8695,6211,814,9991,2458,9537,7344,6119,1904,8214,6087,6827,4224,7266,2172,690,2966,7898,3465,3287,1838,609,7668,829,8452,84,7725,8074,871,3939,7803,5918,6502,4969,5910,5313,4506,9606,1432,2762,7820,3872,9590,8397,1138,8114,9087,456,6012,8904,3743,7850,9514,7764,5031,4318,7848,9108,8745,5071,9400,2900,7341,5902,7870,3251,7567,2376,9209,9000,1491,7030,2872,7433,1779,362,5547,7218,7171,7911,2474,914,2114,8340,8678,3497,2659,2878,2606,7756,7949,2006,656,5291,4260,8526,4894,1828,7255,456,7180,8746,3838,6404,6179,5617,3118,8078,9187,289,5989,1661,1204,8103,2,6234,7953,9013,5465,559,6769,9766,2565,7425,1409,3177,2304,6304,5005,9559,6760,2185,4657,598,8589,836,2567,1708,5266,1754,8349,1255,9767,5905,5711,9769,8492,3664,5134,3957,575,1903,3723,3140,5681,5133,6317,4337,7789,7675,3896,4549,6212,8553,1499,1154,5741,418,9214,1007,2172,7563,8614,8291,3469,677,4413,1961,4341,9547,5918,4916,7803,9641,4408,3484,1126,7078,7821,8915,1105,8069,9816,7317,2974,1315,8471,8715,1733,7685,6074,257,5249,4688,8549,5070,5366,2962,7031,6059,8861,9301,7328,6664,5294,8088,6500,6421,1518,4321,5336,2623,8742,1505,9941,1716,2820,4764,6783,906,2450,2857,7515,4051,7546,2416,9121,9264,1730,6152,1675,592,1805,9003,7256,7099,3444,3757,9872,4962,4430,1561,7586,3173,3066,3879,1241,2238,8643,8025,3144,7445,882,7012,1496,4780,9428,617,396,1159,3121,2072,1751,4926,7427,5359,8378,871,5468,8250,5834,9899,9811,9772,9424,2877,3651,7017,5116,8646,5042,4612,6092,2277,1624,7588,3409,1053,8206,3806,8564,7679,2230,6667,8958,6009,2026,7336,6881,3847,5586,9067,98,1750,8839,9522,4627,8842,2891,6095,7488,7934,708,3580,6563,8684,7521,9972,6089,2079,130,4653,9758,2360,1320,8716,8370,9699,6052,1603,3546,7991,670,3644,6093,9509,9518,7072,4703,2409,3168,2191,6695,228,2124,3258,5264,9645,9583,1354,1724,9713,2359,1482,8426,3680,6551,3148,9731,8955,4751,9629,6946,5421,9625,9391,1282,5495,6464,5985,4256,5984,4528,952,6212,6652,562,1476,6297,145,9182,8021,6211,1542,5856,4637,1574,2407,7785,1305,1362,2536,934,4661,4309,559,4052,1943,2406,516,4280,6662,2852,8808,7614,9064,1813,4529,6893,8110,4674,2427,2484,7237,3969,8340,1874,5543,7099,6011,3200,8461,8547,486,9474,9208,7397,9879,7503,9803,6747,1783,6466,9600,6944,432,8664,8757,4961,1909,6867,5988,4337,5703,3225,4658,4043,1452,6554,1142,7463,9754,5956,2363,241,1782,7923,7638,1661,5427,3794,8409,7210,260,8009,4154,692,3025,9263,2006,4935,2483,7994,5624,8186,7571,282,8582,9023,6836,6076,6487,6591,2032,8850,3184,3815,3125,7174,5476,8552,968,3885,2115,7580,8246,2621,4625,1272,1885,6631,6207,4368,4625,8183,2554,8548,8465,1136,7572,1654,7213,411,4597,5597,5613,7781,5764,8738,1307,7593,7291,8628,7830,9406,6208,6077,2027,833,7349,3912,7464,9908,4632,8441,8091,7187,6990,2908,4675,914,4562,8240,1325,9159,190,6938,3292,5954,2028,4600,9899,9319,3228,7730,5077,9436,159,7105,6622,7508,7369,4086,3768,2002,8880,8211,5541,2222,1119,216,3136,5682,4809,813,1193,4999,4103,4486,7305,6131,9086,7205,5451,2314,1287,528,8102,1446,3985,4724,5306,1355,5163,9074,9709,4043,7285,5250,2617,4756,1818,2105,6790,6627,2918,7984,7978,7021,2470,1636,3152,7908,8841,4955,222,6480,5484,4676,7926,5821,9401,3232,7176,916,8658,3237,1311,5943,8487,3928,7051,306,6033,3842,3285,8951,1826,7616,2324,648,9252,5476,8556,4445,6784]"
                    },
                    {
                        "username": "Raju10",
                        "content": "[1, 2, 4, 2, 5, 7, 2, 4, 9, 0]\\ncan anyone tell how the expected output is 13 for the above test case input,\\ni think its 12, isn\\'t it??"
                    },
                    {
                        "username": "itaisir",
                        "content": "buy on day 1(1) and sell on day 6(7) => profit = 6\\nbuy on day 7(2) and sell on day 9(9) => profit = 7\\ntotal profit = 6 + 7 = 13"
                    },
                    {
                        "username": "anwendeng",
                        "content": "you should buy on day 1 (price=1) and sell on day 6(price=7), profit=7-1=6"
                    },
                    {
                        "username": "engineerNewYork",
                        "content": "You buy when the price is 1 and sell when the price 7 where your profit is 6. The next time, you buy when the price is 2 and then sell it when it increases to 9 with which you make a profit of 7. In total, you get 13. "
                    },
                    {
                        "username": "tibi01993",
                        "content": "Hi everyone,\\nCan anyone help to explain why this testcase return 13? \\n[1,2,4,2,5,7,2,4,9,0]\\nAs I have profits :\\n4 - 1 = 3\\n7 - 2 = 5 \\n9 - 2 = 7\\n-> MaxProfit with 2 transactions: 5 + 7 = 12"
                    },
                    {
                        "username": "itaisir",
                        "content": "buy on day 1(1) and sell on day 6(7) => profit = 6\\nbuy on day 7(2) and sell on day 9(9) => profit = 7\\ntotal profit = 6 + 7 = 13"
                    },
                    {
                        "username": "anwendeng",
                        "content": "you should buy on day 1 (price=1) and sell on day 6(price=7), profit=7-1=6\\n"
                    },
                    {
                        "username": "arqb",
                        "content": "[@Jim](/tibi01993) and [@Saptarshi123123](/Saptarshi123123) the 2 biggest transactions are : \n9-2 = 7\n7-1 = 6\n => 7+6 = 13"
                    },
                    {
                        "username": "Saptarshi123123",
                        "content": "yes same problem!\\n"
                    },
                    {
                        "username": "wibotwi",
                        "content": "The problem for me was in understanding other guys -> because they name variables in strange way. When they say \\'sell2\\' they actually mean \\'totalProfitAfterSecondSell\\'. After I realized that -> I understood the solution.\\n\\nLet\\'s assume task was: Buy stocks on one day only. (pay attention: no sell at all!)\\nThe solution would be: find minimum of a function \\'totalProfitAfterFirstBuy\\'.\\nWhich is just go through all days and search for minimum of \\'- currPrice\\'. (cause buying stock makes our profit negative, we had \"0\"$ and now we have \"-X\"$).\\n\\nLet\\'s add second operation. The one day buy/sell solution : find minimum of a function \\'totalProfitAfterSecondSellAfterFirstBuy\\'.\\nWe will continue minimizing \\'totalProfitAfterFirstBuy\\'. But at the same time we will be minimizing \\'totalProfitAfterSecondSellAfterFirstBuy = totalProfitAfterFirstBuy + currPrice\\'. (selling gives us positive, we earn money).\\n\\nNow this solution can be applied to any number of operations. Say we were asked to minimize operations: \"Buy, Buy, Buy, Sell, Sell\".\\nTo solve it we will be minimizing profits after each op: [profitAfterOp1, profitAfterOp2, profitAfterOp3, ...].\\n\\nHope this will make it clear for everybody!\\n\\n"
                    },
                    {
                        "username": "aditichoudhary",
                        "content": "[1,2,4,2,5,7,2,4,9,0] for this input how the expected output is 13......as sets of peak valley are(V-1 P-4, V-2 P-7,V-2 P-9)  maxprofit will be =(7-2)+(9-2)"
                    },
                    {
                        "username": "ABoyNamedCrow",
                        "content": "Does it mean you can buy once and sell once, or does it mean you can buy twice and sell twice?\\n\\nNaively it seems clear the meaning should be buy once and sell once, but looking at the test cases, the other meaning seems to be what the autograder wants. Really poorly worded."
                    },
                    {
                        "username": "zhnzhang61",
                        "content": "For some of the test cases, how can a stock be priced at 0????????\\n[2,1,2,0,1]"
                    },
                    {
                        "username": "belwalrohan",
                        "content": "https://github.com/belwalrohan/August-Leetcode-Challenge/blob/master/16thAug.cpp"
                    },
                    {
                        "username": "mls__",
                        "content": "**Example 2:**\\n`Buy on day 1 (price = 1)` and at same time `Note that you cannot buy on day 1`.\\nI\\'m confused. \\n\\n\\n"
                    },
                    {
                        "username": "krishnakumar780800",
                        "content": "for the arr [1,2,3,4,5] here we buy om 1st day and sell on 5th day so profit=4 ans buy on 2nd day and sell on 4th day so profit is 2 so total profit will be 4+2=6"
                    },
                    {
                        "username": "rawbeholder",
                        "content": "You must sell the stock before buying again , so you cannot buy the stock on the 2nd day since one stock is already purchased. You need to sell the stock before buying agian."
                    }
                ]
            },
            {
                "id": 2044494,
                "content": [
                    {
                        "username": "Ankit5ingh",
                        "content": "TLE test case \\n[397,6621,4997,7506,8918,1662,9187,3278,3890,514,18,9305,93,5508,3031,2692,6019,1134,1691,4949,5071,799,8953,7882,4273,302,6753,4657,8368,3942,1982,5117,563,3332,2623,9482,4994,8163,9112,5236,5029,5483,4542,1474,991,3925,4166,3362,5059,5857,4663,6482,3008,3616,4365,3634,270,1118,8291,4990,1413,273,107,1976,9957,9083,7810,4952,7246,3275,6540,2275,8758,7434,3750,6101,1359,4268,5815,2771,126,478,9253,9486,446,3618,3120,7068,1089,1411,2058,2502,8037,2165,830,7994,1248,4993,9298,4846,8268,2191,3474,3378,9625,7224,9479,985,1492,1646,3756,7970,8476,3009,7457,8922,2980,577,2342,4069,8341,4400,2923,2730,2917,105,724,518,5098,6375,5364,3366,8566,8838,3096,8191,2414,2575,5528,259,573,5636,4581,9049,4998,2038,4323,7978,8968,6665,8399,7309,7417,1322,6391,335,1427,7115,853,2878,9842,2569,2596,4760,7760,5693,9304,6526,8268,4832,6785,5194,6821,1367,4243,1819,9757,4919,6149,8725,7936,4548,2386,5354,2222,8777,2041,1,2245,9246,2879,8439,1815,5476,3200,5927,7521,2504,2454,5789,3688,9239,7335,6861,6958,7931,8680,3068,2850,1181,1793,7138,2081,532,2492,4303,5661,885,657,4258,131,9888,9050,1947,1716,2250,4226,9237,1106,6680,1379,1146,2272,8714,8008,9230,6645,3040,2298,5847,4222,444,2986,2655,7328,1830,6959,9341,2716,3968,9952,2847,3856,9002,1146,5573,1252,5373,1162,8710,2053,2541,9856,677,1256,4216,9908,4253,3609,8558,6453,4183,5354,9439,6838,2682,7621,149,8376,337,4117,8328,9537,4326,7330,683,9899,4934,2408,7413,9996,814,9955,9852,1491,7563,421,7751,1816,4030,2662,8269,8213,8016,4060,5051,7051,1682,5201,5427,8371,5670,3755,7908,9996,7437,4944,9895,2371,7352,3661,2367,4518,3616,8571,6010,1179,5344,113,9347,9374,2775,3969,3939,792,4381,8991,7843,2415,544,3270,787,6214,3377,8695,6211,814,9991,2458,9537,7344,6119,1904,8214,6087,6827,4224,7266,2172,690,2966,7898,3465,3287,1838,609,7668,829,8452,84,7725,8074,871,3939,7803,5918,6502,4969,5910,5313,4506,9606,1432,2762,7820,3872,9590,8397,1138,8114,9087,456,6012,8904,3743,7850,9514,7764,5031,4318,7848,9108,8745,5071,9400,2900,7341,5902,7870,3251,7567,2376,9209,9000,1491,7030,2872,7433,1779,362,5547,7218,7171,7911,2474,914,2114,8340,8678,3497,2659,2878,2606,7756,7949,2006,656,5291,4260,8526,4894,1828,7255,456,7180,8746,3838,6404,6179,5617,3118,8078,9187,289,5989,1661,1204,8103,2,6234,7953,9013,5465,559,6769,9766,2565,7425,1409,3177,2304,6304,5005,9559,6760,2185,4657,598,8589,836,2567,1708,5266,1754,8349,1255,9767,5905,5711,9769,8492,3664,5134,3957,575,1903,3723,3140,5681,5133,6317,4337,7789,7675,3896,4549,6212,8553,1499,1154,5741,418,9214,1007,2172,7563,8614,8291,3469,677,4413,1961,4341,9547,5918,4916,7803,9641,4408,3484,1126,7078,7821,8915,1105,8069,9816,7317,2974,1315,8471,8715,1733,7685,6074,257,5249,4688,8549,5070,5366,2962,7031,6059,8861,9301,7328,6664,5294,8088,6500,6421,1518,4321,5336,2623,8742,1505,9941,1716,2820,4764,6783,906,2450,2857,7515,4051,7546,2416,9121,9264,1730,6152,1675,592,1805,9003,7256,7099,3444,3757,9872,4962,4430,1561,7586,3173,3066,3879,1241,2238,8643,8025,3144,7445,882,7012,1496,4780,9428,617,396,1159,3121,2072,1751,4926,7427,5359,8378,871,5468,8250,5834,9899,9811,9772,9424,2877,3651,7017,5116,8646,5042,4612,6092,2277,1624,7588,3409,1053,8206,3806,8564,7679,2230,6667,8958,6009,2026,7336,6881,3847,5586,9067,98,1750,8839,9522,4627,8842,2891,6095,7488,7934,708,3580,6563,8684,7521,9972,6089,2079,130,4653,9758,2360,1320,8716,8370,9699,6052,1603,3546,7991,670,3644,6093,9509,9518,7072,4703,2409,3168,2191,6695,228,2124,3258,5264,9645,9583,1354,1724,9713,2359,1482,8426,3680,6551,3148,9731,8955,4751,9629,6946,5421,9625,9391,1282,5495,6464,5985,4256,5984,4528,952,6212,6652,562,1476,6297,145,9182,8021,6211,1542,5856,4637,1574,2407,7785,1305,1362,2536,934,4661,4309,559,4052,1943,2406,516,4280,6662,2852,8808,7614,9064,1813,4529,6893,8110,4674,2427,2484,7237,3969,8340,1874,5543,7099,6011,3200,8461,8547,486,9474,9208,7397,9879,7503,9803,6747,1783,6466,9600,6944,432,8664,8757,4961,1909,6867,5988,4337,5703,3225,4658,4043,1452,6554,1142,7463,9754,5956,2363,241,1782,7923,7638,1661,5427,3794,8409,7210,260,8009,4154,692,3025,9263,2006,4935,2483,7994,5624,8186,7571,282,8582,9023,6836,6076,6487,6591,2032,8850,3184,3815,3125,7174,5476,8552,968,3885,2115,7580,8246,2621,4625,1272,1885,6631,6207,4368,4625,8183,2554,8548,8465,1136,7572,1654,7213,411,4597,5597,5613,7781,5764,8738,1307,7593,7291,8628,7830,9406,6208,6077,2027,833,7349,3912,7464,9908,4632,8441,8091,7187,6990,2908,4675,914,4562,8240,1325,9159,190,6938,3292,5954,2028,4600,9899,9319,3228,7730,5077,9436,159,7105,6622,7508,7369,4086,3768,2002,8880,8211,5541,2222,1119,216,3136,5682,4809,813,1193,4999,4103,4486,7305,6131,9086,7205,5451,2314,1287,528,8102,1446,3985,4724,5306,1355,5163,9074,9709,4043,7285,5250,2617,4756,1818,2105,6790,6627,2918,7984,7978,7021,2470,1636,3152,7908,8841,4955,222,6480,5484,4676,7926,5821,9401,3232,7176,916,8658,3237,1311,5943,8487,3928,7051,306,6033,3842,3285,8951,1826,7616,2324,648,9252,5476,8556,4445,6784]"
                    },
                    {
                        "username": "Raju10",
                        "content": "[1, 2, 4, 2, 5, 7, 2, 4, 9, 0]\\ncan anyone tell how the expected output is 13 for the above test case input,\\ni think its 12, isn\\'t it??"
                    },
                    {
                        "username": "itaisir",
                        "content": "buy on day 1(1) and sell on day 6(7) => profit = 6\\nbuy on day 7(2) and sell on day 9(9) => profit = 7\\ntotal profit = 6 + 7 = 13"
                    },
                    {
                        "username": "anwendeng",
                        "content": "you should buy on day 1 (price=1) and sell on day 6(price=7), profit=7-1=6"
                    },
                    {
                        "username": "engineerNewYork",
                        "content": "You buy when the price is 1 and sell when the price 7 where your profit is 6. The next time, you buy when the price is 2 and then sell it when it increases to 9 with which you make a profit of 7. In total, you get 13. "
                    },
                    {
                        "username": "tibi01993",
                        "content": "Hi everyone,\\nCan anyone help to explain why this testcase return 13? \\n[1,2,4,2,5,7,2,4,9,0]\\nAs I have profits :\\n4 - 1 = 3\\n7 - 2 = 5 \\n9 - 2 = 7\\n-> MaxProfit with 2 transactions: 5 + 7 = 12"
                    },
                    {
                        "username": "itaisir",
                        "content": "buy on day 1(1) and sell on day 6(7) => profit = 6\\nbuy on day 7(2) and sell on day 9(9) => profit = 7\\ntotal profit = 6 + 7 = 13"
                    },
                    {
                        "username": "anwendeng",
                        "content": "you should buy on day 1 (price=1) and sell on day 6(price=7), profit=7-1=6\\n"
                    },
                    {
                        "username": "arqb",
                        "content": "[@Jim](/tibi01993) and [@Saptarshi123123](/Saptarshi123123) the 2 biggest transactions are : \n9-2 = 7\n7-1 = 6\n => 7+6 = 13"
                    },
                    {
                        "username": "Saptarshi123123",
                        "content": "yes same problem!\\n"
                    },
                    {
                        "username": "wibotwi",
                        "content": "The problem for me was in understanding other guys -> because they name variables in strange way. When they say \\'sell2\\' they actually mean \\'totalProfitAfterSecondSell\\'. After I realized that -> I understood the solution.\\n\\nLet\\'s assume task was: Buy stocks on one day only. (pay attention: no sell at all!)\\nThe solution would be: find minimum of a function \\'totalProfitAfterFirstBuy\\'.\\nWhich is just go through all days and search for minimum of \\'- currPrice\\'. (cause buying stock makes our profit negative, we had \"0\"$ and now we have \"-X\"$).\\n\\nLet\\'s add second operation. The one day buy/sell solution : find minimum of a function \\'totalProfitAfterSecondSellAfterFirstBuy\\'.\\nWe will continue minimizing \\'totalProfitAfterFirstBuy\\'. But at the same time we will be minimizing \\'totalProfitAfterSecondSellAfterFirstBuy = totalProfitAfterFirstBuy + currPrice\\'. (selling gives us positive, we earn money).\\n\\nNow this solution can be applied to any number of operations. Say we were asked to minimize operations: \"Buy, Buy, Buy, Sell, Sell\".\\nTo solve it we will be minimizing profits after each op: [profitAfterOp1, profitAfterOp2, profitAfterOp3, ...].\\n\\nHope this will make it clear for everybody!\\n\\n"
                    },
                    {
                        "username": "aditichoudhary",
                        "content": "[1,2,4,2,5,7,2,4,9,0] for this input how the expected output is 13......as sets of peak valley are(V-1 P-4, V-2 P-7,V-2 P-9)  maxprofit will be =(7-2)+(9-2)"
                    },
                    {
                        "username": "ABoyNamedCrow",
                        "content": "Does it mean you can buy once and sell once, or does it mean you can buy twice and sell twice?\\n\\nNaively it seems clear the meaning should be buy once and sell once, but looking at the test cases, the other meaning seems to be what the autograder wants. Really poorly worded."
                    },
                    {
                        "username": "zhnzhang61",
                        "content": "For some of the test cases, how can a stock be priced at 0????????\\n[2,1,2,0,1]"
                    },
                    {
                        "username": "belwalrohan",
                        "content": "https://github.com/belwalrohan/August-Leetcode-Challenge/blob/master/16thAug.cpp"
                    },
                    {
                        "username": "mls__",
                        "content": "**Example 2:**\\n`Buy on day 1 (price = 1)` and at same time `Note that you cannot buy on day 1`.\\nI\\'m confused. \\n\\n\\n"
                    },
                    {
                        "username": "krishnakumar780800",
                        "content": "for the arr [1,2,3,4,5] here we buy om 1st day and sell on 5th day so profit=4 ans buy on 2nd day and sell on 4th day so profit is 2 so total profit will be 4+2=6"
                    },
                    {
                        "username": "rawbeholder",
                        "content": "You must sell the stock before buying again , so you cannot buy the stock on the 2nd day since one stock is already purchased. You need to sell the stock before buying agian."
                    }
                ]
            },
            {
                "id": 2039489,
                "content": [
                    {
                        "username": "Ankit5ingh",
                        "content": "TLE test case \\n[397,6621,4997,7506,8918,1662,9187,3278,3890,514,18,9305,93,5508,3031,2692,6019,1134,1691,4949,5071,799,8953,7882,4273,302,6753,4657,8368,3942,1982,5117,563,3332,2623,9482,4994,8163,9112,5236,5029,5483,4542,1474,991,3925,4166,3362,5059,5857,4663,6482,3008,3616,4365,3634,270,1118,8291,4990,1413,273,107,1976,9957,9083,7810,4952,7246,3275,6540,2275,8758,7434,3750,6101,1359,4268,5815,2771,126,478,9253,9486,446,3618,3120,7068,1089,1411,2058,2502,8037,2165,830,7994,1248,4993,9298,4846,8268,2191,3474,3378,9625,7224,9479,985,1492,1646,3756,7970,8476,3009,7457,8922,2980,577,2342,4069,8341,4400,2923,2730,2917,105,724,518,5098,6375,5364,3366,8566,8838,3096,8191,2414,2575,5528,259,573,5636,4581,9049,4998,2038,4323,7978,8968,6665,8399,7309,7417,1322,6391,335,1427,7115,853,2878,9842,2569,2596,4760,7760,5693,9304,6526,8268,4832,6785,5194,6821,1367,4243,1819,9757,4919,6149,8725,7936,4548,2386,5354,2222,8777,2041,1,2245,9246,2879,8439,1815,5476,3200,5927,7521,2504,2454,5789,3688,9239,7335,6861,6958,7931,8680,3068,2850,1181,1793,7138,2081,532,2492,4303,5661,885,657,4258,131,9888,9050,1947,1716,2250,4226,9237,1106,6680,1379,1146,2272,8714,8008,9230,6645,3040,2298,5847,4222,444,2986,2655,7328,1830,6959,9341,2716,3968,9952,2847,3856,9002,1146,5573,1252,5373,1162,8710,2053,2541,9856,677,1256,4216,9908,4253,3609,8558,6453,4183,5354,9439,6838,2682,7621,149,8376,337,4117,8328,9537,4326,7330,683,9899,4934,2408,7413,9996,814,9955,9852,1491,7563,421,7751,1816,4030,2662,8269,8213,8016,4060,5051,7051,1682,5201,5427,8371,5670,3755,7908,9996,7437,4944,9895,2371,7352,3661,2367,4518,3616,8571,6010,1179,5344,113,9347,9374,2775,3969,3939,792,4381,8991,7843,2415,544,3270,787,6214,3377,8695,6211,814,9991,2458,9537,7344,6119,1904,8214,6087,6827,4224,7266,2172,690,2966,7898,3465,3287,1838,609,7668,829,8452,84,7725,8074,871,3939,7803,5918,6502,4969,5910,5313,4506,9606,1432,2762,7820,3872,9590,8397,1138,8114,9087,456,6012,8904,3743,7850,9514,7764,5031,4318,7848,9108,8745,5071,9400,2900,7341,5902,7870,3251,7567,2376,9209,9000,1491,7030,2872,7433,1779,362,5547,7218,7171,7911,2474,914,2114,8340,8678,3497,2659,2878,2606,7756,7949,2006,656,5291,4260,8526,4894,1828,7255,456,7180,8746,3838,6404,6179,5617,3118,8078,9187,289,5989,1661,1204,8103,2,6234,7953,9013,5465,559,6769,9766,2565,7425,1409,3177,2304,6304,5005,9559,6760,2185,4657,598,8589,836,2567,1708,5266,1754,8349,1255,9767,5905,5711,9769,8492,3664,5134,3957,575,1903,3723,3140,5681,5133,6317,4337,7789,7675,3896,4549,6212,8553,1499,1154,5741,418,9214,1007,2172,7563,8614,8291,3469,677,4413,1961,4341,9547,5918,4916,7803,9641,4408,3484,1126,7078,7821,8915,1105,8069,9816,7317,2974,1315,8471,8715,1733,7685,6074,257,5249,4688,8549,5070,5366,2962,7031,6059,8861,9301,7328,6664,5294,8088,6500,6421,1518,4321,5336,2623,8742,1505,9941,1716,2820,4764,6783,906,2450,2857,7515,4051,7546,2416,9121,9264,1730,6152,1675,592,1805,9003,7256,7099,3444,3757,9872,4962,4430,1561,7586,3173,3066,3879,1241,2238,8643,8025,3144,7445,882,7012,1496,4780,9428,617,396,1159,3121,2072,1751,4926,7427,5359,8378,871,5468,8250,5834,9899,9811,9772,9424,2877,3651,7017,5116,8646,5042,4612,6092,2277,1624,7588,3409,1053,8206,3806,8564,7679,2230,6667,8958,6009,2026,7336,6881,3847,5586,9067,98,1750,8839,9522,4627,8842,2891,6095,7488,7934,708,3580,6563,8684,7521,9972,6089,2079,130,4653,9758,2360,1320,8716,8370,9699,6052,1603,3546,7991,670,3644,6093,9509,9518,7072,4703,2409,3168,2191,6695,228,2124,3258,5264,9645,9583,1354,1724,9713,2359,1482,8426,3680,6551,3148,9731,8955,4751,9629,6946,5421,9625,9391,1282,5495,6464,5985,4256,5984,4528,952,6212,6652,562,1476,6297,145,9182,8021,6211,1542,5856,4637,1574,2407,7785,1305,1362,2536,934,4661,4309,559,4052,1943,2406,516,4280,6662,2852,8808,7614,9064,1813,4529,6893,8110,4674,2427,2484,7237,3969,8340,1874,5543,7099,6011,3200,8461,8547,486,9474,9208,7397,9879,7503,9803,6747,1783,6466,9600,6944,432,8664,8757,4961,1909,6867,5988,4337,5703,3225,4658,4043,1452,6554,1142,7463,9754,5956,2363,241,1782,7923,7638,1661,5427,3794,8409,7210,260,8009,4154,692,3025,9263,2006,4935,2483,7994,5624,8186,7571,282,8582,9023,6836,6076,6487,6591,2032,8850,3184,3815,3125,7174,5476,8552,968,3885,2115,7580,8246,2621,4625,1272,1885,6631,6207,4368,4625,8183,2554,8548,8465,1136,7572,1654,7213,411,4597,5597,5613,7781,5764,8738,1307,7593,7291,8628,7830,9406,6208,6077,2027,833,7349,3912,7464,9908,4632,8441,8091,7187,6990,2908,4675,914,4562,8240,1325,9159,190,6938,3292,5954,2028,4600,9899,9319,3228,7730,5077,9436,159,7105,6622,7508,7369,4086,3768,2002,8880,8211,5541,2222,1119,216,3136,5682,4809,813,1193,4999,4103,4486,7305,6131,9086,7205,5451,2314,1287,528,8102,1446,3985,4724,5306,1355,5163,9074,9709,4043,7285,5250,2617,4756,1818,2105,6790,6627,2918,7984,7978,7021,2470,1636,3152,7908,8841,4955,222,6480,5484,4676,7926,5821,9401,3232,7176,916,8658,3237,1311,5943,8487,3928,7051,306,6033,3842,3285,8951,1826,7616,2324,648,9252,5476,8556,4445,6784]"
                    },
                    {
                        "username": "Raju10",
                        "content": "[1, 2, 4, 2, 5, 7, 2, 4, 9, 0]\\ncan anyone tell how the expected output is 13 for the above test case input,\\ni think its 12, isn\\'t it??"
                    },
                    {
                        "username": "itaisir",
                        "content": "buy on day 1(1) and sell on day 6(7) => profit = 6\\nbuy on day 7(2) and sell on day 9(9) => profit = 7\\ntotal profit = 6 + 7 = 13"
                    },
                    {
                        "username": "anwendeng",
                        "content": "you should buy on day 1 (price=1) and sell on day 6(price=7), profit=7-1=6"
                    },
                    {
                        "username": "engineerNewYork",
                        "content": "You buy when the price is 1 and sell when the price 7 where your profit is 6. The next time, you buy when the price is 2 and then sell it when it increases to 9 with which you make a profit of 7. In total, you get 13. "
                    },
                    {
                        "username": "tibi01993",
                        "content": "Hi everyone,\\nCan anyone help to explain why this testcase return 13? \\n[1,2,4,2,5,7,2,4,9,0]\\nAs I have profits :\\n4 - 1 = 3\\n7 - 2 = 5 \\n9 - 2 = 7\\n-> MaxProfit with 2 transactions: 5 + 7 = 12"
                    },
                    {
                        "username": "itaisir",
                        "content": "buy on day 1(1) and sell on day 6(7) => profit = 6\\nbuy on day 7(2) and sell on day 9(9) => profit = 7\\ntotal profit = 6 + 7 = 13"
                    },
                    {
                        "username": "anwendeng",
                        "content": "you should buy on day 1 (price=1) and sell on day 6(price=7), profit=7-1=6\\n"
                    },
                    {
                        "username": "arqb",
                        "content": "[@Jim](/tibi01993) and [@Saptarshi123123](/Saptarshi123123) the 2 biggest transactions are : \n9-2 = 7\n7-1 = 6\n => 7+6 = 13"
                    },
                    {
                        "username": "Saptarshi123123",
                        "content": "yes same problem!\\n"
                    },
                    {
                        "username": "wibotwi",
                        "content": "The problem for me was in understanding other guys -> because they name variables in strange way. When they say \\'sell2\\' they actually mean \\'totalProfitAfterSecondSell\\'. After I realized that -> I understood the solution.\\n\\nLet\\'s assume task was: Buy stocks on one day only. (pay attention: no sell at all!)\\nThe solution would be: find minimum of a function \\'totalProfitAfterFirstBuy\\'.\\nWhich is just go through all days and search for minimum of \\'- currPrice\\'. (cause buying stock makes our profit negative, we had \"0\"$ and now we have \"-X\"$).\\n\\nLet\\'s add second operation. The one day buy/sell solution : find minimum of a function \\'totalProfitAfterSecondSellAfterFirstBuy\\'.\\nWe will continue minimizing \\'totalProfitAfterFirstBuy\\'. But at the same time we will be minimizing \\'totalProfitAfterSecondSellAfterFirstBuy = totalProfitAfterFirstBuy + currPrice\\'. (selling gives us positive, we earn money).\\n\\nNow this solution can be applied to any number of operations. Say we were asked to minimize operations: \"Buy, Buy, Buy, Sell, Sell\".\\nTo solve it we will be minimizing profits after each op: [profitAfterOp1, profitAfterOp2, profitAfterOp3, ...].\\n\\nHope this will make it clear for everybody!\\n\\n"
                    },
                    {
                        "username": "aditichoudhary",
                        "content": "[1,2,4,2,5,7,2,4,9,0] for this input how the expected output is 13......as sets of peak valley are(V-1 P-4, V-2 P-7,V-2 P-9)  maxprofit will be =(7-2)+(9-2)"
                    },
                    {
                        "username": "ABoyNamedCrow",
                        "content": "Does it mean you can buy once and sell once, or does it mean you can buy twice and sell twice?\\n\\nNaively it seems clear the meaning should be buy once and sell once, but looking at the test cases, the other meaning seems to be what the autograder wants. Really poorly worded."
                    },
                    {
                        "username": "zhnzhang61",
                        "content": "For some of the test cases, how can a stock be priced at 0????????\\n[2,1,2,0,1]"
                    },
                    {
                        "username": "belwalrohan",
                        "content": "https://github.com/belwalrohan/August-Leetcode-Challenge/blob/master/16thAug.cpp"
                    },
                    {
                        "username": "mls__",
                        "content": "**Example 2:**\\n`Buy on day 1 (price = 1)` and at same time `Note that you cannot buy on day 1`.\\nI\\'m confused. \\n\\n\\n"
                    },
                    {
                        "username": "krishnakumar780800",
                        "content": "for the arr [1,2,3,4,5] here we buy om 1st day and sell on 5th day so profit=4 ans buy on 2nd day and sell on 4th day so profit is 2 so total profit will be 4+2=6"
                    },
                    {
                        "username": "rawbeholder",
                        "content": "You must sell the stock before buying again , so you cannot buy the stock on the 2nd day since one stock is already purchased. You need to sell the stock before buying agian."
                    }
                ]
            },
            {
                "id": 2027184,
                "content": [
                    {
                        "username": "aaryanman05",
                        "content": "I managed to do Buy and Sell stock IV and this is a special case of that program. But since my code is memoized and not bottom up DP it works there but not here and gives TLE for the last two testcases"
                    },
                    {
                        "username": "jackMar",
                        "content": "It might be helpful to clarify in the problem statement that a \"transaction\" here refers to a buy-sell pair. This could prevent confusion as the term \"transaction\" in financial contexts often refers to an individual buy or sell. Specifying that \"at most two buy/sell transaction pairs are allowed\" might make the rules more clear."
                    },
                    {
                        "username": "gadmo",
                        "content": "Kind of autopilot dp, 2 minutes work , really nothing here to call this \"hard\"  defiantly easier than most medium dp  problems."
                    },
                    {
                        "username": "riya1901",
                        "content": "class Solution {\\n public:\\nvector<int>store(int buy,int sell,vector<int>& prices,vector<int>&v){\\n\\n       \\n       if(sell==prices.size()-1)\\n       {\\n        v.push_back(prices[sell]-prices[buy]);\\n        }\\n\\n\\n             if(prices[sell+1]<=prices[sell]){\\n                v.push_back(prices[sell]-prices[buy]);\\n                store(sell+1,sell+1,prices,v);\\n                \\n            }\\n            else{\\n                store(buy,sell+1,prices,v);\\n            }\\n\\n            return v;\\n      \\n }\\n\\n\\n   int maxProfit(vector<int>& prices) {\\n        vector<int>v;\\n         store(0,0,prices,v);\\n        int n=v.size();\\n        sort(v.begin(),v.end());\\n\\n        return v[n-1]+v[n-2];\\n    \\n   }\\n };\\n\\nwhy i am getting run time error using this "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ClydeUrov",
                        "content": "broken task. The comments below confirm this."
                    },
                    {
                        "username": "paullam328",
                        "content": "Tip for y'all, the most optimal solution of this problem is derived from the most optimal solution from Best Time to Buy and Sell Stock IV for k = 2, so try out Best Time to Buy and Sell Stock IV and suffer there first and this problem is gonna be a breeze, it's more intuitive this way than that whatever state machine shit."
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `int helper(int []prices,int buy,int index,int count,int [][][]dp){\\n        if(index==prices.length||count==2){\\n            return 0;\\n        }\\n        if(dp[index][buy][count]!=-1){\\n            return dp[index][buy][count];\\n        }\\n        //two cases\\n        int ans=0;\\n        if(buy==1){\\n            int ans1=helper(prices,0,index+1,count+1,dp)+prices[index];\\n            int ans2=helper(prices,buy,index+1,count,dp);\\n            ans=Math.max(ans1,ans2);\\n        }else {\\n            int ans1=helper(prices,1,index+1,count,dp)-prices[index];\\n            int ans2=helper(prices,buy,index+1,count,dp);\\n            ans=Math.max(ans1,ans2);\\n        }\\n        return dp[index][buy][count]=ans;\\n    }\\n    public int maxProfit(int[] price) {\\n        int n=price.length;\\n        int [][][]dp=new int[n+1][2+1][2+1];\\n       for(int [][]arr:dp){\\n           for(int []arr2:arr)\\n            Arrays.fill(arr2,-1);\\n       }\\n        return helper(price,0,0,0,dp);\\n    }`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `int helper(int []prices,int buy,int index,int count,int [][][]dp){\\n        if(index==prices.length||count==2){\\n            return 0;\\n        }\\n        if(dp[index][buy][count]!=-1){\\n            return dp[index][buy][count];\\n        }\\n        //two cases\\n        int ans=0;\\n        if(buy==1){\\n            int ans1=helper(prices,0,index+1,count+1,dp)+prices[index];\\n            int ans2=helper(prices,buy,index+1,count,dp);\\n            ans=Math.max(ans1,ans2);\\n        }else {\\n            int ans1=helper(prices,1,index+1,count,dp)-prices[index];\\n            int ans2=helper(prices,buy,index+1,count,dp);\\n            ans=Math.max(ans1,ans2);\\n        }\\n        return dp[index][buy][count]=ans;\\n    }\\n    public int maxProfit(int[] price) {\\n        int n=price.length;\\n        int [][][]dp=new int[n+1][2+1][2+1];\\n       for(int [][]arr:dp){\\n           for(int []arr2:arr)\\n            Arrays.fill(arr2,-1);\\n       }\\n        return helper(price,0,0,0,dp);\\n    }`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "#pragma GCC optimize(\"Ofast,unroll-loops\")\\n#pragma GCC target(\"avx2,tune=native\")\\n\\nauto _ = [](){\\n    cin.tie(0)->sync_with_stdio(0);\\n    return 0;\\n}();\\n\\n\\n\\nclass Solution {\\npublic:\\n    \\n    int maxProfit(vector<int>& price){\\n\\n    int n= price.size();\\n    \\n    if(n==0 || n==1){\\n     return 0;\\n    }\\n\\n    int *left  = new int[n+1];\\n    int minl=price[0];\\n    left[0]=0;\\n\\n    for(int i=1;i<n;i++){\\n        left[i] = max(left[i-1],price[i]-minl);\\n        minl = min(minl,price[i]);\\n\\n    }\\n    int right =0,maxr=0,ans=0;\\n\\n    //reverse traverse\\n\\n    for(int i=n-1;i>=0;i--){\\n        right = max(right,maxr-price[i]);\\n        maxr = max(maxr,price[i]);\\n        ans = max(ans,left[i]+right); //calcualate profit\\n    }\\n\\n    return ans;\\n}\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "can we buy and also sell on the same day?"
                    },
                    {
                        "username": "user8928Vy",
                        "content": "[@magnetics](/magnetics) Was looking for this! Thanks!"
                    },
                    {
                        "username": "magnetics",
                        "content": "Suppose if you buy on day \\'d1\\' then sell it on day \\'d2\\' then buy again on day \\'d2\\', and then sell on some other day \\'d3\\', your overall profit for day \\'d2\\' will be canceled out as =>\\n(prices[d3] - prices[d2]) + (prices[d2] - prices[d1]) = prices[d3] - prices[d1]\\nTherefore selling and buying on same day made no difference at all.\\nHope it clarifies :P"
                    }
                ]
            },
            {
                "id": 2005609,
                "content": [
                    {
                        "username": "aaryanman05",
                        "content": "I managed to do Buy and Sell stock IV and this is a special case of that program. But since my code is memoized and not bottom up DP it works there but not here and gives TLE for the last two testcases"
                    },
                    {
                        "username": "jackMar",
                        "content": "It might be helpful to clarify in the problem statement that a \"transaction\" here refers to a buy-sell pair. This could prevent confusion as the term \"transaction\" in financial contexts often refers to an individual buy or sell. Specifying that \"at most two buy/sell transaction pairs are allowed\" might make the rules more clear."
                    },
                    {
                        "username": "gadmo",
                        "content": "Kind of autopilot dp, 2 minutes work , really nothing here to call this \"hard\"  defiantly easier than most medium dp  problems."
                    },
                    {
                        "username": "riya1901",
                        "content": "class Solution {\\n public:\\nvector<int>store(int buy,int sell,vector<int>& prices,vector<int>&v){\\n\\n       \\n       if(sell==prices.size()-1)\\n       {\\n        v.push_back(prices[sell]-prices[buy]);\\n        }\\n\\n\\n             if(prices[sell+1]<=prices[sell]){\\n                v.push_back(prices[sell]-prices[buy]);\\n                store(sell+1,sell+1,prices,v);\\n                \\n            }\\n            else{\\n                store(buy,sell+1,prices,v);\\n            }\\n\\n            return v;\\n      \\n }\\n\\n\\n   int maxProfit(vector<int>& prices) {\\n        vector<int>v;\\n         store(0,0,prices,v);\\n        int n=v.size();\\n        sort(v.begin(),v.end());\\n\\n        return v[n-1]+v[n-2];\\n    \\n   }\\n };\\n\\nwhy i am getting run time error using this "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ClydeUrov",
                        "content": "broken task. The comments below confirm this."
                    },
                    {
                        "username": "paullam328",
                        "content": "Tip for y'all, the most optimal solution of this problem is derived from the most optimal solution from Best Time to Buy and Sell Stock IV for k = 2, so try out Best Time to Buy and Sell Stock IV and suffer there first and this problem is gonna be a breeze, it's more intuitive this way than that whatever state machine shit."
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `int helper(int []prices,int buy,int index,int count,int [][][]dp){\\n        if(index==prices.length||count==2){\\n            return 0;\\n        }\\n        if(dp[index][buy][count]!=-1){\\n            return dp[index][buy][count];\\n        }\\n        //two cases\\n        int ans=0;\\n        if(buy==1){\\n            int ans1=helper(prices,0,index+1,count+1,dp)+prices[index];\\n            int ans2=helper(prices,buy,index+1,count,dp);\\n            ans=Math.max(ans1,ans2);\\n        }else {\\n            int ans1=helper(prices,1,index+1,count,dp)-prices[index];\\n            int ans2=helper(prices,buy,index+1,count,dp);\\n            ans=Math.max(ans1,ans2);\\n        }\\n        return dp[index][buy][count]=ans;\\n    }\\n    public int maxProfit(int[] price) {\\n        int n=price.length;\\n        int [][][]dp=new int[n+1][2+1][2+1];\\n       for(int [][]arr:dp){\\n           for(int []arr2:arr)\\n            Arrays.fill(arr2,-1);\\n       }\\n        return helper(price,0,0,0,dp);\\n    }`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `int helper(int []prices,int buy,int index,int count,int [][][]dp){\\n        if(index==prices.length||count==2){\\n            return 0;\\n        }\\n        if(dp[index][buy][count]!=-1){\\n            return dp[index][buy][count];\\n        }\\n        //two cases\\n        int ans=0;\\n        if(buy==1){\\n            int ans1=helper(prices,0,index+1,count+1,dp)+prices[index];\\n            int ans2=helper(prices,buy,index+1,count,dp);\\n            ans=Math.max(ans1,ans2);\\n        }else {\\n            int ans1=helper(prices,1,index+1,count,dp)-prices[index];\\n            int ans2=helper(prices,buy,index+1,count,dp);\\n            ans=Math.max(ans1,ans2);\\n        }\\n        return dp[index][buy][count]=ans;\\n    }\\n    public int maxProfit(int[] price) {\\n        int n=price.length;\\n        int [][][]dp=new int[n+1][2+1][2+1];\\n       for(int [][]arr:dp){\\n           for(int []arr2:arr)\\n            Arrays.fill(arr2,-1);\\n       }\\n        return helper(price,0,0,0,dp);\\n    }`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "#pragma GCC optimize(\"Ofast,unroll-loops\")\\n#pragma GCC target(\"avx2,tune=native\")\\n\\nauto _ = [](){\\n    cin.tie(0)->sync_with_stdio(0);\\n    return 0;\\n}();\\n\\n\\n\\nclass Solution {\\npublic:\\n    \\n    int maxProfit(vector<int>& price){\\n\\n    int n= price.size();\\n    \\n    if(n==0 || n==1){\\n     return 0;\\n    }\\n\\n    int *left  = new int[n+1];\\n    int minl=price[0];\\n    left[0]=0;\\n\\n    for(int i=1;i<n;i++){\\n        left[i] = max(left[i-1],price[i]-minl);\\n        minl = min(minl,price[i]);\\n\\n    }\\n    int right =0,maxr=0,ans=0;\\n\\n    //reverse traverse\\n\\n    for(int i=n-1;i>=0;i--){\\n        right = max(right,maxr-price[i]);\\n        maxr = max(maxr,price[i]);\\n        ans = max(ans,left[i]+right); //calcualate profit\\n    }\\n\\n    return ans;\\n}\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "can we buy and also sell on the same day?"
                    },
                    {
                        "username": "user8928Vy",
                        "content": "[@magnetics](/magnetics) Was looking for this! Thanks!"
                    },
                    {
                        "username": "magnetics",
                        "content": "Suppose if you buy on day \\'d1\\' then sell it on day \\'d2\\' then buy again on day \\'d2\\', and then sell on some other day \\'d3\\', your overall profit for day \\'d2\\' will be canceled out as =>\\n(prices[d3] - prices[d2]) + (prices[d2] - prices[d1]) = prices[d3] - prices[d1]\\nTherefore selling and buying on same day made no difference at all.\\nHope it clarifies :P"
                    }
                ]
            },
            {
                "id": 1957289,
                "content": [
                    {
                        "username": "aaryanman05",
                        "content": "I managed to do Buy and Sell stock IV and this is a special case of that program. But since my code is memoized and not bottom up DP it works there but not here and gives TLE for the last two testcases"
                    },
                    {
                        "username": "jackMar",
                        "content": "It might be helpful to clarify in the problem statement that a \"transaction\" here refers to a buy-sell pair. This could prevent confusion as the term \"transaction\" in financial contexts often refers to an individual buy or sell. Specifying that \"at most two buy/sell transaction pairs are allowed\" might make the rules more clear."
                    },
                    {
                        "username": "gadmo",
                        "content": "Kind of autopilot dp, 2 minutes work , really nothing here to call this \"hard\"  defiantly easier than most medium dp  problems."
                    },
                    {
                        "username": "riya1901",
                        "content": "class Solution {\\n public:\\nvector<int>store(int buy,int sell,vector<int>& prices,vector<int>&v){\\n\\n       \\n       if(sell==prices.size()-1)\\n       {\\n        v.push_back(prices[sell]-prices[buy]);\\n        }\\n\\n\\n             if(prices[sell+1]<=prices[sell]){\\n                v.push_back(prices[sell]-prices[buy]);\\n                store(sell+1,sell+1,prices,v);\\n                \\n            }\\n            else{\\n                store(buy,sell+1,prices,v);\\n            }\\n\\n            return v;\\n      \\n }\\n\\n\\n   int maxProfit(vector<int>& prices) {\\n        vector<int>v;\\n         store(0,0,prices,v);\\n        int n=v.size();\\n        sort(v.begin(),v.end());\\n\\n        return v[n-1]+v[n-2];\\n    \\n   }\\n };\\n\\nwhy i am getting run time error using this "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ClydeUrov",
                        "content": "broken task. The comments below confirm this."
                    },
                    {
                        "username": "paullam328",
                        "content": "Tip for y'all, the most optimal solution of this problem is derived from the most optimal solution from Best Time to Buy and Sell Stock IV for k = 2, so try out Best Time to Buy and Sell Stock IV and suffer there first and this problem is gonna be a breeze, it's more intuitive this way than that whatever state machine shit."
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `int helper(int []prices,int buy,int index,int count,int [][][]dp){\\n        if(index==prices.length||count==2){\\n            return 0;\\n        }\\n        if(dp[index][buy][count]!=-1){\\n            return dp[index][buy][count];\\n        }\\n        //two cases\\n        int ans=0;\\n        if(buy==1){\\n            int ans1=helper(prices,0,index+1,count+1,dp)+prices[index];\\n            int ans2=helper(prices,buy,index+1,count,dp);\\n            ans=Math.max(ans1,ans2);\\n        }else {\\n            int ans1=helper(prices,1,index+1,count,dp)-prices[index];\\n            int ans2=helper(prices,buy,index+1,count,dp);\\n            ans=Math.max(ans1,ans2);\\n        }\\n        return dp[index][buy][count]=ans;\\n    }\\n    public int maxProfit(int[] price) {\\n        int n=price.length;\\n        int [][][]dp=new int[n+1][2+1][2+1];\\n       for(int [][]arr:dp){\\n           for(int []arr2:arr)\\n            Arrays.fill(arr2,-1);\\n       }\\n        return helper(price,0,0,0,dp);\\n    }`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `int helper(int []prices,int buy,int index,int count,int [][][]dp){\\n        if(index==prices.length||count==2){\\n            return 0;\\n        }\\n        if(dp[index][buy][count]!=-1){\\n            return dp[index][buy][count];\\n        }\\n        //two cases\\n        int ans=0;\\n        if(buy==1){\\n            int ans1=helper(prices,0,index+1,count+1,dp)+prices[index];\\n            int ans2=helper(prices,buy,index+1,count,dp);\\n            ans=Math.max(ans1,ans2);\\n        }else {\\n            int ans1=helper(prices,1,index+1,count,dp)-prices[index];\\n            int ans2=helper(prices,buy,index+1,count,dp);\\n            ans=Math.max(ans1,ans2);\\n        }\\n        return dp[index][buy][count]=ans;\\n    }\\n    public int maxProfit(int[] price) {\\n        int n=price.length;\\n        int [][][]dp=new int[n+1][2+1][2+1];\\n       for(int [][]arr:dp){\\n           for(int []arr2:arr)\\n            Arrays.fill(arr2,-1);\\n       }\\n        return helper(price,0,0,0,dp);\\n    }`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "#pragma GCC optimize(\"Ofast,unroll-loops\")\\n#pragma GCC target(\"avx2,tune=native\")\\n\\nauto _ = [](){\\n    cin.tie(0)->sync_with_stdio(0);\\n    return 0;\\n}();\\n\\n\\n\\nclass Solution {\\npublic:\\n    \\n    int maxProfit(vector<int>& price){\\n\\n    int n= price.size();\\n    \\n    if(n==0 || n==1){\\n     return 0;\\n    }\\n\\n    int *left  = new int[n+1];\\n    int minl=price[0];\\n    left[0]=0;\\n\\n    for(int i=1;i<n;i++){\\n        left[i] = max(left[i-1],price[i]-minl);\\n        minl = min(minl,price[i]);\\n\\n    }\\n    int right =0,maxr=0,ans=0;\\n\\n    //reverse traverse\\n\\n    for(int i=n-1;i>=0;i--){\\n        right = max(right,maxr-price[i]);\\n        maxr = max(maxr,price[i]);\\n        ans = max(ans,left[i]+right); //calcualate profit\\n    }\\n\\n    return ans;\\n}\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "can we buy and also sell on the same day?"
                    },
                    {
                        "username": "user8928Vy",
                        "content": "[@magnetics](/magnetics) Was looking for this! Thanks!"
                    },
                    {
                        "username": "magnetics",
                        "content": "Suppose if you buy on day \\'d1\\' then sell it on day \\'d2\\' then buy again on day \\'d2\\', and then sell on some other day \\'d3\\', your overall profit for day \\'d2\\' will be canceled out as =>\\n(prices[d3] - prices[d2]) + (prices[d2] - prices[d1]) = prices[d3] - prices[d1]\\nTherefore selling and buying on same day made no difference at all.\\nHope it clarifies :P"
                    }
                ]
            },
            {
                "id": 1953746,
                "content": [
                    {
                        "username": "aaryanman05",
                        "content": "I managed to do Buy and Sell stock IV and this is a special case of that program. But since my code is memoized and not bottom up DP it works there but not here and gives TLE for the last two testcases"
                    },
                    {
                        "username": "jackMar",
                        "content": "It might be helpful to clarify in the problem statement that a \"transaction\" here refers to a buy-sell pair. This could prevent confusion as the term \"transaction\" in financial contexts often refers to an individual buy or sell. Specifying that \"at most two buy/sell transaction pairs are allowed\" might make the rules more clear."
                    },
                    {
                        "username": "gadmo",
                        "content": "Kind of autopilot dp, 2 minutes work , really nothing here to call this \"hard\"  defiantly easier than most medium dp  problems."
                    },
                    {
                        "username": "riya1901",
                        "content": "class Solution {\\n public:\\nvector<int>store(int buy,int sell,vector<int>& prices,vector<int>&v){\\n\\n       \\n       if(sell==prices.size()-1)\\n       {\\n        v.push_back(prices[sell]-prices[buy]);\\n        }\\n\\n\\n             if(prices[sell+1]<=prices[sell]){\\n                v.push_back(prices[sell]-prices[buy]);\\n                store(sell+1,sell+1,prices,v);\\n                \\n            }\\n            else{\\n                store(buy,sell+1,prices,v);\\n            }\\n\\n            return v;\\n      \\n }\\n\\n\\n   int maxProfit(vector<int>& prices) {\\n        vector<int>v;\\n         store(0,0,prices,v);\\n        int n=v.size();\\n        sort(v.begin(),v.end());\\n\\n        return v[n-1]+v[n-2];\\n    \\n   }\\n };\\n\\nwhy i am getting run time error using this "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ClydeUrov",
                        "content": "broken task. The comments below confirm this."
                    },
                    {
                        "username": "paullam328",
                        "content": "Tip for y'all, the most optimal solution of this problem is derived from the most optimal solution from Best Time to Buy and Sell Stock IV for k = 2, so try out Best Time to Buy and Sell Stock IV and suffer there first and this problem is gonna be a breeze, it's more intuitive this way than that whatever state machine shit."
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `int helper(int []prices,int buy,int index,int count,int [][][]dp){\\n        if(index==prices.length||count==2){\\n            return 0;\\n        }\\n        if(dp[index][buy][count]!=-1){\\n            return dp[index][buy][count];\\n        }\\n        //two cases\\n        int ans=0;\\n        if(buy==1){\\n            int ans1=helper(prices,0,index+1,count+1,dp)+prices[index];\\n            int ans2=helper(prices,buy,index+1,count,dp);\\n            ans=Math.max(ans1,ans2);\\n        }else {\\n            int ans1=helper(prices,1,index+1,count,dp)-prices[index];\\n            int ans2=helper(prices,buy,index+1,count,dp);\\n            ans=Math.max(ans1,ans2);\\n        }\\n        return dp[index][buy][count]=ans;\\n    }\\n    public int maxProfit(int[] price) {\\n        int n=price.length;\\n        int [][][]dp=new int[n+1][2+1][2+1];\\n       for(int [][]arr:dp){\\n           for(int []arr2:arr)\\n            Arrays.fill(arr2,-1);\\n       }\\n        return helper(price,0,0,0,dp);\\n    }`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `int helper(int []prices,int buy,int index,int count,int [][][]dp){\\n        if(index==prices.length||count==2){\\n            return 0;\\n        }\\n        if(dp[index][buy][count]!=-1){\\n            return dp[index][buy][count];\\n        }\\n        //two cases\\n        int ans=0;\\n        if(buy==1){\\n            int ans1=helper(prices,0,index+1,count+1,dp)+prices[index];\\n            int ans2=helper(prices,buy,index+1,count,dp);\\n            ans=Math.max(ans1,ans2);\\n        }else {\\n            int ans1=helper(prices,1,index+1,count,dp)-prices[index];\\n            int ans2=helper(prices,buy,index+1,count,dp);\\n            ans=Math.max(ans1,ans2);\\n        }\\n        return dp[index][buy][count]=ans;\\n    }\\n    public int maxProfit(int[] price) {\\n        int n=price.length;\\n        int [][][]dp=new int[n+1][2+1][2+1];\\n       for(int [][]arr:dp){\\n           for(int []arr2:arr)\\n            Arrays.fill(arr2,-1);\\n       }\\n        return helper(price,0,0,0,dp);\\n    }`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "#pragma GCC optimize(\"Ofast,unroll-loops\")\\n#pragma GCC target(\"avx2,tune=native\")\\n\\nauto _ = [](){\\n    cin.tie(0)->sync_with_stdio(0);\\n    return 0;\\n}();\\n\\n\\n\\nclass Solution {\\npublic:\\n    \\n    int maxProfit(vector<int>& price){\\n\\n    int n= price.size();\\n    \\n    if(n==0 || n==1){\\n     return 0;\\n    }\\n\\n    int *left  = new int[n+1];\\n    int minl=price[0];\\n    left[0]=0;\\n\\n    for(int i=1;i<n;i++){\\n        left[i] = max(left[i-1],price[i]-minl);\\n        minl = min(minl,price[i]);\\n\\n    }\\n    int right =0,maxr=0,ans=0;\\n\\n    //reverse traverse\\n\\n    for(int i=n-1;i>=0;i--){\\n        right = max(right,maxr-price[i]);\\n        maxr = max(maxr,price[i]);\\n        ans = max(ans,left[i]+right); //calcualate profit\\n    }\\n\\n    return ans;\\n}\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "can we buy and also sell on the same day?"
                    },
                    {
                        "username": "user8928Vy",
                        "content": "[@magnetics](/magnetics) Was looking for this! Thanks!"
                    },
                    {
                        "username": "magnetics",
                        "content": "Suppose if you buy on day \\'d1\\' then sell it on day \\'d2\\' then buy again on day \\'d2\\', and then sell on some other day \\'d3\\', your overall profit for day \\'d2\\' will be canceled out as =>\\n(prices[d3] - prices[d2]) + (prices[d2] - prices[d1]) = prices[d3] - prices[d1]\\nTherefore selling and buying on same day made no difference at all.\\nHope it clarifies :P"
                    }
                ]
            },
            {
                "id": 1923848,
                "content": [
                    {
                        "username": "aaryanman05",
                        "content": "I managed to do Buy and Sell stock IV and this is a special case of that program. But since my code is memoized and not bottom up DP it works there but not here and gives TLE for the last two testcases"
                    },
                    {
                        "username": "jackMar",
                        "content": "It might be helpful to clarify in the problem statement that a \"transaction\" here refers to a buy-sell pair. This could prevent confusion as the term \"transaction\" in financial contexts often refers to an individual buy or sell. Specifying that \"at most two buy/sell transaction pairs are allowed\" might make the rules more clear."
                    },
                    {
                        "username": "gadmo",
                        "content": "Kind of autopilot dp, 2 minutes work , really nothing here to call this \"hard\"  defiantly easier than most medium dp  problems."
                    },
                    {
                        "username": "riya1901",
                        "content": "class Solution {\\n public:\\nvector<int>store(int buy,int sell,vector<int>& prices,vector<int>&v){\\n\\n       \\n       if(sell==prices.size()-1)\\n       {\\n        v.push_back(prices[sell]-prices[buy]);\\n        }\\n\\n\\n             if(prices[sell+1]<=prices[sell]){\\n                v.push_back(prices[sell]-prices[buy]);\\n                store(sell+1,sell+1,prices,v);\\n                \\n            }\\n            else{\\n                store(buy,sell+1,prices,v);\\n            }\\n\\n            return v;\\n      \\n }\\n\\n\\n   int maxProfit(vector<int>& prices) {\\n        vector<int>v;\\n         store(0,0,prices,v);\\n        int n=v.size();\\n        sort(v.begin(),v.end());\\n\\n        return v[n-1]+v[n-2];\\n    \\n   }\\n };\\n\\nwhy i am getting run time error using this "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ClydeUrov",
                        "content": "broken task. The comments below confirm this."
                    },
                    {
                        "username": "paullam328",
                        "content": "Tip for y'all, the most optimal solution of this problem is derived from the most optimal solution from Best Time to Buy and Sell Stock IV for k = 2, so try out Best Time to Buy and Sell Stock IV and suffer there first and this problem is gonna be a breeze, it's more intuitive this way than that whatever state machine shit."
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `int helper(int []prices,int buy,int index,int count,int [][][]dp){\\n        if(index==prices.length||count==2){\\n            return 0;\\n        }\\n        if(dp[index][buy][count]!=-1){\\n            return dp[index][buy][count];\\n        }\\n        //two cases\\n        int ans=0;\\n        if(buy==1){\\n            int ans1=helper(prices,0,index+1,count+1,dp)+prices[index];\\n            int ans2=helper(prices,buy,index+1,count,dp);\\n            ans=Math.max(ans1,ans2);\\n        }else {\\n            int ans1=helper(prices,1,index+1,count,dp)-prices[index];\\n            int ans2=helper(prices,buy,index+1,count,dp);\\n            ans=Math.max(ans1,ans2);\\n        }\\n        return dp[index][buy][count]=ans;\\n    }\\n    public int maxProfit(int[] price) {\\n        int n=price.length;\\n        int [][][]dp=new int[n+1][2+1][2+1];\\n       for(int [][]arr:dp){\\n           for(int []arr2:arr)\\n            Arrays.fill(arr2,-1);\\n       }\\n        return helper(price,0,0,0,dp);\\n    }`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `int helper(int []prices,int buy,int index,int count,int [][][]dp){\\n        if(index==prices.length||count==2){\\n            return 0;\\n        }\\n        if(dp[index][buy][count]!=-1){\\n            return dp[index][buy][count];\\n        }\\n        //two cases\\n        int ans=0;\\n        if(buy==1){\\n            int ans1=helper(prices,0,index+1,count+1,dp)+prices[index];\\n            int ans2=helper(prices,buy,index+1,count,dp);\\n            ans=Math.max(ans1,ans2);\\n        }else {\\n            int ans1=helper(prices,1,index+1,count,dp)-prices[index];\\n            int ans2=helper(prices,buy,index+1,count,dp);\\n            ans=Math.max(ans1,ans2);\\n        }\\n        return dp[index][buy][count]=ans;\\n    }\\n    public int maxProfit(int[] price) {\\n        int n=price.length;\\n        int [][][]dp=new int[n+1][2+1][2+1];\\n       for(int [][]arr:dp){\\n           for(int []arr2:arr)\\n            Arrays.fill(arr2,-1);\\n       }\\n        return helper(price,0,0,0,dp);\\n    }`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "#pragma GCC optimize(\"Ofast,unroll-loops\")\\n#pragma GCC target(\"avx2,tune=native\")\\n\\nauto _ = [](){\\n    cin.tie(0)->sync_with_stdio(0);\\n    return 0;\\n}();\\n\\n\\n\\nclass Solution {\\npublic:\\n    \\n    int maxProfit(vector<int>& price){\\n\\n    int n= price.size();\\n    \\n    if(n==0 || n==1){\\n     return 0;\\n    }\\n\\n    int *left  = new int[n+1];\\n    int minl=price[0];\\n    left[0]=0;\\n\\n    for(int i=1;i<n;i++){\\n        left[i] = max(left[i-1],price[i]-minl);\\n        minl = min(minl,price[i]);\\n\\n    }\\n    int right =0,maxr=0,ans=0;\\n\\n    //reverse traverse\\n\\n    for(int i=n-1;i>=0;i--){\\n        right = max(right,maxr-price[i]);\\n        maxr = max(maxr,price[i]);\\n        ans = max(ans,left[i]+right); //calcualate profit\\n    }\\n\\n    return ans;\\n}\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "can we buy and also sell on the same day?"
                    },
                    {
                        "username": "user8928Vy",
                        "content": "[@magnetics](/magnetics) Was looking for this! Thanks!"
                    },
                    {
                        "username": "magnetics",
                        "content": "Suppose if you buy on day \\'d1\\' then sell it on day \\'d2\\' then buy again on day \\'d2\\', and then sell on some other day \\'d3\\', your overall profit for day \\'d2\\' will be canceled out as =>\\n(prices[d3] - prices[d2]) + (prices[d2] - prices[d1]) = prices[d3] - prices[d1]\\nTherefore selling and buying on same day made no difference at all.\\nHope it clarifies :P"
                    }
                ]
            },
            {
                "id": 1840568,
                "content": [
                    {
                        "username": "aaryanman05",
                        "content": "I managed to do Buy and Sell stock IV and this is a special case of that program. But since my code is memoized and not bottom up DP it works there but not here and gives TLE for the last two testcases"
                    },
                    {
                        "username": "jackMar",
                        "content": "It might be helpful to clarify in the problem statement that a \"transaction\" here refers to a buy-sell pair. This could prevent confusion as the term \"transaction\" in financial contexts often refers to an individual buy or sell. Specifying that \"at most two buy/sell transaction pairs are allowed\" might make the rules more clear."
                    },
                    {
                        "username": "gadmo",
                        "content": "Kind of autopilot dp, 2 minutes work , really nothing here to call this \"hard\"  defiantly easier than most medium dp  problems."
                    },
                    {
                        "username": "riya1901",
                        "content": "class Solution {\\n public:\\nvector<int>store(int buy,int sell,vector<int>& prices,vector<int>&v){\\n\\n       \\n       if(sell==prices.size()-1)\\n       {\\n        v.push_back(prices[sell]-prices[buy]);\\n        }\\n\\n\\n             if(prices[sell+1]<=prices[sell]){\\n                v.push_back(prices[sell]-prices[buy]);\\n                store(sell+1,sell+1,prices,v);\\n                \\n            }\\n            else{\\n                store(buy,sell+1,prices,v);\\n            }\\n\\n            return v;\\n      \\n }\\n\\n\\n   int maxProfit(vector<int>& prices) {\\n        vector<int>v;\\n         store(0,0,prices,v);\\n        int n=v.size();\\n        sort(v.begin(),v.end());\\n\\n        return v[n-1]+v[n-2];\\n    \\n   }\\n };\\n\\nwhy i am getting run time error using this "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ClydeUrov",
                        "content": "broken task. The comments below confirm this."
                    },
                    {
                        "username": "paullam328",
                        "content": "Tip for y'all, the most optimal solution of this problem is derived from the most optimal solution from Best Time to Buy and Sell Stock IV for k = 2, so try out Best Time to Buy and Sell Stock IV and suffer there first and this problem is gonna be a breeze, it's more intuitive this way than that whatever state machine shit."
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `int helper(int []prices,int buy,int index,int count,int [][][]dp){\\n        if(index==prices.length||count==2){\\n            return 0;\\n        }\\n        if(dp[index][buy][count]!=-1){\\n            return dp[index][buy][count];\\n        }\\n        //two cases\\n        int ans=0;\\n        if(buy==1){\\n            int ans1=helper(prices,0,index+1,count+1,dp)+prices[index];\\n            int ans2=helper(prices,buy,index+1,count,dp);\\n            ans=Math.max(ans1,ans2);\\n        }else {\\n            int ans1=helper(prices,1,index+1,count,dp)-prices[index];\\n            int ans2=helper(prices,buy,index+1,count,dp);\\n            ans=Math.max(ans1,ans2);\\n        }\\n        return dp[index][buy][count]=ans;\\n    }\\n    public int maxProfit(int[] price) {\\n        int n=price.length;\\n        int [][][]dp=new int[n+1][2+1][2+1];\\n       for(int [][]arr:dp){\\n           for(int []arr2:arr)\\n            Arrays.fill(arr2,-1);\\n       }\\n        return helper(price,0,0,0,dp);\\n    }`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `int helper(int []prices,int buy,int index,int count,int [][][]dp){\\n        if(index==prices.length||count==2){\\n            return 0;\\n        }\\n        if(dp[index][buy][count]!=-1){\\n            return dp[index][buy][count];\\n        }\\n        //two cases\\n        int ans=0;\\n        if(buy==1){\\n            int ans1=helper(prices,0,index+1,count+1,dp)+prices[index];\\n            int ans2=helper(prices,buy,index+1,count,dp);\\n            ans=Math.max(ans1,ans2);\\n        }else {\\n            int ans1=helper(prices,1,index+1,count,dp)-prices[index];\\n            int ans2=helper(prices,buy,index+1,count,dp);\\n            ans=Math.max(ans1,ans2);\\n        }\\n        return dp[index][buy][count]=ans;\\n    }\\n    public int maxProfit(int[] price) {\\n        int n=price.length;\\n        int [][][]dp=new int[n+1][2+1][2+1];\\n       for(int [][]arr:dp){\\n           for(int []arr2:arr)\\n            Arrays.fill(arr2,-1);\\n       }\\n        return helper(price,0,0,0,dp);\\n    }`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "#pragma GCC optimize(\"Ofast,unroll-loops\")\\n#pragma GCC target(\"avx2,tune=native\")\\n\\nauto _ = [](){\\n    cin.tie(0)->sync_with_stdio(0);\\n    return 0;\\n}();\\n\\n\\n\\nclass Solution {\\npublic:\\n    \\n    int maxProfit(vector<int>& price){\\n\\n    int n= price.size();\\n    \\n    if(n==0 || n==1){\\n     return 0;\\n    }\\n\\n    int *left  = new int[n+1];\\n    int minl=price[0];\\n    left[0]=0;\\n\\n    for(int i=1;i<n;i++){\\n        left[i] = max(left[i-1],price[i]-minl);\\n        minl = min(minl,price[i]);\\n\\n    }\\n    int right =0,maxr=0,ans=0;\\n\\n    //reverse traverse\\n\\n    for(int i=n-1;i>=0;i--){\\n        right = max(right,maxr-price[i]);\\n        maxr = max(maxr,price[i]);\\n        ans = max(ans,left[i]+right); //calcualate profit\\n    }\\n\\n    return ans;\\n}\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "can we buy and also sell on the same day?"
                    },
                    {
                        "username": "user8928Vy",
                        "content": "[@magnetics](/magnetics) Was looking for this! Thanks!"
                    },
                    {
                        "username": "magnetics",
                        "content": "Suppose if you buy on day \\'d1\\' then sell it on day \\'d2\\' then buy again on day \\'d2\\', and then sell on some other day \\'d3\\', your overall profit for day \\'d2\\' will be canceled out as =>\\n(prices[d3] - prices[d2]) + (prices[d2] - prices[d1]) = prices[d3] - prices[d1]\\nTherefore selling and buying on same day made no difference at all.\\nHope it clarifies :P"
                    }
                ]
            },
            {
                "id": 1815359,
                "content": [
                    {
                        "username": "aaryanman05",
                        "content": "I managed to do Buy and Sell stock IV and this is a special case of that program. But since my code is memoized and not bottom up DP it works there but not here and gives TLE for the last two testcases"
                    },
                    {
                        "username": "jackMar",
                        "content": "It might be helpful to clarify in the problem statement that a \"transaction\" here refers to a buy-sell pair. This could prevent confusion as the term \"transaction\" in financial contexts often refers to an individual buy or sell. Specifying that \"at most two buy/sell transaction pairs are allowed\" might make the rules more clear."
                    },
                    {
                        "username": "gadmo",
                        "content": "Kind of autopilot dp, 2 minutes work , really nothing here to call this \"hard\"  defiantly easier than most medium dp  problems."
                    },
                    {
                        "username": "riya1901",
                        "content": "class Solution {\\n public:\\nvector<int>store(int buy,int sell,vector<int>& prices,vector<int>&v){\\n\\n       \\n       if(sell==prices.size()-1)\\n       {\\n        v.push_back(prices[sell]-prices[buy]);\\n        }\\n\\n\\n             if(prices[sell+1]<=prices[sell]){\\n                v.push_back(prices[sell]-prices[buy]);\\n                store(sell+1,sell+1,prices,v);\\n                \\n            }\\n            else{\\n                store(buy,sell+1,prices,v);\\n            }\\n\\n            return v;\\n      \\n }\\n\\n\\n   int maxProfit(vector<int>& prices) {\\n        vector<int>v;\\n         store(0,0,prices,v);\\n        int n=v.size();\\n        sort(v.begin(),v.end());\\n\\n        return v[n-1]+v[n-2];\\n    \\n   }\\n };\\n\\nwhy i am getting run time error using this "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ClydeUrov",
                        "content": "broken task. The comments below confirm this."
                    },
                    {
                        "username": "paullam328",
                        "content": "Tip for y'all, the most optimal solution of this problem is derived from the most optimal solution from Best Time to Buy and Sell Stock IV for k = 2, so try out Best Time to Buy and Sell Stock IV and suffer there first and this problem is gonna be a breeze, it's more intuitive this way than that whatever state machine shit."
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `int helper(int []prices,int buy,int index,int count,int [][][]dp){\\n        if(index==prices.length||count==2){\\n            return 0;\\n        }\\n        if(dp[index][buy][count]!=-1){\\n            return dp[index][buy][count];\\n        }\\n        //two cases\\n        int ans=0;\\n        if(buy==1){\\n            int ans1=helper(prices,0,index+1,count+1,dp)+prices[index];\\n            int ans2=helper(prices,buy,index+1,count,dp);\\n            ans=Math.max(ans1,ans2);\\n        }else {\\n            int ans1=helper(prices,1,index+1,count,dp)-prices[index];\\n            int ans2=helper(prices,buy,index+1,count,dp);\\n            ans=Math.max(ans1,ans2);\\n        }\\n        return dp[index][buy][count]=ans;\\n    }\\n    public int maxProfit(int[] price) {\\n        int n=price.length;\\n        int [][][]dp=new int[n+1][2+1][2+1];\\n       for(int [][]arr:dp){\\n           for(int []arr2:arr)\\n            Arrays.fill(arr2,-1);\\n       }\\n        return helper(price,0,0,0,dp);\\n    }`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `int helper(int []prices,int buy,int index,int count,int [][][]dp){\\n        if(index==prices.length||count==2){\\n            return 0;\\n        }\\n        if(dp[index][buy][count]!=-1){\\n            return dp[index][buy][count];\\n        }\\n        //two cases\\n        int ans=0;\\n        if(buy==1){\\n            int ans1=helper(prices,0,index+1,count+1,dp)+prices[index];\\n            int ans2=helper(prices,buy,index+1,count,dp);\\n            ans=Math.max(ans1,ans2);\\n        }else {\\n            int ans1=helper(prices,1,index+1,count,dp)-prices[index];\\n            int ans2=helper(prices,buy,index+1,count,dp);\\n            ans=Math.max(ans1,ans2);\\n        }\\n        return dp[index][buy][count]=ans;\\n    }\\n    public int maxProfit(int[] price) {\\n        int n=price.length;\\n        int [][][]dp=new int[n+1][2+1][2+1];\\n       for(int [][]arr:dp){\\n           for(int []arr2:arr)\\n            Arrays.fill(arr2,-1);\\n       }\\n        return helper(price,0,0,0,dp);\\n    }`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "#pragma GCC optimize(\"Ofast,unroll-loops\")\\n#pragma GCC target(\"avx2,tune=native\")\\n\\nauto _ = [](){\\n    cin.tie(0)->sync_with_stdio(0);\\n    return 0;\\n}();\\n\\n\\n\\nclass Solution {\\npublic:\\n    \\n    int maxProfit(vector<int>& price){\\n\\n    int n= price.size();\\n    \\n    if(n==0 || n==1){\\n     return 0;\\n    }\\n\\n    int *left  = new int[n+1];\\n    int minl=price[0];\\n    left[0]=0;\\n\\n    for(int i=1;i<n;i++){\\n        left[i] = max(left[i-1],price[i]-minl);\\n        minl = min(minl,price[i]);\\n\\n    }\\n    int right =0,maxr=0,ans=0;\\n\\n    //reverse traverse\\n\\n    for(int i=n-1;i>=0;i--){\\n        right = max(right,maxr-price[i]);\\n        maxr = max(maxr,price[i]);\\n        ans = max(ans,left[i]+right); //calcualate profit\\n    }\\n\\n    return ans;\\n}\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "can we buy and also sell on the same day?"
                    },
                    {
                        "username": "user8928Vy",
                        "content": "[@magnetics](/magnetics) Was looking for this! Thanks!"
                    },
                    {
                        "username": "magnetics",
                        "content": "Suppose if you buy on day \\'d1\\' then sell it on day \\'d2\\' then buy again on day \\'d2\\', and then sell on some other day \\'d3\\', your overall profit for day \\'d2\\' will be canceled out as =>\\n(prices[d3] - prices[d2]) + (prices[d2] - prices[d1]) = prices[d3] - prices[d1]\\nTherefore selling and buying on same day made no difference at all.\\nHope it clarifies :P"
                    }
                ]
            },
            {
                "id": 1815358,
                "content": [
                    {
                        "username": "aaryanman05",
                        "content": "I managed to do Buy and Sell stock IV and this is a special case of that program. But since my code is memoized and not bottom up DP it works there but not here and gives TLE for the last two testcases"
                    },
                    {
                        "username": "jackMar",
                        "content": "It might be helpful to clarify in the problem statement that a \"transaction\" here refers to a buy-sell pair. This could prevent confusion as the term \"transaction\" in financial contexts often refers to an individual buy or sell. Specifying that \"at most two buy/sell transaction pairs are allowed\" might make the rules more clear."
                    },
                    {
                        "username": "gadmo",
                        "content": "Kind of autopilot dp, 2 minutes work , really nothing here to call this \"hard\"  defiantly easier than most medium dp  problems."
                    },
                    {
                        "username": "riya1901",
                        "content": "class Solution {\\n public:\\nvector<int>store(int buy,int sell,vector<int>& prices,vector<int>&v){\\n\\n       \\n       if(sell==prices.size()-1)\\n       {\\n        v.push_back(prices[sell]-prices[buy]);\\n        }\\n\\n\\n             if(prices[sell+1]<=prices[sell]){\\n                v.push_back(prices[sell]-prices[buy]);\\n                store(sell+1,sell+1,prices,v);\\n                \\n            }\\n            else{\\n                store(buy,sell+1,prices,v);\\n            }\\n\\n            return v;\\n      \\n }\\n\\n\\n   int maxProfit(vector<int>& prices) {\\n        vector<int>v;\\n         store(0,0,prices,v);\\n        int n=v.size();\\n        sort(v.begin(),v.end());\\n\\n        return v[n-1]+v[n-2];\\n    \\n   }\\n };\\n\\nwhy i am getting run time error using this "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ClydeUrov",
                        "content": "broken task. The comments below confirm this."
                    },
                    {
                        "username": "paullam328",
                        "content": "Tip for y'all, the most optimal solution of this problem is derived from the most optimal solution from Best Time to Buy and Sell Stock IV for k = 2, so try out Best Time to Buy and Sell Stock IV and suffer there first and this problem is gonna be a breeze, it's more intuitive this way than that whatever state machine shit."
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `int helper(int []prices,int buy,int index,int count,int [][][]dp){\\n        if(index==prices.length||count==2){\\n            return 0;\\n        }\\n        if(dp[index][buy][count]!=-1){\\n            return dp[index][buy][count];\\n        }\\n        //two cases\\n        int ans=0;\\n        if(buy==1){\\n            int ans1=helper(prices,0,index+1,count+1,dp)+prices[index];\\n            int ans2=helper(prices,buy,index+1,count,dp);\\n            ans=Math.max(ans1,ans2);\\n        }else {\\n            int ans1=helper(prices,1,index+1,count,dp)-prices[index];\\n            int ans2=helper(prices,buy,index+1,count,dp);\\n            ans=Math.max(ans1,ans2);\\n        }\\n        return dp[index][buy][count]=ans;\\n    }\\n    public int maxProfit(int[] price) {\\n        int n=price.length;\\n        int [][][]dp=new int[n+1][2+1][2+1];\\n       for(int [][]arr:dp){\\n           for(int []arr2:arr)\\n            Arrays.fill(arr2,-1);\\n       }\\n        return helper(price,0,0,0,dp);\\n    }`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `int helper(int []prices,int buy,int index,int count,int [][][]dp){\\n        if(index==prices.length||count==2){\\n            return 0;\\n        }\\n        if(dp[index][buy][count]!=-1){\\n            return dp[index][buy][count];\\n        }\\n        //two cases\\n        int ans=0;\\n        if(buy==1){\\n            int ans1=helper(prices,0,index+1,count+1,dp)+prices[index];\\n            int ans2=helper(prices,buy,index+1,count,dp);\\n            ans=Math.max(ans1,ans2);\\n        }else {\\n            int ans1=helper(prices,1,index+1,count,dp)-prices[index];\\n            int ans2=helper(prices,buy,index+1,count,dp);\\n            ans=Math.max(ans1,ans2);\\n        }\\n        return dp[index][buy][count]=ans;\\n    }\\n    public int maxProfit(int[] price) {\\n        int n=price.length;\\n        int [][][]dp=new int[n+1][2+1][2+1];\\n       for(int [][]arr:dp){\\n           for(int []arr2:arr)\\n            Arrays.fill(arr2,-1);\\n       }\\n        return helper(price,0,0,0,dp);\\n    }`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "#pragma GCC optimize(\"Ofast,unroll-loops\")\\n#pragma GCC target(\"avx2,tune=native\")\\n\\nauto _ = [](){\\n    cin.tie(0)->sync_with_stdio(0);\\n    return 0;\\n}();\\n\\n\\n\\nclass Solution {\\npublic:\\n    \\n    int maxProfit(vector<int>& price){\\n\\n    int n= price.size();\\n    \\n    if(n==0 || n==1){\\n     return 0;\\n    }\\n\\n    int *left  = new int[n+1];\\n    int minl=price[0];\\n    left[0]=0;\\n\\n    for(int i=1;i<n;i++){\\n        left[i] = max(left[i-1],price[i]-minl);\\n        minl = min(minl,price[i]);\\n\\n    }\\n    int right =0,maxr=0,ans=0;\\n\\n    //reverse traverse\\n\\n    for(int i=n-1;i>=0;i--){\\n        right = max(right,maxr-price[i]);\\n        maxr = max(maxr,price[i]);\\n        ans = max(ans,left[i]+right); //calcualate profit\\n    }\\n\\n    return ans;\\n}\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "can we buy and also sell on the same day?"
                    },
                    {
                        "username": "user8928Vy",
                        "content": "[@magnetics](/magnetics) Was looking for this! Thanks!"
                    },
                    {
                        "username": "magnetics",
                        "content": "Suppose if you buy on day \\'d1\\' then sell it on day \\'d2\\' then buy again on day \\'d2\\', and then sell on some other day \\'d3\\', your overall profit for day \\'d2\\' will be canceled out as =>\\n(prices[d3] - prices[d2]) + (prices[d2] - prices[d1]) = prices[d3] - prices[d1]\\nTherefore selling and buying on same day made no difference at all.\\nHope it clarifies :P"
                    }
                ]
            },
            {
                "id": 1809680,
                "content": [
                    {
                        "username": "aaryanman05",
                        "content": "I managed to do Buy and Sell stock IV and this is a special case of that program. But since my code is memoized and not bottom up DP it works there but not here and gives TLE for the last two testcases"
                    },
                    {
                        "username": "jackMar",
                        "content": "It might be helpful to clarify in the problem statement that a \"transaction\" here refers to a buy-sell pair. This could prevent confusion as the term \"transaction\" in financial contexts often refers to an individual buy or sell. Specifying that \"at most two buy/sell transaction pairs are allowed\" might make the rules more clear."
                    },
                    {
                        "username": "gadmo",
                        "content": "Kind of autopilot dp, 2 minutes work , really nothing here to call this \"hard\"  defiantly easier than most medium dp  problems."
                    },
                    {
                        "username": "riya1901",
                        "content": "class Solution {\\n public:\\nvector<int>store(int buy,int sell,vector<int>& prices,vector<int>&v){\\n\\n       \\n       if(sell==prices.size()-1)\\n       {\\n        v.push_back(prices[sell]-prices[buy]);\\n        }\\n\\n\\n             if(prices[sell+1]<=prices[sell]){\\n                v.push_back(prices[sell]-prices[buy]);\\n                store(sell+1,sell+1,prices,v);\\n                \\n            }\\n            else{\\n                store(buy,sell+1,prices,v);\\n            }\\n\\n            return v;\\n      \\n }\\n\\n\\n   int maxProfit(vector<int>& prices) {\\n        vector<int>v;\\n         store(0,0,prices,v);\\n        int n=v.size();\\n        sort(v.begin(),v.end());\\n\\n        return v[n-1]+v[n-2];\\n    \\n   }\\n };\\n\\nwhy i am getting run time error using this "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ClydeUrov",
                        "content": "broken task. The comments below confirm this."
                    },
                    {
                        "username": "paullam328",
                        "content": "Tip for y'all, the most optimal solution of this problem is derived from the most optimal solution from Best Time to Buy and Sell Stock IV for k = 2, so try out Best Time to Buy and Sell Stock IV and suffer there first and this problem is gonna be a breeze, it's more intuitive this way than that whatever state machine shit."
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `int helper(int []prices,int buy,int index,int count,int [][][]dp){\\n        if(index==prices.length||count==2){\\n            return 0;\\n        }\\n        if(dp[index][buy][count]!=-1){\\n            return dp[index][buy][count];\\n        }\\n        //two cases\\n        int ans=0;\\n        if(buy==1){\\n            int ans1=helper(prices,0,index+1,count+1,dp)+prices[index];\\n            int ans2=helper(prices,buy,index+1,count,dp);\\n            ans=Math.max(ans1,ans2);\\n        }else {\\n            int ans1=helper(prices,1,index+1,count,dp)-prices[index];\\n            int ans2=helper(prices,buy,index+1,count,dp);\\n            ans=Math.max(ans1,ans2);\\n        }\\n        return dp[index][buy][count]=ans;\\n    }\\n    public int maxProfit(int[] price) {\\n        int n=price.length;\\n        int [][][]dp=new int[n+1][2+1][2+1];\\n       for(int [][]arr:dp){\\n           for(int []arr2:arr)\\n            Arrays.fill(arr2,-1);\\n       }\\n        return helper(price,0,0,0,dp);\\n    }`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `int helper(int []prices,int buy,int index,int count,int [][][]dp){\\n        if(index==prices.length||count==2){\\n            return 0;\\n        }\\n        if(dp[index][buy][count]!=-1){\\n            return dp[index][buy][count];\\n        }\\n        //two cases\\n        int ans=0;\\n        if(buy==1){\\n            int ans1=helper(prices,0,index+1,count+1,dp)+prices[index];\\n            int ans2=helper(prices,buy,index+1,count,dp);\\n            ans=Math.max(ans1,ans2);\\n        }else {\\n            int ans1=helper(prices,1,index+1,count,dp)-prices[index];\\n            int ans2=helper(prices,buy,index+1,count,dp);\\n            ans=Math.max(ans1,ans2);\\n        }\\n        return dp[index][buy][count]=ans;\\n    }\\n    public int maxProfit(int[] price) {\\n        int n=price.length;\\n        int [][][]dp=new int[n+1][2+1][2+1];\\n       for(int [][]arr:dp){\\n           for(int []arr2:arr)\\n            Arrays.fill(arr2,-1);\\n       }\\n        return helper(price,0,0,0,dp);\\n    }`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "#pragma GCC optimize(\"Ofast,unroll-loops\")\\n#pragma GCC target(\"avx2,tune=native\")\\n\\nauto _ = [](){\\n    cin.tie(0)->sync_with_stdio(0);\\n    return 0;\\n}();\\n\\n\\n\\nclass Solution {\\npublic:\\n    \\n    int maxProfit(vector<int>& price){\\n\\n    int n= price.size();\\n    \\n    if(n==0 || n==1){\\n     return 0;\\n    }\\n\\n    int *left  = new int[n+1];\\n    int minl=price[0];\\n    left[0]=0;\\n\\n    for(int i=1;i<n;i++){\\n        left[i] = max(left[i-1],price[i]-minl);\\n        minl = min(minl,price[i]);\\n\\n    }\\n    int right =0,maxr=0,ans=0;\\n\\n    //reverse traverse\\n\\n    for(int i=n-1;i>=0;i--){\\n        right = max(right,maxr-price[i]);\\n        maxr = max(maxr,price[i]);\\n        ans = max(ans,left[i]+right); //calcualate profit\\n    }\\n\\n    return ans;\\n}\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "can we buy and also sell on the same day?"
                    },
                    {
                        "username": "user8928Vy",
                        "content": "[@magnetics](/magnetics) Was looking for this! Thanks!"
                    },
                    {
                        "username": "magnetics",
                        "content": "Suppose if you buy on day \\'d1\\' then sell it on day \\'d2\\' then buy again on day \\'d2\\', and then sell on some other day \\'d3\\', your overall profit for day \\'d2\\' will be canceled out as =>\\n(prices[d3] - prices[d2]) + (prices[d2] - prices[d1]) = prices[d3] - prices[d1]\\nTherefore selling and buying on same day made no difference at all.\\nHope it clarifies :P"
                    }
                ]
            },
            {
                "id": 1791818,
                "content": [
                    {
                        "username": "aaryanman05",
                        "content": "I managed to do Buy and Sell stock IV and this is a special case of that program. But since my code is memoized and not bottom up DP it works there but not here and gives TLE for the last two testcases"
                    },
                    {
                        "username": "jackMar",
                        "content": "It might be helpful to clarify in the problem statement that a \"transaction\" here refers to a buy-sell pair. This could prevent confusion as the term \"transaction\" in financial contexts often refers to an individual buy or sell. Specifying that \"at most two buy/sell transaction pairs are allowed\" might make the rules more clear."
                    },
                    {
                        "username": "gadmo",
                        "content": "Kind of autopilot dp, 2 minutes work , really nothing here to call this \"hard\"  defiantly easier than most medium dp  problems."
                    },
                    {
                        "username": "riya1901",
                        "content": "class Solution {\\n public:\\nvector<int>store(int buy,int sell,vector<int>& prices,vector<int>&v){\\n\\n       \\n       if(sell==prices.size()-1)\\n       {\\n        v.push_back(prices[sell]-prices[buy]);\\n        }\\n\\n\\n             if(prices[sell+1]<=prices[sell]){\\n                v.push_back(prices[sell]-prices[buy]);\\n                store(sell+1,sell+1,prices,v);\\n                \\n            }\\n            else{\\n                store(buy,sell+1,prices,v);\\n            }\\n\\n            return v;\\n      \\n }\\n\\n\\n   int maxProfit(vector<int>& prices) {\\n        vector<int>v;\\n         store(0,0,prices,v);\\n        int n=v.size();\\n        sort(v.begin(),v.end());\\n\\n        return v[n-1]+v[n-2];\\n    \\n   }\\n };\\n\\nwhy i am getting run time error using this "
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "ClydeUrov",
                        "content": "broken task. The comments below confirm this."
                    },
                    {
                        "username": "paullam328",
                        "content": "Tip for y'all, the most optimal solution of this problem is derived from the most optimal solution from Best Time to Buy and Sell Stock IV for k = 2, so try out Best Time to Buy and Sell Stock IV and suffer there first and this problem is gonna be a breeze, it's more intuitive this way than that whatever state machine shit."
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `int helper(int []prices,int buy,int index,int count,int [][][]dp){\\n        if(index==prices.length||count==2){\\n            return 0;\\n        }\\n        if(dp[index][buy][count]!=-1){\\n            return dp[index][buy][count];\\n        }\\n        //two cases\\n        int ans=0;\\n        if(buy==1){\\n            int ans1=helper(prices,0,index+1,count+1,dp)+prices[index];\\n            int ans2=helper(prices,buy,index+1,count,dp);\\n            ans=Math.max(ans1,ans2);\\n        }else {\\n            int ans1=helper(prices,1,index+1,count,dp)-prices[index];\\n            int ans2=helper(prices,buy,index+1,count,dp);\\n            ans=Math.max(ans1,ans2);\\n        }\\n        return dp[index][buy][count]=ans;\\n    }\\n    public int maxProfit(int[] price) {\\n        int n=price.length;\\n        int [][][]dp=new int[n+1][2+1][2+1];\\n       for(int [][]arr:dp){\\n           for(int []arr2:arr)\\n            Arrays.fill(arr2,-1);\\n       }\\n        return helper(price,0,0,0,dp);\\n    }`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `int helper(int []prices,int buy,int index,int count,int [][][]dp){\\n        if(index==prices.length||count==2){\\n            return 0;\\n        }\\n        if(dp[index][buy][count]!=-1){\\n            return dp[index][buy][count];\\n        }\\n        //two cases\\n        int ans=0;\\n        if(buy==1){\\n            int ans1=helper(prices,0,index+1,count+1,dp)+prices[index];\\n            int ans2=helper(prices,buy,index+1,count,dp);\\n            ans=Math.max(ans1,ans2);\\n        }else {\\n            int ans1=helper(prices,1,index+1,count,dp)-prices[index];\\n            int ans2=helper(prices,buy,index+1,count,dp);\\n            ans=Math.max(ans1,ans2);\\n        }\\n        return dp[index][buy][count]=ans;\\n    }\\n    public int maxProfit(int[] price) {\\n        int n=price.length;\\n        int [][][]dp=new int[n+1][2+1][2+1];\\n       for(int [][]arr:dp){\\n           for(int []arr2:arr)\\n            Arrays.fill(arr2,-1);\\n       }\\n        return helper(price,0,0,0,dp);\\n    }`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "#pragma GCC optimize(\"Ofast,unroll-loops\")\\n#pragma GCC target(\"avx2,tune=native\")\\n\\nauto _ = [](){\\n    cin.tie(0)->sync_with_stdio(0);\\n    return 0;\\n}();\\n\\n\\n\\nclass Solution {\\npublic:\\n    \\n    int maxProfit(vector<int>& price){\\n\\n    int n= price.size();\\n    \\n    if(n==0 || n==1){\\n     return 0;\\n    }\\n\\n    int *left  = new int[n+1];\\n    int minl=price[0];\\n    left[0]=0;\\n\\n    for(int i=1;i<n;i++){\\n        left[i] = max(left[i-1],price[i]-minl);\\n        minl = min(minl,price[i]);\\n\\n    }\\n    int right =0,maxr=0,ans=0;\\n\\n    //reverse traverse\\n\\n    for(int i=n-1;i>=0;i--){\\n        right = max(right,maxr-price[i]);\\n        maxr = max(maxr,price[i]);\\n        ans = max(ans,left[i]+right); //calcualate profit\\n    }\\n\\n    return ans;\\n}\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Hoaibao_21520628",
                        "content": "can we buy and also sell on the same day?"
                    },
                    {
                        "username": "user8928Vy",
                        "content": "[@magnetics](/magnetics) Was looking for this! Thanks!"
                    },
                    {
                        "username": "magnetics",
                        "content": "Suppose if you buy on day \\'d1\\' then sell it on day \\'d2\\' then buy again on day \\'d2\\', and then sell on some other day \\'d3\\', your overall profit for day \\'d2\\' will be canceled out as =>\\n(prices[d3] - prices[d2]) + (prices[d2] - prices[d1]) = prices[d3] - prices[d1]\\nTherefore selling and buying on same day made no difference at all.\\nHope it clarifies :P"
                    }
                ]
            }
        ]
    },
    {
        "title": "Rectangle Area",
        "question_content": "<p>Given the coordinates of two <strong>rectilinear</strong> rectangles in a 2D plane, return <em>the total area covered by the two rectangles</em>.</p>\n\n<p>The first rectangle is defined by its <strong>bottom-left</strong> corner <code>(ax1, ay1)</code> and its <strong>top-right</strong> corner <code>(ax2, ay2)</code>.</p>\n\n<p>The second rectangle is defined by its <strong>bottom-left</strong> corner <code>(bx1, by1)</code> and its <strong>top-right</strong> corner <code>(bx2, by2)</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"Rectangle Area\" src=\"https://assets.leetcode.com/uploads/2021/05/08/rectangle-plane.png\" style=\"width: 700px; height: 365px;\" />\n<pre>\n<strong>Input:</strong> ax1 = -3, ay1 = 0, ax2 = 3, ay2 = 4, bx1 = 0, by1 = -1, bx2 = 9, by2 = 2\n<strong>Output:</strong> 45\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> ax1 = -2, ay1 = -2, ax2 = 2, ay2 = 2, bx1 = -2, by1 = -2, bx2 = 2, by2 = 2\n<strong>Output:</strong> 16\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-10<sup>4</sup> &lt;= ax1 &lt;= ax2 &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= ay1 &lt;= ay2 &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= bx1 &lt;= bx2 &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt;= by1 &lt;= by2 &lt;= 10<sup>4</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 62142,
                "title": "if-you-want-to-laugh-look-at-my-solution",
                "content": "    This is utterly ridiculous. As I was writing this I knew I was going about it wrong but I wanted to finish it before I thought of a different method or looked at any other solutions.\\n    \\n      int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n    \\tint area1 = (D - B)*(C - A);\\n    \\tint area2 = (H - F)*(G - E);\\n    \\tint area3;\\n    \\tif (area1 == 0) {\\n    \\t\\treturn area2;\\n    \\t}\\n    \\tif (area2 == 0) {\\n    \\t\\treturn area1;\\n    \\t}\\n    \\tif ((A == D) && (B == F) && (C == G) && (D == H)) {\\n    \\t\\treturn area1;\\n    \\t}\\n    \\tif ((E >= C) | (G <= A) | (H <= B) | (D <= F)) {    //not overlapping\\n    \\t\\treturn (area1 + area2);\\n    \\t}\\n    \\tif (((G - E) <= (C - A)) && ((H - F) <= (D - B)) && (E >= A) && (F >= B) && (G <= C) && (D >= H)) {                        //rect2 is inside rect1\\n    \\t\\treturn area1;\\n    \\t}\\n    \\tif (((C - A) <= (G - E)) && ((D - B) <= (H - F)) && (E <= A) && (B >= F) && (G >= C) && (H >= D)) {                        //rect1 is inside rect2\\n    \\t\\treturn area2;\\n    \\t}\\n    \\tif ((F >= B) && (E >= A) && (G >= C) && (H >= D)) {                       //overlapping upper right corner\\n    \\t\\tarea3 = (C - E)*(D - F);\\n    \\t}\\n    \\telse if ((F >= B) && (E <= A) && (G <= C) && (H >= D)) {                       //overlapping upper left corner\\n    \\t\\tarea3 = (G - A)*(D - F);\\n    \\t}\\n    \\telse if ((F <= B) && (E <= A) && (G <= C) && (H <= D)) {                       //overlapping bottom left corner\\n    \\t\\tarea3 = (G - A)*(H - B);\\n    \\t}\\n    \\telse if ((F <= B) && (E >= A) && (G >= C) && (H <= D)) {                        //overlapping bottom right corner\\n    \\t\\tarea3 = (H - B)*(C - E);\\n    \\t}\\n    \\telse if (((C - A) <= (G - E)) && (H <= D) && (G >= C) && (E <= A) && (F <= B)) {               //overlapping bottom side\\n    \\t\\tarea3 = (C - A)*(H - B);\\n    \\t}\\n    \\telse if (((C - A) <= (G - E)) && (H >= D) && (G >= C) && (E <= A) && (F >= B)) {               //overlapping top side\\n    \\t\\tarea3 = (C - A)*(D - F);\\n    \\t}\\n    \\telse if (((D - B) <= (H - F)) && (E <= A) && (F <= B) && (H >= D) && (G <= C)) {               //overlapping left side\\n    \\t\\tarea3 = (G - A)*(D - B);\\n    \\t}\\n    \\telse if (((D - B) <= (H - F)) && (E >= A) && (F <= B) && (H >= D) && (G >= C)) {               //overlapping right side\\n    \\t\\tarea3 = (C - E)*(D - B);\\n    \\t}\\n    \\telse if (((C - A) >= (G - E)) && (E >= A) && (F >= B) && (C >= G) && (D <= H)) {      //overlapping part of top side\\n    \\t\\tarea3 = (G - E)*(D - F);\\n    \\t}\\n    \\telse if (((C - A) >= (G - E)) && (A <= E) && (B >= F) && (G <= C) && (D >= H)) {       //overlapping part of bottom side\\n    \\t\\tarea3 = (G - E)*(H - B);\\n    \\t}\\n    \\telse if (((D - B) >= (H - F)) && (E <= A) && (F >= B) && (G <= C) && (H <= D)) {      //overlapping part of left side\\n    \\t\\tarea3 = (G - A)*(H - F);\\n    \\t}\\n    \\telse if (((D - B) >= (H - F)) && (E >= A) && (F >= B) && (G >= C) && (H <= D)) {       //overlapping part of right side\\n    \\t\\tarea3 = (C - E)*(H - F);\\n    \\t}\\n    \\telse if (((G - E) <= (C - A)) && (E >= A) && (F <= B) && (G <= C) && (H >= D)) {     //overlapping top and bottom\\n    \\t\\tarea3 = (G - E)*(D - B);\\n    \\t}\\n    \\telse if (((H - F) <= (D - B)) && (E <= A) && (F >= B) && (C <= G) && (D >= H)) {     //overlapping left and right\\n    \\t\\tarea3 = (C - A)*(H - F);\\n    \\t}\\n    \\n    \\treturn (area1 + area2 - area3);\\n    }",
                "solutionTags": [],
                "code": "    This is utterly ridiculous. As I was writing this I knew I was going about it wrong but I wanted to finish it before I thought of a different method or looked at any other solutions.\\n    \\n      int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n    \\tint area1 = (D - B)*(C - A);\\n    \\tint area2 = (H - F)*(G - E);\\n    \\tint area3;\\n    \\tif (area1 == 0) {\\n    \\t\\treturn area2;\\n    \\t}\\n    \\tif (area2 == 0) {\\n    \\t\\treturn area1;\\n    \\t}\\n    \\tif ((A == D) && (B == F) && (C == G) && (D == H)) {\\n    \\t\\treturn area1;\\n    \\t}\\n    \\tif ((E >= C) | (G <= A) | (H <= B) | (D <= F)) {    //not overlapping\\n    \\t\\treturn (area1 + area2);\\n    \\t}\\n    \\tif (((G - E) <= (C - A)) && ((H - F) <= (D - B)) && (E >= A) && (F >= B) && (G <= C) && (D >= H)) {                        //rect2 is inside rect1\\n    \\t\\treturn area1;\\n    \\t}\\n    \\tif (((C - A) <= (G - E)) && ((D - B) <= (H - F)) && (E <= A) && (B >= F) && (G >= C) && (H >= D)) {                        //rect1 is inside rect2\\n    \\t\\treturn area2;\\n    \\t}\\n    \\tif ((F >= B) && (E >= A) && (G >= C) && (H >= D)) {                       //overlapping upper right corner\\n    \\t\\tarea3 = (C - E)*(D - F);\\n    \\t}\\n    \\telse if ((F >= B) && (E <= A) && (G <= C) && (H >= D)) {                       //overlapping upper left corner\\n    \\t\\tarea3 = (G - A)*(D - F);\\n    \\t}\\n    \\telse if ((F <= B) && (E <= A) && (G <= C) && (H <= D)) {                       //overlapping bottom left corner\\n    \\t\\tarea3 = (G - A)*(H - B);\\n    \\t}\\n    \\telse if ((F <= B) && (E >= A) && (G >= C) && (H <= D)) {                        //overlapping bottom right corner\\n    \\t\\tarea3 = (H - B)*(C - E);\\n    \\t}\\n    \\telse if (((C - A) <= (G - E)) && (H <= D) && (G >= C) && (E <= A) && (F <= B)) {               //overlapping bottom side\\n    \\t\\tarea3 = (C - A)*(H - B);\\n    \\t}\\n    \\telse if (((C - A) <= (G - E)) && (H >= D) && (G >= C) && (E <= A) && (F >= B)) {               //overlapping top side\\n    \\t\\tarea3 = (C - A)*(D - F);\\n    \\t}\\n    \\telse if (((D - B) <= (H - F)) && (E <= A) && (F <= B) && (H >= D) && (G <= C)) {               //overlapping left side\\n    \\t\\tarea3 = (G - A)*(D - B);\\n    \\t}\\n    \\telse if (((D - B) <= (H - F)) && (E >= A) && (F <= B) && (H >= D) && (G >= C)) {               //overlapping right side\\n    \\t\\tarea3 = (C - E)*(D - B);\\n    \\t}\\n    \\telse if (((C - A) >= (G - E)) && (E >= A) && (F >= B) && (C >= G) && (D <= H)) {      //overlapping part of top side\\n    \\t\\tarea3 = (G - E)*(D - F);\\n    \\t}\\n    \\telse if (((C - A) >= (G - E)) && (A <= E) && (B >= F) && (G <= C) && (D >= H)) {       //overlapping part of bottom side\\n    \\t\\tarea3 = (G - E)*(H - B);\\n    \\t}\\n    \\telse if (((D - B) >= (H - F)) && (E <= A) && (F >= B) && (G <= C) && (H <= D)) {      //overlapping part of left side\\n    \\t\\tarea3 = (G - A)*(H - F);\\n    \\t}\\n    \\telse if (((D - B) >= (H - F)) && (E >= A) && (F >= B) && (G >= C) && (H <= D)) {       //overlapping part of right side\\n    \\t\\tarea3 = (C - E)*(H - F);\\n    \\t}\\n    \\telse if (((G - E) <= (C - A)) && (E >= A) && (F <= B) && (G <= C) && (H >= D)) {     //overlapping top and bottom\\n    \\t\\tarea3 = (G - E)*(D - B);\\n    \\t}\\n    \\telse if (((H - F) <= (D - B)) && (E <= A) && (F >= B) && (C <= G) && (D >= H)) {     //overlapping left and right\\n    \\t\\tarea3 = (C - A)*(H - F);\\n    \\t}\\n    \\n    \\treturn (area1 + area2 - area3);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 62149,
                "title": "just-another-short-way",
                "content": "Instead of checking whether the rectangles overlap, I max `right` with `left` (and `top` with `bottom`). Haven't seen that in other solutions.\\n\\n    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        int left = max(A,E), right = max(min(C,G), left);\\n        int bottom = max(B,F), top = max(min(D,H), bottom);\\n        return (C-A)*(D-B) - (right-left)*(top-bottom) + (G-E)*(H-F);\\n    }",
                "solutionTags": [],
                "code": "Instead of checking whether the rectangles overlap, I max `right` with `left` (and `top` with `bottom`). Haven't seen that in other solutions.\\n\\n    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        int left = max(A,E), right = max(min(C,G), left);\\n        int bottom = max(B,F), top = max(min(D,H), bottom);\\n        return (C-A)*(D-B) - (right-left)*(top-bottom) + (G-E)*(H-F);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 62138,
                "title": "my-java-solution-sum-of-areas-overlapped-area",
                "content": "    public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n            \\n            int areaOfSqrA = (C-A) * (D-B);\\n             int areaOfSqrB = (G-E) * (H-F);\\n            \\n            int left = Math.max(A, E);\\n            int right = Math.min(G, C);\\n            int bottom = Math.max(F, B);\\n            int top = Math.min(D, H);\\n            \\n            //If overlap\\n            int overlap = 0;\\n            if(right > left && top > bottom)\\n                 overlap = (right - left) * (top - bottom);\\n            \\n            return areaOfSqrA + areaOfSqrB - overlap;\\n        }\\n\\nHello! So, the code should be fairly straightforward. I first calculate the area of each rectangle and then calculate the overlapping area between the two rectangles (if there is one!). At the end, we sum up the individual areas and subtract the overlapping area/0 ! \\n\\nFeel free to ask should you have any queries for me OR if my solution can be improved upon! :)",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n            \\n            int areaOfSqrA = (C-A) * (D-B);\\n             int areaOfSqrB = (G-E) * (H-F);\\n            \\n            int left = Math.max(A, E);\\n            int right = Math.min(G, C);\\n            int bottom = Math.max(F, B);\\n            int top = Math.min(D, H);\\n            \\n            //If overlap\\n            int overlap = 0;\\n            if(right > left && top > bottom)\\n                 overlap = (right - left) * (top - bottom);\\n            \\n            return areaOfSqrA + areaOfSqrB - overlap;\\n        }\\n\\nHello! So, the code should be fairly straightforward. I first calculate the area of each rectangle and then calculate the overlapping area between the two rectangles (if there is one!). At the end, we sum up the individual areas and subtract the overlapping area/0 ! \\n\\nFeel free to ask should you have any queries for me OR if my solution can be improved upon! :)",
                "codeTag": "Unknown"
            },
            {
                "id": 2822228,
                "title": "python3-one-liner-o-1-detailed-explanations",
                "content": "```python\\nclass Solution:\\n    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:\\n        return (ax2-ax1)*(ay2-ay1) + (bx2-bx1)*(by2-by1) - max(min(ax2,bx2)-max(ax1,bx1), 0) * max(min(ay2,by2)-max(ay1,by1), 0)\\n```\\n\\n**Algorithm:**\\n(1) calculate the total area covered by the two rectangles\\n(2) calculate the area of the overlap between the two rectangles\\n(3) subtract the overlap from the total area\\n\\nThe tricky part is how to calculate the overlapped area.\\nWe get the overlap on x-axis, and y-axis separately.\\nUsing examples on x-axis for illustration:\\n```\\ncase1:\\nax1-----------ax2\\n      bx1-----------bx2\\n\\ncase2:\\nax1-----------ax2\\n     bx1-bx2\\n\\ncase3:\\nax1-----------ax2\\n                    bx1-----------bx2\\n```\\nIf you draw all the cases down for a and b, there can be 10 cases. However, after we swap ```a``` and ```b```, there are only 3 cases as shown above, and all we need to do is to \\n(1) find the **minimum** of the two **endpoints**\\n(2) find the **maximum** of the two **start points**\\n(3) ```overlap``` = (1) - (2) Note that if the result is negative, it means there is no overlap, then overlap=0, so we do ```overlap = max( (1)-(2), 0)```\\n\\nIn case you don\\'t like the one-liner\\n```python\\nclass Solution:\\n    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:\\n        def area(x1,y1,x2,y2):\\n            return (x2-x1)*(y2-y1)\\n        xOverlap = max(min(ax2,bx2)-max(ax1,bx1), 0)\\n        yOverlap = max(min(ay2,by2)-max(ay1,by1), 0)\\n        return area(ax1,ay1,ax2,ay2) + area(bx1,by1,bx2,by2) - xOverlap*yOverlap\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:\\n        return (ax2-ax1)*(ay2-ay1) + (bx2-bx1)*(by2-by1) - max(min(ax2,bx2)-max(ax1,bx1), 0) * max(min(ay2,by2)-max(ay1,by1), 0)\\n```\n```\\ncase1:\\nax1-----------ax2\\n      bx1-----------bx2\\n\\ncase2:\\nax1-----------ax2\\n     bx1-bx2\\n\\ncase3:\\nax1-----------ax2\\n                    bx1-----------bx2\\n```\n```a```\n```b```\n```overlap```\n```overlap = max( (1)-(2), 0)```\n```python\\nclass Solution:\\n    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:\\n        def area(x1,y1,x2,y2):\\n            return (x2-x1)*(y2-y1)\\n        xOverlap = max(min(ax2,bx2)-max(ax1,bx1), 0)\\n        yOverlap = max(min(ay2,by2)-max(ay1,by1), 0)\\n        return area(ax1,ay1,ax2,ay2) + area(bx1,by1,bx2,by2) - xOverlap*yOverlap\\n```",
                "codeTag": "Java"
            },
            {
                "id": 62139,
                "title": "python-concise-solution",
                "content": "        \\n    def computeArea(self, A, B, C, D, E, F, G, H):\\n        overlap = max(min(C,G)-max(A,E), 0)*max(min(D,H)-max(B,F), 0)\\n        return (A-C)*(B-D) + (E-G)*(F-H) - overlap",
                "solutionTags": [
                    "Python"
                ],
                "code": "        \\n    def computeArea(self, A, B, C, D, E, F, G, H):\\n        overlap = max(min(C,G)-max(A,E), 0)*max(min(D,H)-max(B,F), 0)\\n        return (A-C)*(B-D) + (E-G)*(F-H) - overlap",
                "codeTag": "Python3"
            },
            {
                "id": 62302,
                "title": "clean-c-solution-with-detailed-explanations",
                "content": "Well, this problem looks easy at first glance. However, to get a bug-free code may be not that easy. \\n\\nThe total square is simply equal to the sum of the area of the two rectangles minus the area of their overlap. How do we compute the area of a rectangle? Well, simply times its height with its width. And the height and width can be obtained from the coordinates of the corners.\\n\\nThe key to this problem actually lies in how to handle overlap. \\n\\nFirst, let's think about when overlap will happen? Well, if one rectangle is completely to the left (or right/top/bottom) of the other, then no overlap will happen; otherwise, it will.\\n\\nHow do we know whether a rectangle is completely to the left of the other? Well, just make sure that the right boundary of it is to the left of the left boundary of the other. That is, `C <= E`. The right/top/bottom cases can be handled similarly by `A >= G`, `D <= F`, `B >= H`.\\n\\nNow we know how to check for overlap. If overlap happens, how do we compute it? The key is to find the boundary of the overlap. \\n\\nTake the image at the problem statement as an example. It can be seen that the left boundary of the overlap is `max(A, E)`, the right boundary is `min(C, G)`. The top and bottom boundaries are `min(D, H)` and `max(B, F)` similarly. So the area of the overlap is simply `(min(C, G) - max(A, E)) * (min(D, H) - max(B, F))`.\\n\\nYou should now convince yourself that all kind of overlapping cases can be handled by the above formula by drawing some examples on the paper.\\n\\nFinally, we have the following code (simply a translation of the above idea).\\n\\n    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        int s1 = (C - A) * (D - B);\\n        int s2 = (G - E) * (H - F); \\n        if (A >= G || C <= E || D <= F || B >= H)\\n            return s1 + s2; \\n        return s1 - (min(G, C) - max(A, E)) * (min(D, H) - max(B, F)) + s2;\\n    }",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "Well, this problem looks easy at first glance. However, to get a bug-free code may be not that easy. \\n\\nThe total square is simply equal to the sum of the area of the two rectangles minus the area of their overlap. How do we compute the area of a rectangle? Well, simply times its height with its width. And the height and width can be obtained from the coordinates of the corners.\\n\\nThe key to this problem actually lies in how to handle overlap. \\n\\nFirst, let's think about when overlap will happen? Well, if one rectangle is completely to the left (or right/top/bottom) of the other, then no overlap will happen; otherwise, it will.\\n\\nHow do we know whether a rectangle is completely to the left of the other? Well, just make sure that the right boundary of it is to the left of the left boundary of the other. That is, `C <= E`. The right/top/bottom cases can be handled similarly by `A >= G`, `D <= F`, `B >= H`.\\n\\nNow we know how to check for overlap. If overlap happens, how do we compute it? The key is to find the boundary of the overlap. \\n\\nTake the image at the problem statement as an example. It can be seen that the left boundary of the overlap is `max(A, E)`, the right boundary is `min(C, G)`. The top and bottom boundaries are `min(D, H)` and `max(B, F)` similarly. So the area of the overlap is simply `(min(C, G) - max(A, E)) * (min(D, H) - max(B, F))`.\\n\\nYou should now convince yourself that all kind of overlapping cases can be handled by the above formula by drawing some examples on the paper.\\n\\nFinally, we have the following code (simply a translation of the above idea).\\n\\n    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        int s1 = (C - A) * (D - B);\\n        int s2 = (G - E) * (H - F); \\n        if (A >= G || C <= E || D <= F || B >= H)\\n            return s1 + s2; \\n        return s1 - (min(G, C) - max(A, E)) * (min(D, H) - max(B, F)) + s2;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 62164,
                "title": "my-easy-c-solution",
                "content": "    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) \\n    {\\n        int total = (C-A) * (D-B) + (G-E) * (H-F);\\n        \\n        if (C<=E || A>=G || B>=H || D<=F )\\n            return total;\\n        else\\n        {\\n            vector <int> h;\\n            h.push_back(A);\\n            h.push_back(C);\\n            h.push_back(E);\\n            h.push_back(G);\\n       \\n            vector <int> v;\\n            v.push_back(B);\\n            v.push_back(D);\\n            v.push_back(F);\\n            v.push_back(H);\\n        \\n            sort(h.begin(), h.end());\\n            sort(v.begin(), v.end());\\n        \\n            total = total - (h[2] - h [1]) * (v[2] - v[1]);\\n            return total;\\n        }\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) \\n    {\\n        int total = (C-A) * (D-B) + (G-E) * (H-F);\\n        \\n        if (C<=E || A>=G || B>=H || D<=F )\\n            return total;\\n        else\\n        {\\n            vector <int> h;\\n            h.push_back(A);\\n            h.push_back(C);\\n            h.push_back(E);\\n            h.push_back(G);\\n       \\n            vector <int> v;\\n            v.push_back(B);\\n            v.push_back(D);\\n            v.push_back(F);\\n            v.push_back(H);\\n        \\n            sort(h.begin(), h.end());\\n            sort(v.begin(), v.end());\\n        \\n            total = total - (h[2] - h [1]) * (v[2] - v[1]);\\n            return total;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2822226,
                "title": "python-c-java-rust-sum-of-rectangles-minus-intersection-explained",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs simple computation of areas of three rectangles, two given ones and their intersection. Time complexity is constant: **O(1)**. Space complexity is constant: **O(1)**.\\n****\\n**Comment.** This is a follow-up to [**836. Rectangle Overlap**](https://leetcode.com/problems/rectangle-overlap/). In this problem, however, we are being asked not just to detect the overlap but also to compute its area. This is needed here because when adding areas of two rectangles, their intersection is being counted twice, thus, we have to subtract it.\\n\\n**Python #1.** One-liner. Sum of areas of two rectangles minus the area of their intersection.\\n```\\nclass Solution:\\n    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:\\n        \\n        # sum of areas of two rectangles minus the area of their intersection\\n        return (ax2 - ax1) * (ay2 - ay1) + \\\\\\n               (bx2 - bx1) * (by2 - by1) - \\\\\\n               max(min(ax2,bx2) - max(ax1,bx1),0) * max(min(ay2,by2) - max(ay1,by1),0)\\n```\\n\\n**Python #2.** More explicitly...\\n```\\nclass Solution:\\n    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:\\n        \\n        area_1 = (ax2 - ax1) * (ay2 - ay1)               # [1] area of the first rectangle\\n        area_2 = (bx2 - bx1) * (by2 - by1)               # [2] area of the second rectangle \\n        x_over = max(min(ax2,bx2) - max(ax1,bx1),0)      # [3] overlap of sides along x-axis\\n        y_over = max(min(ay2,by2) - max(ay1,by1),0)      # [4] overlap of sides along y-axis\\n        area_0 = x_over * y_over                         # [5] area of the overlap region\\n        \\n        return area_1 + area_2 - area_0\\n```\\n\\n<iframe src=\"https://leetcode.com/playground/gNm53iJ9/shared\" frameBorder=\"0\" width=\"800\" height=\"280\"></iframe>",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:\\n        \\n        # sum of areas of two rectangles minus the area of their intersection\\n        return (ax2 - ax1) * (ay2 - ay1) + \\\\\\n               (bx2 - bx1) * (by2 - by1) - \\\\\\n               max(min(ax2,bx2) - max(ax1,bx1),0) * max(min(ay2,by2) - max(ay1,by1),0)\\n```\n```\\nclass Solution:\\n    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:\\n        \\n        area_1 = (ax2 - ax1) * (ay2 - ay1)               # [1] area of the first rectangle\\n        area_2 = (bx2 - bx1) * (by2 - by1)               # [2] area of the second rectangle \\n        x_over = max(min(ax2,bx2) - max(ax1,bx1),0)      # [3] overlap of sides along x-axis\\n        y_over = max(min(ay2,by2) - max(ay1,by1),0)      # [4] overlap of sides along y-axis\\n        area_0 = x_over * y_over                         # [5] area of the overlap region\\n        \\n        return area_1 + area_2 - area_0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 62202,
                "title": "an-easy-to-understand-solution-in-java",
                "content": "Calculate the area of each rectangle at first. Judge whether they have intersection. If not, return the sum area of them. Otherwise, count the intersection area and subtract it by one time of total area.  \\n\\n    public class Solution {\\n        public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n            int rectOne = (C - A) * (D - B);\\n            int rectTwo = (G - E) * (H - F);\\n            \\n            if(A >= G || B >= H || C <= E || D <= F){\\n                return rectOne + rectTwo;\\n            }\\n            \\n            int length = Math.min(C, G) - Math.max(A, E);\\n            int height = Math.min(D, H) - Math.max(B, F);\\n            \\n            return rectOne + rectTwo - length * height;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n            int rectOne = (C - A) * (D - B);\\n            int rectTwo = (G - E) * (H - F);\\n            \\n            if(A >= G || B >= H || C <= E || D <= F){\\n                return rectOne + rectTwo;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 62329,
                "title": "one-liner-clear-solution-and-explanation",
                "content": "First the one-liner solution:\\n\\n    def computeArea(self, A, B, C, D, E, F, G, H):\\n        return (C-A)*(D-B)+(G-E)*(H-F)-max(min(C,G)-max(A, E),0)*max(min(D,H)-max(B,F),0)\\n\\nJust compute the area of first and second rectangle minus area of the overlap. How to compute the overlap? It's two-dimensional, but we can break it down to two one-dimensional problems, one to find its width and one to find its height. How to find the overlap width? Well, the input rectangles occupy the intervals [A, C] and [E, G] on the x-axis. The overlap is the intersection of those intervals. How to find the intersection of two intervals? Just take the larger left end and the smaller right end, so in this case: [max(A, E), min(C, G)]. And the length of that interval is the width of the overlap, so min(C, G) - max(A, E). However, if there's no overlap, then max(A, E) is larger than min(C, G) and the \"length\" of that interval is negative. You could check whether max(A, E) is larger than min(C, G), but you can also just use the maximum of the potentially negative \"length\" and zero, as seen in the below code. Note, however, that in languages like C++ and Java, where integers can overflow, [this can lead to wrong answers](https://leetcode.com/discuss/39302/we-need-to-add-some-tests?show=39361#c39361).\\n\\nMeaningful names for input variables and intermediate values help:\\n\\n    def computeArea(self, left1, bottom1, right1, top1, left2, bottom2, right2, top2):\\n        first = (right1 - left1) * (top1 - bottom1)\\n        second = (right2 - left2) * (top2 - bottom2)\\n\\n        # overlap\\n        left    = max(left1, left2)\\n        right   = min(right1, right2)\\n        top     = min(top1, top2)\\n        bottom  = max(bottom1, bottom2)\\n        width   = max(right - left, 0)\\n        height  = max(top - bottom, 0)\\n        overlap = width * height\\n        \\n        return first + second - overlap\\n\\n\"Regular\" solution:\\n\\n    def computeArea(self, A, B, C, D, E, F, G, H):\\n        first = (C - A) * (D - B)\\n        second = (G - E) * (H - F)\\n        overlap = max(min(C, G) - max(A, E), 0) * max(min(D, H) - max(B, F), 0)\\n        return first + second - overlap",
                "solutionTags": [
                    "Python"
                ],
                "code": "First the one-liner solution:\\n\\n    def computeArea(self, A, B, C, D, E, F, G, H):\\n        return (C-A)*(D-B)+(G-E)*(H-F)-max(min(C,G)-max(A, E),0)*max(min(D,H)-max(B,F),0)\\n\\nJust compute the area of first and second rectangle minus area of the overlap. How to compute the overlap? It's two-dimensional, but we can break it down to two one-dimensional problems, one to find its width and one to find its height. How to find the overlap width? Well, the input rectangles occupy the intervals [A, C] and [E, G] on the x-axis. The overlap is the intersection of those intervals. How to find the intersection of two intervals? Just take the larger left end and the smaller right end, so in this case: [max(A, E), min(C, G)]. And the length of that interval is the width of the overlap, so min(C, G) - max(A, E). However, if there's no overlap, then max(A, E) is larger than min(C, G) and the \"length\" of that interval is negative. You could check whether max(A, E) is larger than min(C, G), but you can also just use the maximum of the potentially negative \"length\" and zero, as seen in the below code. Note, however, that in languages like C++ and Java, where integers can overflow, [this can lead to wrong answers](https://leetcode.com/discuss/39302/we-need-to-add-some-tests?show=39361#c39361).\\n\\nMeaningful names for input variables and intermediate values help:\\n\\n    def computeArea(self, left1, bottom1, right1, top1, left2, bottom2, right2, top2):\\n        first = (right1 - left1) * (top1 - bottom1)\\n        second = (right2 - left2) * (top2 - bottom2)\\n\\n        # overlap\\n        left    = max(left1, left2)\\n        right   = min(right1, right2)\\n        top     = min(top1, top2)\\n        bottom  = max(bottom1, bottom2)\\n        width   = max(right - left, 0)\\n        height  = max(top - bottom, 0)\\n        overlap = width * height\\n        \\n        return first + second - overlap\\n\\n\"Regular\" solution:\\n\\n    def computeArea(self, A, B, C, D, E, F, G, H):\\n        first = (C - A) * (D - B)\\n        second = (G - E) * (H - F)\\n        overlap = max(min(C, G) - max(A, E), 0) * max(min(D, H) - max(B, F), 0)\\n        return first + second - overlap",
                "codeTag": "Python3"
            },
            {
                "id": 2822607,
                "title": "java-solution-faster-than",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFirst find overlapping interval on x and y axis, area will be product of both, but if x-overlap or y-overlap is negative means both rectangles don\\'t intersect\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        int a1=(ax2-ax1)*(ay2-ay1);//area of rectangle 1\\n        int a2=(bx2-bx1)*(by2-by1);//area of rectangle 2\\n\\n        //co-ordinates of intersecting rectangle\\n        int x5 = Math.max(ax1, bx1);\\n        int y5 = Math.max(ay1, by1);\\n        int x6 = Math.min(ax2, bx2);\\n        int y6 = Math.min(ay2, by2);\\n\\n        int x=x6-x5;\\n        int y=y6-y5;\\n        int a3=x*y;//area of intersecting rectangle\\n        if(x<0 || y<0){//means both rectangle don\\'t intersects\\n            a3=0;\\n        }\\n        \\n        return a1+a2-a3;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\n    public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        int a1=(ax2-ax1)*(ay2-ay1);//area of rectangle 1\\n        int a2=(bx2-bx1)*(by2-by1);//area of rectangle 2\\n\\n        //co-ordinates of intersecting rectangle\\n        int x5 = Math.max(ax1, bx1);\\n        int y5 = Math.max(ay1, by1);\\n        int x6 = Math.min(ax2, bx2);\\n        int y6 = Math.min(ay2, by2);\\n\\n        int x=x6-x5;\\n        int y=y6-y5;\\n        int a3=x*y;//area of intersecting rectangle\\n        if(x<0 || y<0){//means both rectangle don\\'t intersects\\n            a3=0;\\n        }\\n        \\n        return a1+a2-a3;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 62260,
                "title": "simple-python-solution",
                "content": "    class Solution(object):\\n        def computeArea(self, A, B, C, D, E, F, G, H):\\n            total = (C - A) * (D - B) + (G - E) * (H - F)\\n      \\n            width = max(0, min(C, G) - max(A, E))\\n            height = max(0, min(D, H) - max(B, F))\\n            \\n            return total - width * height",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        def computeArea(self, A, B, C, D, E, F, G, H):\\n            total = (C - A) * (D - B) + (G - E) * (H - F)\\n      \\n            width = max(0, min(C, G) - max(A, E))\\n            height = max(0, min(D, H) - max(B, F))\\n            \\n            return total - width * height",
                "codeTag": "Java"
            },
            {
                "id": 62254,
                "title": "my-java-solution",
                "content": "    public int computeAreaJoin(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        int hTop = Math.min(D, H);\\n        int hBot = Math.max(B, F);\\n        int wTop = Math.min(C, G);\\n        int wBot = Math.max(A, E);\\n        if (hTop < hBot || wTop < wBot) {\\n            return 0;\\n        } else {\\n            return (hTop - hBot) * (wTop - wBot);\\n        }\\n    }\\n    // A U B = A + B - A * B\\n    public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        return (C-A)*(D-B) + (G-E)*(H-F) - computeAreaJoin(A,B,C,D,E,F,G,H);\\n    }",
                "solutionTags": [],
                "code": "    public int computeAreaJoin(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        int hTop = Math.min(D, H);\\n        int hBot = Math.max(B, F);\\n        int wTop = Math.min(C, G);\\n        int wBot = Math.max(A, E);\\n        if (hTop < hBot || wTop < wBot) {\\n            return 0;\\n        } else {\\n            return (hTop - hBot) * (wTop - wBot);\\n        }\\n    }\\n    // A U B = A + B - A * B\\n    public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        return (C-A)*(D-B) + (G-E)*(H-F) - computeAreaJoin(A,B,C,D,E,F,G,H);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 62265,
                "title": "after-looking-at-the-discuss-area-i-m-going-to-be-crazy",
                "content": "that's the solution after i try thousands of times. you can laugh at me now......\\n\\n    class Solution {\\n    public:\\n    struct myPoint\\n    {\\n        int x;\\n        int y;\\n        bool flag;\\n    };\\n    struct myRect\\n    {\\n        myPoint bl;\\n        myPoint tr;\\n        myPoint tl;\\n        myPoint br;\\n    };\\n    myRect rect1;\\n    myRect rect2;\\n    vector<myPoint> pts;\\n    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H)\\n    {\\n        int myinterarea=InterArea(A,B,C,D,E,F,G,H);\\n        return myArea(rect1)+myArea(rect2)-myinterarea;\\n    }\\n    int InterArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        rect1.bl.x=A;\\n        rect1.bl.y=B;\\n        rect1.tr.x=C;\\n        rect1.tr.y=D;\\n        rect1.tl.x=A;\\n        rect1.tl.y=D;\\n        rect1.br.x=C;\\n        rect1.br.y=B;\\n        rect2.bl.x=E;\\n        rect2.bl.y=F;\\n        rect2.tr.x=G;\\n        rect2.tr.y=H;\\n        rect2.tl.x=E;\\n        rect2.tl.y=H;\\n        rect2.br.x=G;\\n        rect2.br.y=F;\\n        \\n        int ptinrect1=0,ptinrect2=0;\\n        if(myPtInRect(rect2.tl,rect1))\\n            ptinrect1++;\\n        if(myPtInRect(rect2.tr,rect1))\\n            ptinrect1++;\\n        if(myPtInRect(rect2.bl,rect1))\\n            ptinrect1++;\\n        if(myPtInRect(rect2.br,rect1))\\n            ptinrect1++;\\n        \\n        if(myPtInRect(rect1.tl,rect2))\\n            ptinrect2++;\\n        if(myPtInRect(rect1.tr,rect2))\\n            ptinrect2++;\\n        if(myPtInRect(rect1.bl,rect2))\\n            ptinrect2++;\\n        if(myPtInRect(rect1.br,rect2))\\n            ptinrect2++;\\n            \\n        if(ptinrect1==4&&ptinrect2==4)\\n            return myArea(rect1);\\n        if(ptinrect1==4&&ptinrect2==0)\\n            return myArea(rect2);\\n        if(ptinrect1==0&&ptinrect2==4)\\n            return myArea(rect1);\\n        if(ptinrect1==2&&ptinrect2==2)\\n        {\\n            int xmin=min<int>(pts[0].x,min<int>(pts[1].x,min<int>(pts[2].x,pts[3].x)));\\n            int xmax=max<int>(pts[0].x,max<int>(pts[1].x,max<int>(pts[2].x,pts[3].x)));\\n            int ymin=min<int>(pts[0].y,min<int>(pts[1].y,min<int>(pts[2].y,pts[3].y)));\\n            int ymax=max<int>(pts[0].y,max<int>(pts[1].y,max<int>(pts[2].y,pts[3].y)));\\n            return (xmax-xmin)*(ymax-ymin);\\n        }\\n        if(ptinrect1==1&&ptinrect2==1)\\n        {\\n            int xmin=min<int>(pts[0].x,pts[1].x);\\n            int xmax=max<int>(pts[0].x,pts[1].x);\\n            int ymin=min<int>(pts[0].y,pts[1].y);\\n            int ymax=max<int>(pts[0].y,pts[1].y);\\n            return (xmax-xmin)*(ymax-ymin);\\n        }\\n        if((ptinrect1==2&&ptinrect2==0)||(ptinrect1==0&&ptinrect2==2))\\n        {\\n            if(ptinrect1==0&&ptinrect2==2)\\n            {\\n                myRect temprect=rect1;\\n                rect1=rect2;\\n                rect2=temprect;\\n            }\\n            if(pts[0].x==pts[1].x)\\n            {\\n                if(pts[0].x==rect2.tl.x)\\n                    return (rect1.br.x-rect2.tl.x)*(rect2.tl.y-rect2.bl.y);\\n                else if(pts[0].x==rect2.tr.x)\\n                    return (rect2.br.x-rect1.tl.x)*(rect2.tr.y-rect2.br.y);\\n            }\\n            else if(pts[0].y==pts[1].y)\\n            {\\n                if(pts[0].y==rect2.tl.y)\\n                    return (rect2.tr.x-rect2.tl.x)*(rect2.tl.y-rect1.br.y);\\n                else if(pts[0].y==rect2.br.y)\\n                    return (rect2.br.x-rect2.bl.x)*(rect1.tl.y-rect2.br.y);\\n            }\\n        }\\n        if(ptinrect1==0&&ptinrect2==0)\\n        {\\n            if((rect1.tl.x>rect2.br.x)||(rect2.tl.x>rect1.br.x)||(rect1.tl.y<rect2.br.y)||(rect2.tl.y<rect1.br.y))\\n                return 0;\\n            else\\n            {\\n                myPoint newtl,newbr;\\n                newtl.x=max<int>(rect1.tl.x,rect2.tl.x);\\n                newtl.y=min<int>(rect1.tl.y,rect2.tl.y);\\n                newbr.x=min<int>(rect1.br.x,rect2.br.x);\\n                newbr.y=max<int>(rect1.br.y,rect2.br.y);\\n                return (newbr.x-newtl.x)*(newtl.y-newbr.y);\\n            }\\n        }\\n        if((ptinrect1==1&&ptinrect2==2)||(ptinrect1==2&&ptinrect2==1))\\n        {\\n            if((rect1.tl.x>=rect2.br.x)||(rect2.tl.x>=rect1.br.x)||(rect1.tl.y<=rect2.br.y)||(rect2.tl.y<=rect1.br.y))\\n                return 0;\\n            else\\n            {\\n                myPoint newtl,newbr;\\n                newtl.x=min<int>(pts[0].x,min<int>(pts[1].x,pts[2].x));\\n                newtl.y=max<int>(pts[0].y,max<int>(pts[1].y,pts[2].y));\\n                newbr.x=max<int>(pts[0].x,max<int>(pts[1].x,pts[2].x));\\n                newbr.y=min<int>(pts[0].y,min<int>(pts[1].y,pts[2].y));\\n                return (newbr.x-newtl.x)*(newtl.y-newbr.y);\\n            }\\n        }\\n        if((ptinrect1==1&&ptinrect2==4)||(ptinrect1==4&&ptinrect2==1))\\n            return min<int>(myArea(rect1),myArea(rect2));\\n        if((ptinrect1==2&&ptinrect2==4)||(ptinrect1==4&&ptinrect2==2))\\n            return min<int>(myArea(rect1),myArea(rect2));\\n    }\\n    \\n    int myArea(myRect rect)\\n    {\\n        return (rect.tr.x-rect.bl.x)*(rect.tr.y-rect.bl.y);\\n    }\\n    \\n    bool myPtInRect(myPoint pt,myRect rect)\\n    {\\n        if(pt.x>=rect.bl.x&&pt.x<=rect.tr.x&&pt.y>=rect.bl.y&&pt.y<=rect.tr.y)\\n        {\\n            pts.push_back(pt);\\n            return true;\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    struct myPoint\\n    {\\n        int x;\\n        int y;\\n        bool flag;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2822416,
                "title": "c-java-python3-intuitive-solution-de-morgans-law",
                "content": "**De Morgans law :** *The complement of the union of two sets is the intersection of their complements and the complement of the intersection of two sets is the union of their complements.*\\n\\n\\nThis is a follow-up to the question **[836. Rectangle Overlap](https://leetcode.com/problems/rectangle-overlap/)**\\n\\n\\n```\\n// There are primarily 3 scenarios.\\n\\nscenario 1 (partly overlapping):\\nax1-----------ax2\\n       bx1-----------bx2\\n\\nscenario 2 (fully overlapping):\\nax1-----------ax2\\n     bx1-bx2\\n\\nscenario 3 (no overlapping):\\nax1-----------ax2\\n                    bx1-----------bx2\\n\\t\\t\\t\\t\\t\\nHence, intersection can be discovered by:\\n\\n* determining the greater of the two starting locations\\n* calculating the smaller of the two endpoints\\n\\n```\\n\\n\\n\\n```\\n         int x1 = max(rec1[0],rec2[0]);\\n\\t\\t int x2 = min(rec1[2],rec2[2]);\\n\\t\\t \\n         int y1 = max(rec1[1],rec2[1]);\\n         int y2 = min(rec1[3],rec2[3]);\\n        \\n         // if(x1 < x2 && y1 < y2) then there is an overlap between two rectangles.\\n         // else, there isn\\'t.\\n```\\n\\n\\n------------------------------\\n------------------------------\\n\\n**C++**\\n\\n```\\nclass Solution {\\npublic:\\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        \\n        int areaOf1stRectangle = (ax2 - ax1) * (ay2 - ay1);\\n        int areaOf2ndRectangle = (bx2 - bx1) * (by2 - by1);\\n\\n        int xOverlap = min(ax2, bx2) - max(ax1, bx1);\\n        int yOverlap = min(ay2, by2) - max(ay1, by1);\\n        int areaOverlap = (xOverlap > 0 && yOverlap > 0) ? xOverlap * yOverlap : 0;\\n\\n        return (areaOf1stRectangle + areaOf2ndRectangle - areaOverlap);    \\n    }\\n};\\n```\\n\\n\\n--------------------------------\\n\\n**JAVA**\\n\\n```\\nclass Solution {\\n    public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        \\n        int areaOf1stRectangle = (ax2 - ax1) * (ay2 - ay1);\\n        int areaOf2ndRectangle = (bx2 - bx1) * (by2 - by1);\\n\\n        int xOverlap = Math.min(ax2, bx2) - Math.max(ax1, bx1);\\n        int yOverlap = Math.min(ay2, by2) - Math.max(ay1, by1);\\n        int areaOverlap = (xOverlap > 0 && yOverlap > 0) ? xOverlap * yOverlap : 0;\\n\\n        return (areaOf1stRectangle + areaOf2ndRectangle - areaOverlap); \\n    }\\n}\\n```\\n\\n-------------------------\\n\\n**Python3**\\n\\n```\\nclass Solution:\\n    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:\\n        areaOf1stRectangle = (ax2 - ax1) * (ay2 - ay1);\\n        areaOf2ndRectangle = (bx2 - bx1) * (by2 - by1);\\n\\n        xOverlap = min(ax2, bx2) - max(ax1, bx1);\\n        yOverlap = min(ay2, by2) - max(ay1, by1);\\n        areaOverlap = max(xOverlap,0) * max(yOverlap,0);\\n\\n        return (areaOf1stRectangle + areaOf2ndRectangle - areaOverlap);\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\n// There are primarily 3 scenarios.\\n\\nscenario 1 (partly overlapping):\\nax1-----------ax2\\n       bx1-----------bx2\\n\\nscenario 2 (fully overlapping):\\nax1-----------ax2\\n     bx1-bx2\\n\\nscenario 3 (no overlapping):\\nax1-----------ax2\\n                    bx1-----------bx2\\n\\t\\t\\t\\t\\t\\nHence, intersection can be discovered by:\\n\\n* determining the greater of the two starting locations\\n* calculating the smaller of the two endpoints\\n\\n```\n```\\n         int x1 = max(rec1[0],rec2[0]);\\n\\t\\t int x2 = min(rec1[2],rec2[2]);\\n\\t\\t \\n         int y1 = max(rec1[1],rec2[1]);\\n         int y2 = min(rec1[3],rec2[3]);\\n        \\n         // if(x1 < x2 && y1 < y2) then there is an overlap between two rectangles.\\n         // else, there isn\\'t.\\n```\n```\\nclass Solution {\\npublic:\\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        \\n        int areaOf1stRectangle = (ax2 - ax1) * (ay2 - ay1);\\n        int areaOf2ndRectangle = (bx2 - bx1) * (by2 - by1);\\n\\n        int xOverlap = min(ax2, bx2) - max(ax1, bx1);\\n        int yOverlap = min(ay2, by2) - max(ay1, by1);\\n        int areaOverlap = (xOverlap > 0 && yOverlap > 0) ? xOverlap * yOverlap : 0;\\n\\n        return (areaOf1stRectangle + areaOf2ndRectangle - areaOverlap);    \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        \\n        int areaOf1stRectangle = (ax2 - ax1) * (ay2 - ay1);\\n        int areaOf2ndRectangle = (bx2 - bx1) * (by2 - by1);\\n\\n        int xOverlap = Math.min(ax2, bx2) - Math.max(ax1, bx1);\\n        int yOverlap = Math.min(ay2, by2) - Math.max(ay1, by1);\\n        int areaOverlap = (xOverlap > 0 && yOverlap > 0) ? xOverlap * yOverlap : 0;\\n\\n        return (areaOf1stRectangle + areaOf2ndRectangle - areaOverlap); \\n    }\\n}\\n```\n```\\nclass Solution:\\n    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:\\n        areaOf1stRectangle = (ax2 - ax1) * (ay2 - ay1);\\n        areaOf2ndRectangle = (bx2 - bx1) * (by2 - by1);\\n\\n        xOverlap = min(ax2, bx2) - max(ax1, bx1);\\n        yOverlap = min(ay2, by2) - max(ay1, by1);\\n        areaOverlap = max(xOverlap,0) * max(yOverlap,0);\\n\\n        return (areaOf1stRectangle + areaOf2ndRectangle - areaOverlap);\\n```",
                "codeTag": "Java"
            },
            {
                "id": 62301,
                "title": "check-the-overlapping-area-of-two-rectangles-tricky",
                "content": "I guess the most tricky part of this problem is to check whether two rectangles have an overlapping if so how to calculate it. \\n\\nSo here is my \"verbose\" solution in Java. Hope it is self-explanatory.\\n\\n\\t/**\\n\\t * Calculate the overlapping area of two rectangles.\\n\\t */\\n    public int overlapArea(int A, int B, int C, int D,\\n         \\t\\t\\t        int E, int F, int G, int H) {\\n    \\t/* Check if there is indeed an overlap.\\n         * e.g.  E >= C  i.e. the most left point of the rectangle (EFGH) is \\n         *       on the right side of the most right point of the rectangle (ABCD),\\n         *       therefore there is no overlapping.\\n         */\\n    \\tif ( (E>=C) || (F>= D) || (A>=G) || (B >= H) )\\n    \\t\\treturn 0;\\n\\n    \\t/* bottom left point of the overlapping area. */\\n    \\tint bl_x = Math.max(A, E);\\n    \\tint bl_y = Math.max(B, F);\\n\\n    \\t/* top right point of the overlapping area. */\\n    \\tint tr_x = Math.min(C, G);\\n    \\tint tr_y = Math.min(D, H);\\n    \\t\\n    \\treturn (tr_x - bl_x) * (tr_y - bl_y);\\n    }\\n    \\n    /**\\n     * Calculate the area of a single rectangle.\\n     */\\n    public int computeArea(int A, int B, int C, int D) {\\n    \\treturn (C-A) * (D-B);\\n    }\\n    \\n    /**\\n\\t * Find the total area covered by two rectilinear rectangles in a 2D plane.\\n\\t * Each rectangle is defined by its bottom left corner and top right corner.\\n\\t */\\n    public int computeArea(int A, int B, int C, int D,\\n    \\t\\t\\t\\t\\t   int E, int F, int G, int H) {\\n    \\t// The addition of area of the two rectangles minus the overlapping area.\\n    \\treturn computeArea(A, B, C, D) + computeArea(E, F, G, H) - \\n    \\t\\t   overlapArea(A, B, C, D, E, F, G, H);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "I guess the most tricky part of this problem is to check whether two rectangles have an overlapping if so how to calculate it. \\n\\nSo here is my \"verbose\" solution in Java. Hope it is self-explanatory.\\n\\n\\t/**\\n\\t * Calculate the overlapping area of two rectangles.\\n\\t */\\n    public int overlapArea(int A, int B, int C, int D,\\n         \\t\\t\\t        int E, int F, int G, int H) {\\n    \\t/* Check if there is indeed an overlap.\\n         * e.g.  E >= C  i.e. the most left point of the rectangle (EFGH) is \\n         *       on the right side of the most right point of the rectangle (ABCD),\\n         *       therefore there is no overlapping.\\n         */\\n    \\tif ( (E>=C) || (F>= D) || (A>=G) || (B >= H) )\\n    \\t\\treturn 0;\\n\\n    \\t/* bottom left point of the overlapping area. */\\n    \\tint bl_x = Math.max(A, E);\\n    \\tint bl_y = Math.max(B, F);\\n\\n    \\t/* top right point of the overlapping area. */\\n    \\tint tr_x = Math.min(C, G);\\n    \\tint tr_y = Math.min(D, H);\\n    \\t\\n    \\treturn (tr_x - bl_x) * (tr_y - bl_y);\\n    }\\n    \\n    /**\\n     * Calculate the area of a single rectangle.\\n     */\\n    public int computeArea(int A, int B, int C, int D) {\\n    \\treturn (C-A) * (D-B);\\n    }\\n    \\n    /**\\n\\t * Find the total area covered by two rectilinear rectangles in a 2D plane.\\n\\t * Each rectangle is defined by its bottom left corner and top right corner.\\n\\t */\\n    public int computeArea(int A, int B, int C, int D,\\n    \\t\\t\\t\\t\\t   int E, int F, int G, int H) {\\n    \\t// The addition of area of the two rectangles minus the overlapping area.\\n    \\treturn computeArea(A, B, C, D) + computeArea(E, F, G, H) - \\n    \\t\\t   overlapArea(A, B, C, D, E, F, G, H);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 62286,
                "title": "simple-0ms-c-solution-using-min-and-max-updated-again-to-avoid-overflow",
                "content": "The original version wasn't passing anymore because of new test cases that cause overflow. So now we're avoiding computing the differences below if the result will be negative. This avoids overflow in cases where the rectangles are far apart. It looks like this is basically the same thing that @shw1500 was suggesting, but you don't need the extra max function on the outside.\\n\\nThe return statement is based on comments from @StefanPochmann. We want to avoid forming the sum area(R1) + area(R2). This avoids overflow in cases where area(R1) + area(R2) will overflow, but area(R1) + area(R2) - overlap(R1, R2) fits in an int. There aren't any test cases for this. Add some maybe? Edit: There are test cases for this, but the overflow didn't matter.\\n\\nNew version- avoids overflow when area(R1) + area(R2) overflows but the answer shouldn't.\\n\\n    class Solution {\\n        public:\\n            int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n                int overlap_width = min(C, G) > max(A, E) ? min(C, G) - max(A, E) : 0; \\n                int overlap_height = min(D, H) > max(B, F) ? min(D, H) - max(B, F) : 0;\\n                return ((C - A) * (D - B) - overlap_width * overlap_height) + (G - E) * (H - F); // order avoids overflow\\n            }\\n        };\\n\\nSecond version- avoids overflow when rectangles are far apart\\n\\n    class Solution {\\n    public:\\n        int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n            int overlap_width = min(C, G) > max(A, E) ? min(C, G) - max(A, E) : 0; \\n            int overlap_height = min(D, H) > max(B, F) ? min(D, H) - max(B, F) : 0;\\n            return (C - A) * (D - B) + (G - E) * (H - F) - overlap_width * overlap_height;\\n        }\\n    };\\n\\nOld version- overflows for some inputs where the rectangles are far apart.\\n\\n    class Solution {\\n    public:\\n        int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n            int overlap_width = max(min(C, G) - max(A, E), 0), overlap_height = max(min(D, H) - max(B, F), 0);\\n            return (C - A) * (D - B) + (G - E) * (H - F) - overlap_width * overlap_height;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n        public:\\n            int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n                int overlap_width = min(C, G) > max(A, E) ? min(C, G) - max(A, E) : 0; \\n                int overlap_height = min(D, H) > max(B, F) ? min(D, H) - max(B, F) : 0;\\n                return ((C - A) * (D - B) - overlap_width * overlap_height) + (G - E) * (H - F); // order avoids overflow\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 665532,
                "title": "python-js-java-c-sol-by-math-w-hint",
                "content": "Time Complexity:\\nO(1) for basic math operations\\n\\nSpace Complexity:\\nO(1) for fixed number of local temporary variables\\n\\n---\\n\\n**Hint**:\\n\\n**Check** whether **overlapped area exists or not**.\\nIf yes, remember to subtract overlapped area.\\n\\nGeneral formula:\\n\\nFinal result = Area of first rectangle + Area of second rectangle **-** **Area of overlapped**\\n\\n---\\n\\n**Implementation** by **Python**:\\n\\n```\\nclass Solution:\\n    def computeArea(self, A: int, B: int, C: int, D: int, E: int, F: int, G: int, H: int) -> int:\\n        \\n        left_boundary = max(A, E)\\n        right_boundary = min(C, G)\\n        \\n        top_boundary = min(D, H)\\n        bottom_bondary = max(B, F)\\n        \\n        \\n        area_1 = (C - A)*(D - B)\\n        area_2 = (G - E)*(H - F)\\n        \\n        if (left_boundary < right_boundary) and (bottom_bondary < top_boundary):\\n            # area_1 and area_2 has overlapped area\\n            intersection = ( right_boundary - left_boundary ) * ( top_boundary - bottom_bondary )\\n\\t\\t\\t\\n        else:\\n            # area_1 and area_2 has no overlapped area\\n            intersection = 0\\n        \\n        return area_1 + area_2 - intersection\\n```\\n\\n---\\n\\n**Implementation** by **C++**:\\n\\n```\\nclass Solution {\\npublic:\\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        \\n        int left_boundary = max(ax1, bx1);\\n        int right_boundary = min(ax2, bx2);\\n        \\n        int top_boundary = min(ay2, by2);\\n        int bottom_bondary = max(ay1, by1);\\n        \\n        \\n        int area_1 = (ax2 - ax1)*(ay2 - ay1);\\n        int area_2 = (bx2 - bx1)*(by2 - by1);\\n        int intersection = 0;\\n        \\n        if( (left_boundary < right_boundary) && (bottom_bondary < top_boundary) ){\\n            // area_1 and area_2 has overlapped area\\n            intersection = ( right_boundary - left_boundary ) * ( top_boundary - bottom_bondary );\\n        }\\n\\n        \\n        return area_1 + area_2 - intersection;\\n    }\\n};\\n```\\n\\n---\\n\\n**Implementation** by **Java**:\\n\\n```\\nclass Solution {\\n    public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        \\n        int left_boundary = Math.max(ax1, bx1);\\n        int right_boundary = Math.min(ax2, bx2);\\n        \\n        int top_boundary = Math.min(ay2, by2);\\n        int bottom_bondary = Math.max(ay1, by1);\\n        \\n        \\n        int area_1 = (ax2 - ax1)*(ay2 - ay1);\\n        int area_2 = (bx2 - bx1)*(by2 - by1);\\n        int intersection = 0;\\n        \\n        if( (left_boundary < right_boundary) && (bottom_bondary < top_boundary) ){\\n            // area_1 and area_2 has overlapped area\\n            intersection = ( right_boundary - left_boundary ) * ( top_boundary - bottom_bondary );\\n        }\\n\\n        \\n        return area_1 + area_2 - intersection;\\n    }\\n}\\n```\\n\\n---\\n\\n**Implementation** by **JavaScript**:\\n\\n```\\nvar computeArea = function(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {\\n    \\n        let left_boundary = Math.max(ax1, bx1);\\n        let right_boundary = Math.min(ax2, bx2);\\n        \\n        let top_boundary = Math.min(ay2, by2);\\n        let bottom_bondary = Math.max(ay1, by1);\\n        \\n        \\n        let area_1 = (ax2 - ax1)*(ay2 - ay1);\\n        let area_2 = (bx2 - bx1)*(by2 - by1);\\n        let intersection = 0;\\n        \\n        if( (left_boundary < right_boundary) && (bottom_bondary < top_boundary) ){\\n            // area_1 and area_2 has overlapped area\\n            intersection = ( right_boundary - left_boundary ) * ( top_boundary - bottom_bondary );\\n        }\\n\\n        \\n        return area_1 + area_2 - intersection;\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def computeArea(self, A: int, B: int, C: int, D: int, E: int, F: int, G: int, H: int) -> int:\\n        \\n        left_boundary = max(A, E)\\n        right_boundary = min(C, G)\\n        \\n        top_boundary = min(D, H)\\n        bottom_bondary = max(B, F)\\n        \\n        \\n        area_1 = (C - A)*(D - B)\\n        area_2 = (G - E)*(H - F)\\n        \\n        if (left_boundary < right_boundary) and (bottom_bondary < top_boundary):\\n            # area_1 and area_2 has overlapped area\\n            intersection = ( right_boundary - left_boundary ) * ( top_boundary - bottom_bondary )\\n\\t\\t\\t\\n        else:\\n            # area_1 and area_2 has no overlapped area\\n            intersection = 0\\n        \\n        return area_1 + area_2 - intersection\\n```\n```\\nclass Solution {\\npublic:\\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        \\n        int left_boundary = max(ax1, bx1);\\n        int right_boundary = min(ax2, bx2);\\n        \\n        int top_boundary = min(ay2, by2);\\n        int bottom_bondary = max(ay1, by1);\\n        \\n        \\n        int area_1 = (ax2 - ax1)*(ay2 - ay1);\\n        int area_2 = (bx2 - bx1)*(by2 - by1);\\n        int intersection = 0;\\n        \\n        if( (left_boundary < right_boundary) && (bottom_bondary < top_boundary) ){\\n            // area_1 and area_2 has overlapped area\\n            intersection = ( right_boundary - left_boundary ) * ( top_boundary - bottom_bondary );\\n        }\\n\\n        \\n        return area_1 + area_2 - intersection;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        \\n        int left_boundary = Math.max(ax1, bx1);\\n        int right_boundary = Math.min(ax2, bx2);\\n        \\n        int top_boundary = Math.min(ay2, by2);\\n        int bottom_bondary = Math.max(ay1, by1);\\n        \\n        \\n        int area_1 = (ax2 - ax1)*(ay2 - ay1);\\n        int area_2 = (bx2 - bx1)*(by2 - by1);\\n        int intersection = 0;\\n        \\n        if( (left_boundary < right_boundary) && (bottom_bondary < top_boundary) ){\\n            // area_1 and area_2 has overlapped area\\n            intersection = ( right_boundary - left_boundary ) * ( top_boundary - bottom_bondary );\\n        }\\n\\n        \\n        return area_1 + area_2 - intersection;\\n    }\\n}\\n```\n```\\nvar computeArea = function(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {\\n    \\n        let left_boundary = Math.max(ax1, bx1);\\n        let right_boundary = Math.min(ax2, bx2);\\n        \\n        let top_boundary = Math.min(ay2, by2);\\n        let bottom_bondary = Math.max(ay1, by1);\\n        \\n        \\n        let area_1 = (ax2 - ax1)*(ay2 - ay1);\\n        let area_2 = (bx2 - bx1)*(by2 - by1);\\n        let intersection = 0;\\n        \\n        if( (left_boundary < right_boundary) && (bottom_bondary < top_boundary) ){\\n            // area_1 and area_2 has overlapped area\\n            intersection = ( right_boundary - left_boundary ) * ( top_boundary - bottom_bondary );\\n        }\\n\\n        \\n        return area_1 + area_2 - intersection;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2822706,
                "title": "c-easy-understandable-intutive-solution-video",
                "content": "**C++ Clear Explaination ,Please support if you find it usefull. Can give me feedback in comment for improvement.,will be very thankfull.**\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/btxtREq8fAQ\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen>\\n\\n\\n</iframe>\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n\\n        int AreaOfA = (ax2-ax1)*(ay2-ay1);\\n        int AreaOfB= (bx2-bx1)*(by2-by1);\\n\\n        int overlapR =0;\\n\\n        // x overlap.\\n        int xoverlap = min(ax2,bx2) - max(ax1,bx1);\\n        int yoverlap = min(ay2,by2) - max(ay1,by1);\\n\\n        if(xoverlap>0 && yoverlap>0)\\n        overlapR = xoverlap*yoverlap;\\n\\n        return AreaOfA+AreaOfB-overlapR;\\n\\n\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n\\n        int AreaOfA = (ax2-ax1)*(ay2-ay1);\\n        int AreaOfB= (bx2-bx1)*(by2-by1);\\n\\n        int overlapR =0;\\n\\n        // x overlap.\\n        int xoverlap = min(ax2,bx2) - max(ax1,bx1);\\n        int yoverlap = min(ay2,by2) - max(ay1,by1);\\n\\n        if(xoverlap>0 && yoverlap>0)\\n        overlapR = xoverlap*yoverlap;\\n\\n        return AreaOfA+AreaOfB-overlapR;\\n\\n\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 62272,
                "title": "two-lines-ac-java-code",
                "content": "    public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        int common = (C <= E || A >= G || B >= H || D <= F) ? 0 : (Math.min(C, G) - Math.max(A, E)) * (Math.min(D, H) - Math.max(B, F));\\n        return (C - A) * (D - B) + (G - E) * (H - F) - common;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        int common = (C <= E || A >= G || B >= H || D <= F) ? 0 : (Math.min(C, G) - Math.max(A, E)) * (Math.min(D, H) - Math.max(B, F));\\n        return (C - A) * (D - B) + (G - E) * (H - F) - common;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 62316,
                "title": "accepted-c-solution-too-simple-to-explain",
                "content": "    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n    \\tint area=(C-A)*(D-B)+(G-E)*(H-F);\\n    \\t// no overlap\\n    \\tif (A>=G||E>=C||B>=H||D<=F)\\n    \\t{\\n    \\t\\treturn area;\\n    \\t}\\n    \\n    \\tint x1= A>E?A:E;\\n    \\tint x2= C<G?C:G;\\n    \\n    \\tint y1= B>F?B:F;\\n    \\tint y2= D<H?D:H;\\n    \\n    \\treturn area-(x2-x1)*(y2-y1);\\n    }\\njust calculate the areas of two rectangles, and minus the overlap area if exists",
                "solutionTags": [],
                "code": "    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n    \\tint area=(C-A)*(D-B)+(G-E)*(H-F);\\n    \\t// no overlap\\n    \\tif (A>=G||E>=C||B>=H||D<=F)\\n    \\t{\\n    \\t\\treturn area;\\n    \\t}\\n    \\n    \\tint x1= A>E?A:E;\\n    \\tint x2= C<G?C:G;\\n    \\n    \\tint y1= B>F?B:F;\\n    \\tint y2= D<H?D:H;\\n    \\n    \\treturn area-(x2-x1)*(y2-y1);\\n    }\\njust calculate the areas of two rectangles, and minus the overlap area if exists",
                "codeTag": "Unknown"
            },
            {
                "id": 62241,
                "title": "easy-to-understand-python-solution-sum-of-areas-overlapped-area",
                "content": "    class Solution(object):\\n        def computeArea(self, A, B, C, D, E, F, G, H):\\n            \"\"\"\\n            :type A: int\\n            :type B: int\\n            :type C: int\\n            :type D: int\\n            :type E: int\\n            :type F: int\\n            :type G: int\\n            :type H: int\\n            :rtype: int\\n            \"\"\"\\n            total=(C-A)*(D-B)+(G-E)*(H-F)\\n            if E>C or F>D or G<A or H<B:\\n                # no overlap\\n                return total\\n            I,J=max(A,E), max(B,F) # overlap bottom left corner\\n            K,L=min(C,G), min(D,H) # overlap top right corner\\n            return total-(K-I)*(L-J)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def computeArea(self, A, B, C, D, E, F, G, H):\\n            \"\"\"\\n            :type A: int\\n            :type B: int\\n            :type C: int\\n            :type D: int\\n            :type E: int\\n            :type F: int\\n            :type G: int\\n            :type H: int\\n            :rtype: int\\n            \"\"\"\\n            total=(C-A)*(D-B)+(G-E)*(H-F)\\n            if E>C or F>D or G<A or H<B:\\n                # no overlap\\n                return total\\n            I,J=max(A,E), max(B,F) # overlap bottom left corner\\n            K,L=min(C,G), min(D,H) # overlap top right corner\\n            return total-(K-I)*(L-J)",
                "codeTag": "Java"
            },
            {
                "id": 2822409,
                "title": "fastest-python-solution",
                "content": "```\\nclass Solution:\\n    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:\\n        coxl=max(ax1,bx1)\\n        coxr=min(ax2,bx2)\\n        coyl=max(ay1,by1)\\n        coyr=min(ay2,by2)\\n        dx=coxr-coxl\\n        dy=coyr-coyl\\n        comm=0\\n        if dx>0 and dy>0:\\n            comm=dx*dy\\n        a=abs(ax2-ax1)*abs(ay2-ay1)\\n        b=abs(bx2-bx1)*abs(by2-by1)\\n        area=a+b-comm\\n        return area\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:\\n        coxl=max(ax1,bx1)\\n        coxr=min(ax2,bx2)\\n        coyl=max(ay1,by1)\\n        coyr=min(ay2,by2)\\n        dx=coxr-coxl\\n        dy=coyr-coyl\\n        comm=0\\n        if dx>0 and dy>0:\\n            comm=dx*dy\\n        a=abs(ax2-ax1)*abs(ay2-ay1)\\n        b=abs(bx2-bx1)*abs(by2-by1)\\n        area=a+b-comm\\n        return area\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1523773,
                "title": "o-1-10-line-code-easy-to-understand",
                "content": "```\\n//O(1)\\nclass Solution {\\npublic:\\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        int area1 = (ax2-ax1) * (ay2-ay1);\\n        int area2 = (bx2-bx1) * (by2-by1);\\n        int comarea = 0;\\n        \\n        int left = max(ax1, bx1);\\n        int right = min(ax2, bx2);\\n        int top = min(ay2, by2);\\n        int bottom = max(ay1, by1);\\n        \\n        if(left < right && top > bottom)\\n            comarea = (right-left) *(top-bottom);\\n            \\n        return area1 + area2 - comarea;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        int area1 = (ax2-ax1) * (ay2-ay1);\\n        int area2 = (bx2-bx1) * (by2-by1);\\n        int comarea = 0;\\n        \\n        int left = max(ax1, bx1);\\n        int right = min(ax2, bx2);\\n        int top = min(ay2, by2);\\n        int bottom = max(ay1, by1);\\n        \\n        if(left < right && top > bottom)\\n            comarea = (right-left) *(top-bottom);\\n            \\n        return area1 + area2 - comarea;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2822392,
                "title": "explanation-with-comments-java-cpp-totalarea-overlappedarea-easy-solution",
                "content": "Okay, so it\\'s a very basic question where we simply need to calculate the total area and subtract the overlapped area from it.\\n\\n```\\n\\ttotalArea = areaA + areaB - overlappedArea\\n```\\n\\nTo calculate overlappedArea, we need to check whether the left boundary of one rectangle and right boundary of another rectangle overlaps or not, similar for the upper and lower boundary\\n\\nTo check it, simply we can calculate which right boundary is smaller and which left boundary is larger, similar thing for lower and upper boundaries\\n\\n```\\n\\tright_boundary = min(right_boundary_of_first_rectangle, right_boundary_of_second_rectangle);\\n\\tleft_boundary = max(left_boundary_of_first_rectangle, left_boudary_of_second_rectangle);\\n```\\n\\nThen if smaller_right_boundary > larger_left_boundary && smaller_upper_boundary > larger_lower_boundary,  then we can say that our rectangles are overlapping. \\n\\n```\\n\\tif(right_boundary > left_boundary && upper_boundary > lower_boundary) {\\n\\t\\t// Rectangles Are Overlapping\\n\\t}\\n```\\n\\nSo, simply we can subtract the overlapped rectangle having this four points (smaller_right_boundary, larger_left_boundary,  smaller_upper_boundary && larger_lower_boundary) as its four coordinate and we will get our required Area !!!\\n\\n```\\n\\toverlappedArea = (right_boundary - left_boundary) * (upper_boundary - lower_boundary);\\n```\\n\\nWe can also write 8 cases to check whether rectangles are overlapping or not, but that is not required if we could figure out this logic to check overlapping of rectangles.\\n\\nCode (Java) : \\n\\n\\n```\\nclass Solution {\\n    public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        \\n        // Calculating Area Of A and B\\n        int areaA = (ax2 - ax1) * (ay2 - ay1);\\n        int areaB = (bx2 - bx1) * (by2 - by1);\\n        \\n        // Calculating The Left Boundary\\n        int left_boundary = Math.max(ax1, bx1);\\n        \\n        // Calculating The Right Boundary\\n        int right_boundary = Math.min(bx2, ax2);\\n        \\n        // Calculating The Up Boundary\\n        int upper_boundary = Math.min(by2, ay2);\\n        \\n        // Calculating The Down Boundary\\n        int lower_boundary = Math.max(ay1, by1);\\n        \\n        // Total Area\\n        int totalArea = areaA + areaB;\\n        \\n        // If Both Reactangle Overlaps\\n        if(right_boundary > left_boundary && upper_boundary > lower_boundary) totalArea -= ((right_boundary - left_boundary) * (upper_boundary - lower_boundary));\\n        \\n        return totalArea;\\n        \\n        \\n    }\\n}\\n```\\n\\n\\nCode (C++) : \\n\\n```\\nclass Solution {\\npublic:\\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        // Calculating Area Of A and B\\n        int areaA = (ax2 - ax1) * (ay2 - ay1);\\n        int areaB = (bx2 - bx1) * (by2 - by1);\\n        \\n        // Calculating The Left Boundary\\n        int left_boundary = max(ax1, bx1);\\n        \\n        // Calculating The Right Boundary\\n        int right_boundary = min(bx2, ax2);\\n        \\n        // Calculating The Up Boundary\\n        int upper_boundary = min(by2, ay2);\\n        \\n        // Calculating The Down Boundary\\n        int lower_boundary = max(ay1, by1);\\n        \\n        // Total Area\\n        int totalArea = areaA + areaB;\\n        \\n        // If Both Reactangle Overlaps\\n        if(right_boundary > left_boundary && upper_boundary > lower_boundary) totalArea -= ((right_boundary - left_boundary) * (upper_boundary - lower_boundary));\\n        \\n        return totalArea;\\n    }\\n};\\n```\\n\\nThank You !!!",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Math"
                ],
                "code": "```\\n\\ttotalArea = areaA + areaB - overlappedArea\\n```\n```\\n\\tright_boundary = min(right_boundary_of_first_rectangle, right_boundary_of_second_rectangle);\\n\\tleft_boundary = max(left_boundary_of_first_rectangle, left_boudary_of_second_rectangle);\\n```\n```\\n\\tif(right_boundary > left_boundary && upper_boundary > lower_boundary) {\\n\\t\\t// Rectangles Are Overlapping\\n\\t}\\n```\n```\\n\\toverlappedArea = (right_boundary - left_boundary) * (upper_boundary - lower_boundary);\\n```\n```\\nclass Solution {\\n    public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        \\n        // Calculating Area Of A and B\\n        int areaA = (ax2 - ax1) * (ay2 - ay1);\\n        int areaB = (bx2 - bx1) * (by2 - by1);\\n        \\n        // Calculating The Left Boundary\\n        int left_boundary = Math.max(ax1, bx1);\\n        \\n        // Calculating The Right Boundary\\n        int right_boundary = Math.min(bx2, ax2);\\n        \\n        // Calculating The Up Boundary\\n        int upper_boundary = Math.min(by2, ay2);\\n        \\n        // Calculating The Down Boundary\\n        int lower_boundary = Math.max(ay1, by1);\\n        \\n        // Total Area\\n        int totalArea = areaA + areaB;\\n        \\n        // If Both Reactangle Overlaps\\n        if(right_boundary > left_boundary && upper_boundary > lower_boundary) totalArea -= ((right_boundary - left_boundary) * (upper_boundary - lower_boundary));\\n        \\n        return totalArea;\\n        \\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        // Calculating Area Of A and B\\n        int areaA = (ax2 - ax1) * (ay2 - ay1);\\n        int areaB = (bx2 - bx1) * (by2 - by1);\\n        \\n        // Calculating The Left Boundary\\n        int left_boundary = max(ax1, bx1);\\n        \\n        // Calculating The Right Boundary\\n        int right_boundary = min(bx2, ax2);\\n        \\n        // Calculating The Up Boundary\\n        int upper_boundary = min(by2, ay2);\\n        \\n        // Calculating The Down Boundary\\n        int lower_boundary = max(ay1, by1);\\n        \\n        // Total Area\\n        int totalArea = areaA + areaB;\\n        \\n        // If Both Reactangle Overlaps\\n        if(right_boundary > left_boundary && upper_boundary > lower_boundary) totalArea -= ((right_boundary - left_boundary) * (upper_boundary - lower_boundary));\\n        \\n        return totalArea;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1202022,
                "title": "sweet-c-solution-with-an-image-explaining-how",
                "content": "1) Find the areas of the individual rectangles.\\n2) Find the area of the overlapping rectangle.\\n3) Subtract them for the result!\\n\\n![image](https://assets.leetcode.com/users/images/286e12d6-e889-4bc4-bc5e-1c5f912b3183_1620701668.0335035.jpeg)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        int h1 = ay2 - ay1;\\n        int h2 = by2 - by1;\\n        int w1 = ax2 - ax1;\\n        int w2 = bx2 - bx1;\\n        int area = h1 * w1 + h2 * w2;\\n        int overlapping_h = min(ay2, by2) - max(by1, ay1);\\n        int overlapping_w = min(ax2, bx2) - max(bx1, ax1);\\n        if(overlapping_h > 0 && overlapping_w > 0) area -= overlapping_h * overlapping_w;\\n        return area;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        int h1 = ay2 - ay1;\\n        int h2 = by2 - by1;\\n        int w1 = ax2 - ax1;\\n        int w2 = bx2 - bx1;\\n        int area = h1 * w1 + h2 * w2;\\n        int overlapping_h = min(ay2, by2) - max(by1, ay1);\\n        int overlapping_w = min(ax2, bx2) - max(bx1, ax1);\\n        if(overlapping_h > 0 && overlapping_w > 0) area -= overlapping_h * overlapping_w;\\n        return area;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 62233,
                "title": "c-solution-32ms",
                "content": "    class Solution {\\n    public:\\n        int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n            int l = min(max(A, E), C);\\n            int r = min(max(A, G), C);\\n            int t = min(max(B, H), D);\\n            int b = min(max(B, F), D);\\n            return (C-A)*(D-B) + (G-E)*(H-F) - (r-l)*(t-b);\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n            int l = min(max(A, E), C);\\n            int r = min(max(A, G), C);\\n            int t = min(max(B, H), D);\\n            int b = min(max(B, F), D);\\n            return (C-A)*(D-B) + (G-E)*(H-F) - (r-l)*(t-b);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 62291,
                "title": "why-do-you-expect-4-instead-of-0-with-input-0-0-0-0-1-1-1-1",
                "content": "The question says: Find the total area covered by two rectilinear rectangles in a 2D plane, but expects a result of 4 when input is  (0, 0, 0, 0, -1, -1, 1, 1).\\n\\nIt's confusing for a non native English speaker and new timer here, how would a zero-sized rectangle cover a rectangle sized 4?\\n\\nAnd here is my code in C#:\\n\\n    public class Solution {\\n        public int ComputeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n            \\n            var bottom = Math.Max(B, F);\\n            var top = Math.Min(D, H);\\n            var left = Math.Max(A, E);\\n            var right = Math.Min(C, G);\\n            \\n            if(bottom >= top || left >= right)\\n                return 0;\\n                \\n            return (top - bottom) * (right - left);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int ComputeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n            \\n            var bottom = Math.Max(B, F);\\n            var top = Math.Min(D, H);\\n            var left = Math.Max(A, E);\\n            var right = Math.Min(C, G);\\n            \\n            if(bottom >= top || left >= right)\\n                return 0;\\n                \\n            return (top - bottom) * (right - left);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 62269,
                "title": "my-python-solutions",
                "content": "    class Solution:\\n        def computeArea(self, A, B, C, D, E, F, G, H):\\n            areaA = (C - A) * (D - B)\\n            areaB = (G - E) * (H - F)\\n            l = max(0, min(C, G) - max(A, E))\\n            h = max(0, min(D, H) - max(B, F))\\n            return areaA + areaB - l * h",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        def computeArea(self, A, B, C, D, E, F, G, H):\\n            areaA = (C - A) * (D - B)\\n            areaB = (G - E) * (H - F)\\n            l = max(0, min(C, G) - max(A, E))\\n            h = max(0, min(D, H) - max(B, F))\\n            return areaA + areaB - l * h",
                "codeTag": "Java"
            },
            {
                "id": 2824547,
                "title": "python3-readable-code-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nThis is a very popular algorithm for calculation the IoU (intersection over union) in Deep Learning algorithms. Firs\\u0435, we calculate areas of both rectangles and then get their sum `S`. Since the area of the overlap is included twice in the `S`, we need to remove the redundant value. If rectangles do not overlap at all, we just return the sum of areas.\\n\\n```\\nclass Solution:\\n    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:\\n        Sa = (ax2-ax1) * (ay2-ay1)\\n        Sb = (bx2-bx1) * (by2-by1)\\n        S = Sa + Sb\\n        \\n        w_ov = min(ax2, bx2) - max(ax1, bx1)\\n        if w_ov <= 0:\\n            return S\\n        \\n        h_ov = min(ay2, by2) - max(ay1, by1)\\n        if h_ov <= 0:\\n            return S\\n        \\n        S_ov = w_ov * h_ov\\n        \\n        return S - S_ov\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:\\n        Sa = (ax2-ax1) * (ay2-ay1)\\n        Sb = (bx2-bx1) * (by2-by1)\\n        S = Sa + Sb\\n        \\n        w_ov = min(ax2, bx2) - max(ax1, bx1)\\n        if w_ov <= 0:\\n            return S\\n        \\n        h_ov = min(ay2, by2) - max(ay1, by1)\\n        if h_ov <= 0:\\n            return S\\n        \\n        S_ov = w_ov * h_ov\\n        \\n        return S - S_ov\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2823591,
                "title": "c-if-you-know-coding-you-can-solve-this-question-see-how",
                "content": "# Thought Process:\\nLike the heading says, *\"If you know C++, You can solve this question!\"*.\\nIf you are getting wrong answer, then you are probably missing out some cases. Let\\'s examine them all !!\\n \\n Note: -\\n ```\\n Here,\\n \\n x = Common length  along x axis.\\n y = Common length along y axis.\\n (.) = ax1 on the number line.\\n (..) = ax2 on the number line.\\n (*) = bx1 on the number line.\\n (**) = bx2 on the number line\\n ```\\n \\n **COMMON LENGTH ALONG X- AXIS**\\n \\n **Case 1:**\\n```\\n(.)---------------(..)\\n            (*)-----------------(**)\\n\\nor\\n\\n(.)---------------(..)\\n(*)--------------------(**)\\n\\nor \\n\\n(.)---------------(..)\\n      (*)----(**)\\n\\t  \\nor\\n\\n(.)---------------(..)\\n(*)------(**)\\n\\nTo handle above cases, we will write: -\\nif (ax1 <= bx1 && bx1 < ax2) x = abs (min (ax2,bx2)-bx1);\\n```\\n\\n**Case 2:**\\n```\\n            (.)---------------(..)\\n(*)-----------------(**)\\n\\nor\\n\\n        (.)---------------(..)\\n(*)-----------------------(**)\\n\\nor \\n\\n(.)---------------(..)\\n      (*)----(**)\\n\\t  \\nor\\n\\n(.)---------------(..)\\n            (*)---(**)\\n\\nTo handle above cases, we will write: -\\nelse if (ax1 < bx2 && bx2 <= ax2) x = abs (max (ax1,bx1)-bx2);\\n```\\n\\n**Case 3:**\\n```\\n(*)---------------(**)\\n            (.)-----------------(..)\\n\\nor\\n\\n(*)---------------(**)\\n(.)--------------------(..)\\n\\nor \\n\\n(*)---------------(**)\\n      (.)----(..)\\n\\t  \\nor\\n\\n(*)---------------(**)\\n(.)------(.)\\n\\nTo handle above cases, we will write: -\\nelse if (bx1 <= ax1 && ax1 < bx2) x = abs (min (bx2,ax2)-ax1);\\n```\\n\\n**Case 4:**\\n```\\n            (*)---------------(**)\\n(.)-----------------(..)\\n\\nor\\n\\n        (*)---------------(**)\\n(.)-----------------------(..)\\n\\nor \\n\\n(*)---------------(**)\\n      (.)----(..)\\n\\t  \\nor\\n\\n(*)---------------(**)\\n            (.)---(..)\\n\\nTo handle above cases, we will write: -\\nelse if (bx1 < ax2 && ax2 <= bx2) x = abs (max (bx1,ax1)-ax2);\\n```\\n\\nSimilary, we have to this for Y-axis.\\n\\n```result = Area of rectangle \\'a\\' + Area of rectangle \\'b\\' - common area```\\n\\n```\\nclass Solution {\\npublic:\\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        int x = 0, y = 0;\\n        \\n        if (ax1 <= bx1 && bx1 < ax2) x = abs (min (ax2,bx2)-bx1);\\n        else if (ax1 < bx2 && bx2 <= ax2) x = abs (max (ax1,bx1)-bx2);        \\n        else if (bx1 <= ax1 && ax1 < bx2) x = abs (min (bx2,ax2)-ax1);\\n        else if (bx1 < ax2 && ax2 <= bx2) x = abs (max (bx1,ax1)-ax2);\\n        \\n        if (ay1 <= by1 && by1 < ay2) y= abs (by1-min (by2,ay2));\\n        else if (ay1 < by2 && by2 <= ay2) y = abs (max (ay1, by1)-by2);\\n        else if (by1 <= ay1 && ay1 < by2) y = abs (ay1 - min (by2,ay2));\\n        else if (by1 < ay2 && ay2 <= by2) y = abs (ay2 - max (ay1,by1)); \\n        \\n        return abs(ax1-ax2)*abs(ay1-ay2) + abs (bx1-bx2)*abs(by1-by2) - x*y;\\n    }\\n};\\n```\\n\\n# Complexities:\\n**TC:** O(1)\\n**SC:** O(1)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n Here,\\n \\n x = Common length  along x axis.\\n y = Common length along y axis.\\n (.) = ax1 on the number line.\\n (..) = ax2 on the number line.\\n (*) = bx1 on the number line.\\n (**) = bx2 on the number line\\n ```\n```\\n(.)---------------(..)\\n            (*)-----------------(**)\\n\\nor\\n\\n(.)---------------(..)\\n(*)--------------------(**)\\n\\nor \\n\\n(.)---------------(..)\\n      (*)----(**)\\n\\t  \\nor\\n\\n(.)---------------(..)\\n(*)------(**)\\n\\nTo handle above cases, we will write: -\\nif (ax1 <= bx1 && bx1 < ax2) x = abs (min (ax2,bx2)-bx1);\\n```\n```\\n            (.)---------------(..)\\n(*)-----------------(**)\\n\\nor\\n\\n        (.)---------------(..)\\n(*)-----------------------(**)\\n\\nor \\n\\n(.)---------------(..)\\n      (*)----(**)\\n\\t  \\nor\\n\\n(.)---------------(..)\\n            (*)---(**)\\n\\nTo handle above cases, we will write: -\\nelse if (ax1 < bx2 && bx2 <= ax2) x = abs (max (ax1,bx1)-bx2);\\n```\n```\\n(*)---------------(**)\\n            (.)-----------------(..)\\n\\nor\\n\\n(*)---------------(**)\\n(.)--------------------(..)\\n\\nor \\n\\n(*)---------------(**)\\n      (.)----(..)\\n\\t  \\nor\\n\\n(*)---------------(**)\\n(.)------(.)\\n\\nTo handle above cases, we will write: -\\nelse if (bx1 <= ax1 && ax1 < bx2) x = abs (min (bx2,ax2)-ax1);\\n```\n```\\n            (*)---------------(**)\\n(.)-----------------(..)\\n\\nor\\n\\n        (*)---------------(**)\\n(.)-----------------------(..)\\n\\nor \\n\\n(*)---------------(**)\\n      (.)----(..)\\n\\t  \\nor\\n\\n(*)---------------(**)\\n            (.)---(..)\\n\\nTo handle above cases, we will write: -\\nelse if (bx1 < ax2 && ax2 <= bx2) x = abs (max (bx1,ax1)-ax2);\\n```\n```result = Area of rectangle \\'a\\' + Area of rectangle \\'b\\' - common area```\n```\\nclass Solution {\\npublic:\\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        int x = 0, y = 0;\\n        \\n        if (ax1 <= bx1 && bx1 < ax2) x = abs (min (ax2,bx2)-bx1);\\n        else if (ax1 < bx2 && bx2 <= ax2) x = abs (max (ax1,bx1)-bx2);        \\n        else if (bx1 <= ax1 && ax1 < bx2) x = abs (min (bx2,ax2)-ax1);\\n        else if (bx1 < ax2 && ax2 <= bx2) x = abs (max (bx1,ax1)-ax2);\\n        \\n        if (ay1 <= by1 && by1 < ay2) y= abs (by1-min (by2,ay2));\\n        else if (ay1 < by2 && by2 <= ay2) y = abs (max (ay1, by1)-by2);\\n        else if (by1 <= ay1 && ay1 < by2) y = abs (ay1 - min (by2,ay2));\\n        else if (by1 < ay2 && ay2 <= by2) y = abs (ay2 - max (ay1,by1)); \\n        \\n        return abs(ax1-ax2)*abs(ay1-ay2) + abs (bx1-bx2)*abs(by1-by2) - x*y;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2822810,
                "title": "easy-simple-c",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n  int area = (abs(ax1-ax2)*abs(ay1-ay2))+(abs(bx1-bx2)*abs(by1-by2));\\n     //*** area = area of 1st + 2nd rectangle\\n\\n     int ox1 = max(ax1,bx1);   // ** left edge of overlapping region\\n     int oy1 = max(ay1,by1);   // ** bottom edge of overlapping region\\n     int ox2 = min(ax2,bx2);   // ** right edge of overlapping region\\n     int oy2 = min(ay2,by2);   // ** top edge of overlapping region\\n      \\n      if(ox2>ox1 && oy2>oy1){\\n          area -= ((ox1-ox2)*(oy1-oy2));\\n      }\\n\\n     return area;\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n  int area = (abs(ax1-ax2)*abs(ay1-ay2))+(abs(bx1-bx2)*abs(by1-by2));\\n     //*** area = area of 1st + 2nd rectangle\\n\\n     int ox1 = max(ax1,bx1);   // ** left edge of overlapping region\\n     int oy1 = max(ay1,by1);   // ** bottom edge of overlapping region\\n     int ox2 = min(ax2,bx2);   // ** right edge of overlapping region\\n     int oy2 = min(ay2,by2);   // ** top edge of overlapping region\\n      \\n      if(ox2>ox1 && oy2>oy1){\\n          area -= ((ox1-ox2)*(oy1-oy2));\\n      }\\n\\n     return area;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 62247,
                "title": "easy-understanding-concise-java-solution",
                "content": "    public class Solution {\\n        public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n            int a = (C-A)*(D-B), b = (G-E)*(H-F);\\n            return a + b - overlap(A, C, E, G) * overlap(F, H, B, D);\\n        }\\n        \\n        private int overlap(int a, int b, int c, int d) {\\n            if (b<=c || d<=a) { return 0; }  // not overlapping\\n            return Math.min(b, d) - Math.max(a, c);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n            int a = (C-A)*(D-B), b = (G-E)*(H-F);\\n            return a + b - overlap(A, C, E, G) * overlap(F, H, B, D);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 62282,
                "title": "a-clear-js-solution",
                "content": "    var computeArea = function(A, B, C, D, E, F, G, H) {\\n        var intersectionWidth = Math.min(C,G) - Math.max(A,E);\\n        var intersectionHeight = Math.min(D,H) - Math.max(B,F);\\n        intersectionWidth = intersectionWidth > 0 ? intersectionWidth : 0;\\n        intersectionHeight = intersectionHeight > 0 ? intersectionHeight : 0;\\n        return (C - A) * (D - B) + (G - E) * (H - F) - intersectionWidth * intersectionHeight;\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var computeArea = function(A, B, C, D, E, F, G, H) {\\n        var intersectionWidth = Math.min(C,G) - Math.max(A,E);\\n        var intersectionHeight = Math.min(D,H) - Math.max(B,F);\\n        intersectionWidth = intersectionWidth > 0 ? intersectionWidth : 0;\\n        intersectionHeight = intersectionHeight > 0 ? intersectionHeight : 0;\\n        return (C - A) * (D - B) + (G - E) * (H - F) - intersectionWidth * intersectionHeight;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 62283,
                "title": "using-c-i-think-my-code-is-vey-short",
                "content": "    nt computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        if(E>=C||G<=A||B>=H||F>=D)\\n        return (C-A)*(D-B)+(G-E)*(H-F);\\n        else\\n        return (C-A)*(D-B)+(G-E)*(H-F)-abs(max(A,E)-min(C,G))*abs(max(B,F)-min(D,H));\\n    }",
                "solutionTags": [],
                "code": "    nt computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        if(E>=C||G<=A||B>=H||F>=D)\\n        return (C-A)*(D-B)+(G-E)*(H-F);\\n        else\\n        return (C-A)*(D-B)+(G-E)*(H-F)-abs(max(A,E)-min(C,G))*abs(max(B,F)-min(D,H));\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 62340,
                "title": "the-tests-are-bad",
                "content": "The tests should include cases like these:\\n\\n`computeArea(0, 0, 1, 1, 8, 8, 9, 9)`  => area: 1 + 1 = 2  \\n`computeArea(0, 0, 1, 1, 8, 0, 9, 1)`  => area: 1 + 1 = 2\\n\\nCurrently there's apparently not a single test case where the two rectangles don't touch, and wrong solutions that don't handle such cases get accepted.\\n\\nFor example, this gets accepted even though it returns -47 and 9 for the above examples:\\n\\n    def computeArea(self, left1, bottom1, right1, top1, left2, bottom2, right2, top2):\\n        first = (right1 - left1) * (top1 - bottom1)\\n        second = (right2 - left2) * (top2 - bottom2)\\n        overlap_width = min(right1, right2) - max(left1, left2)\\n        overlap_height = min(top1, top2) - max(bottom1, bottom2)\\n        return first + second - overlap_width * overlap_height",
                "solutionTags": [],
                "code": "The tests should include cases like these:\\n\\n`computeArea(0, 0, 1, 1, 8, 8, 9, 9)`  => area: 1 + 1 = 2  \\n`computeArea(0, 0, 1, 1, 8, 0, 9, 1)`  => area: 1 + 1 = 2\\n\\nCurrently there's apparently not a single test case where the two rectangles don't touch, and wrong solutions that don't handle such cases get accepted.\\n\\nFor example, this gets accepted even though it returns -47 and 9 for the above examples:\\n\\n    def computeArea(self, left1, bottom1, right1, top1, left2, bottom2, right2, top2):\\n        first = (right1 - left1) * (top1 - bottom1)\\n        second = (right2 - left2) * (top2 - bottom2)\\n        overlap_width = min(right1, right2) - max(left1, left2)\\n        overlap_height = min(top1, top2) - max(bottom1, bottom2)\\n        return first + second - overlap_width * overlap_height",
                "codeTag": "Python3"
            },
            {
                "id": 2822407,
                "title": "python-3-2-lines-geometry-w-explanation-t-m-97-98",
                "content": "```\\nclass Solution:\\n    def computeArea(self, ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) -> int:\\n        \\n        int_area = (max((min(ay2, by2)-max(ay1, by1)),0)*               #  int_area is the area of the rectangles\\' \\n                    max((min(ax2, bx2)-max(ax1, bx1)),0))               #  intersection. If no intersection, int_area == 0\\n                       \\n        return ((ax2-ax1)*(ay2-ay1) +                                   #  area of rectangle A +\\n                (bx2-bx1)*(by2-by1) -                                   #  area of rectangle B -\\n                int_area              )                                 #  area of the intersection, if any\\n```\\n[https://leetcode.com/submissions/detail/635540335/](http://)\\n\\nI could be wrong, but I think it\\'s *O*(1) / *O*(1).",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def computeArea(self, ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) -> int:\\n        \\n        int_area = (max((min(ay2, by2)-max(ay1, by1)),0)*               #  int_area is the area of the rectangles\\' \\n                    max((min(ax2, bx2)-max(ax1, bx1)),0))               #  intersection. If no intersection, int_area == 0\\n                       \\n        return ((ax2-ax1)*(ay2-ay1) +                                   #  area of rectangle A +\\n                (bx2-bx1)*(by2-by1) -                                   #  area of rectangle B -\\n                int_area              )                                 #  area of the intersection, if any\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2822204,
                "title": "daily-leetcoding-challenge-november-day-17",
                "content": "This problem is the Daily LeetCoding Challenge for November, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/rectangle-area/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/rectangle-area/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 447983,
                "title": "java-beat-100-few-lines",
                "content": "1, Math.max to check overlapping;\\n2, use long to avoid out of int bound.\\n```\\nclass Solution {\\n    public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        long rec1 = (C - A) * (D - B);\\n        long rec2 = (G - E) * (H - F);\\n        \\n        long left = Math.max(A, E);\\n        long right = Math.min(C, G);\\n        long bottom = Math.max(B, F);\\n        long top = Math.min(D, H);\\n\\n        long rec3 = Math.max(0, right -left) * Math.max(0, top - bottom);\\n        \\n        return (int)(rec1 + rec2 - rec3);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        long rec1 = (C - A) * (D - B);\\n        long rec2 = (G - E) * (H - F);\\n        \\n        long left = Math.max(A, E);\\n        long right = Math.min(C, G);\\n        long bottom = Math.max(B, F);\\n        long top = Math.min(D, H);\\n\\n        long rec3 = Math.max(0, right -left) * Math.max(0, top - bottom);\\n        \\n        return (int)(rec1 + rec2 - rec3);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 425670,
                "title": "one-line-python-solution",
                "content": "The max terms are calculating the overlap areas:\\n```\\ndef computeArea(self, A, B, C, D, E, F, G, H):\\n\\treturn (C-A)*(D-B)+(G-E)*(H-F)-max(min(G, C) - max(A, E),0)*max(min(D,H) - max(B, F),0)\\n```",
                "solutionTags": [],
                "code": "```\\ndef computeArea(self, A, B, C, D, E, F, G, H):\\n\\treturn (C-A)*(D-B)+(G-E)*(H-F)-max(min(G, C) - max(A, E),0)*max(min(D,H) - max(B, F),0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 337710,
                "title": "intuitive-draw-solution",
                "content": "Let\\'s draw possible situations.\\nAssume x1 < x2 < x3 < x4, y1 < y2 < y3 < y4\\n![image](https://assets.leetcode.com/users/go2018/image_1563414701.png)\\n![image](https://assets.leetcode.com/users/go2018/image_1563414739.png)\\n\\nfind out cover area = |x2 - x3| * |y2 - y3|, so we need to find the second and third large x, y.\\nNotice there is an exception that no cover area between two rectangles.\\n```\\npublic int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        \\n        int totalArea = (C - A) * (D - B) + (G - E) * (H - F);\\n        int x = Math.min(C, G) -  Math.max(A, E);\\n        int y = Math.min(D, H) - Math.max(B, F);\\n        // no cover area\\n        if (E > C || A > G) return totalArea;  \\n        int coverArea = 0;\\n        \\n        if (x > 0 && y > 0)\\n            coverArea = x * y;\\n        return totalArea - coverArea;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        \\n        int totalArea = (C - A) * (D - B) + (G - E) * (H - F);\\n        int x = Math.min(C, G) -  Math.max(A, E);\\n        int y = Math.min(D, H) - Math.max(B, F);\\n        // no cover area\\n        if (E > C || A > G) return totalArea;  \\n        int coverArea = 0;\\n        \\n        if (x > 0 && y > 0)\\n            coverArea = x * y;\\n        return totalArea - coverArea;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 62217,
                "title": "c-easy-understanding",
                "content": "    class Solution {\\n    public:\\n        int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n            int area1 = (C - A) * (D - B);\\n            int area2 = (G - E) * (H - F);\\n            int total = area1 + area2;\\n            int maxLeft = max(A, E);\\n            int minRight = min(C, G);\\n            int maxBottom = max(B, F);\\n            int minTop = min(D, H);\\n            if(maxLeft >= minRight || maxBottom >= minTop){\\n                return total;\\n            }\\n            return total - (minRight - maxLeft) * (minTop - maxBottom);\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n            int area1 = (C - A) * (D - B);\\n            int area2 = (G - E) * (H - F);\\n            int total = area1 + area2;\\n            int maxLeft = max(A, E);\\n            int minRight = min(C, G);\\n            int maxBottom = max(B, F);\\n            int minTop = min(D, H);\\n            if(maxLeft >= minRight || maxBottom >= minTop){\\n                return total;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 62235,
                "title": "java-5-line-solution-easy-to-understand",
                "content": "    public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n    \\tint area1 = Math.abs((D-B)*(C-A));\\n    \\tint area2 = Math.abs((G-E)*(H-F));\\n    \\tint repeat_h = Math.max(B,F)>Math.min(D,H) ? 0 : Math.min(D,H)-Math.max(B, F);\\n    \\tint repeat_w = Math.max(A,E)>Math.min(C,G) ? 0 : Math.min(C,G)-Math.max(A, E);\\n\\t    return area1+area2-(repeat_h*repeat_w);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n    \\tint area1 = Math.abs((D-B)*(C-A));\\n    \\tint area2 = Math.abs((G-E)*(H-F));\\n    \\tint repeat_h = Math.max(B,F)>Math.min(D,H) ? 0 : Math.min(D,H)-Math.max(B, F);\\n    \\tint repeat_w = Math.max(A,E)>Math.min(C,G) ? 0 : Math.min(C,G)-Math.max(A, E);\\n\\t    return area1+area2-(repeat_h*repeat_w);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 62240,
                "title": "share-c-solution-area-1-area-2-overlap",
                "content": "    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n    \\n        // Area1: (A,B) - (C,D)  Area2: (E,F) - (G-H)\\n        int minX, minY, maxX, maxY;\\n    \\n        // Step 1: Find the overlap of the two area\\n        minX = A < E ? E : A;\\n        maxX = C < G ? C : G;\\n    \\n        minY = B < F ? F : B;\\n        maxY = D < H ? D : H;\\n    \\n        printf(\"[%d,%d]-[%d,%d]\", minX, minY, maxX, maxY);\\n    \\n        int overlap;\\n    \\n        if (minX >=maxX || minY >= maxY)\\n        {\\n            // No overlap\\n            overlap = 0;\\n        }\\n        else\\n        {\\n            // Overlap exists\\n            overlap = (maxX-minX)*(maxY-minY);\\n        }\\n        \\n        \\n        // Step 2: Area1 + Area2 - overlap = the toal Area\\n        return (C-A)*(D-B) + (G-E)*(H-F) - overlap;\\n    \\n    }",
                "solutionTags": [],
                "code": "    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n    \\n        // Area1: (A,B) - (C,D)  Area2: (E,F) - (G-H)\\n        int minX, minY, maxX, maxY;\\n    \\n        // Step 1: Find the overlap of the two area\\n        minX = A < E ? E : A;\\n        maxX = C < G ? C : G;\\n    \\n        minY = B < F ? F : B;\\n        maxY = D < H ? D : H;\\n    \\n        printf(\"[%d,%d]-[%d,%d]\", minX, minY, maxX, maxY);\\n    \\n        int overlap;\\n    \\n        if (minX >=maxX || minY >= maxY)\\n        {\\n            // No overlap\\n            overlap = 0;\\n        }\\n        else\\n        {\\n            // Overlap exists\\n            overlap = (maxX-minX)*(maxY-minY);\\n        }\\n        \\n        \\n        // Step 2: Area1 + Area2 - overlap = the toal Area\\n        return (C-A)*(D-B) + (G-E)*(H-F) - overlap;\\n    \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 62279,
                "title": "my-java-solution",
                "content": "    public class Solution {\\n        public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n            int result =  (C-A ) * (D-B) + (G-E) * (H-F);\\n            if ( overlap(A,C, E,G) > 0 && overlap(B,D,F,H) > 0)\\n                result -= overlap(A,C, E,G)* overlap(B,D,F,H) ;\\n                \\n            return result;\\n        }\\n        \\n        int overlap(int s1, int e1, int s2, int e2) {\\n            if (s2 > e1 || s1 > e2) return 0;\\n            return Math.min(e1,e2) - Math.max(s1,s2);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n            int result =  (C-A ) * (D-B) + (G-E) * (H-F);\\n            if ( overlap(A,C, E,G) > 0 && overlap(B,D,F,H) > 0)\\n                result -= overlap(A,C, E,G)* overlap(B,D,F,H) ;\\n                \\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 62293,
                "title": "my-1-line-python-solution",
                "content": "Thanks for Python's infinite integer:\\n\\n        return (C-A)*(D-B) + (G-E)*(H-F) - max(0,min(G,C)-max(A,E))*max(0,min(D,H)-max(B,F))",
                "solutionTags": [
                    "Python"
                ],
                "code": "Thanks for Python's infinite integer:\\n\\n        return (C-A)*(D-B) + (G-E)*(H-F) - max(0,min(G,C)-max(A,E))*max(0,min(D,H)-max(B,F))",
                "codeTag": "Unknown"
            },
            {
                "id": 62312,
                "title": "11-lines-java-solution",
                "content": "    public class Solution {\\n    \\t    public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n    \\t        int area = (C-A)*(D-B) + (G-E)*(H-F);\\n    \\t        long coverLen =(long)Math.min(C,G) -(long)Math.max(A,E);\\n    \\t        long coverHei =(long)Math.min(D,H) -(long)Math.max(B,F);\\n    \\t        if(coverLen <=0 || coverHei <= 0)\\n    \\t            return area;\\n    \\t        else\\n    \\t            return (int) (area-coverLen*coverHei);\\n    \\t    }\\n    \\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\t    public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n    \\t        int area = (C-A)*(D-B) + (G-E)*(H-F);\\n    \\t        long coverLen =(long)Math.min(C,G) -(long)Math.max(A,E);\\n    \\t        long coverHei =(long)Math.min(D,H) -(long)Math.max(B,F);\\n    \\t        if(coverLen <=0 || coverHei <= 0)\\n    \\t            return area;\\n    \\t        else\\n    \\t            return (int) (area-coverLen*coverHei);\\n    \\t    }",
                "codeTag": "Java"
            },
            {
                "id": 3227597,
                "title": "223-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. First, we compute the area of both rectangles using the formula area = width * height.\\n2. Then, we compute the width and height of the overlap region between the two rectangles. We use min to find the right-most edge of the overlap region, and max to find the left-most edge of the overlap region. We do the same thing for the top and bottom edges of the overlap region.\\n3. If the rectangles don\\'t overlap, overlapWidth or overlapHeight will be negative, so we use max to set them to 0 in order to get the correct overlap area.\\n4. Finally, we subtract the overlap area from the sum of the areas of the two rectangles to get the total area covered by the two rectangles.\\n\\n# Complexity\\n- Time complexity:\\n81.84%\\n\\n- Space complexity:\\n62.79%\\n\\n# Code\\n```\\nclass Solution:\\n    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:\\n        # Compute the area of the two rectangles\\n        area1 = (ax2 - ax1) * (ay2 - ay1)\\n        area2 = (bx2 - bx1) * (by2 - by1)\\n        \\n        # Compute the overlap area\\n        overlapWidth = min(ax2, bx2) - max(ax1, bx1)\\n        overlapHeight = min(ay2, by2) - max(ay1, by1)\\n        overlapArea = max(overlapWidth, 0) * max(overlapHeight, 0)\\n        \\n        # Compute the total area covered by the two rectangles\\n        totalArea = area1 + area2 - overlapArea\\n        \\n        return totalArea\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nclass Solution:\\n    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:\\n        # Compute the area of the two rectangles\\n        area1 = (ax2 - ax1) * (ay2 - ay1)\\n        area2 = (bx2 - bx1) * (by2 - by1)\\n        \\n        # Compute the overlap area\\n        overlapWidth = min(ax2, bx2) - max(ax1, bx1)\\n        overlapHeight = min(ay2, by2) - max(ay1, by1)\\n        overlapArea = max(overlapWidth, 0) * max(overlapHeight, 0)\\n        \\n        # Compute the total area covered by the two rectangles\\n        totalArea = area1 + area2 - overlapArea\\n        \\n        return totalArea\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3018601,
                "title": "my-simple-cpp-code-beats-98-86",
                "content": "# Intuition\\nFrom our basic knowledge of geometry we can compute the total areas occupied by rectangles , there are 2 cases :\\n1. when rectangles don\\'t intersect: we compute areas of both rectangles and add them.\\n\\nThe condition when rectangles don\\'t intersect can be observed geometrically,from the given figure:\\n\\nax2<=bx1 || ax1>=bx2 || by1>=ay2 || by2<=ay1.\\n\\n\\n2. when rectangles intersect:\\n   we need to add areas of both rectangles and substract the area   of common rectangle .\\n  To find the coordinates of common rectangle we can use max and min funtion on all of the 4 coordinates.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint computeArea (int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n    \\n     int rect1= (ax2-ax1) *(ay2-ay1); \\n     int rect2 = (bx2-bx1) *(by2-by1);\\n//to check if rectangles are not intersecting\\nif (ax2<=bx1 || ax1>=bx2 || by1>=ay2 || by2<=ay1){\\n\\nreturn rect1+rect2;\\n}\\n//to find coordinates of commom area rectangle\\nint max_common_x = max(ax1,bx1);\\n\\nint max_common_y = max(ay1, by1);\\n\\nint min_common_x = min(ax2, bx2);\\n\\nint min_common_y = min(ay2, by2);\\n\\n//sum of areas of both rectangles - area of common rectangle\\n\\nreturn rect1 + rect2 - (min_common_x-max_common_x) * (min_common_y-max_common_y);\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint computeArea (int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n    \\n     int rect1= (ax2-ax1) *(ay2-ay1); \\n     int rect2 = (bx2-bx1) *(by2-by1);\\n//to check if rectangles are not intersecting\\nif (ax2<=bx1 || ax1>=bx2 || by1>=ay2 || by2<=ay1){\\n\\nreturn rect1+rect2;\\n}\\n//to find coordinates of commom area rectangle\\nint max_common_x = max(ax1,bx1);\\n\\nint max_common_y = max(ay1, by1);\\n\\nint min_common_x = min(ax2, bx2);\\n\\nint min_common_y = min(ay2, by2);\\n\\n//sum of areas of both rectangles - area of common rectangle\\n\\nreturn rect1 + rect2 - (min_common_x-max_common_x) * (min_common_y-max_common_y);\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2823795,
                "title": "sum-of-rectangles-common-area-approach-in-a-clear-and-concise-way",
                "content": "Treat the given x and y coordinates as intervals vertically and horizontally and get their overlapping coordinates, then from the sum of area of 2 rectangles substract the overlapping area\\n\\nA Similar concept - [Determine if Two Events Have Conflict (Discuss)](https://leetcode.com/problems/determine-if-two-events-have-conflict/discuss/2734120/JavaC%2B%2BPython-Easy-1-liner-Solutions)\\n\\n\\n\\n```\\nclass Solution {\\n    public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        int tot=(by2-by1)*(bx2-bx1) + (ay2-ay1)*(ax2-ax1);\\n        \\n        int[] iY=findIntersection(new int[]{ay1,ay2},new int[]{by1,by2});\\n        int[] iX=findIntersection(new int[]{ax1,ax2},new int[]{bx1,bx2});\\n        \\n        int common;\\n        \\n        if(iX==null || iY==null){\\n            common=0;\\n        }else{\\n            common=(iY[1]-iY[0])*(iX[1]-iX[0]);\\n        }\\n        \\n        return tot-common;\\n    }\\n    \\n    private int[] findIntersection(int[] a,int[] b){\\n        if(a[0]>b[0]){\\n            return findIntersection(b,a);\\n        }\\n        \\n        if(a[1]<b[0]){\\n            return null;\\n        }\\n        \\n        return new int[]{Math.max(a[0],b[0]),Math.min(a[1],b[1])};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\n    public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        int tot=(by2-by1)*(bx2-bx1) + (ay2-ay1)*(ax2-ax1);\\n        \\n        int[] iY=findIntersection(new int[]{ay1,ay2},new int[]{by1,by2});\\n        int[] iX=findIntersection(new int[]{ax1,ax2},new int[]{bx1,bx2});\\n        \\n        int common;\\n        \\n        if(iX==null || iY==null){\\n            common=0;\\n        }else{\\n            common=(iY[1]-iY[0])*(iX[1]-iX[0]);\\n        }\\n        \\n        return tot-common;\\n    }\\n    \\n    private int[] findIntersection(int[] a,int[] b){\\n        if(a[0]>b[0]){\\n            return findIntersection(b,a);\\n        }\\n        \\n        if(a[1]<b[0]){\\n            return null;\\n        }\\n        \\n        return new int[]{Math.max(a[0],b[0]),Math.min(a[1],b[1])};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2823322,
                "title": "c-easy-to-understand-solution-o-1",
                "content": "int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n         int area1=abs((ax2-ax1)*(ay2-ay1));\\n         int area2=abs((bx2-bx1)*(by2-by1));\\n        \\n        int left=max(ax1,bx1);\\n        int right=min(ax2,bx2);\\n        int top=min(ay2,by2);\\n        int bottom=max(ay1,by1);\\n   \\n        int tArea=0;\\n        if(right>left && top>bottom){\\n            tArea=(right-left)*(top-bottom);\\n        }\\n        \\n        return area1+area2-tArea;\\n    }",
                "solutionTags": [],
                "code": "int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n         int area1=abs((ax2-ax1)*(ay2-ay1));\\n         int area2=abs((bx2-bx1)*(by2-by1));\\n        \\n        int left=max(ax1,bx1);\\n        int right=min(ax2,bx2);\\n        int top=min(ay2,by2);\\n        int bottom=max(ay1,by1);\\n   \\n        int tArea=0;\\n        if(right>left && top>bottom){\\n            tArea=(right-left)*(top-bottom);\\n        }\\n        \\n        return area1+area2-tArea;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2823067,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) \\n    {\\n        int area1 = (ax2 - ax1)*(ay2 - ay1);\\n        int area2 = (bx2 - bx1)*(by2-by1);\\n        \\n        int cx1 = max(ax1,bx1) , cy1 = max(ay1,by1);\\n        int cx2 = min(ax2,bx2) , cy2 = min(ay2, by2);\\n        \\n        int cl = (cx2 - cx1);\\n        int cb = (cy2 - cy1);\\n        int coverArea = 0;\\n        if(cl > 0 && cb > 0)\\n        {\\n            coverArea = cl * cb;\\n        }\\n        return area1 + area2 - coverArea;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) \\n    {\\n        int area1 = (ax2 - ax1)*(ay2 - ay1);\\n        int area2 = (bx2 - bx1)*(by2-by1);\\n        \\n        int cx1 = max(ax1,bx1) , cy1 = max(ay1,by1);\\n        int cx2 = min(ax2,bx2) , cy2 = min(ay2, by2);\\n        \\n        int cl = (cx2 - cx1);\\n        int cb = (cy2 - cy1);\\n        int coverArea = 0;\\n        if(cl > 0 && cb > 0)\\n        {\\n            coverArea = cl * cb;\\n        }\\n        return area1 + area2 - coverArea;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2820821,
                "title": "easy-java-solution-with-comments-step-by-step",
                "content": "# Intuition\\n**Think 1 dimensonal and then duplicate it for the scnd axis.**\\n1. calc line intersection \\n2. then calc field intersection\\n3. if you want to you can also do it for the third dimension\\n# Code\\n```\\nclass Solution {\\n    public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        // calculate the overlap only by the x axis\\n        int xOverlap = Math.max(ax1, bx1) - Math.min(ax2, bx2);\\n        if(Math.max(ax1, bx1) > Math.min(ax2, bx2)) xOverlap = 0;\\n\\n        // calculate the overlap only by the y axis      \\n        int yOverlap = Math.max(ay1, by1) - Math.min(ay2, by2);\\n        if(Math.max(ay1, by1) > Math.min(ay2, by2)) yOverlap = 0;\\n\\n        int overlapAr = xOverlap * yOverlap, // calculate the overlap area\\n            areaA = (ax2 - ax1) * (ay2 - ay1), \\n            areaB = (bx2 - bx1) * (by2 - by1);\\n\\n        return areaA + areaB - overlapAr; // substract the overlap area so we don\\'t count it twice\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        // calculate the overlap only by the x axis\\n        int xOverlap = Math.max(ax1, bx1) - Math.min(ax2, bx2);\\n        if(Math.max(ax1, bx1) > Math.min(ax2, bx2)) xOverlap = 0;\\n\\n        // calculate the overlap only by the y axis      \\n        int yOverlap = Math.max(ay1, by1) - Math.min(ay2, by2);\\n        if(Math.max(ay1, by1) > Math.min(ay2, by2)) yOverlap = 0;\\n\\n        int overlapAr = xOverlap * yOverlap, // calculate the overlap area\\n            areaA = (ax2 - ax1) * (ay2 - ay1), \\n            areaB = (bx2 - bx1) * (by2 - by1);\\n\\n        return areaA + areaB - overlapAr; // substract the overlap area so we don\\'t count it twice\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2533627,
                "title": "python-elegant-short-o-1-unpacking",
                "content": "```\\ndef computeArea(self, *coords) -> int:\\n\\tx1, y1, x2, y2, x3, y3, x4, y4 = coords\\n\\toverlap = max(min(x2, x4) - max(x1, x3), 0) * max(min(y2, y4) - max(y1, y3), 0)\\n\\treturn (x2 - x1) * (y2 - y1) + (x4 - x3) * (y4 - y3) - overlap\\n```\\n\\nIf you like this solution remember to **upvote it** to let me know.\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef computeArea(self, *coords) -> int:\\n\\tx1, y1, x2, y2, x3, y3, x4, y4 = coords\\n\\toverlap = max(min(x2, x4) - max(x1, x3), 0) * max(min(y2, y4) - max(y1, y3), 0)\\n\\treturn (x2 - x1) * (y2 - y1) + (x4 - x3) * (y4 - y3) - overlap\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1421328,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        int area1 = (ax2-ax1)*(ay2-ay1);\\n        int area2 = (bx2-bx1)*(by2-by1);\\n        \\n        int overlapingArea = max(min(ax2,bx2)-max(ax1,bx1),0)*max(min(ay2,by2)-max(ay1,by1),0);\\n        return area1+area2-overlapingArea;\\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        int area1 = (ax2-ax1)*(ay2-ay1);\\n        int area2 = (bx2-bx1)*(by2-by1);\\n        \\n        int overlapingArea = max(min(ax2,bx2)-max(ax1,bx1),0)*max(min(ay2,by2)-max(ay1,by1),0);\\n        return area1+area2-overlapingArea;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1352121,
                "title": "javascript-faster-than-98-25",
                "content": "```\\n/**\\n * @param {number} ax1\\n * @param {number} ay1\\n * @param {number} ax2\\n * @param {number} ay2\\n * @param {number} bx1\\n * @param {number} by1\\n * @param {number} bx2\\n * @param {number} by2\\n * @return {number}\\n */\\nvar computeArea = function (ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {\\n\\tconst aArea = (ax2 - ax1) * (ay2 - ay1);\\n\\tconst bArea = (bx2 - bx1) * (by2 - by1);\\n\\n\\tconst overlapY = Math.max(Math.min(ay2, by2) - Math.max(ay1, by1), 0);\\n\\n\\tconst overlapX = Math.max(Math.min(ax2, bx2) - Math.max(ax1, bx1), 0);\\n\\n\\tconst overlapArea = overlapX * overlapY;\\n\\n\\treturn aArea + bArea - overlapArea;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} ax1\\n * @param {number} ay1\\n * @param {number} ax2\\n * @param {number} ay2\\n * @param {number} bx1\\n * @param {number} by1\\n * @param {number} bx2\\n * @param {number} by2\\n * @return {number}\\n */\\nvar computeArea = function (ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {\\n\\tconst aArea = (ax2 - ax1) * (ay2 - ay1);\\n\\tconst bArea = (bx2 - bx1) * (by2 - by1);\\n\\n\\tconst overlapY = Math.max(Math.min(ay2, by2) - Math.max(ay1, by1), 0);\\n\\n\\tconst overlapX = Math.max(Math.min(ax2, bx2) - Math.max(ax1, bx1), 0);\\n\\n\\tconst overlapArea = overlapX * overlapY;\\n\\n\\treturn aArea + bArea - overlapArea;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 680110,
                "title": "c-easy-solution-4-ms-97-faster-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        long int area1= (abs(C - A) * abs (D -B));  // Find the area of rectangle A.\\n        long int area2 = (abs(G -E) * abs(H -F));  // Find the area of rectangle B.\\n        \\n\\t\\t\\n\\t\\t// Check the condition if both the rectangles overlap or not.\\n        if ((B >= H) || (C <= E) || (A >= G) || (F >= D)){\\n\\t\\t\\t//If two rectangles do not overlap, return the sum of the individual areas.\\n            return area1 + area2;\\n        } else {\\n\\t\\t\\t// Else return area of rectangle A + area of rectangle B - overlap.\\n            return area1 + area2 - (min(C, G)-max(A,E)) * (min(H, D) - max(B, F)); \\n        }      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        long int area1= (abs(C - A) * abs (D -B));  // Find the area of rectangle A.\\n        long int area2 = (abs(G -E) * abs(H -F));  // Find the area of rectangle B.\\n        \\n\\t\\t\\n\\t\\t// Check the condition if both the rectangles overlap or not.\\n        if ((B >= H) || (C <= E) || (A >= G) || (F >= D)){\\n\\t\\t\\t//If two rectangles do not overlap, return the sum of the individual areas.\\n            return area1 + area2;\\n        } else {\\n\\t\\t\\t// Else return area of rectangle A + area of rectangle B - overlap.\\n            return area1 + area2 - (min(C, G)-max(A,E)) * (min(H, D) - max(B, F)); \\n        }      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 352933,
                "title": "easy-peasy-python-solution",
                "content": "\\tdef computeArea(self, A: int, B: int, C: int, D: int, E: int, F: int, G: int, H: int) -> int:\\n        area1 = (D-B)*(C-A)\\n        area2 = (H-F)*(G-E)\\n        if not self.overlap(A, B, C, D, E, F, G, H):\\n            return area1 + area2\\n        else:\\n            x = min(C-A, G-E, C-E, G-A)\\n            y = min(D-B, H-F, D-F, H-B)\\n            return area1 + area2 - x*y\\n            \\n    def overlap(self, A, B, C, D, E, F, G, H):\\n        return not (C <= E or G <= A or H <= B or D <= F)",
                "solutionTags": [],
                "code": "\\tdef computeArea(self, A: int, B: int, C: int, D: int, E: int, F: int, G: int, H: int) -> int:\\n        area1 = (D-B)*(C-A)\\n        area2 = (H-F)*(G-E)\\n        if not self.overlap(A, B, C, D, E, F, G, H):\\n            return area1 + area2\\n        else:\\n            x = min(C-A, G-E, C-E, G-A)\\n            y = min(D-B, H-F, D-F, H-B)\\n            return area1 + area2 - x*y\\n            \\n    def overlap(self, A, B, C, D, E, F, G, H):\\n        return not (C <= E or G <= A or H <= B or D <= F)",
                "codeTag": "Python3"
            },
            {
                "id": 62197,
                "title": "beats-94-56-28ms-3-lines-c-solution",
                "content": "\\n    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        int s = (C-A) * (D-B) + (G-E) * (H-F); // areas of the two rectangle\\n        if(E>=C || F>=D || G<=A || H<=B)    return s; // no overlap\\n        return s - (min(C,G) - max(A,E)) * (min(D,H) - max(B,F)); //areas of the two rectangle - overlap\\n    }",
                "solutionTags": [],
                "code": "\\n    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        int s = (C-A) * (D-B) + (G-E) * (H-F); // areas of the two rectangle\\n        if(E>=C || F>=D || G<=A || H<=B)    return s; // no overlap\\n        return s - (min(C,G) - max(A,E)) * (min(D,H) - max(B,F)); //areas of the two rectangle - overlap\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 62223,
                "title": "java-5-line-concise-solution-with-comments",
                "content": "Add up the areas of two rectangles and then subtract the overlap area from it.\\n\\n    public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        int result = (C - A) * (D - B) + (G - E) * (H - F); //Sum of areas of two rectangles\\n        if(C <= E || G <= A || H <= B || D <= F) return result; //If no overlap at all.\\n        int dx = Math.min(C, G) - Math.max(A, E); //Overlap length along x\\n        int dy = Math.min(D, H) - Math.max(B, F); //Overlap length along y\\n        return result - dx * dy;\\n    }",
                "solutionTags": [],
                "code": "Add up the areas of two rectangles and then subtract the overlap area from it.\\n\\n    public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        int result = (C - A) * (D - B) + (G - E) * (H - F); //Sum of areas of two rectangles\\n        if(C <= E || G <= A || H <= B || D <= F) return result; //If no overlap at all.\\n        int dx = Math.min(C, G) - Math.max(A, E); //Overlap length along x\\n        int dy = Math.min(D, H) - Math.max(B, F); //Overlap length along y\\n        return result - dx * dy;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 62249,
                "title": "c-concise-solution",
                "content": "        \\n    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        int overlap = (min(C,G)-max(A,E))*(min(D,H)-max(B,F));\\n        if ( min(C,G)<=max(A,E) || min(D,H)<=max(B,F) )\\n            overlap = 0;\\n        return (C-A)*(D-B)+(G-E)*(H-F)-overlap;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "        \\n    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        int overlap = (min(C,G)-max(A,E))*(min(D,H)-max(B,F));\\n        if ( min(C,G)<=max(A,E) || min(D,H)<=max(B,F) )\\n            overlap = 0;\\n        return (C-A)*(D-B)+(G-E)*(H-F)-overlap;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 62250,
                "title": "my-clean-c-implementation-based-on-min-max-no-branches",
                "content": "    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H)\\n    {\\n        int64_t xmin1 = min( A, C );\\n        int64_t xmax1 = max( A, C );\\n        \\n        int64_t ymin1 = min( B, D );\\n        int64_t ymax1 = max( B, D );\\n        \\n        int64_t xmin2 = min( E, G );\\n        int64_t xmax2 = max( E, G );\\n        \\n        int64_t ymin2 = min( F, H );\\n        int64_t ymax2 = max( F, H );\\n        \\n        int64_t xa = min( xmax1, xmax2 ) - max( xmin1, xmin2 );\\n        int64_t ya = min( ymax1, ymax2 ) - max( ymin1, ymin2 );\\n        \\n        int64_t z = 0, ca = max( xa, z ) * max( ya, z );\\n        \\n        int64_t a1 = (xmax1 - xmin1) * (ymax1 - ymin1);\\n        int64_t a2 = (xmax2 - xmin2) * (ymax2 - ymin2);\\n        \\n        return a1 + a2 - ca;\\n    }",
                "solutionTags": [],
                "code": "    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H)\\n    {\\n        int64_t xmin1 = min( A, C );\\n        int64_t xmax1 = max( A, C );\\n        \\n        int64_t ymin1 = min( B, D );\\n        int64_t ymax1 = max( B, D );\\n        \\n        int64_t xmin2 = min( E, G );\\n        int64_t xmax2 = max( E, G );\\n        \\n        int64_t ymin2 = min( F, H );\\n        int64_t ymax2 = max( F, H );\\n        \\n        int64_t xa = min( xmax1, xmax2 ) - max( xmin1, xmin2 );\\n        int64_t ya = min( ymax1, ymax2 ) - max( ymin1, ymin2 );\\n        \\n        int64_t z = 0, ca = max( xa, z ) * max( ya, z );\\n        \\n        int64_t a1 = (xmax1 - xmin1) * (ymax1 - ymin1);\\n        int64_t a2 = (xmax2 - xmin2) * (ymax2 - ymin2);\\n        \\n        return a1 + a2 - ca;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 62271,
                "title": "easy-to-understand-ac-java-solution",
                "content": "    public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        if (A >= G || E >= C || B >= H || F >= D) return (C - A) * (D - B) + (G - E) * (H - F);\\n        int x1 = Math.max(A, E);\\n        int y1 = Math.max(B, F);\\n        int x2 = Math.min(C, G);\\n        int y2 = Math.min(D, H);\\n        return (C - A) * (D - B) + (G - E) * (H - F) - (x2 - x1) * (y2 -y1);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        if (A >= G || E >= C || B >= H || F >= D) return (C - A) * (D - B) + (G - E) * (H - F);\\n        int x1 = Math.max(A, E);\\n        int y1 = Math.max(B, F);\\n        int x2 = Math.min(C, G);\\n        int y2 = Math.min(D, H);\\n        return (C - A) * (D - B) + (G - E) * (H - F) - (x2 - x1) * (y2 -y1);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 62281,
                "title": "my-1-line-c-solution",
                "content": "    class Solution {\\n    public:\\n        int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n            return (C>E && G>A && H>B && D>F) ? (C-A)*(D-B)+(G-E)*(H-F)-(min(C,G)-max(A,E))*(min(D,H)-max(B,F)) : (C-A)*(D-B)+(G-E)*(H-F);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n            return (C>E && G>A && H>B && D>F) ? (C-A)*(D-B)+(G-E)*(H-F)-(min(C,G)-max(A,E))*(min(D,H)-max(B,F)) : (C-A)*(D-B)+(G-E)*(H-F);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 62308,
                "title": "transparent-c-solution-runtime-32-ms",
                "content": "    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        int S1 = (C-A)*(D-B);\\n        int S2 = (G-E)*(H-F);\\n        if(C < E || G < A || H < B || D < F)\\n        {\\n            return S1 + S2; // no intersection\\n        }\\n        int xi_left = max(A, E);\\n        int yi_left = max(B, F);\\n        int xi_right = min(C, G);\\n        int yi_right = min(D, H);\\n        \\n        return S1 + S2 - (xi_right - xi_left)*(yi_right - yi_left);\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        int S1 = (C-A)*(D-B);\\n        int S2 = (G-E)*(H-F);\\n        if(C < E || G < A || H < B || D < F)\\n        {\\n            return S1 + S2; // no intersection\\n        }\\n        int xi_left = max(A, E);\\n        int yi_left = max(B, F);\\n        int xi_right = min(C, G);\\n        int yi_right = min(D, H);\\n        \\n        return S1 + S2 - (xi_right - xi_left)*(yi_right - yi_left);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3359046,
                "title": "beats-99-time-98-space-python3-readable-and-easy-to-understand-full-commented-code",
                "content": "# Approach\\nTo find the intersection points of two rectangles, we first need to determine the maximum and minimum values of their edge lines. Once we have identified these values, we can check whether the rectangles are truly intersecting or not. If they are, we can calculate the new intersecting rectangles using basic mathematical principles. The combined area of the two rectangles can then be determined by adding their individual areas and subtracting the area of the intersecting region. On the other hand, if the rectangles are not intersecting, we simply add their areas together to determine their combined area. This approach allows for a clear and logical method for determining the area of overlapping rectangles.\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:\\n        # find intersecting point first\\n        # find the min_left_value of the intersecting rectangle\\n        min_left_value = max(ax1, bx1)\\n        # find the min_right_value of the intersecting rectangle\\n        min_right_value = min(ax2, bx2)\\n        # find the min_top_value of the intersecting rectangle\\n        min_top_value = min(ay2, by2)\\n        # find the min_bottom_value of the intersecting rectangle\\n        min_bottom_value = max(ay1, by1)\\n        # calculate the total area of the first rectangle\\n        first_rect_area = (ax2 - ax1) * (ay2 - ay1)\\n        # calculate the total area of the second rectangle\\n        second_rect_area = (bx2 - bx1) * (by2 - by1)\\n        # check there is an intersecting rectangle or not if not return the sum of the first_rect_area and second_rect_area\\n        if (min_right_value - min_left_value) < 0 or (min_top_value- min_bottom_value) < 0:\\n            return first_rect_area + second_rect_area\\n        # else if there is an intersecting rectangle\\n        # calculate the total area of the intersecting rectangle\\n        intersecting_total_area = (min_right_value - min_left_value) * (min_top_value- min_bottom_value)\\n        # return the sum of the first_rect_area, second_rect_area then subtract the intersecting_total_area\\n        return first_rect_area + second_rect_area - intersecting_total_area\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:\\n        # find intersecting point first\\n        # find the min_left_value of the intersecting rectangle\\n        min_left_value = max(ax1, bx1)\\n        # find the min_right_value of the intersecting rectangle\\n        min_right_value = min(ax2, bx2)\\n        # find the min_top_value of the intersecting rectangle\\n        min_top_value = min(ay2, by2)\\n        # find the min_bottom_value of the intersecting rectangle\\n        min_bottom_value = max(ay1, by1)\\n        # calculate the total area of the first rectangle\\n        first_rect_area = (ax2 - ax1) * (ay2 - ay1)\\n        # calculate the total area of the second rectangle\\n        second_rect_area = (bx2 - bx1) * (by2 - by1)\\n        # check there is an intersecting rectangle or not if not return the sum of the first_rect_area and second_rect_area\\n        if (min_right_value - min_left_value) < 0 or (min_top_value- min_bottom_value) < 0:\\n            return first_rect_area + second_rect_area\\n        # else if there is an intersecting rectangle\\n        # calculate the total area of the intersecting rectangle\\n        intersecting_total_area = (min_right_value - min_left_value) * (min_top_value- min_bottom_value)\\n        # return the sum of the first_rect_area, second_rect_area then subtract the intersecting_total_area\\n        return first_rect_area + second_rect_area - intersecting_total_area\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2824781,
                "title": "c-solution-not-so-organised",
                "content": "in this question we just have to calculate the areas of both rectangles separately and subtract the overlapping area once.\\n\\n```\\nclass Solution {\\npublic:\\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        int r1=(ax2-ax1)*(ay2-ay1) + (bx2-bx1)*(by2-by1);\\n        if(bx1>=ax1 && bx1<=ax2 && by1>=ay1 && by1<=ay2 || bx2>=ax1 && bx2<=ax2 && by2>=ay1 && by2<=ay2 || ax1>=bx1 && ax1<=bx2 && ay1>=by1 && ay1<=by2 || ax2>=bx1 && ax2<=bx2 && ay2>=by1 && ay2<=by2 || bx1>=ax1 && bx1<=ax2 && by2>=ay1 && by2<=ay2 || bx2>=ax1 && bx2<=ax2 && by1>=ay1 && by1<=ay2 || ax2>=bx1 && ax2<=bx2 && ay1>=by1 && ay1<=by2 || ax1>=bx1 && ax1<=bx2 && ay2>=by1 && ay2<=by2){ \\n            r1-=(min(ax2,bx2)-max(ax1,bx1))*(min(ay2,by2)-max(ay1,by1));\\n        }else if(bx1>=ax1 && bx2>=ax1 && bx1<=ax2 && bx2<=ax2 && by1<=ay1 && by2>=ay2 || ax1>=bx1 && ax2>=bx1 && ax1<=bx2 && ax2<=bx2 && ay1<=by1 && ay2>=by2){\\n            r1-=(min(ax2-ax1,bx2-bx1))*(min(ay2-ay1,by2-by1));\\n        }\\n        return r1;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        int r1=(ax2-ax1)*(ay2-ay1) + (bx2-bx1)*(by2-by1);\\n        if(bx1>=ax1 && bx1<=ax2 && by1>=ay1 && by1<=ay2 || bx2>=ax1 && bx2<=ax2 && by2>=ay1 && by2<=ay2 || ax1>=bx1 && ax1<=bx2 && ay1>=by1 && ay1<=by2 || ax2>=bx1 && ax2<=bx2 && ay2>=by1 && ay2<=by2 || bx1>=ax1 && bx1<=ax2 && by2>=ay1 && by2<=ay2 || bx2>=ax1 && bx2<=ax2 && by1>=ay1 && by1<=ay2 || ax2>=bx1 && ax2<=bx2 && ay1>=by1 && ay1<=by2 || ax1>=bx1 && ax1<=bx2 && ay2>=by1 && ay2<=by2){ \\n            r1-=(min(ax2,bx2)-max(ax1,bx1))*(min(ay2,by2)-max(ay1,by1));\\n        }else if(bx1>=ax1 && bx2>=ax1 && bx1<=ax2 && bx2<=ax2 && by1<=ay1 && by2>=ay2 || ax1>=bx1 && ax2>=bx1 && ax1<=bx2 && ax2<=bx2 && ay1<=by1 && ay2>=by2){\\n            r1-=(min(ax2-ax1,bx2-bx1))*(min(ay2-ay1,by2-by1));\\n        }\\n        return r1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2824767,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public boolean overlaps(int A, int B, int C, int D, int E, int F, int G, int H){\\n        if(!(B>H || D<F  || A>G || C<E  )){\\n            return true;\\n        }\\n        return false;\\n    }\\n    public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        int rect1=(D-B)*(C-A);\\n        int rect2 =(G-E)*(H-F);\\n        int overlap=0;\\n        if(overlaps(A,B,C,D,E,F,G,H)){\\n                int overlapY1=Math.max(F,B);\\n                int overlapX1=Math.max(E,A);\\n                int overlapY2=Math.min(H,D);\\n                int overlapX2=Math.min(G,C);\\n                overlap=(overlapX2-overlapX1)*(overlapY2-overlapY1);\\n        }\\n        return rect1+rect2-overlap;\\n       \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean overlaps(int A, int B, int C, int D, int E, int F, int G, int H){\\n        if(!(B>H || D<F  || A>G || C<E  )){\\n            return true;\\n        }\\n        return false;\\n    }\\n    public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        int rect1=(D-B)*(C-A);\\n        int rect2 =(G-E)*(H-F);\\n        int overlap=0;\\n        if(overlaps(A,B,C,D,E,F,G,H)){\\n                int overlapY1=Math.max(F,B);\\n                int overlapX1=Math.max(E,A);\\n                int overlapY2=Math.min(H,D);\\n                int overlapX2=Math.min(G,C);\\n                overlap=(overlapX2-overlapX1)*(overlapY2-overlapY1);\\n        }\\n        return rect1+rect2-overlap;\\n       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2824519,
                "title": "java-math-beat-100",
                "content": "```\\nclass Solution {\\n    public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        int horizontal = Math.max(0, Math.min(ax2,bx2) - Math.max(ax1,bx1));\\n        int vertical = Math.max(0, Math.min(ay2,by2) - Math.max(ay1,by1));\\n        return (ax2-ax1)*(ay2-ay1) + (bx2-bx1)*(by2-by1) - horizontal* vertical;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        int horizontal = Math.max(0, Math.min(ax2,bx2) - Math.max(ax1,bx1));\\n        int vertical = Math.max(0, Math.min(ay2,by2) - Math.max(ay1,by1));\\n        return (ax2-ax1)*(ay2-ay1) + (bx2-bx1)*(by2-by1) - horizontal* vertical;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2824024,
                "title": "java-simple-and-clear-explanation-with-comments",
                "content": "**Intution**\\n* If the rectangles don\\'t overlap return the sum of the area of the both rectangles.\\n* If they overlap remove the extra area from the total area.\\n\\n**There are three parts to solve this.**\\n\\n**Working**\\n\\n* **1st part** - First find the total area.\\n\\t* awidth = absolute difference between (ay1  and ay2).\\n\\t* alength = absolute difference between (ax1 and ax2).\\n\\t* bwidth = absolute difference between (by1  and by2).\\n\\t* blength = absolute difference between (bx1 and bx2).\\n\\t* TotalArea = (awidth * alength) + (bwidth * blength).\\n* Now find if the two rectangles overlap or not.\\n\\n* **2nd part** - When they don\\'t overlap.\\n\\t* **Don\\'t move the first rectangle(a) and move the second rectangle(b)** around the first without merging the rectangles.\\n\\t* You will find the conditions like this :-\\n\\t\\t* When the second rectnagle on **top then ay2 <= by1**.\\n\\t\\t* When the second rectangle on **right then ax2 <= bx1**.\\n\\t\\t* When the second rectangle on **down then by2 <= ay1**.\\n\\t\\t* When the second rectangle on **left then bx2 <= ax1**.\\n\\t* If any of the above condition staisfies that means they don\\'t overlap.\\n\\t* Now return the TotalArea.\\n\\t\\n* **3rd part** - When they overlap.\\n\\t* We have to find the extra area now.\\n\\t* Now when the two rectangles merge it will create a small rectangle(extra) inside it.\\n\\t* Let the points of the extra rectangle be ex1, ex2, ey1, ey2.\\n\\t* Start with ex1, when the rectangles merge then the **max of ax1 and bx1 will be the ex1**.\\n\\t\\t* From ax1 and bx1 whichever is right in graph will be our ex1 i.e max of ax1 and bx1.\\n\\t* ex2, **min of ax2 and bx2 will be the ex2**.\\n\\t\\t* From ax2 and bx2 whichever is left in graph will be our ex2 i.e min of ax2 and bx2.\\n\\t* ey1, **max of ay1 and by1 will be the ey1**.\\n\\t\\t* From ay1 and by1 whichever is top in graph will be our ey1 i.e max of ay1 and by1.\\n\\t* ey2, **min of ay2 and by2 will be the ey2**.\\n\\t\\t* From ay2 and by2 whichever is down in graph will be our ey2 i.e min of ay2 and by2.\\n\\t* Now calculate the area of extra rectangle with the help of ex1, ex2, ey1, and ey2.\\n\\t* Return TotalArea - extraArea\\n\\n**TIme and Space complexity is constant**\\n\\nCode:- \\n\\n```\\npublic int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        \\n\\t\\t// 1st Part \\n\\t\\t// Calculate the total area.\\n        int alength = Math.abs(ax1 - ax2);\\n        int awidth = Math.abs(ay1 - ay2);\\n\\n        int blength = Math.abs(bx1 - bx2);\\n        int bwidth = Math.abs(by1 - by2);\\n        \\n        int total = (awidth * alength) + (bwidth * blength);\\n        \\n\\t\\t// 2nd Part \\n\\t\\t// Check all the boundary condition when they don\\'t overlap if any condition is true return the totalArea.\\n        if(by2 <= ay1 || ay2 <= by1 || bx2 <= ax1 || ax2 <= bx1){   \\n            \\n            return total;\\n        } \\n        \\n\\t\\t// 3rd Part\\n\\t\\t// When they overlap find the extra rectangle coordinates ex1, ex2, ey1 and ey2.\\n        int ex1 = Math.max(ax1, bx1);\\n        int ex2 = Math.min(ax2, bx2);\\n        \\n        int ey1 = Math.max(ay1, by1);\\n        int ey2 = Math.min(ay2, by2);\\n        \\n\\t\\t// Calculate width and length of extra rectangle.\\n        int ewidth = Math.abs(ex1 - ex2);\\n        int elength = Math.abs(ey1 - ey2);\\n        \\n\\t\\t// Calculate the area of extra rectangle\\n        int extra = ewidth * elength;\\n        \\n\\t\\t// Remove the extra area from totalArea and return it.\\n        return total - extra;\\n        \\n    }\\n```\\n\\nPlease UpVote !!!",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\npublic int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        \\n\\t\\t// 1st Part \\n\\t\\t// Calculate the total area.\\n        int alength = Math.abs(ax1 - ax2);\\n        int awidth = Math.abs(ay1 - ay2);\\n\\n        int blength = Math.abs(bx1 - bx2);\\n        int bwidth = Math.abs(by1 - by2);\\n        \\n        int total = (awidth * alength) + (bwidth * blength);\\n        \\n\\t\\t// 2nd Part \\n\\t\\t// Check all the boundary condition when they don\\'t overlap if any condition is true return the totalArea.\\n        if(by2 <= ay1 || ay2 <= by1 || bx2 <= ax1 || ax2 <= bx1){   \\n            \\n            return total;\\n        } \\n        \\n\\t\\t// 3rd Part\\n\\t\\t// When they overlap find the extra rectangle coordinates ex1, ex2, ey1 and ey2.\\n        int ex1 = Math.max(ax1, bx1);\\n        int ex2 = Math.min(ax2, bx2);\\n        \\n        int ey1 = Math.max(ay1, by1);\\n        int ey2 = Math.min(ay2, by2);\\n        \\n\\t\\t// Calculate width and length of extra rectangle.\\n        int ewidth = Math.abs(ex1 - ex2);\\n        int elength = Math.abs(ey1 - ey2);\\n        \\n\\t\\t// Calculate the area of extra rectangle\\n        int extra = ewidth * elength;\\n        \\n\\t\\t// Remove the extra area from totalArea and return it.\\n        return total - extra;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2823961,
                "title": "3-line-java-code-beats-92-space-and-100-time",
                "content": "# Intuition\\nIntuition is to apply the set theory basics. Find individual areas and eliminate the intersection.\\n\\n# Approach\\nFor finding individual areas, approach is a piece of cake.\\n\\nArea of rectangle 1 : (ax2-ax1)*(ay2-ay1)\\nArea of rectangle 2 : (bx2-bx1)*(by2-by1)\\n\\n\\nMain part comes where we have to find the intersection area just by the given coordinates. There are mainly 2 cases:\\n\\n1) There is common area\\n2) There is no common area\\n\\n### Case 1: There is common area\\nIn this case we will find the range of x-coordinate and that of the y-coordinate that falls common between the figures. There are 4 sub-cases for x-coordinate:\\n\\na) rectangle 1 lies ahead of rectangle 2\\nb) rectangle 2 lies ahead of rectangle 1\\nc) rectangle 1 is contained in rectangle 2\\nd) rctangle 2 is contained in rectangle 1\\n\\nSimilarly, there are 4 sub-cases for y-coordinate. In total 4x4 = 16 total cases.\\n\\nThe solution is never to solve individually each of the 16 cases, but to solve 4 sub-cases for x and 4 sub-cases for y individually, i.e. solve problems of x-axis and y-axis individually like we used to do in high school level 2D physics.\\n\\n\\nTherefore, the solution can be done by:\\n\\n1) For range of x: Math.min(bx2,ax2)-Math.max(bx1,ax1)\\n2) For range of y: Math.min(by2,ay2)-Math.max(by1,ay1)\\n\\n\\n### Case 2: There is no common area\\n\\nThis can be found by checking the same range of x and range of y, if any one of them is less than 0 after calculating as per the formula in c=above case, then the intersection area is 0.\\n\\n\\n\\nNow, Combine both of the above cases as done in the code below in a single return statement.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n\\n# Result\\n\\n![image.png](https://assets.leetcode.com/users/images/7837385c-87f9-4132-b7e0-a26c14db34e7_1668689603.5964744.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        int x_range = Math.min(bx2,ax2)-Math.max(bx1,ax1);\\n        int y_range = (Math.min(by2,ay2)-Math.max(by1,ay1));        \\n        return (ax2-ax1)*(ay2-ay1)+(bx2-bx1)*(by2-by1)-((x_range<0||y_range<0)?0:x_range*y_range);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        int x_range = Math.min(bx2,ax2)-Math.max(bx1,ax1);\\n        int y_range = (Math.min(by2,ay2)-Math.max(by1,ay1));        \\n        return (ax2-ax1)*(ay2-ay1)+(bx2-bx1)*(by2-by1)-((x_range<0||y_range<0)?0:x_range*y_range);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2822829,
                "title": "o-1-space-and-time-complexity",
                "content": "# Intuition\\nCalculate the area of both Reactangles and substract the overlap part if overlap found.\\n\\n\\n# Complexity\\n- Time complexity:\\n constant TC O(1)\\n\\n- Space complexity:\\nConstant ST O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        int Minx=min({ax1,ax2,bx1,bx2}) ,Miny=min({ay1,ay2,by1,by2});\\n        \\n        // change all the coordinates in positive X,Y axis; \\n        Minx=abs(Minx); Miny=abs(Miny);\\n        ax1+=Minx; ax2+=Minx; bx1+=Minx; bx2+=Minx;\\n        ay1+=Miny; ay2+=Miny; by1+=Miny; by2+=Miny;\\n        \\n        // find the area occupied by both rectangles\\n        long ans= (long)abs(ax2-ax1)*(abs(ay2-ay1)) +\\n                  (long)abs(bx2-bx1)*(abs(by2-by1));\\n        \\n        // calculate the (x1,y1) , (x2,y2) part of overlap rectangle\\n        int x1 = max(ax1,bx1),x2=min(ax2,bx2);\\n        int y1=max(ay1,by1),y2=min(ay2,by2);\\n        \\n        // if no overlap found\\n        if((x2-x1)<=0 || (y2-y1)<=0) return ans;\\n        \\n         // substract the overlap rectangle\\n        return ans-(x2-x1)*(y2-y1);    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        int Minx=min({ax1,ax2,bx1,bx2}) ,Miny=min({ay1,ay2,by1,by2});\\n        \\n        // change all the coordinates in positive X,Y axis; \\n        Minx=abs(Minx); Miny=abs(Miny);\\n        ax1+=Minx; ax2+=Minx; bx1+=Minx; bx2+=Minx;\\n        ay1+=Miny; ay2+=Miny; by1+=Miny; by2+=Miny;\\n        \\n        // find the area occupied by both rectangles\\n        long ans= (long)abs(ax2-ax1)*(abs(ay2-ay1)) +\\n                  (long)abs(bx2-bx1)*(abs(by2-by1));\\n        \\n        // calculate the (x1,y1) , (x2,y2) part of overlap rectangle\\n        int x1 = max(ax1,bx1),x2=min(ax2,bx2);\\n        int y1=max(ay1,by1),y2=min(ay2,by2);\\n        \\n        // if no overlap found\\n        if((x2-x1)<=0 || (y2-y1)<=0) return ans;\\n        \\n         // substract the overlap rectangle\\n        return ans-(x2-x1)*(y2-y1);    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2822660,
                "title": "python-professional-solution-fastest-99-faster",
                "content": "**\\uD83D\\uDD3C IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n```\\nclass Solution:\\n    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:\\n        \\n        # Function to caculate area of rectangle (Length * width)\\n        def area(x1,y1,x2,y2):\\n            return (x2-x1)*(y2-y1)\\n        \\n        # Finding the overlap rectangle length and width\\n        overlapX = max(min(ax2,bx2)-max(ax1,bx1), 0)\\n        overlapY = max(min(ay2,by2)-max(ay1,by1), 0)\\n        \\n        # Area1 + Area2 - Overlap Rectangle Area\\n        return area(ax1,ay1,ax2,ay2) + area(bx1,by1,bx2,by2) - overlapX * overlapY\\n```\\n\\n**For Leetcode Solution with Explanation Visit this Blog:\\nhttps://www.python-techs.com/\\n(Please open this link in new tab)**\\n\\nThank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:\\n        \\n        # Function to caculate area of rectangle (Length * width)\\n        def area(x1,y1,x2,y2):\\n            return (x2-x1)*(y2-y1)\\n        \\n        # Finding the overlap rectangle length and width\\n        overlapX = max(min(ax2,bx2)-max(ax1,bx1), 0)\\n        overlapY = max(min(ay2,by2)-max(ay1,by1), 0)\\n        \\n        # Area1 + Area2 - Overlap Rectangle Area\\n        return area(ax1,ay1,ax2,ay2) + area(bx1,by1,bx2,by2) - overlapX * overlapY\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2822478,
                "title": "javascript-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number} ax1\\n * @param {number} ay1\\n * @param {number} ax2\\n * @param {number} ay2\\n * @param {number} bx1\\n * @param {number} by1\\n * @param {number} bx2\\n * @param {number} by2\\n * @return {number}\\n */\\nvar computeArea = function(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {\\n    const maxStart1 = Math.max(ax1, bx1);\\n    const minEnd1 = Math.min(ax2, bx2);\\n   \\n    const width = Math.abs(maxStart1 - minEnd1);\\n    \\n    const minStart2 = Math.min(ay2, by2);\\n    const maxEnd2 = Math.max(ay1, by1);\\n    \\n    const height = Math.abs(minStart2 - maxEnd2);\\n    \\n    let overLapArea = 0;\\n    \\n    if (maxStart1 <= minEnd1 && maxEnd2 <= minStart2) {\\n        overLapArea = width * height;\\n    }\\n    const rectArea1 = calculateArea(ax1, ay1, ax2, ay2);\\n    const rectArea2 = calculateArea(bx1, by1, bx2, by2);\\n    \\n    return rectArea1 + rectArea2 - overLapArea;\\n} \\n\\nfunction calculateArea(x1, y1, x2, y2) {\\n    const width = Math.abs(x1 - x2);\\n    const height = Math.abs(y1 - y2);\\n    return width * height;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} ax1\\n * @param {number} ay1\\n * @param {number} ax2\\n * @param {number} ay2\\n * @param {number} bx1\\n * @param {number} by1\\n * @param {number} bx2\\n * @param {number} by2\\n * @return {number}\\n */\\nvar computeArea = function(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {\\n    const maxStart1 = Math.max(ax1, bx1);\\n    const minEnd1 = Math.min(ax2, bx2);\\n   \\n    const width = Math.abs(maxStart1 - minEnd1);\\n    \\n    const minStart2 = Math.min(ay2, by2);\\n    const maxEnd2 = Math.max(ay1, by1);\\n    \\n    const height = Math.abs(minStart2 - maxEnd2);\\n    \\n    let overLapArea = 0;\\n    \\n    if (maxStart1 <= minEnd1 && maxEnd2 <= minStart2) {\\n        overLapArea = width * height;\\n    }\\n    const rectArea1 = calculateArea(ax1, ay1, ax2, ay2);\\n    const rectArea2 = calculateArea(bx1, by1, bx2, by2);\\n    \\n    return rectArea1 + rectArea2 - overLapArea;\\n} \\n\\nfunction calculateArea(x1, y1, x2, y2) {\\n    const width = Math.abs(x1 - x2);\\n    const height = Math.abs(y1 - y2);\\n    return width * height;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2772499,
                "title": "c-easy-intuitive-solution-concise",
                "content": "```\\nclass Solution {\\npublic:\\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        \\n        int xOverlap = min(ax2, bx2) - max(ax1, bx1);\\n        int yOverlap = min(ay2, by2) - max(ay1, by1);\\n        \\n        int aArea = (ax2 - ax1) * (ay2 - ay1);\\n        int bArea = (bx2 - bx1) * (by2 - by1);\\n        int overlapArea = 0;\\n        if(xOverlap > 0 and yOverlap > 0)\\n            overlapArea = xOverlap * yOverlap;\\n        \\n        return (aArea + bArea - overlapArea);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        \\n        int xOverlap = min(ax2, bx2) - max(ax1, bx1);\\n        int yOverlap = min(ay2, by2) - max(ay1, by1);\\n        \\n        int aArea = (ax2 - ax1) * (ay2 - ay1);\\n        int bArea = (bx2 - bx1) * (by2 - by1);\\n        int overlapArea = 0;\\n        if(xOverlap > 0 and yOverlap > 0)\\n            overlapArea = xOverlap * yOverlap;\\n        \\n        return (aArea + bArea - overlapArea);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2699717,
                "title": "java-c-stupid-approach-5ms",
                "content": "# Code\\n## Method A\\n``` java []\\nclass Solution {\\n    public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        int A1 = (ax2 - ax1) * (ay2 - ay1);\\n        int A2 = (bx2 - bx1) * (by2 - by1);\\n        int overlap = 0;\\n        int top = Math.min(ay2, by2);\\n        int bottom = Math.max(by1, ay1);\\n        int left = Math.max(ax1, bx1);\\n        int right = Math.min(ax2, bx2);\\n        if (top > bottom && left < right) {\\n            overlap = (top - bottom) * (right - left);\\n        }\\n        return A1 + A2 - overlap;\\n    }\\n}\\n```\\n```cpp []\\nclass Solution {\\n    public:\\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        int A1 = (ax2 - ax1) * (ay2 - ay1);\\n        int A2 = (bx2 - bx1) * (by2 - by1);\\n        int overlap = 0;\\n        int top = min(ay2,by2);\\n        int bottom = max(by1,ay1);\\n        int left = max(ax1,bx1);\\n        int right = min(ax2,bx2);\\n        if (top > bottom && left < right) {\\n            overlap = (top - bottom) * (right - left);\\n        }\\n        return A1 + A2 - overlap;\\n    }\\n};\\n```\\n\\n## Method B\\n```java []\\nclass Solution {\\n    public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        if (ax1 <= bx1 && ay1 <= by1 && ax2 >= bx2 && ay2 >= by2)       return (ax2 - ax1) * (ay2 - ay1);\\n        if (ax1 >= bx1 && ay1 >= by1 && ax2 <= bx2 && ay2 <= by2)       return (bx2 - bx1) * (by2 - by1);\\n        if (ax1 >= bx1 && ax2 <= bx2 && ay2 >= by2 && ay1 <= by1)       return (ax2 - ax1) * (ay2 - ay1) - (ax2 - ax1) * (by2 - by1) + (bx2 - bx1) * (by2 - by1);\\n        if (ax1 <= bx1 && ax2 >= bx2 && ay2 <= by2 && ay1 >= by1)       return (ax2 - ax1) * (ay2 - ay1) - (bx2 - bx1) * (ay2 - ay1) + (bx2 - bx1) * (by2 - by1);\\n        if (ax2 >= bx1 && ax1 <= bx1 && ay2 >= by2 && ay1 <= by1)       return (ax2 - ax1) * (ay2 - ay1) - (ax2 - bx1) * (by2 - by1) + (bx2 - bx1) * (by2 - by1);\\n        if (by2 >= ay1 && by2 <= ay2 && bx1 >= ax1 && bx2 <= ax2)       return (ax2 - ax1) * (ay2 - ay1) - (bx2 - bx1) * (by2 - ay1) + (bx2 - bx1) * (by2 - by1);\\n        if (bx2 >= ax1 && bx2 <= ax2 && by1 >= ay1 && by2 <= ay2)       return (ax2 - ax1) * (ay2 - ay1) - (bx2 - ax1) * (by2 - by1) + (bx2 - bx1) * (by2 - by1);\\n        if (by1 >= ay1 && by1 <= ay2 && bx1 >= ax1 && bx2 <= ax2)       return (ax2 - ax1) * (ay2 - ay1) - (ay2 - by1) * (bx2 - bx1) + (bx2 - bx1) * (by2 - by1);\\n        if (bx2 >= ax1 && bx1 <= ax1 && by2 >= ay2 && by1 <= ay1)       return (ax2 - ax1) * (ay2 - ay1) - (bx2 - ax1) * (ay2 - ay1) + (bx2 - bx1) * (by2 - by1);\\n        if (ay2 >= by1 && ay2 <= by2 && ax1 >= bx1 && ax2 <= bx2)       return (ax2 - ax1) * (ay2 - ay1) - (ax2 - ax1) * (ay2 - by1) + (bx2 - bx1) * (by2 - by1);\\n        if (ax2 >= bx1 && ax2 <= bx2 && ay1 >= by1 && ay2 <= by2)       return (ax2 - ax1) * (ay2 - ay1) - (ax2 - bx1) * (ay2 - ay1) + (bx2 - bx1) * (by2 - by1);\\n        if (ay1 >= by1 && ay1 <= by2 && ax1 >= bx1 && ax2 <= bx2)       return (ax2 - ax1) * (ay2 - ay1) - (by2 - ay1) * (ax2 - ax1) + (bx2 - bx1) * (by2 - by1);\\n        if (ax2 >= bx1 && bx2 >= ax2 && ay1 >= by1 && by2 >= ay1)       return (ax2 - ax1) * (ay2 - ay1) - (ax2 - bx1) * (by2 - ay1) + (bx2 - bx1) * (by2 - by1);\\n        if (bx2 >= ax1 && ax1 >= bx1 && by1 <= ay1 && ay1 <= by2)       return (ax2 - ax1) * (ay2 - ay1) - (bx2 - ax1) * (by2 - ay1) + (bx2 - bx1) * (by2 - by1);\\n        if (bx2 >= ax1 && ax1 >= bx1 && by2 >= ay2 && by1 <= ay2)       return (ax2 - ax1) * (ay2 - ay1) - (bx2 - ax1) * (ay2 - by1) + (bx2 - bx1) * (by2 - by1);\\n        if (ax2 >= bx1 && ax2 <= bx2 && by1 <= ay2 && by2 >= ay2)       return (ax2 - ax1) * (ay2 - ay1) - (ax2 - bx1) * (ay2 - by1) + (bx2 - bx1) * (by2 - by1);\\n        return (ax2 - ax1) * (ay2 - ay1) + (bx2 - bx1) * (by2 - by1);\\n    }\\n}\\n```\\n```cpp []\\nclass Solution {\\n    public:\\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        if (ax1 <= bx1 && ay1 <= by1 && ax2 >= bx2 && ay2 >= by2)       return (ax2 - ax1) * (ay2 - ay1);\\n        if (ax1 >= bx1 && ay1 >= by1 && ax2 <= bx2 && ay2 <= by2)       return (bx2 - bx1) * (by2 - by1);\\n        if (ax1 >= bx1 && ax2 <= bx2 && ay2 >= by2 && ay1 <= by1)       return (ax2 - ax1) * (ay2 - ay1) - (ax2 - ax1) * (by2 - by1) + (bx2 - bx1) * (by2 - by1);\\n        if (ax1 <= bx1 && ax2 >= bx2 && ay2 <= by2 && ay1 >= by1)       return (ax2 - ax1) * (ay2 - ay1) - (bx2 - bx1) * (ay2 - ay1) + (bx2 - bx1) * (by2 - by1);\\n        if (ax2 >= bx1 && ax1 <= bx1 && ay2 >= by2 && ay1 <= by1)       return (ax2 - ax1) * (ay2 - ay1) - (ax2 - bx1) * (by2 - by1) + (bx2 - bx1) * (by2 - by1);\\n        if (by2 >= ay1 && by2 <= ay2 && bx1 >= ax1 && bx2 <= ax2)       return (ax2 - ax1) * (ay2 - ay1) - (bx2 - bx1) * (by2 - ay1) + (bx2 - bx1) * (by2 - by1);\\n        if (bx2 >= ax1 && bx2 <= ax2 && by1 >= ay1 && by2 <= ay2)       return (ax2 - ax1) * (ay2 - ay1) - (bx2 - ax1) * (by2 - by1) + (bx2 - bx1) * (by2 - by1);\\n        if (by1 >= ay1 && by1 <= ay2 && bx1 >= ax1 && bx2 <= ax2)       return (ax2 - ax1) * (ay2 - ay1) - (ay2 - by1) * (bx2 - bx1) + (bx2 - bx1) * (by2 - by1);\\n        if (bx2 >= ax1 && bx1 <= ax1 && by2 >= ay2 && by1 <= ay1)       return (ax2 - ax1) * (ay2 - ay1) - (bx2 - ax1) * (ay2 - ay1) + (bx2 - bx1) * (by2 - by1);\\n        if (ay2 >= by1 && ay2 <= by2 && ax1 >= bx1 && ax2 <= bx2)       return (ax2 - ax1) * (ay2 - ay1) - (ax2 - ax1) * (ay2 - by1) + (bx2 - bx1) * (by2 - by1);\\n        if (ax2 >= bx1 && ax2 <= bx2 && ay1 >= by1 && ay2 <= by2)       return (ax2 - ax1) * (ay2 - ay1) - (ax2 - bx1) * (ay2 - ay1) + (bx2 - bx1) * (by2 - by1);\\n        if (ay1 >= by1 && ay1 <= by2 && ax1 >= bx1 && ax2 <= bx2)       return (ax2 - ax1) * (ay2 - ay1) - (by2 - ay1) * (ax2 - ax1) + (bx2 - bx1) * (by2 - by1);\\n        if (ax2 >= bx1 && bx2 >= ax2 && ay1 >= by1 && by2 >= ay1)       return (ax2 - ax1) * (ay2 - ay1) - (ax2 - bx1) * (by2 - ay1) + (bx2 - bx1) * (by2 - by1);\\n        if (bx2 >= ax1 && ax1 >= bx1 && by1 <= ay1 && ay1 <= by2)       return (ax2 - ax1) * (ay2 - ay1) - (bx2 - ax1) * (by2 - ay1) + (bx2 - bx1) * (by2 - by1);\\n        if (bx2 >= ax1 && ax1 >= bx1 && by2 >= ay2 && by1 <= ay2)       return (ax2 - ax1) * (ay2 - ay1) - (bx2 - ax1) * (ay2 - by1) + (bx2 - bx1) * (by2 - by1);\\n        if (ax2 >= bx1 && ax2 <= bx2 && by1 <= ay2 && by2 >= ay2)       return (ax2 - ax1) * (ay2 - ay1) - (ax2 - bx1) * (ay2 - by1) + (bx2 - bx1) * (by2 - by1);\\n        return (ax2 - ax1) * (ay2 - ay1) + (bx2 - bx1) * (by2 - by1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        int A1 = (ax2 - ax1) * (ay2 - ay1);\\n        int A2 = (bx2 - bx1) * (by2 - by1);\\n        int overlap = 0;\\n        int top = Math.min(ay2, by2);\\n        int bottom = Math.max(by1, ay1);\\n        int left = Math.max(ax1, bx1);\\n        int right = Math.min(ax2, bx2);\\n        if (top > bottom && left < right) {\\n            overlap = (top - bottom) * (right - left);\\n        }\\n        return A1 + A2 - overlap;\\n    }\\n}\\n```\n```cpp []\\nclass Solution {\\n    public:\\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        int A1 = (ax2 - ax1) * (ay2 - ay1);\\n        int A2 = (bx2 - bx1) * (by2 - by1);\\n        int overlap = 0;\\n        int top = min(ay2,by2);\\n        int bottom = max(by1,ay1);\\n        int left = max(ax1,bx1);\\n        int right = min(ax2,bx2);\\n        if (top > bottom && left < right) {\\n            overlap = (top - bottom) * (right - left);\\n        }\\n        return A1 + A2 - overlap;\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        if (ax1 <= bx1 && ay1 <= by1 && ax2 >= bx2 && ay2 >= by2)       return (ax2 - ax1) * (ay2 - ay1);\\n        if (ax1 >= bx1 && ay1 >= by1 && ax2 <= bx2 && ay2 <= by2)       return (bx2 - bx1) * (by2 - by1);\\n        if (ax1 >= bx1 && ax2 <= bx2 && ay2 >= by2 && ay1 <= by1)       return (ax2 - ax1) * (ay2 - ay1) - (ax2 - ax1) * (by2 - by1) + (bx2 - bx1) * (by2 - by1);\\n        if (ax1 <= bx1 && ax2 >= bx2 && ay2 <= by2 && ay1 >= by1)       return (ax2 - ax1) * (ay2 - ay1) - (bx2 - bx1) * (ay2 - ay1) + (bx2 - bx1) * (by2 - by1);\\n        if (ax2 >= bx1 && ax1 <= bx1 && ay2 >= by2 && ay1 <= by1)       return (ax2 - ax1) * (ay2 - ay1) - (ax2 - bx1) * (by2 - by1) + (bx2 - bx1) * (by2 - by1);\\n        if (by2 >= ay1 && by2 <= ay2 && bx1 >= ax1 && bx2 <= ax2)       return (ax2 - ax1) * (ay2 - ay1) - (bx2 - bx1) * (by2 - ay1) + (bx2 - bx1) * (by2 - by1);\\n        if (bx2 >= ax1 && bx2 <= ax2 && by1 >= ay1 && by2 <= ay2)       return (ax2 - ax1) * (ay2 - ay1) - (bx2 - ax1) * (by2 - by1) + (bx2 - bx1) * (by2 - by1);\\n        if (by1 >= ay1 && by1 <= ay2 && bx1 >= ax1 && bx2 <= ax2)       return (ax2 - ax1) * (ay2 - ay1) - (ay2 - by1) * (bx2 - bx1) + (bx2 - bx1) * (by2 - by1);\\n        if (bx2 >= ax1 && bx1 <= ax1 && by2 >= ay2 && by1 <= ay1)       return (ax2 - ax1) * (ay2 - ay1) - (bx2 - ax1) * (ay2 - ay1) + (bx2 - bx1) * (by2 - by1);\\n        if (ay2 >= by1 && ay2 <= by2 && ax1 >= bx1 && ax2 <= bx2)       return (ax2 - ax1) * (ay2 - ay1) - (ax2 - ax1) * (ay2 - by1) + (bx2 - bx1) * (by2 - by1);\\n        if (ax2 >= bx1 && ax2 <= bx2 && ay1 >= by1 && ay2 <= by2)       return (ax2 - ax1) * (ay2 - ay1) - (ax2 - bx1) * (ay2 - ay1) + (bx2 - bx1) * (by2 - by1);\\n        if (ay1 >= by1 && ay1 <= by2 && ax1 >= bx1 && ax2 <= bx2)       return (ax2 - ax1) * (ay2 - ay1) - (by2 - ay1) * (ax2 - ax1) + (bx2 - bx1) * (by2 - by1);\\n        if (ax2 >= bx1 && bx2 >= ax2 && ay1 >= by1 && by2 >= ay1)       return (ax2 - ax1) * (ay2 - ay1) - (ax2 - bx1) * (by2 - ay1) + (bx2 - bx1) * (by2 - by1);\\n        if (bx2 >= ax1 && ax1 >= bx1 && by1 <= ay1 && ay1 <= by2)       return (ax2 - ax1) * (ay2 - ay1) - (bx2 - ax1) * (by2 - ay1) + (bx2 - bx1) * (by2 - by1);\\n        if (bx2 >= ax1 && ax1 >= bx1 && by2 >= ay2 && by1 <= ay2)       return (ax2 - ax1) * (ay2 - ay1) - (bx2 - ax1) * (ay2 - by1) + (bx2 - bx1) * (by2 - by1);\\n        if (ax2 >= bx1 && ax2 <= bx2 && by1 <= ay2 && by2 >= ay2)       return (ax2 - ax1) * (ay2 - ay1) - (ax2 - bx1) * (ay2 - by1) + (bx2 - bx1) * (by2 - by1);\\n        return (ax2 - ax1) * (ay2 - ay1) + (bx2 - bx1) * (by2 - by1);\\n    }\\n}\\n```\n```cpp []\\nclass Solution {\\n    public:\\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        if (ax1 <= bx1 && ay1 <= by1 && ax2 >= bx2 && ay2 >= by2)       return (ax2 - ax1) * (ay2 - ay1);\\n        if (ax1 >= bx1 && ay1 >= by1 && ax2 <= bx2 && ay2 <= by2)       return (bx2 - bx1) * (by2 - by1);\\n        if (ax1 >= bx1 && ax2 <= bx2 && ay2 >= by2 && ay1 <= by1)       return (ax2 - ax1) * (ay2 - ay1) - (ax2 - ax1) * (by2 - by1) + (bx2 - bx1) * (by2 - by1);\\n        if (ax1 <= bx1 && ax2 >= bx2 && ay2 <= by2 && ay1 >= by1)       return (ax2 - ax1) * (ay2 - ay1) - (bx2 - bx1) * (ay2 - ay1) + (bx2 - bx1) * (by2 - by1);\\n        if (ax2 >= bx1 && ax1 <= bx1 && ay2 >= by2 && ay1 <= by1)       return (ax2 - ax1) * (ay2 - ay1) - (ax2 - bx1) * (by2 - by1) + (bx2 - bx1) * (by2 - by1);\\n        if (by2 >= ay1 && by2 <= ay2 && bx1 >= ax1 && bx2 <= ax2)       return (ax2 - ax1) * (ay2 - ay1) - (bx2 - bx1) * (by2 - ay1) + (bx2 - bx1) * (by2 - by1);\\n        if (bx2 >= ax1 && bx2 <= ax2 && by1 >= ay1 && by2 <= ay2)       return (ax2 - ax1) * (ay2 - ay1) - (bx2 - ax1) * (by2 - by1) + (bx2 - bx1) * (by2 - by1);\\n        if (by1 >= ay1 && by1 <= ay2 && bx1 >= ax1 && bx2 <= ax2)       return (ax2 - ax1) * (ay2 - ay1) - (ay2 - by1) * (bx2 - bx1) + (bx2 - bx1) * (by2 - by1);\\n        if (bx2 >= ax1 && bx1 <= ax1 && by2 >= ay2 && by1 <= ay1)       return (ax2 - ax1) * (ay2 - ay1) - (bx2 - ax1) * (ay2 - ay1) + (bx2 - bx1) * (by2 - by1);\\n        if (ay2 >= by1 && ay2 <= by2 && ax1 >= bx1 && ax2 <= bx2)       return (ax2 - ax1) * (ay2 - ay1) - (ax2 - ax1) * (ay2 - by1) + (bx2 - bx1) * (by2 - by1);\\n        if (ax2 >= bx1 && ax2 <= bx2 && ay1 >= by1 && ay2 <= by2)       return (ax2 - ax1) * (ay2 - ay1) - (ax2 - bx1) * (ay2 - ay1) + (bx2 - bx1) * (by2 - by1);\\n        if (ay1 >= by1 && ay1 <= by2 && ax1 >= bx1 && ax2 <= bx2)       return (ax2 - ax1) * (ay2 - ay1) - (by2 - ay1) * (ax2 - ax1) + (bx2 - bx1) * (by2 - by1);\\n        if (ax2 >= bx1 && bx2 >= ax2 && ay1 >= by1 && by2 >= ay1)       return (ax2 - ax1) * (ay2 - ay1) - (ax2 - bx1) * (by2 - ay1) + (bx2 - bx1) * (by2 - by1);\\n        if (bx2 >= ax1 && ax1 >= bx1 && by1 <= ay1 && ay1 <= by2)       return (ax2 - ax1) * (ay2 - ay1) - (bx2 - ax1) * (by2 - ay1) + (bx2 - bx1) * (by2 - by1);\\n        if (bx2 >= ax1 && ax1 >= bx1 && by2 >= ay2 && by1 <= ay2)       return (ax2 - ax1) * (ay2 - ay1) - (bx2 - ax1) * (ay2 - by1) + (bx2 - bx1) * (by2 - by1);\\n        if (ax2 >= bx1 && ax2 <= bx2 && by1 <= ay2 && by2 >= ay2)       return (ax2 - ax1) * (ay2 - ay1) - (ax2 - bx1) * (ay2 - by1) + (bx2 - bx1) * (by2 - by1);\\n        return (ax2 - ax1) * (ay2 - ay1) + (bx2 - bx1) * (by2 - by1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2686395,
                "title": "simple-python-solution-o-1",
                "content": "```\\nclass Solution:\\n    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:\\n        a_area = abs(ax1 - ax2) * abs(ay1 - ay2)\\n        b_area = abs(bx1 - bx2) * abs(by1 - by2)\\n        \\n        if (bx1 < ax2 and ax1 < bx2) and (by1 < ay2 and ay1 < by2): # Intersection\\n            rx1 = max(ax1, bx1)\\n            rx2 = min(ax2, bx2)\\n            ry1 = max(ay1, by1)\\n            ry2 = min(ay2, by2)\\n            return a_area + b_area - abs(rx1 - rx2) * abs(ry1 - ry2)\\n        \\n        return a_area + b_area  # No Intersection\\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:\\n        a_area = abs(ax1 - ax2) * abs(ay1 - ay2)\\n        b_area = abs(bx1 - bx2) * abs(by1 - by2)\\n        \\n        if (bx1 < ax2 and ax1 < bx2) and (by1 < ay2 and ay1 < by2): # Intersection\\n            rx1 = max(ax1, bx1)\\n            rx2 = min(ax2, bx2)\\n            ry1 = max(ay1, by1)\\n            ry2 = min(ay2, by2)\\n            return a_area + b_area - abs(rx1 - rx2) * abs(ry1 - ry2)\\n        \\n        return a_area + b_area  # No Intersection\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2463810,
                "title": "easy-explanation-with-visual-help-c-java-python-javascript-golang",
                "content": "**Intuition**\\nIf the rectangles do not overlap, then the answer is obvious: add the areas of both. If they do overlap, then we are adding the overlapping part twice. In that case, we could find out the relative configuration of both rectangles, break the common figure into smaller rectangles accordingly, and then add the smaller parts together. However, there are multiple configurations, and each one would have to be treated differently:\\n<br>\\n![image](https://assets.leetcode.com/users/images/9c01ab75-f8c9-4e51-bfa9-fa94d47f6dc8_1661168144.9706047.png)\\n<br>\\n<br>\\nA better solution would be to add the two rectangles and simply substract the common part that was added twice:\\n\\n![image](https://assets.leetcode.com/users/images/d9aac873-53f1-45e2-ba90-6a9bf5571e76_1661172217.2438798.png)\\n\\n It is always a rectangle limited by the *rightmost left* line, the *higher bottom*, the *leftmost right* and the *lower top*.\\n<br>\\n**Solution:**\\nThis can be solved in one line but it would be a very hacky solution that would paint a poor image in an interview (\"the candidate shows little regard for readability / maintainability\"). On the other hand, we could do the opposite:\\n<br>\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        int first  = area(ax1, ay1, ax2, ay2);\\n        int second = area(bx1, by1, bx2, by2);\\n        \\n        int leftOverlap  = max(ax1, bx1);\\n        int downOverlap  = max(ay1, by1);\\n        \\n        int rightOverlap = min(ax2, bx2);\\n        int upOverlap    = min(ay2, by2);\\n\\n        int overlap = area(leftOverlap, downOverlap, rightOverlap, upOverlap);\\n\\n        return first + second - overlap;\\n    }\\n\\nprivate:\\n    // Returns 0 if right < left or up < down\\n    int area(int left, int down, int right, int up) {\\n        \\n        if (left > right || down > up) {\\n            return 0;\\n        }\\n        \\n        return (right - left) * (up - down);\\n            \\n    }\\n};\\n```\\n<br>\\n\\n**Java**\\n```\\nclass Solution {\\n    public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        int first  = area(ax1, ay1, ax2, ay2);\\n        int second = area(bx1, by1, bx2, by2);\\n        \\n        int leftOverlap  = Math.max(ax1, bx1);\\n        int downOverlap  = Math.max(ay1, by1);\\n        \\n        int rightOverlap = Math.min(ax2, bx2);\\n        int upOverlap    = Math.min(ay2, by2);\\n\\n        int overlap = area(leftOverlap, downOverlap, rightOverlap, upOverlap);\\n\\n        return first + second - overlap;\\n    }\\n    \\n    \\n    // Returns 0 if right < left or up < down\\n    private int area(int left, int down, int right, int up) {\\n        \\n        if (left > right || down > up) {\\n            return 0;\\n        }\\n        \\n        return (right - left) * (up - down);\\n            \\n    }\\n}\\n```\\n<br>\\n\\n**Python**\\n```\\nclass Solution(object):\\n    def computeArea(self, ax1, ay1, ax2, ay2, bx1, by1, bx2, by2):\\n\\t\\n        first  = self.area(ax1, ay1, ax2, ay2)\\n        second = self.area(bx1, by1, bx2, by2)\\n\\n        leftOverlap  = max(ax1, bx1)\\n        downOverlap  = max(ay1, by1)\\n\\n        rightOverlap = min(ax2, bx2)\\n        upOverlap    = min(ay2, by2)\\n\\n        overlap = self.area(leftOverlap, downOverlap, rightOverlap, upOverlap)\\n\\n        return first + second - overlap\\n\\t\\t\\n    # Returns 0 if right < left or up < down\\n    def area(self, left, down, right, up):\\n\\t\\n        if left > right or down > up:\\n            return 0\\n        \\n        return (right - left) * (up - down)\\n    \\n    \\n```\\n<br>\\n\\n**JavaScript**\\n```\\nvar computeArea = function(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {\\n    let first  = area(ax1, ay1, ax2, ay2);\\n    let second = area(bx1, by1, bx2, by2);\\n\\n    let leftOverlap  = Math.max(ax1, bx1);\\n    let downOverlap  = Math.max(ay1, by1);\\n\\n    let rightOverlap = Math.min(ax2, bx2);\\n    let upOverlap    = Math.min(ay2, by2);\\n\\n    let overlap = area(leftOverlap, downOverlap, rightOverlap, upOverlap);\\n\\n    return first + second - overlap;\\n};\\n\\n// Returns 0 if right < left or up < down\\nfunction area(left, down, right, up) {\\n        \\n    if (left > right || down > up) {\\n        return 0;\\n    }\\n\\n    return (right - left) * (up - down);\\n    \\n}\\n```\\n<br>\\n\\n**Golang**\\n```\\nfunc computeArea(ax1 int, ay1 int, ax2 int, ay2 int, bx1 int, by1 int, bx2 int, by2 int) int {\\n    \\n    first  := area(ax1, ay1, ax2, ay2)\\n    second := area(bx1, by1, bx2, by2)\\n    \\n    leftOverlap  := max(ax1, bx1)\\n    downOverlap  := max(ay1, by1)\\n    \\n    rightOverlap := min(ax2, bx2)\\n    upOverlap    := min(ay2, by2)\\n    \\n    overlap := area(leftOverlap, downOverlap, rightOverlap, upOverlap)\\n    \\n    return first + second - overlap\\n    \\n}\\n\\n// Returns 0 if right < left or up < down\\nfunc area(left, down, right, up int) int {\\n    if left > right || down > up {\\n        return 0\\n    }\\n    return (right - left) * (up - down)\\n}\\n\\n// math.Max accepts and returns floats and makes a mess\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Go"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        int first  = area(ax1, ay1, ax2, ay2);\\n        int second = area(bx1, by1, bx2, by2);\\n        \\n        int leftOverlap  = max(ax1, bx1);\\n        int downOverlap  = max(ay1, by1);\\n        \\n        int rightOverlap = min(ax2, bx2);\\n        int upOverlap    = min(ay2, by2);\\n\\n        int overlap = area(leftOverlap, downOverlap, rightOverlap, upOverlap);\\n\\n        return first + second - overlap;\\n    }\\n\\nprivate:\\n    // Returns 0 if right < left or up < down\\n    int area(int left, int down, int right, int up) {\\n        \\n        if (left > right || down > up) {\\n            return 0;\\n        }\\n        \\n        return (right - left) * (up - down);\\n            \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        int first  = area(ax1, ay1, ax2, ay2);\\n        int second = area(bx1, by1, bx2, by2);\\n        \\n        int leftOverlap  = Math.max(ax1, bx1);\\n        int downOverlap  = Math.max(ay1, by1);\\n        \\n        int rightOverlap = Math.min(ax2, bx2);\\n        int upOverlap    = Math.min(ay2, by2);\\n\\n        int overlap = area(leftOverlap, downOverlap, rightOverlap, upOverlap);\\n\\n        return first + second - overlap;\\n    }\\n    \\n    \\n    // Returns 0 if right < left or up < down\\n    private int area(int left, int down, int right, int up) {\\n        \\n        if (left > right || down > up) {\\n            return 0;\\n        }\\n        \\n        return (right - left) * (up - down);\\n            \\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def computeArea(self, ax1, ay1, ax2, ay2, bx1, by1, bx2, by2):\\n\\t\\n        first  = self.area(ax1, ay1, ax2, ay2)\\n        second = self.area(bx1, by1, bx2, by2)\\n\\n        leftOverlap  = max(ax1, bx1)\\n        downOverlap  = max(ay1, by1)\\n\\n        rightOverlap = min(ax2, bx2)\\n        upOverlap    = min(ay2, by2)\\n\\n        overlap = self.area(leftOverlap, downOverlap, rightOverlap, upOverlap)\\n\\n        return first + second - overlap\\n\\t\\t\\n    # Returns 0 if right < left or up < down\\n    def area(self, left, down, right, up):\\n\\t\\n        if left > right or down > up:\\n            return 0\\n        \\n        return (right - left) * (up - down)\\n    \\n    \\n```\n```\\nvar computeArea = function(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {\\n    let first  = area(ax1, ay1, ax2, ay2);\\n    let second = area(bx1, by1, bx2, by2);\\n\\n    let leftOverlap  = Math.max(ax1, bx1);\\n    let downOverlap  = Math.max(ay1, by1);\\n\\n    let rightOverlap = Math.min(ax2, bx2);\\n    let upOverlap    = Math.min(ay2, by2);\\n\\n    let overlap = area(leftOverlap, downOverlap, rightOverlap, upOverlap);\\n\\n    return first + second - overlap;\\n};\\n\\n// Returns 0 if right < left or up < down\\nfunction area(left, down, right, up) {\\n        \\n    if (left > right || down > up) {\\n        return 0;\\n    }\\n\\n    return (right - left) * (up - down);\\n    \\n}\\n```\n```\\nfunc computeArea(ax1 int, ay1 int, ax2 int, ay2 int, bx1 int, by1 int, bx2 int, by2 int) int {\\n    \\n    first  := area(ax1, ay1, ax2, ay2)\\n    second := area(bx1, by1, bx2, by2)\\n    \\n    leftOverlap  := max(ax1, bx1)\\n    downOverlap  := max(ay1, by1)\\n    \\n    rightOverlap := min(ax2, bx2)\\n    upOverlap    := min(ay2, by2)\\n    \\n    overlap := area(leftOverlap, downOverlap, rightOverlap, upOverlap)\\n    \\n    return first + second - overlap\\n    \\n}\\n\\n// Returns 0 if right < left or up < down\\nfunc area(left, down, right, up int) int {\\n    if left > right || down > up {\\n        return 0\\n    }\\n    return (right - left) * (up - down)\\n}\\n\\n// math.Max accepts and returns floats and makes a mess\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2052948,
                "title": "o-1-java",
                "content": "Let (x1, y1, x2, y2) and (X1, Y1, X2, Y2).\\n\\n```\\npublic int computeArea(int x1, int y1, int x2, int y2, int X1, int Y1, int X2, int Y2) {\\n\\tint area1 = (x2-x1) * (y2-y1);\\n\\tint area2 = (X2-X1) * (Y2-Y1);\\n\\n\\tint overlap = 0;\\n\\tint left = Math.max(x1, X1);\\n\\tint right = Math.min(x2, X2);\\n\\tint bottom = Math.max(y1, Y1);\\n\\tint top = Math.min(y2, Y2);\\n\\n\\tif (left < right && bottom < top) \\n\\t\\toverlap = (right-left) * (top-bottom);\\n\\n\\treturn area1 + area2 - overlap; \\n}\\n```\\n\\nTC : O(1)\\nSC : O(1)\\n\\nHope this helps \\uD83D\\uDE0A. Spread love \\uD83E\\uDDE1 ... there is already so much hatred out there!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int computeArea(int x1, int y1, int x2, int y2, int X1, int Y1, int X2, int Y2) {\\n\\tint area1 = (x2-x1) * (y2-y1);\\n\\tint area2 = (X2-X1) * (Y2-Y1);\\n\\n\\tint overlap = 0;\\n\\tint left = Math.max(x1, X1);\\n\\tint right = Math.min(x2, X2);\\n\\tint bottom = Math.max(y1, Y1);\\n\\tint top = Math.min(y2, Y2);\\n\\n\\tif (left < right && bottom < top) \\n\\t\\toverlap = (right-left) * (top-bottom);\\n\\n\\treturn area1 + area2 - overlap; \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1687223,
                "title": "java-simple-100-solution",
                "content": "```\\n\\nclass Solution {\\n \\n    public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {        \\n        int fistRectArea = Math.abs((ax2 - ax1) * (ay2 - ay1));\\n        int secondRectArea = Math.abs((bx2 - bx1) * (by2 - by1));\\n\\n        int commonX = Math.min(ax2, bx2) - Math.max(ax1, bx1);\\n        if (commonX < 0) {\\n            commonX = 0;\\n        }\\n             \\n        int commonY = Math.min(ay2, by2) - Math.max(ay1, by1);\\n        if (commonY < 0) {\\n            commonY = 0;\\n        }        \\n        \\n        return fistRectArea + secondRectArea - commonX * commonY;      \\n    }\\n    \\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n \\n    public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {        \\n        int fistRectArea = Math.abs((ax2 - ax1) * (ay2 - ay1));\\n        int secondRectArea = Math.abs((bx2 - bx1) * (by2 - by1));\\n\\n        int commonX = Math.min(ax2, bx2) - Math.max(ax1, bx1);\\n        if (commonX < 0) {\\n            commonX = 0;\\n        }\\n             \\n        int commonY = Math.min(ay2, by2) - Math.max(ay1, by1);\\n        if (commonY < 0) {\\n            commonY = 0;\\n        }        \\n        \\n        return fistRectArea + secondRectArea - commonX * commonY;      \\n    }\\n    \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1381595,
                "title": "c-simple-solution",
                "content": "```\\npublic int ComputeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        int totalArea = (ax2 - ax1) * (ay2 - ay1) + (bx2 - bx1) * (by2 - by1);\\n        \\n        int length =  Math.Min(ax2, bx2) - Math.Max(ax1, bx1);\\n        \\n        int height = Math.Min(ay2, by2) - Math.Max(ay1, by1);\\n        \\n        if (height < 0 || length < 0)\\n            return totalArea;\\n        \\n        return totalArea - (length * height);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int ComputeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        int totalArea = (ax2 - ax1) * (ay2 - ay1) + (bx2 - bx1) * (by2 - by1);\\n        \\n        int length =  Math.Min(ax2, bx2) - Math.Max(ax1, bx1);\\n        \\n        int height = Math.Min(ay2, by2) - Math.Max(ay1, by1);\\n        \\n        if (height < 0 || length < 0)\\n            return totalArea;\\n        \\n        return totalArea - (length * height);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1112232,
                "title": "a-java-readable-code-runtime-2-ms-faster-than-100-00",
                "content": "## Algorithm:\\n\\n1. Calculate Area of First Rectange.\\n2. Calculate Area of Second Rectange.\\n3. Calculate the Sum of Two Area\\n4. Check whether Rectange are overlap are not\\n\\t- if overlap \\n\\t\\t- calculate overlaped Area\\n\\t- else\\n\\t\\t- overlape area is 0\\n```\\nclass Solution {\\n    public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        \\n        int rectOneArea = (C -A) * (D -B);\\n        int rectTwoArea = (G -E) * (H -F);\\n        // calculate total area of two\\n        int area = rectOneArea + rectTwoArea;\\n        \\n        // find Overlaped x and y\\n        int left =  Math.max(A, E); \\n        int right =  Math.min(C, G);  \\n        int bottom =  Math.max(B, F);\\n        int top =  Math.min(D, H);\\n        // calculate overlap area\\n        int overlapArea = 0;\\n        if(right > left && top > bottom)\\n            overlapArea = (right - left) * (top-bottom);\\n        \\n       return area-overlapArea;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        \\n        int rectOneArea = (C -A) * (D -B);\\n        int rectTwoArea = (G -E) * (H -F);\\n        // calculate total area of two\\n        int area = rectOneArea + rectTwoArea;\\n        \\n        // find Overlaped x and y\\n        int left =  Math.max(A, E); \\n        int right =  Math.min(C, G);  \\n        int bottom =  Math.max(B, F);\\n        int top =  Math.min(D, H);\\n        // calculate overlap area\\n        int overlapArea = 0;\\n        if(right > left && top > bottom)\\n            overlapArea = (right - left) * (top-bottom);\\n        \\n       return area-overlapArea;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1094752,
                "title": "golang-solution-92-86-100-with-explanation-and-images",
                "content": "**Code On The Bottom**\\n\\nThe main idea of this solution is to find the area of each indivigual rectangle and then add them together. After that subtract the overlap of both of them. \\n\\nIf you don\\'t understand the `ABCDRectangle` and the `EFGHRectangle` then look at the following images:\\n\\n**We can have the example:**\\n\\n![image](https://assets.leetcode.com/users/images/4702cfe7-8a0f-4787-b102-b0b0a74416ab_1614961353.9702065.png)\\n\\n\\nLet us start of with the `ABCDRectangle`:\\n\\n![image](https://assets.leetcode.com/users/images/13d5569c-1590-41e6-86de-e457b925911c_1614961370.9766803.png)\\n\\n\\nWhen we do the equation `(D - B) * (C - A)` we are basicly doing `width * length`. The `width` is `(D - B)`. This can be show by using the image above where `A = -4, B = 2, C = 4, D = 5`. When we do `(D - B)` it equal `(5 - 2) = 3`. So we know that the rectangle has a width of `3`.\\n\\nNow the `length` is going to be `(C - A)` which is equal to `(4 - (-4)) = (4 + 4) = 8`. Since we already know the width, and we know the height we can put them together. `width * height = 3 * 8 = 24`. The area of this rectangle is `24`.\\n\\nNext let us do `EFGHRectangle`:\\n\\n![image](https://assets.leetcode.com/users/images/3749c188-0e74-492a-9176-ce35e5beb951_1614961401.110166.png)\\n\\n\\nThis is pretty much the same as the `ABCDRectangle`. The equation `(H - F) * (G - E) = width * length`. As you can see in the image `E = 3, F = -2, G = 7, H = 8`. When we input the numbers in for the variables we get `(H - F) = (8 - (-2)) = (8 + 2) = 10`, so our width is `10`.\\n\\nWe can do the same thing but with length, The part of the equation that is for length is `(G - E)` when we input the numbers in for the variables we get `(7 - 3) = 4`. So we have a length of `4`.\\n\\nWhen we multiply our width and our length together we get `10 * 4 = 40` so we have an area of `40`.\\n\\nWhen we put both rectangles together we get:\\n\\n\\nSince we have an area of `24` for `ABCDRectangle` and an area of `40` for `EFGHRectangle`, when we add them up we get an area of `64`. The only problem is we have some over lap (Which I have colored purple in the image). We need to subtract the overlap from the total area. \\n\\n![image](https://assets.leetcode.com/users/images/2f8e2900-f92d-4ca7-ba0d-1db430213d9b_1614961429.249176.png)\\n\\n\\n\\nThe overlap is a rectangle as well so we know that it has two part, `length` and `width`. The idea of this part is the find the length and the width and then multiply them together and subtract that product from the total area.\\n\\nI made four variables to find out where the overlap is, `left, right, up , down`. Left is the max of `A` and `E`. In this example the max is `E`, and it is the left side of the rectangle. The right is the min of `G` and `C`. In this example `C` is the minimum. Up is the minumum of `D` and `H`. `D` is smaller than `H` so up is `D`. Down is the max of `F` and `B`. `B` is greater than `F` so down is `B`.\\n\\nSince we know that `left = E, right = C, up = D, down = B`, also we know that `A = -4, B = 2, C = 4, D = 5, E = 3, F = -2, G = 7, H = 8` so we can put those values in for their variables. `left = 3, right = 4, up = 5, down = 2`.\\n\\nBefore we even make the over lap rectangle we have to check whether there is a overlap rectangle. So we do `right > left` because that means the right pointer is greater than the left pointer, and that there is not a negative area. Next it checks whether `up > down` for the same reason that there is no negative area.\\n\\nNow we can make a rectangle using these values and then subtract that rectangle from the total area. The length will be `(right - left) = (4 - 3) = 1`, and the width will be `(up - down) = (5 - 2) = 3`. Since we know that the area of a rectangle is `length * width` we can do `1 * 3 = 3`. \\n\\nNow we can just subtract the area of the overlaping rectangle from the total area which is `64 - 3 = 61`. Now we know that our answer is **61**.\\n\\n``` go\\nfunc computeArea(A int, B int, C int, D int, E int, F int, G int, H int) int {\\n    ABCDRectangle := (D - B) * (C - A) // the first square\\n    EFGHRectangle := (H - F) * (G - E) // the second square\\n    sum := ABCDRectangle + EFGHRectangle\\n\\n    left, right := max(A, E), min(G, C)\\n    up, down := min(D, H), max(F, B)\\n\\n    if right > left && up > down {\\n        sum -= (right - left) * (up - down) // overlap\\n    }\\n    return sum\\n}\\n\\nfunc max(a, b int) int {\\n    if a < b {return b}\\n    return a\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {return a}\\n    return b\\n}\\n```\\n\\n**If You Like Please Up Vote**",
                "solutionTags": [
                    "Go"
                ],
                "code": "``` go\\nfunc computeArea(A int, B int, C int, D int, E int, F int, G int, H int) int {\\n    ABCDRectangle := (D - B) * (C - A) // the first square\\n    EFGHRectangle := (H - F) * (G - E) // the second square\\n    sum := ABCDRectangle + EFGHRectangle\\n\\n    left, right := max(A, E), min(G, C)\\n    up, down := min(D, H), max(F, B)\\n\\n    if right > left && up > down {\\n        sum -= (right - left) * (up - down) // overlap\\n    }\\n    return sum\\n}\\n\\nfunc max(a, b int) int {\\n    if a < b {return b}\\n    return a\\n}\\n\\nfunc min(a, b int) int {\\n    if a < b {return a}\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1005224,
                "title": "clean-java-solution-with-only-2-if-statements",
                "content": "```\\nclass Solution {\\n    public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        final int rect1Area = (C - A) * (D - B);\\n        final int rect2Area = (G - E) * (H - F); \\n        final int xUnion;\\n        if (E > C || A > G) {\\n            xUnion = 0;\\n        } else {\\n            xUnion = Math.min(G, C) - Math.max(A, E);\\n        } \\n        final int yUnion;\\n        if (F > D || B > H) {\\n            yUnion = 0;\\n        } else {\\n            yUnion = Math.min(D, H) - Math.max(F, B);\\n        }         \\n        return rect1Area + rect2Area - xUnion * yUnion;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        final int rect1Area = (C - A) * (D - B);\\n        final int rect2Area = (G - E) * (H - F); \\n        final int xUnion;\\n        if (E > C || A > G) {\\n            xUnion = 0;\\n        } else {\\n            xUnion = Math.min(G, C) - Math.max(A, E);\\n        } \\n        final int yUnion;\\n        if (F > D || B > H) {\\n            yUnion = 0;\\n        } else {\\n            yUnion = Math.min(D, H) - Math.max(F, B);\\n        }         \\n        return rect1Area + rect2Area - xUnion * yUnion;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 213727,
                "title": "python-solution",
                "content": "Time complexity: `O(1)`, space complexity: `O(1)`.\\n\\n```\\nclass Solution:\\n    def computeArea(self, A, B, C, D, E, F, G, H):\\n        \"\"\"\\n        :type A: int\\n        :type B: int\\n        :type C: int\\n        :type D: int\\n        :type E: int\\n        :type F: int\\n        :type G: int\\n        :type H: int\\n        :rtype: int\\n        \"\"\"\\n        width = min(C,G) - max(A,E) \\n        height = min(D,H) - max(B,F)\\n        overlap = 0 if width <= 0 or height <= 0 else width*height\\n        return (C-A)*(D-B) + (G-E)*(H-F) - overlap\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def computeArea(self, A, B, C, D, E, F, G, H):\\n        \"\"\"\\n        :type A: int\\n        :type B: int\\n        :type C: int\\n        :type D: int\\n        :type E: int\\n        :type F: int\\n        :type G: int\\n        :type H: int\\n        :rtype: int\\n        \"\"\"\\n        width = min(C,G) - max(A,E) \\n        height = min(D,H) - max(B,F)\\n        overlap = 0 if width <= 0 or height <= 0 else width*height\\n        return (C-A)*(D-B) + (G-E)*(H-F) - overlap\\n```",
                "codeTag": "Java"
            },
            {
                "id": 194542,
                "title": "an-easy-and-interesting-scanning-view-of-this-problem-java-solution",
                "content": "I realize an interesting fact that, if we scan the x-coordinates from left to right, and scan the y-coordinate from bottom to up, the overlapped area (if exists) must be composed of the 2nd smallest (x,y) and the 3rd smallest (x,y). Intuitively, the overlapped region must be \"contained\" in the 1st and 4th smallest coordinates. Just as the picture shows:\\n\\n![image](https://assets.leetcode.com/users/zhiying_qian/image_1542429751.png)\\n\\nThus, we can sort the coordinates and find the 2nd and 3rd (x,y) combinations. Then we can calculate the overlapped area and solve the problem.\\n\\n```\\nclass Solution {\\n    public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        // case: C <= E or A >= G or D <= F or B >= H, there weill be no overlap\\n        int totalArea = (D - B) * (C - A) + (H - F) * (G - E);\\n        if (C <= E || A >= G || D <= F || B >= H) return totalArea;\\n        \\n        // if there is overlap, calculate the area\\n        int[] xs = {A, C, E, G};\\n        int[] ys = {B, D, F, H};\\n        Arrays.sort(xs);\\n        Arrays.sort(ys);\\n        return totalArea - (ys[2] - ys[1]) * (xs[2] - xs[1]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        // case: C <= E or A >= G or D <= F or B >= H, there weill be no overlap\\n        int totalArea = (D - B) * (C - A) + (H - F) * (G - E);\\n        if (C <= E || A >= G || D <= F || B >= H) return totalArea;\\n        \\n        // if there is overlap, calculate the area\\n        int[] xs = {A, C, E, G};\\n        int[] ys = {B, D, F, H};\\n        Arrays.sort(xs);\\n        Arrays.sort(ys);\\n        return totalArea - (ys[2] - ys[1]) * (xs[2] - xs[1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 62183,
                "title": "a-java-sweep-line-solution-could-be-generalized-to-solve-k-rectangles-union-problem",
                "content": "Though this solution seems to be an overkill to this problem, it could be generalized to solve k rectangles union area problem. Just need to initialize 'events' properly. \\nan useful reference: \\nhttps://www.topcoder.com/community/data-science/data-science-tutorials/line-sweep-algorithms/\\n```\\npublic class Solution {\\n    class Pair{\\n        int x;\\n        int y;\\n        public Pair(int x, int y){\\n            this.x = x;\\n            this.y = y;\\n        }\\n        \\n        public boolean equals(Object o){\\n            if(o instanceof Pair){\\n                Pair p = (Pair) o;\\n                return this.x == p.x && this.y == p.y; \\n            } \\n            return false;\\n        }\\n        \\n        public int hashCode(){\\n            return new Integer(x).hashCode() +new Integer(y).hashCode();\\n        }\\n    }\\n\\n    public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        List<int[]> events = new ArrayList<>(4);\\n        events.add(new int[]{A, A, B, C, D});\\n        events.add(new int[]{C, A, B, C, D});\\n        events.add(new int[]{E, E, F, G, H});\\n        events.add(new int[]{G, E, F, G, H});\\n        Collections.sort(events, new Comparator<int[]>(){\\n            public int compare(int[] i1, int[] i2){\\n                if(i1[0] == i2[0]){\\n                    return i1[1]-i2[1];\\n                }\\n                return i1[0]-i2[0];\\n            }\\n        });\\n        int area = 0, prev = events.get(0)[0], index = 0;\\n        Map<Pair, Integer> map = new HashMap<Pair, Integer>();\\n        while(index < events.size()){\\n            int time = events.get(index)[0];\\n            area = area + (time-prev)*computeLength(map);\\n            prev = time;\\n            while(index < events.size() && events.get(index)[0] == time){\\n                Pair interval = new Pair(events.get(index)[2], events.get(index)[4]);\\n                if(events.get(index)[0] == events.get(index)[1]){\\n                    map.put(interval, map.getOrDefault(interval, 0)+1);\\n                } else if(events.get(index)[0] == events.get(index)[3]){\\n                    if(map.get(interval) == 1){\\n                        map.remove(interval);    \\n                    }else{\\n                        map.put(interval, map.get(interval)-1);\\n                    }\\n                }\\n                index++;\\n            }\\n        }\\n        return area;\\n    }\\n    \\n    private int computeLength(Map<Pair, Integer> map){\\n        if(map.isEmpty()) return 0;\\n        List<int[]> intervals = new ArrayList<>();\\n        for(Pair entry : map.keySet()){\\n            for(int i=0; i<map.get(entry); i++){\\n                intervals.add(new int[]{entry.x, entry.y});\\n            }\\n        }\\n        Collections.sort(intervals, new Comparator<int[]>(){\\n            public int compare(int[] i1, int[] i2){\\n                if(i1[0] == i2[0]){\\n                    return i1[1]-i2[1];\\n                }\\n                return i1[0]-i2[0];\\n            }\\n        });\\n        int length = intervals.get(0)[1] - intervals.get(0)[0], prev = intervals.get(0)[1];\\n        for(int i=1; i<intervals.size(); i++){\\n            if(intervals.get(i)[0] <= prev){\\n                if(intervals.get(i)[1] > prev){\\n                    length = length + intervals.get(i)[1]-prev;\\n                    prev = intervals.get(i)[1];\\n                }\\n            }else{\\n                length = length + intervals.get(i)[1] - intervals.get(i)[0];\\n                prev = intervals.get(i)[1];\\n            }\\n        }\\n        return length;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    class Pair{\\n        int x;\\n        int y;\\n        public Pair(int x, int y){\\n            this.x = x;\\n            this.y = y;\\n        }\\n        \\n        public boolean equals(Object o){\\n            if(o instanceof Pair){\\n                Pair p = (Pair) o;\\n                return this.x == p.x && this.y == p.y; \\n            } \\n            return false;\\n        }\\n        \\n        public int hashCode(){\\n            return new Integer(x).hashCode() +new Integer(y).hashCode();\\n        }\\n    }\\n\\n    public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        List<int[]> events = new ArrayList<>(4);\\n        events.add(new int[]{A, A, B, C, D});\\n        events.add(new int[]{C, A, B, C, D});\\n        events.add(new int[]{E, E, F, G, H});\\n        events.add(new int[]{G, E, F, G, H});\\n        Collections.sort(events, new Comparator<int[]>(){\\n            public int compare(int[] i1, int[] i2){\\n                if(i1[0] == i2[0]){\\n                    return i1[1]-i2[1];\\n                }\\n                return i1[0]-i2[0];\\n            }\\n        });\\n        int area = 0, prev = events.get(0)[0], index = 0;\\n        Map<Pair, Integer> map = new HashMap<Pair, Integer>();\\n        while(index < events.size()){\\n            int time = events.get(index)[0];\\n            area = area + (time-prev)*computeLength(map);\\n            prev = time;\\n            while(index < events.size() && events.get(index)[0] == time){\\n                Pair interval = new Pair(events.get(index)[2], events.get(index)[4]);\\n                if(events.get(index)[0] == events.get(index)[1]){\\n                    map.put(interval, map.getOrDefault(interval, 0)+1);\\n                } else if(events.get(index)[0] == events.get(index)[3]){\\n                    if(map.get(interval) == 1){\\n                        map.remove(interval);    \\n                    }else{\\n                        map.put(interval, map.get(interval)-1);\\n                    }\\n                }\\n                index++;\\n            }\\n        }\\n        return area;\\n    }\\n    \\n    private int computeLength(Map<Pair, Integer> map){\\n        if(map.isEmpty()) return 0;\\n        List<int[]> intervals = new ArrayList<>();\\n        for(Pair entry : map.keySet()){\\n            for(int i=0; i<map.get(entry); i++){\\n                intervals.add(new int[]{entry.x, entry.y});\\n            }\\n        }\\n        Collections.sort(intervals, new Comparator<int[]>(){\\n            public int compare(int[] i1, int[] i2){\\n                if(i1[0] == i2[0]){\\n                    return i1[1]-i2[1];\\n                }\\n                return i1[0]-i2[0];\\n            }\\n        });\\n        int length = intervals.get(0)[1] - intervals.get(0)[0], prev = intervals.get(0)[1];\\n        for(int i=1; i<intervals.size(); i++){\\n            if(intervals.get(i)[0] <= prev){\\n                if(intervals.get(i)[1] > prev){\\n                    length = length + intervals.get(i)[1]-prev;\\n                    prev = intervals.get(i)[1];\\n                }\\n            }else{\\n                length = length + intervals.get(i)[1] - intervals.get(i)[0];\\n                prev = intervals.get(i)[1];\\n            }\\n        }\\n        return length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 62195,
                "title": "one-step-math-in-java",
                "content": "```\\npublic class Solution {\\n    public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        int areaA = (D - B) * (C - A);\\n        int areaB = (H - F) * (G - E);\\n        int lowerTop = Math.min(D, H);\\n        int upperBot = Math.max(B, F);\\n        int lefterRight = Math.min(C, G);\\n        int righterLeft = Math.max(A, E);\\n        int overlap = 0;\\n        if (lowerTop > upperBot && lefterRight > righterLeft) {\\n            overlap = (lowerTop - upperBot) * (lefterRight - righterLeft);\\n        }\\n        return areaA + areaB - overlap;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        int areaA = (D - B) * (C - A);\\n        int areaB = (H - F) * (G - E);\\n        int lowerTop = Math.min(D, H);\\n        int upperBot = Math.max(B, F);\\n        int lefterRight = Math.min(C, G);\\n        int righterLeft = Math.max(A, E);\\n        int overlap = 0;\\n        if (lowerTop > upperBot && lefterRight > righterLeft) {\\n            overlap = (lowerTop - upperBot) * (lefterRight - righterLeft);\\n        }\\n        return areaA + areaB - overlap;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 62268,
                "title": "my-simple-c-code",
                "content": "class Solution {\\npublic:\\n    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        \\n        int area1 = (C-A)*(D-B);\\n        int area2 = (G-E)*(H-F);\\n        if(C<=E || G<=A || D<=F ||B>=H){\\n            return area1+area2;\\n        }\\n        int width =  (A<=E)?min(C-E,G-E):min(C-A,G-A);\\n        int height = (B>=F)?min(D-B,H-B):min(D-F,H-F);\\n        return area1+area2-width*height;\\n       \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        \\n        int area1 = (C-A)*(D-B);\\n        int area2 = (G-E)*(H-F);\\n        if(C<=E || G<=A || D<=F ||B>=H){\\n            return area1+area2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 62278,
                "title": "easy-understanding-c-c-solution",
                "content": "\\n\\n    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n    \\tint areaA = (C - A)*(D - B);\\n    \\tint areaB = (G - E)*(H - F);\\n    \\tint total = areaA + areaB;\\n\\n        //if no intersection, then just return total area\\n    \\tif (C <= E || A >= G || D <= F || B >= H)\\n    \\t\\treturn total;\\n        //else get the coordinate of intersection at (bottom,left) (top, right) \\n    \\t// (max(a,e), max(f,b)) (min(c,g), min(h,d))\\n    \\tint interCection = (min(C, G) - max(A, E))*(min(H, D) - max(F, B));\\n    \\treturn (total - interCection);\\n    }",
                "solutionTags": [],
                "code": "\\n\\n    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n    \\tint areaA = (C - A)*(D - B);\\n    \\tint areaB = (G - E)*(H - F);\\n    \\tint total = areaA + areaB;\\n\\n        //if no intersection, then just return total area\\n    \\tif (C <= E || A >= G || D <= F || B >= H)\\n    \\t\\treturn total;\\n        //else get the coordinate of intersection at (bottom,left) (top, right) \\n    \\t// (max(a,e), max(f,b)) (min(c,g), min(h,d))\\n    \\tint interCection = (min(C, G) - max(A, E))*(min(H, D) - max(F, B));\\n    \\treturn (total - interCection);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 62287,
                "title": "my-very-pythonic-solution-120ms-though",
                "content": "    def computeArea(self, A, B, C, D, E, F, G, H):\\n        area1 = abs(C-A)*abs(D-B)\\n        area2 = abs(G-E)*abs(H-F)\\n\\t\\t\\n\\t\\t# Find the overlapping area\\n        height = min(D, H) - max(B, F)\\n        width =  min(C, G) - max(A, E)\\n        return area1 + area2 - (height>0 and width>0)*height*width",
                "solutionTags": [],
                "code": "    def computeArea(self, A, B, C, D, E, F, G, H):\\n        area1 = abs(C-A)*abs(D-B)\\n        area2 = abs(G-E)*abs(H-F)\\n\\t\\t\\n\\t\\t# Find the overlapping area\\n        height = min(D, H) - max(B, F)\\n        width =  min(C, G) - max(A, E)\\n        return area1 + area2 - (height>0 and width>0)*height*width",
                "codeTag": "Python3"
            },
            {
                "id": 3570925,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        int tot=(by2-by1)*(bx2-bx1) + (ay2-ay1)*(ax2-ax1);\\n        \\n        int[] iY=findIntersection(new int[]{ay1,ay2},new int[]{by1,by2});\\n        int[] iX=findIntersection(new int[]{ax1,ax2},new int[]{bx1,bx2});\\n        \\n        int common;\\n        \\n        if(iX==null || iY==null){\\n            common=0;\\n        }else{\\n            common=(iY[1]-iY[0])*(iX[1]-iX[0]);\\n        }\\n        \\n        return tot-common;\\n    }\\n    \\n    private int[] findIntersection(int[] a,int[] b){\\n        if(a[0]>b[0]){\\n            return findIntersection(b,a);\\n        }\\n        \\n        if(a[1]<b[0]){\\n            return null;\\n        }\\n        \\n        return new int[]{Math.max(a[0],b[0]),Math.min(a[1],b[1])};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        int tot=(by2-by1)*(bx2-bx1) + (ay2-ay1)*(ax2-ax1);\\n        \\n        int[] iY=findIntersection(new int[]{ay1,ay2},new int[]{by1,by2});\\n        int[] iX=findIntersection(new int[]{ax1,ax2},new int[]{bx1,bx2});\\n        \\n        int common;\\n        \\n        if(iX==null || iY==null){\\n            common=0;\\n        }else{\\n            common=(iY[1]-iY[0])*(iX[1]-iX[0]);\\n        }\\n        \\n        return tot-common;\\n    }\\n    \\n    private int[] findIntersection(int[] a,int[] b){\\n        if(a[0]>b[0]){\\n            return findIntersection(b,a);\\n        }\\n        \\n        if(a[1]<b[0]){\\n            return null;\\n        }\\n        \\n        return new int[]{Math.max(a[0],b[0]),Math.min(a[1],b[1])};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518700,
                "title": "java-solution-for-rectangle-area-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo calculate the combined area of two rectangles, we need to consider the non-overlapping areas of the rectangles. If there is an overlap between the rectangles, we subtract the overlapping area to avoid double-counting.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. If the two rectangles do not overlap along the x-axis (ax2 < bx1 or bx2 < ax1) or the y-axis (ay2 < by1 or by2 < ay1), then the rectangles are disjoint and we can calculate the combined area by adding the individual areas of the rectangles: (bx2 - bx1) * (by2 - by1) + (ax2 - ax1) * (ay2 - ay1).\\n2. If there is an overlap between the rectangles, we calculate the overlapping area:\\n- Find the rightmost x-coordinate of the overlapping region as the minimum of ax2 and bx2.\\n- Find the leftmost x-coordinate of the overlapping region as the maximum of ax1 and bx1.\\n- Find the topmost y-coordinate of the overlapping region as the minimum of by2 and ay2.\\n- Find the bottommost y-coordinate of the overlapping region as the maximum of by1 and ay1.\\n- Calculate the overlapping area as (right - left) * (top - bottom).\\n3. Subtract the overlapping area from the combined area of the rectangles: (bx2 - bx1) * (by2 - by1) + (ax2 - ax1) * (ay2 - ay1) - (right - left) * (top - bottom).\\n4. Return the combined area.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe code has a constant number of operations, so the time complexity is O(1).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the code is O(1) as it does not use any additional data structures that grow with the input size.\\n\\n# Code\\n```\\nclass Solution {\\n    public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        if(ax2<bx1||bx2<ax1 )\\n            return (bx2-bx1)*(by2-by1) + (ax2-ax1)*(ay2-ay1);\\n        if(ay2<by1 || by2<ay1)\\n            return (bx2-bx1)*(by2-by1) + (ax2-ax1)*(ay2-ay1);\\n        int right = Math.min(ax2,bx2);\\n        int left = Math.max(ax1,bx1);\\n        int top = Math.min(by2,ay2);\\n        int bottom = Math.max(by1,ay1);\\n        return (bx2-bx1)*(by2-by1) + (ax2-ax1)*(ay2-ay1) - (right-left)*(top-bottom);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        if(ax2<bx1||bx2<ax1 )\\n            return (bx2-bx1)*(by2-by1) + (ax2-ax1)*(ay2-ay1);\\n        if(ay2<by1 || by2<ay1)\\n            return (bx2-bx1)*(by2-by1) + (ax2-ax1)*(ay2-ay1);\\n        int right = Math.min(ax2,bx2);\\n        int left = Math.max(ax1,bx1);\\n        int top = Math.min(by2,ay2);\\n        int bottom = Math.max(by1,ay1);\\n        return (bx2-bx1)*(by2-by1) + (ax2-ax1)*(ay2-ay1) - (right-left)*(top-bottom);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3399424,
                "title": "java-solution-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSolution computes the area of two axis-aligned rectangles while taking into account the overlap between them. The approach first checks if the rectangles overlap by comparing their coordinates, and if they do, it calculates the overlap area and subtracts it from the total area of the two rectangles. The **isOverlap()** method returns a boolean indicating whether the rectangles overlap or not, while the **computeArea()** method computes the areas of the rectangles and the overlap area.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        // Step 1: Calculate width and height of rectangles\\n        int width1 = ax2 - ax1;\\n        int height1 = ay2 - ay1;\\n        int width2 = bx2 - bx1;\\n        int height2 = by2 - by1;\\n\\n        // Step 2: Calculate area of rectangles\\n        int area1 = width1 * height1;\\n        int area2 = width2 * height2;\\n\\n        // NOTE: we need to remove overlapped area\\n        int intersectionArea = 0;\\n\\n        if (isOverlap(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2)) {\\n            // Find bottom-left corner of the intersection\\n            int x1 = Math.max(ax1, bx1);\\n            int y1 = Math.max(ay1, by1);\\n\\n            // Find top-right corner of the intersection\\n            int x2 = Math.min(ax2, bx2);\\n            int y2 = Math.min(ay2, by2);\\n\\n            // Calculate interaction area\\n            intersectionArea = (x2 - x1) * (y2 - y1);\\n        }\\n\\n        return area1 + area2 - intersectionArea;\\n    }\\n\\n    public boolean isOverlap(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        // Check if rectangles do not overlapped\\n        if(ax1 >= bx2 || bx1 >= ax2 || ay1 >= by2 || by1 >= ay2) {\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        // Step 1: Calculate width and height of rectangles\\n        int width1 = ax2 - ax1;\\n        int height1 = ay2 - ay1;\\n        int width2 = bx2 - bx1;\\n        int height2 = by2 - by1;\\n\\n        // Step 2: Calculate area of rectangles\\n        int area1 = width1 * height1;\\n        int area2 = width2 * height2;\\n\\n        // NOTE: we need to remove overlapped area\\n        int intersectionArea = 0;\\n\\n        if (isOverlap(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2)) {\\n            // Find bottom-left corner of the intersection\\n            int x1 = Math.max(ax1, bx1);\\n            int y1 = Math.max(ay1, by1);\\n\\n            // Find top-right corner of the intersection\\n            int x2 = Math.min(ax2, bx2);\\n            int y2 = Math.min(ay2, by2);\\n\\n            // Calculate interaction area\\n            intersectionArea = (x2 - x1) * (y2 - y1);\\n        }\\n\\n        return area1 + area2 - intersectionArea;\\n    }\\n\\n    public boolean isOverlap(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        // Check if rectangles do not overlapped\\n        if(ax1 >= bx2 || bx1 >= ax2 || ay1 >= by2 || by1 >= ay2) {\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2837259,
                "title": "c-easy-to-understand-maths-based-o-n",
                "content": "\\n\\n# CPP Code\\n```\\nclass Solution {\\npublic:\\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        \\n        int areaOfA = (ay2 - ay1) * (ax2 - ax1);\\n        int areaOfB = (by2 - by1) * (bx2 - bx1);\\n\\n        int xOverlap = min(ax2, bx2) - max(ax1, bx1);\\n\\n        int yOverlap = min(ay2, by2) - max(ay1, by1);\\n\\n        int areaOfOverlap = 0;\\n        \\n        if (xOverlap > 0 && yOverlap > 0) {\\n            areaOfOverlap = xOverlap * yOverlap;\\n        }\\n        \\n        int totalArea = areaOfA + areaOfB - areaOfOverlap;\\n\\n        return totalArea;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        \\n        int areaOfA = (ay2 - ay1) * (ax2 - ax1);\\n        int areaOfB = (by2 - by1) * (bx2 - bx1);\\n\\n        int xOverlap = min(ax2, bx2) - max(ax1, bx1);\\n\\n        int yOverlap = min(ay2, by2) - max(ay1, by1);\\n\\n        int areaOfOverlap = 0;\\n        \\n        if (xOverlap > 0 && yOverlap > 0) {\\n            areaOfOverlap = xOverlap * yOverlap;\\n        }\\n        \\n        int totalArea = areaOfA + areaOfB - areaOfOverlap;\\n\\n        return totalArea;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2824303,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        int A1 = 0 , A2 = 0 , CA=0;\\n        A1 = (ax2-ax1)*(ay2-ay1);\\n        A2 = (bx2-bx1)*(by2-by1);\\n        if(ax2<bx1 || bx2<ax1 || by2<ay1 || ay2<by1){\\n            return A1+A2;\\n        }\\n        else {\\n            int cl = min(bx2 , ax2) - max(bx1,ax1);\\n            int cb = min(ay2 , by2) - max(by1,ay1);\\n            CA = cl*cb;\\n        }\\n        return A1+A2-CA;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        int A1 = 0 , A2 = 0 , CA=0;\\n        A1 = (ax2-ax1)*(ay2-ay1);\\n        A2 = (bx2-bx1)*(by2-by1);\\n        if(ax2<bx1 || bx2<ax1 || by2<ay1 || ay2<by1){\\n            return A1+A2;\\n        }\\n        else {\\n            int cl = min(bx2 , ax2) - max(bx1,ax1);\\n            int cb = min(ay2 , by2) - max(by1,ay1);\\n            CA = cl*cb;\\n        }\\n        return A1+A2-CA;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2823710,
                "title": "c-easy-detailed-answer-and-explanations-in-o-1",
                "content": "Answer:----\\n\\nThere can be two cases for this problem - \\n1. When two rectangle doesn\\u2019t overlap, then the total area will be the sum of two rectangles. \\n2. When two rectangle overlap, the total area will be the sum of two rectangles minus the overlapped area. \\nThis is the simple solution to the problem :\\n\\nclass Solution {\\npublic:\\nint computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n    int total_area = (ax2 - ax1) * (ay2 - ay1) + (bx2 - bx1) * (by2 - by1);\\n    if (ax2 <= bx1 || ay1 >= by2 || ax1 >= bx2 || ay2<= by1) {\\n        return total_area;  //for 1st case\\n    }\\n    //for 2nd case\\n    int c1 = min(ax2, bx2) - max(ax1, bx1);\\n    int c2 = min(ay2, by2) - max(ay1, by1);\\n    int overlap_area = c1 * c2;\\n    return total_area - overlap_area;\\n    \\n}\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\nint computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n    int total_area = (ax2 - ax1) * (ay2 - ay1) + (bx2 - bx1) * (by2 - by1);\\n    if (ax2 <= bx1 || ay1 >= by2 || ax1 >= bx2 || ay2<= by1) {\\n        return total_area;  //for 1st case\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2823606,
                "title": "daily-leetcode-soln-easy-c-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``````\\nCode block\\nclass Solution {\\npublic:\\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        \\n       \\n                 int a1=abs(ax2-ax1) * abs(ay2-ay1);\\n                 int a2=abs(bx2-bx1) * abs(by2-by1);\\n                 int p=min(ax2,bx2);\\n                 int q=max(ax1,bx1);\\n                 int r= min(ay2,by2);\\n                 int s=max(ay1,by1);\\n                 int inter=(p-q)*(r-s);\\n                cout<<a1<<\" \"<<a2<<\" \"<<inter<<endl;\\n            if((bx1)>(ax2)||(by1)>(ay2)||(bx2)<(ax1)||(by2)<(ay1))\\n\\n            {   \\n                return a1+a2;\\n            }\\n            else\\n            {\\n            return a1+a2-inter;\\n            }\\n            \\n\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "``````",
                "codeTag": "Unknown"
            },
            {
                "id": 2823459,
                "title": "c-o-1-finding-common-area",
                "content": "# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int area(int l, int h){\\n        return l*h;\\n    }\\n\\n    int common(int x1_st, int x1_end, int x2_st, int x2_end){\\n        if((x1_st < x2_st && x1_end < x2_st) || (x2_st < x1_st && x2_end < x1_st)) return INT_MAX;\\n        else{\\n            int ansst = max(x1_st, x2_st);\\n            int ansend = min(x1_end, x2_end);\\n            return ansend;\\n        }\\n    }\\n    int common2(int x1_st, int x1_end, int x2_st, int x2_end){\\n        if((x1_st < x2_st && x1_end < x2_st) || (x2_st < x1_st && x2_end < x1_st)) return INT_MAX;\\n        else{\\n            int ansst = max(x1_st, x2_st);\\n            int ansend = min(x1_end, x2_end);\\n            return ansst;\\n        }\\n    }\\n\\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        int area1 = area(abs(ax1-ax2), abs(ay1-ay2));\\n        int area2 = area(abs(bx1-bx2), abs(by1-by2));\\n        // cout<<\"area1 : \"<<area1<<\"  area2 : \"<<area2<<endl;\\n\\n        int a2x = common(ax1, ax2, bx1, bx2), a2y = common(ay1, ay2, by1, by2);\\n        int a1x = common2(ax1, ax2, bx1, bx2), a1y = common2(ay1, ay2, by1, by2);\\n        int area3 = 0;\\n        // cout<<a1x<<\" \"<<a1y<<\" \"<<a2x<<\" \"<<a2y<<endl;\\n        if(a2x != INT_MAX && a2y != INT_MAX && a1x != INT_MAX && a1y != INT_MAX){\\n            area3 = area(abs(a1x-a2x), abs(a1y-a2y));\\n            // cout<<\"area 3 : \"<<area3<<endl;\\n        }\\n\\n        return (area1 + area2 - area3);\\n    }\\n\\n// -2\\n// -2\\n// 2\\n// 2\\n// -4\\n// -4\\n// -3\\n// -3\\n\\n\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int area(int l, int h){\\n        return l*h;\\n    }\\n\\n    int common(int x1_st, int x1_end, int x2_st, int x2_end){\\n        if((x1_st < x2_st && x1_end < x2_st) || (x2_st < x1_st && x2_end < x1_st)) return INT_MAX;\\n        else{\\n            int ansst = max(x1_st, x2_st);\\n            int ansend = min(x1_end, x2_end);\\n            return ansend;\\n        }\\n    }\\n    int common2(int x1_st, int x1_end, int x2_st, int x2_end){\\n        if((x1_st < x2_st && x1_end < x2_st) || (x2_st < x1_st && x2_end < x1_st)) return INT_MAX;\\n        else{\\n            int ansst = max(x1_st, x2_st);\\n            int ansend = min(x1_end, x2_end);\\n            return ansst;\\n        }\\n    }\\n\\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        int area1 = area(abs(ax1-ax2), abs(ay1-ay2));\\n        int area2 = area(abs(bx1-bx2), abs(by1-by2));\\n        // cout<<\"area1 : \"<<area1<<\"  area2 : \"<<area2<<endl;\\n\\n        int a2x = common(ax1, ax2, bx1, bx2), a2y = common(ay1, ay2, by1, by2);\\n        int a1x = common2(ax1, ax2, bx1, bx2), a1y = common2(ay1, ay2, by1, by2);\\n        int area3 = 0;\\n        // cout<<a1x<<\" \"<<a1y<<\" \"<<a2x<<\" \"<<a2y<<endl;\\n        if(a2x != INT_MAX && a2y != INT_MAX && a1x != INT_MAX && a1y != INT_MAX){\\n            area3 = area(abs(a1x-a2x), abs(a1y-a2y));\\n            // cout<<\"area 3 : \"<<area3<<endl;\\n        }\\n\\n        return (area1 + area2 - area3);\\n    }\\n\\n// -2\\n// -2\\n// 2\\n// 2\\n// -4\\n// -4\\n// -3\\n// -3\\n\\n\\n\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2823394,
                "title": "c-brute-force-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n\\t\\t\\tint a1=(ax2-ax1)*(ay2-ay1), a2=(bx2-bx1)*(by2-by1);\\n\\t\\t\\tif(ax1>=bx2 || ax2<=bx1 || ay1>=by2 || ay2<=by1){return a1+a2;}\\n\\t\\t\\tvector<int>v, v1;\\n\\t\\t\\tv.push_back(ax1); v.push_back(ax2); v.push_back(bx1); v.push_back(bx2);\\n\\t\\t\\tsort(v.begin(), v.end());\\n\\t\\t\\tv1.push_back(ay1); v1.push_back(ay2); v1.push_back(by1); v1.push_back(by2);\\n\\t\\t\\tsort(v1.begin(), v1.end());\\n\\t\\t\\treturn a1+a2-(v[2]-v[1])*(v1[2]-v1[1]);\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n\\t\\t\\tint a1=(ax2-ax1)*(ay2-ay1), a2=(bx2-bx1)*(by2-by1);\\n\\t\\t\\tif(ax1>=bx2 || ax2<=bx1 || ay1>=by2 || ay2<=by1){return a1+a2;}",
                "codeTag": "Java"
            },
            {
                "id": 2822909,
                "title": "java-runtime-2-ms-faster-than-100-00-of-java-online-submissions",
                "content": "\\uD83D\\uDC69  If you like this solution, please click UpVote button. If you have any question, feel free write as a comment. Thanks \\uD83D\\uDE0A\\n\\n```\\nclass Solution {\\n    public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        int totalArea = (ax2 - ax1) * (ay2 - ay1) + (bx2 - bx1) * (by2 - by1);\\n        if (ax2 <= bx1 || ay1 >= by2 || ax1 >= bx2 || ay2<= by1) {\\n            return totalArea;\\n        }\\n        int num1 = Math.min(ax2, bx2) - Math.max(ax1, bx1);\\n        int num2 = Math.min(ay2, by2) - Math.max(ay1, by1);\\n        int dupValue = num1 * num2;\\n        return totalArea - dupValue;\\n    }\\n}",
                "solutionTags": [
                    "Math"
                ],
                "code": "class Solution {\\n    public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        int totalArea = (ax2 - ax1) * (ay2 - ay1) + (bx2 - bx1) * (by2 - by1);\\n        if (ax2 <= bx1 || ay1 >= by2 || ax1 >= bx2 || ay2<= by1) {\\n            return totalArea;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2822862,
                "title": "very-easy-c-solution",
                "content": "```\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        int area1 = (ax2 - ax1) * (ay2 - ay1);\\n        int area2 = (bx2 - bx1) * (by2 - by1);\\n        int overlap = 0;\\n        if (ax1 < bx2 && ax2 > bx1 && ay1 < by2 && ay2 > by1) {\\n            int x1 = max(ax1, bx1);\\n            int y1 = max(ay1, by1);\\n            int x2 = min(ax2, bx2);\\n            int y2 = min(ay2, by2);\\n            overlap = (x2 - x1) * (y2 - y1);\\n        }\\n        return area1 + area2 - overlap;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        int area1 = (ax2 - ax1) * (ay2 - ay1);\\n        int area2 = (bx2 - bx1) * (by2 - by1);\\n        int overlap = 0;\\n        if (ax1 < bx2 && ax2 > bx1 && ay1 < by2 && ay2 > by1) {\\n            int x1 = max(ax1, bx1);\\n            int y1 = max(ay1, by1);\\n            int x2 = min(ax2, bx2);\\n            int y2 = min(ay2, by2);\\n            overlap = (x2 - x1) * (y2 - y1);\\n        }\\n        return area1 + area2 - overlap;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2822547,
                "title": "generic-solution-thought-process-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntution - Imagine a 1 dimensional space(Line) where there are four co ordinates a1,a2,b1,b2 . Determine the positions of intersections. There are four cases possible \\n      \\na) if b1 in between a1 and a2 , b2>a2 . Then intersection is b1,a2 \\n    **a1----*b1*----a2---*b2***\\n\\nb) if b2 in between a1 and a2, b1<a1 . Then intersection is a1,b2\\n    ***b1*---a1--*-b2*---a2**\\n\\nc) if b1 and b2 in between a1 and a2 . Then intersection is b1,b2\\n    **a1---*b1---b2*---a2** \\n\\nd) if b1<a1 and b2>a2 then intersection is a1,a2. Do this for both X and Y co ords to get bottom left and top right of the intersection rectangle.\\n    ***b1*---a1---a2---*b2***\\n\\n\\nAll the other cases are not intersections and can be avoided. \\n\\n\\n# Code\\n```\\nclass Solution:\\n    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:\\n        \\n        def sendpotentialcoordinates(a1,a2,b1,b2):\\n            if b1>=a1 and b1<a2:\\n                if b2>=a2:\\n                    return (b1,a2) #a case\\n                else:\\n                    return (b1,b2) #c case\\n            if b1<a1 and b2>a1:\\n                if b2>=a2:\\n                    return (a1,a2) #d case\\n                else:\\n                    return (a1,b2) #b case\\n            return (None,None) #All other cases\\n        \\n        x1,x2=sendpotentialcoordinates(ax1,ax2,bx1,bx2)\\n        y1,y2=sendpotentialcoordinates(ay1,ay2,by1,by2)\\n        # print(x1,x2,y1,y2)\\n        if x1!=None and y1!=None:\\n\\n            return  (abs(ax1-ax2)*abs(ay1-ay2))+(abs(bx1-bx2)*abs(by1-by2))-((abs(x1-x2)*abs(y1-y2)))\\n        else:\\n            return (abs(ax1-ax2)*abs(ay1-ay2))+(abs(bx1-bx2)*abs(by1-by2))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:\\n        \\n        def sendpotentialcoordinates(a1,a2,b1,b2):\\n            if b1>=a1 and b1<a2:\\n                if b2>=a2:\\n                    return (b1,a2) #a case\\n                else:\\n                    return (b1,b2) #c case\\n            if b1<a1 and b2>a1:\\n                if b2>=a2:\\n                    return (a1,a2) #d case\\n                else:\\n                    return (a1,b2) #b case\\n            return (None,None) #All other cases\\n        \\n        x1,x2=sendpotentialcoordinates(ax1,ax2,bx1,bx2)\\n        y1,y2=sendpotentialcoordinates(ay1,ay2,by1,by2)\\n        # print(x1,x2,y1,y2)\\n        if x1!=None and y1!=None:\\n\\n            return  (abs(ax1-ax2)*abs(ay1-ay2))+(abs(bx1-bx2)*abs(by1-by2))-((abs(x1-x2)*abs(y1-y2)))\\n        else:\\n            return (abs(ax1-ax2)*abs(ay1-ay2))+(abs(bx1-bx2)*abs(by1-by2))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2822342,
                "title": "most-easy-and-intuitive-solution-in-c-explained-beginner-friendly",
                "content": "**Please Upvote if you like the Solution**\\n\\n1. Finding the area of both rectangle as \\'a\\' and \\'b\\'\\n2. Checking if two rectange have overlaping or not. if not returning the sum of area of both rectangle\\n3. If there is overlaping then Finding the area of overlap rectangle and subtacting it from sum of area of both rectangle\\n\\n\\nclass Solution {\\npublic:\\n\\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        int a = (ax2 - ax1) * (ay2 - ay1);     \\n        int b = (bx2 - bx1) * (by2 - by1);              \\n        \\n        if (ax1 >= bx2 || ax2 <= bx1 || ay2 <= by1 || ay1 >= by2) \\n            return a + b;                                               \\n        \\n        return a + b - (min(bx2, ax2) - max(ax1, bx1)) * (min(ay2, by2) - max(ay1, by1)); \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        int a = (ax2 - ax1) * (ay2 - ay1);     \\n        int b = (bx2 - bx1) * (by2 - by1);              \\n        \\n        if (ax1 >= bx2 || ax2 <= bx1 || ay2 <= by1 || ay1 >= by2) \\n            return a + b;                                               \\n        \\n        return a + b - (min(bx2, ax2) - max(ax1, bx1)) * (min(ay2, by2) - max(ay1, by1)); \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2382263,
                "title": "short-and-simple-solution-fully-explained",
                "content": "# **Approach**\\n\\nIn this problem, we need to check whether the two given rectangles overlap or not.\\nTo check this, we need to check whether the intervals defined by coordinates of the rectangles on X-axis and Y-axis overlap or not.\\nTo check whether the interval defined by points (x1,x2) and (x3,x4) overlap or not, we check if,\\n**max(x1,x3)<min(x2,x4)**,\\nif above is the case, then the overlapped interval is ( max(x1,x3) , min(x2,x4) ), else the two intervals defined do not overlap.\\nHere, Kindly note that (x1,x2) represent an interval on a number line and not the x coordinate and y coordinate of a point in 2D plane.\\nFor a rectangle to be formed by overlapping, the intervals enclosed by both X coordinates and Y coordinates of the two rectangles should overlap.\\nThus, to calculate the total area defined by coordinates of two rectangles will be calculated as :-\\nTotal Area:- Area(Rectangle 1) + Area(Rectangle 2) - Area(Overlapped triangle)\\nLet\\'s go through the code now...\\n```\\nclass Solution {\\npublic:\\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n\\t\\tint rec1=abs(ax2-ax1)*abs(ay2-ay1);   //Area(Rectangle 1)\\n        int rec2=abs(bx2-bx1)*abs(by2-by1);   //Area(Rectangle 2)\\n\\t\\t\\n\\t\\t/*  As explained above, if intervals overlap,\\n            max(x1,x3) < min(x2,x4) and overlapped interval is \\n            ( max(x1,x3) , min(x2,x4) ). */\\n\\t\\t\\n        int ox1=(max(ax1,bx1)-min(ax2,bx2));   //if ox1 is negative, abs(ox1) is the length of overlapped rectangle, else rectangles do not overlap.\\n        int oy1=(max(ay1,by1)-min(ay2,by2));   //breadth of overlapped rectangle\\n\\t\\t\\n\\t\\tint rec3=0;  //if rectangles do not overlap, area of overlapped rectangle is zero.\\n        if(ox1<0&&oy1<0)   //if both ox1 and oy2 are negative, two rectangles overlap. \\n            rec3=ox1*oy1;\\n        return rec1+rec2-rec3;  //Area(Rectangle 1) + Area(Rectangle 2) - Area(Overlapped triangle)   \\n    }\\n};\\n\\n```\\nKindly let me know your doubts in the comment section, if any.\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n\\t\\tint rec1=abs(ax2-ax1)*abs(ay2-ay1);   //Area(Rectangle 1)\\n        int rec2=abs(bx2-bx1)*abs(by2-by1);   //Area(Rectangle 2)\\n\\t\\t\\n\\t\\t/*  As explained above, if intervals overlap,\\n            max(x1,x3) < min(x2,x4) and overlapped interval is \\n            ( max(x1,x3) , min(x2,x4) ). */\\n\\t\\t\\n        int ox1=(max(ax1,bx1)-min(ax2,bx2));   //if ox1 is negative, abs(ox1) is the length of overlapped rectangle, else rectangles do not overlap.\\n        int oy1=(max(ay1,by1)-min(ay2,by2));   //breadth of overlapped rectangle\\n\\t\\t\\n\\t\\tint rec3=0;  //if rectangles do not overlap, area of overlapped rectangle is zero.\\n        if(ox1<0&&oy1<0)   //if both ox1 and oy2 are negative, two rectangles overlap. \\n            rec3=ox1*oy1;\\n        return rec1+rec2-rec3;  //Area(Rectangle 1) + Area(Rectangle 2) - Area(Overlapped triangle)   \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2234369,
                "title": "overlap-area",
                "content": "```c++\\nclass Solution {\\npublic:\\n    /*\\n        split them into n rectangles.\\n        \\n        In 1-d scenario: we have three cases\\n            \\n            -----------\\n              -------\\n              \\n            -------\\n               --------\\n               \\n              a1      b1\\n               --------\\n            -------\\n           a2     b2\\n        \\n        overlap length = max(0, min(b1, b2) - max(a1, a2))\\n        \\n        In 2-d scenario: solve x direction and y direction (two 1-d case)\\n    */\\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        int w = max(0, min(ax2, bx2) - max(ax1, bx1));\\n        int h = max(0, min(by2, ay2) - max(by1, ay1));\\n        \\n        return abs(ay2 - ay1) * abs(ax2 - ax1) + abs(by2 - by1) * abs(bx2 - bx1) - w * h;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    /*\\n        split them into n rectangles.\\n        \\n        In 1-d scenario: we have three cases\\n            \\n            -----------\\n              -------\\n              \\n            -------\\n               --------\\n               \\n              a1      b1\\n               --------\\n            -------\\n           a2     b2\\n        \\n        overlap length = max(0, min(b1, b2) - max(a1, a2))\\n        \\n        In 2-d scenario: solve x direction and y direction (two 1-d case)\\n    */\\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        int w = max(0, min(ax2, bx2) - max(ax1, bx1));\\n        int h = max(0, min(by2, ay2) - max(by1, ay1));\\n        \\n        return abs(ay2 - ay1) * abs(ax2 - ax1) + abs(by2 - by1) * abs(bx2 - bx1) - w * h;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2214850,
                "title": "simple-and-short-python-code",
                "content": "```\\nclass Solution:\\n    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:\\n        ans = (ay2-ay1)*(ax2-ax1)+(by2-by1)*(bx2-bx1)\\n        h = min(ay2,by2)-max(ay1,by1)\\n        w = min(bx2,ax2)-max(ax1,bx1)\\n        if h>0 and w>0:\\n            ans-=h*w\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:\\n        ans = (ay2-ay1)*(ax2-ax1)+(by2-by1)*(bx2-bx1)\\n        h = min(ay2,by2)-max(ay1,by1)\\n        w = min(bx2,ax2)-max(ax1,bx1)\\n        if h>0 and w>0:\\n            ans-=h*w\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2126135,
                "title": "java-solution-explained-with-comments",
                "content": "```\\nclass Solution {\\n    public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n            \\n        //x1 --> Bottom                     //y1 --> Left\\n        //x2 --> Top                        //y2 --> Right \\n        \\n        boolean overlap = false;\\n        \\n        \\n        // Boundaries of the overlapped rectangle\\n        int bottom = Math.max(ay1, by1);\\n        int top = Math.min (ay2, by2);\\n        int left = Math.max (ax1, bx1);;\\n        int right = Math.min (ax2, bx2);;\\n        \\n        if (top > bottom && left < right)\\n            overlap = true;\\n        \\n        \\n        \\n            //First Rectangle\\n            int l1 =  (ay2 - ay1);\\n            int b1 =  (ax2 - ax1);\\n            int a1 =  l1 * b1;\\n            \\n            //Second Rectangle\\n            int l2 = (by2 - by1);\\n            int b2 = (bx2 - bx1);\\n            int a2 = l2 * b2;\\n        \\n        if (overlap){\\n            \\n            //Overlapped area\\n            int ova = (top - bottom) * (right - left);\\n                \\n            int area = a1 + a2 - ova;\\n            \\n            return area;\\n            \\n        }\\n        \\n        return a1 + a2;\\n    \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Math",
                    "Geometry"
                ],
                "code": "```\\nclass Solution {\\n    public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n            \\n        //x1 --> Bottom                     //y1 --> Left\\n        //x2 --> Top                        //y2 --> Right \\n        \\n        boolean overlap = false;\\n        \\n        \\n        // Boundaries of the overlapped rectangle\\n        int bottom = Math.max(ay1, by1);\\n        int top = Math.min (ay2, by2);\\n        int left = Math.max (ax1, bx1);;\\n        int right = Math.min (ax2, bx2);;\\n        \\n        if (top > bottom && left < right)\\n            overlap = true;\\n        \\n        \\n        \\n            //First Rectangle\\n            int l1 =  (ay2 - ay1);\\n            int b1 =  (ax2 - ax1);\\n            int a1 =  l1 * b1;\\n            \\n            //Second Rectangle\\n            int l2 = (by2 - by1);\\n            int b2 = (bx2 - bx1);\\n            int a2 = l2 * b2;\\n        \\n        if (overlap){\\n            \\n            //Overlapped area\\n            int ova = (top - bottom) * (right - left);\\n                \\n            int area = a1 + a2 - ova;\\n            \\n            return area;\\n            \\n        }\\n        \\n        return a1 + a2;\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2081427,
                "title": "concise-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int getArea(int x1, int y1, int x2, int y2)\\n    {\\n        if(x2>=x1 && y2>=y1)\\n        {\\n            return (x2-x1)*(y2-y1);\\n        }\\n        return 0;\\n    }\\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        \\n        return getArea(ax1,ay1,ax2,ay2)+getArea(bx1,by1,bx2,by2)-getArea(max(ax1,bx1),max(ay1,by1),min(ax2,bx2),min(ay2,by2)); \\n    }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getArea(int x1, int y1, int x2, int y2)\\n    {\\n        if(x2>=x1 && y2>=y1)\\n        {\\n            return (x2-x1)*(y2-y1);\\n        }\\n        return 0;\\n    }\\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        \\n        return getArea(ax1,ay1,ax2,ay2)+getArea(bx1,by1,bx2,by2)-getArea(max(ax1,bx1),max(ay1,by1),min(ax2,bx2),min(ay2,by2)); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1894235,
                "title": "4ms-c-solution",
                "content": "**Intution:**\\n         As of simple approach we try to sum up the individual rectangle areas and subtract overlapped area as it counted twice.\\n\\t\\tWe will try to caluclate the area as given below.\\n        <img src=\"https://assets.leetcode.com/users/images/d76ca44f-94c6-4ea8-ae04-bc719e0533de_1648552797.818356.jpeg\" alt=\"drawing\" width=\"600\"/>\\n\\t\\tNow here comes the tricky part to caluclate the overlapped area.We will take the simple case of caluclating overlapping area in two rectangles as given below.It will work automatically for all cases.\\n\\t\\t<img src=\"https://assets.leetcode.com/users/images/ec4d06b6-0b6f-4af5-ae8f-1916c4fc638e_1648553454.204118.jpeg\" alt=\"drawing\" width=\"600\"/>\\n\\t\\t\\n For the above case new overlapped rectangle coordinates are like:\\n      new_x1=max(ax1,bx1);\\n\\t  new_x2=min(ax2,bx2);\\n\\t  new_y1=max(ay1,by1);\\n\\t  new_y2=min(ay2,by2);\\n \\n Since we caluclated the new area coordinates we can now caluclate the overlapped area (like above problem).\\n   **Area=(new_x2-new_x1)** * **(new_y2-new_y1)**\\n **Edge Case**:\\n       As there may be   a case when two recytangle won\\'t overlap.In that case one of the above terms will become negative in expression of area. We will handle the above case like this:\\n\\t   **Area=max((new_x2-new_x1),0)** * **max((new_y2-new_y1),0)**.\\n\\t   \\n**Code**\\n```\\n class Solution {\\n       public:\\n           int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n               long long a1=abs((long long)(ax1-ax2))*abs((long long)(ay1-ay2));\\n               long long a2=abs((long long)(bx1-bx2))*abs((long long)(by1-by2));\\n               long long ol=max(min(ax2,bx2)-max(ax1,bx1),0)*max(min(ay2,by2)-max(ay1,by1),0);\\n               return (int)(a1+a2-ol);\\n    }\\n};\\n```\\n\\n**Time Complexity:O(1)**\\n**Space Complexity:O(1)**\\n\\n",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\n class Solution {\\n       public:\\n           int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n               long long a1=abs((long long)(ax1-ax2))*abs((long long)(ay1-ay2));\\n               long long a2=abs((long long)(bx1-bx2))*abs((long long)(by1-by2));\\n               long long ol=max(min(ax2,bx2)-max(ax1,bx1),0)*max(min(ay2,by2)-max(ay1,by1),0);\\n               return (int)(a1+a2-ol);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1853569,
                "title": "python-explained",
                "content": "final_area = area1 + area2 - overlap_area\\nThe key problem is to compute the overlap rectangle area.\\nIf there is a overlap rectangle, it always holds that\\n* overlap_left_side = max(left_side1, left_side2)\\n* overlap_right_side =min(right_side1, right_side2)\\n\\n(If overlap_left_side >= overlap_right_side, there is no overlap)\\n\\nSimilarly, we have\\n* overlap_top_side = min(top_side1, top_side2)\\n* overlap_bottom_side =max(bottom_side1, bottom_side2)\\n\\n```\\nclass Solution:\\n    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:\\n        cx1, cx2, cy1, cy2 = max(ax1, bx1), min(ax2, bx2), max(ay1, by1), min(ay2, by2)\\n        return (ax2 - ax1) * (ay2 - ay1) + (bx2 - bx1) * (by2 - by1) - max(0, cx2 - cx1) * max(0, cy2 - cy1)\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:\\n        cx1, cx2, cy1, cy2 = max(ax1, bx1), min(ax2, bx2), max(ay1, by1), min(ay2, by2)\\n        return (ax2 - ax1) * (ay2 - ay1) + (bx2 - bx1) * (by2 - by1) - max(0, cx2 - cx1) * max(0, cy2 - cy1)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1631675,
                "title": "python-total-area-minus-intersection-area",
                "content": "```\\nclass Solution:\\n    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:\\n        total  = abs(ax1 - ax2) * abs(ay1 - ay2)  + abs(bx1 - bx2) * abs(by1 - by2)         \\n        x1 = max(ax1, bx1)\\n        y1 = max(ay1, by1)                \\n        x2 = min(ax2, bx2)\\n        y2 = min(ay2, by2)        \\n        if x2-x1 >= 0 and y2-y1 >= 0: total -= (x2 - x1) * (y2 - y1)            \\n        return total\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:\\n        total  = abs(ax1 - ax2) * abs(ay1 - ay2)  + abs(bx1 - bx2) * abs(by1 - by2)         \\n        x1 = max(ax1, bx1)\\n        y1 = max(ay1, by1)                \\n        x2 = min(ax2, bx2)\\n        y2 = min(ay2, by2)        \\n        if x2-x1 >= 0 and y2-y1 >= 0: total -= (x2 - x1) * (y2 - y1)            \\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1592547,
                "title": "my-disgusting-oneliner-in-kotlin",
                "content": "```\\n    fun computeArea(ax1: Int, ay1: Int, ax2: Int, ay2: Int, bx1: Int, by1: Int, bx2: Int, by2: Int) =\\n        (ax2 - ax1) * (ay2 - ay1) + (bx2 - bx1) * (by2 - by1) - maxOf(0, minOf(ax2, bx2) - maxOf(ax1, bx1)) * maxOf(0, minOf(ay2, by2) - maxOf(ay1, by1))\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n    fun computeArea(ax1: Int, ay1: Int, ax2: Int, ay2: Int, bx1: Int, by1: Int, bx2: Int, by2: Int) =\\n        (ax2 - ax1) * (ay2 - ay1) + (bx2 - bx1) * (by2 - by1) - maxOf(0, minOf(ax2, bx2) - maxOf(ax1, bx1)) * maxOf(0, minOf(ay2, by2) - maxOf(ay1, by1))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1591412,
                "title": "python3-interview-ready-implementation",
                "content": "```\\nclass Solution:\\n    \\n    def find_common(self, a1, a2, b1, b2):\\n        return min(a2, b2) - max(a1, b1)\\n    \\n    def find_area(self, x1, x2, y1, y2):\\n        return (x2-x1) * (y2-y1)\\n    \\n    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:\\n        \\n        x_common = max(0,self.find_common(ax1,ax2,bx1,bx2))\\n        y_common = max(0,self.find_common(ay1,ay2,by1,by2))\\n        area_common = x_common * y_common\\n        area_first = self.find_area(ax1,ax2,ay1,ay2)\\n        area_second = self.find_area(bx1,bx2,by1,by2)\\n        \\n        req_area = area_first + area_second - area_common\\n        return req_area\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def find_common(self, a1, a2, b1, b2):\\n        return min(a2, b2) - max(a1, b1)\\n    \\n    def find_area(self, x1, x2, y1, y2):\\n        return (x2-x1) * (y2-y1)\\n    \\n    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:\\n        \\n        x_common = max(0,self.find_common(ax1,ax2,bx1,bx2))\\n        y_common = max(0,self.find_common(ay1,ay2,by1,by2))\\n        area_common = x_common * y_common\\n        area_first = self.find_area(ax1,ax2,ay1,ay2)\\n        area_second = self.find_area(bx1,bx2,by1,by2)\\n        \\n        req_area = area_first + area_second - area_common\\n        return req_area\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1328507,
                "title": "100-java-o-1-easy-to-understand",
                "content": "Explanation:\\nDepart into several situations and analyse respectively, and we can get the regularity about the overlapped area.\\n\\n```java\\n// AC: Runtime: 2 ms, faster than 100.00% of Java online submissions for Rectangle Area.\\n// Memory Usage: 38.1 MB, less than 88.56% of Java online submissions for Rectangle Area.\\n// Depart into several situations and analyse respectively, and we can get the regularity about the overlapped area.\\n// T:O(1), S:O(1)\\n// \\nclass Solution {\\n    public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        int overlapArea, sumArea = (ay2 - ay1) * (ax2 - ax1) + (by2 - by1) * (bx2 - bx1);\\n        \\n        // no-overlapping area.\\n        if (bx1 >= ax2 || bx2 <= ax1 || by1 >= ay2 || by2 <= ay1) {\\n            overlapArea = 0;\\n        } else {\\n            // the overlapped area\\n            overlapArea = (Math.min(bx2, ax2) - Math.max(bx1, ax1)) * (Math.min(by2, ay2) - Math.max(by1, ay1));\\n        }\\n        \\n        return sumArea - overlapArea;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n// AC: Runtime: 2 ms, faster than 100.00% of Java online submissions for Rectangle Area.\\n// Memory Usage: 38.1 MB, less than 88.56% of Java online submissions for Rectangle Area.\\n// Depart into several situations and analyse respectively, and we can get the regularity about the overlapped area.\\n// T:O(1), S:O(1)\\n// \\nclass Solution {\\n    public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        int overlapArea, sumArea = (ay2 - ay1) * (ax2 - ax1) + (by2 - by1) * (bx2 - bx1);\\n        \\n        // no-overlapping area.\\n        if (bx1 >= ax2 || bx2 <= ax1 || by1 >= ay2 || by2 <= ay1) {\\n            overlapArea = 0;\\n        } else {\\n            // the overlapped area\\n            overlapArea = (Math.min(bx2, ax2) - Math.max(bx1, ax1)) * (Math.min(by2, ay2) - Math.max(by1, ay1));\\n        }\\n        \\n        return sumArea - overlapArea;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1249504,
                "title": "watch-my-solution-for-clear-understanding",
                "content": "class Solution:\\n    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:\\n        \\n\\t\\t#cordinates for overlapped section!\\n\\t\\tcx1=max(ax1,bx1)\\n        cx2=min(ax2,bx2)\\n        cy1=max(ay1,by1)\\n        cy2=min(ay2,by2)\\n\\t\\t\\n\\t\\t#if -ve length then it means that the rectangles are not overlapping\\n\\t\\tnew_x=max(0,cx2-cx1)\\n        new_y=max(0,cy2-cy1)\\n\\t\\t\\n\\t\\t#length of rect a\\n\\t\\ta_x=abs(ax2-ax1)\\n\\t\\t#width of rect a\\n        a_y=abs(ay2-ay1)\\n        #length of rect b\\n\\t\\tb_y=abs(by2-by1)\\n        #width of rect b\\n\\t\\tb_x=abs(bx2-bx1)\\n        return ((a_x*a_y)+(b_x*b_y)-(new_x*new_y))\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:\\n        \\n\\t\\t#cordinates for overlapped section!\\n\\t\\tcx1=max(ax1,bx1)\\n        cx2=min(ax2,bx2)\\n        cy1=max(ay1,by1)\\n        cy2=min(ay2,by2)\\n\\t\\t\\n\\t\\t#if -ve length then it means that the rectangles are not overlapping\\n\\t\\tnew_x=max(0,cx2-cx1)\\n        new_y=max(0,cy2-cy1)\\n\\t\\t\\n\\t\\t#length of rect a\\n\\t\\ta_x=abs(ax2-ax1)\\n\\t\\t#width of rect a\\n        a_y=abs(ay2-ay1)\\n        #length of rect b\\n\\t\\tb_y=abs(by2-by1)\\n        #width of rect b\\n\\t\\tb_x=abs(bx2-bx1)\\n        return ((a_x*a_y)+(b_x*b_y)-(new_x*new_y))\\n",
                "codeTag": "Java"
            },
            {
                "id": 1224273,
                "title": "python-java-solution-with-6-lines",
                "content": "I dont understand why other solutions here makes it so complicated and uses if statement to see if theres an overlap. My solution is much more straightforward. Also my Java solution is 100% fastest. Enjoy!\\n\\nPython:\\n```\\nclass Solution:\\n    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:\\n        # Finding the overlapping length by subtracting min of both rect\\'s x2s with maximum of both rect\\'s x1s. If negative means no overlap and output 0 instead\\n        length = max(0, min(ax2, bx2) - max(ax1, bx1))  \\n        width = max(0, min(ay2, by2) - max(ay1, by1))\\n        overlap = length * width\\n        \\n        # Calculating total area by Addition rule\\n        aa = (ax2 - ax1) * (ay2 - ay1)\\n        ab = (bx2 - bx1) * (by2 - by1)\\n        return aa + ab - overlap\\n```\\n\\nJAVA:\\n```\\nclass Solution {\\n    public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        // Finding the overlapping length by subtracting min of both rect\\'s x2s with maximum of both rect\\'s x1s. If negative means no overlap and output 0 instead\\n        int length = Math.max(0, Math.min(ax2, bx2) - Math.max(ax1, bx1));  \\n        int width = Math.max(0, Math.min(ay2, by2) - Math.max(ay1, by1));\\n        int overlap = length * width;\\n        \\n        // Calculating total area by Addition rule\\n        int aa = (ax2 - ax1) * (ay2 - ay1);\\n        int ab = (bx2 - bx1) * (by2 - by1);\\n        return aa + ab - overlap;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:\\n        # Finding the overlapping length by subtracting min of both rect\\'s x2s with maximum of both rect\\'s x1s. If negative means no overlap and output 0 instead\\n        length = max(0, min(ax2, bx2) - max(ax1, bx1))  \\n        width = max(0, min(ay2, by2) - max(ay1, by1))\\n        overlap = length * width\\n        \\n        # Calculating total area by Addition rule\\n        aa = (ax2 - ax1) * (ay2 - ay1)\\n        ab = (bx2 - bx1) * (by2 - by1)\\n        return aa + ab - overlap\\n```\n```\\nclass Solution {\\n    public int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        // Finding the overlapping length by subtracting min of both rect\\'s x2s with maximum of both rect\\'s x1s. If negative means no overlap and output 0 instead\\n        int length = Math.max(0, Math.min(ax2, bx2) - Math.max(ax1, bx1));  \\n        int width = Math.max(0, Math.min(ay2, by2) - Math.max(ay1, by1));\\n        int overlap = length * width;\\n        \\n        // Calculating total area by Addition rule\\n        int aa = (ax2 - ax1) * (ay2 - ay1);\\n        int ab = (bx2 - bx1) * (by2 - by1);\\n        return aa + ab - overlap;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1067703,
                "title": "javascript-clean-solution",
                "content": "```javascript\\nvar computeArea = function(A, B, C, D, E, F, G, H) {\\n    function findArea(x1, y1, x2, y2) {\\n        return (x1 - x2) * (y1 - y2);\\n    }\\n    \\n    const area1 = findArea(A, B, C, D);\\n    const area2 = findArea(E, F, G, H);\\n    let area3 = 0;\\n    \\n    const xStart = Math.max(A, E);\\n    const xEnd = Math.min(C, G);\\n    const yStart = Math.max(B, F);\\n    const yEnd = Math.min(D, H);\\n    \\n    // check if the rectangles overlap\\n    if(xStart <= xEnd && yStart <= yEnd) { \\n        area3 = findArea(xStart, yStart, xEnd, yEnd);\\n    }\\n    return area1 + area2 - area3;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar computeArea = function(A, B, C, D, E, F, G, H) {\\n    function findArea(x1, y1, x2, y2) {\\n        return (x1 - x2) * (y1 - y2);\\n    }\\n    \\n    const area1 = findArea(A, B, C, D);\\n    const area2 = findArea(E, F, G, H);\\n    let area3 = 0;\\n    \\n    const xStart = Math.max(A, E);\\n    const xEnd = Math.min(C, G);\\n    const yStart = Math.max(B, F);\\n    const yEnd = Math.min(D, H);\\n    \\n    // check if the rectangles overlap\\n    if(xStart <= xEnd && yStart <= yEnd) { \\n        area3 = findArea(xStart, yStart, xEnd, yEnd);\\n    }\\n    return area1 + area2 - area3;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1038538,
                "title": "java-3-lines-of-code-super-easy",
                "content": "```\\nclass Solution {\\n    public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        //find area of the 1st rectangle (length*breath)\\n        long area1 = (1L*D-1L*B)*(1L*C-1L*A);\\n\\t\\t//finding area of the 2nd rectangle\\n        long area2 = (1L*H-1L*F)*(1L*G-1L*E);\\n\\t\\t//finding overlaped region \\n        long overlap = Math.max(1L*Math.min(C,G)-1L*Math.max(A,E),0)*\\n                    Math.max(1L*Math.min(H,D)-1L*Math.max(B,F),0);\\n\\t\\t\\t\\t\\t//Math.max(somevalue,0) -> 0 is for if there is no overlap it will took 0\\n\\t\\t\\t\\t\\t\\n\\t\\t// now to area consists of 2 times overlap of rectangle since we adding area of both\\n\\t\\t//rectangle. so subtracting 1 overlap region\\n        return (int)(area1+area2-overlap);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        //find area of the 1st rectangle (length*breath)\\n        long area1 = (1L*D-1L*B)*(1L*C-1L*A);\\n\\t\\t//finding area of the 2nd rectangle\\n        long area2 = (1L*H-1L*F)*(1L*G-1L*E);\\n\\t\\t//finding overlaped region \\n        long overlap = Math.max(1L*Math.min(C,G)-1L*Math.max(A,E),0)*\\n                    Math.max(1L*Math.min(H,D)-1L*Math.max(B,F),0);\\n\\t\\t\\t\\t\\t//Math.max(somevalue,0) -> 0 is for if there is no overlap it will took 0\\n\\t\\t\\t\\t\\t\\n\\t\\t// now to area consists of 2 times overlap of rectangle since we adding area of both\\n\\t\\t//rectangle. so subtracting 1 overlap region\\n        return (int)(area1+area2-overlap);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1025952,
                "title": "c-solution-with-comments-for-explanation",
                "content": "* If you had troubles with the question, try drawing it out, makes it a lot easier to understand\\n* Finding the area of two rectangle is trivial, but the intersection may not be\\n* Can find the area of the intersection by finding the corners\\n* Notice that the intersection corners must be in the *bounds* of both rectangles\\n\\n```\\nclass Solution {\\npublic:\\n    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        // Finding the area of two rectangles\\n        int a1 = abs(abs(A - C) * abs(B - D));\\n        int a2 = abs(abs(E - G) * abs(F - H));\\n        \\n        // If it does not meet the criteria for instersecting rectangles\\n        // return the sum        \\n        if (!(A < G && B < H && E < C && F < D)) return a1 + a2;\\n        \\n        // Finding the corners of the intersection\\n        int a = max(A, E);\\n        int b = max(B, F);\\n        int c = min(C, G);\\n        int d = min(D, H);\\n        \\n        // Finding the area of the intersection\\n        int intersect = abs(abs(a - c) * abs(b - d));\\n        \\n        // the interset must be placed in the middle incase of int\\n        // overflow with two large a1 + a2\\n        return a1 - intersect + a2 ;\\n    }\\n};\\n```\\n* drop a like if you found it useful :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        // Finding the area of two rectangles\\n        int a1 = abs(abs(A - C) * abs(B - D));\\n        int a2 = abs(abs(E - G) * abs(F - H));\\n        \\n        // If it does not meet the criteria for instersecting rectangles\\n        // return the sum        \\n        if (!(A < G && B < H && E < C && F < D)) return a1 + a2;\\n        \\n        // Finding the corners of the intersection\\n        int a = max(A, E);\\n        int b = max(B, F);\\n        int c = min(C, G);\\n        int d = min(D, H);\\n        \\n        // Finding the area of the intersection\\n        int intersect = abs(abs(a - c) * abs(b - d));\\n        \\n        // the interset must be placed in the middle incase of int\\n        // overflow with two large a1 + a2\\n        return a1 - intersect + a2 ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 958730,
                "title": "python3-one-liner-without-any-if-statement",
                "content": "```\\nclass Solution:\\n    def computeArea(self, A: int, B: int, C: int, D: int, E: int, F: int, G: int, H: int) -> int:\\n        return abs(C-A) * abs(D-B) + \\\\\\n               abs(G-E) * abs(F-H) - \\\\\\n               max(min(H, D) - max(B,F), 0) * max(min(G,C) - max(A,E), 0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def computeArea(self, A: int, B: int, C: int, D: int, E: int, F: int, G: int, H: int) -> int:\\n        return abs(C-A) * abs(D-B) + \\\\\\n               abs(G-E) * abs(F-H) - \\\\\\n               max(min(H, D) - max(B,F), 0) * max(min(G,C) - max(A,E), 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 954168,
                "title": "java-solution-with-picture",
                "content": "![image](https://assets.leetcode.com/users/images/20f0e5ec-0c1c-4383-b663-268c8ef2584c_1606706955.071892.png)\\n\\n```\\npublic int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        \\n        int recA = (C-A)*(D-B);\\n        int recB = (G-E)*(H-F);\\n        \\n        if(A >= G || E >= C ||  // no overlap on x-axis\\n           B >= H || F >= D)    // no overlap on y-axis\\n        {   \\n        \\n            return recA + recB;\\n        }\\n        else\\n        {\\n            int x = Math.min(C, G) - Math.max(A, E);\\n            int y = Math.min(D, H) - Math.max(B, F);\\n            int intersection = x * y;\\n            return (recA + recB - intersection);\\n        }\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        \\n        int recA = (C-A)*(D-B);\\n        int recB = (G-E)*(H-F);\\n        \\n        if(A >= G || E >= C ||  // no overlap on x-axis\\n           B >= H || F >= D)    // no overlap on y-axis\\n        {   \\n        \\n            return recA + recB;\\n        }\\n        else\\n        {\\n            int x = Math.min(C, G) - Math.max(A, E);\\n            int y = Math.min(D, H) - Math.max(B, F);\\n            int intersection = x * y;\\n            return (recA + recB - intersection);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 882814,
                "title": "cpp-solution-don-t-bother-to-consider-their-relative-position-it-s-a-waste-of-time",
                "content": "This passage would consider this problem in a distinct manner.\\n\\nEveryone knows how to handle this problem if the two rectangles don\\'t overlap with each other. \\nSo, the most challenging task comes to how do we calculate the overlap between the two rectangles. Here\\'s a subtle method to work out the common space without knowing their relative position - \"use the second and third index\".\\n\\n![image](https://assets.leetcode.com/users/images/0147666a-5fd6-458f-834f-77f6013ba257_1602038330.8400195.png)\\n\\n\\nA rectangle has two horizontal edges and two vertical edges as the pic shows above.  \\nAssuming two rectangles have some common space, no matter where they are, the overlapped part MUST be formed by two horizontal edges and two vertical edges. What\\'s more, the two vertical edges ( colored blue ) ought to locate between another two vertical edges ( one is orange, the other is green ). Naturally, they are the SECOND and THIRD vertical edge if we sort the four vertical edges with their x index. Similarly, the two horizontal edges forming the common rectangle (colored yellow) are the SECOND and the THIRD edge in a sorted \"horizontal edge list\".\\n\\n![image](https://assets.leetcode.com/users/images/c1ec6516-59b3-4336-835c-a1172b872df7_1602040591.312382.png)\\n\\nEven if one rectangle is insider another, the aforementioned conclusion stands still.\\n![image](https://assets.leetcode.com/users/images/3086c7e5-e85c-43f4-aa60-e9d6a66d0611_1602040947.8798864.png)\\n\\nNoticing the feature shown above, we just need to put the four vertical edges in a vector, sort the vector and  get the distance between the 2nd and 3rd elements, namely, the width of the common rectangle; the 3rd horizontal edges minus the 2nd horizontal edges is the height. \\n\\nThe result is area of rectange1 + area of rectangle2 - area common space ( if exists ).\\n\\nHere\\'s the code if you need. Be free to post your comments below, any suggestions or advice would be appreciated.\\n\\n```\\nclass Solution {\\npublic:\\n    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        long long add = static_cast<long long>((H-F)*(G-E)) + static_cast<long long>((D-B)*(C-A));\\n        // case 1: no common space\\n        if(E>=C || G<=A || F>=D || H<=B)\\n            return add;\\n        // case 2: need to calculate area of the common rectangle\\n        vector<int> xindex = {A,E,C,G};\\n        vector<int> yindex = {F,B,H,D};\\n        sort(xindex.begin(),xindex.end());\\n        sort(yindex.begin(),yindex.end());\\n        int commonspace = (xindex[2]-xindex[1])*(yindex[2]-yindex[1]);\\n        return add-commonspace;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        long long add = static_cast<long long>((H-F)*(G-E)) + static_cast<long long>((D-B)*(C-A));\\n        // case 1: no common space\\n        if(E>=C || G<=A || F>=D || H<=B)\\n            return add;\\n        // case 2: need to calculate area of the common rectangle\\n        vector<int> xindex = {A,E,C,G};\\n        vector<int> yindex = {F,B,H,D};\\n        sort(xindex.begin(),xindex.end());\\n        sort(yindex.begin(),yindex.end());\\n        int commonspace = (xindex[2]-xindex[1])*(yindex[2]-yindex[1]);\\n        return add-commonspace;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 858373,
                "title": "so-you-want-to-do-deep-learning",
                "content": "In object detection neural networks, this problem is part of a more complicated and so-called problem named \"non-maximum suppression\", where you need to compute the \"intersection over union\" between bouding boxes.  Like many other algorithms used in deep learning, they are not fancy at all, but error-prone, and hard to implement concisely. \\n\\nC++ solutions:\\n\\n```\\nclass Solution {\\npublic:\\n    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        long long xmin = max (A,E);\\n        long long ymin = max (B,F);\\n        long long xmax = min (C,G);\\n        long long ymax = min (D,H);\\n        long long area0 = (C-A)*(D-B);\\n        long long area1 = (G-E)*(H-F);\\n        long long intersect = (xmax-xmin)*(ymax-ymin);\\n        if (xmax-xmin <= 0 || ymax-ymin <= 0)\\n            intersect = 0;\\n        return area0+area1-intersect;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        long long xmin = max (A,E);\\n        long long ymin = max (B,F);\\n        long long xmax = min (C,G);\\n        long long ymax = min (D,H);\\n        long long area0 = (C-A)*(D-B);\\n        long long area1 = (G-E)*(H-F);\\n        long long intersect = (xmax-xmin)*(ymax-ymin);\\n        if (xmax-xmin <= 0 || ymax-ymin <= 0)\\n            intersect = 0;\\n        return area0+area1-intersect;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 783032,
                "title": "simple-and-easy-to-understand",
                "content": "```(C - A) * (D - B) + (G - E) * (H - F) - commonX * commonY + ;``` yields an overflow for some testcase,\\nwhich is why I modified it to ```(C - A) * (D - B) - commonX * commonY + (G - E) * (H - F);```.\\n```\\nclass Solution {\\npublic:\\n    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        int commonX = max(A, E) < min(C, G) ? min(C, G) - max(A, E) : 0;\\n        int commonY = max(B, F) < min(D, H) ? min(D, H) - max(B, F) : 0;\\n        return (C - A) * (D - B) - commonX * commonY + (G - E) * (H - F);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```(C - A) * (D - B) + (G - E) * (H - F) - commonX * commonY + ;```\n```(C - A) * (D - B) - commonX * commonY + (G - E) * (H - F);```\n```\\nclass Solution {\\npublic:\\n    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        int commonX = max(A, E) < min(C, G) ? min(C, G) - max(A, E) : 0;\\n        int commonY = max(B, F) < min(D, H) ? min(D, H) - max(B, F) : 0;\\n        return (C - A) * (D - B) - commonX * commonY + (G - E) * (H - F);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 619060,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        \\n        unsigned long long areaABCD = (D-B)*(C-A);\\n        unsigned long long areaEFGH = (H-F)*(G-E);\\n        \\n        int x_overlap = min(C,G) > max(A, E);\\n        int y_overlap = min(D,H) > max(B, F);\\n        \\n        unsigned long long areaOverlap = 0;\\n         \\n        if (x_overlap && y_overlap)\\n           areaOverlap = (min(C,G) - max(A,E))*(min(D,H) - max(B, F));\\n        \\n        return areaABCD+areaEFGH-areaOverlap;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        \\n        unsigned long long areaABCD = (D-B)*(C-A);\\n        unsigned long long areaEFGH = (H-F)*(G-E);\\n        \\n        int x_overlap = min(C,G) > max(A, E);\\n        int y_overlap = min(D,H) > max(B, F);\\n        \\n        unsigned long long areaOverlap = 0;\\n         \\n        if (x_overlap && y_overlap)\\n           areaOverlap = (min(C,G) - max(A,E))*(min(D,H) - max(B, F));\\n        \\n        return areaABCD+areaEFGH-areaOverlap;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 487940,
                "title": "c-concise-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n\\t\\t\\tlong x1=max(A,E);\\n\\t\\t\\tlong y1=max(B,F);\\n\\t\\t\\tlong x2=min(C,G);\\n\\t\\t\\tlong y2=min(D,H);\\n\\t\\t\\tlong overlap;\\n\\t\\t\\tif(x1>=x2 || y1>=y2){\\n\\t\\t\\t\\toverlap=0;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\toverlap=(x2-x1)*(y2-y1);\\n\\t\\t\\t}\\n\\t\\t\\treturn (long)(C-A)*(D-B)+(long)(G-E)*(H-F)-overlap;\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n\\t\\t\\tlong x1=max(A,E);\\n\\t\\t\\tlong y1=max(B,F);\\n\\t\\t\\tlong x2=min(C,G);\\n\\t\\t\\tlong y2=min(D,H);\\n\\t\\t\\tlong overlap;\\n\\t\\t\\tif(x1>=x2 || y1>=y2){\\n\\t\\t\\t\\toverlap=0;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 429720,
                "title": "c-simple-easy-to-follow-short-and-sweet",
                "content": "```\\nclass Solution {\\npublic:\\n    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n\\n        if (C<=E || A>=G || B>=H || D<=F )\\n            return (C-A) * (D-B) + (G-E) * (H-F);\\n        else\\n        {\\n            vector <int> h;\\n            h.push_back(A);\\n            h.push_back(C);\\n            h.push_back(E);\\n            h.push_back(G);\\n\\n            vector <int> v;\\n            v.push_back(B);\\n            v.push_back(D);\\n            v.push_back(F);\\n            v.push_back(H);\\n\\n            sort(h.begin(), h.end());\\n            sort(v.begin(), v.end());\\n\\n            int total = - (h[2] - h [1]) * (v[2] - v[1])\\n                        + (C-A) * (D-B) + (G-E) * (H-F) ;\\n            return total;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n\\n        if (C<=E || A>=G || B>=H || D<=F )\\n            return (C-A) * (D-B) + (G-E) * (H-F);\\n        else\\n        {\\n            vector <int> h;\\n            h.push_back(A);\\n            h.push_back(C);\\n            h.push_back(E);\\n            h.push_back(G);\\n\\n            vector <int> v;\\n            v.push_back(B);\\n            v.push_back(D);\\n            v.push_back(F);\\n            v.push_back(H);\\n\\n            sort(h.begin(), h.end());\\n            sort(v.begin(), v.end());\\n\\n            int total = - (h[2] - h [1]) * (v[2] - v[1])\\n                        + (C-A) * (D-B) + (G-E) * (H-F) ;\\n            return total;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 362404,
                "title": "cpp-c-code-using-max-min-from-stl-99-time-85-space-3-liner",
                "content": "```\\nclass Solution {\\npublic:\\n    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        if (A >= G || C <= E || D <= F || B >= H)\\n            return abs((C-A)*(D-B))+abs((G-E)*(H-F));\\n        return abs((C-A)*(D-B))-abs((min(G,C)-max(A,E))*(min(H,D)-max(B,F)))+abs((G-E)*(H-F)); \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        if (A >= G || C <= E || D <= F || B >= H)\\n            return abs((C-A)*(D-B))+abs((G-E)*(H-F));\\n        return abs((C-A)*(D-B))-abs((min(G,C)-max(A,E))*(min(H,D)-max(B,F)))+abs((G-E)*(H-F)); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 260488,
                "title": "c-100-memory-and-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        int area1 = (C-A) * (D-B);\\n        int area2 = (G-E) * (H-F);\\n        int overlap = 0;\\n        int bottomLeftX = max(A, E);\\n        int bottomLeftY = max(B, F);\\n        int topRightX = min(C, G);\\n        int topRightY = min(D, H);\\n        // no overlap\\n        if(B > H || C < E || A > G || F > D) {\\n            overlap = 0;\\n        } else {\\n            overlap = (topRightX - bottomLeftX) * (topRightY - bottomLeftY);\\n        }\\n        return area1 - overlap + area2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        int area1 = (C-A) * (D-B);\\n        int area2 = (G-E) * (H-F);\\n        int overlap = 0;\\n        int bottomLeftX = max(A, E);\\n        int bottomLeftY = max(B, F);\\n        int topRightX = min(C, G);\\n        int topRightY = min(D, H);\\n        // no overlap\\n        if(B > H || C < E || A > G || F > D) {\\n            overlap = 0;\\n        } else {\\n            overlap = (topRightX - bottomLeftX) * (topRightY - bottomLeftY);\\n        }\\n        return area1 - overlap + area2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 257842,
                "title": "",
                "content": "```\\nclass Solution {\\n    public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        //\\u5148\\u8BA1\\u7B97\\u4E24\\u4E2A\\u77E9\\u5F62\\u7684\\u9762\\u79EF\\uFF0C\\u540E\\u9762\\u518D\\u7B97\\u91CD\\u5408\\u90E8\\u5206\\u7684\\u9762\\u79EF\\u51CF\\u53BB\\u5C31\\u53EF\\u4EE5\\u5566\\n        int s1 = (C-A)*(D-B);\\n        int s2 = (G-E)*(H-F);\\n        \\n        // \\u4E3A\\u4E86\\u4FBF\\u4E8E\\u7406\\u89E3\\uFF0C\\u6211\\u4EEC\\u628A\\u5750\\u6807\\u4E2D\\u5FC3\\u79FB\\u52A8\\u5230\\u7B2C\\u4E00\\u4E2A\\u77E9\\u5F62\\u7684\\u5DE6\\u4E0B\\uFF0C\\u6240\\u6709\\u5750\\u6807\\u505A\\u5E73\\u79FB\\uFF0C\\u6B64\\u65F6\\u4FDD\\u8BC1\\u7B2C\\u4E00\\u4E2A\\u77E9\\u5F62\\u5728\\u7B2C\\u4E00\\u8C61\\u9650\\n        C-=A;\\n        D-=B;\\n        E-=A;\\n        F-=B;\\n        G-=A;\\n        H-=B;\\n        A=0;\\n        B=0;\\n        // \\u5728\\u7B2C234\\u8C61\\u9650\\u7684\\u90E8\\u5206\\u53EF\\u4EE5\\u76F4\\u63A5\\u4E0D\\u8BA1\\u7B97\\u4E86\\uFF0C\\u56E0\\u4E3A\\u77E9\\u9635\\u4E00\\u53EA\\u5728\\u7B2C\\u4E00\\u8C61\\u9650\\n        if(E<0)E=0;\\n        if(F<0)F=0;\\n        if(G<0)G=0;\\n        if(H<0)H=0;\\n        \\n        //\\u5982\\u679C\\u77E92\\u5DE6\\u4E0B\\u89D2\\u6CA1\\u6709\\u843D\\u5728\\u77E91\\u4E2D\\u5219\\u76F4\\u63A5\\u65E0\\u91CD\\u5408\\n        if(E>=C||F>=D)return s1+s2;\\n        \\n        //\\u5DE6\\u4E0B\\u843D\\u5728\\u77E91\\u4E2D\\uFF0C\\u5219\\u91CD\\u5408\\u90E8\\u5206\\u7684\\u5DE6\\u4E0B\\u89D2\\u5C31\\u662F\\u77E92\\u7684\\u5DE6\\u4E0B\\u89D2\\n        //\\u53F3\\u4E0A\\u89D2\\u662Fmin(g,c) min(d,h)\\u53EF\\u4EE5\\u753B\\u56FE\\u81EA\\u5DF1\\u770B\\u4E00\\u4E0B\\uFF0C\\u5F88\\u5BB9\\u6613\\u7406\\u89E3\\n        return s1+s2-(Math.min(G,C)-E)*(Math.min(D,H)-F);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        //\\u5148\\u8BA1\\u7B97\\u4E24\\u4E2A\\u77E9\\u5F62\\u7684\\u9762\\u79EF\\uFF0C\\u540E\\u9762\\u518D\\u7B97\\u91CD\\u5408\\u90E8\\u5206\\u7684\\u9762\\u79EF\\u51CF\\u53BB\\u5C31\\u53EF\\u4EE5\\u5566\\n        int s1 = (C-A)*(D-B);\\n        int s2 = (G-E)*(H-F);\\n        \\n        // \\u4E3A\\u4E86\\u4FBF\\u4E8E\\u7406\\u89E3\\uFF0C\\u6211\\u4EEC\\u628A\\u5750\\u6807\\u4E2D\\u5FC3\\u79FB\\u52A8\\u5230\\u7B2C\\u4E00\\u4E2A\\u77E9\\u5F62\\u7684\\u5DE6\\u4E0B\\uFF0C\\u6240\\u6709\\u5750\\u6807\\u505A\\u5E73\\u79FB\\uFF0C\\u6B64\\u65F6\\u4FDD\\u8BC1\\u7B2C\\u4E00\\u4E2A\\u77E9\\u5F62\\u5728\\u7B2C\\u4E00\\u8C61\\u9650\\n        C-=A;\\n        D-=B;\\n        E-=A;\\n        F-=B;\\n        G-=A;\\n        H-=B;\\n        A=0;\\n        B=0;\\n        // \\u5728\\u7B2C234\\u8C61\\u9650\\u7684\\u90E8\\u5206\\u53EF\\u4EE5\\u76F4\\u63A5\\u4E0D\\u8BA1\\u7B97\\u4E86\\uFF0C\\u56E0\\u4E3A\\u77E9\\u9635\\u4E00\\u53EA\\u5728\\u7B2C\\u4E00\\u8C61\\u9650\\n        if(E<0)E=0;\\n        if(F<0)F=0;\\n        if(G<0)G=0;\\n        if(H<0)H=0;\\n        \\n        //\\u5982\\u679C\\u77E92\\u5DE6\\u4E0B\\u89D2\\u6CA1\\u6709\\u843D\\u5728\\u77E91\\u4E2D\\u5219\\u76F4\\u63A5\\u65E0\\u91CD\\u5408\\n        if(E>=C||F>=D)return s1+s2;\\n        \\n        //\\u5DE6\\u4E0B\\u843D\\u5728\\u77E91\\u4E2D\\uFF0C\\u5219\\u91CD\\u5408\\u90E8\\u5206\\u7684\\u5DE6\\u4E0B\\u89D2\\u5C31\\u662F\\u77E92\\u7684\\u5DE6\\u4E0B\\u89D2\\n        //\\u53F3\\u4E0A\\u89D2\\u662Fmin(g,c) min(d,h)\\u53EF\\u4EE5\\u753B\\u56FE\\u81EA\\u5DF1\\u770B\\u4E00\\u4E0B\\uFF0C\\u5F88\\u5BB9\\u6613\\u7406\\u89E3\\n        return s1+s2-(Math.min(G,C)-E)*(Math.min(D,H)-F);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 232150,
                "title": "python-basic-5-lines",
                "content": "Could even be made into a one-liner. Compute the combined area of the two rectangles then subtract the intersection area, if it exists.\\n\\n```\\nclass Solution(object):\\n    def computeArea(self, A, B, C, D, E, F, G, H):\\n        total = (C - A) * (D - B) + (G - E) * (H - F)\\n        intx = min(C,G) - max(A,E)\\n        inty = min(D,H) - max(B,F)\\n        if intx > 0 and inty > 0: return total - (intx * inty)\\n        return total\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def computeArea(self, A, B, C, D, E, F, G, H):\\n        total = (C - A) * (D - B) + (G - E) * (H - F)\\n        intx = min(C,G) - max(A,E)\\n        inty = min(D,H) - max(B,F)\\n        if intx > 0 and inty > 0: return total - (intx * inty)\\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 197757,
                "title": "neat-python-solution",
                "content": "I think the easiest way to calculate the overlapping area is to see the overlap on each axis. Draw segments and you will see how the following code works.\\n\\n```\\ndef computeArea(self, A, B, C, D, E, F, G, H):\\n        \"\"\"\\n        :type A: int\\n        :type B: int\\n        :type C: int\\n        :type D: int\\n        :type E: int\\n        :type F: int\\n        :type G: int\\n        :type H: int\\n        :rtype: int\\n        \"\"\"\\n        dx = max(min(C, G) - max(A, E), 0) # x-axis\\n        dy = max(min(D, H) - max(B, F), 0) # y-axis\\n        overlap_area = dx * dy\\n        \\n        return (C - A) * (D - B) + (G - E) * (H - F) - overlap_area\\n```",
                "solutionTags": [],
                "code": "```\\ndef computeArea(self, A, B, C, D, E, F, G, H):\\n        \"\"\"\\n        :type A: int\\n        :type B: int\\n        :type C: int\\n        :type D: int\\n        :type E: int\\n        :type F: int\\n        :type G: int\\n        :type H: int\\n        :rtype: int\\n        \"\"\"\\n        dx = max(min(C, G) - max(A, E), 0) # x-axis\\n        dy = max(min(D, H) - max(B, F), 0) # y-axis\\n        overlap_area = dx * dy\\n        \\n        return (C - A) * (D - B) + (G - E) * (H - F) - overlap_area\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 158002,
                "title": "simple-3-lines-java-solution",
                "content": "Sum is the the sum of independent areas of the two rectangles (not considering overlap).\\nIf statement true, then no overlap, just return the sum.\\nOtherwise, return sum minus overlap.\\n```\\nclass Solution {\\n    public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        int sum =  (C-A)*(D-B) + (G-E)*(H-F);\\n        if(C < E || G<A || B>H || D<F)return sum;\\n        return sum-(Math.min(D,H)-Math.max(B,F))*(Math.min(G,C)-Math.max(A,E));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        int sum =  (C-A)*(D-B) + (G-E)*(H-F);\\n        if(C < E || G<A || B>H || D<F)return sum;\\n        return sum-(Math.min(D,H)-Math.max(B,F))*(Math.min(G,C)-Math.max(A,E));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 62186,
                "title": "c-accepted-brief-explanation",
                "content": "This question is a little bit of tricky... \\n\\n    class Solution {\\n    public:\\n    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        int area1 = (C-A)*(D-B);\\n        int area2 = (G-E)*(H-F);\\n        //1:(A,D),(C,D),(C,B),(A,B)\\n        //2:(E,H),(G,H),(G,F),(E,F)\\n        \\n        if(A>=G || E>=C || B>=H || F>=D){return area1 + area2;}\\n        //one top >= another bottom, one left >= another right\\n        return area1 + area2 - (min(C,G) - max(A,E))*(min(D,H) - max(B,F));\\n        // min left - max right, min up - max bottom.\\n        \\n    }\\n   };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        int area1 = (C-A)*(D-B);\\n        int area2 = (G-E)*(H-F);\\n        //1:(A,D),(C,D),(C,B),(A,B)\\n        //2:(E,H),(G,H),(G,F),(E,F)\\n        \\n        if(A>=G || E>=C || B>=H || F>=D){return area1 + area2;}",
                "codeTag": "Java"
            },
            {
                "id": 62187,
                "title": "simple-c-solution-84-74",
                "content": "```\\nclass Solution {\\npublic:\\n    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        int nblx = (A > E) ? A : E;\\n        int nbly = (B > F) ? B : F;\\n        int ntrx = (C > G) ? G : C;\\n        int ntry = (D > H) ? H : D;\\n        int uni = 0;\\n        if (ntrx >= nblx && ntry >= nbly) uni = (ntrx - nblx) * (ntry - nbly);\\n        return ((C - A) * (D - B) + (G - E) * (H - F)) - uni;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        int nblx = (A > E) ? A : E;\\n        int nbly = (B > F) ? B : F;\\n        int ntrx = (C > G) ? G : C;\\n        int ntry = (D > H) ? H : D;\\n        int uni = 0;\\n        if (ntrx >= nblx && ntry >= nbly) uni = (ntrx - nblx) * (ntry - nbly);\\n        return ((C - A) * (D - B) + (G - E) * (H - F)) - uni;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 62230,
                "title": "java-easy-solution",
                "content": "\\n    public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n      int xOverlapping = calcOverlap(A, C, E, G);\\n      int yOverlapping = calcOverlap(B, D, F, H);\\n      return (C - A) * (D - B) + (G - E) * (H - F) - xOverlapping * yOverlapping;\\n    }\\n\\n    private int calcOverlap(long a1, long a2, long b1, long b2) {\\n      long diff = (Math.min(a2, b2) - Math.max(a1, b1));\\n      if (diff > 0) {\\n        return (int) diff;\\n      } else {\\n        return 0;\\n      }\\n    }",
                "solutionTags": [],
                "code": "\\n    public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n      int xOverlapping = calcOverlap(A, C, E, G);\\n      int yOverlapping = calcOverlap(B, D, F, H);\\n      return (C - A) * (D - B) + (G - E) * (H - F) - xOverlapping * yOverlapping;\\n    }\\n\\n    private int calcOverlap(long a1, long a2, long b1, long b2) {\\n      long diff = (Math.min(a2, b2) - Math.max(a1, b1));\\n      if (diff > 0) {\\n        return (int) diff;\\n      } else {\\n        return 0;\\n      }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 62245,
                "title": "share-my-c-solution-easy-to-understand",
                "content": "    class Solution {\\n    public:\\n        int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n            int l1 = C - A;\\n            int w1 = D - B;\\n            \\n            int l2 = G - E;\\n            int w2 = H - F;\\n            \\n            int ret = l1 * w1 + l2 * w2;\\n            \\n            if (G <= A || C <= E || H <= B || D <= F) //no overlap\\n                return ret;\\n            \\n            int l3 = min(C, G) - max(A, E);\\n            int w3 = min(D, H) - max(B, F);\\n            int overlap = l3 * w3;\\n                \\n            return ret - overlap;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n            int l1 = C - A;\\n            int w1 = D - B;\\n            \\n            int l2 = G - E;\\n            int w2 = H - F;\\n            \\n            int ret = l1 * w1 + l2 * w2;\\n            \\n            if (G <= A || C <= E || H <= B || D <= F) //no overlap\\n                return ret;\\n            \\n            int l3 = min(C, G) - max(A, E);\\n            int w3 = min(D, H) - max(B, F);\\n            int overlap = l3 * w3;\\n                \\n            return ret - overlap;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 62246,
                "title": "3-lines-java-solution",
                "content": "    public class Solution {\\n    public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        int lapWidth = Math.min((C > E ? C - E : 0) - (A > E ? A - E : 0), (G > A ? G - A : 0) - (E > A ? E - A : 0));\\n        int lapHeight = Math.min((D > F ? D - F : 0) - (B > F ? B - F : 0), (H > B ? H - B : 0) - (F > B ? F - B : 0));\\n        return (C - A) * (D - B) + (G - E) * (H - F) - lapWidth * lapHeight;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        int lapWidth = Math.min((C > E ? C - E : 0) - (A > E ? A - E : 0), (G > A ? G - A : 0) - (E > A ? E - A : 0));\\n        int lapHeight = Math.min((D > F ? D - F : 0) - (B > F ? B - F : 0), (H > B ? H - B : 0) - (F > B ? F - B : 0));\\n        return (C - A) * (D - B) + (G - E) * (H - F) - lapWidth * lapHeight;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 62280,
                "title": "c-solution-with-explanation",
                "content": "class Solution {\\npublic:\\n    int RectArea(int left, int bottom, int right, int top){ \\n\\n        int result = (right > left && top > bottom)? ((right-left) * (top-bottom)) : 0; // If there is no common area it will be 0;\\n        return result;\\n    }\\n    int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) { // For better understanding the problem try to draw intersected/not intersected rectangles;\\n        int left1 = A;\\n        int bottom1 = B;\\n        int right1 = C;\\n        int top1 = D;\\n        int left2 = E;\\n        int bottom2 = F;\\n        int right2 = G;\\n        int top2 = H;\\n        int interleft = max(left1, left2);          //IF two rectangle intersects max will return the intersect point X value; \\n        int interright = min(right1, right2);       //IF two rectangle intersects min will return the intersect point X value\\n        int intertop = min(top1, top2);             //IF two rectangle intersects min will return the intersect point Y value\\n        int interbottom = max(bottom1, bottom2);    //IF two rectangle intersects max will return the intersect point Y value\\n        int total_area = RectArea(left1, bottom1, right1, top1) + RectArea(left2, bottom2, right2, top2) - RectArea(interleft, interbottom, interright, intertop);\\n        return total_area;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int RectArea(int left, int bottom, int right, int top){ \\n\\n        int result = (right > left && top > bottom)? ((right-left) * (top-bottom)) : 0; // If there is no common area it will be 0;\\n        return result;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 62295,
                "title": "2-solutions-c",
                "content": "        //36ms\\n            int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n                return (D-B)*(C-A)+(G-E)*(H-F)-getXY(D,B,H,F)*getXY(C,A,G,E);\\n            }\\n            // assert D>=B,H>=F \\n            int getXY(int D, int B, int H, int F){\\n                if((B>=H)||(D<=F))\\n                    return 0;       // no overlap\\n                vector<int>V(4);\\n                V[0] = D;V[1] = B; V[2] = H, V[3] = F;\\n                sort(V.begin(),V.end());     // get the second and the third one to calc overlap length\\n                return V[2]-V[1];  // if no overLap, then v[2]-v[1] = 0, return 0\\n            }\\n\\n            // 32ms\\n            int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n                int S = (D-B)*(C-A)+(G-E)*(H-F);\\n                if((H<=B)||(D<=F)||(C<=E)||(G<=A)) return S;  //in case of overflow, avoid calc overlap\\n                return S-(min(D,H)-max(B,F))*(min(C,G)-max(A,E)); \\n            // return S-max(min(D,H)-max(B,F), 0)*max(min(C,G)-max(A,E), 0); //old ver\\n\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "        //36ms\\n            int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n                return (D-B)*(C-A)+(G-E)*(H-F)-getXY(D,B,H,F)*getXY(C,A,G,E);\\n            }\\n            // assert D>=B,H>=F \\n            int getXY(int D, int B, int H, int F){\\n                if((B>=H)||(D<=F))\\n                    return 0;       // no overlap\\n                vector<int>V(4);\\n                V[0] = D;V[1] = B; V[2] = H, V[3] = F;\\n                sort(V.begin(),V.end());     // get the second and the third one to calc overlap length\\n                return V[2]-V[1];  // if no overLap, then v[2]-v[1] = 0, return 0\\n            }\\n\\n            // 32ms\\n            int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n                int S = (D-B)*(C-A)+(G-E)*(H-F);\\n                if((H<=B)||(D<=F)||(C<=E)||(G<=A)) return S;  //in case of overflow, avoid calc overlap\\n                return S-(min(D,H)-max(B,F))*(min(C,G)-max(A,E)); \\n            // return S-max(min(D,H)-max(B,F), 0)*max(min(C,G)-max(A,E), 0); //old ver\\n\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 62170,
                "title": "small-c-solution",
                "content": "   \\n\\n    class Solution {\\n        public:\\n            int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n                int leftX = max(A,E);     // x value of the left side of the intersection\\n                int rightX = min(C,G);   // x value of the right side of the intersection\\n                int topY = min(H,D);     // y value of the bottom side of the intersection\\n                int botY = max(F,B);     //y value of the top side of the intersection\\n                int intersecArea = 0; \\n                if(leftX < rightX && topY > botY) //if one of the sides above is misplaced => the intersection is empty\\n                    intersecArea =  (rightX-leftX)*(topY-botY);\\n                return (C-A)*(D-B) + (G-E)*(H-F) - intersecArea; // Area rectangle 1 + area rectangle 2 - intersection\\n            }\\n        };",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n                int leftX = max(A,E);     // x value of the left side of the intersection\\n                int rightX = min(C,G);   // x value of the right side of the intersection\\n                int topY = min(H,D);     // y value of the bottom side of the intersection\\n                int botY = max(F,B);     //y value of the top side of the intersection\\n                int intersecArea = 0; \\n                if(leftX < rightX && topY > botY) //if one of the sides above is misplaced => the intersection is empty\\n                    intersecArea =  (rightX-leftX)*(topY-botY);\\n                return (C-A)*(D-B) + (G-E)*(H-F) - intersecArea; // Area rectangle 1 + area rectangle 2 - intersection\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 62322,
                "title": "i-used-abs-value-and-borrowed-technique-from-another-solution-that-worked",
                "content": "    public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        \\n        int space =0;\\n        int space1 = (Math.abs(A-C)*Math.abs(B-D));\\n        int space2 =(Math.abs(E-G)*Math.abs(F-H));\\n        \\n        //borrowed from anther solution\\n        int left = Math.max(A,E);\\n        int right = Math.min(G,C);\\n        int top = Math.min(D,H);\\n        int bottom = Math.max(B,F);\\n        \\n        if (top >= bottom && right >= left) {\\n            space = (Math.abs(bottom-top)*Math.abs(left-right));\\n        }\\n        return space1+space2-space;\\n        \\n    }",
                "solutionTags": [
                    "Math"
                ],
                "code": "    public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        \\n        int space =0;\\n        int space1 = (Math.abs(A-C)*Math.abs(B-D));\\n        int space2 =(Math.abs(E-G)*Math.abs(F-H));\\n        \\n        //borrowed from anther solution\\n        int left = Math.max(A,E);\\n        int right = Math.min(G,C);\\n        int top = Math.min(D,H);\\n        int bottom = Math.max(B,F);\\n        \\n        if (top >= bottom && right >= left) {\\n            space = (Math.abs(bottom-top)*Math.abs(left-right));\\n        }\\n        return space1+space2-space;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 62341,
                "title": "a-java-solution",
                "content": "public class Solution {\\n    public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        \\n        int area1 = (Math.abs(D - B)) * (Math.abs(C - A));\\n        int area2 = (Math.abs(H - F)) * (Math.abs(G - E));\\n        int area3 = area1 + area2;\\n        \\n        int left = Math.max(A, E);\\n        int right = Math.min(C, G);\\n        if (left  >= right) return area3;\\n        \\n        int above = Math.min(D, H);\\n        int below = Math.max(B, F);\\n        \\n        if (below >= above) return area3;\\n        \\n        return area3 - ((right - left) * (above - below));\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {\\n        \\n        int area1 = (Math.abs(D - B)) * (Math.abs(C - A));\\n        int area2 = (Math.abs(H - F)) * (Math.abs(G - E));\\n        int area3 = area1 + area2;\\n        \\n        int left = Math.max(A, E);\\n        int right = Math.min(C, G);\\n        if (left  >= right) return area3;\\n        \\n        int above = Math.min(D, H);\\n        int below = Math.max(B, F);\\n        \\n        if (below >= above) return area3;\\n        \\n        return area3 - ((right - left) * (above - below));\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3221596,
                "title": "rectangle-area",
                "content": "# Intuition\\nThe rectangle area is the sum of individual area with the intersecting one taking into consideration.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst checking for the intersection of the rectangles, if any find the points where that happen, then substructing the intersection from the cummilative sum.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution:\\n    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:\\n        area1 = abs(ax2-ax1) * abs(ay2-ay1)\\n        area2 = abs(bx2-bx1) * abs(by2-by1)\\n        # check intersection\\n        conditionX = (bx1 <= ax2 and bx2 >= ax1) or (bx2 <= ax2 and bx1 >= ax1)\\n        conditionY = (by1 <= ay2 and by2 >= ay1) or (by2 <= ay2 and by1 >= ay1)\\n        \\n        if conditionX and conditionY:\\n            intersectArea = abs(min(ax2,bx2)-max(bx1,ax1)) * abs(min(ay2,by2)-max(by1,ay1))\\n        else: \\n            intersectArea = 0\\n        return area1 + area2 - intersectArea\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:\\n        area1 = abs(ax2-ax1) * abs(ay2-ay1)\\n        area2 = abs(bx2-bx1) * abs(by2-by1)\\n        # check intersection\\n        conditionX = (bx1 <= ax2 and bx2 >= ax1) or (bx2 <= ax2 and bx1 >= ax1)\\n        conditionY = (by1 <= ay2 and by2 >= ay1) or (by2 <= ay2 and by1 >= ay1)\\n        \\n        if conditionX and conditionY:\\n            intersectArea = abs(min(ax2,bx2)-max(bx1,ax1)) * abs(min(ay2,by2)-max(by1,ay1))\\n        else: \\n            intersectArea = 0\\n        return area1 + area2 - intersectArea\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182248,
                "title": "easy-and-well-explained-solution-in-c",
                "content": "# Intuition\\nIntuition of this problem is simple.To calculate the common area between two rectangles,we use (area_1 + area_2 - common_area(between two rectangles)).\\n\\n# Approach\\n\\nFirstly,we will calculate the area1 and area2 by simple mathematics .i.e. length * width .Now our main task is compute the common area.There are few cases that can exist between two rectangles that are as follows:\\n\\n**Case 1:** Rectangle 1 is enclosed in rectangle 2.\\n- Condition: ax1>=bx1 && ax2<=bx2 && ay1>=by1 && ay2<=by2\\n- Common Area:Area 1\\n\\n**Case 2:** Rectangle 2 is enclosed in rectangle 1.\\n- Condition: bx1>=ax1 && bx2<=ax2 && by1>=ay1 && by2<=ay2\\n- Common Area:Area 2\\n\\n**Case 3:** Rectangle 1 and rectangle 2 share some common area.\\n- Condition: max(ax1,bx1)<= min(ax2,bx2)  &&   max(ay1,by1)<= min(ay2,by2)\\n- common_area= (max(ax1,bx1)- min(ax2,bx2))*(max(ay1,by1)- min(ay2,by2))\\n     \\n**Case 4:** Rectangle 1 and rectangle 2 has no common area.\\n- Common area=0\\n\\n# Complexity\\n- Time complexity:\\nTime complexity will be O(1).\\n\\n- Space complexity:\\nSpace complexity will be O(1).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        long long area1=(ax2-ax1)*(ay2-ay1);\\n         long long area2=(bx2-bx1)*(by2-by1);\\n        long long common_area;\\n\\n        if( ax1>=bx1 && ax2<=bx2 && ay1>=by1 && ay2<=by2){\\n            common_area= area1;\\n        }\\n        else if( bx1>=ax1 && bx2<=ax2 && by1>=ay1 && by2<=ay2){\\n            common_area= area2;\\n        }\\n        else if( max(ax1,bx1)<= min(ax2,bx2)  &&   max(ay1,by1)<= min(ay2,by2)){\\n            common_area= (max(ax1,bx1)- min(ax2,bx2))*(max(ay1,by1)- min(ay2,by2));\\n        }\\n        else common_area=0;\\n\\n        return area1+area2-common_area;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        long long area1=(ax2-ax1)*(ay2-ay1);\\n         long long area2=(bx2-bx1)*(by2-by1);\\n        long long common_area;\\n\\n        if( ax1>=bx1 && ax2<=bx2 && ay1>=by1 && ay2<=by2){\\n            common_area= area1;\\n        }\\n        else if( bx1>=ax1 && bx2<=ax2 && by1>=ay1 && by2<=ay2){\\n            common_area= area2;\\n        }\\n        else if( max(ax1,bx1)<= min(ax2,bx2)  &&   max(ay1,by1)<= min(ay2,by2)){\\n            common_area= (max(ax1,bx1)- min(ax2,bx2))*(max(ay1,by1)- min(ay2,by2));\\n        }\\n        else common_area=0;\\n\\n        return area1+area2-common_area;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3131841,
                "title": "please-click-me",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```Rust []\\nimpl Solution {\\n    pub fn compute_area(ax1: i32, ay1: i32, ax2: i32, ay2: i32, bx1: i32, by1: i32, bx2: i32, by2: i32) -> i32 {\\n        (ax2 - ax1) * (ay2 - ay1) + (bx2 - bx1) * (by2 - by1) - (0.max(ax2.min(bx2) - ax1.max(bx1)) * 0.max(ay2.min(by2) - ay1.max(by1)))\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```Rust []\\nimpl Solution {\\n    pub fn compute_area(ax1: i32, ay1: i32, ax2: i32, ay2: i32, bx1: i32, by1: i32, bx2: i32, by2: i32) -> i32 {\\n        (ax2 - ax1) * (ay2 - ay1) + (bx2 - bx1) * (by2 - by1) - (0.max(ax2.min(bx2) - ax1.max(bx1)) * 0.max(ay2.min(by2) - ay1.max(by1)))\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2830556,
                "title": "simple-approach-3-line-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        if(ay1>=by2 || bx1>=ax2 || by1>=ay2 || bx2<=ax1){\\n            return ((ax2-ax1)*(ay2-ay1))+((bx2-bx1)*(by2-by1));\\n        }\\n        return ((ax2-ax1)*(ay2-ay1))+((bx2-bx1)*(by2-by1))-(min(ay2, by2)-max(ay1, by1))*(min(ax2, bx2)-max(bx1, ax1));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        if(ay1>=by2 || bx1>=ax2 || by1>=ay2 || bx2<=ax1){\\n            return ((ax2-ax1)*(ay2-ay1))+((bx2-bx1)*(by2-by1));\\n        }\\n        return ((ax2-ax1)*(ay2-ay1))+((bx2-bx1)*(by2-by1))-(min(ay2, by2)-max(ay1, by1))*(min(ax2, bx2)-max(bx1, ax1));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2828629,
                "title": "c-one-liner",
                "content": "```class Solution {\\npublic:\\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {   \\n\\t\\treturn (ax2-ax1)*(ay2-ay1)+(bx2-bx1)*(by2-by1)-max(min(ax2,bx2)-max(ax1,bx1),0)*max(min(ay2,by2)-max(ay1,by1),0);\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```class Solution {\\npublic:\\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {   \\n\\t\\treturn (ax2-ax1)*(ay2-ay1)+(bx2-bx1)*(by2-by1)-max(min(ax2,bx2)-max(ax1,bx1),0)*max(min(ay2,by2)-max(ay1,by1),0);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2828514,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        int ar1=(ax2-ax1)*(ay2-ay1);\\n        int ar2=(bx2-bx1)*(by2-by1);\\n        int a=min(ax2,bx2)-max(ax1,bx1);\\n        int b=min(ay2,by2)-max(ay1,by1);\\n         \\n        int ar=max(a,0)*max(b,0);\\n            \\n        int ans=ar1+ar2-ar;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int computeArea(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) {\\n        int ar1=(ax2-ax1)*(ay2-ay1);\\n        int ar2=(bx2-bx1)*(by2-by1);\\n        int a=min(ax2,bx2)-max(ax1,bx1);\\n        int b=min(ay2,by2)-max(ay1,by1);\\n         \\n        int ar=max(a,0)*max(b,0);\\n            \\n        int ans=ar1+ar2-ar;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564793,
                "content": [
                    {
                        "username": "shintaroid",
                        "content": "We should consider the following two problems:\\n\\n 1. How to know whether the two rectangle areas are not overlapped.\\n 2. If the two rectangle areas are overlapped, how to calculate the overlapped area.\\n\\nFor me, both situations are not intuitive to see. I tried the intuitive solution, but I gave up as it needs too many lines of code. Here I write down a smarter way in plain language which is actually from other user's codes to solve the problem.\\n\\n1, To know whether the two areas are not overlapped: \\n\\n - We actually only need to consider four situations: B>=H or E>=C or F>=D or A>=G. For example, if B is larger than H, the area (A,B,C,D) is definitely not overlapped with area (E,F,G,H), and we even know that area (A,B,C,D) is on the upper area of the plot compared with area (E,F,G,H). You can also check if other situations work.\\n\\n2, To calculate the overlapped area:\\n\\n - When the two areas are overlapped, we only need to know the bottom left corner and top right corner of the overlapped area: the larger one of A and E, the larger one of B and F, the smaller one of C and G, and the smaller one of D and H. For example, in the case of the given figure of the original problem, we just consider the point (E,B) and the point (C,H), and the overlapped area is (E,B,C,H) which could be calculated intuitively. So how about other kinds of overlapping? The formula given above never change! You can try imagining other kind of  overlapped area, you will see that in any case we only need to know max(A,E), max(B,F), min(C,G), and min(D,H) to calculate the overlapped area.\\n\\nI don't consider this problem as an easy one, if you try to solve it intuitively."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Two know if they are overlapping, we can do like this \\nfor X coordinate -> max(ax1,bx1)<min(ax2,bx2)\\nfor y coordinate -> max(ay1,by1)<min(ay2,by2)"
                    },
                    {
                        "username": "madokamylove",
                        "content": "In the statement, it says\\n*\"Each rectangle is defined by its bottom left corner and top right corner\"*\\n\\nHowever, there are test cases like \\n\\nInput:\\t-2, -2, 2, 2, -3, 3, -4, 4\\n\\nWhich is wrong, because there are no rectangles with bottom left corner (-3, 3) and top right corner (-4, 4)."
                    },
                    {
                        "username": "isinghabhishek",
                        "content": "https://leetcode.com/problems/rectangle-area/solutions/3114906/java-easy-to-understand-beats-100-simple-approach-beginner-friendly-2ms/"
                    },
                    {
                        "username": "kevv96",
                        "content": "answer = sum of two areas - overlap area\\n\\noverlap rectangle coordinates:\\n        cx1 = max(ax1, bx1)\\n        cx2 = min(ax2, bx2)\\n        cy1 = max(ay1, by1)\\n        cy2 = min(ay2, by2)\\n\\noverlap area = max(0, cx2 - cx1) * max(0, cy2 - cy1)\\n\\ndone!"
                    },
                    {
                        "username": "kevv96",
                        "content": "[@ayush391](/ayush391) You are welcome mate \\uD83D\\uDE0A"
                    },
                    {
                        "username": "ayush391",
                        "content": "A simple and concise answer. thnks mate."
                    },
                    {
                        "username": "varunshrivastava2706",
                        "content": "BORINGGGG........................"
                    },
                    {
                        "username": "riyan372828",
                        "content": "\\n**Watch this video for the better explanation of the code.**\\nhttps://www.youtube.com/watch?v=0wjT7XQfXEo\\n\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "I though if a a rectangle has points as x1 , y1 , x2 , y2 \\nthe the area covered by it would be (x2 - x1  + 1) * (y2 - y1 + 1) which is giving wrong ans.\\nAnd (x2 - x1) * (y2 - y1) is giving correct ans! \\nHow ?\\n\\nSay x1 == x2 and y1 == y2 then area covered should be 1 , not 0! Doesn\\'t make sense."
                    },
                    {
                        "username": "sigrayornot",
                        "content": "if x1 == x2 or y1 == y2, then side length = 0, then area = 0 * another side => area = 0"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "[@grkem](/grkem) Thanks now I see , I was actually considering area to the no of points. My bad."
                    },
                    {
                        "username": "Peachyy",
                        "content": "If x1 == x2 and y1 == y2 it would not be a rectangle but a point on the grid"
                    },
                    {
                        "username": "grkem",
                        "content": "You are thinking about something else, counting the number of points on a rectangular shape on a grid. I am not even sure if that is called \"area\". The question defines a continuous plane, not a discrete one."
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "rectange to rectangle, rectange to circle, circle to circle, triangle to rectangle, ball to rectangle ..etc...\\nFor game deverloper only."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "collision detection !!"
                    },
                    {
                        "username": "user4898sC",
                        "content": "Why is this medium?"
                    },
                    {
                        "username": "usmonali",
                        "content": "what do you mean? is it so easy? if yes, then I agree"
                    },
                    {
                        "username": "drap5468",
                        "content": "It\\'s certainly not the hardest medium in the world, but I think \"medium\" is fair, because it requires a bit of thought to figure out a good way of calculating the overlapping area.\\n\\nGenerally speaking, \"easy\" problems are those that essentially require 0 creativity, just applying something that (leetcode expects) you already know. The small amount of thought required to figure out a new problem you\\'ve never seen before, like calculating the overlapping area, is enough to count as a medium IMO"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\n\\nStep 1 : Find the area of Rectangle 1 assume AR1\\nStep 2 : Find the area of Rectangle 2 assume AR2\\nStep 3 : Try to find a way to tell if the rectangles are overlapping or not (if they are not, return AR1 + AR2)\\nStep 3 : Find the area of intersecting rectangle formed assume IR and return AR1 + AR2 - IR.\\n\\n\\nHINT 2:\\nAll the steps might seem really easy except the third one.\\nTo find if the rectangles overlap.... find the maximum of their left extremes(L) and minimum of their right extremes(R) and similarly take the minimum of top extremes(T) and maximum of bottom extremes(B) co-ordinates \\nAnd now if the difference between R and L comes out to be negative and similarly the difference between T and B comes out to be negative, the rectangles do not intersect / overlap.\\n"
                    },
                    {
                        "username": "Ayush_km_gupta",
                        "content": "HII NICE QUESTION HELP IN INTERVIEW PREPRATION>"
                    }
                ]
            },
            {
                "id": 1565006,
                "content": [
                    {
                        "username": "shintaroid",
                        "content": "We should consider the following two problems:\\n\\n 1. How to know whether the two rectangle areas are not overlapped.\\n 2. If the two rectangle areas are overlapped, how to calculate the overlapped area.\\n\\nFor me, both situations are not intuitive to see. I tried the intuitive solution, but I gave up as it needs too many lines of code. Here I write down a smarter way in plain language which is actually from other user's codes to solve the problem.\\n\\n1, To know whether the two areas are not overlapped: \\n\\n - We actually only need to consider four situations: B>=H or E>=C or F>=D or A>=G. For example, if B is larger than H, the area (A,B,C,D) is definitely not overlapped with area (E,F,G,H), and we even know that area (A,B,C,D) is on the upper area of the plot compared with area (E,F,G,H). You can also check if other situations work.\\n\\n2, To calculate the overlapped area:\\n\\n - When the two areas are overlapped, we only need to know the bottom left corner and top right corner of the overlapped area: the larger one of A and E, the larger one of B and F, the smaller one of C and G, and the smaller one of D and H. For example, in the case of the given figure of the original problem, we just consider the point (E,B) and the point (C,H), and the overlapped area is (E,B,C,H) which could be calculated intuitively. So how about other kinds of overlapping? The formula given above never change! You can try imagining other kind of  overlapped area, you will see that in any case we only need to know max(A,E), max(B,F), min(C,G), and min(D,H) to calculate the overlapped area.\\n\\nI don't consider this problem as an easy one, if you try to solve it intuitively."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Two know if they are overlapping, we can do like this \\nfor X coordinate -> max(ax1,bx1)<min(ax2,bx2)\\nfor y coordinate -> max(ay1,by1)<min(ay2,by2)"
                    },
                    {
                        "username": "madokamylove",
                        "content": "In the statement, it says\\n*\"Each rectangle is defined by its bottom left corner and top right corner\"*\\n\\nHowever, there are test cases like \\n\\nInput:\\t-2, -2, 2, 2, -3, 3, -4, 4\\n\\nWhich is wrong, because there are no rectangles with bottom left corner (-3, 3) and top right corner (-4, 4)."
                    },
                    {
                        "username": "isinghabhishek",
                        "content": "https://leetcode.com/problems/rectangle-area/solutions/3114906/java-easy-to-understand-beats-100-simple-approach-beginner-friendly-2ms/"
                    },
                    {
                        "username": "kevv96",
                        "content": "answer = sum of two areas - overlap area\\n\\noverlap rectangle coordinates:\\n        cx1 = max(ax1, bx1)\\n        cx2 = min(ax2, bx2)\\n        cy1 = max(ay1, by1)\\n        cy2 = min(ay2, by2)\\n\\noverlap area = max(0, cx2 - cx1) * max(0, cy2 - cy1)\\n\\ndone!"
                    },
                    {
                        "username": "kevv96",
                        "content": "[@ayush391](/ayush391) You are welcome mate \\uD83D\\uDE0A"
                    },
                    {
                        "username": "ayush391",
                        "content": "A simple and concise answer. thnks mate."
                    },
                    {
                        "username": "varunshrivastava2706",
                        "content": "BORINGGGG........................"
                    },
                    {
                        "username": "riyan372828",
                        "content": "\\n**Watch this video for the better explanation of the code.**\\nhttps://www.youtube.com/watch?v=0wjT7XQfXEo\\n\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "I though if a a rectangle has points as x1 , y1 , x2 , y2 \\nthe the area covered by it would be (x2 - x1  + 1) * (y2 - y1 + 1) which is giving wrong ans.\\nAnd (x2 - x1) * (y2 - y1) is giving correct ans! \\nHow ?\\n\\nSay x1 == x2 and y1 == y2 then area covered should be 1 , not 0! Doesn\\'t make sense."
                    },
                    {
                        "username": "sigrayornot",
                        "content": "if x1 == x2 or y1 == y2, then side length = 0, then area = 0 * another side => area = 0"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "[@grkem](/grkem) Thanks now I see , I was actually considering area to the no of points. My bad."
                    },
                    {
                        "username": "Peachyy",
                        "content": "If x1 == x2 and y1 == y2 it would not be a rectangle but a point on the grid"
                    },
                    {
                        "username": "grkem",
                        "content": "You are thinking about something else, counting the number of points on a rectangular shape on a grid. I am not even sure if that is called \"area\". The question defines a continuous plane, not a discrete one."
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "rectange to rectangle, rectange to circle, circle to circle, triangle to rectangle, ball to rectangle ..etc...\\nFor game deverloper only."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "collision detection !!"
                    },
                    {
                        "username": "user4898sC",
                        "content": "Why is this medium?"
                    },
                    {
                        "username": "usmonali",
                        "content": "what do you mean? is it so easy? if yes, then I agree"
                    },
                    {
                        "username": "drap5468",
                        "content": "It\\'s certainly not the hardest medium in the world, but I think \"medium\" is fair, because it requires a bit of thought to figure out a good way of calculating the overlapping area.\\n\\nGenerally speaking, \"easy\" problems are those that essentially require 0 creativity, just applying something that (leetcode expects) you already know. The small amount of thought required to figure out a new problem you\\'ve never seen before, like calculating the overlapping area, is enough to count as a medium IMO"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\n\\nStep 1 : Find the area of Rectangle 1 assume AR1\\nStep 2 : Find the area of Rectangle 2 assume AR2\\nStep 3 : Try to find a way to tell if the rectangles are overlapping or not (if they are not, return AR1 + AR2)\\nStep 3 : Find the area of intersecting rectangle formed assume IR and return AR1 + AR2 - IR.\\n\\n\\nHINT 2:\\nAll the steps might seem really easy except the third one.\\nTo find if the rectangles overlap.... find the maximum of their left extremes(L) and minimum of their right extremes(R) and similarly take the minimum of top extremes(T) and maximum of bottom extremes(B) co-ordinates \\nAnd now if the difference between R and L comes out to be negative and similarly the difference between T and B comes out to be negative, the rectangles do not intersect / overlap.\\n"
                    },
                    {
                        "username": "Ayush_km_gupta",
                        "content": "HII NICE QUESTION HELP IN INTERVIEW PREPRATION>"
                    }
                ]
            },
            {
                "id": 1686985,
                "content": [
                    {
                        "username": "shintaroid",
                        "content": "We should consider the following two problems:\\n\\n 1. How to know whether the two rectangle areas are not overlapped.\\n 2. If the two rectangle areas are overlapped, how to calculate the overlapped area.\\n\\nFor me, both situations are not intuitive to see. I tried the intuitive solution, but I gave up as it needs too many lines of code. Here I write down a smarter way in plain language which is actually from other user's codes to solve the problem.\\n\\n1, To know whether the two areas are not overlapped: \\n\\n - We actually only need to consider four situations: B>=H or E>=C or F>=D or A>=G. For example, if B is larger than H, the area (A,B,C,D) is definitely not overlapped with area (E,F,G,H), and we even know that area (A,B,C,D) is on the upper area of the plot compared with area (E,F,G,H). You can also check if other situations work.\\n\\n2, To calculate the overlapped area:\\n\\n - When the two areas are overlapped, we only need to know the bottom left corner and top right corner of the overlapped area: the larger one of A and E, the larger one of B and F, the smaller one of C and G, and the smaller one of D and H. For example, in the case of the given figure of the original problem, we just consider the point (E,B) and the point (C,H), and the overlapped area is (E,B,C,H) which could be calculated intuitively. So how about other kinds of overlapping? The formula given above never change! You can try imagining other kind of  overlapped area, you will see that in any case we only need to know max(A,E), max(B,F), min(C,G), and min(D,H) to calculate the overlapped area.\\n\\nI don't consider this problem as an easy one, if you try to solve it intuitively."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Two know if they are overlapping, we can do like this \\nfor X coordinate -> max(ax1,bx1)<min(ax2,bx2)\\nfor y coordinate -> max(ay1,by1)<min(ay2,by2)"
                    },
                    {
                        "username": "madokamylove",
                        "content": "In the statement, it says\\n*\"Each rectangle is defined by its bottom left corner and top right corner\"*\\n\\nHowever, there are test cases like \\n\\nInput:\\t-2, -2, 2, 2, -3, 3, -4, 4\\n\\nWhich is wrong, because there are no rectangles with bottom left corner (-3, 3) and top right corner (-4, 4)."
                    },
                    {
                        "username": "isinghabhishek",
                        "content": "https://leetcode.com/problems/rectangle-area/solutions/3114906/java-easy-to-understand-beats-100-simple-approach-beginner-friendly-2ms/"
                    },
                    {
                        "username": "kevv96",
                        "content": "answer = sum of two areas - overlap area\\n\\noverlap rectangle coordinates:\\n        cx1 = max(ax1, bx1)\\n        cx2 = min(ax2, bx2)\\n        cy1 = max(ay1, by1)\\n        cy2 = min(ay2, by2)\\n\\noverlap area = max(0, cx2 - cx1) * max(0, cy2 - cy1)\\n\\ndone!"
                    },
                    {
                        "username": "kevv96",
                        "content": "[@ayush391](/ayush391) You are welcome mate \\uD83D\\uDE0A"
                    },
                    {
                        "username": "ayush391",
                        "content": "A simple and concise answer. thnks mate."
                    },
                    {
                        "username": "varunshrivastava2706",
                        "content": "BORINGGGG........................"
                    },
                    {
                        "username": "riyan372828",
                        "content": "\\n**Watch this video for the better explanation of the code.**\\nhttps://www.youtube.com/watch?v=0wjT7XQfXEo\\n\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "I though if a a rectangle has points as x1 , y1 , x2 , y2 \\nthe the area covered by it would be (x2 - x1  + 1) * (y2 - y1 + 1) which is giving wrong ans.\\nAnd (x2 - x1) * (y2 - y1) is giving correct ans! \\nHow ?\\n\\nSay x1 == x2 and y1 == y2 then area covered should be 1 , not 0! Doesn\\'t make sense."
                    },
                    {
                        "username": "sigrayornot",
                        "content": "if x1 == x2 or y1 == y2, then side length = 0, then area = 0 * another side => area = 0"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "[@grkem](/grkem) Thanks now I see , I was actually considering area to the no of points. My bad."
                    },
                    {
                        "username": "Peachyy",
                        "content": "If x1 == x2 and y1 == y2 it would not be a rectangle but a point on the grid"
                    },
                    {
                        "username": "grkem",
                        "content": "You are thinking about something else, counting the number of points on a rectangular shape on a grid. I am not even sure if that is called \"area\". The question defines a continuous plane, not a discrete one."
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "rectange to rectangle, rectange to circle, circle to circle, triangle to rectangle, ball to rectangle ..etc...\\nFor game deverloper only."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "collision detection !!"
                    },
                    {
                        "username": "user4898sC",
                        "content": "Why is this medium?"
                    },
                    {
                        "username": "usmonali",
                        "content": "what do you mean? is it so easy? if yes, then I agree"
                    },
                    {
                        "username": "drap5468",
                        "content": "It\\'s certainly not the hardest medium in the world, but I think \"medium\" is fair, because it requires a bit of thought to figure out a good way of calculating the overlapping area.\\n\\nGenerally speaking, \"easy\" problems are those that essentially require 0 creativity, just applying something that (leetcode expects) you already know. The small amount of thought required to figure out a new problem you\\'ve never seen before, like calculating the overlapping area, is enough to count as a medium IMO"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\n\\nStep 1 : Find the area of Rectangle 1 assume AR1\\nStep 2 : Find the area of Rectangle 2 assume AR2\\nStep 3 : Try to find a way to tell if the rectangles are overlapping or not (if they are not, return AR1 + AR2)\\nStep 3 : Find the area of intersecting rectangle formed assume IR and return AR1 + AR2 - IR.\\n\\n\\nHINT 2:\\nAll the steps might seem really easy except the third one.\\nTo find if the rectangles overlap.... find the maximum of their left extremes(L) and minimum of their right extremes(R) and similarly take the minimum of top extremes(T) and maximum of bottom extremes(B) co-ordinates \\nAnd now if the difference between R and L comes out to be negative and similarly the difference between T and B comes out to be negative, the rectangles do not intersect / overlap.\\n"
                    },
                    {
                        "username": "Ayush_km_gupta",
                        "content": "HII NICE QUESTION HELP IN INTERVIEW PREPRATION>"
                    }
                ]
            },
            {
                "id": 1686981,
                "content": [
                    {
                        "username": "shintaroid",
                        "content": "We should consider the following two problems:\\n\\n 1. How to know whether the two rectangle areas are not overlapped.\\n 2. If the two rectangle areas are overlapped, how to calculate the overlapped area.\\n\\nFor me, both situations are not intuitive to see. I tried the intuitive solution, but I gave up as it needs too many lines of code. Here I write down a smarter way in plain language which is actually from other user's codes to solve the problem.\\n\\n1, To know whether the two areas are not overlapped: \\n\\n - We actually only need to consider four situations: B>=H or E>=C or F>=D or A>=G. For example, if B is larger than H, the area (A,B,C,D) is definitely not overlapped with area (E,F,G,H), and we even know that area (A,B,C,D) is on the upper area of the plot compared with area (E,F,G,H). You can also check if other situations work.\\n\\n2, To calculate the overlapped area:\\n\\n - When the two areas are overlapped, we only need to know the bottom left corner and top right corner of the overlapped area: the larger one of A and E, the larger one of B and F, the smaller one of C and G, and the smaller one of D and H. For example, in the case of the given figure of the original problem, we just consider the point (E,B) and the point (C,H), and the overlapped area is (E,B,C,H) which could be calculated intuitively. So how about other kinds of overlapping? The formula given above never change! You can try imagining other kind of  overlapped area, you will see that in any case we only need to know max(A,E), max(B,F), min(C,G), and min(D,H) to calculate the overlapped area.\\n\\nI don't consider this problem as an easy one, if you try to solve it intuitively."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Two know if they are overlapping, we can do like this \\nfor X coordinate -> max(ax1,bx1)<min(ax2,bx2)\\nfor y coordinate -> max(ay1,by1)<min(ay2,by2)"
                    },
                    {
                        "username": "madokamylove",
                        "content": "In the statement, it says\\n*\"Each rectangle is defined by its bottom left corner and top right corner\"*\\n\\nHowever, there are test cases like \\n\\nInput:\\t-2, -2, 2, 2, -3, 3, -4, 4\\n\\nWhich is wrong, because there are no rectangles with bottom left corner (-3, 3) and top right corner (-4, 4)."
                    },
                    {
                        "username": "isinghabhishek",
                        "content": "https://leetcode.com/problems/rectangle-area/solutions/3114906/java-easy-to-understand-beats-100-simple-approach-beginner-friendly-2ms/"
                    },
                    {
                        "username": "kevv96",
                        "content": "answer = sum of two areas - overlap area\\n\\noverlap rectangle coordinates:\\n        cx1 = max(ax1, bx1)\\n        cx2 = min(ax2, bx2)\\n        cy1 = max(ay1, by1)\\n        cy2 = min(ay2, by2)\\n\\noverlap area = max(0, cx2 - cx1) * max(0, cy2 - cy1)\\n\\ndone!"
                    },
                    {
                        "username": "kevv96",
                        "content": "[@ayush391](/ayush391) You are welcome mate \\uD83D\\uDE0A"
                    },
                    {
                        "username": "ayush391",
                        "content": "A simple and concise answer. thnks mate."
                    },
                    {
                        "username": "varunshrivastava2706",
                        "content": "BORINGGGG........................"
                    },
                    {
                        "username": "riyan372828",
                        "content": "\\n**Watch this video for the better explanation of the code.**\\nhttps://www.youtube.com/watch?v=0wjT7XQfXEo\\n\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "I though if a a rectangle has points as x1 , y1 , x2 , y2 \\nthe the area covered by it would be (x2 - x1  + 1) * (y2 - y1 + 1) which is giving wrong ans.\\nAnd (x2 - x1) * (y2 - y1) is giving correct ans! \\nHow ?\\n\\nSay x1 == x2 and y1 == y2 then area covered should be 1 , not 0! Doesn\\'t make sense."
                    },
                    {
                        "username": "sigrayornot",
                        "content": "if x1 == x2 or y1 == y2, then side length = 0, then area = 0 * another side => area = 0"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "[@grkem](/grkem) Thanks now I see , I was actually considering area to the no of points. My bad."
                    },
                    {
                        "username": "Peachyy",
                        "content": "If x1 == x2 and y1 == y2 it would not be a rectangle but a point on the grid"
                    },
                    {
                        "username": "grkem",
                        "content": "You are thinking about something else, counting the number of points on a rectangular shape on a grid. I am not even sure if that is called \"area\". The question defines a continuous plane, not a discrete one."
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "rectange to rectangle, rectange to circle, circle to circle, triangle to rectangle, ball to rectangle ..etc...\\nFor game deverloper only."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "collision detection !!"
                    },
                    {
                        "username": "user4898sC",
                        "content": "Why is this medium?"
                    },
                    {
                        "username": "usmonali",
                        "content": "what do you mean? is it so easy? if yes, then I agree"
                    },
                    {
                        "username": "drap5468",
                        "content": "It\\'s certainly not the hardest medium in the world, but I think \"medium\" is fair, because it requires a bit of thought to figure out a good way of calculating the overlapping area.\\n\\nGenerally speaking, \"easy\" problems are those that essentially require 0 creativity, just applying something that (leetcode expects) you already know. The small amount of thought required to figure out a new problem you\\'ve never seen before, like calculating the overlapping area, is enough to count as a medium IMO"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\n\\nStep 1 : Find the area of Rectangle 1 assume AR1\\nStep 2 : Find the area of Rectangle 2 assume AR2\\nStep 3 : Try to find a way to tell if the rectangles are overlapping or not (if they are not, return AR1 + AR2)\\nStep 3 : Find the area of intersecting rectangle formed assume IR and return AR1 + AR2 - IR.\\n\\n\\nHINT 2:\\nAll the steps might seem really easy except the third one.\\nTo find if the rectangles overlap.... find the maximum of their left extremes(L) and minimum of their right extremes(R) and similarly take the minimum of top extremes(T) and maximum of bottom extremes(B) co-ordinates \\nAnd now if the difference between R and L comes out to be negative and similarly the difference between T and B comes out to be negative, the rectangles do not intersect / overlap.\\n"
                    },
                    {
                        "username": "Ayush_km_gupta",
                        "content": "HII NICE QUESTION HELP IN INTERVIEW PREPRATION>"
                    }
                ]
            },
            {
                "id": 1687585,
                "content": [
                    {
                        "username": "shintaroid",
                        "content": "We should consider the following two problems:\\n\\n 1. How to know whether the two rectangle areas are not overlapped.\\n 2. If the two rectangle areas are overlapped, how to calculate the overlapped area.\\n\\nFor me, both situations are not intuitive to see. I tried the intuitive solution, but I gave up as it needs too many lines of code. Here I write down a smarter way in plain language which is actually from other user's codes to solve the problem.\\n\\n1, To know whether the two areas are not overlapped: \\n\\n - We actually only need to consider four situations: B>=H or E>=C or F>=D or A>=G. For example, if B is larger than H, the area (A,B,C,D) is definitely not overlapped with area (E,F,G,H), and we even know that area (A,B,C,D) is on the upper area of the plot compared with area (E,F,G,H). You can also check if other situations work.\\n\\n2, To calculate the overlapped area:\\n\\n - When the two areas are overlapped, we only need to know the bottom left corner and top right corner of the overlapped area: the larger one of A and E, the larger one of B and F, the smaller one of C and G, and the smaller one of D and H. For example, in the case of the given figure of the original problem, we just consider the point (E,B) and the point (C,H), and the overlapped area is (E,B,C,H) which could be calculated intuitively. So how about other kinds of overlapping? The formula given above never change! You can try imagining other kind of  overlapped area, you will see that in any case we only need to know max(A,E), max(B,F), min(C,G), and min(D,H) to calculate the overlapped area.\\n\\nI don't consider this problem as an easy one, if you try to solve it intuitively."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Two know if they are overlapping, we can do like this \\nfor X coordinate -> max(ax1,bx1)<min(ax2,bx2)\\nfor y coordinate -> max(ay1,by1)<min(ay2,by2)"
                    },
                    {
                        "username": "madokamylove",
                        "content": "In the statement, it says\\n*\"Each rectangle is defined by its bottom left corner and top right corner\"*\\n\\nHowever, there are test cases like \\n\\nInput:\\t-2, -2, 2, 2, -3, 3, -4, 4\\n\\nWhich is wrong, because there are no rectangles with bottom left corner (-3, 3) and top right corner (-4, 4)."
                    },
                    {
                        "username": "isinghabhishek",
                        "content": "https://leetcode.com/problems/rectangle-area/solutions/3114906/java-easy-to-understand-beats-100-simple-approach-beginner-friendly-2ms/"
                    },
                    {
                        "username": "kevv96",
                        "content": "answer = sum of two areas - overlap area\\n\\noverlap rectangle coordinates:\\n        cx1 = max(ax1, bx1)\\n        cx2 = min(ax2, bx2)\\n        cy1 = max(ay1, by1)\\n        cy2 = min(ay2, by2)\\n\\noverlap area = max(0, cx2 - cx1) * max(0, cy2 - cy1)\\n\\ndone!"
                    },
                    {
                        "username": "kevv96",
                        "content": "[@ayush391](/ayush391) You are welcome mate \\uD83D\\uDE0A"
                    },
                    {
                        "username": "ayush391",
                        "content": "A simple and concise answer. thnks mate."
                    },
                    {
                        "username": "varunshrivastava2706",
                        "content": "BORINGGGG........................"
                    },
                    {
                        "username": "riyan372828",
                        "content": "\\n**Watch this video for the better explanation of the code.**\\nhttps://www.youtube.com/watch?v=0wjT7XQfXEo\\n\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "I though if a a rectangle has points as x1 , y1 , x2 , y2 \\nthe the area covered by it would be (x2 - x1  + 1) * (y2 - y1 + 1) which is giving wrong ans.\\nAnd (x2 - x1) * (y2 - y1) is giving correct ans! \\nHow ?\\n\\nSay x1 == x2 and y1 == y2 then area covered should be 1 , not 0! Doesn\\'t make sense."
                    },
                    {
                        "username": "sigrayornot",
                        "content": "if x1 == x2 or y1 == y2, then side length = 0, then area = 0 * another side => area = 0"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "[@grkem](/grkem) Thanks now I see , I was actually considering area to the no of points. My bad."
                    },
                    {
                        "username": "Peachyy",
                        "content": "If x1 == x2 and y1 == y2 it would not be a rectangle but a point on the grid"
                    },
                    {
                        "username": "grkem",
                        "content": "You are thinking about something else, counting the number of points on a rectangular shape on a grid. I am not even sure if that is called \"area\". The question defines a continuous plane, not a discrete one."
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "rectange to rectangle, rectange to circle, circle to circle, triangle to rectangle, ball to rectangle ..etc...\\nFor game deverloper only."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "collision detection !!"
                    },
                    {
                        "username": "user4898sC",
                        "content": "Why is this medium?"
                    },
                    {
                        "username": "usmonali",
                        "content": "what do you mean? is it so easy? if yes, then I agree"
                    },
                    {
                        "username": "drap5468",
                        "content": "It\\'s certainly not the hardest medium in the world, but I think \"medium\" is fair, because it requires a bit of thought to figure out a good way of calculating the overlapping area.\\n\\nGenerally speaking, \"easy\" problems are those that essentially require 0 creativity, just applying something that (leetcode expects) you already know. The small amount of thought required to figure out a new problem you\\'ve never seen before, like calculating the overlapping area, is enough to count as a medium IMO"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\n\\nStep 1 : Find the area of Rectangle 1 assume AR1\\nStep 2 : Find the area of Rectangle 2 assume AR2\\nStep 3 : Try to find a way to tell if the rectangles are overlapping or not (if they are not, return AR1 + AR2)\\nStep 3 : Find the area of intersecting rectangle formed assume IR and return AR1 + AR2 - IR.\\n\\n\\nHINT 2:\\nAll the steps might seem really easy except the third one.\\nTo find if the rectangles overlap.... find the maximum of their left extremes(L) and minimum of their right extremes(R) and similarly take the minimum of top extremes(T) and maximum of bottom extremes(B) co-ordinates \\nAnd now if the difference between R and L comes out to be negative and similarly the difference between T and B comes out to be negative, the rectangles do not intersect / overlap.\\n"
                    },
                    {
                        "username": "Ayush_km_gupta",
                        "content": "HII NICE QUESTION HELP IN INTERVIEW PREPRATION>"
                    }
                ]
            },
            {
                "id": 1687148,
                "content": [
                    {
                        "username": "shintaroid",
                        "content": "We should consider the following two problems:\\n\\n 1. How to know whether the two rectangle areas are not overlapped.\\n 2. If the two rectangle areas are overlapped, how to calculate the overlapped area.\\n\\nFor me, both situations are not intuitive to see. I tried the intuitive solution, but I gave up as it needs too many lines of code. Here I write down a smarter way in plain language which is actually from other user's codes to solve the problem.\\n\\n1, To know whether the two areas are not overlapped: \\n\\n - We actually only need to consider four situations: B>=H or E>=C or F>=D or A>=G. For example, if B is larger than H, the area (A,B,C,D) is definitely not overlapped with area (E,F,G,H), and we even know that area (A,B,C,D) is on the upper area of the plot compared with area (E,F,G,H). You can also check if other situations work.\\n\\n2, To calculate the overlapped area:\\n\\n - When the two areas are overlapped, we only need to know the bottom left corner and top right corner of the overlapped area: the larger one of A and E, the larger one of B and F, the smaller one of C and G, and the smaller one of D and H. For example, in the case of the given figure of the original problem, we just consider the point (E,B) and the point (C,H), and the overlapped area is (E,B,C,H) which could be calculated intuitively. So how about other kinds of overlapping? The formula given above never change! You can try imagining other kind of  overlapped area, you will see that in any case we only need to know max(A,E), max(B,F), min(C,G), and min(D,H) to calculate the overlapped area.\\n\\nI don't consider this problem as an easy one, if you try to solve it intuitively."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Two know if they are overlapping, we can do like this \\nfor X coordinate -> max(ax1,bx1)<min(ax2,bx2)\\nfor y coordinate -> max(ay1,by1)<min(ay2,by2)"
                    },
                    {
                        "username": "madokamylove",
                        "content": "In the statement, it says\\n*\"Each rectangle is defined by its bottom left corner and top right corner\"*\\n\\nHowever, there are test cases like \\n\\nInput:\\t-2, -2, 2, 2, -3, 3, -4, 4\\n\\nWhich is wrong, because there are no rectangles with bottom left corner (-3, 3) and top right corner (-4, 4)."
                    },
                    {
                        "username": "isinghabhishek",
                        "content": "https://leetcode.com/problems/rectangle-area/solutions/3114906/java-easy-to-understand-beats-100-simple-approach-beginner-friendly-2ms/"
                    },
                    {
                        "username": "kevv96",
                        "content": "answer = sum of two areas - overlap area\\n\\noverlap rectangle coordinates:\\n        cx1 = max(ax1, bx1)\\n        cx2 = min(ax2, bx2)\\n        cy1 = max(ay1, by1)\\n        cy2 = min(ay2, by2)\\n\\noverlap area = max(0, cx2 - cx1) * max(0, cy2 - cy1)\\n\\ndone!"
                    },
                    {
                        "username": "kevv96",
                        "content": "[@ayush391](/ayush391) You are welcome mate \\uD83D\\uDE0A"
                    },
                    {
                        "username": "ayush391",
                        "content": "A simple and concise answer. thnks mate."
                    },
                    {
                        "username": "varunshrivastava2706",
                        "content": "BORINGGGG........................"
                    },
                    {
                        "username": "riyan372828",
                        "content": "\\n**Watch this video for the better explanation of the code.**\\nhttps://www.youtube.com/watch?v=0wjT7XQfXEo\\n\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "I though if a a rectangle has points as x1 , y1 , x2 , y2 \\nthe the area covered by it would be (x2 - x1  + 1) * (y2 - y1 + 1) which is giving wrong ans.\\nAnd (x2 - x1) * (y2 - y1) is giving correct ans! \\nHow ?\\n\\nSay x1 == x2 and y1 == y2 then area covered should be 1 , not 0! Doesn\\'t make sense."
                    },
                    {
                        "username": "sigrayornot",
                        "content": "if x1 == x2 or y1 == y2, then side length = 0, then area = 0 * another side => area = 0"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "[@grkem](/grkem) Thanks now I see , I was actually considering area to the no of points. My bad."
                    },
                    {
                        "username": "Peachyy",
                        "content": "If x1 == x2 and y1 == y2 it would not be a rectangle but a point on the grid"
                    },
                    {
                        "username": "grkem",
                        "content": "You are thinking about something else, counting the number of points on a rectangular shape on a grid. I am not even sure if that is called \"area\". The question defines a continuous plane, not a discrete one."
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "rectange to rectangle, rectange to circle, circle to circle, triangle to rectangle, ball to rectangle ..etc...\\nFor game deverloper only."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "collision detection !!"
                    },
                    {
                        "username": "user4898sC",
                        "content": "Why is this medium?"
                    },
                    {
                        "username": "usmonali",
                        "content": "what do you mean? is it so easy? if yes, then I agree"
                    },
                    {
                        "username": "drap5468",
                        "content": "It\\'s certainly not the hardest medium in the world, but I think \"medium\" is fair, because it requires a bit of thought to figure out a good way of calculating the overlapping area.\\n\\nGenerally speaking, \"easy\" problems are those that essentially require 0 creativity, just applying something that (leetcode expects) you already know. The small amount of thought required to figure out a new problem you\\'ve never seen before, like calculating the overlapping area, is enough to count as a medium IMO"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\n\\nStep 1 : Find the area of Rectangle 1 assume AR1\\nStep 2 : Find the area of Rectangle 2 assume AR2\\nStep 3 : Try to find a way to tell if the rectangles are overlapping or not (if they are not, return AR1 + AR2)\\nStep 3 : Find the area of intersecting rectangle formed assume IR and return AR1 + AR2 - IR.\\n\\n\\nHINT 2:\\nAll the steps might seem really easy except the third one.\\nTo find if the rectangles overlap.... find the maximum of their left extremes(L) and minimum of their right extremes(R) and similarly take the minimum of top extremes(T) and maximum of bottom extremes(B) co-ordinates \\nAnd now if the difference between R and L comes out to be negative and similarly the difference between T and B comes out to be negative, the rectangles do not intersect / overlap.\\n"
                    },
                    {
                        "username": "Ayush_km_gupta",
                        "content": "HII NICE QUESTION HELP IN INTERVIEW PREPRATION>"
                    }
                ]
            },
            {
                "id": 1573491,
                "content": [
                    {
                        "username": "shintaroid",
                        "content": "We should consider the following two problems:\\n\\n 1. How to know whether the two rectangle areas are not overlapped.\\n 2. If the two rectangle areas are overlapped, how to calculate the overlapped area.\\n\\nFor me, both situations are not intuitive to see. I tried the intuitive solution, but I gave up as it needs too many lines of code. Here I write down a smarter way in plain language which is actually from other user's codes to solve the problem.\\n\\n1, To know whether the two areas are not overlapped: \\n\\n - We actually only need to consider four situations: B>=H or E>=C or F>=D or A>=G. For example, if B is larger than H, the area (A,B,C,D) is definitely not overlapped with area (E,F,G,H), and we even know that area (A,B,C,D) is on the upper area of the plot compared with area (E,F,G,H). You can also check if other situations work.\\n\\n2, To calculate the overlapped area:\\n\\n - When the two areas are overlapped, we only need to know the bottom left corner and top right corner of the overlapped area: the larger one of A and E, the larger one of B and F, the smaller one of C and G, and the smaller one of D and H. For example, in the case of the given figure of the original problem, we just consider the point (E,B) and the point (C,H), and the overlapped area is (E,B,C,H) which could be calculated intuitively. So how about other kinds of overlapping? The formula given above never change! You can try imagining other kind of  overlapped area, you will see that in any case we only need to know max(A,E), max(B,F), min(C,G), and min(D,H) to calculate the overlapped area.\\n\\nI don't consider this problem as an easy one, if you try to solve it intuitively."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Two know if they are overlapping, we can do like this \\nfor X coordinate -> max(ax1,bx1)<min(ax2,bx2)\\nfor y coordinate -> max(ay1,by1)<min(ay2,by2)"
                    },
                    {
                        "username": "madokamylove",
                        "content": "In the statement, it says\\n*\"Each rectangle is defined by its bottom left corner and top right corner\"*\\n\\nHowever, there are test cases like \\n\\nInput:\\t-2, -2, 2, 2, -3, 3, -4, 4\\n\\nWhich is wrong, because there are no rectangles with bottom left corner (-3, 3) and top right corner (-4, 4)."
                    },
                    {
                        "username": "isinghabhishek",
                        "content": "https://leetcode.com/problems/rectangle-area/solutions/3114906/java-easy-to-understand-beats-100-simple-approach-beginner-friendly-2ms/"
                    },
                    {
                        "username": "kevv96",
                        "content": "answer = sum of two areas - overlap area\\n\\noverlap rectangle coordinates:\\n        cx1 = max(ax1, bx1)\\n        cx2 = min(ax2, bx2)\\n        cy1 = max(ay1, by1)\\n        cy2 = min(ay2, by2)\\n\\noverlap area = max(0, cx2 - cx1) * max(0, cy2 - cy1)\\n\\ndone!"
                    },
                    {
                        "username": "kevv96",
                        "content": "[@ayush391](/ayush391) You are welcome mate \\uD83D\\uDE0A"
                    },
                    {
                        "username": "ayush391",
                        "content": "A simple and concise answer. thnks mate."
                    },
                    {
                        "username": "varunshrivastava2706",
                        "content": "BORINGGGG........................"
                    },
                    {
                        "username": "riyan372828",
                        "content": "\\n**Watch this video for the better explanation of the code.**\\nhttps://www.youtube.com/watch?v=0wjT7XQfXEo\\n\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "I though if a a rectangle has points as x1 , y1 , x2 , y2 \\nthe the area covered by it would be (x2 - x1  + 1) * (y2 - y1 + 1) which is giving wrong ans.\\nAnd (x2 - x1) * (y2 - y1) is giving correct ans! \\nHow ?\\n\\nSay x1 == x2 and y1 == y2 then area covered should be 1 , not 0! Doesn\\'t make sense."
                    },
                    {
                        "username": "sigrayornot",
                        "content": "if x1 == x2 or y1 == y2, then side length = 0, then area = 0 * another side => area = 0"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "[@grkem](/grkem) Thanks now I see , I was actually considering area to the no of points. My bad."
                    },
                    {
                        "username": "Peachyy",
                        "content": "If x1 == x2 and y1 == y2 it would not be a rectangle but a point on the grid"
                    },
                    {
                        "username": "grkem",
                        "content": "You are thinking about something else, counting the number of points on a rectangular shape on a grid. I am not even sure if that is called \"area\". The question defines a continuous plane, not a discrete one."
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "rectange to rectangle, rectange to circle, circle to circle, triangle to rectangle, ball to rectangle ..etc...\\nFor game deverloper only."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "collision detection !!"
                    },
                    {
                        "username": "user4898sC",
                        "content": "Why is this medium?"
                    },
                    {
                        "username": "usmonali",
                        "content": "what do you mean? is it so easy? if yes, then I agree"
                    },
                    {
                        "username": "drap5468",
                        "content": "It\\'s certainly not the hardest medium in the world, but I think \"medium\" is fair, because it requires a bit of thought to figure out a good way of calculating the overlapping area.\\n\\nGenerally speaking, \"easy\" problems are those that essentially require 0 creativity, just applying something that (leetcode expects) you already know. The small amount of thought required to figure out a new problem you\\'ve never seen before, like calculating the overlapping area, is enough to count as a medium IMO"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\n\\nStep 1 : Find the area of Rectangle 1 assume AR1\\nStep 2 : Find the area of Rectangle 2 assume AR2\\nStep 3 : Try to find a way to tell if the rectangles are overlapping or not (if they are not, return AR1 + AR2)\\nStep 3 : Find the area of intersecting rectangle formed assume IR and return AR1 + AR2 - IR.\\n\\n\\nHINT 2:\\nAll the steps might seem really easy except the third one.\\nTo find if the rectangles overlap.... find the maximum of their left extremes(L) and minimum of their right extremes(R) and similarly take the minimum of top extremes(T) and maximum of bottom extremes(B) co-ordinates \\nAnd now if the difference between R and L comes out to be negative and similarly the difference between T and B comes out to be negative, the rectangles do not intersect / overlap.\\n"
                    },
                    {
                        "username": "Ayush_km_gupta",
                        "content": "HII NICE QUESTION HELP IN INTERVIEW PREPRATION>"
                    }
                ]
            },
            {
                "id": 1687068,
                "content": [
                    {
                        "username": "shintaroid",
                        "content": "We should consider the following two problems:\\n\\n 1. How to know whether the two rectangle areas are not overlapped.\\n 2. If the two rectangle areas are overlapped, how to calculate the overlapped area.\\n\\nFor me, both situations are not intuitive to see. I tried the intuitive solution, but I gave up as it needs too many lines of code. Here I write down a smarter way in plain language which is actually from other user's codes to solve the problem.\\n\\n1, To know whether the two areas are not overlapped: \\n\\n - We actually only need to consider four situations: B>=H or E>=C or F>=D or A>=G. For example, if B is larger than H, the area (A,B,C,D) is definitely not overlapped with area (E,F,G,H), and we even know that area (A,B,C,D) is on the upper area of the plot compared with area (E,F,G,H). You can also check if other situations work.\\n\\n2, To calculate the overlapped area:\\n\\n - When the two areas are overlapped, we only need to know the bottom left corner and top right corner of the overlapped area: the larger one of A and E, the larger one of B and F, the smaller one of C and G, and the smaller one of D and H. For example, in the case of the given figure of the original problem, we just consider the point (E,B) and the point (C,H), and the overlapped area is (E,B,C,H) which could be calculated intuitively. So how about other kinds of overlapping? The formula given above never change! You can try imagining other kind of  overlapped area, you will see that in any case we only need to know max(A,E), max(B,F), min(C,G), and min(D,H) to calculate the overlapped area.\\n\\nI don't consider this problem as an easy one, if you try to solve it intuitively."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Two know if they are overlapping, we can do like this \\nfor X coordinate -> max(ax1,bx1)<min(ax2,bx2)\\nfor y coordinate -> max(ay1,by1)<min(ay2,by2)"
                    },
                    {
                        "username": "madokamylove",
                        "content": "In the statement, it says\\n*\"Each rectangle is defined by its bottom left corner and top right corner\"*\\n\\nHowever, there are test cases like \\n\\nInput:\\t-2, -2, 2, 2, -3, 3, -4, 4\\n\\nWhich is wrong, because there are no rectangles with bottom left corner (-3, 3) and top right corner (-4, 4)."
                    },
                    {
                        "username": "isinghabhishek",
                        "content": "https://leetcode.com/problems/rectangle-area/solutions/3114906/java-easy-to-understand-beats-100-simple-approach-beginner-friendly-2ms/"
                    },
                    {
                        "username": "kevv96",
                        "content": "answer = sum of two areas - overlap area\\n\\noverlap rectangle coordinates:\\n        cx1 = max(ax1, bx1)\\n        cx2 = min(ax2, bx2)\\n        cy1 = max(ay1, by1)\\n        cy2 = min(ay2, by2)\\n\\noverlap area = max(0, cx2 - cx1) * max(0, cy2 - cy1)\\n\\ndone!"
                    },
                    {
                        "username": "kevv96",
                        "content": "[@ayush391](/ayush391) You are welcome mate \\uD83D\\uDE0A"
                    },
                    {
                        "username": "ayush391",
                        "content": "A simple and concise answer. thnks mate."
                    },
                    {
                        "username": "varunshrivastava2706",
                        "content": "BORINGGGG........................"
                    },
                    {
                        "username": "riyan372828",
                        "content": "\\n**Watch this video for the better explanation of the code.**\\nhttps://www.youtube.com/watch?v=0wjT7XQfXEo\\n\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "I though if a a rectangle has points as x1 , y1 , x2 , y2 \\nthe the area covered by it would be (x2 - x1  + 1) * (y2 - y1 + 1) which is giving wrong ans.\\nAnd (x2 - x1) * (y2 - y1) is giving correct ans! \\nHow ?\\n\\nSay x1 == x2 and y1 == y2 then area covered should be 1 , not 0! Doesn\\'t make sense."
                    },
                    {
                        "username": "sigrayornot",
                        "content": "if x1 == x2 or y1 == y2, then side length = 0, then area = 0 * another side => area = 0"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "[@grkem](/grkem) Thanks now I see , I was actually considering area to the no of points. My bad."
                    },
                    {
                        "username": "Peachyy",
                        "content": "If x1 == x2 and y1 == y2 it would not be a rectangle but a point on the grid"
                    },
                    {
                        "username": "grkem",
                        "content": "You are thinking about something else, counting the number of points on a rectangular shape on a grid. I am not even sure if that is called \"area\". The question defines a continuous plane, not a discrete one."
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "rectange to rectangle, rectange to circle, circle to circle, triangle to rectangle, ball to rectangle ..etc...\\nFor game deverloper only."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "collision detection !!"
                    },
                    {
                        "username": "user4898sC",
                        "content": "Why is this medium?"
                    },
                    {
                        "username": "usmonali",
                        "content": "what do you mean? is it so easy? if yes, then I agree"
                    },
                    {
                        "username": "drap5468",
                        "content": "It\\'s certainly not the hardest medium in the world, but I think \"medium\" is fair, because it requires a bit of thought to figure out a good way of calculating the overlapping area.\\n\\nGenerally speaking, \"easy\" problems are those that essentially require 0 creativity, just applying something that (leetcode expects) you already know. The small amount of thought required to figure out a new problem you\\'ve never seen before, like calculating the overlapping area, is enough to count as a medium IMO"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\n\\nStep 1 : Find the area of Rectangle 1 assume AR1\\nStep 2 : Find the area of Rectangle 2 assume AR2\\nStep 3 : Try to find a way to tell if the rectangles are overlapping or not (if they are not, return AR1 + AR2)\\nStep 3 : Find the area of intersecting rectangle formed assume IR and return AR1 + AR2 - IR.\\n\\n\\nHINT 2:\\nAll the steps might seem really easy except the third one.\\nTo find if the rectangles overlap.... find the maximum of their left extremes(L) and minimum of their right extremes(R) and similarly take the minimum of top extremes(T) and maximum of bottom extremes(B) co-ordinates \\nAnd now if the difference between R and L comes out to be negative and similarly the difference between T and B comes out to be negative, the rectangles do not intersect / overlap.\\n"
                    },
                    {
                        "username": "Ayush_km_gupta",
                        "content": "HII NICE QUESTION HELP IN INTERVIEW PREPRATION>"
                    }
                ]
            },
            {
                "id": 1687304,
                "content": [
                    {
                        "username": "shintaroid",
                        "content": "We should consider the following two problems:\\n\\n 1. How to know whether the two rectangle areas are not overlapped.\\n 2. If the two rectangle areas are overlapped, how to calculate the overlapped area.\\n\\nFor me, both situations are not intuitive to see. I tried the intuitive solution, but I gave up as it needs too many lines of code. Here I write down a smarter way in plain language which is actually from other user's codes to solve the problem.\\n\\n1, To know whether the two areas are not overlapped: \\n\\n - We actually only need to consider four situations: B>=H or E>=C or F>=D or A>=G. For example, if B is larger than H, the area (A,B,C,D) is definitely not overlapped with area (E,F,G,H), and we even know that area (A,B,C,D) is on the upper area of the plot compared with area (E,F,G,H). You can also check if other situations work.\\n\\n2, To calculate the overlapped area:\\n\\n - When the two areas are overlapped, we only need to know the bottom left corner and top right corner of the overlapped area: the larger one of A and E, the larger one of B and F, the smaller one of C and G, and the smaller one of D and H. For example, in the case of the given figure of the original problem, we just consider the point (E,B) and the point (C,H), and the overlapped area is (E,B,C,H) which could be calculated intuitively. So how about other kinds of overlapping? The formula given above never change! You can try imagining other kind of  overlapped area, you will see that in any case we only need to know max(A,E), max(B,F), min(C,G), and min(D,H) to calculate the overlapped area.\\n\\nI don't consider this problem as an easy one, if you try to solve it intuitively."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Two know if they are overlapping, we can do like this \\nfor X coordinate -> max(ax1,bx1)<min(ax2,bx2)\\nfor y coordinate -> max(ay1,by1)<min(ay2,by2)"
                    },
                    {
                        "username": "madokamylove",
                        "content": "In the statement, it says\\n*\"Each rectangle is defined by its bottom left corner and top right corner\"*\\n\\nHowever, there are test cases like \\n\\nInput:\\t-2, -2, 2, 2, -3, 3, -4, 4\\n\\nWhich is wrong, because there are no rectangles with bottom left corner (-3, 3) and top right corner (-4, 4)."
                    },
                    {
                        "username": "isinghabhishek",
                        "content": "https://leetcode.com/problems/rectangle-area/solutions/3114906/java-easy-to-understand-beats-100-simple-approach-beginner-friendly-2ms/"
                    },
                    {
                        "username": "kevv96",
                        "content": "answer = sum of two areas - overlap area\\n\\noverlap rectangle coordinates:\\n        cx1 = max(ax1, bx1)\\n        cx2 = min(ax2, bx2)\\n        cy1 = max(ay1, by1)\\n        cy2 = min(ay2, by2)\\n\\noverlap area = max(0, cx2 - cx1) * max(0, cy2 - cy1)\\n\\ndone!"
                    },
                    {
                        "username": "kevv96",
                        "content": "[@ayush391](/ayush391) You are welcome mate \\uD83D\\uDE0A"
                    },
                    {
                        "username": "ayush391",
                        "content": "A simple and concise answer. thnks mate."
                    },
                    {
                        "username": "varunshrivastava2706",
                        "content": "BORINGGGG........................"
                    },
                    {
                        "username": "riyan372828",
                        "content": "\\n**Watch this video for the better explanation of the code.**\\nhttps://www.youtube.com/watch?v=0wjT7XQfXEo\\n\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "I though if a a rectangle has points as x1 , y1 , x2 , y2 \\nthe the area covered by it would be (x2 - x1  + 1) * (y2 - y1 + 1) which is giving wrong ans.\\nAnd (x2 - x1) * (y2 - y1) is giving correct ans! \\nHow ?\\n\\nSay x1 == x2 and y1 == y2 then area covered should be 1 , not 0! Doesn\\'t make sense."
                    },
                    {
                        "username": "sigrayornot",
                        "content": "if x1 == x2 or y1 == y2, then side length = 0, then area = 0 * another side => area = 0"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "[@grkem](/grkem) Thanks now I see , I was actually considering area to the no of points. My bad."
                    },
                    {
                        "username": "Peachyy",
                        "content": "If x1 == x2 and y1 == y2 it would not be a rectangle but a point on the grid"
                    },
                    {
                        "username": "grkem",
                        "content": "You are thinking about something else, counting the number of points on a rectangular shape on a grid. I am not even sure if that is called \"area\". The question defines a continuous plane, not a discrete one."
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "rectange to rectangle, rectange to circle, circle to circle, triangle to rectangle, ball to rectangle ..etc...\\nFor game deverloper only."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "collision detection !!"
                    },
                    {
                        "username": "user4898sC",
                        "content": "Why is this medium?"
                    },
                    {
                        "username": "usmonali",
                        "content": "what do you mean? is it so easy? if yes, then I agree"
                    },
                    {
                        "username": "drap5468",
                        "content": "It\\'s certainly not the hardest medium in the world, but I think \"medium\" is fair, because it requires a bit of thought to figure out a good way of calculating the overlapping area.\\n\\nGenerally speaking, \"easy\" problems are those that essentially require 0 creativity, just applying something that (leetcode expects) you already know. The small amount of thought required to figure out a new problem you\\'ve never seen before, like calculating the overlapping area, is enough to count as a medium IMO"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\n\\nStep 1 : Find the area of Rectangle 1 assume AR1\\nStep 2 : Find the area of Rectangle 2 assume AR2\\nStep 3 : Try to find a way to tell if the rectangles are overlapping or not (if they are not, return AR1 + AR2)\\nStep 3 : Find the area of intersecting rectangle formed assume IR and return AR1 + AR2 - IR.\\n\\n\\nHINT 2:\\nAll the steps might seem really easy except the third one.\\nTo find if the rectangles overlap.... find the maximum of their left extremes(L) and minimum of their right extremes(R) and similarly take the minimum of top extremes(T) and maximum of bottom extremes(B) co-ordinates \\nAnd now if the difference between R and L comes out to be negative and similarly the difference between T and B comes out to be negative, the rectangles do not intersect / overlap.\\n"
                    },
                    {
                        "username": "Ayush_km_gupta",
                        "content": "HII NICE QUESTION HELP IN INTERVIEW PREPRATION>"
                    }
                ]
            },
            {
                "id": 1687516,
                "content": [
                    {
                        "username": "shintaroid",
                        "content": "We should consider the following two problems:\\n\\n 1. How to know whether the two rectangle areas are not overlapped.\\n 2. If the two rectangle areas are overlapped, how to calculate the overlapped area.\\n\\nFor me, both situations are not intuitive to see. I tried the intuitive solution, but I gave up as it needs too many lines of code. Here I write down a smarter way in plain language which is actually from other user's codes to solve the problem.\\n\\n1, To know whether the two areas are not overlapped: \\n\\n - We actually only need to consider four situations: B>=H or E>=C or F>=D or A>=G. For example, if B is larger than H, the area (A,B,C,D) is definitely not overlapped with area (E,F,G,H), and we even know that area (A,B,C,D) is on the upper area of the plot compared with area (E,F,G,H). You can also check if other situations work.\\n\\n2, To calculate the overlapped area:\\n\\n - When the two areas are overlapped, we only need to know the bottom left corner and top right corner of the overlapped area: the larger one of A and E, the larger one of B and F, the smaller one of C and G, and the smaller one of D and H. For example, in the case of the given figure of the original problem, we just consider the point (E,B) and the point (C,H), and the overlapped area is (E,B,C,H) which could be calculated intuitively. So how about other kinds of overlapping? The formula given above never change! You can try imagining other kind of  overlapped area, you will see that in any case we only need to know max(A,E), max(B,F), min(C,G), and min(D,H) to calculate the overlapped area.\\n\\nI don't consider this problem as an easy one, if you try to solve it intuitively."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Two know if they are overlapping, we can do like this \\nfor X coordinate -> max(ax1,bx1)<min(ax2,bx2)\\nfor y coordinate -> max(ay1,by1)<min(ay2,by2)"
                    },
                    {
                        "username": "madokamylove",
                        "content": "In the statement, it says\\n*\"Each rectangle is defined by its bottom left corner and top right corner\"*\\n\\nHowever, there are test cases like \\n\\nInput:\\t-2, -2, 2, 2, -3, 3, -4, 4\\n\\nWhich is wrong, because there are no rectangles with bottom left corner (-3, 3) and top right corner (-4, 4)."
                    },
                    {
                        "username": "isinghabhishek",
                        "content": "https://leetcode.com/problems/rectangle-area/solutions/3114906/java-easy-to-understand-beats-100-simple-approach-beginner-friendly-2ms/"
                    },
                    {
                        "username": "kevv96",
                        "content": "answer = sum of two areas - overlap area\\n\\noverlap rectangle coordinates:\\n        cx1 = max(ax1, bx1)\\n        cx2 = min(ax2, bx2)\\n        cy1 = max(ay1, by1)\\n        cy2 = min(ay2, by2)\\n\\noverlap area = max(0, cx2 - cx1) * max(0, cy2 - cy1)\\n\\ndone!"
                    },
                    {
                        "username": "kevv96",
                        "content": "[@ayush391](/ayush391) You are welcome mate \\uD83D\\uDE0A"
                    },
                    {
                        "username": "ayush391",
                        "content": "A simple and concise answer. thnks mate."
                    },
                    {
                        "username": "varunshrivastava2706",
                        "content": "BORINGGGG........................"
                    },
                    {
                        "username": "riyan372828",
                        "content": "\\n**Watch this video for the better explanation of the code.**\\nhttps://www.youtube.com/watch?v=0wjT7XQfXEo\\n\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "I though if a a rectangle has points as x1 , y1 , x2 , y2 \\nthe the area covered by it would be (x2 - x1  + 1) * (y2 - y1 + 1) which is giving wrong ans.\\nAnd (x2 - x1) * (y2 - y1) is giving correct ans! \\nHow ?\\n\\nSay x1 == x2 and y1 == y2 then area covered should be 1 , not 0! Doesn\\'t make sense."
                    },
                    {
                        "username": "sigrayornot",
                        "content": "if x1 == x2 or y1 == y2, then side length = 0, then area = 0 * another side => area = 0"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "[@grkem](/grkem) Thanks now I see , I was actually considering area to the no of points. My bad."
                    },
                    {
                        "username": "Peachyy",
                        "content": "If x1 == x2 and y1 == y2 it would not be a rectangle but a point on the grid"
                    },
                    {
                        "username": "grkem",
                        "content": "You are thinking about something else, counting the number of points on a rectangular shape on a grid. I am not even sure if that is called \"area\". The question defines a continuous plane, not a discrete one."
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "rectange to rectangle, rectange to circle, circle to circle, triangle to rectangle, ball to rectangle ..etc...\\nFor game deverloper only."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "collision detection !!"
                    },
                    {
                        "username": "user4898sC",
                        "content": "Why is this medium?"
                    },
                    {
                        "username": "usmonali",
                        "content": "what do you mean? is it so easy? if yes, then I agree"
                    },
                    {
                        "username": "drap5468",
                        "content": "It\\'s certainly not the hardest medium in the world, but I think \"medium\" is fair, because it requires a bit of thought to figure out a good way of calculating the overlapping area.\\n\\nGenerally speaking, \"easy\" problems are those that essentially require 0 creativity, just applying something that (leetcode expects) you already know. The small amount of thought required to figure out a new problem you\\'ve never seen before, like calculating the overlapping area, is enough to count as a medium IMO"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\n\\nStep 1 : Find the area of Rectangle 1 assume AR1\\nStep 2 : Find the area of Rectangle 2 assume AR2\\nStep 3 : Try to find a way to tell if the rectangles are overlapping or not (if they are not, return AR1 + AR2)\\nStep 3 : Find the area of intersecting rectangle formed assume IR and return AR1 + AR2 - IR.\\n\\n\\nHINT 2:\\nAll the steps might seem really easy except the third one.\\nTo find if the rectangles overlap.... find the maximum of their left extremes(L) and minimum of their right extremes(R) and similarly take the minimum of top extremes(T) and maximum of bottom extremes(B) co-ordinates \\nAnd now if the difference between R and L comes out to be negative and similarly the difference between T and B comes out to be negative, the rectangles do not intersect / overlap.\\n"
                    },
                    {
                        "username": "Ayush_km_gupta",
                        "content": "HII NICE QUESTION HELP IN INTERVIEW PREPRATION>"
                    }
                ]
            },
            {
                "id": 1564793,
                "content": [
                    {
                        "username": "shintaroid",
                        "content": "We should consider the following two problems:\\n\\n 1. How to know whether the two rectangle areas are not overlapped.\\n 2. If the two rectangle areas are overlapped, how to calculate the overlapped area.\\n\\nFor me, both situations are not intuitive to see. I tried the intuitive solution, but I gave up as it needs too many lines of code. Here I write down a smarter way in plain language which is actually from other user's codes to solve the problem.\\n\\n1, To know whether the two areas are not overlapped: \\n\\n - We actually only need to consider four situations: B>=H or E>=C or F>=D or A>=G. For example, if B is larger than H, the area (A,B,C,D) is definitely not overlapped with area (E,F,G,H), and we even know that area (A,B,C,D) is on the upper area of the plot compared with area (E,F,G,H). You can also check if other situations work.\\n\\n2, To calculate the overlapped area:\\n\\n - When the two areas are overlapped, we only need to know the bottom left corner and top right corner of the overlapped area: the larger one of A and E, the larger one of B and F, the smaller one of C and G, and the smaller one of D and H. For example, in the case of the given figure of the original problem, we just consider the point (E,B) and the point (C,H), and the overlapped area is (E,B,C,H) which could be calculated intuitively. So how about other kinds of overlapping? The formula given above never change! You can try imagining other kind of  overlapped area, you will see that in any case we only need to know max(A,E), max(B,F), min(C,G), and min(D,H) to calculate the overlapped area.\\n\\nI don't consider this problem as an easy one, if you try to solve it intuitively."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Two know if they are overlapping, we can do like this \\nfor X coordinate -> max(ax1,bx1)<min(ax2,bx2)\\nfor y coordinate -> max(ay1,by1)<min(ay2,by2)"
                    },
                    {
                        "username": "madokamylove",
                        "content": "In the statement, it says\\n*\"Each rectangle is defined by its bottom left corner and top right corner\"*\\n\\nHowever, there are test cases like \\n\\nInput:\\t-2, -2, 2, 2, -3, 3, -4, 4\\n\\nWhich is wrong, because there are no rectangles with bottom left corner (-3, 3) and top right corner (-4, 4)."
                    },
                    {
                        "username": "isinghabhishek",
                        "content": "https://leetcode.com/problems/rectangle-area/solutions/3114906/java-easy-to-understand-beats-100-simple-approach-beginner-friendly-2ms/"
                    },
                    {
                        "username": "kevv96",
                        "content": "answer = sum of two areas - overlap area\\n\\noverlap rectangle coordinates:\\n        cx1 = max(ax1, bx1)\\n        cx2 = min(ax2, bx2)\\n        cy1 = max(ay1, by1)\\n        cy2 = min(ay2, by2)\\n\\noverlap area = max(0, cx2 - cx1) * max(0, cy2 - cy1)\\n\\ndone!"
                    },
                    {
                        "username": "kevv96",
                        "content": "[@ayush391](/ayush391) You are welcome mate \\uD83D\\uDE0A"
                    },
                    {
                        "username": "ayush391",
                        "content": "A simple and concise answer. thnks mate."
                    },
                    {
                        "username": "varunshrivastava2706",
                        "content": "BORINGGGG........................"
                    },
                    {
                        "username": "riyan372828",
                        "content": "\\n**Watch this video for the better explanation of the code.**\\nhttps://www.youtube.com/watch?v=0wjT7XQfXEo\\n\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "I though if a a rectangle has points as x1 , y1 , x2 , y2 \\nthe the area covered by it would be (x2 - x1  + 1) * (y2 - y1 + 1) which is giving wrong ans.\\nAnd (x2 - x1) * (y2 - y1) is giving correct ans! \\nHow ?\\n\\nSay x1 == x2 and y1 == y2 then area covered should be 1 , not 0! Doesn\\'t make sense."
                    },
                    {
                        "username": "sigrayornot",
                        "content": "if x1 == x2 or y1 == y2, then side length = 0, then area = 0 * another side => area = 0"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "[@grkem](/grkem) Thanks now I see , I was actually considering area to the no of points. My bad."
                    },
                    {
                        "username": "Peachyy",
                        "content": "If x1 == x2 and y1 == y2 it would not be a rectangle but a point on the grid"
                    },
                    {
                        "username": "grkem",
                        "content": "You are thinking about something else, counting the number of points on a rectangular shape on a grid. I am not even sure if that is called \"area\". The question defines a continuous plane, not a discrete one."
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "rectange to rectangle, rectange to circle, circle to circle, triangle to rectangle, ball to rectangle ..etc...\\nFor game deverloper only."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "collision detection !!"
                    },
                    {
                        "username": "user4898sC",
                        "content": "Why is this medium?"
                    },
                    {
                        "username": "usmonali",
                        "content": "what do you mean? is it so easy? if yes, then I agree"
                    },
                    {
                        "username": "drap5468",
                        "content": "It\\'s certainly not the hardest medium in the world, but I think \"medium\" is fair, because it requires a bit of thought to figure out a good way of calculating the overlapping area.\\n\\nGenerally speaking, \"easy\" problems are those that essentially require 0 creativity, just applying something that (leetcode expects) you already know. The small amount of thought required to figure out a new problem you\\'ve never seen before, like calculating the overlapping area, is enough to count as a medium IMO"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\n\\nStep 1 : Find the area of Rectangle 1 assume AR1\\nStep 2 : Find the area of Rectangle 2 assume AR2\\nStep 3 : Try to find a way to tell if the rectangles are overlapping or not (if they are not, return AR1 + AR2)\\nStep 3 : Find the area of intersecting rectangle formed assume IR and return AR1 + AR2 - IR.\\n\\n\\nHINT 2:\\nAll the steps might seem really easy except the third one.\\nTo find if the rectangles overlap.... find the maximum of their left extremes(L) and minimum of their right extremes(R) and similarly take the minimum of top extremes(T) and maximum of bottom extremes(B) co-ordinates \\nAnd now if the difference between R and L comes out to be negative and similarly the difference between T and B comes out to be negative, the rectangles do not intersect / overlap.\\n"
                    },
                    {
                        "username": "Ayush_km_gupta",
                        "content": "HII NICE QUESTION HELP IN INTERVIEW PREPRATION>"
                    }
                ]
            },
            {
                "id": 1565006,
                "content": [
                    {
                        "username": "shintaroid",
                        "content": "We should consider the following two problems:\\n\\n 1. How to know whether the two rectangle areas are not overlapped.\\n 2. If the two rectangle areas are overlapped, how to calculate the overlapped area.\\n\\nFor me, both situations are not intuitive to see. I tried the intuitive solution, but I gave up as it needs too many lines of code. Here I write down a smarter way in plain language which is actually from other user's codes to solve the problem.\\n\\n1, To know whether the two areas are not overlapped: \\n\\n - We actually only need to consider four situations: B>=H or E>=C or F>=D or A>=G. For example, if B is larger than H, the area (A,B,C,D) is definitely not overlapped with area (E,F,G,H), and we even know that area (A,B,C,D) is on the upper area of the plot compared with area (E,F,G,H). You can also check if other situations work.\\n\\n2, To calculate the overlapped area:\\n\\n - When the two areas are overlapped, we only need to know the bottom left corner and top right corner of the overlapped area: the larger one of A and E, the larger one of B and F, the smaller one of C and G, and the smaller one of D and H. For example, in the case of the given figure of the original problem, we just consider the point (E,B) and the point (C,H), and the overlapped area is (E,B,C,H) which could be calculated intuitively. So how about other kinds of overlapping? The formula given above never change! You can try imagining other kind of  overlapped area, you will see that in any case we only need to know max(A,E), max(B,F), min(C,G), and min(D,H) to calculate the overlapped area.\\n\\nI don't consider this problem as an easy one, if you try to solve it intuitively."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Two know if they are overlapping, we can do like this \\nfor X coordinate -> max(ax1,bx1)<min(ax2,bx2)\\nfor y coordinate -> max(ay1,by1)<min(ay2,by2)"
                    },
                    {
                        "username": "madokamylove",
                        "content": "In the statement, it says\\n*\"Each rectangle is defined by its bottom left corner and top right corner\"*\\n\\nHowever, there are test cases like \\n\\nInput:\\t-2, -2, 2, 2, -3, 3, -4, 4\\n\\nWhich is wrong, because there are no rectangles with bottom left corner (-3, 3) and top right corner (-4, 4)."
                    },
                    {
                        "username": "isinghabhishek",
                        "content": "https://leetcode.com/problems/rectangle-area/solutions/3114906/java-easy-to-understand-beats-100-simple-approach-beginner-friendly-2ms/"
                    },
                    {
                        "username": "kevv96",
                        "content": "answer = sum of two areas - overlap area\\n\\noverlap rectangle coordinates:\\n        cx1 = max(ax1, bx1)\\n        cx2 = min(ax2, bx2)\\n        cy1 = max(ay1, by1)\\n        cy2 = min(ay2, by2)\\n\\noverlap area = max(0, cx2 - cx1) * max(0, cy2 - cy1)\\n\\ndone!"
                    },
                    {
                        "username": "kevv96",
                        "content": "[@ayush391](/ayush391) You are welcome mate \\uD83D\\uDE0A"
                    },
                    {
                        "username": "ayush391",
                        "content": "A simple and concise answer. thnks mate."
                    },
                    {
                        "username": "varunshrivastava2706",
                        "content": "BORINGGGG........................"
                    },
                    {
                        "username": "riyan372828",
                        "content": "\\n**Watch this video for the better explanation of the code.**\\nhttps://www.youtube.com/watch?v=0wjT7XQfXEo\\n\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "I though if a a rectangle has points as x1 , y1 , x2 , y2 \\nthe the area covered by it would be (x2 - x1  + 1) * (y2 - y1 + 1) which is giving wrong ans.\\nAnd (x2 - x1) * (y2 - y1) is giving correct ans! \\nHow ?\\n\\nSay x1 == x2 and y1 == y2 then area covered should be 1 , not 0! Doesn\\'t make sense."
                    },
                    {
                        "username": "sigrayornot",
                        "content": "if x1 == x2 or y1 == y2, then side length = 0, then area = 0 * another side => area = 0"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "[@grkem](/grkem) Thanks now I see , I was actually considering area to the no of points. My bad."
                    },
                    {
                        "username": "Peachyy",
                        "content": "If x1 == x2 and y1 == y2 it would not be a rectangle but a point on the grid"
                    },
                    {
                        "username": "grkem",
                        "content": "You are thinking about something else, counting the number of points on a rectangular shape on a grid. I am not even sure if that is called \"area\". The question defines a continuous plane, not a discrete one."
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "rectange to rectangle, rectange to circle, circle to circle, triangle to rectangle, ball to rectangle ..etc...\\nFor game deverloper only."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "collision detection !!"
                    },
                    {
                        "username": "user4898sC",
                        "content": "Why is this medium?"
                    },
                    {
                        "username": "usmonali",
                        "content": "what do you mean? is it so easy? if yes, then I agree"
                    },
                    {
                        "username": "drap5468",
                        "content": "It\\'s certainly not the hardest medium in the world, but I think \"medium\" is fair, because it requires a bit of thought to figure out a good way of calculating the overlapping area.\\n\\nGenerally speaking, \"easy\" problems are those that essentially require 0 creativity, just applying something that (leetcode expects) you already know. The small amount of thought required to figure out a new problem you\\'ve never seen before, like calculating the overlapping area, is enough to count as a medium IMO"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\n\\nStep 1 : Find the area of Rectangle 1 assume AR1\\nStep 2 : Find the area of Rectangle 2 assume AR2\\nStep 3 : Try to find a way to tell if the rectangles are overlapping or not (if they are not, return AR1 + AR2)\\nStep 3 : Find the area of intersecting rectangle formed assume IR and return AR1 + AR2 - IR.\\n\\n\\nHINT 2:\\nAll the steps might seem really easy except the third one.\\nTo find if the rectangles overlap.... find the maximum of their left extremes(L) and minimum of their right extremes(R) and similarly take the minimum of top extremes(T) and maximum of bottom extremes(B) co-ordinates \\nAnd now if the difference between R and L comes out to be negative and similarly the difference between T and B comes out to be negative, the rectangles do not intersect / overlap.\\n"
                    },
                    {
                        "username": "Ayush_km_gupta",
                        "content": "HII NICE QUESTION HELP IN INTERVIEW PREPRATION>"
                    }
                ]
            },
            {
                "id": 1686985,
                "content": [
                    {
                        "username": "shintaroid",
                        "content": "We should consider the following two problems:\\n\\n 1. How to know whether the two rectangle areas are not overlapped.\\n 2. If the two rectangle areas are overlapped, how to calculate the overlapped area.\\n\\nFor me, both situations are not intuitive to see. I tried the intuitive solution, but I gave up as it needs too many lines of code. Here I write down a smarter way in plain language which is actually from other user's codes to solve the problem.\\n\\n1, To know whether the two areas are not overlapped: \\n\\n - We actually only need to consider four situations: B>=H or E>=C or F>=D or A>=G. For example, if B is larger than H, the area (A,B,C,D) is definitely not overlapped with area (E,F,G,H), and we even know that area (A,B,C,D) is on the upper area of the plot compared with area (E,F,G,H). You can also check if other situations work.\\n\\n2, To calculate the overlapped area:\\n\\n - When the two areas are overlapped, we only need to know the bottom left corner and top right corner of the overlapped area: the larger one of A and E, the larger one of B and F, the smaller one of C and G, and the smaller one of D and H. For example, in the case of the given figure of the original problem, we just consider the point (E,B) and the point (C,H), and the overlapped area is (E,B,C,H) which could be calculated intuitively. So how about other kinds of overlapping? The formula given above never change! You can try imagining other kind of  overlapped area, you will see that in any case we only need to know max(A,E), max(B,F), min(C,G), and min(D,H) to calculate the overlapped area.\\n\\nI don't consider this problem as an easy one, if you try to solve it intuitively."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Two know if they are overlapping, we can do like this \\nfor X coordinate -> max(ax1,bx1)<min(ax2,bx2)\\nfor y coordinate -> max(ay1,by1)<min(ay2,by2)"
                    },
                    {
                        "username": "madokamylove",
                        "content": "In the statement, it says\\n*\"Each rectangle is defined by its bottom left corner and top right corner\"*\\n\\nHowever, there are test cases like \\n\\nInput:\\t-2, -2, 2, 2, -3, 3, -4, 4\\n\\nWhich is wrong, because there are no rectangles with bottom left corner (-3, 3) and top right corner (-4, 4)."
                    },
                    {
                        "username": "isinghabhishek",
                        "content": "https://leetcode.com/problems/rectangle-area/solutions/3114906/java-easy-to-understand-beats-100-simple-approach-beginner-friendly-2ms/"
                    },
                    {
                        "username": "kevv96",
                        "content": "answer = sum of two areas - overlap area\\n\\noverlap rectangle coordinates:\\n        cx1 = max(ax1, bx1)\\n        cx2 = min(ax2, bx2)\\n        cy1 = max(ay1, by1)\\n        cy2 = min(ay2, by2)\\n\\noverlap area = max(0, cx2 - cx1) * max(0, cy2 - cy1)\\n\\ndone!"
                    },
                    {
                        "username": "kevv96",
                        "content": "[@ayush391](/ayush391) You are welcome mate \\uD83D\\uDE0A"
                    },
                    {
                        "username": "ayush391",
                        "content": "A simple and concise answer. thnks mate."
                    },
                    {
                        "username": "varunshrivastava2706",
                        "content": "BORINGGGG........................"
                    },
                    {
                        "username": "riyan372828",
                        "content": "\\n**Watch this video for the better explanation of the code.**\\nhttps://www.youtube.com/watch?v=0wjT7XQfXEo\\n\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "I though if a a rectangle has points as x1 , y1 , x2 , y2 \\nthe the area covered by it would be (x2 - x1  + 1) * (y2 - y1 + 1) which is giving wrong ans.\\nAnd (x2 - x1) * (y2 - y1) is giving correct ans! \\nHow ?\\n\\nSay x1 == x2 and y1 == y2 then area covered should be 1 , not 0! Doesn\\'t make sense."
                    },
                    {
                        "username": "sigrayornot",
                        "content": "if x1 == x2 or y1 == y2, then side length = 0, then area = 0 * another side => area = 0"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "[@grkem](/grkem) Thanks now I see , I was actually considering area to the no of points. My bad."
                    },
                    {
                        "username": "Peachyy",
                        "content": "If x1 == x2 and y1 == y2 it would not be a rectangle but a point on the grid"
                    },
                    {
                        "username": "grkem",
                        "content": "You are thinking about something else, counting the number of points on a rectangular shape on a grid. I am not even sure if that is called \"area\". The question defines a continuous plane, not a discrete one."
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "rectange to rectangle, rectange to circle, circle to circle, triangle to rectangle, ball to rectangle ..etc...\\nFor game deverloper only."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "collision detection !!"
                    },
                    {
                        "username": "user4898sC",
                        "content": "Why is this medium?"
                    },
                    {
                        "username": "usmonali",
                        "content": "what do you mean? is it so easy? if yes, then I agree"
                    },
                    {
                        "username": "drap5468",
                        "content": "It\\'s certainly not the hardest medium in the world, but I think \"medium\" is fair, because it requires a bit of thought to figure out a good way of calculating the overlapping area.\\n\\nGenerally speaking, \"easy\" problems are those that essentially require 0 creativity, just applying something that (leetcode expects) you already know. The small amount of thought required to figure out a new problem you\\'ve never seen before, like calculating the overlapping area, is enough to count as a medium IMO"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\n\\nStep 1 : Find the area of Rectangle 1 assume AR1\\nStep 2 : Find the area of Rectangle 2 assume AR2\\nStep 3 : Try to find a way to tell if the rectangles are overlapping or not (if they are not, return AR1 + AR2)\\nStep 3 : Find the area of intersecting rectangle formed assume IR and return AR1 + AR2 - IR.\\n\\n\\nHINT 2:\\nAll the steps might seem really easy except the third one.\\nTo find if the rectangles overlap.... find the maximum of their left extremes(L) and minimum of their right extremes(R) and similarly take the minimum of top extremes(T) and maximum of bottom extremes(B) co-ordinates \\nAnd now if the difference between R and L comes out to be negative and similarly the difference between T and B comes out to be negative, the rectangles do not intersect / overlap.\\n"
                    },
                    {
                        "username": "Ayush_km_gupta",
                        "content": "HII NICE QUESTION HELP IN INTERVIEW PREPRATION>"
                    }
                ]
            },
            {
                "id": 1686981,
                "content": [
                    {
                        "username": "shintaroid",
                        "content": "We should consider the following two problems:\\n\\n 1. How to know whether the two rectangle areas are not overlapped.\\n 2. If the two rectangle areas are overlapped, how to calculate the overlapped area.\\n\\nFor me, both situations are not intuitive to see. I tried the intuitive solution, but I gave up as it needs too many lines of code. Here I write down a smarter way in plain language which is actually from other user's codes to solve the problem.\\n\\n1, To know whether the two areas are not overlapped: \\n\\n - We actually only need to consider four situations: B>=H or E>=C or F>=D or A>=G. For example, if B is larger than H, the area (A,B,C,D) is definitely not overlapped with area (E,F,G,H), and we even know that area (A,B,C,D) is on the upper area of the plot compared with area (E,F,G,H). You can also check if other situations work.\\n\\n2, To calculate the overlapped area:\\n\\n - When the two areas are overlapped, we only need to know the bottom left corner and top right corner of the overlapped area: the larger one of A and E, the larger one of B and F, the smaller one of C and G, and the smaller one of D and H. For example, in the case of the given figure of the original problem, we just consider the point (E,B) and the point (C,H), and the overlapped area is (E,B,C,H) which could be calculated intuitively. So how about other kinds of overlapping? The formula given above never change! You can try imagining other kind of  overlapped area, you will see that in any case we only need to know max(A,E), max(B,F), min(C,G), and min(D,H) to calculate the overlapped area.\\n\\nI don't consider this problem as an easy one, if you try to solve it intuitively."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Two know if they are overlapping, we can do like this \\nfor X coordinate -> max(ax1,bx1)<min(ax2,bx2)\\nfor y coordinate -> max(ay1,by1)<min(ay2,by2)"
                    },
                    {
                        "username": "madokamylove",
                        "content": "In the statement, it says\\n*\"Each rectangle is defined by its bottom left corner and top right corner\"*\\n\\nHowever, there are test cases like \\n\\nInput:\\t-2, -2, 2, 2, -3, 3, -4, 4\\n\\nWhich is wrong, because there are no rectangles with bottom left corner (-3, 3) and top right corner (-4, 4)."
                    },
                    {
                        "username": "isinghabhishek",
                        "content": "https://leetcode.com/problems/rectangle-area/solutions/3114906/java-easy-to-understand-beats-100-simple-approach-beginner-friendly-2ms/"
                    },
                    {
                        "username": "kevv96",
                        "content": "answer = sum of two areas - overlap area\\n\\noverlap rectangle coordinates:\\n        cx1 = max(ax1, bx1)\\n        cx2 = min(ax2, bx2)\\n        cy1 = max(ay1, by1)\\n        cy2 = min(ay2, by2)\\n\\noverlap area = max(0, cx2 - cx1) * max(0, cy2 - cy1)\\n\\ndone!"
                    },
                    {
                        "username": "kevv96",
                        "content": "[@ayush391](/ayush391) You are welcome mate \\uD83D\\uDE0A"
                    },
                    {
                        "username": "ayush391",
                        "content": "A simple and concise answer. thnks mate."
                    },
                    {
                        "username": "varunshrivastava2706",
                        "content": "BORINGGGG........................"
                    },
                    {
                        "username": "riyan372828",
                        "content": "\\n**Watch this video for the better explanation of the code.**\\nhttps://www.youtube.com/watch?v=0wjT7XQfXEo\\n\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "I though if a a rectangle has points as x1 , y1 , x2 , y2 \\nthe the area covered by it would be (x2 - x1  + 1) * (y2 - y1 + 1) which is giving wrong ans.\\nAnd (x2 - x1) * (y2 - y1) is giving correct ans! \\nHow ?\\n\\nSay x1 == x2 and y1 == y2 then area covered should be 1 , not 0! Doesn\\'t make sense."
                    },
                    {
                        "username": "sigrayornot",
                        "content": "if x1 == x2 or y1 == y2, then side length = 0, then area = 0 * another side => area = 0"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "[@grkem](/grkem) Thanks now I see , I was actually considering area to the no of points. My bad."
                    },
                    {
                        "username": "Peachyy",
                        "content": "If x1 == x2 and y1 == y2 it would not be a rectangle but a point on the grid"
                    },
                    {
                        "username": "grkem",
                        "content": "You are thinking about something else, counting the number of points on a rectangular shape on a grid. I am not even sure if that is called \"area\". The question defines a continuous plane, not a discrete one."
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "rectange to rectangle, rectange to circle, circle to circle, triangle to rectangle, ball to rectangle ..etc...\\nFor game deverloper only."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "collision detection !!"
                    },
                    {
                        "username": "user4898sC",
                        "content": "Why is this medium?"
                    },
                    {
                        "username": "usmonali",
                        "content": "what do you mean? is it so easy? if yes, then I agree"
                    },
                    {
                        "username": "drap5468",
                        "content": "It\\'s certainly not the hardest medium in the world, but I think \"medium\" is fair, because it requires a bit of thought to figure out a good way of calculating the overlapping area.\\n\\nGenerally speaking, \"easy\" problems are those that essentially require 0 creativity, just applying something that (leetcode expects) you already know. The small amount of thought required to figure out a new problem you\\'ve never seen before, like calculating the overlapping area, is enough to count as a medium IMO"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\n\\nStep 1 : Find the area of Rectangle 1 assume AR1\\nStep 2 : Find the area of Rectangle 2 assume AR2\\nStep 3 : Try to find a way to tell if the rectangles are overlapping or not (if they are not, return AR1 + AR2)\\nStep 3 : Find the area of intersecting rectangle formed assume IR and return AR1 + AR2 - IR.\\n\\n\\nHINT 2:\\nAll the steps might seem really easy except the third one.\\nTo find if the rectangles overlap.... find the maximum of their left extremes(L) and minimum of their right extremes(R) and similarly take the minimum of top extremes(T) and maximum of bottom extremes(B) co-ordinates \\nAnd now if the difference between R and L comes out to be negative and similarly the difference between T and B comes out to be negative, the rectangles do not intersect / overlap.\\n"
                    },
                    {
                        "username": "Ayush_km_gupta",
                        "content": "HII NICE QUESTION HELP IN INTERVIEW PREPRATION>"
                    }
                ]
            },
            {
                "id": 1687585,
                "content": [
                    {
                        "username": "shintaroid",
                        "content": "We should consider the following two problems:\\n\\n 1. How to know whether the two rectangle areas are not overlapped.\\n 2. If the two rectangle areas are overlapped, how to calculate the overlapped area.\\n\\nFor me, both situations are not intuitive to see. I tried the intuitive solution, but I gave up as it needs too many lines of code. Here I write down a smarter way in plain language which is actually from other user's codes to solve the problem.\\n\\n1, To know whether the two areas are not overlapped: \\n\\n - We actually only need to consider four situations: B>=H or E>=C or F>=D or A>=G. For example, if B is larger than H, the area (A,B,C,D) is definitely not overlapped with area (E,F,G,H), and we even know that area (A,B,C,D) is on the upper area of the plot compared with area (E,F,G,H). You can also check if other situations work.\\n\\n2, To calculate the overlapped area:\\n\\n - When the two areas are overlapped, we only need to know the bottom left corner and top right corner of the overlapped area: the larger one of A and E, the larger one of B and F, the smaller one of C and G, and the smaller one of D and H. For example, in the case of the given figure of the original problem, we just consider the point (E,B) and the point (C,H), and the overlapped area is (E,B,C,H) which could be calculated intuitively. So how about other kinds of overlapping? The formula given above never change! You can try imagining other kind of  overlapped area, you will see that in any case we only need to know max(A,E), max(B,F), min(C,G), and min(D,H) to calculate the overlapped area.\\n\\nI don't consider this problem as an easy one, if you try to solve it intuitively."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Two know if they are overlapping, we can do like this \\nfor X coordinate -> max(ax1,bx1)<min(ax2,bx2)\\nfor y coordinate -> max(ay1,by1)<min(ay2,by2)"
                    },
                    {
                        "username": "madokamylove",
                        "content": "In the statement, it says\\n*\"Each rectangle is defined by its bottom left corner and top right corner\"*\\n\\nHowever, there are test cases like \\n\\nInput:\\t-2, -2, 2, 2, -3, 3, -4, 4\\n\\nWhich is wrong, because there are no rectangles with bottom left corner (-3, 3) and top right corner (-4, 4)."
                    },
                    {
                        "username": "isinghabhishek",
                        "content": "https://leetcode.com/problems/rectangle-area/solutions/3114906/java-easy-to-understand-beats-100-simple-approach-beginner-friendly-2ms/"
                    },
                    {
                        "username": "kevv96",
                        "content": "answer = sum of two areas - overlap area\\n\\noverlap rectangle coordinates:\\n        cx1 = max(ax1, bx1)\\n        cx2 = min(ax2, bx2)\\n        cy1 = max(ay1, by1)\\n        cy2 = min(ay2, by2)\\n\\noverlap area = max(0, cx2 - cx1) * max(0, cy2 - cy1)\\n\\ndone!"
                    },
                    {
                        "username": "kevv96",
                        "content": "[@ayush391](/ayush391) You are welcome mate \\uD83D\\uDE0A"
                    },
                    {
                        "username": "ayush391",
                        "content": "A simple and concise answer. thnks mate."
                    },
                    {
                        "username": "varunshrivastava2706",
                        "content": "BORINGGGG........................"
                    },
                    {
                        "username": "riyan372828",
                        "content": "\\n**Watch this video for the better explanation of the code.**\\nhttps://www.youtube.com/watch?v=0wjT7XQfXEo\\n\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "I though if a a rectangle has points as x1 , y1 , x2 , y2 \\nthe the area covered by it would be (x2 - x1  + 1) * (y2 - y1 + 1) which is giving wrong ans.\\nAnd (x2 - x1) * (y2 - y1) is giving correct ans! \\nHow ?\\n\\nSay x1 == x2 and y1 == y2 then area covered should be 1 , not 0! Doesn\\'t make sense."
                    },
                    {
                        "username": "sigrayornot",
                        "content": "if x1 == x2 or y1 == y2, then side length = 0, then area = 0 * another side => area = 0"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "[@grkem](/grkem) Thanks now I see , I was actually considering area to the no of points. My bad."
                    },
                    {
                        "username": "Peachyy",
                        "content": "If x1 == x2 and y1 == y2 it would not be a rectangle but a point on the grid"
                    },
                    {
                        "username": "grkem",
                        "content": "You are thinking about something else, counting the number of points on a rectangular shape on a grid. I am not even sure if that is called \"area\". The question defines a continuous plane, not a discrete one."
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "rectange to rectangle, rectange to circle, circle to circle, triangle to rectangle, ball to rectangle ..etc...\\nFor game deverloper only."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "collision detection !!"
                    },
                    {
                        "username": "user4898sC",
                        "content": "Why is this medium?"
                    },
                    {
                        "username": "usmonali",
                        "content": "what do you mean? is it so easy? if yes, then I agree"
                    },
                    {
                        "username": "drap5468",
                        "content": "It\\'s certainly not the hardest medium in the world, but I think \"medium\" is fair, because it requires a bit of thought to figure out a good way of calculating the overlapping area.\\n\\nGenerally speaking, \"easy\" problems are those that essentially require 0 creativity, just applying something that (leetcode expects) you already know. The small amount of thought required to figure out a new problem you\\'ve never seen before, like calculating the overlapping area, is enough to count as a medium IMO"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\n\\nStep 1 : Find the area of Rectangle 1 assume AR1\\nStep 2 : Find the area of Rectangle 2 assume AR2\\nStep 3 : Try to find a way to tell if the rectangles are overlapping or not (if they are not, return AR1 + AR2)\\nStep 3 : Find the area of intersecting rectangle formed assume IR and return AR1 + AR2 - IR.\\n\\n\\nHINT 2:\\nAll the steps might seem really easy except the third one.\\nTo find if the rectangles overlap.... find the maximum of their left extremes(L) and minimum of their right extremes(R) and similarly take the minimum of top extremes(T) and maximum of bottom extremes(B) co-ordinates \\nAnd now if the difference between R and L comes out to be negative and similarly the difference between T and B comes out to be negative, the rectangles do not intersect / overlap.\\n"
                    },
                    {
                        "username": "Ayush_km_gupta",
                        "content": "HII NICE QUESTION HELP IN INTERVIEW PREPRATION>"
                    }
                ]
            },
            {
                "id": 1687148,
                "content": [
                    {
                        "username": "shintaroid",
                        "content": "We should consider the following two problems:\\n\\n 1. How to know whether the two rectangle areas are not overlapped.\\n 2. If the two rectangle areas are overlapped, how to calculate the overlapped area.\\n\\nFor me, both situations are not intuitive to see. I tried the intuitive solution, but I gave up as it needs too many lines of code. Here I write down a smarter way in plain language which is actually from other user's codes to solve the problem.\\n\\n1, To know whether the two areas are not overlapped: \\n\\n - We actually only need to consider four situations: B>=H or E>=C or F>=D or A>=G. For example, if B is larger than H, the area (A,B,C,D) is definitely not overlapped with area (E,F,G,H), and we even know that area (A,B,C,D) is on the upper area of the plot compared with area (E,F,G,H). You can also check if other situations work.\\n\\n2, To calculate the overlapped area:\\n\\n - When the two areas are overlapped, we only need to know the bottom left corner and top right corner of the overlapped area: the larger one of A and E, the larger one of B and F, the smaller one of C and G, and the smaller one of D and H. For example, in the case of the given figure of the original problem, we just consider the point (E,B) and the point (C,H), and the overlapped area is (E,B,C,H) which could be calculated intuitively. So how about other kinds of overlapping? The formula given above never change! You can try imagining other kind of  overlapped area, you will see that in any case we only need to know max(A,E), max(B,F), min(C,G), and min(D,H) to calculate the overlapped area.\\n\\nI don't consider this problem as an easy one, if you try to solve it intuitively."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Two know if they are overlapping, we can do like this \\nfor X coordinate -> max(ax1,bx1)<min(ax2,bx2)\\nfor y coordinate -> max(ay1,by1)<min(ay2,by2)"
                    },
                    {
                        "username": "madokamylove",
                        "content": "In the statement, it says\\n*\"Each rectangle is defined by its bottom left corner and top right corner\"*\\n\\nHowever, there are test cases like \\n\\nInput:\\t-2, -2, 2, 2, -3, 3, -4, 4\\n\\nWhich is wrong, because there are no rectangles with bottom left corner (-3, 3) and top right corner (-4, 4)."
                    },
                    {
                        "username": "isinghabhishek",
                        "content": "https://leetcode.com/problems/rectangle-area/solutions/3114906/java-easy-to-understand-beats-100-simple-approach-beginner-friendly-2ms/"
                    },
                    {
                        "username": "kevv96",
                        "content": "answer = sum of two areas - overlap area\\n\\noverlap rectangle coordinates:\\n        cx1 = max(ax1, bx1)\\n        cx2 = min(ax2, bx2)\\n        cy1 = max(ay1, by1)\\n        cy2 = min(ay2, by2)\\n\\noverlap area = max(0, cx2 - cx1) * max(0, cy2 - cy1)\\n\\ndone!"
                    },
                    {
                        "username": "kevv96",
                        "content": "[@ayush391](/ayush391) You are welcome mate \\uD83D\\uDE0A"
                    },
                    {
                        "username": "ayush391",
                        "content": "A simple and concise answer. thnks mate."
                    },
                    {
                        "username": "varunshrivastava2706",
                        "content": "BORINGGGG........................"
                    },
                    {
                        "username": "riyan372828",
                        "content": "\\n**Watch this video for the better explanation of the code.**\\nhttps://www.youtube.com/watch?v=0wjT7XQfXEo\\n\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "I though if a a rectangle has points as x1 , y1 , x2 , y2 \\nthe the area covered by it would be (x2 - x1  + 1) * (y2 - y1 + 1) which is giving wrong ans.\\nAnd (x2 - x1) * (y2 - y1) is giving correct ans! \\nHow ?\\n\\nSay x1 == x2 and y1 == y2 then area covered should be 1 , not 0! Doesn\\'t make sense."
                    },
                    {
                        "username": "sigrayornot",
                        "content": "if x1 == x2 or y1 == y2, then side length = 0, then area = 0 * another side => area = 0"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "[@grkem](/grkem) Thanks now I see , I was actually considering area to the no of points. My bad."
                    },
                    {
                        "username": "Peachyy",
                        "content": "If x1 == x2 and y1 == y2 it would not be a rectangle but a point on the grid"
                    },
                    {
                        "username": "grkem",
                        "content": "You are thinking about something else, counting the number of points on a rectangular shape on a grid. I am not even sure if that is called \"area\". The question defines a continuous plane, not a discrete one."
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "rectange to rectangle, rectange to circle, circle to circle, triangle to rectangle, ball to rectangle ..etc...\\nFor game deverloper only."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "collision detection !!"
                    },
                    {
                        "username": "user4898sC",
                        "content": "Why is this medium?"
                    },
                    {
                        "username": "usmonali",
                        "content": "what do you mean? is it so easy? if yes, then I agree"
                    },
                    {
                        "username": "drap5468",
                        "content": "It\\'s certainly not the hardest medium in the world, but I think \"medium\" is fair, because it requires a bit of thought to figure out a good way of calculating the overlapping area.\\n\\nGenerally speaking, \"easy\" problems are those that essentially require 0 creativity, just applying something that (leetcode expects) you already know. The small amount of thought required to figure out a new problem you\\'ve never seen before, like calculating the overlapping area, is enough to count as a medium IMO"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\n\\nStep 1 : Find the area of Rectangle 1 assume AR1\\nStep 2 : Find the area of Rectangle 2 assume AR2\\nStep 3 : Try to find a way to tell if the rectangles are overlapping or not (if they are not, return AR1 + AR2)\\nStep 3 : Find the area of intersecting rectangle formed assume IR and return AR1 + AR2 - IR.\\n\\n\\nHINT 2:\\nAll the steps might seem really easy except the third one.\\nTo find if the rectangles overlap.... find the maximum of their left extremes(L) and minimum of their right extremes(R) and similarly take the minimum of top extremes(T) and maximum of bottom extremes(B) co-ordinates \\nAnd now if the difference between R and L comes out to be negative and similarly the difference between T and B comes out to be negative, the rectangles do not intersect / overlap.\\n"
                    },
                    {
                        "username": "Ayush_km_gupta",
                        "content": "HII NICE QUESTION HELP IN INTERVIEW PREPRATION>"
                    }
                ]
            },
            {
                "id": 1573491,
                "content": [
                    {
                        "username": "shintaroid",
                        "content": "We should consider the following two problems:\\n\\n 1. How to know whether the two rectangle areas are not overlapped.\\n 2. If the two rectangle areas are overlapped, how to calculate the overlapped area.\\n\\nFor me, both situations are not intuitive to see. I tried the intuitive solution, but I gave up as it needs too many lines of code. Here I write down a smarter way in plain language which is actually from other user's codes to solve the problem.\\n\\n1, To know whether the two areas are not overlapped: \\n\\n - We actually only need to consider four situations: B>=H or E>=C or F>=D or A>=G. For example, if B is larger than H, the area (A,B,C,D) is definitely not overlapped with area (E,F,G,H), and we even know that area (A,B,C,D) is on the upper area of the plot compared with area (E,F,G,H). You can also check if other situations work.\\n\\n2, To calculate the overlapped area:\\n\\n - When the two areas are overlapped, we only need to know the bottom left corner and top right corner of the overlapped area: the larger one of A and E, the larger one of B and F, the smaller one of C and G, and the smaller one of D and H. For example, in the case of the given figure of the original problem, we just consider the point (E,B) and the point (C,H), and the overlapped area is (E,B,C,H) which could be calculated intuitively. So how about other kinds of overlapping? The formula given above never change! You can try imagining other kind of  overlapped area, you will see that in any case we only need to know max(A,E), max(B,F), min(C,G), and min(D,H) to calculate the overlapped area.\\n\\nI don't consider this problem as an easy one, if you try to solve it intuitively."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Two know if they are overlapping, we can do like this \\nfor X coordinate -> max(ax1,bx1)<min(ax2,bx2)\\nfor y coordinate -> max(ay1,by1)<min(ay2,by2)"
                    },
                    {
                        "username": "madokamylove",
                        "content": "In the statement, it says\\n*\"Each rectangle is defined by its bottom left corner and top right corner\"*\\n\\nHowever, there are test cases like \\n\\nInput:\\t-2, -2, 2, 2, -3, 3, -4, 4\\n\\nWhich is wrong, because there are no rectangles with bottom left corner (-3, 3) and top right corner (-4, 4)."
                    },
                    {
                        "username": "isinghabhishek",
                        "content": "https://leetcode.com/problems/rectangle-area/solutions/3114906/java-easy-to-understand-beats-100-simple-approach-beginner-friendly-2ms/"
                    },
                    {
                        "username": "kevv96",
                        "content": "answer = sum of two areas - overlap area\\n\\noverlap rectangle coordinates:\\n        cx1 = max(ax1, bx1)\\n        cx2 = min(ax2, bx2)\\n        cy1 = max(ay1, by1)\\n        cy2 = min(ay2, by2)\\n\\noverlap area = max(0, cx2 - cx1) * max(0, cy2 - cy1)\\n\\ndone!"
                    },
                    {
                        "username": "kevv96",
                        "content": "[@ayush391](/ayush391) You are welcome mate \\uD83D\\uDE0A"
                    },
                    {
                        "username": "ayush391",
                        "content": "A simple and concise answer. thnks mate."
                    },
                    {
                        "username": "varunshrivastava2706",
                        "content": "BORINGGGG........................"
                    },
                    {
                        "username": "riyan372828",
                        "content": "\\n**Watch this video for the better explanation of the code.**\\nhttps://www.youtube.com/watch?v=0wjT7XQfXEo\\n\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "I though if a a rectangle has points as x1 , y1 , x2 , y2 \\nthe the area covered by it would be (x2 - x1  + 1) * (y2 - y1 + 1) which is giving wrong ans.\\nAnd (x2 - x1) * (y2 - y1) is giving correct ans! \\nHow ?\\n\\nSay x1 == x2 and y1 == y2 then area covered should be 1 , not 0! Doesn\\'t make sense."
                    },
                    {
                        "username": "sigrayornot",
                        "content": "if x1 == x2 or y1 == y2, then side length = 0, then area = 0 * another side => area = 0"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "[@grkem](/grkem) Thanks now I see , I was actually considering area to the no of points. My bad."
                    },
                    {
                        "username": "Peachyy",
                        "content": "If x1 == x2 and y1 == y2 it would not be a rectangle but a point on the grid"
                    },
                    {
                        "username": "grkem",
                        "content": "You are thinking about something else, counting the number of points on a rectangular shape on a grid. I am not even sure if that is called \"area\". The question defines a continuous plane, not a discrete one."
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "rectange to rectangle, rectange to circle, circle to circle, triangle to rectangle, ball to rectangle ..etc...\\nFor game deverloper only."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "collision detection !!"
                    },
                    {
                        "username": "user4898sC",
                        "content": "Why is this medium?"
                    },
                    {
                        "username": "usmonali",
                        "content": "what do you mean? is it so easy? if yes, then I agree"
                    },
                    {
                        "username": "drap5468",
                        "content": "It\\'s certainly not the hardest medium in the world, but I think \"medium\" is fair, because it requires a bit of thought to figure out a good way of calculating the overlapping area.\\n\\nGenerally speaking, \"easy\" problems are those that essentially require 0 creativity, just applying something that (leetcode expects) you already know. The small amount of thought required to figure out a new problem you\\'ve never seen before, like calculating the overlapping area, is enough to count as a medium IMO"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\n\\nStep 1 : Find the area of Rectangle 1 assume AR1\\nStep 2 : Find the area of Rectangle 2 assume AR2\\nStep 3 : Try to find a way to tell if the rectangles are overlapping or not (if they are not, return AR1 + AR2)\\nStep 3 : Find the area of intersecting rectangle formed assume IR and return AR1 + AR2 - IR.\\n\\n\\nHINT 2:\\nAll the steps might seem really easy except the third one.\\nTo find if the rectangles overlap.... find the maximum of their left extremes(L) and minimum of their right extremes(R) and similarly take the minimum of top extremes(T) and maximum of bottom extremes(B) co-ordinates \\nAnd now if the difference between R and L comes out to be negative and similarly the difference between T and B comes out to be negative, the rectangles do not intersect / overlap.\\n"
                    },
                    {
                        "username": "Ayush_km_gupta",
                        "content": "HII NICE QUESTION HELP IN INTERVIEW PREPRATION>"
                    }
                ]
            },
            {
                "id": 1687068,
                "content": [
                    {
                        "username": "shintaroid",
                        "content": "We should consider the following two problems:\\n\\n 1. How to know whether the two rectangle areas are not overlapped.\\n 2. If the two rectangle areas are overlapped, how to calculate the overlapped area.\\n\\nFor me, both situations are not intuitive to see. I tried the intuitive solution, but I gave up as it needs too many lines of code. Here I write down a smarter way in plain language which is actually from other user's codes to solve the problem.\\n\\n1, To know whether the two areas are not overlapped: \\n\\n - We actually only need to consider four situations: B>=H or E>=C or F>=D or A>=G. For example, if B is larger than H, the area (A,B,C,D) is definitely not overlapped with area (E,F,G,H), and we even know that area (A,B,C,D) is on the upper area of the plot compared with area (E,F,G,H). You can also check if other situations work.\\n\\n2, To calculate the overlapped area:\\n\\n - When the two areas are overlapped, we only need to know the bottom left corner and top right corner of the overlapped area: the larger one of A and E, the larger one of B and F, the smaller one of C and G, and the smaller one of D and H. For example, in the case of the given figure of the original problem, we just consider the point (E,B) and the point (C,H), and the overlapped area is (E,B,C,H) which could be calculated intuitively. So how about other kinds of overlapping? The formula given above never change! You can try imagining other kind of  overlapped area, you will see that in any case we only need to know max(A,E), max(B,F), min(C,G), and min(D,H) to calculate the overlapped area.\\n\\nI don't consider this problem as an easy one, if you try to solve it intuitively."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Two know if they are overlapping, we can do like this \\nfor X coordinate -> max(ax1,bx1)<min(ax2,bx2)\\nfor y coordinate -> max(ay1,by1)<min(ay2,by2)"
                    },
                    {
                        "username": "madokamylove",
                        "content": "In the statement, it says\\n*\"Each rectangle is defined by its bottom left corner and top right corner\"*\\n\\nHowever, there are test cases like \\n\\nInput:\\t-2, -2, 2, 2, -3, 3, -4, 4\\n\\nWhich is wrong, because there are no rectangles with bottom left corner (-3, 3) and top right corner (-4, 4)."
                    },
                    {
                        "username": "isinghabhishek",
                        "content": "https://leetcode.com/problems/rectangle-area/solutions/3114906/java-easy-to-understand-beats-100-simple-approach-beginner-friendly-2ms/"
                    },
                    {
                        "username": "kevv96",
                        "content": "answer = sum of two areas - overlap area\\n\\noverlap rectangle coordinates:\\n        cx1 = max(ax1, bx1)\\n        cx2 = min(ax2, bx2)\\n        cy1 = max(ay1, by1)\\n        cy2 = min(ay2, by2)\\n\\noverlap area = max(0, cx2 - cx1) * max(0, cy2 - cy1)\\n\\ndone!"
                    },
                    {
                        "username": "kevv96",
                        "content": "[@ayush391](/ayush391) You are welcome mate \\uD83D\\uDE0A"
                    },
                    {
                        "username": "ayush391",
                        "content": "A simple and concise answer. thnks mate."
                    },
                    {
                        "username": "varunshrivastava2706",
                        "content": "BORINGGGG........................"
                    },
                    {
                        "username": "riyan372828",
                        "content": "\\n**Watch this video for the better explanation of the code.**\\nhttps://www.youtube.com/watch?v=0wjT7XQfXEo\\n\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "I though if a a rectangle has points as x1 , y1 , x2 , y2 \\nthe the area covered by it would be (x2 - x1  + 1) * (y2 - y1 + 1) which is giving wrong ans.\\nAnd (x2 - x1) * (y2 - y1) is giving correct ans! \\nHow ?\\n\\nSay x1 == x2 and y1 == y2 then area covered should be 1 , not 0! Doesn\\'t make sense."
                    },
                    {
                        "username": "sigrayornot",
                        "content": "if x1 == x2 or y1 == y2, then side length = 0, then area = 0 * another side => area = 0"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "[@grkem](/grkem) Thanks now I see , I was actually considering area to the no of points. My bad."
                    },
                    {
                        "username": "Peachyy",
                        "content": "If x1 == x2 and y1 == y2 it would not be a rectangle but a point on the grid"
                    },
                    {
                        "username": "grkem",
                        "content": "You are thinking about something else, counting the number of points on a rectangular shape on a grid. I am not even sure if that is called \"area\". The question defines a continuous plane, not a discrete one."
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "rectange to rectangle, rectange to circle, circle to circle, triangle to rectangle, ball to rectangle ..etc...\\nFor game deverloper only."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "collision detection !!"
                    },
                    {
                        "username": "user4898sC",
                        "content": "Why is this medium?"
                    },
                    {
                        "username": "usmonali",
                        "content": "what do you mean? is it so easy? if yes, then I agree"
                    },
                    {
                        "username": "drap5468",
                        "content": "It\\'s certainly not the hardest medium in the world, but I think \"medium\" is fair, because it requires a bit of thought to figure out a good way of calculating the overlapping area.\\n\\nGenerally speaking, \"easy\" problems are those that essentially require 0 creativity, just applying something that (leetcode expects) you already know. The small amount of thought required to figure out a new problem you\\'ve never seen before, like calculating the overlapping area, is enough to count as a medium IMO"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\n\\nStep 1 : Find the area of Rectangle 1 assume AR1\\nStep 2 : Find the area of Rectangle 2 assume AR2\\nStep 3 : Try to find a way to tell if the rectangles are overlapping or not (if they are not, return AR1 + AR2)\\nStep 3 : Find the area of intersecting rectangle formed assume IR and return AR1 + AR2 - IR.\\n\\n\\nHINT 2:\\nAll the steps might seem really easy except the third one.\\nTo find if the rectangles overlap.... find the maximum of their left extremes(L) and minimum of their right extremes(R) and similarly take the minimum of top extremes(T) and maximum of bottom extremes(B) co-ordinates \\nAnd now if the difference between R and L comes out to be negative and similarly the difference between T and B comes out to be negative, the rectangles do not intersect / overlap.\\n"
                    },
                    {
                        "username": "Ayush_km_gupta",
                        "content": "HII NICE QUESTION HELP IN INTERVIEW PREPRATION>"
                    }
                ]
            },
            {
                "id": 1687304,
                "content": [
                    {
                        "username": "shintaroid",
                        "content": "We should consider the following two problems:\\n\\n 1. How to know whether the two rectangle areas are not overlapped.\\n 2. If the two rectangle areas are overlapped, how to calculate the overlapped area.\\n\\nFor me, both situations are not intuitive to see. I tried the intuitive solution, but I gave up as it needs too many lines of code. Here I write down a smarter way in plain language which is actually from other user's codes to solve the problem.\\n\\n1, To know whether the two areas are not overlapped: \\n\\n - We actually only need to consider four situations: B>=H or E>=C or F>=D or A>=G. For example, if B is larger than H, the area (A,B,C,D) is definitely not overlapped with area (E,F,G,H), and we even know that area (A,B,C,D) is on the upper area of the plot compared with area (E,F,G,H). You can also check if other situations work.\\n\\n2, To calculate the overlapped area:\\n\\n - When the two areas are overlapped, we only need to know the bottom left corner and top right corner of the overlapped area: the larger one of A and E, the larger one of B and F, the smaller one of C and G, and the smaller one of D and H. For example, in the case of the given figure of the original problem, we just consider the point (E,B) and the point (C,H), and the overlapped area is (E,B,C,H) which could be calculated intuitively. So how about other kinds of overlapping? The formula given above never change! You can try imagining other kind of  overlapped area, you will see that in any case we only need to know max(A,E), max(B,F), min(C,G), and min(D,H) to calculate the overlapped area.\\n\\nI don't consider this problem as an easy one, if you try to solve it intuitively."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Two know if they are overlapping, we can do like this \\nfor X coordinate -> max(ax1,bx1)<min(ax2,bx2)\\nfor y coordinate -> max(ay1,by1)<min(ay2,by2)"
                    },
                    {
                        "username": "madokamylove",
                        "content": "In the statement, it says\\n*\"Each rectangle is defined by its bottom left corner and top right corner\"*\\n\\nHowever, there are test cases like \\n\\nInput:\\t-2, -2, 2, 2, -3, 3, -4, 4\\n\\nWhich is wrong, because there are no rectangles with bottom left corner (-3, 3) and top right corner (-4, 4)."
                    },
                    {
                        "username": "isinghabhishek",
                        "content": "https://leetcode.com/problems/rectangle-area/solutions/3114906/java-easy-to-understand-beats-100-simple-approach-beginner-friendly-2ms/"
                    },
                    {
                        "username": "kevv96",
                        "content": "answer = sum of two areas - overlap area\\n\\noverlap rectangle coordinates:\\n        cx1 = max(ax1, bx1)\\n        cx2 = min(ax2, bx2)\\n        cy1 = max(ay1, by1)\\n        cy2 = min(ay2, by2)\\n\\noverlap area = max(0, cx2 - cx1) * max(0, cy2 - cy1)\\n\\ndone!"
                    },
                    {
                        "username": "kevv96",
                        "content": "[@ayush391](/ayush391) You are welcome mate \\uD83D\\uDE0A"
                    },
                    {
                        "username": "ayush391",
                        "content": "A simple and concise answer. thnks mate."
                    },
                    {
                        "username": "varunshrivastava2706",
                        "content": "BORINGGGG........................"
                    },
                    {
                        "username": "riyan372828",
                        "content": "\\n**Watch this video for the better explanation of the code.**\\nhttps://www.youtube.com/watch?v=0wjT7XQfXEo\\n\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "I though if a a rectangle has points as x1 , y1 , x2 , y2 \\nthe the area covered by it would be (x2 - x1  + 1) * (y2 - y1 + 1) which is giving wrong ans.\\nAnd (x2 - x1) * (y2 - y1) is giving correct ans! \\nHow ?\\n\\nSay x1 == x2 and y1 == y2 then area covered should be 1 , not 0! Doesn\\'t make sense."
                    },
                    {
                        "username": "sigrayornot",
                        "content": "if x1 == x2 or y1 == y2, then side length = 0, then area = 0 * another side => area = 0"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "[@grkem](/grkem) Thanks now I see , I was actually considering area to the no of points. My bad."
                    },
                    {
                        "username": "Peachyy",
                        "content": "If x1 == x2 and y1 == y2 it would not be a rectangle but a point on the grid"
                    },
                    {
                        "username": "grkem",
                        "content": "You are thinking about something else, counting the number of points on a rectangular shape on a grid. I am not even sure if that is called \"area\". The question defines a continuous plane, not a discrete one."
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "rectange to rectangle, rectange to circle, circle to circle, triangle to rectangle, ball to rectangle ..etc...\\nFor game deverloper only."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "collision detection !!"
                    },
                    {
                        "username": "user4898sC",
                        "content": "Why is this medium?"
                    },
                    {
                        "username": "usmonali",
                        "content": "what do you mean? is it so easy? if yes, then I agree"
                    },
                    {
                        "username": "drap5468",
                        "content": "It\\'s certainly not the hardest medium in the world, but I think \"medium\" is fair, because it requires a bit of thought to figure out a good way of calculating the overlapping area.\\n\\nGenerally speaking, \"easy\" problems are those that essentially require 0 creativity, just applying something that (leetcode expects) you already know. The small amount of thought required to figure out a new problem you\\'ve never seen before, like calculating the overlapping area, is enough to count as a medium IMO"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\n\\nStep 1 : Find the area of Rectangle 1 assume AR1\\nStep 2 : Find the area of Rectangle 2 assume AR2\\nStep 3 : Try to find a way to tell if the rectangles are overlapping or not (if they are not, return AR1 + AR2)\\nStep 3 : Find the area of intersecting rectangle formed assume IR and return AR1 + AR2 - IR.\\n\\n\\nHINT 2:\\nAll the steps might seem really easy except the third one.\\nTo find if the rectangles overlap.... find the maximum of their left extremes(L) and minimum of their right extremes(R) and similarly take the minimum of top extremes(T) and maximum of bottom extremes(B) co-ordinates \\nAnd now if the difference between R and L comes out to be negative and similarly the difference between T and B comes out to be negative, the rectangles do not intersect / overlap.\\n"
                    },
                    {
                        "username": "Ayush_km_gupta",
                        "content": "HII NICE QUESTION HELP IN INTERVIEW PREPRATION>"
                    }
                ]
            },
            {
                "id": 1687516,
                "content": [
                    {
                        "username": "shintaroid",
                        "content": "We should consider the following two problems:\\n\\n 1. How to know whether the two rectangle areas are not overlapped.\\n 2. If the two rectangle areas are overlapped, how to calculate the overlapped area.\\n\\nFor me, both situations are not intuitive to see. I tried the intuitive solution, but I gave up as it needs too many lines of code. Here I write down a smarter way in plain language which is actually from other user's codes to solve the problem.\\n\\n1, To know whether the two areas are not overlapped: \\n\\n - We actually only need to consider four situations: B>=H or E>=C or F>=D or A>=G. For example, if B is larger than H, the area (A,B,C,D) is definitely not overlapped with area (E,F,G,H), and we even know that area (A,B,C,D) is on the upper area of the plot compared with area (E,F,G,H). You can also check if other situations work.\\n\\n2, To calculate the overlapped area:\\n\\n - When the two areas are overlapped, we only need to know the bottom left corner and top right corner of the overlapped area: the larger one of A and E, the larger one of B and F, the smaller one of C and G, and the smaller one of D and H. For example, in the case of the given figure of the original problem, we just consider the point (E,B) and the point (C,H), and the overlapped area is (E,B,C,H) which could be calculated intuitively. So how about other kinds of overlapping? The formula given above never change! You can try imagining other kind of  overlapped area, you will see that in any case we only need to know max(A,E), max(B,F), min(C,G), and min(D,H) to calculate the overlapped area.\\n\\nI don't consider this problem as an easy one, if you try to solve it intuitively."
                    },
                    {
                        "username": "nirutgupta",
                        "content": "Two know if they are overlapping, we can do like this \\nfor X coordinate -> max(ax1,bx1)<min(ax2,bx2)\\nfor y coordinate -> max(ay1,by1)<min(ay2,by2)"
                    },
                    {
                        "username": "madokamylove",
                        "content": "In the statement, it says\\n*\"Each rectangle is defined by its bottom left corner and top right corner\"*\\n\\nHowever, there are test cases like \\n\\nInput:\\t-2, -2, 2, 2, -3, 3, -4, 4\\n\\nWhich is wrong, because there are no rectangles with bottom left corner (-3, 3) and top right corner (-4, 4)."
                    },
                    {
                        "username": "isinghabhishek",
                        "content": "https://leetcode.com/problems/rectangle-area/solutions/3114906/java-easy-to-understand-beats-100-simple-approach-beginner-friendly-2ms/"
                    },
                    {
                        "username": "kevv96",
                        "content": "answer = sum of two areas - overlap area\\n\\noverlap rectangle coordinates:\\n        cx1 = max(ax1, bx1)\\n        cx2 = min(ax2, bx2)\\n        cy1 = max(ay1, by1)\\n        cy2 = min(ay2, by2)\\n\\noverlap area = max(0, cx2 - cx1) * max(0, cy2 - cy1)\\n\\ndone!"
                    },
                    {
                        "username": "kevv96",
                        "content": "[@ayush391](/ayush391) You are welcome mate \\uD83D\\uDE0A"
                    },
                    {
                        "username": "ayush391",
                        "content": "A simple and concise answer. thnks mate."
                    },
                    {
                        "username": "varunshrivastava2706",
                        "content": "BORINGGGG........................"
                    },
                    {
                        "username": "riyan372828",
                        "content": "\\n**Watch this video for the better explanation of the code.**\\nhttps://www.youtube.com/watch?v=0wjT7XQfXEo\\n\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "I though if a a rectangle has points as x1 , y1 , x2 , y2 \\nthe the area covered by it would be (x2 - x1  + 1) * (y2 - y1 + 1) which is giving wrong ans.\\nAnd (x2 - x1) * (y2 - y1) is giving correct ans! \\nHow ?\\n\\nSay x1 == x2 and y1 == y2 then area covered should be 1 , not 0! Doesn\\'t make sense."
                    },
                    {
                        "username": "sigrayornot",
                        "content": "if x1 == x2 or y1 == y2, then side length = 0, then area = 0 * another side => area = 0"
                    },
                    {
                        "username": "saranyamaity2000",
                        "content": "[@grkem](/grkem) Thanks now I see , I was actually considering area to the no of points. My bad."
                    },
                    {
                        "username": "Peachyy",
                        "content": "If x1 == x2 and y1 == y2 it would not be a rectangle but a point on the grid"
                    },
                    {
                        "username": "grkem",
                        "content": "You are thinking about something else, counting the number of points on a rectangular shape on a grid. I am not even sure if that is called \"area\". The question defines a continuous plane, not a discrete one."
                    },
                    {
                        "username": "anhongleetcode",
                        "content": "rectange to rectangle, rectange to circle, circle to circle, triangle to rectangle, ball to rectangle ..etc...\\nFor game deverloper only."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "collision detection !!"
                    },
                    {
                        "username": "user4898sC",
                        "content": "Why is this medium?"
                    },
                    {
                        "username": "usmonali",
                        "content": "what do you mean? is it so easy? if yes, then I agree"
                    },
                    {
                        "username": "drap5468",
                        "content": "It\\'s certainly not the hardest medium in the world, but I think \"medium\" is fair, because it requires a bit of thought to figure out a good way of calculating the overlapping area.\\n\\nGenerally speaking, \"easy\" problems are those that essentially require 0 creativity, just applying something that (leetcode expects) you already know. The small amount of thought required to figure out a new problem you\\'ve never seen before, like calculating the overlapping area, is enough to count as a medium IMO"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\n\\nStep 1 : Find the area of Rectangle 1 assume AR1\\nStep 2 : Find the area of Rectangle 2 assume AR2\\nStep 3 : Try to find a way to tell if the rectangles are overlapping or not (if they are not, return AR1 + AR2)\\nStep 3 : Find the area of intersecting rectangle formed assume IR and return AR1 + AR2 - IR.\\n\\n\\nHINT 2:\\nAll the steps might seem really easy except the third one.\\nTo find if the rectangles overlap.... find the maximum of their left extremes(L) and minimum of their right extremes(R) and similarly take the minimum of top extremes(T) and maximum of bottom extremes(B) co-ordinates \\nAnd now if the difference between R and L comes out to be negative and similarly the difference between T and B comes out to be negative, the rectangles do not intersect / overlap.\\n"
                    },
                    {
                        "username": "Ayush_km_gupta",
                        "content": "HII NICE QUESTION HELP IN INTERVIEW PREPRATION>"
                    }
                ]
            },
            {
                "id": 1687236,
                "content": [
                    {
                        "username": "AlexTyu",
                        "content": "How is ay1 = 0? Doesn\\'t \\'y\\' represent the vertical axis? if ay1 would be 0, then the area of the first rectangle would also be 0, because it wouldn\\'t have a height."
                    },
                    {
                        "username": "malikharshit03",
                        "content": "ay1 is the first y co-ordinate of the rectangle A. \\nIn other terms, ay1 represents the y co-ordinate of the bottom left corner of rectangle A.\\nIt does not represent the height.\\nThe height will be represented by ay2 - ay1, that is, the difference between the upper y co-ordinate - the lower y co-ordinate."
                    },
                    {
                        "username": "jehung",
                        "content": "Hi there, \\n\\nI am very new here and I am having trouble reading the inputs A, B, C, D, E, F, G, H. Can someone please shed some light on how each of these integers relate to the vertices of the 2 rectangles? I thought that A and B relate to the lower end and upper end of the x-axis for the first rectangle, etc. But this interpretation is apparently wrong based on the test case. \\n\\nPlease help!\\n\\nThanks"
                    },
                    {
                        "username": "Cosmic_Phantom",
                        "content": "(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) is equivalent to (int A, int B, int C, int D, int E, int F, int G, int H) and now see the figure given inside the description you will get which point is where. Horizontal axis is x-axis and vertical is y-axis"
                    },
                    {
                        "username": "WindInHisHair",
                        "content": "Is it correct for following test case?\\n\\nInput:\\n0\\n0\\n0\\n0\\n-1\\n-1\\n1\\n1\\n\\nExpected:\\n4\\n\\n a point inside a rectangle , then overlap is the area of rectangle?"
                    },
                    {
                        "username": "ethan8",
                        "content": "return (C-A)*(D-B)+(G-E)*(H-F)-max(min(min(G-A,C-E),min(G-E,C-A)),0)*max(min(min(D-F,H-B),min(D-B,H-F)),0);"
                    },
                    {
                        "username": "grebator",
                        "content": "Python one-liner:\\n\\n `return (ax2 - ax1) * (ay2 - ay1) + (bx2 - bx1) * (by2 - by1) - max(0, min(ax2, bx2) - max(ax1, bx1)) * max(0, min(ay2, by2) - max(ay1, by1))`"
                    },
                    {
                        "username": "DarkAutumnWind",
                        "content": "Hello,\\n\\nI get the following test case:\\n-2\\n-2\\n2\\n2\\n3\\n3\\n4\\n4\\n\\nThe expected result is: 17 while my output is 0;\\nI am confused because I think there is no overlap area. Any idea? Thanks."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Don\\'t overthink "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "In game development there is a concept for detecting collision known as Axis Aligned Bounding Boxes. There is a pretty simple formula to detect 2d and even 3d collision - The 2d version, translated into this problems variables, is this:\\n ```\\nreturn ax1 <= bx2 &&\\n               ax2 >= bx1 &&\\n               ay1 <= by2 &&\\n               ay2 >= by1;\\n```"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 why this problem has so many dislikes"
                    },
                    {
                        "username": "Furies",
                        "content": "How is this medium???"
                    }
                ]
            },
            {
                "id": 1571453,
                "content": [
                    {
                        "username": "AlexTyu",
                        "content": "How is ay1 = 0? Doesn\\'t \\'y\\' represent the vertical axis? if ay1 would be 0, then the area of the first rectangle would also be 0, because it wouldn\\'t have a height."
                    },
                    {
                        "username": "malikharshit03",
                        "content": "ay1 is the first y co-ordinate of the rectangle A. \\nIn other terms, ay1 represents the y co-ordinate of the bottom left corner of rectangle A.\\nIt does not represent the height.\\nThe height will be represented by ay2 - ay1, that is, the difference between the upper y co-ordinate - the lower y co-ordinate."
                    },
                    {
                        "username": "jehung",
                        "content": "Hi there, \\n\\nI am very new here and I am having trouble reading the inputs A, B, C, D, E, F, G, H. Can someone please shed some light on how each of these integers relate to the vertices of the 2 rectangles? I thought that A and B relate to the lower end and upper end of the x-axis for the first rectangle, etc. But this interpretation is apparently wrong based on the test case. \\n\\nPlease help!\\n\\nThanks"
                    },
                    {
                        "username": "Cosmic_Phantom",
                        "content": "(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) is equivalent to (int A, int B, int C, int D, int E, int F, int G, int H) and now see the figure given inside the description you will get which point is where. Horizontal axis is x-axis and vertical is y-axis"
                    },
                    {
                        "username": "WindInHisHair",
                        "content": "Is it correct for following test case?\\n\\nInput:\\n0\\n0\\n0\\n0\\n-1\\n-1\\n1\\n1\\n\\nExpected:\\n4\\n\\n a point inside a rectangle , then overlap is the area of rectangle?"
                    },
                    {
                        "username": "ethan8",
                        "content": "return (C-A)*(D-B)+(G-E)*(H-F)-max(min(min(G-A,C-E),min(G-E,C-A)),0)*max(min(min(D-F,H-B),min(D-B,H-F)),0);"
                    },
                    {
                        "username": "grebator",
                        "content": "Python one-liner:\\n\\n `return (ax2 - ax1) * (ay2 - ay1) + (bx2 - bx1) * (by2 - by1) - max(0, min(ax2, bx2) - max(ax1, bx1)) * max(0, min(ay2, by2) - max(ay1, by1))`"
                    },
                    {
                        "username": "DarkAutumnWind",
                        "content": "Hello,\\n\\nI get the following test case:\\n-2\\n-2\\n2\\n2\\n3\\n3\\n4\\n4\\n\\nThe expected result is: 17 while my output is 0;\\nI am confused because I think there is no overlap area. Any idea? Thanks."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Don\\'t overthink "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "In game development there is a concept for detecting collision known as Axis Aligned Bounding Boxes. There is a pretty simple formula to detect 2d and even 3d collision - The 2d version, translated into this problems variables, is this:\\n ```\\nreturn ax1 <= bx2 &&\\n               ax2 >= bx1 &&\\n               ay1 <= by2 &&\\n               ay2 >= by1;\\n```"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 why this problem has so many dislikes"
                    },
                    {
                        "username": "Furies",
                        "content": "How is this medium???"
                    }
                ]
            },
            {
                "id": 1571455,
                "content": [
                    {
                        "username": "AlexTyu",
                        "content": "How is ay1 = 0? Doesn\\'t \\'y\\' represent the vertical axis? if ay1 would be 0, then the area of the first rectangle would also be 0, because it wouldn\\'t have a height."
                    },
                    {
                        "username": "malikharshit03",
                        "content": "ay1 is the first y co-ordinate of the rectangle A. \\nIn other terms, ay1 represents the y co-ordinate of the bottom left corner of rectangle A.\\nIt does not represent the height.\\nThe height will be represented by ay2 - ay1, that is, the difference between the upper y co-ordinate - the lower y co-ordinate."
                    },
                    {
                        "username": "jehung",
                        "content": "Hi there, \\n\\nI am very new here and I am having trouble reading the inputs A, B, C, D, E, F, G, H. Can someone please shed some light on how each of these integers relate to the vertices of the 2 rectangles? I thought that A and B relate to the lower end and upper end of the x-axis for the first rectangle, etc. But this interpretation is apparently wrong based on the test case. \\n\\nPlease help!\\n\\nThanks"
                    },
                    {
                        "username": "Cosmic_Phantom",
                        "content": "(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) is equivalent to (int A, int B, int C, int D, int E, int F, int G, int H) and now see the figure given inside the description you will get which point is where. Horizontal axis is x-axis and vertical is y-axis"
                    },
                    {
                        "username": "WindInHisHair",
                        "content": "Is it correct for following test case?\\n\\nInput:\\n0\\n0\\n0\\n0\\n-1\\n-1\\n1\\n1\\n\\nExpected:\\n4\\n\\n a point inside a rectangle , then overlap is the area of rectangle?"
                    },
                    {
                        "username": "ethan8",
                        "content": "return (C-A)*(D-B)+(G-E)*(H-F)-max(min(min(G-A,C-E),min(G-E,C-A)),0)*max(min(min(D-F,H-B),min(D-B,H-F)),0);"
                    },
                    {
                        "username": "grebator",
                        "content": "Python one-liner:\\n\\n `return (ax2 - ax1) * (ay2 - ay1) + (bx2 - bx1) * (by2 - by1) - max(0, min(ax2, bx2) - max(ax1, bx1)) * max(0, min(ay2, by2) - max(ay1, by1))`"
                    },
                    {
                        "username": "DarkAutumnWind",
                        "content": "Hello,\\n\\nI get the following test case:\\n-2\\n-2\\n2\\n2\\n3\\n3\\n4\\n4\\n\\nThe expected result is: 17 while my output is 0;\\nI am confused because I think there is no overlap area. Any idea? Thanks."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Don\\'t overthink "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "In game development there is a concept for detecting collision known as Axis Aligned Bounding Boxes. There is a pretty simple formula to detect 2d and even 3d collision - The 2d version, translated into this problems variables, is this:\\n ```\\nreturn ax1 <= bx2 &&\\n               ax2 >= bx1 &&\\n               ay1 <= by2 &&\\n               ay2 >= by1;\\n```"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 why this problem has so many dislikes"
                    },
                    {
                        "username": "Furies",
                        "content": "How is this medium???"
                    }
                ]
            },
            {
                "id": 1571456,
                "content": [
                    {
                        "username": "AlexTyu",
                        "content": "How is ay1 = 0? Doesn\\'t \\'y\\' represent the vertical axis? if ay1 would be 0, then the area of the first rectangle would also be 0, because it wouldn\\'t have a height."
                    },
                    {
                        "username": "malikharshit03",
                        "content": "ay1 is the first y co-ordinate of the rectangle A. \\nIn other terms, ay1 represents the y co-ordinate of the bottom left corner of rectangle A.\\nIt does not represent the height.\\nThe height will be represented by ay2 - ay1, that is, the difference between the upper y co-ordinate - the lower y co-ordinate."
                    },
                    {
                        "username": "jehung",
                        "content": "Hi there, \\n\\nI am very new here and I am having trouble reading the inputs A, B, C, D, E, F, G, H. Can someone please shed some light on how each of these integers relate to the vertices of the 2 rectangles? I thought that A and B relate to the lower end and upper end of the x-axis for the first rectangle, etc. But this interpretation is apparently wrong based on the test case. \\n\\nPlease help!\\n\\nThanks"
                    },
                    {
                        "username": "Cosmic_Phantom",
                        "content": "(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) is equivalent to (int A, int B, int C, int D, int E, int F, int G, int H) and now see the figure given inside the description you will get which point is where. Horizontal axis is x-axis and vertical is y-axis"
                    },
                    {
                        "username": "WindInHisHair",
                        "content": "Is it correct for following test case?\\n\\nInput:\\n0\\n0\\n0\\n0\\n-1\\n-1\\n1\\n1\\n\\nExpected:\\n4\\n\\n a point inside a rectangle , then overlap is the area of rectangle?"
                    },
                    {
                        "username": "ethan8",
                        "content": "return (C-A)*(D-B)+(G-E)*(H-F)-max(min(min(G-A,C-E),min(G-E,C-A)),0)*max(min(min(D-F,H-B),min(D-B,H-F)),0);"
                    },
                    {
                        "username": "grebator",
                        "content": "Python one-liner:\\n\\n `return (ax2 - ax1) * (ay2 - ay1) + (bx2 - bx1) * (by2 - by1) - max(0, min(ax2, bx2) - max(ax1, bx1)) * max(0, min(ay2, by2) - max(ay1, by1))`"
                    },
                    {
                        "username": "DarkAutumnWind",
                        "content": "Hello,\\n\\nI get the following test case:\\n-2\\n-2\\n2\\n2\\n3\\n3\\n4\\n4\\n\\nThe expected result is: 17 while my output is 0;\\nI am confused because I think there is no overlap area. Any idea? Thanks."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Don\\'t overthink "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "In game development there is a concept for detecting collision known as Axis Aligned Bounding Boxes. There is a pretty simple formula to detect 2d and even 3d collision - The 2d version, translated into this problems variables, is this:\\n ```\\nreturn ax1 <= bx2 &&\\n               ax2 >= bx1 &&\\n               ay1 <= by2 &&\\n               ay2 >= by1;\\n```"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 why this problem has so many dislikes"
                    },
                    {
                        "username": "Furies",
                        "content": "How is this medium???"
                    }
                ]
            },
            {
                "id": 1686733,
                "content": [
                    {
                        "username": "AlexTyu",
                        "content": "How is ay1 = 0? Doesn\\'t \\'y\\' represent the vertical axis? if ay1 would be 0, then the area of the first rectangle would also be 0, because it wouldn\\'t have a height."
                    },
                    {
                        "username": "malikharshit03",
                        "content": "ay1 is the first y co-ordinate of the rectangle A. \\nIn other terms, ay1 represents the y co-ordinate of the bottom left corner of rectangle A.\\nIt does not represent the height.\\nThe height will be represented by ay2 - ay1, that is, the difference between the upper y co-ordinate - the lower y co-ordinate."
                    },
                    {
                        "username": "jehung",
                        "content": "Hi there, \\n\\nI am very new here and I am having trouble reading the inputs A, B, C, D, E, F, G, H. Can someone please shed some light on how each of these integers relate to the vertices of the 2 rectangles? I thought that A and B relate to the lower end and upper end of the x-axis for the first rectangle, etc. But this interpretation is apparently wrong based on the test case. \\n\\nPlease help!\\n\\nThanks"
                    },
                    {
                        "username": "Cosmic_Phantom",
                        "content": "(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) is equivalent to (int A, int B, int C, int D, int E, int F, int G, int H) and now see the figure given inside the description you will get which point is where. Horizontal axis is x-axis and vertical is y-axis"
                    },
                    {
                        "username": "WindInHisHair",
                        "content": "Is it correct for following test case?\\n\\nInput:\\n0\\n0\\n0\\n0\\n-1\\n-1\\n1\\n1\\n\\nExpected:\\n4\\n\\n a point inside a rectangle , then overlap is the area of rectangle?"
                    },
                    {
                        "username": "ethan8",
                        "content": "return (C-A)*(D-B)+(G-E)*(H-F)-max(min(min(G-A,C-E),min(G-E,C-A)),0)*max(min(min(D-F,H-B),min(D-B,H-F)),0);"
                    },
                    {
                        "username": "grebator",
                        "content": "Python one-liner:\\n\\n `return (ax2 - ax1) * (ay2 - ay1) + (bx2 - bx1) * (by2 - by1) - max(0, min(ax2, bx2) - max(ax1, bx1)) * max(0, min(ay2, by2) - max(ay1, by1))`"
                    },
                    {
                        "username": "DarkAutumnWind",
                        "content": "Hello,\\n\\nI get the following test case:\\n-2\\n-2\\n2\\n2\\n3\\n3\\n4\\n4\\n\\nThe expected result is: 17 while my output is 0;\\nI am confused because I think there is no overlap area. Any idea? Thanks."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Don\\'t overthink "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "In game development there is a concept for detecting collision known as Axis Aligned Bounding Boxes. There is a pretty simple formula to detect 2d and even 3d collision - The 2d version, translated into this problems variables, is this:\\n ```\\nreturn ax1 <= bx2 &&\\n               ax2 >= bx1 &&\\n               ay1 <= by2 &&\\n               ay2 >= by1;\\n```"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 why this problem has so many dislikes"
                    },
                    {
                        "username": "Furies",
                        "content": "How is this medium???"
                    }
                ]
            },
            {
                "id": 1571454,
                "content": [
                    {
                        "username": "AlexTyu",
                        "content": "How is ay1 = 0? Doesn\\'t \\'y\\' represent the vertical axis? if ay1 would be 0, then the area of the first rectangle would also be 0, because it wouldn\\'t have a height."
                    },
                    {
                        "username": "malikharshit03",
                        "content": "ay1 is the first y co-ordinate of the rectangle A. \\nIn other terms, ay1 represents the y co-ordinate of the bottom left corner of rectangle A.\\nIt does not represent the height.\\nThe height will be represented by ay2 - ay1, that is, the difference between the upper y co-ordinate - the lower y co-ordinate."
                    },
                    {
                        "username": "jehung",
                        "content": "Hi there, \\n\\nI am very new here and I am having trouble reading the inputs A, B, C, D, E, F, G, H. Can someone please shed some light on how each of these integers relate to the vertices of the 2 rectangles? I thought that A and B relate to the lower end and upper end of the x-axis for the first rectangle, etc. But this interpretation is apparently wrong based on the test case. \\n\\nPlease help!\\n\\nThanks"
                    },
                    {
                        "username": "Cosmic_Phantom",
                        "content": "(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) is equivalent to (int A, int B, int C, int D, int E, int F, int G, int H) and now see the figure given inside the description you will get which point is where. Horizontal axis is x-axis and vertical is y-axis"
                    },
                    {
                        "username": "WindInHisHair",
                        "content": "Is it correct for following test case?\\n\\nInput:\\n0\\n0\\n0\\n0\\n-1\\n-1\\n1\\n1\\n\\nExpected:\\n4\\n\\n a point inside a rectangle , then overlap is the area of rectangle?"
                    },
                    {
                        "username": "ethan8",
                        "content": "return (C-A)*(D-B)+(G-E)*(H-F)-max(min(min(G-A,C-E),min(G-E,C-A)),0)*max(min(min(D-F,H-B),min(D-B,H-F)),0);"
                    },
                    {
                        "username": "grebator",
                        "content": "Python one-liner:\\n\\n `return (ax2 - ax1) * (ay2 - ay1) + (bx2 - bx1) * (by2 - by1) - max(0, min(ax2, bx2) - max(ax1, bx1)) * max(0, min(ay2, by2) - max(ay1, by1))`"
                    },
                    {
                        "username": "DarkAutumnWind",
                        "content": "Hello,\\n\\nI get the following test case:\\n-2\\n-2\\n2\\n2\\n3\\n3\\n4\\n4\\n\\nThe expected result is: 17 while my output is 0;\\nI am confused because I think there is no overlap area. Any idea? Thanks."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Don\\'t overthink "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "In game development there is a concept for detecting collision known as Axis Aligned Bounding Boxes. There is a pretty simple formula to detect 2d and even 3d collision - The 2d version, translated into this problems variables, is this:\\n ```\\nreturn ax1 <= bx2 &&\\n               ax2 >= bx1 &&\\n               ay1 <= by2 &&\\n               ay2 >= by1;\\n```"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 why this problem has so many dislikes"
                    },
                    {
                        "username": "Furies",
                        "content": "How is this medium???"
                    }
                ]
            },
            {
                "id": 2055798,
                "content": [
                    {
                        "username": "AlexTyu",
                        "content": "How is ay1 = 0? Doesn\\'t \\'y\\' represent the vertical axis? if ay1 would be 0, then the area of the first rectangle would also be 0, because it wouldn\\'t have a height."
                    },
                    {
                        "username": "malikharshit03",
                        "content": "ay1 is the first y co-ordinate of the rectangle A. \\nIn other terms, ay1 represents the y co-ordinate of the bottom left corner of rectangle A.\\nIt does not represent the height.\\nThe height will be represented by ay2 - ay1, that is, the difference between the upper y co-ordinate - the lower y co-ordinate."
                    },
                    {
                        "username": "jehung",
                        "content": "Hi there, \\n\\nI am very new here and I am having trouble reading the inputs A, B, C, D, E, F, G, H. Can someone please shed some light on how each of these integers relate to the vertices of the 2 rectangles? I thought that A and B relate to the lower end and upper end of the x-axis for the first rectangle, etc. But this interpretation is apparently wrong based on the test case. \\n\\nPlease help!\\n\\nThanks"
                    },
                    {
                        "username": "Cosmic_Phantom",
                        "content": "(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) is equivalent to (int A, int B, int C, int D, int E, int F, int G, int H) and now see the figure given inside the description you will get which point is where. Horizontal axis is x-axis and vertical is y-axis"
                    },
                    {
                        "username": "WindInHisHair",
                        "content": "Is it correct for following test case?\\n\\nInput:\\n0\\n0\\n0\\n0\\n-1\\n-1\\n1\\n1\\n\\nExpected:\\n4\\n\\n a point inside a rectangle , then overlap is the area of rectangle?"
                    },
                    {
                        "username": "ethan8",
                        "content": "return (C-A)*(D-B)+(G-E)*(H-F)-max(min(min(G-A,C-E),min(G-E,C-A)),0)*max(min(min(D-F,H-B),min(D-B,H-F)),0);"
                    },
                    {
                        "username": "grebator",
                        "content": "Python one-liner:\\n\\n `return (ax2 - ax1) * (ay2 - ay1) + (bx2 - bx1) * (by2 - by1) - max(0, min(ax2, bx2) - max(ax1, bx1)) * max(0, min(ay2, by2) - max(ay1, by1))`"
                    },
                    {
                        "username": "DarkAutumnWind",
                        "content": "Hello,\\n\\nI get the following test case:\\n-2\\n-2\\n2\\n2\\n3\\n3\\n4\\n4\\n\\nThe expected result is: 17 while my output is 0;\\nI am confused because I think there is no overlap area. Any idea? Thanks."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Don\\'t overthink "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "In game development there is a concept for detecting collision known as Axis Aligned Bounding Boxes. There is a pretty simple formula to detect 2d and even 3d collision - The 2d version, translated into this problems variables, is this:\\n ```\\nreturn ax1 <= bx2 &&\\n               ax2 >= bx1 &&\\n               ay1 <= by2 &&\\n               ay2 >= by1;\\n```"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 why this problem has so many dislikes"
                    },
                    {
                        "username": "Furies",
                        "content": "How is this medium???"
                    }
                ]
            },
            {
                "id": 2055373,
                "content": [
                    {
                        "username": "AlexTyu",
                        "content": "How is ay1 = 0? Doesn\\'t \\'y\\' represent the vertical axis? if ay1 would be 0, then the area of the first rectangle would also be 0, because it wouldn\\'t have a height."
                    },
                    {
                        "username": "malikharshit03",
                        "content": "ay1 is the first y co-ordinate of the rectangle A. \\nIn other terms, ay1 represents the y co-ordinate of the bottom left corner of rectangle A.\\nIt does not represent the height.\\nThe height will be represented by ay2 - ay1, that is, the difference between the upper y co-ordinate - the lower y co-ordinate."
                    },
                    {
                        "username": "jehung",
                        "content": "Hi there, \\n\\nI am very new here and I am having trouble reading the inputs A, B, C, D, E, F, G, H. Can someone please shed some light on how each of these integers relate to the vertices of the 2 rectangles? I thought that A and B relate to the lower end and upper end of the x-axis for the first rectangle, etc. But this interpretation is apparently wrong based on the test case. \\n\\nPlease help!\\n\\nThanks"
                    },
                    {
                        "username": "Cosmic_Phantom",
                        "content": "(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) is equivalent to (int A, int B, int C, int D, int E, int F, int G, int H) and now see the figure given inside the description you will get which point is where. Horizontal axis is x-axis and vertical is y-axis"
                    },
                    {
                        "username": "WindInHisHair",
                        "content": "Is it correct for following test case?\\n\\nInput:\\n0\\n0\\n0\\n0\\n-1\\n-1\\n1\\n1\\n\\nExpected:\\n4\\n\\n a point inside a rectangle , then overlap is the area of rectangle?"
                    },
                    {
                        "username": "ethan8",
                        "content": "return (C-A)*(D-B)+(G-E)*(H-F)-max(min(min(G-A,C-E),min(G-E,C-A)),0)*max(min(min(D-F,H-B),min(D-B,H-F)),0);"
                    },
                    {
                        "username": "grebator",
                        "content": "Python one-liner:\\n\\n `return (ax2 - ax1) * (ay2 - ay1) + (bx2 - bx1) * (by2 - by1) - max(0, min(ax2, bx2) - max(ax1, bx1)) * max(0, min(ay2, by2) - max(ay1, by1))`"
                    },
                    {
                        "username": "DarkAutumnWind",
                        "content": "Hello,\\n\\nI get the following test case:\\n-2\\n-2\\n2\\n2\\n3\\n3\\n4\\n4\\n\\nThe expected result is: 17 while my output is 0;\\nI am confused because I think there is no overlap area. Any idea? Thanks."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Don\\'t overthink "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "In game development there is a concept for detecting collision known as Axis Aligned Bounding Boxes. There is a pretty simple formula to detect 2d and even 3d collision - The 2d version, translated into this problems variables, is this:\\n ```\\nreturn ax1 <= bx2 &&\\n               ax2 >= bx1 &&\\n               ay1 <= by2 &&\\n               ay2 >= by1;\\n```"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 why this problem has so many dislikes"
                    },
                    {
                        "username": "Furies",
                        "content": "How is this medium???"
                    }
                ]
            },
            {
                "id": 1974438,
                "content": [
                    {
                        "username": "AlexTyu",
                        "content": "How is ay1 = 0? Doesn\\'t \\'y\\' represent the vertical axis? if ay1 would be 0, then the area of the first rectangle would also be 0, because it wouldn\\'t have a height."
                    },
                    {
                        "username": "malikharshit03",
                        "content": "ay1 is the first y co-ordinate of the rectangle A. \\nIn other terms, ay1 represents the y co-ordinate of the bottom left corner of rectangle A.\\nIt does not represent the height.\\nThe height will be represented by ay2 - ay1, that is, the difference between the upper y co-ordinate - the lower y co-ordinate."
                    },
                    {
                        "username": "jehung",
                        "content": "Hi there, \\n\\nI am very new here and I am having trouble reading the inputs A, B, C, D, E, F, G, H. Can someone please shed some light on how each of these integers relate to the vertices of the 2 rectangles? I thought that A and B relate to the lower end and upper end of the x-axis for the first rectangle, etc. But this interpretation is apparently wrong based on the test case. \\n\\nPlease help!\\n\\nThanks"
                    },
                    {
                        "username": "Cosmic_Phantom",
                        "content": "(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) is equivalent to (int A, int B, int C, int D, int E, int F, int G, int H) and now see the figure given inside the description you will get which point is where. Horizontal axis is x-axis and vertical is y-axis"
                    },
                    {
                        "username": "WindInHisHair",
                        "content": "Is it correct for following test case?\\n\\nInput:\\n0\\n0\\n0\\n0\\n-1\\n-1\\n1\\n1\\n\\nExpected:\\n4\\n\\n a point inside a rectangle , then overlap is the area of rectangle?"
                    },
                    {
                        "username": "ethan8",
                        "content": "return (C-A)*(D-B)+(G-E)*(H-F)-max(min(min(G-A,C-E),min(G-E,C-A)),0)*max(min(min(D-F,H-B),min(D-B,H-F)),0);"
                    },
                    {
                        "username": "grebator",
                        "content": "Python one-liner:\\n\\n `return (ax2 - ax1) * (ay2 - ay1) + (bx2 - bx1) * (by2 - by1) - max(0, min(ax2, bx2) - max(ax1, bx1)) * max(0, min(ay2, by2) - max(ay1, by1))`"
                    },
                    {
                        "username": "DarkAutumnWind",
                        "content": "Hello,\\n\\nI get the following test case:\\n-2\\n-2\\n2\\n2\\n3\\n3\\n4\\n4\\n\\nThe expected result is: 17 while my output is 0;\\nI am confused because I think there is no overlap area. Any idea? Thanks."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Don\\'t overthink "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "In game development there is a concept for detecting collision known as Axis Aligned Bounding Boxes. There is a pretty simple formula to detect 2d and even 3d collision - The 2d version, translated into this problems variables, is this:\\n ```\\nreturn ax1 <= bx2 &&\\n               ax2 >= bx1 &&\\n               ay1 <= by2 &&\\n               ay2 >= by1;\\n```"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 why this problem has so many dislikes"
                    },
                    {
                        "username": "Furies",
                        "content": "How is this medium???"
                    }
                ]
            },
            {
                "id": 1779952,
                "content": [
                    {
                        "username": "AlexTyu",
                        "content": "How is ay1 = 0? Doesn\\'t \\'y\\' represent the vertical axis? if ay1 would be 0, then the area of the first rectangle would also be 0, because it wouldn\\'t have a height."
                    },
                    {
                        "username": "malikharshit03",
                        "content": "ay1 is the first y co-ordinate of the rectangle A. \\nIn other terms, ay1 represents the y co-ordinate of the bottom left corner of rectangle A.\\nIt does not represent the height.\\nThe height will be represented by ay2 - ay1, that is, the difference between the upper y co-ordinate - the lower y co-ordinate."
                    },
                    {
                        "username": "jehung",
                        "content": "Hi there, \\n\\nI am very new here and I am having trouble reading the inputs A, B, C, D, E, F, G, H. Can someone please shed some light on how each of these integers relate to the vertices of the 2 rectangles? I thought that A and B relate to the lower end and upper end of the x-axis for the first rectangle, etc. But this interpretation is apparently wrong based on the test case. \\n\\nPlease help!\\n\\nThanks"
                    },
                    {
                        "username": "Cosmic_Phantom",
                        "content": "(int ax1, int ay1, int ax2, int ay2, int bx1, int by1, int bx2, int by2) is equivalent to (int A, int B, int C, int D, int E, int F, int G, int H) and now see the figure given inside the description you will get which point is where. Horizontal axis is x-axis and vertical is y-axis"
                    },
                    {
                        "username": "WindInHisHair",
                        "content": "Is it correct for following test case?\\n\\nInput:\\n0\\n0\\n0\\n0\\n-1\\n-1\\n1\\n1\\n\\nExpected:\\n4\\n\\n a point inside a rectangle , then overlap is the area of rectangle?"
                    },
                    {
                        "username": "ethan8",
                        "content": "return (C-A)*(D-B)+(G-E)*(H-F)-max(min(min(G-A,C-E),min(G-E,C-A)),0)*max(min(min(D-F,H-B),min(D-B,H-F)),0);"
                    },
                    {
                        "username": "grebator",
                        "content": "Python one-liner:\\n\\n `return (ax2 - ax1) * (ay2 - ay1) + (bx2 - bx1) * (by2 - by1) - max(0, min(ax2, bx2) - max(ax1, bx1)) * max(0, min(ay2, by2) - max(ay1, by1))`"
                    },
                    {
                        "username": "DarkAutumnWind",
                        "content": "Hello,\\n\\nI get the following test case:\\n-2\\n-2\\n2\\n2\\n3\\n3\\n4\\n4\\n\\nThe expected result is: 17 while my output is 0;\\nI am confused because I think there is no overlap area. Any idea? Thanks."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "Don\\'t overthink "
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "In game development there is a concept for detecting collision known as Axis Aligned Bounding Boxes. There is a pretty simple formula to detect 2d and even 3d collision - The 2d version, translated into this problems variables, is this:\\n ```\\nreturn ax1 <= bx2 &&\\n               ax2 >= bx1 &&\\n               ay1 <= by2 &&\\n               ay2 >= by1;\\n```"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 why this problem has so many dislikes"
                    },
                    {
                        "username": "Furies",
                        "content": "How is this medium???"
                    }
                ]
            }
        ]
    },
    {
        "title": "Number of Connected Components in an Undirected Graph",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1565040,
                "content": [
                    {
                        "username": "zhugejunwei",
                        "content": "In undirected graph, [2, 3] is equal to [3, 2], right?\\n\\nSo [[2,3],[1,2],[1,3]] is equal to [1,2], [[2,3], [3,1]], right?\\n\\nI don't know how the answer of `[[2,3],[1,2],[1,3]]` is **2**.\\n\\nAny ideas?\\n\\n\\n**Edit:**\\nIs it because the node `0`, which doesn't appear in the test case, but *it is actually there*?"
                    },
                    {
                        "username": "eldarnabiresearch",
                        "content": "[@user3238Gj](/user3238Gj) Good job\\n\\n"
                    },
                    {
                        "username": "worldofvadim",
                        "content": "Thank you, because of your comment understood where is the problem"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "[@user3238Gj](/user3238Gj) see the parameter n in the function, so there might be nodes without edges, so n = 4 means there are nodes: 0, 1, 2 ,3 zo 0 has no edges"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "Every node in there is connected"
                    },
                    {
                        "username": "swjung",
                        "content": "It seems like the constraint `0 <= ai <= bi < n` is not adapted."
                    },
                    {
                        "username": "Seagull360",
                        "content": "[2,3] [1,2] [1,3] are connected. so there is only 1 connected component, but leetcode test case result is 2. \\n\\n1---2---3\\n|\\n|\\n|\\n3\\n"
                    },
                    {
                        "username": "yzyluvcpsc",
                        "content": "[@angeldimitrov](/angeldimitrov) The edges only tells you which is connected to which. But number of nodes are given by n. So here n = 4, edges = [2,3],[1,2],[1,3], where you have 4 nodes (0, 1, 2, 3) and 1,2,3 is a connected cycle and 0 stands alone"
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "[@yzyluvcpsc](/yzyluvcpsc) \\'node index starts from 0\\', what is that supposed to mean? The edge list does not include 0, therefore it is not in the graph. How did you reach this conclusion that 0 is somehow in the graph?"
                    },
                    {
                        "username": "yzyluvcpsc",
                        "content": "The node index starts from 0, this testcase would be a single 0 and the circular graph you mentioned, so result is 2"
                    },
                    {
                        "username": "fuxian",
                        "content": "why result of 4 [[2,3],[1,2],[1,3]] is 2 not 1?"
                    },
                    {
                        "username": "jnesom",
                        "content": "[@irfanwustl](/irfanwustl) but that node that\\'s not included has no edges, so although it is a component,  its not connected "
                    },
                    {
                        "username": "irfanwustl",
                        "content": "Cause the edges has node 1,2 and 3. But the total node is 4. So there is a node which is not included in the edge list. "
                    },
                    {
                        "username": "jnesom",
                        "content": "Hey all,  a node all by itself with no edges is still considered a connected component. \\n\\n\\n\\n https://www.baeldung.com/cs/graph-connected-components"
                    },
                    {
                        "username": "MrGonzo",
                        "content": "for input [[2,3],[1,2],[1,3]] expected ans 2. it should be 1 right? bcz its circular connected."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "You forgot about 0 which is a standalone node."
                    },
                    {
                        "username": "newman2",
                        "content": "In the worse case, union-find is O(m log n) and BFS/DFS is O(n + m) right?\\nThen the union-find has strictly worse worst case execution time no?\\nIn practice, where the graph is sparse, the union-find can be much faster, but here I am only talking about big O time.\\nCorrect me if I am wrong."
                    },
                    {
                        "username": "andrewtoth",
                        "content": "The constraints say `0 <= ai <= bi < n`\\nbut test case 27 is `[[1,0],[2,0]]` where both `a1 > b1` and `a2>b2`\\nThis should be changed to 2 different constraints\\n`0 <= ai < n`\\nand \\n`0 <= bi < n`\\nor am I missing something about constraint syntax?"
                    },
                    {
                        "username": "lgibson",
                        "content": "I think this should be corrected in the description which says ai <= bi AND ai != bi.  Both can't be true. It should be edited as andrewtoth describes. "
                    },
                    {
                        "username": "A_Penguin",
                        "content": "This problem should be easy."
                    }
                ]
            },
            {
                "id": 1565763,
                "content": [
                    {
                        "username": "zhugejunwei",
                        "content": "In undirected graph, [2, 3] is equal to [3, 2], right?\\n\\nSo [[2,3],[1,2],[1,3]] is equal to [1,2], [[2,3], [3,1]], right?\\n\\nI don't know how the answer of `[[2,3],[1,2],[1,3]]` is **2**.\\n\\nAny ideas?\\n\\n\\n**Edit:**\\nIs it because the node `0`, which doesn't appear in the test case, but *it is actually there*?"
                    },
                    {
                        "username": "eldarnabiresearch",
                        "content": "[@user3238Gj](/user3238Gj) Good job\\n\\n"
                    },
                    {
                        "username": "worldofvadim",
                        "content": "Thank you, because of your comment understood where is the problem"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "[@user3238Gj](/user3238Gj) see the parameter n in the function, so there might be nodes without edges, so n = 4 means there are nodes: 0, 1, 2 ,3 zo 0 has no edges"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "Every node in there is connected"
                    },
                    {
                        "username": "swjung",
                        "content": "It seems like the constraint `0 <= ai <= bi < n` is not adapted."
                    },
                    {
                        "username": "Seagull360",
                        "content": "[2,3] [1,2] [1,3] are connected. so there is only 1 connected component, but leetcode test case result is 2. \\n\\n1---2---3\\n|\\n|\\n|\\n3\\n"
                    },
                    {
                        "username": "yzyluvcpsc",
                        "content": "[@angeldimitrov](/angeldimitrov) The edges only tells you which is connected to which. But number of nodes are given by n. So here n = 4, edges = [2,3],[1,2],[1,3], where you have 4 nodes (0, 1, 2, 3) and 1,2,3 is a connected cycle and 0 stands alone"
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "[@yzyluvcpsc](/yzyluvcpsc) \\'node index starts from 0\\', what is that supposed to mean? The edge list does not include 0, therefore it is not in the graph. How did you reach this conclusion that 0 is somehow in the graph?"
                    },
                    {
                        "username": "yzyluvcpsc",
                        "content": "The node index starts from 0, this testcase would be a single 0 and the circular graph you mentioned, so result is 2"
                    },
                    {
                        "username": "fuxian",
                        "content": "why result of 4 [[2,3],[1,2],[1,3]] is 2 not 1?"
                    },
                    {
                        "username": "jnesom",
                        "content": "[@irfanwustl](/irfanwustl) but that node that\\'s not included has no edges, so although it is a component,  its not connected "
                    },
                    {
                        "username": "irfanwustl",
                        "content": "Cause the edges has node 1,2 and 3. But the total node is 4. So there is a node which is not included in the edge list. "
                    },
                    {
                        "username": "jnesom",
                        "content": "Hey all,  a node all by itself with no edges is still considered a connected component. \\n\\n\\n\\n https://www.baeldung.com/cs/graph-connected-components"
                    },
                    {
                        "username": "MrGonzo",
                        "content": "for input [[2,3],[1,2],[1,3]] expected ans 2. it should be 1 right? bcz its circular connected."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "You forgot about 0 which is a standalone node."
                    },
                    {
                        "username": "newman2",
                        "content": "In the worse case, union-find is O(m log n) and BFS/DFS is O(n + m) right?\\nThen the union-find has strictly worse worst case execution time no?\\nIn practice, where the graph is sparse, the union-find can be much faster, but here I am only talking about big O time.\\nCorrect me if I am wrong."
                    },
                    {
                        "username": "andrewtoth",
                        "content": "The constraints say `0 <= ai <= bi < n`\\nbut test case 27 is `[[1,0],[2,0]]` where both `a1 > b1` and `a2>b2`\\nThis should be changed to 2 different constraints\\n`0 <= ai < n`\\nand \\n`0 <= bi < n`\\nor am I missing something about constraint syntax?"
                    },
                    {
                        "username": "lgibson",
                        "content": "I think this should be corrected in the description which says ai <= bi AND ai != bi.  Both can't be true. It should be edited as andrewtoth describes. "
                    },
                    {
                        "username": "A_Penguin",
                        "content": "This problem should be easy."
                    }
                ]
            },
            {
                "id": 1776556,
                "content": [
                    {
                        "username": "zhugejunwei",
                        "content": "In undirected graph, [2, 3] is equal to [3, 2], right?\\n\\nSo [[2,3],[1,2],[1,3]] is equal to [1,2], [[2,3], [3,1]], right?\\n\\nI don't know how the answer of `[[2,3],[1,2],[1,3]]` is **2**.\\n\\nAny ideas?\\n\\n\\n**Edit:**\\nIs it because the node `0`, which doesn't appear in the test case, but *it is actually there*?"
                    },
                    {
                        "username": "eldarnabiresearch",
                        "content": "[@user3238Gj](/user3238Gj) Good job\\n\\n"
                    },
                    {
                        "username": "worldofvadim",
                        "content": "Thank you, because of your comment understood where is the problem"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "[@user3238Gj](/user3238Gj) see the parameter n in the function, so there might be nodes without edges, so n = 4 means there are nodes: 0, 1, 2 ,3 zo 0 has no edges"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "Every node in there is connected"
                    },
                    {
                        "username": "swjung",
                        "content": "It seems like the constraint `0 <= ai <= bi < n` is not adapted."
                    },
                    {
                        "username": "Seagull360",
                        "content": "[2,3] [1,2] [1,3] are connected. so there is only 1 connected component, but leetcode test case result is 2. \\n\\n1---2---3\\n|\\n|\\n|\\n3\\n"
                    },
                    {
                        "username": "yzyluvcpsc",
                        "content": "[@angeldimitrov](/angeldimitrov) The edges only tells you which is connected to which. But number of nodes are given by n. So here n = 4, edges = [2,3],[1,2],[1,3], where you have 4 nodes (0, 1, 2, 3) and 1,2,3 is a connected cycle and 0 stands alone"
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "[@yzyluvcpsc](/yzyluvcpsc) \\'node index starts from 0\\', what is that supposed to mean? The edge list does not include 0, therefore it is not in the graph. How did you reach this conclusion that 0 is somehow in the graph?"
                    },
                    {
                        "username": "yzyluvcpsc",
                        "content": "The node index starts from 0, this testcase would be a single 0 and the circular graph you mentioned, so result is 2"
                    },
                    {
                        "username": "fuxian",
                        "content": "why result of 4 [[2,3],[1,2],[1,3]] is 2 not 1?"
                    },
                    {
                        "username": "jnesom",
                        "content": "[@irfanwustl](/irfanwustl) but that node that\\'s not included has no edges, so although it is a component,  its not connected "
                    },
                    {
                        "username": "irfanwustl",
                        "content": "Cause the edges has node 1,2 and 3. But the total node is 4. So there is a node which is not included in the edge list. "
                    },
                    {
                        "username": "jnesom",
                        "content": "Hey all,  a node all by itself with no edges is still considered a connected component. \\n\\n\\n\\n https://www.baeldung.com/cs/graph-connected-components"
                    },
                    {
                        "username": "MrGonzo",
                        "content": "for input [[2,3],[1,2],[1,3]] expected ans 2. it should be 1 right? bcz its circular connected."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "You forgot about 0 which is a standalone node."
                    },
                    {
                        "username": "newman2",
                        "content": "In the worse case, union-find is O(m log n) and BFS/DFS is O(n + m) right?\\nThen the union-find has strictly worse worst case execution time no?\\nIn practice, where the graph is sparse, the union-find can be much faster, but here I am only talking about big O time.\\nCorrect me if I am wrong."
                    },
                    {
                        "username": "andrewtoth",
                        "content": "The constraints say `0 <= ai <= bi < n`\\nbut test case 27 is `[[1,0],[2,0]]` where both `a1 > b1` and `a2>b2`\\nThis should be changed to 2 different constraints\\n`0 <= ai < n`\\nand \\n`0 <= bi < n`\\nor am I missing something about constraint syntax?"
                    },
                    {
                        "username": "lgibson",
                        "content": "I think this should be corrected in the description which says ai <= bi AND ai != bi.  Both can't be true. It should be edited as andrewtoth describes. "
                    },
                    {
                        "username": "A_Penguin",
                        "content": "This problem should be easy."
                    }
                ]
            },
            {
                "id": 1574090,
                "content": [
                    {
                        "username": "zhugejunwei",
                        "content": "In undirected graph, [2, 3] is equal to [3, 2], right?\\n\\nSo [[2,3],[1,2],[1,3]] is equal to [1,2], [[2,3], [3,1]], right?\\n\\nI don't know how the answer of `[[2,3],[1,2],[1,3]]` is **2**.\\n\\nAny ideas?\\n\\n\\n**Edit:**\\nIs it because the node `0`, which doesn't appear in the test case, but *it is actually there*?"
                    },
                    {
                        "username": "eldarnabiresearch",
                        "content": "[@user3238Gj](/user3238Gj) Good job\\n\\n"
                    },
                    {
                        "username": "worldofvadim",
                        "content": "Thank you, because of your comment understood where is the problem"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "[@user3238Gj](/user3238Gj) see the parameter n in the function, so there might be nodes without edges, so n = 4 means there are nodes: 0, 1, 2 ,3 zo 0 has no edges"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "Every node in there is connected"
                    },
                    {
                        "username": "swjung",
                        "content": "It seems like the constraint `0 <= ai <= bi < n` is not adapted."
                    },
                    {
                        "username": "Seagull360",
                        "content": "[2,3] [1,2] [1,3] are connected. so there is only 1 connected component, but leetcode test case result is 2. \\n\\n1---2---3\\n|\\n|\\n|\\n3\\n"
                    },
                    {
                        "username": "yzyluvcpsc",
                        "content": "[@angeldimitrov](/angeldimitrov) The edges only tells you which is connected to which. But number of nodes are given by n. So here n = 4, edges = [2,3],[1,2],[1,3], where you have 4 nodes (0, 1, 2, 3) and 1,2,3 is a connected cycle and 0 stands alone"
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "[@yzyluvcpsc](/yzyluvcpsc) \\'node index starts from 0\\', what is that supposed to mean? The edge list does not include 0, therefore it is not in the graph. How did you reach this conclusion that 0 is somehow in the graph?"
                    },
                    {
                        "username": "yzyluvcpsc",
                        "content": "The node index starts from 0, this testcase would be a single 0 and the circular graph you mentioned, so result is 2"
                    },
                    {
                        "username": "fuxian",
                        "content": "why result of 4 [[2,3],[1,2],[1,3]] is 2 not 1?"
                    },
                    {
                        "username": "jnesom",
                        "content": "[@irfanwustl](/irfanwustl) but that node that\\'s not included has no edges, so although it is a component,  its not connected "
                    },
                    {
                        "username": "irfanwustl",
                        "content": "Cause the edges has node 1,2 and 3. But the total node is 4. So there is a node which is not included in the edge list. "
                    },
                    {
                        "username": "jnesom",
                        "content": "Hey all,  a node all by itself with no edges is still considered a connected component. \\n\\n\\n\\n https://www.baeldung.com/cs/graph-connected-components"
                    },
                    {
                        "username": "MrGonzo",
                        "content": "for input [[2,3],[1,2],[1,3]] expected ans 2. it should be 1 right? bcz its circular connected."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "You forgot about 0 which is a standalone node."
                    },
                    {
                        "username": "newman2",
                        "content": "In the worse case, union-find is O(m log n) and BFS/DFS is O(n + m) right?\\nThen the union-find has strictly worse worst case execution time no?\\nIn practice, where the graph is sparse, the union-find can be much faster, but here I am only talking about big O time.\\nCorrect me if I am wrong."
                    },
                    {
                        "username": "andrewtoth",
                        "content": "The constraints say `0 <= ai <= bi < n`\\nbut test case 27 is `[[1,0],[2,0]]` where both `a1 > b1` and `a2>b2`\\nThis should be changed to 2 different constraints\\n`0 <= ai < n`\\nand \\n`0 <= bi < n`\\nor am I missing something about constraint syntax?"
                    },
                    {
                        "username": "lgibson",
                        "content": "I think this should be corrected in the description which says ai <= bi AND ai != bi.  Both can't be true. It should be edited as andrewtoth describes. "
                    },
                    {
                        "username": "A_Penguin",
                        "content": "This problem should be easy."
                    }
                ]
            },
            {
                "id": 1568155,
                "content": [
                    {
                        "username": "zhugejunwei",
                        "content": "In undirected graph, [2, 3] is equal to [3, 2], right?\\n\\nSo [[2,3],[1,2],[1,3]] is equal to [1,2], [[2,3], [3,1]], right?\\n\\nI don't know how the answer of `[[2,3],[1,2],[1,3]]` is **2**.\\n\\nAny ideas?\\n\\n\\n**Edit:**\\nIs it because the node `0`, which doesn't appear in the test case, but *it is actually there*?"
                    },
                    {
                        "username": "eldarnabiresearch",
                        "content": "[@user3238Gj](/user3238Gj) Good job\\n\\n"
                    },
                    {
                        "username": "worldofvadim",
                        "content": "Thank you, because of your comment understood where is the problem"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "[@user3238Gj](/user3238Gj) see the parameter n in the function, so there might be nodes without edges, so n = 4 means there are nodes: 0, 1, 2 ,3 zo 0 has no edges"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "Every node in there is connected"
                    },
                    {
                        "username": "swjung",
                        "content": "It seems like the constraint `0 <= ai <= bi < n` is not adapted."
                    },
                    {
                        "username": "Seagull360",
                        "content": "[2,3] [1,2] [1,3] are connected. so there is only 1 connected component, but leetcode test case result is 2. \\n\\n1---2---3\\n|\\n|\\n|\\n3\\n"
                    },
                    {
                        "username": "yzyluvcpsc",
                        "content": "[@angeldimitrov](/angeldimitrov) The edges only tells you which is connected to which. But number of nodes are given by n. So here n = 4, edges = [2,3],[1,2],[1,3], where you have 4 nodes (0, 1, 2, 3) and 1,2,3 is a connected cycle and 0 stands alone"
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "[@yzyluvcpsc](/yzyluvcpsc) \\'node index starts from 0\\', what is that supposed to mean? The edge list does not include 0, therefore it is not in the graph. How did you reach this conclusion that 0 is somehow in the graph?"
                    },
                    {
                        "username": "yzyluvcpsc",
                        "content": "The node index starts from 0, this testcase would be a single 0 and the circular graph you mentioned, so result is 2"
                    },
                    {
                        "username": "fuxian",
                        "content": "why result of 4 [[2,3],[1,2],[1,3]] is 2 not 1?"
                    },
                    {
                        "username": "jnesom",
                        "content": "[@irfanwustl](/irfanwustl) but that node that\\'s not included has no edges, so although it is a component,  its not connected "
                    },
                    {
                        "username": "irfanwustl",
                        "content": "Cause the edges has node 1,2 and 3. But the total node is 4. So there is a node which is not included in the edge list. "
                    },
                    {
                        "username": "jnesom",
                        "content": "Hey all,  a node all by itself with no edges is still considered a connected component. \\n\\n\\n\\n https://www.baeldung.com/cs/graph-connected-components"
                    },
                    {
                        "username": "MrGonzo",
                        "content": "for input [[2,3],[1,2],[1,3]] expected ans 2. it should be 1 right? bcz its circular connected."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "You forgot about 0 which is a standalone node."
                    },
                    {
                        "username": "newman2",
                        "content": "In the worse case, union-find is O(m log n) and BFS/DFS is O(n + m) right?\\nThen the union-find has strictly worse worst case execution time no?\\nIn practice, where the graph is sparse, the union-find can be much faster, but here I am only talking about big O time.\\nCorrect me if I am wrong."
                    },
                    {
                        "username": "andrewtoth",
                        "content": "The constraints say `0 <= ai <= bi < n`\\nbut test case 27 is `[[1,0],[2,0]]` where both `a1 > b1` and `a2>b2`\\nThis should be changed to 2 different constraints\\n`0 <= ai < n`\\nand \\n`0 <= bi < n`\\nor am I missing something about constraint syntax?"
                    },
                    {
                        "username": "lgibson",
                        "content": "I think this should be corrected in the description which says ai <= bi AND ai != bi.  Both can't be true. It should be edited as andrewtoth describes. "
                    },
                    {
                        "username": "A_Penguin",
                        "content": "This problem should be easy."
                    }
                ]
            },
            {
                "id": 1767408,
                "content": [
                    {
                        "username": "zhugejunwei",
                        "content": "In undirected graph, [2, 3] is equal to [3, 2], right?\\n\\nSo [[2,3],[1,2],[1,3]] is equal to [1,2], [[2,3], [3,1]], right?\\n\\nI don't know how the answer of `[[2,3],[1,2],[1,3]]` is **2**.\\n\\nAny ideas?\\n\\n\\n**Edit:**\\nIs it because the node `0`, which doesn't appear in the test case, but *it is actually there*?"
                    },
                    {
                        "username": "eldarnabiresearch",
                        "content": "[@user3238Gj](/user3238Gj) Good job\\n\\n"
                    },
                    {
                        "username": "worldofvadim",
                        "content": "Thank you, because of your comment understood where is the problem"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "[@user3238Gj](/user3238Gj) see the parameter n in the function, so there might be nodes without edges, so n = 4 means there are nodes: 0, 1, 2 ,3 zo 0 has no edges"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "Every node in there is connected"
                    },
                    {
                        "username": "swjung",
                        "content": "It seems like the constraint `0 <= ai <= bi < n` is not adapted."
                    },
                    {
                        "username": "Seagull360",
                        "content": "[2,3] [1,2] [1,3] are connected. so there is only 1 connected component, but leetcode test case result is 2. \\n\\n1---2---3\\n|\\n|\\n|\\n3\\n"
                    },
                    {
                        "username": "yzyluvcpsc",
                        "content": "[@angeldimitrov](/angeldimitrov) The edges only tells you which is connected to which. But number of nodes are given by n. So here n = 4, edges = [2,3],[1,2],[1,3], where you have 4 nodes (0, 1, 2, 3) and 1,2,3 is a connected cycle and 0 stands alone"
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "[@yzyluvcpsc](/yzyluvcpsc) \\'node index starts from 0\\', what is that supposed to mean? The edge list does not include 0, therefore it is not in the graph. How did you reach this conclusion that 0 is somehow in the graph?"
                    },
                    {
                        "username": "yzyluvcpsc",
                        "content": "The node index starts from 0, this testcase would be a single 0 and the circular graph you mentioned, so result is 2"
                    },
                    {
                        "username": "fuxian",
                        "content": "why result of 4 [[2,3],[1,2],[1,3]] is 2 not 1?"
                    },
                    {
                        "username": "jnesom",
                        "content": "[@irfanwustl](/irfanwustl) but that node that\\'s not included has no edges, so although it is a component,  its not connected "
                    },
                    {
                        "username": "irfanwustl",
                        "content": "Cause the edges has node 1,2 and 3. But the total node is 4. So there is a node which is not included in the edge list. "
                    },
                    {
                        "username": "jnesom",
                        "content": "Hey all,  a node all by itself with no edges is still considered a connected component. \\n\\n\\n\\n https://www.baeldung.com/cs/graph-connected-components"
                    },
                    {
                        "username": "MrGonzo",
                        "content": "for input [[2,3],[1,2],[1,3]] expected ans 2. it should be 1 right? bcz its circular connected."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "You forgot about 0 which is a standalone node."
                    },
                    {
                        "username": "newman2",
                        "content": "In the worse case, union-find is O(m log n) and BFS/DFS is O(n + m) right?\\nThen the union-find has strictly worse worst case execution time no?\\nIn practice, where the graph is sparse, the union-find can be much faster, but here I am only talking about big O time.\\nCorrect me if I am wrong."
                    },
                    {
                        "username": "andrewtoth",
                        "content": "The constraints say `0 <= ai <= bi < n`\\nbut test case 27 is `[[1,0],[2,0]]` where both `a1 > b1` and `a2>b2`\\nThis should be changed to 2 different constraints\\n`0 <= ai < n`\\nand \\n`0 <= bi < n`\\nor am I missing something about constraint syntax?"
                    },
                    {
                        "username": "lgibson",
                        "content": "I think this should be corrected in the description which says ai <= bi AND ai != bi.  Both can't be true. It should be edited as andrewtoth describes. "
                    },
                    {
                        "username": "A_Penguin",
                        "content": "This problem should be easy."
                    }
                ]
            },
            {
                "id": 1572407,
                "content": [
                    {
                        "username": "zhugejunwei",
                        "content": "In undirected graph, [2, 3] is equal to [3, 2], right?\\n\\nSo [[2,3],[1,2],[1,3]] is equal to [1,2], [[2,3], [3,1]], right?\\n\\nI don't know how the answer of `[[2,3],[1,2],[1,3]]` is **2**.\\n\\nAny ideas?\\n\\n\\n**Edit:**\\nIs it because the node `0`, which doesn't appear in the test case, but *it is actually there*?"
                    },
                    {
                        "username": "eldarnabiresearch",
                        "content": "[@user3238Gj](/user3238Gj) Good job\\n\\n"
                    },
                    {
                        "username": "worldofvadim",
                        "content": "Thank you, because of your comment understood where is the problem"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "[@user3238Gj](/user3238Gj) see the parameter n in the function, so there might be nodes without edges, so n = 4 means there are nodes: 0, 1, 2 ,3 zo 0 has no edges"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "Every node in there is connected"
                    },
                    {
                        "username": "swjung",
                        "content": "It seems like the constraint `0 <= ai <= bi < n` is not adapted."
                    },
                    {
                        "username": "Seagull360",
                        "content": "[2,3] [1,2] [1,3] are connected. so there is only 1 connected component, but leetcode test case result is 2. \\n\\n1---2---3\\n|\\n|\\n|\\n3\\n"
                    },
                    {
                        "username": "yzyluvcpsc",
                        "content": "[@angeldimitrov](/angeldimitrov) The edges only tells you which is connected to which. But number of nodes are given by n. So here n = 4, edges = [2,3],[1,2],[1,3], where you have 4 nodes (0, 1, 2, 3) and 1,2,3 is a connected cycle and 0 stands alone"
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "[@yzyluvcpsc](/yzyluvcpsc) \\'node index starts from 0\\', what is that supposed to mean? The edge list does not include 0, therefore it is not in the graph. How did you reach this conclusion that 0 is somehow in the graph?"
                    },
                    {
                        "username": "yzyluvcpsc",
                        "content": "The node index starts from 0, this testcase would be a single 0 and the circular graph you mentioned, so result is 2"
                    },
                    {
                        "username": "fuxian",
                        "content": "why result of 4 [[2,3],[1,2],[1,3]] is 2 not 1?"
                    },
                    {
                        "username": "jnesom",
                        "content": "[@irfanwustl](/irfanwustl) but that node that\\'s not included has no edges, so although it is a component,  its not connected "
                    },
                    {
                        "username": "irfanwustl",
                        "content": "Cause the edges has node 1,2 and 3. But the total node is 4. So there is a node which is not included in the edge list. "
                    },
                    {
                        "username": "jnesom",
                        "content": "Hey all,  a node all by itself with no edges is still considered a connected component. \\n\\n\\n\\n https://www.baeldung.com/cs/graph-connected-components"
                    },
                    {
                        "username": "MrGonzo",
                        "content": "for input [[2,3],[1,2],[1,3]] expected ans 2. it should be 1 right? bcz its circular connected."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "You forgot about 0 which is a standalone node."
                    },
                    {
                        "username": "newman2",
                        "content": "In the worse case, union-find is O(m log n) and BFS/DFS is O(n + m) right?\\nThen the union-find has strictly worse worst case execution time no?\\nIn practice, where the graph is sparse, the union-find can be much faster, but here I am only talking about big O time.\\nCorrect me if I am wrong."
                    },
                    {
                        "username": "andrewtoth",
                        "content": "The constraints say `0 <= ai <= bi < n`\\nbut test case 27 is `[[1,0],[2,0]]` where both `a1 > b1` and `a2>b2`\\nThis should be changed to 2 different constraints\\n`0 <= ai < n`\\nand \\n`0 <= bi < n`\\nor am I missing something about constraint syntax?"
                    },
                    {
                        "username": "lgibson",
                        "content": "I think this should be corrected in the description which says ai <= bi AND ai != bi.  Both can't be true. It should be edited as andrewtoth describes. "
                    },
                    {
                        "username": "A_Penguin",
                        "content": "This problem should be easy."
                    }
                ]
            },
            {
                "id": 1569075,
                "content": [
                    {
                        "username": "zhugejunwei",
                        "content": "In undirected graph, [2, 3] is equal to [3, 2], right?\\n\\nSo [[2,3],[1,2],[1,3]] is equal to [1,2], [[2,3], [3,1]], right?\\n\\nI don't know how the answer of `[[2,3],[1,2],[1,3]]` is **2**.\\n\\nAny ideas?\\n\\n\\n**Edit:**\\nIs it because the node `0`, which doesn't appear in the test case, but *it is actually there*?"
                    },
                    {
                        "username": "eldarnabiresearch",
                        "content": "[@user3238Gj](/user3238Gj) Good job\\n\\n"
                    },
                    {
                        "username": "worldofvadim",
                        "content": "Thank you, because of your comment understood where is the problem"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "[@user3238Gj](/user3238Gj) see the parameter n in the function, so there might be nodes without edges, so n = 4 means there are nodes: 0, 1, 2 ,3 zo 0 has no edges"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "Every node in there is connected"
                    },
                    {
                        "username": "swjung",
                        "content": "It seems like the constraint `0 <= ai <= bi < n` is not adapted."
                    },
                    {
                        "username": "Seagull360",
                        "content": "[2,3] [1,2] [1,3] are connected. so there is only 1 connected component, but leetcode test case result is 2. \\n\\n1---2---3\\n|\\n|\\n|\\n3\\n"
                    },
                    {
                        "username": "yzyluvcpsc",
                        "content": "[@angeldimitrov](/angeldimitrov) The edges only tells you which is connected to which. But number of nodes are given by n. So here n = 4, edges = [2,3],[1,2],[1,3], where you have 4 nodes (0, 1, 2, 3) and 1,2,3 is a connected cycle and 0 stands alone"
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "[@yzyluvcpsc](/yzyluvcpsc) \\'node index starts from 0\\', what is that supposed to mean? The edge list does not include 0, therefore it is not in the graph. How did you reach this conclusion that 0 is somehow in the graph?"
                    },
                    {
                        "username": "yzyluvcpsc",
                        "content": "The node index starts from 0, this testcase would be a single 0 and the circular graph you mentioned, so result is 2"
                    },
                    {
                        "username": "fuxian",
                        "content": "why result of 4 [[2,3],[1,2],[1,3]] is 2 not 1?"
                    },
                    {
                        "username": "jnesom",
                        "content": "[@irfanwustl](/irfanwustl) but that node that\\'s not included has no edges, so although it is a component,  its not connected "
                    },
                    {
                        "username": "irfanwustl",
                        "content": "Cause the edges has node 1,2 and 3. But the total node is 4. So there is a node which is not included in the edge list. "
                    },
                    {
                        "username": "jnesom",
                        "content": "Hey all,  a node all by itself with no edges is still considered a connected component. \\n\\n\\n\\n https://www.baeldung.com/cs/graph-connected-components"
                    },
                    {
                        "username": "MrGonzo",
                        "content": "for input [[2,3],[1,2],[1,3]] expected ans 2. it should be 1 right? bcz its circular connected."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "You forgot about 0 which is a standalone node."
                    },
                    {
                        "username": "newman2",
                        "content": "In the worse case, union-find is O(m log n) and BFS/DFS is O(n + m) right?\\nThen the union-find has strictly worse worst case execution time no?\\nIn practice, where the graph is sparse, the union-find can be much faster, but here I am only talking about big O time.\\nCorrect me if I am wrong."
                    },
                    {
                        "username": "andrewtoth",
                        "content": "The constraints say `0 <= ai <= bi < n`\\nbut test case 27 is `[[1,0],[2,0]]` where both `a1 > b1` and `a2>b2`\\nThis should be changed to 2 different constraints\\n`0 <= ai < n`\\nand \\n`0 <= bi < n`\\nor am I missing something about constraint syntax?"
                    },
                    {
                        "username": "lgibson",
                        "content": "I think this should be corrected in the description which says ai <= bi AND ai != bi.  Both can't be true. It should be edited as andrewtoth describes. "
                    },
                    {
                        "username": "A_Penguin",
                        "content": "This problem should be easy."
                    }
                ]
            },
            {
                "id": 1785035,
                "content": [
                    {
                        "username": "zhugejunwei",
                        "content": "In undirected graph, [2, 3] is equal to [3, 2], right?\\n\\nSo [[2,3],[1,2],[1,3]] is equal to [1,2], [[2,3], [3,1]], right?\\n\\nI don't know how the answer of `[[2,3],[1,2],[1,3]]` is **2**.\\n\\nAny ideas?\\n\\n\\n**Edit:**\\nIs it because the node `0`, which doesn't appear in the test case, but *it is actually there*?"
                    },
                    {
                        "username": "eldarnabiresearch",
                        "content": "[@user3238Gj](/user3238Gj) Good job\\n\\n"
                    },
                    {
                        "username": "worldofvadim",
                        "content": "Thank you, because of your comment understood where is the problem"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "[@user3238Gj](/user3238Gj) see the parameter n in the function, so there might be nodes without edges, so n = 4 means there are nodes: 0, 1, 2 ,3 zo 0 has no edges"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "Every node in there is connected"
                    },
                    {
                        "username": "swjung",
                        "content": "It seems like the constraint `0 <= ai <= bi < n` is not adapted."
                    },
                    {
                        "username": "Seagull360",
                        "content": "[2,3] [1,2] [1,3] are connected. so there is only 1 connected component, but leetcode test case result is 2. \\n\\n1---2---3\\n|\\n|\\n|\\n3\\n"
                    },
                    {
                        "username": "yzyluvcpsc",
                        "content": "[@angeldimitrov](/angeldimitrov) The edges only tells you which is connected to which. But number of nodes are given by n. So here n = 4, edges = [2,3],[1,2],[1,3], where you have 4 nodes (0, 1, 2, 3) and 1,2,3 is a connected cycle and 0 stands alone"
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "[@yzyluvcpsc](/yzyluvcpsc) \\'node index starts from 0\\', what is that supposed to mean? The edge list does not include 0, therefore it is not in the graph. How did you reach this conclusion that 0 is somehow in the graph?"
                    },
                    {
                        "username": "yzyluvcpsc",
                        "content": "The node index starts from 0, this testcase would be a single 0 and the circular graph you mentioned, so result is 2"
                    },
                    {
                        "username": "fuxian",
                        "content": "why result of 4 [[2,3],[1,2],[1,3]] is 2 not 1?"
                    },
                    {
                        "username": "jnesom",
                        "content": "[@irfanwustl](/irfanwustl) but that node that\\'s not included has no edges, so although it is a component,  its not connected "
                    },
                    {
                        "username": "irfanwustl",
                        "content": "Cause the edges has node 1,2 and 3. But the total node is 4. So there is a node which is not included in the edge list. "
                    },
                    {
                        "username": "jnesom",
                        "content": "Hey all,  a node all by itself with no edges is still considered a connected component. \\n\\n\\n\\n https://www.baeldung.com/cs/graph-connected-components"
                    },
                    {
                        "username": "MrGonzo",
                        "content": "for input [[2,3],[1,2],[1,3]] expected ans 2. it should be 1 right? bcz its circular connected."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "You forgot about 0 which is a standalone node."
                    },
                    {
                        "username": "newman2",
                        "content": "In the worse case, union-find is O(m log n) and BFS/DFS is O(n + m) right?\\nThen the union-find has strictly worse worst case execution time no?\\nIn practice, where the graph is sparse, the union-find can be much faster, but here I am only talking about big O time.\\nCorrect me if I am wrong."
                    },
                    {
                        "username": "andrewtoth",
                        "content": "The constraints say `0 <= ai <= bi < n`\\nbut test case 27 is `[[1,0],[2,0]]` where both `a1 > b1` and `a2>b2`\\nThis should be changed to 2 different constraints\\n`0 <= ai < n`\\nand \\n`0 <= bi < n`\\nor am I missing something about constraint syntax?"
                    },
                    {
                        "username": "lgibson",
                        "content": "I think this should be corrected in the description which says ai <= bi AND ai != bi.  Both can't be true. It should be edited as andrewtoth describes. "
                    },
                    {
                        "username": "A_Penguin",
                        "content": "This problem should be easy."
                    }
                ]
            },
            {
                "id": 2075371,
                "content": [
                    {
                        "username": "zhugejunwei",
                        "content": "In undirected graph, [2, 3] is equal to [3, 2], right?\\n\\nSo [[2,3],[1,2],[1,3]] is equal to [1,2], [[2,3], [3,1]], right?\\n\\nI don't know how the answer of `[[2,3],[1,2],[1,3]]` is **2**.\\n\\nAny ideas?\\n\\n\\n**Edit:**\\nIs it because the node `0`, which doesn't appear in the test case, but *it is actually there*?"
                    },
                    {
                        "username": "eldarnabiresearch",
                        "content": "[@user3238Gj](/user3238Gj) Good job\\n\\n"
                    },
                    {
                        "username": "worldofvadim",
                        "content": "Thank you, because of your comment understood where is the problem"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "[@user3238Gj](/user3238Gj) see the parameter n in the function, so there might be nodes without edges, so n = 4 means there are nodes: 0, 1, 2 ,3 zo 0 has no edges"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "Every node in there is connected"
                    },
                    {
                        "username": "swjung",
                        "content": "It seems like the constraint `0 <= ai <= bi < n` is not adapted."
                    },
                    {
                        "username": "Seagull360",
                        "content": "[2,3] [1,2] [1,3] are connected. so there is only 1 connected component, but leetcode test case result is 2. \\n\\n1---2---3\\n|\\n|\\n|\\n3\\n"
                    },
                    {
                        "username": "yzyluvcpsc",
                        "content": "[@angeldimitrov](/angeldimitrov) The edges only tells you which is connected to which. But number of nodes are given by n. So here n = 4, edges = [2,3],[1,2],[1,3], where you have 4 nodes (0, 1, 2, 3) and 1,2,3 is a connected cycle and 0 stands alone"
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "[@yzyluvcpsc](/yzyluvcpsc) \\'node index starts from 0\\', what is that supposed to mean? The edge list does not include 0, therefore it is not in the graph. How did you reach this conclusion that 0 is somehow in the graph?"
                    },
                    {
                        "username": "yzyluvcpsc",
                        "content": "The node index starts from 0, this testcase would be a single 0 and the circular graph you mentioned, so result is 2"
                    },
                    {
                        "username": "fuxian",
                        "content": "why result of 4 [[2,3],[1,2],[1,3]] is 2 not 1?"
                    },
                    {
                        "username": "jnesom",
                        "content": "[@irfanwustl](/irfanwustl) but that node that\\'s not included has no edges, so although it is a component,  its not connected "
                    },
                    {
                        "username": "irfanwustl",
                        "content": "Cause the edges has node 1,2 and 3. But the total node is 4. So there is a node which is not included in the edge list. "
                    },
                    {
                        "username": "jnesom",
                        "content": "Hey all,  a node all by itself with no edges is still considered a connected component. \\n\\n\\n\\n https://www.baeldung.com/cs/graph-connected-components"
                    },
                    {
                        "username": "MrGonzo",
                        "content": "for input [[2,3],[1,2],[1,3]] expected ans 2. it should be 1 right? bcz its circular connected."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "You forgot about 0 which is a standalone node."
                    },
                    {
                        "username": "newman2",
                        "content": "In the worse case, union-find is O(m log n) and BFS/DFS is O(n + m) right?\\nThen the union-find has strictly worse worst case execution time no?\\nIn practice, where the graph is sparse, the union-find can be much faster, but here I am only talking about big O time.\\nCorrect me if I am wrong."
                    },
                    {
                        "username": "andrewtoth",
                        "content": "The constraints say `0 <= ai <= bi < n`\\nbut test case 27 is `[[1,0],[2,0]]` where both `a1 > b1` and `a2>b2`\\nThis should be changed to 2 different constraints\\n`0 <= ai < n`\\nand \\n`0 <= bi < n`\\nor am I missing something about constraint syntax?"
                    },
                    {
                        "username": "lgibson",
                        "content": "I think this should be corrected in the description which says ai <= bi AND ai != bi.  Both can't be true. It should be edited as andrewtoth describes. "
                    },
                    {
                        "username": "A_Penguin",
                        "content": "This problem should be easy."
                    }
                ]
            },
            {
                "id": 1565040,
                "content": [
                    {
                        "username": "zhugejunwei",
                        "content": "In undirected graph, [2, 3] is equal to [3, 2], right?\\n\\nSo [[2,3],[1,2],[1,3]] is equal to [1,2], [[2,3], [3,1]], right?\\n\\nI don't know how the answer of `[[2,3],[1,2],[1,3]]` is **2**.\\n\\nAny ideas?\\n\\n\\n**Edit:**\\nIs it because the node `0`, which doesn't appear in the test case, but *it is actually there*?"
                    },
                    {
                        "username": "eldarnabiresearch",
                        "content": "[@user3238Gj](/user3238Gj) Good job\\n\\n"
                    },
                    {
                        "username": "worldofvadim",
                        "content": "Thank you, because of your comment understood where is the problem"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "[@user3238Gj](/user3238Gj) see the parameter n in the function, so there might be nodes without edges, so n = 4 means there are nodes: 0, 1, 2 ,3 zo 0 has no edges"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "Every node in there is connected"
                    },
                    {
                        "username": "swjung",
                        "content": "It seems like the constraint `0 <= ai <= bi < n` is not adapted."
                    },
                    {
                        "username": "Seagull360",
                        "content": "[2,3] [1,2] [1,3] are connected. so there is only 1 connected component, but leetcode test case result is 2. \\n\\n1---2---3\\n|\\n|\\n|\\n3\\n"
                    },
                    {
                        "username": "yzyluvcpsc",
                        "content": "[@angeldimitrov](/angeldimitrov) The edges only tells you which is connected to which. But number of nodes are given by n. So here n = 4, edges = [2,3],[1,2],[1,3], where you have 4 nodes (0, 1, 2, 3) and 1,2,3 is a connected cycle and 0 stands alone"
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "[@yzyluvcpsc](/yzyluvcpsc) \\'node index starts from 0\\', what is that supposed to mean? The edge list does not include 0, therefore it is not in the graph. How did you reach this conclusion that 0 is somehow in the graph?"
                    },
                    {
                        "username": "yzyluvcpsc",
                        "content": "The node index starts from 0, this testcase would be a single 0 and the circular graph you mentioned, so result is 2"
                    },
                    {
                        "username": "fuxian",
                        "content": "why result of 4 [[2,3],[1,2],[1,3]] is 2 not 1?"
                    },
                    {
                        "username": "jnesom",
                        "content": "[@irfanwustl](/irfanwustl) but that node that\\'s not included has no edges, so although it is a component,  its not connected "
                    },
                    {
                        "username": "irfanwustl",
                        "content": "Cause the edges has node 1,2 and 3. But the total node is 4. So there is a node which is not included in the edge list. "
                    },
                    {
                        "username": "jnesom",
                        "content": "Hey all,  a node all by itself with no edges is still considered a connected component. \\n\\n\\n\\n https://www.baeldung.com/cs/graph-connected-components"
                    },
                    {
                        "username": "MrGonzo",
                        "content": "for input [[2,3],[1,2],[1,3]] expected ans 2. it should be 1 right? bcz its circular connected."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "You forgot about 0 which is a standalone node."
                    },
                    {
                        "username": "newman2",
                        "content": "In the worse case, union-find is O(m log n) and BFS/DFS is O(n + m) right?\\nThen the union-find has strictly worse worst case execution time no?\\nIn practice, where the graph is sparse, the union-find can be much faster, but here I am only talking about big O time.\\nCorrect me if I am wrong."
                    },
                    {
                        "username": "andrewtoth",
                        "content": "The constraints say `0 <= ai <= bi < n`\\nbut test case 27 is `[[1,0],[2,0]]` where both `a1 > b1` and `a2>b2`\\nThis should be changed to 2 different constraints\\n`0 <= ai < n`\\nand \\n`0 <= bi < n`\\nor am I missing something about constraint syntax?"
                    },
                    {
                        "username": "lgibson",
                        "content": "I think this should be corrected in the description which says ai <= bi AND ai != bi.  Both can't be true. It should be edited as andrewtoth describes. "
                    },
                    {
                        "username": "A_Penguin",
                        "content": "This problem should be easy."
                    }
                ]
            },
            {
                "id": 1565763,
                "content": [
                    {
                        "username": "zhugejunwei",
                        "content": "In undirected graph, [2, 3] is equal to [3, 2], right?\\n\\nSo [[2,3],[1,2],[1,3]] is equal to [1,2], [[2,3], [3,1]], right?\\n\\nI don't know how the answer of `[[2,3],[1,2],[1,3]]` is **2**.\\n\\nAny ideas?\\n\\n\\n**Edit:**\\nIs it because the node `0`, which doesn't appear in the test case, but *it is actually there*?"
                    },
                    {
                        "username": "eldarnabiresearch",
                        "content": "[@user3238Gj](/user3238Gj) Good job\\n\\n"
                    },
                    {
                        "username": "worldofvadim",
                        "content": "Thank you, because of your comment understood where is the problem"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "[@user3238Gj](/user3238Gj) see the parameter n in the function, so there might be nodes without edges, so n = 4 means there are nodes: 0, 1, 2 ,3 zo 0 has no edges"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "Every node in there is connected"
                    },
                    {
                        "username": "swjung",
                        "content": "It seems like the constraint `0 <= ai <= bi < n` is not adapted."
                    },
                    {
                        "username": "Seagull360",
                        "content": "[2,3] [1,2] [1,3] are connected. so there is only 1 connected component, but leetcode test case result is 2. \\n\\n1---2---3\\n|\\n|\\n|\\n3\\n"
                    },
                    {
                        "username": "yzyluvcpsc",
                        "content": "[@angeldimitrov](/angeldimitrov) The edges only tells you which is connected to which. But number of nodes are given by n. So here n = 4, edges = [2,3],[1,2],[1,3], where you have 4 nodes (0, 1, 2, 3) and 1,2,3 is a connected cycle and 0 stands alone"
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "[@yzyluvcpsc](/yzyluvcpsc) \\'node index starts from 0\\', what is that supposed to mean? The edge list does not include 0, therefore it is not in the graph. How did you reach this conclusion that 0 is somehow in the graph?"
                    },
                    {
                        "username": "yzyluvcpsc",
                        "content": "The node index starts from 0, this testcase would be a single 0 and the circular graph you mentioned, so result is 2"
                    },
                    {
                        "username": "fuxian",
                        "content": "why result of 4 [[2,3],[1,2],[1,3]] is 2 not 1?"
                    },
                    {
                        "username": "jnesom",
                        "content": "[@irfanwustl](/irfanwustl) but that node that\\'s not included has no edges, so although it is a component,  its not connected "
                    },
                    {
                        "username": "irfanwustl",
                        "content": "Cause the edges has node 1,2 and 3. But the total node is 4. So there is a node which is not included in the edge list. "
                    },
                    {
                        "username": "jnesom",
                        "content": "Hey all,  a node all by itself with no edges is still considered a connected component. \\n\\n\\n\\n https://www.baeldung.com/cs/graph-connected-components"
                    },
                    {
                        "username": "MrGonzo",
                        "content": "for input [[2,3],[1,2],[1,3]] expected ans 2. it should be 1 right? bcz its circular connected."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "You forgot about 0 which is a standalone node."
                    },
                    {
                        "username": "newman2",
                        "content": "In the worse case, union-find is O(m log n) and BFS/DFS is O(n + m) right?\\nThen the union-find has strictly worse worst case execution time no?\\nIn practice, where the graph is sparse, the union-find can be much faster, but here I am only talking about big O time.\\nCorrect me if I am wrong."
                    },
                    {
                        "username": "andrewtoth",
                        "content": "The constraints say `0 <= ai <= bi < n`\\nbut test case 27 is `[[1,0],[2,0]]` where both `a1 > b1` and `a2>b2`\\nThis should be changed to 2 different constraints\\n`0 <= ai < n`\\nand \\n`0 <= bi < n`\\nor am I missing something about constraint syntax?"
                    },
                    {
                        "username": "lgibson",
                        "content": "I think this should be corrected in the description which says ai <= bi AND ai != bi.  Both can't be true. It should be edited as andrewtoth describes. "
                    },
                    {
                        "username": "A_Penguin",
                        "content": "This problem should be easy."
                    }
                ]
            },
            {
                "id": 1776556,
                "content": [
                    {
                        "username": "zhugejunwei",
                        "content": "In undirected graph, [2, 3] is equal to [3, 2], right?\\n\\nSo [[2,3],[1,2],[1,3]] is equal to [1,2], [[2,3], [3,1]], right?\\n\\nI don't know how the answer of `[[2,3],[1,2],[1,3]]` is **2**.\\n\\nAny ideas?\\n\\n\\n**Edit:**\\nIs it because the node `0`, which doesn't appear in the test case, but *it is actually there*?"
                    },
                    {
                        "username": "eldarnabiresearch",
                        "content": "[@user3238Gj](/user3238Gj) Good job\\n\\n"
                    },
                    {
                        "username": "worldofvadim",
                        "content": "Thank you, because of your comment understood where is the problem"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "[@user3238Gj](/user3238Gj) see the parameter n in the function, so there might be nodes without edges, so n = 4 means there are nodes: 0, 1, 2 ,3 zo 0 has no edges"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "Every node in there is connected"
                    },
                    {
                        "username": "swjung",
                        "content": "It seems like the constraint `0 <= ai <= bi < n` is not adapted."
                    },
                    {
                        "username": "Seagull360",
                        "content": "[2,3] [1,2] [1,3] are connected. so there is only 1 connected component, but leetcode test case result is 2. \\n\\n1---2---3\\n|\\n|\\n|\\n3\\n"
                    },
                    {
                        "username": "yzyluvcpsc",
                        "content": "[@angeldimitrov](/angeldimitrov) The edges only tells you which is connected to which. But number of nodes are given by n. So here n = 4, edges = [2,3],[1,2],[1,3], where you have 4 nodes (0, 1, 2, 3) and 1,2,3 is a connected cycle and 0 stands alone"
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "[@yzyluvcpsc](/yzyluvcpsc) \\'node index starts from 0\\', what is that supposed to mean? The edge list does not include 0, therefore it is not in the graph. How did you reach this conclusion that 0 is somehow in the graph?"
                    },
                    {
                        "username": "yzyluvcpsc",
                        "content": "The node index starts from 0, this testcase would be a single 0 and the circular graph you mentioned, so result is 2"
                    },
                    {
                        "username": "fuxian",
                        "content": "why result of 4 [[2,3],[1,2],[1,3]] is 2 not 1?"
                    },
                    {
                        "username": "jnesom",
                        "content": "[@irfanwustl](/irfanwustl) but that node that\\'s not included has no edges, so although it is a component,  its not connected "
                    },
                    {
                        "username": "irfanwustl",
                        "content": "Cause the edges has node 1,2 and 3. But the total node is 4. So there is a node which is not included in the edge list. "
                    },
                    {
                        "username": "jnesom",
                        "content": "Hey all,  a node all by itself with no edges is still considered a connected component. \\n\\n\\n\\n https://www.baeldung.com/cs/graph-connected-components"
                    },
                    {
                        "username": "MrGonzo",
                        "content": "for input [[2,3],[1,2],[1,3]] expected ans 2. it should be 1 right? bcz its circular connected."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "You forgot about 0 which is a standalone node."
                    },
                    {
                        "username": "newman2",
                        "content": "In the worse case, union-find is O(m log n) and BFS/DFS is O(n + m) right?\\nThen the union-find has strictly worse worst case execution time no?\\nIn practice, where the graph is sparse, the union-find can be much faster, but here I am only talking about big O time.\\nCorrect me if I am wrong."
                    },
                    {
                        "username": "andrewtoth",
                        "content": "The constraints say `0 <= ai <= bi < n`\\nbut test case 27 is `[[1,0],[2,0]]` where both `a1 > b1` and `a2>b2`\\nThis should be changed to 2 different constraints\\n`0 <= ai < n`\\nand \\n`0 <= bi < n`\\nor am I missing something about constraint syntax?"
                    },
                    {
                        "username": "lgibson",
                        "content": "I think this should be corrected in the description which says ai <= bi AND ai != bi.  Both can't be true. It should be edited as andrewtoth describes. "
                    },
                    {
                        "username": "A_Penguin",
                        "content": "This problem should be easy."
                    }
                ]
            },
            {
                "id": 1574090,
                "content": [
                    {
                        "username": "zhugejunwei",
                        "content": "In undirected graph, [2, 3] is equal to [3, 2], right?\\n\\nSo [[2,3],[1,2],[1,3]] is equal to [1,2], [[2,3], [3,1]], right?\\n\\nI don't know how the answer of `[[2,3],[1,2],[1,3]]` is **2**.\\n\\nAny ideas?\\n\\n\\n**Edit:**\\nIs it because the node `0`, which doesn't appear in the test case, but *it is actually there*?"
                    },
                    {
                        "username": "eldarnabiresearch",
                        "content": "[@user3238Gj](/user3238Gj) Good job\\n\\n"
                    },
                    {
                        "username": "worldofvadim",
                        "content": "Thank you, because of your comment understood where is the problem"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "[@user3238Gj](/user3238Gj) see the parameter n in the function, so there might be nodes without edges, so n = 4 means there are nodes: 0, 1, 2 ,3 zo 0 has no edges"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "Every node in there is connected"
                    },
                    {
                        "username": "swjung",
                        "content": "It seems like the constraint `0 <= ai <= bi < n` is not adapted."
                    },
                    {
                        "username": "Seagull360",
                        "content": "[2,3] [1,2] [1,3] are connected. so there is only 1 connected component, but leetcode test case result is 2. \\n\\n1---2---3\\n|\\n|\\n|\\n3\\n"
                    },
                    {
                        "username": "yzyluvcpsc",
                        "content": "[@angeldimitrov](/angeldimitrov) The edges only tells you which is connected to which. But number of nodes are given by n. So here n = 4, edges = [2,3],[1,2],[1,3], where you have 4 nodes (0, 1, 2, 3) and 1,2,3 is a connected cycle and 0 stands alone"
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "[@yzyluvcpsc](/yzyluvcpsc) \\'node index starts from 0\\', what is that supposed to mean? The edge list does not include 0, therefore it is not in the graph. How did you reach this conclusion that 0 is somehow in the graph?"
                    },
                    {
                        "username": "yzyluvcpsc",
                        "content": "The node index starts from 0, this testcase would be a single 0 and the circular graph you mentioned, so result is 2"
                    },
                    {
                        "username": "fuxian",
                        "content": "why result of 4 [[2,3],[1,2],[1,3]] is 2 not 1?"
                    },
                    {
                        "username": "jnesom",
                        "content": "[@irfanwustl](/irfanwustl) but that node that\\'s not included has no edges, so although it is a component,  its not connected "
                    },
                    {
                        "username": "irfanwustl",
                        "content": "Cause the edges has node 1,2 and 3. But the total node is 4. So there is a node which is not included in the edge list. "
                    },
                    {
                        "username": "jnesom",
                        "content": "Hey all,  a node all by itself with no edges is still considered a connected component. \\n\\n\\n\\n https://www.baeldung.com/cs/graph-connected-components"
                    },
                    {
                        "username": "MrGonzo",
                        "content": "for input [[2,3],[1,2],[1,3]] expected ans 2. it should be 1 right? bcz its circular connected."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "You forgot about 0 which is a standalone node."
                    },
                    {
                        "username": "newman2",
                        "content": "In the worse case, union-find is O(m log n) and BFS/DFS is O(n + m) right?\\nThen the union-find has strictly worse worst case execution time no?\\nIn practice, where the graph is sparse, the union-find can be much faster, but here I am only talking about big O time.\\nCorrect me if I am wrong."
                    },
                    {
                        "username": "andrewtoth",
                        "content": "The constraints say `0 <= ai <= bi < n`\\nbut test case 27 is `[[1,0],[2,0]]` where both `a1 > b1` and `a2>b2`\\nThis should be changed to 2 different constraints\\n`0 <= ai < n`\\nand \\n`0 <= bi < n`\\nor am I missing something about constraint syntax?"
                    },
                    {
                        "username": "lgibson",
                        "content": "I think this should be corrected in the description which says ai <= bi AND ai != bi.  Both can't be true. It should be edited as andrewtoth describes. "
                    },
                    {
                        "username": "A_Penguin",
                        "content": "This problem should be easy."
                    }
                ]
            },
            {
                "id": 1568155,
                "content": [
                    {
                        "username": "zhugejunwei",
                        "content": "In undirected graph, [2, 3] is equal to [3, 2], right?\\n\\nSo [[2,3],[1,2],[1,3]] is equal to [1,2], [[2,3], [3,1]], right?\\n\\nI don't know how the answer of `[[2,3],[1,2],[1,3]]` is **2**.\\n\\nAny ideas?\\n\\n\\n**Edit:**\\nIs it because the node `0`, which doesn't appear in the test case, but *it is actually there*?"
                    },
                    {
                        "username": "eldarnabiresearch",
                        "content": "[@user3238Gj](/user3238Gj) Good job\\n\\n"
                    },
                    {
                        "username": "worldofvadim",
                        "content": "Thank you, because of your comment understood where is the problem"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "[@user3238Gj](/user3238Gj) see the parameter n in the function, so there might be nodes without edges, so n = 4 means there are nodes: 0, 1, 2 ,3 zo 0 has no edges"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "Every node in there is connected"
                    },
                    {
                        "username": "swjung",
                        "content": "It seems like the constraint `0 <= ai <= bi < n` is not adapted."
                    },
                    {
                        "username": "Seagull360",
                        "content": "[2,3] [1,2] [1,3] are connected. so there is only 1 connected component, but leetcode test case result is 2. \\n\\n1---2---3\\n|\\n|\\n|\\n3\\n"
                    },
                    {
                        "username": "yzyluvcpsc",
                        "content": "[@angeldimitrov](/angeldimitrov) The edges only tells you which is connected to which. But number of nodes are given by n. So here n = 4, edges = [2,3],[1,2],[1,3], where you have 4 nodes (0, 1, 2, 3) and 1,2,3 is a connected cycle and 0 stands alone"
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "[@yzyluvcpsc](/yzyluvcpsc) \\'node index starts from 0\\', what is that supposed to mean? The edge list does not include 0, therefore it is not in the graph. How did you reach this conclusion that 0 is somehow in the graph?"
                    },
                    {
                        "username": "yzyluvcpsc",
                        "content": "The node index starts from 0, this testcase would be a single 0 and the circular graph you mentioned, so result is 2"
                    },
                    {
                        "username": "fuxian",
                        "content": "why result of 4 [[2,3],[1,2],[1,3]] is 2 not 1?"
                    },
                    {
                        "username": "jnesom",
                        "content": "[@irfanwustl](/irfanwustl) but that node that\\'s not included has no edges, so although it is a component,  its not connected "
                    },
                    {
                        "username": "irfanwustl",
                        "content": "Cause the edges has node 1,2 and 3. But the total node is 4. So there is a node which is not included in the edge list. "
                    },
                    {
                        "username": "jnesom",
                        "content": "Hey all,  a node all by itself with no edges is still considered a connected component. \\n\\n\\n\\n https://www.baeldung.com/cs/graph-connected-components"
                    },
                    {
                        "username": "MrGonzo",
                        "content": "for input [[2,3],[1,2],[1,3]] expected ans 2. it should be 1 right? bcz its circular connected."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "You forgot about 0 which is a standalone node."
                    },
                    {
                        "username": "newman2",
                        "content": "In the worse case, union-find is O(m log n) and BFS/DFS is O(n + m) right?\\nThen the union-find has strictly worse worst case execution time no?\\nIn practice, where the graph is sparse, the union-find can be much faster, but here I am only talking about big O time.\\nCorrect me if I am wrong."
                    },
                    {
                        "username": "andrewtoth",
                        "content": "The constraints say `0 <= ai <= bi < n`\\nbut test case 27 is `[[1,0],[2,0]]` where both `a1 > b1` and `a2>b2`\\nThis should be changed to 2 different constraints\\n`0 <= ai < n`\\nand \\n`0 <= bi < n`\\nor am I missing something about constraint syntax?"
                    },
                    {
                        "username": "lgibson",
                        "content": "I think this should be corrected in the description which says ai <= bi AND ai != bi.  Both can't be true. It should be edited as andrewtoth describes. "
                    },
                    {
                        "username": "A_Penguin",
                        "content": "This problem should be easy."
                    }
                ]
            },
            {
                "id": 1767408,
                "content": [
                    {
                        "username": "zhugejunwei",
                        "content": "In undirected graph, [2, 3] is equal to [3, 2], right?\\n\\nSo [[2,3],[1,2],[1,3]] is equal to [1,2], [[2,3], [3,1]], right?\\n\\nI don't know how the answer of `[[2,3],[1,2],[1,3]]` is **2**.\\n\\nAny ideas?\\n\\n\\n**Edit:**\\nIs it because the node `0`, which doesn't appear in the test case, but *it is actually there*?"
                    },
                    {
                        "username": "eldarnabiresearch",
                        "content": "[@user3238Gj](/user3238Gj) Good job\\n\\n"
                    },
                    {
                        "username": "worldofvadim",
                        "content": "Thank you, because of your comment understood where is the problem"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "[@user3238Gj](/user3238Gj) see the parameter n in the function, so there might be nodes without edges, so n = 4 means there are nodes: 0, 1, 2 ,3 zo 0 has no edges"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "Every node in there is connected"
                    },
                    {
                        "username": "swjung",
                        "content": "It seems like the constraint `0 <= ai <= bi < n` is not adapted."
                    },
                    {
                        "username": "Seagull360",
                        "content": "[2,3] [1,2] [1,3] are connected. so there is only 1 connected component, but leetcode test case result is 2. \\n\\n1---2---3\\n|\\n|\\n|\\n3\\n"
                    },
                    {
                        "username": "yzyluvcpsc",
                        "content": "[@angeldimitrov](/angeldimitrov) The edges only tells you which is connected to which. But number of nodes are given by n. So here n = 4, edges = [2,3],[1,2],[1,3], where you have 4 nodes (0, 1, 2, 3) and 1,2,3 is a connected cycle and 0 stands alone"
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "[@yzyluvcpsc](/yzyluvcpsc) \\'node index starts from 0\\', what is that supposed to mean? The edge list does not include 0, therefore it is not in the graph. How did you reach this conclusion that 0 is somehow in the graph?"
                    },
                    {
                        "username": "yzyluvcpsc",
                        "content": "The node index starts from 0, this testcase would be a single 0 and the circular graph you mentioned, so result is 2"
                    },
                    {
                        "username": "fuxian",
                        "content": "why result of 4 [[2,3],[1,2],[1,3]] is 2 not 1?"
                    },
                    {
                        "username": "jnesom",
                        "content": "[@irfanwustl](/irfanwustl) but that node that\\'s not included has no edges, so although it is a component,  its not connected "
                    },
                    {
                        "username": "irfanwustl",
                        "content": "Cause the edges has node 1,2 and 3. But the total node is 4. So there is a node which is not included in the edge list. "
                    },
                    {
                        "username": "jnesom",
                        "content": "Hey all,  a node all by itself with no edges is still considered a connected component. \\n\\n\\n\\n https://www.baeldung.com/cs/graph-connected-components"
                    },
                    {
                        "username": "MrGonzo",
                        "content": "for input [[2,3],[1,2],[1,3]] expected ans 2. it should be 1 right? bcz its circular connected."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "You forgot about 0 which is a standalone node."
                    },
                    {
                        "username": "newman2",
                        "content": "In the worse case, union-find is O(m log n) and BFS/DFS is O(n + m) right?\\nThen the union-find has strictly worse worst case execution time no?\\nIn practice, where the graph is sparse, the union-find can be much faster, but here I am only talking about big O time.\\nCorrect me if I am wrong."
                    },
                    {
                        "username": "andrewtoth",
                        "content": "The constraints say `0 <= ai <= bi < n`\\nbut test case 27 is `[[1,0],[2,0]]` where both `a1 > b1` and `a2>b2`\\nThis should be changed to 2 different constraints\\n`0 <= ai < n`\\nand \\n`0 <= bi < n`\\nor am I missing something about constraint syntax?"
                    },
                    {
                        "username": "lgibson",
                        "content": "I think this should be corrected in the description which says ai <= bi AND ai != bi.  Both can't be true. It should be edited as andrewtoth describes. "
                    },
                    {
                        "username": "A_Penguin",
                        "content": "This problem should be easy."
                    }
                ]
            },
            {
                "id": 1572407,
                "content": [
                    {
                        "username": "zhugejunwei",
                        "content": "In undirected graph, [2, 3] is equal to [3, 2], right?\\n\\nSo [[2,3],[1,2],[1,3]] is equal to [1,2], [[2,3], [3,1]], right?\\n\\nI don't know how the answer of `[[2,3],[1,2],[1,3]]` is **2**.\\n\\nAny ideas?\\n\\n\\n**Edit:**\\nIs it because the node `0`, which doesn't appear in the test case, but *it is actually there*?"
                    },
                    {
                        "username": "eldarnabiresearch",
                        "content": "[@user3238Gj](/user3238Gj) Good job\\n\\n"
                    },
                    {
                        "username": "worldofvadim",
                        "content": "Thank you, because of your comment understood where is the problem"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "[@user3238Gj](/user3238Gj) see the parameter n in the function, so there might be nodes without edges, so n = 4 means there are nodes: 0, 1, 2 ,3 zo 0 has no edges"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "Every node in there is connected"
                    },
                    {
                        "username": "swjung",
                        "content": "It seems like the constraint `0 <= ai <= bi < n` is not adapted."
                    },
                    {
                        "username": "Seagull360",
                        "content": "[2,3] [1,2] [1,3] are connected. so there is only 1 connected component, but leetcode test case result is 2. \\n\\n1---2---3\\n|\\n|\\n|\\n3\\n"
                    },
                    {
                        "username": "yzyluvcpsc",
                        "content": "[@angeldimitrov](/angeldimitrov) The edges only tells you which is connected to which. But number of nodes are given by n. So here n = 4, edges = [2,3],[1,2],[1,3], where you have 4 nodes (0, 1, 2, 3) and 1,2,3 is a connected cycle and 0 stands alone"
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "[@yzyluvcpsc](/yzyluvcpsc) \\'node index starts from 0\\', what is that supposed to mean? The edge list does not include 0, therefore it is not in the graph. How did you reach this conclusion that 0 is somehow in the graph?"
                    },
                    {
                        "username": "yzyluvcpsc",
                        "content": "The node index starts from 0, this testcase would be a single 0 and the circular graph you mentioned, so result is 2"
                    },
                    {
                        "username": "fuxian",
                        "content": "why result of 4 [[2,3],[1,2],[1,3]] is 2 not 1?"
                    },
                    {
                        "username": "jnesom",
                        "content": "[@irfanwustl](/irfanwustl) but that node that\\'s not included has no edges, so although it is a component,  its not connected "
                    },
                    {
                        "username": "irfanwustl",
                        "content": "Cause the edges has node 1,2 and 3. But the total node is 4. So there is a node which is not included in the edge list. "
                    },
                    {
                        "username": "jnesom",
                        "content": "Hey all,  a node all by itself with no edges is still considered a connected component. \\n\\n\\n\\n https://www.baeldung.com/cs/graph-connected-components"
                    },
                    {
                        "username": "MrGonzo",
                        "content": "for input [[2,3],[1,2],[1,3]] expected ans 2. it should be 1 right? bcz its circular connected."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "You forgot about 0 which is a standalone node."
                    },
                    {
                        "username": "newman2",
                        "content": "In the worse case, union-find is O(m log n) and BFS/DFS is O(n + m) right?\\nThen the union-find has strictly worse worst case execution time no?\\nIn practice, where the graph is sparse, the union-find can be much faster, but here I am only talking about big O time.\\nCorrect me if I am wrong."
                    },
                    {
                        "username": "andrewtoth",
                        "content": "The constraints say `0 <= ai <= bi < n`\\nbut test case 27 is `[[1,0],[2,0]]` where both `a1 > b1` and `a2>b2`\\nThis should be changed to 2 different constraints\\n`0 <= ai < n`\\nand \\n`0 <= bi < n`\\nor am I missing something about constraint syntax?"
                    },
                    {
                        "username": "lgibson",
                        "content": "I think this should be corrected in the description which says ai <= bi AND ai != bi.  Both can't be true. It should be edited as andrewtoth describes. "
                    },
                    {
                        "username": "A_Penguin",
                        "content": "This problem should be easy."
                    }
                ]
            },
            {
                "id": 1569075,
                "content": [
                    {
                        "username": "zhugejunwei",
                        "content": "In undirected graph, [2, 3] is equal to [3, 2], right?\\n\\nSo [[2,3],[1,2],[1,3]] is equal to [1,2], [[2,3], [3,1]], right?\\n\\nI don't know how the answer of `[[2,3],[1,2],[1,3]]` is **2**.\\n\\nAny ideas?\\n\\n\\n**Edit:**\\nIs it because the node `0`, which doesn't appear in the test case, but *it is actually there*?"
                    },
                    {
                        "username": "eldarnabiresearch",
                        "content": "[@user3238Gj](/user3238Gj) Good job\\n\\n"
                    },
                    {
                        "username": "worldofvadim",
                        "content": "Thank you, because of your comment understood where is the problem"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "[@user3238Gj](/user3238Gj) see the parameter n in the function, so there might be nodes without edges, so n = 4 means there are nodes: 0, 1, 2 ,3 zo 0 has no edges"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "Every node in there is connected"
                    },
                    {
                        "username": "swjung",
                        "content": "It seems like the constraint `0 <= ai <= bi < n` is not adapted."
                    },
                    {
                        "username": "Seagull360",
                        "content": "[2,3] [1,2] [1,3] are connected. so there is only 1 connected component, but leetcode test case result is 2. \\n\\n1---2---3\\n|\\n|\\n|\\n3\\n"
                    },
                    {
                        "username": "yzyluvcpsc",
                        "content": "[@angeldimitrov](/angeldimitrov) The edges only tells you which is connected to which. But number of nodes are given by n. So here n = 4, edges = [2,3],[1,2],[1,3], where you have 4 nodes (0, 1, 2, 3) and 1,2,3 is a connected cycle and 0 stands alone"
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "[@yzyluvcpsc](/yzyluvcpsc) \\'node index starts from 0\\', what is that supposed to mean? The edge list does not include 0, therefore it is not in the graph. How did you reach this conclusion that 0 is somehow in the graph?"
                    },
                    {
                        "username": "yzyluvcpsc",
                        "content": "The node index starts from 0, this testcase would be a single 0 and the circular graph you mentioned, so result is 2"
                    },
                    {
                        "username": "fuxian",
                        "content": "why result of 4 [[2,3],[1,2],[1,3]] is 2 not 1?"
                    },
                    {
                        "username": "jnesom",
                        "content": "[@irfanwustl](/irfanwustl) but that node that\\'s not included has no edges, so although it is a component,  its not connected "
                    },
                    {
                        "username": "irfanwustl",
                        "content": "Cause the edges has node 1,2 and 3. But the total node is 4. So there is a node which is not included in the edge list. "
                    },
                    {
                        "username": "jnesom",
                        "content": "Hey all,  a node all by itself with no edges is still considered a connected component. \\n\\n\\n\\n https://www.baeldung.com/cs/graph-connected-components"
                    },
                    {
                        "username": "MrGonzo",
                        "content": "for input [[2,3],[1,2],[1,3]] expected ans 2. it should be 1 right? bcz its circular connected."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "You forgot about 0 which is a standalone node."
                    },
                    {
                        "username": "newman2",
                        "content": "In the worse case, union-find is O(m log n) and BFS/DFS is O(n + m) right?\\nThen the union-find has strictly worse worst case execution time no?\\nIn practice, where the graph is sparse, the union-find can be much faster, but here I am only talking about big O time.\\nCorrect me if I am wrong."
                    },
                    {
                        "username": "andrewtoth",
                        "content": "The constraints say `0 <= ai <= bi < n`\\nbut test case 27 is `[[1,0],[2,0]]` where both `a1 > b1` and `a2>b2`\\nThis should be changed to 2 different constraints\\n`0 <= ai < n`\\nand \\n`0 <= bi < n`\\nor am I missing something about constraint syntax?"
                    },
                    {
                        "username": "lgibson",
                        "content": "I think this should be corrected in the description which says ai <= bi AND ai != bi.  Both can't be true. It should be edited as andrewtoth describes. "
                    },
                    {
                        "username": "A_Penguin",
                        "content": "This problem should be easy."
                    }
                ]
            },
            {
                "id": 1785035,
                "content": [
                    {
                        "username": "zhugejunwei",
                        "content": "In undirected graph, [2, 3] is equal to [3, 2], right?\\n\\nSo [[2,3],[1,2],[1,3]] is equal to [1,2], [[2,3], [3,1]], right?\\n\\nI don't know how the answer of `[[2,3],[1,2],[1,3]]` is **2**.\\n\\nAny ideas?\\n\\n\\n**Edit:**\\nIs it because the node `0`, which doesn't appear in the test case, but *it is actually there*?"
                    },
                    {
                        "username": "eldarnabiresearch",
                        "content": "[@user3238Gj](/user3238Gj) Good job\\n\\n"
                    },
                    {
                        "username": "worldofvadim",
                        "content": "Thank you, because of your comment understood where is the problem"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "[@user3238Gj](/user3238Gj) see the parameter n in the function, so there might be nodes without edges, so n = 4 means there are nodes: 0, 1, 2 ,3 zo 0 has no edges"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "Every node in there is connected"
                    },
                    {
                        "username": "swjung",
                        "content": "It seems like the constraint `0 <= ai <= bi < n` is not adapted."
                    },
                    {
                        "username": "Seagull360",
                        "content": "[2,3] [1,2] [1,3] are connected. so there is only 1 connected component, but leetcode test case result is 2. \\n\\n1---2---3\\n|\\n|\\n|\\n3\\n"
                    },
                    {
                        "username": "yzyluvcpsc",
                        "content": "[@angeldimitrov](/angeldimitrov) The edges only tells you which is connected to which. But number of nodes are given by n. So here n = 4, edges = [2,3],[1,2],[1,3], where you have 4 nodes (0, 1, 2, 3) and 1,2,3 is a connected cycle and 0 stands alone"
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "[@yzyluvcpsc](/yzyluvcpsc) \\'node index starts from 0\\', what is that supposed to mean? The edge list does not include 0, therefore it is not in the graph. How did you reach this conclusion that 0 is somehow in the graph?"
                    },
                    {
                        "username": "yzyluvcpsc",
                        "content": "The node index starts from 0, this testcase would be a single 0 and the circular graph you mentioned, so result is 2"
                    },
                    {
                        "username": "fuxian",
                        "content": "why result of 4 [[2,3],[1,2],[1,3]] is 2 not 1?"
                    },
                    {
                        "username": "jnesom",
                        "content": "[@irfanwustl](/irfanwustl) but that node that\\'s not included has no edges, so although it is a component,  its not connected "
                    },
                    {
                        "username": "irfanwustl",
                        "content": "Cause the edges has node 1,2 and 3. But the total node is 4. So there is a node which is not included in the edge list. "
                    },
                    {
                        "username": "jnesom",
                        "content": "Hey all,  a node all by itself with no edges is still considered a connected component. \\n\\n\\n\\n https://www.baeldung.com/cs/graph-connected-components"
                    },
                    {
                        "username": "MrGonzo",
                        "content": "for input [[2,3],[1,2],[1,3]] expected ans 2. it should be 1 right? bcz its circular connected."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "You forgot about 0 which is a standalone node."
                    },
                    {
                        "username": "newman2",
                        "content": "In the worse case, union-find is O(m log n) and BFS/DFS is O(n + m) right?\\nThen the union-find has strictly worse worst case execution time no?\\nIn practice, where the graph is sparse, the union-find can be much faster, but here I am only talking about big O time.\\nCorrect me if I am wrong."
                    },
                    {
                        "username": "andrewtoth",
                        "content": "The constraints say `0 <= ai <= bi < n`\\nbut test case 27 is `[[1,0],[2,0]]` where both `a1 > b1` and `a2>b2`\\nThis should be changed to 2 different constraints\\n`0 <= ai < n`\\nand \\n`0 <= bi < n`\\nor am I missing something about constraint syntax?"
                    },
                    {
                        "username": "lgibson",
                        "content": "I think this should be corrected in the description which says ai <= bi AND ai != bi.  Both can't be true. It should be edited as andrewtoth describes. "
                    },
                    {
                        "username": "A_Penguin",
                        "content": "This problem should be easy."
                    }
                ]
            },
            {
                "id": 2075371,
                "content": [
                    {
                        "username": "zhugejunwei",
                        "content": "In undirected graph, [2, 3] is equal to [3, 2], right?\\n\\nSo [[2,3],[1,2],[1,3]] is equal to [1,2], [[2,3], [3,1]], right?\\n\\nI don't know how the answer of `[[2,3],[1,2],[1,3]]` is **2**.\\n\\nAny ideas?\\n\\n\\n**Edit:**\\nIs it because the node `0`, which doesn't appear in the test case, but *it is actually there*?"
                    },
                    {
                        "username": "eldarnabiresearch",
                        "content": "[@user3238Gj](/user3238Gj) Good job\\n\\n"
                    },
                    {
                        "username": "worldofvadim",
                        "content": "Thank you, because of your comment understood where is the problem"
                    },
                    {
                        "username": "user3238Gj",
                        "content": "[@user3238Gj](/user3238Gj) see the parameter n in the function, so there might be nodes without edges, so n = 4 means there are nodes: 0, 1, 2 ,3 zo 0 has no edges"
                    },
                    {
                        "username": "joeleetcode2018",
                        "content": "Every node in there is connected"
                    },
                    {
                        "username": "swjung",
                        "content": "It seems like the constraint `0 <= ai <= bi < n` is not adapted."
                    },
                    {
                        "username": "Seagull360",
                        "content": "[2,3] [1,2] [1,3] are connected. so there is only 1 connected component, but leetcode test case result is 2. \\n\\n1---2---3\\n|\\n|\\n|\\n3\\n"
                    },
                    {
                        "username": "yzyluvcpsc",
                        "content": "[@angeldimitrov](/angeldimitrov) The edges only tells you which is connected to which. But number of nodes are given by n. So here n = 4, edges = [2,3],[1,2],[1,3], where you have 4 nodes (0, 1, 2, 3) and 1,2,3 is a connected cycle and 0 stands alone"
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "[@yzyluvcpsc](/yzyluvcpsc) \\'node index starts from 0\\', what is that supposed to mean? The edge list does not include 0, therefore it is not in the graph. How did you reach this conclusion that 0 is somehow in the graph?"
                    },
                    {
                        "username": "yzyluvcpsc",
                        "content": "The node index starts from 0, this testcase would be a single 0 and the circular graph you mentioned, so result is 2"
                    },
                    {
                        "username": "fuxian",
                        "content": "why result of 4 [[2,3],[1,2],[1,3]] is 2 not 1?"
                    },
                    {
                        "username": "jnesom",
                        "content": "[@irfanwustl](/irfanwustl) but that node that\\'s not included has no edges, so although it is a component,  its not connected "
                    },
                    {
                        "username": "irfanwustl",
                        "content": "Cause the edges has node 1,2 and 3. But the total node is 4. So there is a node which is not included in the edge list. "
                    },
                    {
                        "username": "jnesom",
                        "content": "Hey all,  a node all by itself with no edges is still considered a connected component. \\n\\n\\n\\n https://www.baeldung.com/cs/graph-connected-components"
                    },
                    {
                        "username": "MrGonzo",
                        "content": "for input [[2,3],[1,2],[1,3]] expected ans 2. it should be 1 right? bcz its circular connected."
                    },
                    {
                        "username": "anyvchyk",
                        "content": "You forgot about 0 which is a standalone node."
                    },
                    {
                        "username": "newman2",
                        "content": "In the worse case, union-find is O(m log n) and BFS/DFS is O(n + m) right?\\nThen the union-find has strictly worse worst case execution time no?\\nIn practice, where the graph is sparse, the union-find can be much faster, but here I am only talking about big O time.\\nCorrect me if I am wrong."
                    },
                    {
                        "username": "andrewtoth",
                        "content": "The constraints say `0 <= ai <= bi < n`\\nbut test case 27 is `[[1,0],[2,0]]` where both `a1 > b1` and `a2>b2`\\nThis should be changed to 2 different constraints\\n`0 <= ai < n`\\nand \\n`0 <= bi < n`\\nor am I missing something about constraint syntax?"
                    },
                    {
                        "username": "lgibson",
                        "content": "I think this should be corrected in the description which says ai <= bi AND ai != bi.  Both can't be true. It should be edited as andrewtoth describes. "
                    },
                    {
                        "username": "A_Penguin",
                        "content": "This problem should be easy."
                    }
                ]
            }
        ]
    }
]