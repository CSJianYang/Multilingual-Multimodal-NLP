[
    {
        "title": "Minimum Distance to the Target Element",
        "question_content": "Given an integer array nums (0-indexed) and two integers target and start, find an index i such that nums[i] == target and abs(i - start) is minimized. Note that&nbsp;abs(x)&nbsp;is the absolute value of x.\nReturn abs(i - start).\nIt is guaranteed that target exists in nums.\n&nbsp;\nExample 1:\n\nInput: nums = [1,2,3,4,5], target = 5, start = 3\nOutput: 1\nExplanation: nums[4] = 5 is the only value equal to target, so the answer is abs(4 - 3) = 1.\n\nExample 2:\n\nInput: nums = [1], target = 1, start = 0\nOutput: 0\nExplanation: nums[0] = 1 is the only value equal to target, so the answer is abs(0 - 0) = 0.\n\nExample 3:\n\nInput: nums = [1,1,1,1,1,1,1,1,1,1], target = 1, start = 0\nOutput: 0\nExplanation: Every value of nums is 1, but nums[0] minimizes abs(i - start), which is abs(0 - 0) = 0.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 1000\n\t1 <= nums[i] <= 104\n\t0 <= start < nums.length\n\ttarget is in nums.",
        "solutions": [
            {
                "id": 1186927,
                "title": "c-one-pass-optimization",
                "content": "As an optional optimization, we exit early if `res` cannot be improved anymore.\\n\\n\\n```cpp\\nint getMinDistance(vector<int>& nums, int target, int start) {\\n    int res = INT_MAX;\\n    for (int i = 0; i < nums.size() && res > abs(start - i); ++i)\\n        if (nums[i] == target)\\n            res = abs(start - i);\\n    return res;\\n}\\n```\\nAnother optimization is to initiate the search from the `start` position. It is potentially faster when the `target` is close to the `start`.\\n```cpp\\nint getMinDistance(vector<int>& nums, int t, int start) {\\n    int i = 0, sz = nums.size();\\n    while (nums[max(0, start - i)] != t && nums[min(start + i, sz - 1)] != t)\\n        ++i;\\n    return i;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint getMinDistance(vector<int>& nums, int target, int start) {\\n    int res = INT_MAX;\\n    for (int i = 0; i < nums.size() && res > abs(start - i); ++i)\\n        if (nums[i] == target)\\n            res = abs(start - i);\\n    return res;\\n}\\n```\n```cpp\\nint getMinDistance(vector<int>& nums, int t, int start) {\\n    int i = 0, sz = nums.size();\\n    while (nums[max(0, start - i)] != t && nums[min(start + i, sz - 1)] != t)\\n        ++i;\\n    return i;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1186947,
                "title": "clean-python-3-o-answer",
                "content": "Will be faster if `target` is cloese to `start`.\\n\\nTime: `O(answer)`, degrade to `O(N)` if target is in the head or tail of the given array.\\nSpace: `O(1)`\\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        l = r = start\\n        while l >= 0 or r < len(nums):\\n            if l >= 0 and nums[l] == target: return start - l\\n            if r < len(nums) and nums[r] == target: return r - start\\n            l -= 1\\n            r += 1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        l = r = start\\n        while l >= 0 or r < len(nums):\\n            if l >= 0 and nums[l] == target: return start - l\\n            if r < len(nums) and nums[r] == target: return r - start\\n            l -= 1\\n            r += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186832,
                "title": "python-1-line-solution",
                "content": "# **Explanation**\\nIterate all values and check if it equals to target.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(1)`\\n<br>\\n\\n\\n**Python**\\n```py\\n    def getMinDistance(self, A, target, start):\\n        return min(abs(i - start) for i, a in enumerate(A) if a == target)\\n```\\n",
                "solutionTags": [],
                "code": "```py\\n    def getMinDistance(self, A, target, start):\\n        return min(abs(i - start) for i, a in enumerate(A) if a == target)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1186862,
                "title": "python3-linear-sweep",
                "content": "\\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        ans = inf\\n        for i, x in enumerate(nums): \\n            if x == target: \\n                ans = min(ans, abs(i - start))\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        ans = inf\\n        for i, x in enumerate(nums): \\n            if x == target: \\n                ans = min(ans, abs(i - start))\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186825,
                "title": "c-java-self-explanatory",
                "content": "# c++\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int ans=INT_MAX;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==target){\\n                ans=min(ans,abs(i-start));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# java\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int ans = Integer.MAX_VALUE;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == target) {\\n                ans = Math.min(ans, Math.abs(i - start));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int ans=INT_MAX;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==target){\\n                ans=min(ans,abs(i-start));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int ans = Integer.MAX_VALUE;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == target) {\\n                ans = Math.min(ans, Math.abs(i - start));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186979,
                "title": "c-sequential-scan-two-pointer-approach",
                "content": "There are two ways to solve this problem.\\n\\n1. Doing a sequential traversal of array and updating the min(abs(start-i), min) whenever nums[i] == target.\\n2. Second is to use two pointers,  have two pointers starting from start and let them move in opposite directions. Whenever we reach the target, this is closest to start.\\n\\nCode for 2nd approach:\\n\\n```\\nint getMinDistance(vector<int>& nums, int target, int start) {\\n        int i = start, j = start;\\n        \\n        while(i >= 0 or j <= nums.size()-1) {\\n            if(i >= 0 and nums[i] == target) break;\\n            if(j <= nums.size() - 1 and nums[j] == target) break;\\n            \\n            j++;\\n            i--;\\n        }\\n        \\n        if(i >= 0 and nums[i] == target) {\\n            return abs(start - i);\\n        }\\n        \\n        return abs(start - j);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint getMinDistance(vector<int>& nums, int target, int start) {\\n        int i = start, j = start;\\n        \\n        while(i >= 0 or j <= nums.size()-1) {\\n            if(i >= 0 and nums[i] == target) break;\\n            if(j <= nums.size() - 1 and nums[j] == target) break;\\n            \\n            j++;\\n            i--;\\n        }\\n        \\n        if(i >= 0 and nums[i] == target) {\\n            return abs(start - i);\\n        }\\n        \\n        return abs(start - j);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1187372,
                "title": "java-array-beats-100-0ms-t-c-o-n-s-c-o-1",
                "content": "\\n    // O(nums.length) O(1)\\n\\tpublic int getMinDistance(int[] nums, int target, int start) {\\n\\n\\t\\tint min = Integer.MAX_VALUE, len = nums.length;\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tif (nums[i] == target) {\\n\\t\\t\\t\\tif (Math.abs(i - start) < min)\\n\\t\\t\\t\\t\\tmin = Math.abs(i - start);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn min;\\n\\t}",
                "solutionTags": [],
                "code": "\\n    // O(nums.length) O(1)\\n\\tpublic int getMinDistance(int[] nums, int target, int start) {\\n\\n\\t\\tint min = Integer.MAX_VALUE, len = nums.length;\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tif (nums[i] == target) {\\n\\t\\t\\t\\tif (Math.abs(i - start) < min)\\n\\t\\t\\t\\t\\tmin = Math.abs(i - start);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn min;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1188573,
                "title": "java-o-n-solution-using-stream",
                "content": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        return IntStream.range(0, nums.length)\\n            .filter(i -> nums[i] == target)\\n            .map(i -> Math.abs(i - start))\\n            .min()\\n            .getAsInt();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        return IntStream.range(0, nums.length)\\n            .filter(i -> nums[i] == target)\\n            .map(i -> Math.abs(i - start))\\n            .min()\\n            .getAsInt();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186919,
                "title": "python-easy-to-undersand",
                "content": "Just in case, this code may be explained well for beginners.\\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        a = []\\n        for i in range(len(nums)):\\n            if nums[i]==target:\\n                 a.append(abs(start-i))\\n        return min(a)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        a = []\\n        for i in range(len(nums)):\\n            if nums[i]==target:\\n                 a.append(abs(start-i))\\n        return min(a)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1262476,
                "title": "c-one-pass-4-lines-of-code-only",
                "content": "**PLZ UPVOTE IF YOU LIKED IT**\\n\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int ans=INT_MAX;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==target) ans=min(ans,abs(start-i));\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int ans=INT_MAX;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==target) ans=min(ans,abs(start-i));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2965311,
                "title": "java-easy-solution-3-line-code",
                "content": "please upvote, if you like it.Thak you\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] array, int target, int start) {\\n        int store = Integer.MAX_VALUE, min = Integer.MAX_VALUE;\\n        for (int i = 0; i < array.length; i++) {\\n            if (array[i] == target) store = i;\\n            min = Math.min(min, Math.abs(store - start));\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] array, int target, int start) {\\n        int store = Integer.MAX_VALUE, min = Integer.MAX_VALUE;\\n        for (int i = 0; i < array.length; i++) {\\n            if (array[i] == target) store = i;\\n            min = Math.min(min, Math.abs(store - start));\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1204659,
                "title": "python3-simple-solution-beats-90-users",
                "content": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        if nums[start] == target:return 0\\n        i, j = start-1, start+1\\n        while j < len(nums) or i > -1:\\n            if i > -1:\\n                if nums[i] == target:\\n                    return start-i\\n                i -= 1\\n            if j < len(nums):\\n                if nums[j] == target:\\n                    return j-start\\n                j += 1\\n```\\n**If you like this solution, please upvote for this**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        if nums[start] == target:return 0\\n        i, j = start-1, start+1\\n        while j < len(nums) or i > -1:\\n            if i > -1:\\n                if nums[i] == target:\\n                    return start-i\\n                i -= 1\\n            if j < len(nums):\\n                if nums[j] == target:\\n                    return j-start\\n                j += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186800,
                "title": "python-2-simple-solutions-faster-than-100",
                "content": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        res = []\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                res.append(abs(i - start))\\n        return min(res)\\n```\\n\\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        res = sys.maxsize\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                res = min(res,(abs(i - start)))\\n        return res\\n```\\n\\n![image](https://assets.leetcode.com/users/images/407ccaaa-0b71-4b0f-a453-34a0a54e68bb_1619928523.5857952.png)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        res = []\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                res.append(abs(i - start))\\n        return min(res)\\n```\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        res = sys.maxsize\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                res = min(res,(abs(i - start)))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669607,
                "title": "100-beats-best-java-beginner-friendly-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n     int n = nums.length;\\n     int min = Integer.MAX_VALUE;\\n     for(int i=0;i<n;i++){\\n         if(nums[i]==target){\\n          if(Math.abs(i-start)<min){\\n              min = Math.abs(i-start);\\n          }   \\n         }\\n     }\\n     return min;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n     int n = nums.length;\\n     int min = Integer.MAX_VALUE;\\n     for(int i=0;i<n;i++){\\n         if(nums[i]==target){\\n          if(Math.abs(i-start)<min){\\n              min = Math.abs(i-start);\\n          }   \\n         }\\n     }\\n     return min;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2914715,
                "title": "java-easy-peasy-solution",
                "content": "# Please Upvote :D\\n``` java []\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int min = Integer.MAX_VALUE;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == target) {\\n                min = Math.min(min, Math.abs(i - start));\\n            }\\n        }\\n\\n        return min;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int min = Integer.MAX_VALUE;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == target) {\\n                min = Math.min(min, Math.abs(i - start));\\n            }\\n        }\\n\\n        return min;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2825709,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int sum=nums.length-1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n              sum=Math.min(sum,Math.abs(i-start));  \\n            }\\n        }\\n        return sum;\\n    }}\\n\\t```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int sum=nums.length-1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n              sum=Math.min(sum,Math.abs(i-start));  \\n            }\\n        }\\n        return sum;\\n    }}\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2705184,
                "title": "o-n-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n    let min = Number.POSITIVE_INFINITY;\\n    for(let i =0;i<nums.length;i++){\\n        if(nums[i]==target){\\n            min = Math.min(min,Math.abs(i-start))\\n        }\\n    }\\n   return min\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n    let min = Number.POSITIVE_INFINITY;\\n    for(let i =0;i<nums.length;i++){\\n        if(nums[i]==target){\\n            min = Math.min(min,Math.abs(i-start))\\n        }\\n    }\\n   return min\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2589037,
                "title": "with-explanation-comments-time-8-ms-63-78-space-9-5-mb-96-11",
                "content": "**Like it? ->Upvote please!** \\u30C4\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        \\n        //initialize a variable with the largest possible value\\n        int res=INT_MAX;\\n        \\n        //loop over the whole array elements\\n        for(int i=0;i<nums.size();i++){\\n            //check if the current value equals to the target one\\n            if(nums[i]==target)\\n                //if yes-> compare and save the minumum valid number reached in the loop\\n                res=min(res, abs(i-start));\\n                \\n        }\\n        \\n        //return the min absolute value of the two variables\\n        return res;\\n    }\\n};\\n\\'\\'\\'\\n\\n**Like it? ->Upvote please!** \\u30C4\\n**If still not understood, feel free to comment. I will help you out**\\n**Happy Coding :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        \\n        //initialize a variable with the largest possible value\\n        int res=INT_MAX;\\n        \\n        //loop over the whole array elements\\n        for(int i=0;i<nums.size();i++){\\n            //check if the current value equals to the target one\\n            if(nums[i]==target)\\n                //if yes-> compare and save the minumum valid number reached in the loop\\n                res=min(res, abs(i-start));\\n                \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1290930,
                "title": "python-for-beginners",
                "content": "\\t\\tclass Solution:\\n\\t\\t\\tdef getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n\\t\\t\\t\\treturn min(abs(i-start) for i,j in enumerate(nums) if nums[i]==target)",
                "solutionTags": [],
                "code": "\\t\\tclass Solution:\\n\\t\\t\\tdef getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n\\t\\t\\t\\treturn min(abs(i-start) for i,j in enumerate(nums) if nums[i]==target)",
                "codeTag": "Java"
            },
            {
                "id": 1200271,
                "title": "python-with-early-exit",
                "content": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        if nums[start] == target: return 0\\n        left, right = start-1, start+1\\n        N = len(nums)\\n        while True:\\n            if left >=0 and nums[left] == target:\\n                return start - left\\n            if right < N and nums[right] == target:\\n                return right - start\\n            left -= 1\\n            right += 1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        if nums[start] == target: return 0\\n        left, right = start-1, start+1\\n        N = len(nums)\\n        while True:\\n            if left >=0 and nums[left] == target:\\n                return start - left\\n            if right < N and nums[right] == target:\\n                return right - start\\n            left -= 1\\n            right += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1188277,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn get_min_distance(nums: Vec<i32>, target: i32, start: i32) -> i32 {\\n        let mut min_dist = std::i32::MAX;\\n        for (i, val) in nums.iter().enumerate() {\\n            if *val == target {\\n                min_dist = min_dist.min((i as i32 - start).abs());\\n                if min_dist == 0 {\\n                    break;\\n                }\\n            }\\n        }\\n        min_dist\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Enumeration"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn get_min_distance(nums: Vec<i32>, target: i32, start: i32) -> i32 {\\n        let mut min_dist = std::i32::MAX;\\n        for (i, val) in nums.iter().enumerate() {\\n            if *val == target {\\n                min_dist = min_dist.min((i as i32 - start).abs());\\n                if min_dist == 0 {\\n                    break;\\n                }\\n            }\\n        }\\n        min_dist\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3653440,
                "title": "java-easy-solution-0ms-beats100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhere i have used basic concept.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n       int min=Integer.MAX_VALUE;\\n       for(int i=0;i<nums.length;i++) {\\n           if(nums[i]==target){\\n               int ans=Math.abs(i-start);\\n               min=Math.min(ans,min);\\n           }\\n       }\\n       return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n       int min=Integer.MAX_VALUE;\\n       for(int i=0;i<nums.length;i++) {\\n           if(nums[i]==target){\\n               int ans=Math.abs(i-start);\\n               min=Math.min(ans,min);\\n           }\\n       }\\n       return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596152,
                "title": "python-easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        curVal=len(nums)\\n        for i in range(start,len(nums)):\\n            if nums[i]==target:\\n                curVal=min(curVal,abs(i-start))\\n                break\\n        j=start\\n        while(j>=0):\\n            if nums[j]==target:\\n                curVal=min(curVal,abs(j-start))\\n                break\\n            j-=1\\n        return curVal\\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        curVal=len(nums)\\n        for i in range(start,len(nums)):\\n            if nums[i]==target:\\n                curVal=min(curVal,abs(i-start))\\n                break\\n        j=start\\n        while(j>=0):\\n            if nums[j]==target:\\n                curVal=min(curVal,abs(j-start))\\n                break\\n            j-=1\\n        return curVal\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516534,
                "title": "easy-c-solution-in-o-n-time-complexity",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind the index of \\'target\\', then find the minimum value if target - start.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& a, int target, int start) {\\n        int e1 = -1;\\n        int dist = INT_MAX;\\n        \\n        for(int i = 0; i < a.size(); i++)\\n        {\\n            if(a[i] == target)\\n                e1 = i;    \\n            if(e1 != -1)\\n                if(abs(e1-start) < dist)\\n                    dist = abs(e1-start);\\n        }\\n        if(dist == INT_MAX)\\n            return -1;\\n        return dist;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& a, int target, int start) {\\n        int e1 = -1;\\n        int dist = INT_MAX;\\n        \\n        for(int i = 0; i < a.size(); i++)\\n        {\\n            if(a[i] == target)\\n                e1 = i;    \\n            if(e1 != -1)\\n                if(abs(e1-start) < dist)\\n                    dist = abs(e1-start);\\n        }\\n        if(dist == INT_MAX)\\n            return -1;\\n        return dist;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3413116,
                "title": "minimum-distance-to-the-target-element-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int i, min=INT_MAX;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i]==target && abs(i-start)<min)\\n            {\\n                min = abs(i-start);\\n            }\\n        }\\n        return min;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/792a2ee3-fa92-4936-9a87-216cd9a9ac02_1682613207.1269994.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int i, min=INT_MAX;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i]==target && abs(i-start)<min)\\n            {\\n                min = abs(i-start);\\n            }\\n        }\\n        return min;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3223288,
                "title": "java-runtime-0-ms-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        \\n        int index = nums.length;\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                index = Math.min(index,Math.abs(i-start));\\n            }\\n        }\\n        return index;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        \\n        int index = nums.length;\\n\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                index = Math.min(index,Math.abs(i-start));\\n            }\\n        }\\n        return index;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2972643,
                "title": "fast-easy-js-solution",
                "content": "```\\nvar getMinDistance = function(nums, target, start) {\\n  let dif;\\n\\n  nums\\n    .map((num) => (num == target ? num : null))\\n    .forEach((el, i) => {\\n      if (el !== null) {\\n        const currDif = Math.abs(i - start);\\n\\n        if (dif == undefined) {\\n          dif = currDif;\\n        } else if (currDif < dif) {\\n          dif = currDif;\\n        }\\n      }\\n    });\\n\\n  return dif;  \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar getMinDistance = function(nums, target, start) {\\n  let dif;\\n\\n  nums\\n    .map((num) => (num == target ? num : null))\\n    .forEach((el, i) => {\\n      if (el !== null) {\\n        const currDif = Math.abs(i - start);\\n\\n        if (dif == undefined) {\\n          dif = currDif;\\n        } else if (currDif < dif) {\\n          dif = currDif;\\n        }\\n      }\\n    });\\n\\n  return dif;  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2823504,
                "title": "easy-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n   let left = 0;\\n   let right = 0;\\n   for(let i = start; i>=0; i--){\\n     if(nums[i]===target){\\n       left  = Math.abs(i-start);\\n       break\\n     } else{\\n       left = nums.length;\\n     }\\n   }\\n    for(let i = start; i<nums.length; i++){\\n     if(nums[i]===target){\\n       right  = Math.abs(i-start);\\n       break\\n     } else{\\n       right = nums.length;\\n     }\\n   }  \\n   return left>right ? right : left;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n   let left = 0;\\n   let right = 0;\\n   for(let i = start; i>=0; i--){\\n     if(nums[i]===target){\\n       left  = Math.abs(i-start);\\n       break\\n     } else{\\n       left = nums.length;\\n     }\\n   }\\n    for(let i = start; i<nums.length; i++){\\n     if(nums[i]===target){\\n       right  = Math.abs(i-start);\\n       break\\n     } else{\\n       right = nums.length;\\n     }\\n   }  \\n   return left>right ? right : left;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2821922,
                "title": "java-beats-100-simple-easy",
                "content": "\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int minDistance = Integer.MAX_VALUE;\\n        for(int i=start; i>=0; i--){\\n            if(nums[i] == target){\\n                minDistance = start - i;\\n                break;\\n            }\\n        }\\n        for(int i=start+1; i<nums.length; i++){\\n            if(nums[i] == target){\\n                minDistance = Math.min(minDistance, i-start);\\n                break;\\n            }\\n        }\\n        return minDistance;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int minDistance = Integer.MAX_VALUE;\\n        for(int i=start; i>=0; i--){\\n            if(nums[i] == target){\\n                minDistance = start - i;\\n                break;\\n            }\\n        }\\n        for(int i=start+1; i<nums.length; i++){\\n            if(nums[i] == target){\\n                minDistance = Math.min(minDistance, i-start);\\n                break;\\n            }\\n        }\\n        return minDistance;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2626508,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int t=start;\\n        int ans;\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                ans=Math.abs(i-t);\\n                if(ans<min){\\n                    min=ans;\\n                }\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int t=start;\\n        int ans;\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                ans=Math.abs(i-t);\\n                if(ans<min){\\n                    min=ans;\\n                }\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2551734,
                "title": "short-javascript-solution",
                "content": "```\\nvar getMinDistance = function (nums, target, start) {\\n    let min = Infinity\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] === target && Math.abs(i - start) < min) {\\n            min = Math.abs(i - start)\\n        }\\n    }\\n\\t\\n    return min\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar getMinDistance = function (nums, target, start) {\\n    let min = Infinity\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        if (nums[i] === target && Math.abs(i - start) < min) {\\n            min = Math.abs(i - start)\\n        }\\n    }\\n\\t\\n    return min\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2521585,
                "title": "python-minimum-distance-to-the-target-element-easy-understanding",
                "content": "```\\nclass Solution(object):\\n    def getMinDistance(self, nums, target, start):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :type start: int\\n        :rtype: int\\n        \"\"\"\\n        index = 0\\n        result = []\\n        while index < len(nums):\\n            if nums[index] == target:\\n                result.append(abs(index - start))\\n            index += 1\\n        \\n        return min(result)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def getMinDistance(self, nums, target, start):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :type start: int\\n        :rtype: int\\n        \"\"\"\\n        index = 0\\n        result = []\\n        while index < len(nums):\\n            if nums[index] == target:\\n                result.append(abs(index - start))\\n            index += 1\\n        \\n        return min(result)",
                "codeTag": "Java"
            },
            {
                "id": 2215549,
                "title": "c-2-lines-of-code-short-clean",
                "content": "![image](https://assets.leetcode.com/users/images/d3cf85cf-076a-4762-9722-d583db8daaae_1656541049.452096.png)\\n\\n**T->O(N) && S->O(1)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint getMinDistance(vector<int>& nums, int t, int s) {\\n\\t\\t\\tint ans=INT_MAX;\\n\\t\\t\\tfor(int i=0;i<nums.size();i++){\\n\\t\\t\\t\\tif(nums[i]==t) ans=min(ans,abs(i-s));\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint getMinDistance(vector<int>& nums, int t, int s) {\\n\\t\\t\\tint ans=INT_MAX;\\n\\t\\t\\tfor(int i=0;i<nums.size();i++){\\n\\t\\t\\t\\tif(nums[i]==t) ans=min(ans,abs(i-s));\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1938581,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int min=1001;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==target)\\n                min=Math.min(Math.abs(i-start),min);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int min=1001;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==target)\\n                min=Math.min(Math.abs(i-start),min);\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1831075,
                "title": "o-n-java-simple-beats-100",
                "content": "We will do a two pointer approach, where the `left` and `right` pointer will be initialized to `start` index and we will move our two pointers in opposite direction to find the `target` as soon as we found the target we will just return the required result.\\n\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        \\n        int left = start;\\n        int right = start;\\n        \\n        while(left >= 0 || right < nums.length){\\n            if(left >= 0 && nums[left] == target)\\n                return Math.abs(left - start);\\n            \\n            if(right < nums.length && nums[right] == target)\\n                return Math.abs(right - start);\\n            \\n            left--;\\n            right++;\\n        }\\n    \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        \\n        int left = start;\\n        int right = start;\\n        \\n        while(left >= 0 || right < nums.length){\\n            if(left >= 0 && nums[left] == target)\\n                return Math.abs(left - start);\\n            \\n            if(right < nums.length && nums[right] == target)\\n                return Math.abs(right - start);\\n            \\n            left--;\\n            right++;\\n        }\\n    \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1813450,
                "title": "c-easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        \\n        int i=0;\\n        int result=INT_MAX;\\n        \\n        while(i<nums.size())\\n        {\\n            if(nums[i]==target)\\n            {\\n                result=min(result,abs(i-start));\\n                \\n            }\\n            i++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        \\n        int i=0;\\n        int result=INT_MAX;\\n        \\n        while(i<nums.size())\\n        {\\n            if(nums[i]==target)\\n            {\\n                result=min(result,abs(i-start));\\n                \\n            }\\n            i++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1772913,
                "title": "easy-solution",
                "content": "class Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n  int res = INT_MAX;\\n    for (int i = 0; i < nums.size() && res > abs(start - i); ++i)\\n        if (nums[i] == target)\\n            res = abs(start - i);\\n    return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n  int res = INT_MAX;\\n    for (int i = 0; i < nums.size() && res > abs(start - i); ++i)\\n        if (nums[i] == target)\\n            res = abs(start - i);\\n    return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1687685,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        if (target == nums[start]) return 0;\\n        int minDis = Integer.MAX_VALUE;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == target)\\n                minDis = Math.min(minDis, Math.abs(i - start));\\n        }\\n        return minDis;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        if (target == nums[start]) return 0;\\n        int minDis = Integer.MAX_VALUE;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == target)\\n                minDis = Math.min(minDis, Math.abs(i - start));\\n        }\\n        return minDis;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1637535,
                "title": "java-easy-solution-100-faster",
                "content": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int ans=Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target) ans=Math.min(ans,Math.abs(i-start));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int ans=Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target) ans=Math.min(ans,Math.abs(i-start));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1596373,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        return functools.reduce(lambda a, b: min(a, abs(b[0] - start)) if (b[1] == target) else a, enumerate(nums), float(\\'inf\\'))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        return functools.reduce(lambda a, b: min(a, abs(b[0] - start)) if (b[1] == target) else a, enumerate(nums), float(\\'inf\\'))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1584649,
                "title": "python-sol-faster-than-99",
                "content": "![image](https://assets.leetcode.com/users/images/76662b9f-96ad-4fdd-aa44-c0fa3e4b438b_1637237611.385875.png)\\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        if nums[start] == target:\\n            return 0\\n        i = start\\n        j = start\\n        left = 0\\n        right = 0\\n        \\n        while i < len(nums) or j > 0 :\\n            if nums[i] == target :\\n                \\n                return abs(i - start)\\n            if nums[j] == target:\\n                return abs(start - j)\\n            if i != len(nums) - 1:\\n                i += 1\\n            if j != 0 :\\n                j -= 1\\n        return\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        if nums[start] == target:\\n            return 0\\n        i = start\\n        j = start\\n        left = 0\\n        right = 0\\n        \\n        while i < len(nums) or j > 0 :\\n            if nums[i] == target :\\n                \\n                return abs(i - start)\\n            if nums[j] == target:\\n                return abs(start - j)\\n            if i != len(nums) - 1:\\n                i += 1\\n            if j != 0 :\\n                j -= 1\\n        return\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1538304,
                "title": "c-o-n-t-c-90-fast",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n          int left=start;\\n           int right=start+1;\\n          while(left>=0){\\n              if(nums[left]==target) break;\\n              left--;\\n          }\\n        while(right<nums.size()){\\n            if(nums[right]==target) break;\\n            right++;\\n        }\\n          if(left<0 && right<nums.size()) return abs(right-start);\\n        else if(left>=0 && right>=nums.size()) return abs(left-start);\\n        return min(abs(left-start),abs(right-start));\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n          int left=start;\\n           int right=start+1;\\n          while(left>=0){\\n              if(nums[left]==target) break;\\n              left--;\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 1490609,
                "title": "c-easy-solution-using-only-loops-6-line-code",
                "content": "```\\n// PLEASE UPVOTE IF YOU LIKE THE SOLUTION!!\\nclass Solution \\n{\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) \\n    {\\n        vector<int> l;\\n        int k=0;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==target)\\n            {\\n                \\n                k=abs(i-start);\\n                l.push_back(k);// PUSH ALL THE VALUE SO THAT WE CAN FIND MINIMUM ONE\\n                \\n            }}\\n        sort(l.begin(),l.end());//SORTING\\n        \\n        return l[0];\\n    }\\n    \\n};\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution \\n{\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) \\n    {\\n        vector<int> l;\\n        int k=0;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==target)\\n            {\\n                \\n                k=abs(i-start);\\n                l.push_back(k);// PUSH ALL THE VALUE SO THAT WE CAN FIND MINIMUM ONE\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1459507,
                "title": "c-solution-o-n-time-complexity-and-o-1-space-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& a, int t, int s) {\\n        int n=a.size();\\n        int c=INT_MAX;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]==t)\\n            {\\n                if(abs(i-s)<c)\\n                    c=abs(i-s);\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& a, int t, int s) {\\n        int n=a.size();\\n        int c=INT_MAX;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]==t)\\n            {\\n                if(abs(i-s)<c)\\n                    c=abs(i-s);\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1433500,
                "title": "c-easy-solution-2-pointer-approach",
                "content": "```\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int mini= INT_MAX;\\n        int st= 0;\\n        int end= nums.size()-1;\\n        \\n        while(st<=end)\\n        {\\n            if(nums[st] == target) {\\n                mini= min(mini, abs(st-start)); \\n                st++;\\n            }\\n            else if(nums[end] == target) {\\n                mini= min(mini, abs(end-start)); \\n                end--;\\n            }\\n            else {\\n                st++;   end--;\\n            }\\n        }\\n        return mini;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int mini= INT_MAX;\\n        int st= 0;\\n        int end= nums.size()-1;\\n        \\n        while(st<=end)\\n        {\\n            if(nums[st] == target) {\\n                mini= min(mini, abs(st-start)); \\n                st++;\\n            }\\n            else if(nums[end] == target) {\\n                mini= min(mini, abs(end-start)); \\n                end--;\\n            }\\n            else {\\n                st++;   end--;\\n            }\\n        }\\n        return mini;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1428868,
                "title": "c-easy-to-understand-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int mn=INT_MAX;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i]==target)\\n                mn=min(mn, abs(i-start));\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int mn=INT_MAX;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i]==target)\\n                mn=min(mn, abs(i-start));\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1397435,
                "title": "simple-java-solution",
                "content": "class Solution {\\n\\n    public int getMinDistance(int[] n, int t, int s) {\\n        int i,j,c=Integer.MAX_VALUE,k=0;\\n        for(i=s;i<n.length;i++)\\n        {\\n            if(n[i]==t)\\n            {\\n                k=Math.abs(i-s);\\n                c=Math.min(c,k);\\n            }\\n        }\\n        {\\n            for(i=s;i>=0;i--)\\n            {\\n               if(n[i]==t)\\n               {\\n                   k=Math.abs(i-s);\\n                   c=Math.min(c,k);\\n               }\\n            }\\n        }\\n        return c;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int getMinDistance(int[] n, int t, int s) {\\n        int i,j,c=Integer.MAX_VALUE,k=0;\\n        for(i=s;i<n.length;i++)\\n        {\\n            if(n[i]==t)\\n            {\\n                k=Math.abs(i-s);\\n                c=Math.min(c,k);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1388775,
                "title": "faster-than-92-05-of-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int mn = INT_MAX,n = nums.size();\\n        for(int i = 0 ; i <n;i++)\\n        {\\n            if(nums[i] == target)\\n            {\\n                if(mn > abs(i-start))\\n                    mn = abs(i-start);\\n            }\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int mn = INT_MAX,n = nums.size();\\n        for(int i = 0 ; i <n;i++)\\n        {\\n            if(nums[i] == target)\\n            {\\n                if(mn > abs(i-start))\\n                    mn = abs(i-start);\\n            }\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1297195,
                "title": "python-two-pointers",
                "content": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        l = r = start\\n        while 1:\\n            if l>=0:\\n                if nums[l]==target:\\n                    return start - l\\n                l-=1\\n            if r<len(nums):\\n                if nums[r]==target:\\n                    return r - start\\n                r+=1\\n            \\n            \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        l = r = start\\n        while 1:\\n            if l>=0:\\n                if nums[l]==target:\\n                    return start - l\\n                l-=1\\n            if r<len(nums):\\n                if nums[r]==target:\\n                    return r - start\\n                r+=1\\n            \\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1294967,
                "title": "simple",
                "content": "guys if you find solution usefull \\ndo upvote\\nand feel free to ask in the comment\\n\\n\\n\\n\\n\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int minn=INT_MAX;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==target)\\n             minn=min(minn,abs(i-start));   \\n            }\\n        return minn;\\n        }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int minn=INT_MAX;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==target)\\n             minn=min(minn,abs(i-start));   \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1283284,
                "title": "optimum-solution-java-version",
                "content": "```java\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int left = start, right = start, leftFirstDiff = Integer.MAX_VALUE, rightFirstDiff =  Integer.MAX_VALUE;\\n        boolean leftContinue= true, rightContinue = true;\\n        while(left >= 0 && leftContinue){\\n            if(nums[left] == target){\\n                leftContinue = false;\\n                leftFirstDiff = Math.abs(left - start);\\n            }\\n            left--;\\n        }\\n        while(right < nums.length && rightContinue){\\n            if(nums[right] == target){\\n                rightContinue = false;\\n                rightFirstDiff = Math.abs(right - start);\\n            }\\n            right++;\\n        }\\n        return Math.min(leftFirstDiff, rightFirstDiff);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int left = start, right = start, leftFirstDiff = Integer.MAX_VALUE, rightFirstDiff =  Integer.MAX_VALUE;\\n        boolean leftContinue= true, rightContinue = true;\\n        while(left >= 0 && leftContinue){\\n            if(nums[left] == target){\\n                leftContinue = false;\\n                leftFirstDiff = Math.abs(left - start);\\n            }\\n            left--;\\n        }\\n        while(right < nums.length && rightContinue){\\n            if(nums[right] == target){\\n                rightContinue = false;\\n                rightFirstDiff = Math.abs(right - start);\\n            }\\n            right++;\\n        }\\n        return Math.min(leftFirstDiff, rightFirstDiff);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1277810,
                "title": "runtime-64-ms-faster-than-100-00-of-javascript-online-submissions",
                "content": "#### [](http://)Runtime: 64 ms, faster than 100.00% of JavaScript online submissions for Minimum Distance to the Target Element.\\n```\\nvar getMinDistance = function(nums, target, start) {\\n    let min = Infinity;\\n    for(let i=nums.indexOf(target);i<nums.length;i++){\\n        if(nums[i]===target){\\n            if(Math.abs(i-start)<min) min = Math.abs(i-start);\\n        }\\n    }\\n    return min;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar getMinDistance = function(nums, target, start) {\\n    let min = Infinity;\\n    for(let i=nums.indexOf(target);i<nums.length;i++){\\n        if(nums[i]===target){\\n            if(Math.abs(i-start)<min) min = Math.abs(i-start);\\n        }\\n    }\\n    return min;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1255146,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n       int min=Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(target==nums[i])\\n            {   \\n                min=Math.min(min,Math.abs(i-start));\\n            }  \\n        }   \\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n       int min=Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(target==nums[i])\\n            {   \\n                min=Math.min(min,Math.abs(i-start));\\n            }  \\n        }   \\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1242840,
                "title": "two-pointer-approach-cpp-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int i=start,j=start+1;\\n        int ans=INT_MAX;\\n        int n=nums.size();\\n        while(i>=0 || j<n){\\n            if(i>=0){\\n                if(nums[i]==target && ans>abs(i-start)){\\n                    return abs(i-start);\\n                }\\n            }\\n            if(j<n){\\n                if(nums[j]==target && ans>abs(j-start)){\\n                    return abs(j-start);\\n                }\\n            }\\n            i--;j++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int i=start,j=start+1;\\n        int ans=INT_MAX;\\n        int n=nums.size();\\n        while(i>=0 || j<n){\\n            if(i>=0){\\n                if(nums[i]==target && ans>abs(i-start)){\\n                    return abs(i-start);\\n                }\\n            }\\n            if(j<n){\\n                if(nums[j]==target && ans>abs(j-start)){\\n                    return abs(j-start);\\n                }\\n            }\\n            i--;j++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1234711,
                "title": "rust-linear-scan-to-high-low-pointers",
                "content": "\\n\\n<b>Problem List</b>\\n#High-LowPointers - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/blob/main/txt/by_technique/n_pointers/by_pointer_amount/high_low_pointers.txt)\\n#LinearScan - [github](https://github.com/An7One/leetcode-problems-by-tag-an7one/tree/main/txt/by_technique/n_pointers/by_pointer_amount/linear_scan)\\n\\nHigh-Low Pointers Approach\\n\\n```\\nimpl Solution {\\n    pub fn get_min_distance(nums: Vec<i32>, target: i32, start: i32) -> i32 {\\n        let len_n: i32 = nums.len() as i32;\\n        \\n        let mut lo: i32 = start;\\n        let mut hi: i32 = start;\\n        while lo >= 0 || hi < len_n{\\n            if lo >= 0 {\\n                if nums[lo as usize] == target{\\n                    return start - lo;\\n                }\\n                \\n                lo -= 1;\\n            }\\n            \\n            if hi < len_n{\\n                if nums[hi as usize] == target{\\n                    return hi - start;\\n                }\\n                \\n                hi += 1;\\n            }\\n        }\\n        \\n        unreachable!()\\n    }\\n}\\n```\\n\\nLinear Scan Approach:\\n```\\nimpl Solution {\\n    pub fn get_min_distance(nums: Vec<i32>, target: i32, start: i32) -> i32 {\\n        let len_n: i32 = nums.len() as i32;\\n        let mut min_dis: i32 = len_n;\\n        \\n        for (idx, num) in nums.into_iter().enumerate(){\\n            if num == target{\\n                min_dis = std::cmp::min(min_dis,\\n                (start - idx as i32).abs());\\n            }\\n        };\\n        \\n        min_dis\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn get_min_distance(nums: Vec<i32>, target: i32, start: i32) -> i32 {\\n        let len_n: i32 = nums.len() as i32;\\n        \\n        let mut lo: i32 = start;\\n        let mut hi: i32 = start;\\n        while lo >= 0 || hi < len_n{\\n            if lo >= 0 {\\n                if nums[lo as usize] == target{\\n                    return start - lo;\\n                }\\n                \\n                lo -= 1;\\n            }\\n            \\n            if hi < len_n{\\n                if nums[hi as usize] == target{\\n                    return hi - start;\\n                }\\n                \\n                hi += 1;\\n            }\\n        }\\n        \\n        unreachable!()\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn get_min_distance(nums: Vec<i32>, target: i32, start: i32) -> i32 {\\n        let len_n: i32 = nums.len() as i32;\\n        let mut min_dis: i32 = len_n;\\n        \\n        for (idx, num) in nums.into_iter().enumerate(){\\n            if num == target{\\n                min_dis = std::cmp::min(min_dis,\\n                (start - idx as i32).abs());\\n            }\\n        };\\n        \\n        min_dis\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1220487,
                "title": "easy-to-understand-c-code-by-archit-garg",
                "content": "\\n\\nint getMinDistance(int* nums, int numsSize, int target, int start){\\n    int ans=INT_MAX;\\n        for(int i=0;i<numsSize && ans > abs(start-i);++i)\\n        {\\n            if(nums[i]==target)\\n            {\\n                ans= abs(start-i);\\n            }\\n        }\\n    return ans;\\n}",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n\\nint getMinDistance(int* nums, int numsSize, int target, int start){\\n    int ans=INT_MAX;\\n        for(int i=0;i<numsSize && ans > abs(start-i);++i)\\n        {\\n            if(nums[i]==target)\\n            {\\n                ans= abs(start-i);\\n            }\\n        }\\n    return ans;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1218972,
                "title": "java-two-pointer",
                "content": "```\\npublic int getMinDistance(int[] nums, int target, int start) {\\n        \\n        /* Initialise two pointers Left (L) and Right (R) both to begin at start*/\\n        int n = nums.length -1;\\n        int L = start;\\n        int R = start;\\n        \\n        /* We need to find the minimum dist from start either on left or right of start.\\n\\t\\t * Loop to find the if the closest element is target such that the difference of the target \\n\\t\\t * index and start is minimum\\n         */\\n        while( L >= 0 || R <= n){\\n            if(L >= 0 && nums[L] == target) {\\n                return start - L;\\n            } \\n            if(R <= n && nums[R] == target){\\n                return R - start;\\n            }\\n            L--;\\n            R++;\\n        }\\n        \\n        return 0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int getMinDistance(int[] nums, int target, int start) {\\n        \\n        /* Initialise two pointers Left (L) and Right (R) both to begin at start*/\\n        int n = nums.length -1;\\n        int L = start;\\n        int R = start;\\n        \\n        /* We need to find the minimum dist from start either on left or right of start.\\n\\t\\t * Loop to find the if the closest element is target such that the difference of the target \\n\\t\\t * index and start is minimum\\n         */\\n        while( L >= 0 || R <= n){\\n            if(L >= 0 && nums[L] == target) {\\n                return start - L;\\n            } \\n            if(R <= n && nums[R] == target){\\n                return R - start;\\n            }\\n            L--;\\n            R++;\\n        }\\n        \\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1216412,
                "title": "0ms-java-solution",
                "content": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int min = Integer.MAX_VALUE;\\n        for (int i = start; i < nums.length; i++){\\n            if (nums[i] == target)\\n                min = Math.min(min, Math.abs(i-start));\\n        }\\n        for (int i = start; i >= 0; i--){\\n            if (nums[i] == target)\\n                min = Math.min(min, Math.abs(i-start));\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int min = Integer.MAX_VALUE;\\n        for (int i = start; i < nums.length; i++){\\n            if (nums[i] == target)\\n                min = Math.min(min, Math.abs(i-start));\\n        }\\n        for (int i = start; i >= 0; i--){\\n            if (nums[i] == target)\\n                min = Math.min(min, Math.abs(i-start));\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1214397,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n    var min = Infinity;\\n    for(let i=0; i<nums.length; i++){\\n        if(nums[i] === target){\\n            var diff = Math.abs(i - start);\\n            if(min > diff){\\n                min = diff\\n            }\\n        }\\n    }\\n    return min\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n    var min = Infinity;\\n    for(let i=0; i<nums.length; i++){\\n        if(nums[i] === target){\\n            var diff = Math.abs(i - start);\\n            if(min > diff){\\n                min = diff\\n            }\\n        }\\n    }\\n    return min\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1195213,
                "title": "a-few-solutions",
                "content": "*Kotlin*\\n```\\nclass Solution {\\n    fun getMinDistance(A: IntArray, T: Int, K: Int): Int {\\n        return A.mapIndexed{ i, _ -> if (A[i] == T) Math.abs(i - K) else (1e9 + 7).toInt() }.min()!!\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet getMinDistance = (A, T, K) => Math.min(...A.map((_, i) => A[i] == T ? Math.abs(i - K) : Infinity));\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def getMinDistance(self, A: List[int], T: int, K: int) -> int:\\n        return min(abs(i - K) for i in range(len(A)) if A[i] == T)\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int getMinDistance(VI& A, int T, int K, VI B = {}) {\\n        transform(A.begin(), A.end(), back_inserter(B), [&A, T, K, i = -1](auto _) mutable {\\n            return A[++i] == T ? abs(i - K) : int(1e9 + 7);\\n        });\\n        return *min_element(B.begin(), B.end());\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun getMinDistance(A: IntArray, T: Int, K: Int): Int {\\n        return A.mapIndexed{ i, _ -> if (A[i] == T) Math.abs(i - K) else (1e9 + 7).toInt() }.min()!!\\n    }\\n}\\n```\n```\\nlet getMinDistance = (A, T, K) => Math.min(...A.map((_, i) => A[i] == T ? Math.abs(i - K) : Infinity));\\n```\n```\\nclass Solution:\\n    def getMinDistance(self, A: List[int], T: int, K: int) -> int:\\n        return min(abs(i - K) for i in range(len(A)) if A[i] == T)\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int getMinDistance(VI& A, int T, int K, VI B = {}) {\\n        transform(A.begin(), A.end(), back_inserter(B), [&A, T, K, i = -1](auto _) mutable {\\n            return A[++i] == T ? abs(i - K) : int(1e9 + 7);\\n        });\\n        return *min_element(B.begin(), B.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1191675,
                "title": "c-4ms-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:  \\n    \\n    vector<int> Ind(vector<int> V, int val){\\n        // O(n) function\\n        vector<int> indi;\\n        \\n        for(int i{0}; i<V.size(); ++i){\\n            if(V[i] == val)\\n                indi.push_back(i);\\n        }\\n        return indi;\\n    }\\n    \\n    \\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int ans;\\n        vector<int> index = Ind(nums, target);\\n        for(auto &i : index) i = abs(i-start);\\n        ans = *min_element(index.begin(), index.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:  \\n    \\n    vector<int> Ind(vector<int> V, int val){\\n        // O(n) function\\n        vector<int> indi;\\n        \\n        for(int i{0}; i<V.size(); ++i){\\n            if(V[i] == val)\\n                indi.push_back(i);\\n        }\\n        return indi;\\n    }\\n    \\n    \\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int ans;\\n        vector<int> index = Ind(nums, target);\\n        for(auto &i : index) i = abs(i-start);\\n        ans = *min_element(index.begin(), index.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1191643,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        return min([abs(i-start) for i in range(len(nums)) if nums[i]==target]) \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        return min([abs(i-start) for i in range(len(nums)) if nums[i]==target]) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1189619,
                "title": "swift-solution",
                "content": "Swift solution\\n```\\nclass Solution {\\n    func getMinDistance(_ nums: [Int], _ target: Int, _ start: Int) -> Int {\\n        let c = nums.count\\n        for i in 0...max(start, c - 1 - start) {\\n            let left = start - i, right = start + i\\n            if left >= 0 && nums[left] == target || right < c && nums[right] == target {\\n                return i\\n            }\\n        }\\n        return -1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func getMinDistance(_ nums: [Int], _ target: Int, _ start: Int) -> Int {\\n        let c = nums.count\\n        for i in 0...max(start, c - 1 - start) {\\n            let left = start - i, right = start + i\\n            if left >= 0 && nums[left] == target || right < c && nums[right] == target {\\n                return i\\n            }\\n        }\\n        return -1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1189571,
                "title": "faster-than-100-00",
                "content": "```\\nvar getMinDistance = function(nums, target, start) {\\n  let output = null\\n    for(let i = 0; i < nums.length; i++) {\\n      if(nums[i] === target) {\\n        if(output === null || output > Math.abs(start - i)) { //only storing the **minimized** value\\n          output = Math.abs(start - i)\\n        }\\n      }\\n    }\\n    return output\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar getMinDistance = function(nums, target, start) {\\n  let output = null\\n    for(let i = 0; i < nums.length; i++) {\\n      if(nums[i] === target) {\\n        if(output === null || output > Math.abs(start - i)) { //only storing the **minimized** value\\n          output = Math.abs(start - i)\\n        }\\n      }\\n    }\\n    return output\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1188162,
                "title": "javascript-one-pass",
                "content": "```\\nconst getMinDistance = (nums, target, start) => {\\n    let ans = 1000;\\n    for (let i = 0; i < nums.length; i++)\\n        if (nums[i] == target)\\n            ans = Math.min(ans, Math.abs(i - start));\\n    return ans;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst getMinDistance = (nums, target, start) => {\\n    let ans = 1000;\\n    for (let i = 0; i < nums.length; i++)\\n        if (nums[i] == target)\\n            ans = Math.min(ans, Math.abs(i - start));\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1187614,
                "title": "go-simple-solution",
                "content": "```\\nfunc getMinDistance(nums []int, target int, start int) int {\\n    ans := 100000\\n    for i, n := range(nums) {\\n        if n == target {\\n            diff := i - start\\n            if diff < 0 {\\n                diff = -diff\\n            }\\n            if diff < ans {\\n                ans = diff\\n            }\\n        }\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc getMinDistance(nums []int, target int, start int) int {\\n    ans := 100000\\n    for i, n := range(nums) {\\n        if n == target {\\n            diff := i - start\\n            if diff < 0 {\\n                diff = -diff\\n            }\\n            if diff < ans {\\n                ans = diff\\n            }\\n        }\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1187500,
                "title": "python-3-simple-solution",
                "content": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        n = len(nums)\\n        f = start\\n        b = start\\n        idx = None\\n        while f < n or b >= 0:\\n            if f < n:\\n                if nums[f] == target:\\n                    idx = f\\n                    break\\n                f += 1\\n            if b >= 0:\\n                if nums[b] == target:\\n                    idx  = b\\n                    break\\n                b -= 1\\n        return abs(idx-start)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        n = len(nums)\\n        f = start\\n        b = start\\n        idx = None\\n        while f < n or b >= 0:\\n            if f < n:\\n                if nums[f] == target:\\n                    idx = f\\n                    break\\n                f += 1\\n            if b >= 0:\\n                if nums[b] == target:\\n                    idx  = b\\n                    break\\n                b -= 1\\n        return abs(idx-start)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186816,
                "title": "very-easy-one-pass-c-with-explanation",
                "content": "Time Complexity - O(N)\\nSpace Complexity - O(1)\\n\\n**Explanation**\\nInitialize ans variable with max value (INT_MAX)\\nIterate all values and check if it equals to target \\nIf it is equal to target update ans with min value between ans and abs(i-start)\\n\\n```\\nclass Solution {\\n   public:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int ans = INT_MAX;\\n        for (int i = 0; i < nums.size(); i++)\\n            if (nums[i] == target) ans = min(abs(i - start), ans);\\n        return ans;\\n    }\\n};\\n```\\n\\nFeel free to ask any doubts and \\nIf you like the solution and explanation please **upvote** !!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n   public:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int ans = INT_MAX;\\n        for (int i = 0; i < nums.size(); i++)\\n            if (nums[i] == target) ans = min(abs(i - start), ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4077026,
                "title": "easiest-one",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n       int min=Integer.MAX_VALUE;\\n       for(int i=0;i<nums.length;i++) {\\n           if(nums[i]==target){\\n               int ans=Math.abs(i-start);\\n               min=Math.min(ans,min);\\n           }\\n       }\\n       return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n       int min=Integer.MAX_VALUE;\\n       for(int i=0;i<nums.length;i++) {\\n           if(nums[i]==target){\\n               int ans=Math.abs(i-start);\\n               min=Math.min(ans,min);\\n           }\\n       }\\n       return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070431,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        dist = 0\\n        while True:\\n            if start - dist >= 0 and nums[start - dist] == target:\\n                return dist\\n            if start + dist < len(nums) and nums[start + dist] == target:\\n                return dist\\n            dist += 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        dist = 0\\n        while True:\\n            if start - dist >= 0 and nums[start - dist] == target:\\n                return dist\\n            if start + dist < len(nums) and nums[start + dist] == target:\\n                return dist\\n            dist += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066542,
                "title": "python3-o-n-time-o-1-space-complexity-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBasic approach of finding min distance \\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        min_dis = len(nums)\\n        for i in range(0,len(nums)):\\n            if nums[i] == target:\\n                min_dis = min(abs(i - start), min_dis)\\n        return min_dis\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        min_dis = len(nums)\\n        for i in range(0,len(nums)):\\n            if nums[i] == target:\\n                min_dis = min(abs(i - start), min_dis)\\n        return min_dis\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064536,
                "title": "basic-concept",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int x=0;\\n        int min=32000;\\n        for (int i= 0;i<nums.length;i++){\\n            if (nums[i]==target){\\n                x=Math.abs(i-start);\\n                min=Math.min(x,min);\\n\\n            }\\n            \\n        }\\n     return min;  \\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int x=0;\\n        int min=32000;\\n        for (int i= 0;i<nums.length;i++){\\n            if (nums[i]==target){\\n                x=Math.abs(i-start);\\n                min=Math.min(x,min);\\n\\n            }\\n            \\n        }\\n     return min;  \\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059139,
                "title": "easy-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int  i = 0;\\n        while(start+i < nums.length || start-i >= 0){\\n            if(start+i < nums.length && nums[start+i] == target)\\n                return Math.abs(start-(start+i));\\n            if(start-i >= 0 && nums[start-i] == target)\\n                return Math.abs(start-(start-i));\\n            i++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int  i = 0;\\n        while(start+i < nums.length || start-i >= 0){\\n            if(start+i < nums.length && nums[start+i] == target)\\n                return Math.abs(start-(start+i));\\n            if(start-i >= 0 && nums[start-i] == target)\\n                return Math.abs(start-(start-i));\\n            i++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044167,
                "title": "one-line-solution",
                "content": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:    \\n        return min(abs(i-start) for i, n in enumerate(nums) if n == target)         \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:    \\n        return min(abs(i-start) for i, n in enumerate(nums) if n == target)         \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040094,
                "title": "simple-c-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int GetMinDistance(int[] nums, int target, int start) {\\n        \\n        int currentResult = Int32.MaxValue;\\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            if(nums[i] == target)\\n            {\\n                if(currentResult > Math.Abs(i - start))\\n                    currentResult = Math.Abs(i-start);\\n            }\\n        }\\n        return currentResult;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int GetMinDistance(int[] nums, int target, int start) {\\n        \\n        int currentResult = Int32.MaxValue;\\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            if(nums[i] == target)\\n            {\\n                if(currentResult > Math.Abs(i - start))\\n                    currentResult = Math.Abs(i-start);\\n            }\\n        }\\n        return currentResult;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4030828,
                "title": "easy-understand-solution-swift",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    func getMinDistance(_ nums: [Int], _ target: Int, _ start: Int) -> Int {\\n        var result = [Int]()\\n        \\n        for (index, num) in nums.enumerated() {\\n            if num == target {\\n                result.append(abs(index - start))\\n            }\\n        }\\n        \\n        return result.min() ?? 0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func getMinDistance(_ nums: [Int], _ target: Int, _ start: Int) -> Int {\\n        var result = [Int]()\\n        \\n        for (index, num) in nums.enumerated() {\\n            if num == target {\\n                result.append(abs(index - start))\\n            }\\n        }\\n        \\n        return result.min() ?? 0\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012972,
                "title": "0ms-beats-100-00-of-users",
                "content": "# Complexity\\n- Time complexity:\\nO(logn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int result = 100000;\\n        int i=0,j=nums.length-1;\\n        while(i<=j){\\n            if(nums[i] == target){\\n                result = Math.min(result, Math.abs(i-start));\\n            }\\n            if(nums[j] == target){\\n                result = Math.min(result, Math.abs(j-start));\\n            }\\n            i++;\\n            j--;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int result = 100000;\\n        int i=0,j=nums.length-1;\\n        while(i<=j){\\n            if(nums[i] == target){\\n                result = Math.min(result, Math.abs(i-start));\\n            }\\n            if(nums[j] == target){\\n                result = Math.min(result, Math.abs(j-start));\\n            }\\n            i++;\\n            j--;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998759,
                "title": "minimum-distance-to-target-element-python-solution-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        mini = 9999\\n        n = len(nums)\\n        for i in range(0, n):\\n            if nums[i]==target and abs(i-start)<mini:\\n                mini = abs(i-start)\\n        if mini == 9999:\\n            return start\\n        return mini\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        mini = 9999\\n        n = len(nums)\\n        for i in range(0, n):\\n            if nums[i]==target and abs(i-start)<mini:\\n                mini = abs(i-start)\\n        if mini == 9999:\\n            return start\\n        return mini\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3989939,
                "title": "easy-java-1ms-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        ArrayList<Integer> list=new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target)\\n                list.add(Math.abs(i-start));\\n        }\\n        return Collections.min(list);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        ArrayList<Integer> list=new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target)\\n                list.add(Math.abs(i-start));\\n        }\\n        return Collections.min(list);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988036,
                "title": "c-bherry-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int mn=INT_MAX;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==target){\\n                mn= min(abs(i - start), mn);\\n            }\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int mn=INT_MAX;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i]==target){\\n                mn= min(abs(i - start), mn);\\n            }\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3986689,
                "title": "beats-100-python-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:o(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        listx=  []\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                listx.append(i)\\n        return min(abs(i - start) for i in listx)\\n\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        listx=  []\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                listx.append(i)\\n        return min(abs(i - start) for i in listx)\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981603,
                "title": "c-simple-and-easy-solution",
                "content": "upvote if you like the solution\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int ans = INT_MAX;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] == target){\\n                ans = min(ans , abs(i - start));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int ans = INT_MAX;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i] == target){\\n                ans = min(ans , abs(i - start));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976916,
                "title": "easy-to-understand-python3-solution-tc-o-n-sc-o-n-worst-case",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        target_i = []\\n\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                target_i.append(i)\\n        \\n        min_val = float(\\'inf\\')\\n\\n        for i in target_i:\\n            min_val = min(min_val, abs(i-start))\\n\\n        return min_val\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        target_i = []\\n\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                target_i.append(i)\\n        \\n        min_val = float(\\'inf\\')\\n\\n        for i in target_i:\\n            min_val = min(min_val, abs(i-start))\\n\\n        return min_val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976065,
                "title": "nice-and-elegant-solution-in-java-beats-100-rt-and-98-memory",
                "content": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int output = Integer.MAX_VALUE;\\n        if (nums[start] == target) {\\n            return 0;\\n        }\\n        for (int i = start; i < nums.length; i++) {\\n            if (nums[i] == target) {\\n                output = Math.abs(i - start);\\n                if (output == 1) {\\n                    return output;\\n                }                \\n                i = nums.length - 1;\\n            }\\n            if (i == nums.length - 1) {\\n                for (int j = 0; j < start; j++) {\\n                    if (nums[j] == target) {\\n                        output = Math.min(output, Math.abs(j - start));\\n                        if (output == 1) {\\n                            return output;\\n                        }\\n                    }                 \\n                }\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int output = Integer.MAX_VALUE;\\n        if (nums[start] == target) {\\n            return 0;\\n        }\\n        for (int i = start; i < nums.length; i++) {\\n            if (nums[i] == target) {\\n                output = Math.abs(i - start);\\n                if (output == 1) {\\n                    return output;\\n                }                \\n                i = nums.length - 1;\\n            }\\n            if (i == nums.length - 1) {\\n                for (int j = 0; j < start; j++) {\\n                    if (nums[j] == target) {\\n                        output = Math.min(output, Math.abs(j - start));\\n                        if (output == 1) {\\n                            return output;\\n                        }\\n                    }                 \\n                }\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975194,
                "title": "easist-way-for-this-problem",
                "content": "```\\nvar getMinDistance = function (nums, target, start) {\\n  let min = nums.length;\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] === target && Math.abs(i - start) < min) {\\n      min = Math.abs(i - start);\\n    }\\n  }\\n  return min;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar getMinDistance = function (nums, target, start) {\\n  let min = nums.length;\\n  for (let i = 0; i < nums.length; i++) {\\n    if (nums[i] === target && Math.abs(i - start) < min) {\\n      min = Math.abs(i - start);\\n    }\\n  }\\n  return min;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3968037,
                "title": "best-sollution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int x = 0;\\n        ArrayList<Integer>list = new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                x = Math.abs(i-start);\\n                list.add(x);\\n            }\\n        }\\n        Collections.sort(list);\\n        return list.get(0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int x = 0;\\n        ArrayList<Integer>list = new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                x = Math.abs(i-start);\\n                list.add(x);\\n            }\\n        }\\n        Collections.sort(list);\\n        return list.get(0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962480,
                "title": "python-simple-and-faster-98-o-n-space-o-1-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def getMinDistance(self, nums, target, start):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :type start: int\\n        :rtype: int\\n        \"\"\"\\n        res = -1\\n        for j, i in enumerate(nums):\\n            if i != target: continue\\n            temp = abs(j - start)\\n            if res == -1 or (res > -1 and temp < res):\\n                res = temp\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def getMinDistance(self, nums, target, start):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :type start: int\\n        :rtype: int\\n        \"\"\"\\n        res = -1\\n        for j, i in enumerate(nums):\\n            if i != target: continue\\n            temp = abs(j - start)\\n            if res == -1 or (res > -1 and temp < res):\\n                res = temp\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942296,
                "title": "simple-3-line-code-tc-o-n-beats-100-00-of-users-with-java",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int ans = Integer.MAX_VALUE;\\n        for (int i = 0; i < nums.length; i++) {\\n            if(nums[i] == target) ans = Math.min(Math.abs(i - start), ans);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int ans = Integer.MAX_VALUE;\\n        for (int i = 0; i < nums.length; i++) {\\n            if(nums[i] == target) ans = Math.min(Math.abs(i - start), ans);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923204,
                "title": "java-solution-one-for-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                int abs=Math.abs(i-start);\\n                min=Math.min(min,abs);\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                int abs=Math.abs(i-start);\\n                min=Math.min(min,abs);\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3915781,
                "title": "beats-100-in-runtime-c",
                "content": "# Intuition\\nCheck every elemet from the right of start, find the shortest distance.\\n\\nGo back to start, and do the same thing for elements to the left of start.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$: 1 iteration over the array total\\n\\n- Space complexity:\\n$$O(1)$$ Local variables have a single value, regardless of size\\n\\n# Code\\n```\\npublic class Solution {\\n    public int GetMinDistance(int[] nums, int target, int start) {\\n\\n        int direction = 1;\\n        int shortestRight = int.MaxValue;\\n        int shortestLeft = int.MaxValue;\\n\\n        for(int i = start; i >= 0; i += direction)\\n        {\\n            if(i == nums.Length)\\n            {\\n                i = start;\\n                direction *= -1;\\n                continue;\\n            }\\n\\n            if(nums[i] == target)\\n            {\\n                if(direction > 0)\\n                {\\n                    shortestRight = Math.Abs(i - start);\\n                    direction *= -1;\\n                    i = start;\\n                } \\n                else\\n                {\\n                    shortestLeft = Math.Abs(start - i); \\n                    break;\\n                } \\n            }\\n        }\\n\\n        return Math.Min(shortestRight, shortestLeft);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int GetMinDistance(int[] nums, int target, int start) {\\n\\n        int direction = 1;\\n        int shortestRight = int.MaxValue;\\n        int shortestLeft = int.MaxValue;\\n\\n        for(int i = start; i >= 0; i += direction)\\n        {\\n            if(i == nums.Length)\\n            {\\n                i = start;\\n                direction *= -1;\\n                continue;\\n            }\\n\\n            if(nums[i] == target)\\n            {\\n                if(direction > 0)\\n                {\\n                    shortestRight = Math.Abs(i - start);\\n                    direction *= -1;\\n                    i = start;\\n                } \\n                else\\n                {\\n                    shortestLeft = Math.Abs(start - i); \\n                    break;\\n                } \\n            }\\n        }\\n\\n        return Math.Min(shortestRight, shortestLeft);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3909354,
                "title": "getmindistance",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nuse a vector to store all the indexes of occurence of target.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        vector<int> v;\\n       \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==target){v.push_back(i);}\\n        }\\n        int min=INT_MAX;\\n        for(auto i:v)\\n        {\\n            if(abs(i-start)<min)min=abs(i-start);\\n        }\\n        return min;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        vector<int> v;\\n       \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==target){v.push_back(i);}\\n        }\\n        int min=INT_MAX;\\n        for(auto i:v)\\n        {\\n            if(abs(i-start)<min)min=abs(i-start);\\n        }\\n        return min;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885790,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int n = nums.length, min = 99000000;\\n\\n        for(int i = 0; i < n; i++)\\n            if(nums[i] == target)\\n                min = Math.min(min, Math.abs(i - start));\\n            \\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int n = nums.length, min = 99000000;\\n\\n        for(int i = 0; i < n; i++)\\n            if(nums[i] == target)\\n                min = Math.min(min, Math.abs(i - start));\\n            \\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884266,
                "title": "minimum-distance-to-the-target-element",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                min = Math.min(min,Math.abs(i-start));\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                min = Math.min(min,Math.abs(i-start));\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3858173,
                "title": "minimum-distance-to-the-target-element",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) \\n    {\\n        int n=nums.size();\\n        int res=INT_MAX;\\n        for(int i=0;i<n; i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                int cnt= abs(i-start);\\n                res=min(cnt,res);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) \\n    {\\n        int n=nums.size();\\n        int res=INT_MAX;\\n        for(int i=0;i<n; i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                int cnt= abs(i-start);\\n                res=min(cnt,res);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3850790,
                "title": "js-simple-solution-faster-than-100",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n    let min = nums.length\\n\\n    for (let i = 0; i < nums.length; i++) if (nums[i] == target && Math.abs(i - start) < min) min = Math.abs(i - start)\\n\\n    return min\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n    let min = nums.length\\n\\n    for (let i = 0; i < nums.length; i++) if (nums[i] == target && Math.abs(i - start) < min) min = Math.abs(i - start)\\n\\n    return min\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3849736,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        vector<int> v;\\n        int ans;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i] == target)ans = abs(i-start);\\n            v.push_back(ans);\\n        }\\n        sort(v.begin(), v.end());\\n        return v[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        vector<int> v;\\n        int ans;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i] == target)ans = abs(i-start);\\n            v.push_back(ans);\\n        }\\n        sort(v.begin(), v.end());\\n        return v[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841825,
                "title": "easy-0ms-java-solution-beats-100-easypeasy-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int n=nums.length;\\n        int i,j;\\n        int a;\\n        int min=Integer.MAX_VALUE;\\n        for(i=0;i<=n-1;i++){\\n            if(nums[i]==target){\\n                a=Math.abs(i-start);\\n                if(a<min){\\n                    min=a;\\n                }\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int n=nums.length;\\n        int i,j;\\n        int a;\\n        int min=Integer.MAX_VALUE;\\n        for(i=0;i<=n-1;i++){\\n            if(nums[i]==target){\\n                a=Math.abs(i-start);\\n                if(a<min){\\n                    min=a;\\n                }\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3834521,
                "title": "easiest-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int ans = Integer.MAX_VALUE;\\n\\n        for (int i = 0; i < nums.length; ++i) {\\n            if (nums[i] == target) {\\n                ans = Math.min(Math.abs(i-start), ans);\\n            }\\n        }\\n        //upvote if helpful\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int ans = Integer.MAX_VALUE;\\n\\n        for (int i = 0; i < nums.length; ++i) {\\n            if (nums[i] == target) {\\n                ans = Math.min(Math.abs(i-start), ans);\\n            }\\n        }\\n        //upvote if helpful\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820844,
                "title": "o-n-solution-in-cpp",
                "content": "\\n# Complexity\\n- Time complexity: ```O(n)```\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: ```O(1)```\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n     int ans = INT_MAX;\\n     for(int i = 0; i < nums.size(); i++){\\n         if(nums[i] == target)\\n            ans = min(ans, abs(i-start));\\n     }\\n\\n\\n     return ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```O(n)```\n```O(1)```\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n     int ans = INT_MAX;\\n     for(int i = 0; i < nums.size(); i++){\\n         if(nums[i] == target)\\n            ans = min(ans, abs(i-start));\\n     }\\n\\n\\n     return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3818638,
                "title": "easy-solution-in-java-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] a, int t ,int s) {\\n         int m=Integer.MAX_VALUE;\\n         int n=a.length;\\n         for(int i=0;i<n;i++) {\\n           if(a[i]==t){\\n               int v=Math.abs(i-s);\\n               if(m>v)\\n               m=v;\\n           }\\n       }\\n       return m;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] a, int t ,int s) {\\n         int m=Integer.MAX_VALUE;\\n         int n=a.length;\\n         for(int i=0;i<n;i++) {\\n           if(a[i]==t){\\n               int v=Math.abs(i-s);\\n               if(m>v)\\n               m=v;\\n           }\\n       }\\n       return m;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3786167,
                "title": "easiest-question",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>&n , int t , int s){\\n        int mn=INT_MAX;\\n        for(int i=0; i<n.size(); i++){\\n            if(n[i]==t){\\n                if(mn>abs(i-s)){\\n                    mn=abs(i-s);\\n                }\\n            }\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>&n , int t , int s){\\n        int mn=INT_MAX;\\n        for(int i=0; i<n.size(); i++){\\n            if(n[i]==t){\\n                if(mn>abs(i-s)){\\n                    mn=abs(i-s);\\n                }\\n            }\\n        }\\n        return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779411,
                "title": "java-easy-0-ms-fastest-don-t-think-complex",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        if(nums[start]==target) return 0;\\n        else {\\n            int min = nums.length+1;\\n            for(int i=start+1; i<nums.length; i++){\\n                if(nums[i]==target) {\\n                    min = i-start;\\n                    break;\\n                }\\n            }\\n            for(int i=start-1; i>=0; i--) {\\n                if(nums[i]==target) {\\n                    if(start-i < min) {\\n                        return start-i;\\n                    }\\n                }\\n            }\\n            return min;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        if(nums[start]==target) return 0;\\n        else {\\n            int min = nums.length+1;\\n            for(int i=start+1; i<nums.length; i++){\\n                if(nums[i]==target) {\\n                    min = i-start;\\n                    break;\\n                }\\n            }\\n            for(int i=start-1; i>=0; i--) {\\n                if(nums[i]==target) {\\n                    if(start-i < min) {\\n                        return start-i;\\n                    }\\n                }\\n            }\\n            return min;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3764340,
                "title": "simple-and-most-basic-solution-beats-100",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate the minimun distace variable whhich contains the maximum value \\nof integer range.\\ncreate a variable to strore the final result and initial it with 0 then interte from start to end of array and check the fisrt condition of arr[i]==t n then create int dist...so we can ccalculate the result at each iteration.\\nthen compare each dist with minimun value varible and assign the value to ans varible.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] arr, int t, int s) {\\n        int min_dis=Integer.MAX_VALUE;\\n        int ans=0;\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]==t){\\n                int dis=Math.abs(i-s);\\n                if(dis<min_dis){\\n                    min_dis=dis;\\n                    ans=dis;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] arr, int t, int s) {\\n        int min_dis=Integer.MAX_VALUE;\\n        int ans=0;\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]==t){\\n                int dis=Math.abs(i-s);\\n                if(dis<min_dis){\\n                    min_dis=dis;\\n                    ans=dis;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3760836,
                "title": "very-basic-java-soln-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int min=nums.length;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target)\\n                min=Math.min(min,Math.abs(i-start));\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int min=nums.length;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target)\\n                min=Math.min(min,Math.abs(i-start));\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3760446,
                "title": "easy-javascript-method",
                "content": "# Intuition\\nWe start at \\'start\\' position and we only need to search the left and right sides of it. \\n\\nThere are 3 situations\\n\\nLeft : a-i\\nRight : b+i\\nSelf : i=0\\n\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n\\n    for (let i=0;i<=nums.length;i++){\\n    let a = nums[start-i];// Left\\n    let b = nums[start+i];// Right\\n    if (target == nums[start]) return i; //Self, i=0\\n    if (a==target || b==target) return i; //Left or Right\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n\\n    for (let i=0;i<=nums.length;i++){\\n    let a = nums[start-i];// Left\\n    let b = nums[start+i];// Right\\n    if (target == nums[start]) return i; //Self, i=0\\n    if (a==target || b==target) return i; //Left or Right\\n    }\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3748933,
                "title": "runtime-67-ms-beats-78-61-memory-16-5-mb-beats-66-75",
                "content": "# Intuition\\nThe code aims to find the minimum distance between a target value and a given starting index in a list of numbers.\\n\\n# Approach\\nThe approach used in the code is to iterate through each element in the `nums` list. For each element, it checks if the element is equal to the target value. If it is, the code calculates the absolute difference between the current index and the starting index and appends it to the `value` list. By doing this for all elements in the `nums` list, the code obtains a list of distances from the target value to the starting index. Finally, it returns the minimum value from the `value` list, representing the minimum distance.\\n\\n# Complexity\\n- Time complexity:\\nThe code iterates through each element in the `nums` list and performs a constant-time operation for each element. Therefore, the time complexity of the code is O(n), where n is the length of the `nums` list.\\n\\n- Space complexity:\\nThe code uses an additional list `value` to store the distances. The maximum length of the `value` list is the same as the length of the `nums` list. Therefore, the space complexity of the code is O(n), as it requires additional space proportional to the input size.\\n\\n# Code\\n```python\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        value = []\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                value.append(abs(i-start))\\n        return min(value)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "# Intuition\\nThe code aims to find the minimum distance between a target value and a given starting index in a list of numbers.\\n\\n# Approach\\nThe approach used in the code is to iterate through each element in the `nums` list. For each element, it checks if the element is equal to the target value. If it is, the code calculates the absolute difference between the current index and the starting index and appends it to the `value` list. By doing this for all elements in the `nums` list, the code obtains a list of distances from the target value to the starting index. Finally, it returns the minimum value from the `value` list, representing the minimum distance.\\n\\n# Complexity\\n- Time complexity:\\nThe code iterates through each element in the `nums` list and performs a constant-time operation for each element. Therefore, the time complexity of the code is O(n), where n is the length of the `nums` list.\\n\\n- Space complexity:\\nThe code uses an additional list `value` to store the distances. The maximum length of the `value` list is the same as the length of the `nums` list. Therefore, the space complexity of the code is O(n), as it requires additional space proportional to the input size.\\n\\n# Code\\n```python\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        value = []\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                value.append(abs(i-start))\\n        return min(value)\\n",
                "codeTag": "Java"
            },
            {
                "id": 3743586,
                "title": "easy-solution-o-n-linear-search",
                "content": "#\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int mini=INT_MAX;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==target&&mini>abs(i-start))\\n             mini=abs(i-start);\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int mini=INT_MAX;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==target&&mini>abs(i-start))\\n             mini=abs(i-start);\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3725514,
                "title": "js-2pointer-beats-100-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n2-pointer approch\\nstart 2 pointers left and right from start\\nincrease right and decrese left untill target is found\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nworst case senario-O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n    let left = start\\n    let right = start\\n    while(left>-1 || right<nums.length){\\n        if(nums[left] === target){\\n            return Math.abs(left-start)\\n        }\\n        if(nums[right] === target){\\n            return Math.abs(right-start)\\n        }\\n        left--\\n        right++\\n\\n    }\\n\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n    let left = start\\n    let right = start\\n    while(left>-1 || right<nums.length){\\n        if(nums[left] === target){\\n            return Math.abs(left-start)\\n        }\\n        if(nums[right] === target){\\n            return Math.abs(right-start)\\n        }\\n        left--\\n        right++\\n\\n    }\\n\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3721598,
                "title": "bfs-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        for i in range(len(nums)):\\n            if start+i < len(nums) and nums[start+i]==target:\\n                return i\\n            if start-i >= 0 and nums[start-i]==target:\\n                return i\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        for i in range(len(nums)):\\n            if start+i < len(nums) and nums[start+i]==target:\\n                return i\\n            if start-i >= 0 and nums[start-i]==target:\\n                return i\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708501,
                "title": "easy-solution-in-c-beats-93",
                "content": "# Intuition\\n\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int minans=0;\\n        int currans=1111111111;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==target){\\n                currans=min(currans,abs(i-start));\\n                minans=currans;\\n            }\\n        }\\n        return currans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int minans=0;\\n        int currans=1111111111;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==target){\\n                currans=min(currans,abs(i-start));\\n                minans=currans;\\n            }\\n        }\\n        return currans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708057,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int ans , mini = 1e9;\\n        for (int i=0 ; i<nums.size() ; i++){\\n            if (abs(i-start) < mini && nums[i]==target){\\n                mini = abs(i-start);\\n                ans = mini;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int ans , mini = 1e9;\\n        for (int i=0 ; i<nums.size() ; i++){\\n            if (abs(i-start) < mini && nums[i]==target){\\n                mini = abs(i-start);\\n                ans = mini;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696847,
                "title": "minimum-distance-to-the-target-element-easy-solution-using-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int min=INT_MAX;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==target){\\n                if(min>abs(start-i)){\\n                    min=abs(start-i);\\n                }\\n            }\\n        }\\n        return min;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int min=INT_MAX;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==target){\\n                if(min>abs(start-i)){\\n                    min=abs(start-i);\\n                }\\n            }\\n        }\\n        return min;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3695195,
                "title": "easiest-java-solution",
                "content": "\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                if((int)Math.abs(i-start)<min)min=(int)Math.abs(i-start);\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                if((int)Math.abs(i-start)<min)min=(int)Math.abs(i-start);\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685262,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def getMinDistance(nums: Array[Int], target: Int, start: Int): Int = {\\n        nums.zipWithIndex.filter(_._1 == target).map(pair => math.abs(pair._2 - start)).min\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def getMinDistance(nums: Array[Int], target: Int, start: Int): Int = {\\n        nums.zipWithIndex.filter(_._1 == target).map(pair => math.abs(pair._2 - start)).min\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3677025,
                "title": "easy-c-solution-beginner-friendly-approach-beats-92-in-both",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int ans = nums.size();\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i]==target)\\n                ans = min(abs(i-start), ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int ans = nums.size();\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i]==target)\\n                ans = min(abs(i-start), ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3654430,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity:  $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n    let min = Number.POSITIVE_INFINITY;\\n    for(let i =0; i<nums.length; i++){\\n        if(nums[i] == target){\\n            min = Math.min(min, Math.abs(i-start))\\n        }\\n    }\\n   return min\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n    let min = Number.POSITIVE_INFINITY;\\n    for(let i =0; i<nums.length; i++){\\n        if(nums[i] == target){\\n            min = Math.min(min, Math.abs(i-start))\\n        }\\n    }\\n   return min\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3651434,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int i,j;\\n        i=start-1;\\n        j=start+1;\\n        if(nums[start]==target)return 0;\\n        while(i>=0||j<nums.length){\\n            if(i>=0){\\n                if(nums[i]==target)return start-i;\\n                i--;\\n            }\\n            if(j<nums.length){\\n                if(nums[j]==target)return j-start;\\n                j++;\\n            }\\n        }\\n       return 0; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int i,j;\\n        i=start-1;\\n        j=start+1;\\n        if(nums[start]==target)return 0;\\n        while(i>=0||j<nums.length){\\n            if(i>=0){\\n                if(nums[i]==target)return start-i;\\n                i--;\\n            }\\n            if(j<nums.length){\\n                if(nums[j]==target)return j-start;\\n                j++;\\n            }\\n        }\\n       return 0; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3635641,
                "title": "java-solution-easy-understanding-runtime-0ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        \\n        int min = Integer.MAX_VALUE;\\n\\n        for(int i = 0; i<nums.length; i++)\\n        {\\n            if(nums[i] == target)\\n            {\\n                int diff = Math.abs(i - start);\\n                min = Math.min(diff, min);\\n            }\\n        }\\n\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        \\n        int min = Integer.MAX_VALUE;\\n\\n        for(int i = 0; i<nums.length; i++)\\n        {\\n            if(nums[i] == target)\\n            {\\n                int diff = Math.abs(i - start);\\n                min = Math.min(diff, min);\\n            }\\n        }\\n\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3625410,
                "title": "100-faster-and-less-memory-im-lazy-so-i-write-what-i-want-w-o-thinking",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn get_min_distance(nums: Vec<i32>, target: i32, start: i32) -> i32 {\\n        if nums[start as usize] == target {return 0}\\n        let mut left: i32 = start-1;\\n        let mut right: i32 = start + 1;\\n        let mut left_found: i32 = -1;\\n        let mut right_found: i32 = -1;\\n        while left >= 0 || right < nums.len() as i32 {\\n            if left_found != -1 && right_found != -1 {\\n                break;\\n            }\\n            if left >= 0 {\\n                if nums[left as usize] == target && left_found == -1{\\n                    left_found = left;\\n                }\\n                left -= 1;\\n            }\\n            if right < nums.len() as i32 {\\n                if nums[right as usize] == target && right_found == -1{\\n                    right_found = right;\\n                }\\n                right += 1;\\n            }\\n        }\\n        // println!(\"{} {}\", left_found, right_found);\\n        if left_found != -1 && right_found != -1 {\\n            let left_start: i32 = i32::abs(start-left_found);\\n            let right_start: i32 = i32::abs(start-right_found);\\n            if left_start < right_start {\\n                return left_start;\\n            }\\n            return right_start;\\n        }\\n        if left_found != -1 {\\n            return i32::abs(start-left_found);\\n        }\\n        i32::abs(start-right_found)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Array"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn get_min_distance(nums: Vec<i32>, target: i32, start: i32) -> i32 {\\n        if nums[start as usize] == target {return 0}\\n        let mut left: i32 = start-1;\\n        let mut right: i32 = start + 1;\\n        let mut left_found: i32 = -1;\\n        let mut right_found: i32 = -1;\\n        while left >= 0 || right < nums.len() as i32 {\\n            if left_found != -1 && right_found != -1 {\\n                break;\\n            }\\n            if left >= 0 {\\n                if nums[left as usize] == target && left_found == -1{\\n                    left_found = left;\\n                }\\n                left -= 1;\\n            }\\n            if right < nums.len() as i32 {\\n                if nums[right as usize] == target && right_found == -1{\\n                    right_found = right;\\n                }\\n                right += 1;\\n            }\\n        }\\n        // println!(\"{} {}\", left_found, right_found);\\n        if left_found != -1 && right_found != -1 {\\n            let left_start: i32 = i32::abs(start-left_found);\\n            let right_start: i32 = i32::abs(start-right_found);\\n            if left_start < right_start {\\n                return left_start;\\n            }\\n            return right_start;\\n        }\\n        if left_found != -1 {\\n            return i32::abs(start-left_found);\\n        }\\n        i32::abs(start-right_found)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3615602,
                "title": "java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int Leftindex = 0, rightIndex = Integer.MAX_VALUE;\\n        for(int i = start; i < nums.length; i++){\\n            if(nums[i] == target){\\n                Leftindex = i;\\n                break;\\n            }\\n        }\\n\\n        for(int i = start; i >= 0; i--){\\n            if(nums[i] == target){\\n                rightIndex = i;\\n                break;\\n            }\\n        }\\n        return Math.min(Math.abs(Leftindex - start), Math.abs(rightIndex - start));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int Leftindex = 0, rightIndex = Integer.MAX_VALUE;\\n        for(int i = start; i < nums.length; i++){\\n            if(nums[i] == target){\\n                Leftindex = i;\\n                break;\\n            }\\n        }\\n\\n        for(int i = start; i >= 0; i--){\\n            if(nums[i] == target){\\n                rightIndex = i;\\n                break;\\n            }\\n        }\\n        return Math.min(Math.abs(Leftindex - start), Math.abs(rightIndex - start));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606023,
                "title": "c-tc-o-n-easy-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int mini=INT_MAX;\\n       \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==target){\\n                mini=min(mini,abs(i-start));\\n               \\n            }\\n        }\\n        return mini;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int mini=INT_MAX;\\n       \\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]==target){\\n                mini=min(mini,abs(i-start));\\n               \\n            }\\n        }\\n        return mini;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600839,
                "title": "simple-approach-easy-to-understand-o-n",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int Ans=INT_MAX;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                Ans=min(Ans,abs(i-start));\\n            }\\n        }\\n    return Ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int Ans=INT_MAX;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n                Ans=min(Ans,abs(i-start));\\n            }\\n        }\\n    return Ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596582,
                "title": "easiest-c-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int mini=INT_MAX;\\n       for(int i=0;i<=start;i++)\\n       {\\n           if(nums[i]==target)\\n              mini=min(mini,abs(i-start));\\n       } \\n       for(int i=start+1;i<nums.size();i++)\\n       {\\n           if(nums[i]==target)\\n              mini=min(mini,abs(i-start));\\n       } \\n       return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int mini=INT_MAX;\\n       for(int i=0;i<=start;i++)\\n       {\\n           if(nums[i]==target)\\n              mini=min(mini,abs(i-start));\\n       } \\n       for(int i=start+1;i<nums.size();i++)\\n       {\\n           if(nums[i]==target)\\n              mini=min(mini,abs(i-start));\\n       } \\n       return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591976,
                "title": "python-simple-approach",
                "content": "# Code\\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        idx = []\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                idx.append(i)\\n        return min(abs(i - start) for i in idx)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        idx = []\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                idx.append(i)\\n        return min(abs(i - start) for i in idx)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565334,
                "title": "java-easy",
                "content": "# Intuition\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int toReturn = 0;\\n        int currentMin = 1000;\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] == target) {\\n                toReturn = Math.abs(i - start);\\n                System.out.println(toReturn);\\n                if(toReturn < currentMin) currentMin = toReturn;\\n            }\\n        }\\n        return currentMin;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int toReturn = 0;\\n        int currentMin = 1000;\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] == target) {\\n                toReturn = Math.abs(i - start);\\n                System.out.println(toReturn);\\n                if(toReturn < currentMin) currentMin = toReturn;\\n            }\\n        }\\n        return currentMin;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3533784,
                "title": "minimum-distance-solution",
                "content": "# Intuition\\nThis is an very simple question that involves iterating through the given list.\\n\\n# Approach\\nHere is a brief pseudocode:\\n<ul>\\n<li>Iterate over the list one element at a time</li>\\n<li>If the element is equal to target, subtract it and store the result.</li>\\n<li>Check the result with the previous results and see if the new result is smaller.</li>\\n<li>update the result and return it</li>\\n</ul>\\n\\n# Complexity\\n- Time complexity:\\n  This is a very easy question with a very basic approach. However, it took me 30 minutes because i couldn\\'t understand the question. Then after debugging i finally understood the question. So on average this should take about 1 minute to do, maybe less\\n\\n- Space complexity:\\n  I tried making the program use as much less memory as possible but it still takes a lot.\\n\\n# Code\\n```\\n#include<limits>\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int> &a, int target, int start)\\n    {\\n        int i = 0;\\n        int prev = std::numeric_limits<int>::max();\\n        for (int x : a)\\n        {\\n            if (x == target)\\n            {\\n                int  p = std::abs(i -start);\\n                if (p < prev)\\n                {\\n                    prev = p;\\n                }\\n            }\\n            i++;\\n        }\\n        if (prev == std::numeric_limits<int>::max())\\n        {\\n            // nothing found\\n            return 0;\\n        }\\n        return prev;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\n#include<limits>\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int> &a, int target, int start)\\n    {\\n        int i = 0;\\n        int prev = std::numeric_limits<int>::max();\\n        for (int x : a)\\n        {\\n            if (x == target)\\n            {\\n                int  p = std::abs(i -start);\\n                if (p < prev)\\n                {\\n                    prev = p;\\n                }\\n            }\\n            i++;\\n        }\\n        if (prev == std::numeric_limits<int>::max())\\n        {\\n            // nothing found\\n            return 0;\\n        }\\n        return prev;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3520788,
                "title": "go-runtime-0-ms-memory-3-2-mb",
                "content": "# Code\\n```\\nfunc getMinDistance(nums []int, target int, start int) int {\\n\\tmin := math.MaxInt\\n\\tfor i, v := range nums {\\n\\t\\tif v == target {\\n\\t\\t\\tdiff := abs(i - start)\\n\\t\\t\\tif min > diff {\\n\\t\\t\\t\\tmin = diff\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn min\\n}\\n\\n// HELPERS ---------------------------------------\\nfunc abs(val int) int {\\n\\tif val < 0 {\\n\\t\\treturn -val\\n\\t}\\n\\treturn val\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc getMinDistance(nums []int, target int, start int) int {\\n\\tmin := math.MaxInt\\n\\tfor i, v := range nums {\\n\\t\\tif v == target {\\n\\t\\t\\tdiff := abs(i - start)\\n\\t\\t\\tif min > diff {\\n\\t\\t\\t\\tmin = diff\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn min\\n}\\n\\n// HELPERS ---------------------------------------\\nfunc abs(val int) int {\\n\\tif val < 0 {\\n\\t\\treturn -val\\n\\t}\\n\\treturn val\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3516788,
                "title": "minimum-distance-java-solution-0ms-beats-100-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have given the target element and the element from which we have to start. \\nWe iterate through the array , check where our target value lies and calculate the minimum distance.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Declared two variables max and min which are initially initialised as the Integer.MAX_VALUE;\\n- Then we iterate through the array,  and whenever we encounter our target element we store it\\'s index to the max variable.\\n- Now to calculate the minimum distance between the index, we use the Math.min() function where the parameters are the min value itself alongwith the positive difference between the max variable value and the start value.\\n- We then return the min value.\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int max = Integer.MAX_VALUE; \\n        int min = Integer.MAX_VALUE;\\n\\n        for(int i = 0 ; i < nums.length ; i++){\\n            if(nums[i] == target){\\n                max = i;\\n\\n                min = Math.min(min , Math.abs(max - start));\\n            }\\n        }   \\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int max = Integer.MAX_VALUE; \\n        int min = Integer.MAX_VALUE;\\n\\n        for(int i = 0 ; i < nums.length ; i++){\\n            if(nums[i] == target){\\n                max = i;\\n\\n                min = Math.min(min , Math.abs(max - start));\\n            }\\n        }   \\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506789,
                "title": "straightforward-python-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        res = float(\"inf\")\\n        for i, n in enumerate(nums):\\n            if n == target:\\n                res = min(res, abs(i-start))\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        res = float(\"inf\")\\n        for i, n in enumerate(nums):\\n            if n == target:\\n                res = min(res, abs(i-start))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502241,
                "title": "100-easy-solution-using-java",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        \\n        int m=Integer.MAX_VALUE;\\n       for(int i=0;i<nums.length;i++){\\n           if(nums[i]==target){\\n             m=Math.min(m,Math.abs(i-start));  \\n           }\\n          \\n       } \\n       return m;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        \\n        int m=Integer.MAX_VALUE;\\n       for(int i=0;i<nums.length;i++){\\n           if(nums[i]==target){\\n             m=Math.min(m,Math.abs(i-start));  \\n           }\\n          \\n       } \\n       return m;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497874,
                "title": "getmindistance",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n//    let index=0;\\n   let indices = [];\\n    if(nums.length >=1 && nums.length <= 1000 && start >=0 && start< nums.length && nums.includes(target)){\\n        nums.filter(function(ele, index) {\\n if(ele == target){\\n   indices.push(Math.abs(index-start))\\n }\\n});\\nreturn Math.min(...indices)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n//    let index=0;\\n   let indices = [];\\n    if(nums.length >=1 && nums.length <= 1000 && start >=0 && start< nums.length && nums.includes(target)){\\n        nums.filter(function(ele, index) {\\n if(ele == target){\\n   indices.push(Math.abs(index-start))\\n }\\n});\\nreturn Math.min(...indices)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3496479,
                "title": "easy-java-solution",
                "content": "`Please upvote if it helps you. Happy Coding!`\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]==target){\\n                min = Math.min(min, Math.abs(i-start));\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]==target){\\n                min = Math.min(min, Math.abs(i-start));\\n            }\\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494169,
                "title": "0ms-100-beats-clean-java-solution-beconsistent",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n              if(Math.abs(i-start)<min)\\n              min=Math.abs(i-start);\\n            }\\n        }\\n   return min;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(nums[i]==target)\\n            {\\n              if(Math.abs(i-start)<min)\\n              min=Math.abs(i-start);\\n            }\\n        }\\n   return min;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484215,
                "title": "minimum-distance-to-the-target-element",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        ans = math.inf\\n        for i, num in enumerate(nums):\\n            if num == target:\\n                ans = min(ans, abs(i - start))\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        ans = math.inf\\n        for i, num in enumerate(nums):\\n            if num == target:\\n                ans = min(ans, abs(i - start))\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483739,
                "title": "minimum-distance-to-the-target-element-easy-solution-with-few-lines-of-code",
                "content": "class Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int smallval= INT_MAX;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i]==target && abs(i-start)<smallval)\\n            {\\n               smallval = abs(i-start);\\n            }\\n              \\n\\n        }\\n        return smallval;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int smallval= INT_MAX;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(nums[i]==target && abs(i-start)<smallval)\\n            {\\n               smallval = abs(i-start);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3478521,
                "title": "with-math-library-in-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n  let array = [];\\n    for ( let i = 0; i < nums.length; i++){\\n      if(nums[i] === target){\\n       array.push(Math.abs(i - start));\\n      }\\n    }\\n    return Math.min(...array)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n  let array = [];\\n    for ( let i = 0; i < nums.length; i++){\\n      if(nums[i] === target){\\n       array.push(Math.abs(i - start));\\n      }\\n    }\\n    return Math.min(...array)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3472603,
                "title": "java-expand-from-start-to-both-side-of-array-easy-to-understand-t-0ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int n = nums.length;\\n        int i = start;\\n        int j = start;\\n        int minDist = Integer.MAX_VALUE;\\n        while(i >= 0){\\n            if(nums[i] == target) {\\n                minDist = Math.min(minDist, Math.abs(i - start));\\n                break;\\n            }\\n            i--;\\n        }\\n\\n        while(j < n){\\n            if(nums[j] == target) {\\n                minDist = Math.min(minDist, Math.abs(j - start));\\n                break;\\n            }\\n            j++;\\n        }\\n        return minDist;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int n = nums.length;\\n        int i = start;\\n        int j = start;\\n        int minDist = Integer.MAX_VALUE;\\n        while(i >= 0){\\n            if(nums[i] == target) {\\n                minDist = Math.min(minDist, Math.abs(i - start));\\n                break;\\n            }\\n            i--;\\n        }\\n\\n        while(j < n){\\n            if(nums[j] == target) {\\n                minDist = Math.min(minDist, Math.abs(j - start));\\n                break;\\n            }\\n            j++;\\n        }\\n        return minDist;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3470428,
                "title": "python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        mini=float(\"inf\")\\n        for i in range(len(nums)):\\n            if nums[i]==target:\\n                mini=min(mini,abs(i-start))\\n        return mini\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        mini=float(\"inf\")\\n        for i in range(len(nums)):\\n            if nums[i]==target:\\n                mini=min(mini,abs(i-start))\\n        return mini\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460686,
                "title": "100-java-solutions",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int ans = Integer.MAX_VALUE;\\n        boolean alreadyOccurred = false;\\n        for(int i=0; i<nums.length; i++ ){\\n            if(nums[i] == target){\\n                ans = alreadyOccurred ? Math.min(ans,Math.abs(i-start)) : Math.abs(i-start);\\n                alreadyOccurred = true;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int ans = Integer.MAX_VALUE;\\n        boolean alreadyOccurred = false;\\n        for(int i=0; i<nums.length; i++ ){\\n            if(nums[i] == target){\\n                ans = alreadyOccurred ? Math.min(ans,Math.abs(i-start)) : Math.abs(i-start);\\n                alreadyOccurred = true;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3457502,
                "title": "minimum-distance-javascript-o-n-51-ms",
                "content": "![image.png](https://assets.leetcode.com/users/images/1a408052-67c1-4cfb-b5f7-87ac9f96447f_1682515561.8084388.png)\\n\\n```\\nvar getMinDistance = function(nums, target, start) {    \\n    right = (10 ** 4), left  = - (10 ** 4)\\n\\n    for (let i = start; i < nums.length; i++) {\\n        if (nums[i] == target) {\\n            right = i\\n            break\\n        }\\n    }\\n\\n    for (let i = start; i >= 0; i--) {\\n        if (nums[i] == target) {\\n            left = i\\n            break\\n        }\\n    }\\n\\n    return Math.min(start - left, right - start)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar getMinDistance = function(nums, target, start) {    \\n    right = (10 ** 4), left  = - (10 ** 4)\\n\\n    for (let i = start; i < nums.length; i++) {\\n        if (nums[i] == target) {\\n            right = i\\n            break\\n        }\\n    }\\n\\n    for (let i = start; i >= 0; i--) {\\n        if (nums[i] == target) {\\n            left = i\\n            break\\n        }\\n    }\\n\\n    return Math.min(start - left, right - start)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3456482,
                "title": "python-basic-approach",
                "content": "# Code\\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        a = []\\n        for i in range(len(nums)):\\n            if nums[i]==target:\\n                a.append(abs(i-start))\\n        return min(a)        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        a = []\\n        for i in range(len(nums)):\\n            if nums[i]==target:\\n                a.append(abs(i-start))\\n        return min(a)        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448304,
                "title": "rust-functional-style-iterators",
                "content": "# Intuition\\nBasic implementation of the problem. Technically there are ways that you could reduce the number of iterations necessary by starting from the middle, but in practice iteration is just faster.\\n\\n# Approach\\niter(), well, iterates over the vector. Note that this is read-only so it\\'s actually iterating over &i32 instead of i32.\\n\\nenumerate() turns an iterator of &i32 into an iterator of (usize, &i32) where the first term is the zero-indexed position. **Note**: we have to enumerate before filtering so our index is relative to its original position.\\n\\nfilter() removes any irrelevant elements from the iterator.\\n\\nmap() throws out the &i32 term (we\\'re done with it after the filter), and converts from i: usize into the absolute value distance measure as an i32.\\n\\nAfter the map, we now have an iterator of distances to \"start\". We use min() to collapse the iterator into Option<i32>; note that it is an option because Rust thinks the iterator might be empty (i.e. no elements match target).\\n\\nBut we\\'re told this is impossible, so we can just unwrap() and call it a day.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n), we do one pass over nums.\\n\\n- Space complexity:\\nO(1), the iterator struct takes up a finite amount of space and there are no heap allocations.\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn get_min_distance(nums: Vec<i32>, target: i32, start: i32) -> i32 {\\n        nums\\n        .iter()\\n        .enumerate()\\n        .filter(|(_, &num)| num == target)\\n        .map(|(i, _)| ((i as i32) - start).abs())\\n        .min()\\n        .unwrap()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn get_min_distance(nums: Vec<i32>, target: i32, start: i32) -> i32 {\\n        nums\\n        .iter()\\n        .enumerate()\\n        .filter(|(_, &num)| num == target)\\n        .map(|(i, _)| ((i as i32) - start).abs())\\n        .min()\\n        .unwrap()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3436903,
                "title": "java-simple-solution-bruteforce-find-minimum",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int minAbsolute = Integer.MAX_VALUE;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == target) {\\n                minAbsolute = Math.min(minAbsolute, Math.abs(i - start));\\n            }\\n        }\\n\\n        return minAbsolute;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int minAbsolute = Integer.MAX_VALUE;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == target) {\\n                minAbsolute = Math.min(minAbsolute, Math.abs(i - start));\\n            }\\n        }\\n\\n        return minAbsolute;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3412410,
                "title": "python-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n) where n is the length of nums\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) where n is the length of nums\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        res = []\\n\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                res.append(abs(i -start))\\n\\n        return min(res)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        res = []\\n\\n        for i in range(len(nums)):\\n            if nums[i] == target:\\n                res.append(abs(i -start))\\n\\n        return min(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3402810,
                "title": "using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int ans = Integer.MAX_VALUE;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]==target){\\n                ans = Math.min(ans, Math.abs(i-start));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int ans = Integer.MAX_VALUE;\\n        for(int i=0; i<nums.length; i++){\\n            if(nums[i]==target){\\n                ans = Math.min(ans, Math.abs(i-start));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396909,
                "title": "3-line-easy-java-code-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int res = Integer.MAX_VALUE;\\n        for(int i=0; i<nums.length; i++)\\n            if(nums[i] == target)\\n               res = Math.min(res,  Math.abs(i - start));\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n        int res = Integer.MAX_VALUE;\\n        for(int i=0; i<nums.length; i++)\\n            if(nums[i] == target)\\n               res = Math.min(res,  Math.abs(i - start));\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382703,
                "title": "c-bfs-from-start",
                "content": "No error checking since constraints say target must exist in vector.\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int l = start, r = start;\\n        while (true){\\n            if (l > -1 && nums[l] == target) return start - l;\\n            if (r < nums.size() && nums[r] == target) return r - start;\\n            --l, ++r;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int l = start, r = start;\\n        while (true){\\n            if (l > -1 && nums[l] == target) return start - l;\\n            if (r < nums.size() && nums[r] == target) return r - start;\\n            --l, ++r;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3368450,
                "title": "solution-to-absolute-value-question-with-proper-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt first It was difficult to grasp what the question was trying to ask but i slowly and steadily understood the problem.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMy approach to solving this problem is quite different compared to other solutions. I have initiated with an array in a for loop which stores the absolute values of \"i-start\" ONLY if the current value of vector is equal to the target we need (since there can be multiple values which match the target value but we want one which is CLOSEST to the index of \"start\" to minimize the absolute value). The loop runs and constantly stores the absolute values whenever it encounters one. Next, I have initiated another loop to check for the MINIMUM absolute value out of all absolute values to get a minimized solution.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int len=nums.size();\\n\\n        int x=0;\\n        int arr[len];\\n        for(int i=0; i<len; i++){\\n            if(nums[i]==target){\\n                arr[x]=abs(i-start);\\n                x++;\\n            }\\n        }\\n        int min=arr[0];\\n        for(int i=1; i<x; i++){\\n            if(arr[0]>arr[i]){\\n                min=arr[i];\\n            }\\n        }\\n        return min;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinDistance(vector<int>& nums, int target, int start) {\\n        int len=nums.size();\\n\\n        int x=0;\\n        int arr[len];\\n        for(int i=0; i<len; i++){\\n            if(nums[i]==target){\\n                arr[x]=abs(i-start);\\n                x++;\\n            }\\n        }\\n        int min=arr[0];\\n        for(int i=1; i<x; i++){\\n            if(arr[0]>arr[i]){\\n                min=arr[i];\\n            }\\n        }\\n        return min;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3358166,
                "title": "easy-5-lines-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n    let arr = [];\\n    for(let i = 0; i < nums.length; i++) {\\n        if(nums[i] == target) {\\n            arr.push(Math.abs(i - start));\\n        }\\n    }\\n    return Math.min(...arr);\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} start\\n * @return {number}\\n */\\nvar getMinDistance = function(nums, target, start) {\\n    let arr = [];\\n    for(let i = 0; i < nums.length; i++) {\\n        if(nums[i] == target) {\\n            arr.push(Math.abs(i - start));\\n        }\\n    }\\n    return Math.min(...arr);\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3354553,
                "title": "java-easiest-solution",
                "content": "class Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n\\n        int ans = Integer.MAX_VALUE;\\n        \\n        for (int i = 0 ; i < nums.length ; i++){\\n\\n            if (nums[i] == target){\\n\\n                ans = Math.min(ans, Math.abs(i - start));\\n\\n            }\\n\\n        }\\n\\n        return ans;\\n\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int getMinDistance(int[] nums, int target, int start) {\\n\\n        int ans = Integer.MAX_VALUE;\\n        \\n        for (int i = 0 ; i < nums.length ; i++){\\n\\n            if (nums[i] == target){\\n\\n                ans = Math.min(ans, Math.abs(i - start));\\n\\n            }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1850808,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "Easy  problem  using Greedy Method"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nNo special algorithm. Just loop through.\\n\\n# <span style=\\'color:green\\'>Answer</span>\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        return min(abs(i - start) for i in range(len(nums)) if nums[i] == target)"
                    }
                ]
            },
            {
                "id": 1799174,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "Easy  problem  using Greedy Method"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nNo special algorithm. Just loop through.\\n\\n# <span style=\\'color:green\\'>Answer</span>\\n    def getMinDistance(self, nums: List[int], target: int, start: int) -> int:\\n        return min(abs(i - start) for i in range(len(nums)) if nums[i] == target)"
                    }
                ]
            }
        ]
    },
    {
        "title": "Splitting a String Into Descending Consecutive Values",
        "question_content": "<p>You are given a string <code>s</code> that consists of only digits.</p>\n\n<p>Check if we can split <code>s</code> into <strong>two or more non-empty substrings</strong> such that the <strong>numerical values</strong> of the substrings are in <strong>descending order</strong> and the <strong>difference</strong> between numerical values of every two <strong>adjacent</strong> <strong>substrings</strong> is equal to <code>1</code>.</p>\n\n<ul>\n\t<li>For example, the string <code>s = &quot;0090089&quot;</code> can be split into <code>[&quot;0090&quot;, &quot;089&quot;]</code> with numerical values <code>[90,89]</code>. The values are in descending order and adjacent values differ by <code>1</code>, so this way is valid.</li>\n\t<li>Another example, the string <code>s = &quot;001&quot;</code> can be split into <code>[&quot;0&quot;, &quot;01&quot;]</code>, <code>[&quot;00&quot;, &quot;1&quot;]</code>, or <code>[&quot;0&quot;, &quot;0&quot;, &quot;1&quot;]</code>. However all the ways are invalid because they have numerical values <code>[0,1]</code>, <code>[0,1]</code>, and <code>[0,0,1]</code> respectively, all of which are not in descending order.</li>\n</ul>\n\n<p>Return <code>true</code> <em>if it is possible to split</em> <code>s</code> <em>as described above</em><em>, or </em><code>false</code><em> otherwise.</em></p>\n\n<p>A <strong>substring</strong> is a contiguous sequence of characters in a string.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;1234&quot;\n<strong>Output:</strong> false\n<strong>Explanation:</strong> There is no valid way to split s.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;050043&quot;\n<strong>Output:</strong> true\n<strong>Explanation:</strong> s can be split into [&quot;05&quot;, &quot;004&quot;, &quot;3&quot;] with numerical values [5,4,3].\nThe values are in descending order with adjacent values differing by 1.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;9080701&quot;\n<strong>Output:</strong> false\n<strong>Explanation:</strong> There is no valid way to split s.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 20</code></li>\n\t<li><code>s</code> only consists of digits.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1186814,
                "title": "java-backtracking",
                "content": "Here, we find the first number/prefixes(where previous is null) and then search in remaining string if numbers are in descending order.\\n```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        return isRemainingValid(s, null);\\n    }\\n    private boolean isRemainingValid(String s, Long previous) {\\n        long current =0;\\n        for(int i=0;i<s.length();i++) {\\n            current = current * 10 + s.charAt(i)-\\'0\\';\\n            if(current >= 10000000000L) return false;   // Avoid overflow\\n            if(previous == null) {\\n                if (isRemainingValid(s.substring(i+1), current)) \\n                    return true;\\n            } else if(current == previous - 1 && (i==s.length()-1 || isRemainingValid(s.substring(i+1), current)))\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        return isRemainingValid(s, null);\\n    }\\n    private boolean isRemainingValid(String s, Long previous) {\\n        long current =0;\\n        for(int i=0;i<s.length();i++) {\\n            current = current * 10 + s.charAt(i)-\\'0\\';\\n            if(current >= 10000000000L) return false;   // Avoid overflow\\n            if(previous == null) {\\n                if (isRemainingValid(s.substring(i+1), current)) \\n                    return true;\\n            } else if(current == previous - 1 && (i==s.length()-1 || isRemainingValid(s.substring(i+1), current)))\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186795,
                "title": "c-backtracking-solution-o-n-2-and-time-complexity-analytics",
                "content": "\\n#### Time complexity\\nO(N ^ 2). even though we use back-tracking here, it is obvious that the upper-bound complexity of this solution is N^2, in the for loop `for(int i = idx; i < s.size(); i++) `, there is only one chance to go into next `dfs` function, so it is linear complexity O(N) for every iteration. so it is O(N ^ 2), if you don\\'t believe this, you can add a counter in the for loop and see what is the value of the counter, it is smaller than(close to) N^2.\\n\\n```\\nlong long MX = 999999999999;\\nclass Solution {\\npublic:\\n    bool dfs(string &s, long long prev, int idx, int cnt) {\\n        if(idx == s.size() ) return cnt > 1;\\n        long long num = 0;\\n        for(int i = idx; i < s.size(); i++) {\\n            num = num *  10l + s[i] - \\'0\\';\\n            if(num > MX) break;\\n            if(num == prev - 1 || prev == -1) {\\n                if(dfs(s, num, i + 1, cnt + 1)) return true;\\n            }\\n            if(num > prev && prev != -1) break;\\n        }\\n        return false;\\n    }\\n    \\n    bool splitString(string s) {\\n        if(s.size() <= 1) return false;\\n        return dfs(s, -1, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlong long MX = 999999999999;\\nclass Solution {\\npublic:\\n    bool dfs(string &s, long long prev, int idx, int cnt) {\\n        if(idx == s.size() ) return cnt > 1;\\n        long long num = 0;\\n        for(int i = idx; i < s.size(); i++) {\\n            num = num *  10l + s[i] - \\'0\\';\\n            if(num > MX) break;\\n            if(num == prev - 1 || prev == -1) {\\n                if(dfs(s, num, i + 1, cnt + 1)) return true;\\n            }\\n            if(num > prev && prev != -1) break;\\n        }\\n        return false;\\n    }\\n    \\n    bool splitString(string s) {\\n        if(s.size() <= 1) return false;\\n        return dfs(s, -1, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186896,
                "title": "java-brute-force-recursion-step-by-step-with-detailed-explanation",
                "content": "**Please Upvote ! if you found useful, so it helps others to find it. Thank you, I tried to explain in as depth as possible. Enjoy!**\\n\\n**Approach 1: Brute Force**\\n\\nSo my idea was to hop **i** digits at the time, if we reach to the end that means we found our answer. \\n**What do i mean by hop?**\\nEx: \"000908760\" \\n\\ti = 1 -> \"0009\" then \"08\" then \"07\" then \"6\" then \"0\" (It will find single digits) i.e 9..8..6..0\\n\\ti = 2 -> \"00090\" then \"87\" then \"60\" (it will find double digits) i.e 90..87..60\\n\\tSo if we reach till End that means we got our answer and return true\\n\\t\\n**Tricky part of this problem**\\n*   **Zeros:** I considered the number after intial 0\\'s i.e 00007 -> 7\\n*  **Gap of 1:** so to check that convert the number to long and subtract with prev itteration and diff should be 1\\n* \\t**Edge case** 001: We check if prev is Long.max value that means this is the first digit and should not return true even we reach till end\\n* \\t **Edge Case** 1009897: here if our i = 2 10..98..97 if i=3 then i=100..989..7 so using variable \"width\" to check if number is 10..100..10000 or power of 10 next number we search is i width shorter so if we find 100 we are nowlooking for 2 digit number instead of 3\\n\\nUsing long because there\\'s a test case which int cannot parse\\nHope it makes sense comment if you have any question.\\n```\\nclass Solution {\\n    public boolean splitString(String s) {\\n\\t// we are only making s.length()/2 hops becase we only want min 2 parts of string\\n        for(int i = 1; i <= (s.length() / 2)+1; i++){\\n            int index = 0, width = i; \\n            Long prev = Long.MAX_VALUE;\\n            while(index < s.length()){ \\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// checking if 100 then next time find 2 digit number so width-1\\n                long ten = (long)Math.pow ( 10, i-1); \\n                if(i > 1 && prev == ten) width--;\\n\\t\\t\\t\\t\\n                String next = getDigit(index, s, width);\\n                long val = Long.parseLong(next);\\n\\t\\t\\t\\t\\n                if(index != 0 && prev - val != 1) break; // \\n                \\n                index += next.length();\\n\\t\\t\\t\\t// If it is not the first values && we hopped till end then return true;\\n                if(prev != Long.MAX_VALUE && index >= s.length()) return true;\\n                prev = val;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n\\t// This function simply returns the next len digit number starting from i index of string\\n\\t// getDigit(2,\"090087\",1) -> 8\\n    public String getDigit(int i, String s, int len){\\n        int digits = 0;\\n        int j = i;\\n        while(j < s.length() && s.charAt(j) == \\'0\\') j++;\\n        return s.substring(i, Math.min(j+len, s.length()));\\n    }\\n}\\n```\\n\\n\\n**Approach 2 DFS**\\n\\nSimply we start and keep finding the next substring(long) such that curr - next = 1 and the end if we reach to the last index we check if we found atleast 2 long\\nEx: \"9998\" -> 9..99..98\\n```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        if (s == null || s.length()<=1) return false;\\n        return backtrack(0, s, new ArrayList<Long>());\\n    }\\n    \\n    public boolean backtrack(int pos, String s, ArrayList<Long> list) {\\n\\t\\t// Base case where we reach till end of string and we have atleast 2 parts\\n        if (pos >= s.length()) return list.size() >= 2; \\n\\n        long num = 0;\\n        for (int i=pos; i<s.length(); i++) {\\n            num = num*10 + (s.charAt(i)-\\'0\\'); // \"070\" i = 1 -> 0.. i = 2 -> 7.. i =3 -> 70 \\n            if (list.size()==0 || list.get(list.size()-1) - num == 1) { // if it is first digit or difference is +1 valid\\n                \\n                list.add(num);  // add the number and continue to next index\\n                if (backtrack(i+1, s, list)) return true;\\n                list.remove(list.size()-1); // backtrack, done with that itteration coun\\'t find it\\n                \\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n\\t// we are only making s.length()/2 hops becase we only want min 2 parts of string\\n        for(int i = 1; i <= (s.length() / 2)+1; i++){\\n            int index = 0, width = i; \\n            Long prev = Long.MAX_VALUE;\\n            while(index < s.length()){ \\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// checking if 100 then next time find 2 digit number so width-1\\n                long ten = (long)Math.pow ( 10, i-1); \\n                if(i > 1 && prev == ten) width--;\\n\\t\\t\\t\\t\\n                String next = getDigit(index, s, width);\\n                long val = Long.parseLong(next);\\n\\t\\t\\t\\t\\n                if(index != 0 && prev - val != 1) break; // \\n                \\n                index += next.length();\\n\\t\\t\\t\\t// If it is not the first values && we hopped till end then return true;\\n                if(prev != Long.MAX_VALUE && index >= s.length()) return true;\\n                prev = val;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n\\t// This function simply returns the next len digit number starting from i index of string\\n\\t// getDigit(2,\"090087\",1) -> 8\\n    public String getDigit(int i, String s, int len){\\n        int digits = 0;\\n        int j = i;\\n        while(j < s.length() && s.charAt(j) == \\'0\\') j++;\\n        return s.substring(i, Math.min(j+len, s.length()));\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        if (s == null || s.length()<=1) return false;\\n        return backtrack(0, s, new ArrayList<Long>());\\n    }\\n    \\n    public boolean backtrack(int pos, String s, ArrayList<Long> list) {\\n\\t\\t// Base case where we reach till end of string and we have atleast 2 parts\\n        if (pos >= s.length()) return list.size() >= 2; \\n\\n        long num = 0;\\n        for (int i=pos; i<s.length(); i++) {\\n            num = num*10 + (s.charAt(i)-\\'0\\'); // \"070\" i = 1 -> 0.. i = 2 -> 7.. i =3 -> 70 \\n            if (list.size()==0 || list.get(list.size()-1) - num == 1) { // if it is first digit or difference is +1 valid\\n                \\n                list.add(num);  // add the number and continue to next index\\n                if (backtrack(i+1, s, list)) return true;\\n                list.remove(list.size()-1); // backtrack, done with that itteration coun\\'t find it\\n                \\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186963,
                "title": "c-check-all-lengths",
                "content": "> Update: added a shorter solution that avoids copying strings. The original solution (as embarrassing as it is) is below just for the reference.\\n \\nThis problem was hard to implement for me. I got hidden WA, and spent a while chasing it down. Turns out, I had a problem with the \"1000999\" test case when the first number is longer than the half of the string.\\n \\n#### Simplified Solution\\nWell this is way simpler than the original solution, but I could not come up with it during the contest. Still a long road ahead to practice.\\n \\nFew important points:\\n- The very first loop does not go all the way to the end - to make sure we have at least one split.\\n- Limit `num` to avoid overflow.\\n \\n```cpp\\nbool splitString(string &s, int i = 0, long prev = 0) {\\n    long num = 0;\\n    for (int j = i; num < 1e+10 && j < s.size() - (i == 0 ? 1 : 0); ++j) {\\n        num = num * 10 + (s[j] - \\'0\\');\\n        if ((i == 0 || prev - 1 == num) && splitString(s, j + 1, num))\\n            return true;\\n    }\\n    return i == s.size();\\n}\\n```\\n\\n#### Original Solution\\nAnyhow, the idea is to iterate through possible number lengths (from `1` to `nums.size() / 2 + 1`), get the first number, and recursively check if we can find decreasing numbers in the rest of the string.\\n\\nTo make it simple, we first trim leading zeros from our string. We create bunch of copies by using `substr()`, but it\\'s tolerable as our string is limited to 20 characters.\\n\\n```cpp\\nbool check(string s, long num) {\\n    if (s.empty())      \\n        return true;    \\n    int i = 0;\\n    while (i + 1 < s.size() && s[i] == \\'0\\')\\n        ++i;\\n    s = s.substr(i);\\n    auto num_s = to_string(num);\\n    if (s.compare(0, num_s.size(), num_s) == 0)\\n        return check(s.substr(num_s.size()), num - 1);\\n    return false;\\n} \\nbool splitString(string s) {\\n    auto pos = s.find_first_not_of(\\'0\\');\\n    if (pos != string::npos)\\n        s = s.substr(pos);\\n    for (int len = 1; len <= (s.size() + 1) / 2; ++len) {\\n        long num_start = stol(s.substr(0, len));\\n        if (s.size() > 1 && check(s.substr(len), num_start - 1))\\n            return true;\\n    }\\n    return false;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nbool splitString(string &s, int i = 0, long prev = 0) {\\n    long num = 0;\\n    for (int j = i; num < 1e+10 && j < s.size() - (i == 0 ? 1 : 0); ++j) {\\n        num = num * 10 + (s[j] - \\'0\\');\\n        if ((i == 0 || prev - 1 == num) && splitString(s, j + 1, num))\\n            return true;\\n    }\\n    return i == s.size();\\n}\\n```\n```cpp\\nbool check(string s, long num) {\\n    if (s.empty())      \\n        return true;    \\n    int i = 0;\\n    while (i + 1 < s.size() && s[i] == \\'0\\')\\n        ++i;\\n    s = s.substr(i);\\n    auto num_s = to_string(num);\\n    if (s.compare(0, num_s.size(), num_s) == 0)\\n        return check(s.substr(num_s.size()), num - 1);\\n    return false;\\n} \\nbool splitString(string s) {\\n    auto pos = s.find_first_not_of(\\'0\\');\\n    if (pos != string::npos)\\n        s = s.substr(pos);\\n    for (int len = 1; len <= (s.size() + 1) / 2; ++len) {\\n        long num_start = stol(s.substr(0, len));\\n        if (s.size() > 1 && check(s.substr(len), num_start - 1))\\n            return true;\\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1186813,
                "title": "c-python-recursive-backtracking-solution-explained-w-comments",
                "content": "\\u2714\\uFE0F ***Solution***\\n\\nWe need to iterate over all possible substrings for each splits. \\n\\nIf a split gives value equal to **`previous split - 1`**, then continue trying to split for remaining index. Otherwise, try increasing the length of split and check again.\\n\\nIf you reach the last index and there are more than 1 splits, return true. Otherwise return false.\\n\\n**C++**\\n\\nFor C++, you need to handle overflows . For this purpose, I have use *`try...catch`* block in the below solution -\\n\\n```\\nbool splitString(string s) {\\n\\treturn solve(s, 0, 1, -1);\\n}\\nbool solve(string& s, int i, int len, long prev, int splits = 0) {\\n\\t// If we reach the end of string and have made splits >= 2, return true\\n\\tif(i == size(s) && splits >= 2) return true;\\n\\twhile(i + len <= size(s)) {\\n\\t\\ttry{\\n\\t\\t\\tauto cur = stoll(s.substr(i, len++));         // convert s[i] to s[i + len] into number\\n\\t\\t\\tif(prev != -1 && cur != prev - 1) continue;   // and check if it is equal to prev - 1 (ignore for first call)\\n\\t\\t\\t// if the above condition satisfies, just  recurse for the remaining indices\\n\\t\\t\\tif(solve(s, i + len - 1, 1, cur, splits + 1)) return true;    \\n\\t\\t} catch(...) { continue; } // handling overflows\\n\\t}\\n\\treturn false;        \\n}\\n```\\n\\n---\\n\\n**Python**\\n```\\ndef splitString(self, s: str) -> bool:\\n\\tdef solve(s, i, length, prev, splits):\\n\\t\\t# At last, if you reach the end and have made splits >= 2, we are sure that a split as per requirement is possible\\n\\t\\tif i == len(s) and splits >= 2: \\n\\t\\t\\treturn True\\n\\t\\twhile i + length <= len(s):\\n\\t\\t\\tcur = int(s[i:i+length])   # convert s[i:i + length] to integer\\n\\t\\t\\tlength += 1\\n\\t\\t\\t# if above converted integer is not equal to prev - 1, try increasing the length\\n\\t\\t\\tif prev != -1 and cur != prev - 1: continue \\n\\t\\t\\t# if it is equal to prev - 1, recurse and make splits for remaining index\\n\\t\\t\\tif solve(s, i + length - 1, 1, cur, splits + 1):\\n\\t\\t\\t\\treturn True\\n\\t\\treturn False\\n\\treturn solve(s, 0, 1, -1, 0)\\n```\\n\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nbool splitString(string s) {\\n\\treturn solve(s, 0, 1, -1);\\n}\\nbool solve(string& s, int i, int len, long prev, int splits = 0) {\\n\\t// If we reach the end of string and have made splits >= 2, return true\\n\\tif(i == size(s) && splits >= 2) return true;\\n\\twhile(i + len <= size(s)) {\\n\\t\\ttry{\\n\\t\\t\\tauto cur = stoll(s.substr(i, len++));         // convert s[i] to s[i + len] into number\\n\\t\\t\\tif(prev != -1 && cur != prev - 1) continue;   // and check if it is equal to prev - 1 (ignore for first call)\\n\\t\\t\\t// if the above condition satisfies, just  recurse for the remaining indices\\n\\t\\t\\tif(solve(s, i + len - 1, 1, cur, splits + 1)) return true;    \\n\\t\\t} catch(...) { continue; } // handling overflows\\n\\t}\\n\\treturn false;        \\n}\\n```\n```\\ndef splitString(self, s: str) -> bool:\\n\\tdef solve(s, i, length, prev, splits):\\n\\t\\t# At last, if you reach the end and have made splits >= 2, we are sure that a split as per requirement is possible\\n\\t\\tif i == len(s) and splits >= 2: \\n\\t\\t\\treturn True\\n\\t\\twhile i + length <= len(s):\\n\\t\\t\\tcur = int(s[i:i+length])   # convert s[i:i + length] to integer\\n\\t\\t\\tlength += 1\\n\\t\\t\\t# if above converted integer is not equal to prev - 1, try increasing the length\\n\\t\\t\\tif prev != -1 and cur != prev - 1: continue \\n\\t\\t\\t# if it is equal to prev - 1, recurse and make splits for remaining index\\n\\t\\t\\tif solve(s, i + length - 1, 1, cur, splits + 1):\\n\\t\\t\\t\\treturn True\\n\\t\\treturn False\\n\\treturn solve(s, 0, 1, -1, 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1186831,
                "title": "c-simple-recursive-solution",
                "content": "Transfer to long long int and compare\\n\\n```cpp\\nclass Solution {\\n    bool helper(string s, long long int tar) {\\n        if (stoull(s) == tar) return true;\\n        for (int i = 1; i < s.size(); ++i) {\\n            if (stoull(s.substr(0, i)) != tar)    continue;\\n            if (helper(s.substr(i, s.size()-i), tar-1))\\n                return true;\\n        }\\n        return false;\\n    }\\npublic:\\n    bool splitString(string s) {\\n        for (int i = 1; i < s.size(); ++i) {\\n            long long int tar = stoull(s.substr(0, i));\\n            if (helper(s.substr(i, s.size()-i), tar-1))\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```cpp\\nclass Solution {\\n    bool helper(string s, long long int tar) {\\n        if (stoull(s) == tar) return true;\\n        for (int i = 1; i < s.size(); ++i) {\\n            if (stoull(s.substr(0, i)) != tar)    continue;\\n            if (helper(s.substr(i, s.size()-i), tar-1))\\n                return true;\\n        }\\n        return false;\\n    }\\npublic:\\n    bool splitString(string s) {\\n        for (int i = 1; i < s.size(); ++i) {\\n            long long int tar = stoull(s.substr(0, i));\\n            if (helper(s.substr(i, s.size()-i), tar-1))\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186812,
                "title": "java-backtracking-100-runtime",
                "content": "Backtracking problem -\\n\\nHint from the constraints  1 <= s.length <= 20\\n\\nWhen the size is less, we can generate all possible combinations and decide\\n\\n# ** backTrack( String s, int index, long prevNumber, int count )**\\n\\nRecursionVirtualization - \\n\\n![image](https://assets.leetcode.com/users/images/9429e601-cc1f-4b41-8269-b99584f12388_1620252266.1658697.gif)\\n\\nRecursion Tree -\\n\\n![image](https://assets.leetcode.com/users/images/14a7f94d-cc9d-4403-be10-0d5debd30c55_1620252278.9633133.png)\\n\\n\\n```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        return backTrack( s , 0, -1, 0 );\\n    }\\n    \\n    public boolean backTrack( String s, int index, long prevNumber, int count )\\n    {\\n        if( index >= s.length() )\\n        {\\n            if( count >= 2) \\n                return true;\\n            return false;\\n        }\\n        \\n        long currNo=0;\\n        for( int i = index; i < s.length() ;i++ )\\n        {\\n            currNo = currNo*10+(s.charAt(i)-\\'0\\');\\n            if( prevNumber == -1 || ( prevNumber - currNo ) == 1 )\\n                if( backTrack( s,i+1,currNo, count+1) )\\n                    return true;\\n        }\\n    return false;\\n    }\\n}\\n```\\nIf we were asked for actual sequence then slight modification to the above code , cList contains the actual sequence \\n```\\n\\nclass Solution {\\n    public boolean splitString(String s) {\\n        return backTrack( s , 0, new LinkedList() );\\n    }\\n    \\n    public boolean backTrack( String s, int index, LinkedList<Long> cList )\\n    {\\n        if( index >= s.length() )\\n        {\\n            if( cList.size() >= 2) \\n                return true;\\n            return false;\\n        }\\n        \\n        long currNo=0;\\n        for( int i = index; i < s.length() ;i++ )\\n        {\\n            long lastNumber = cList.size() > 0 ? cList.getLast() :-1;\\n            currNo = currNo*10+(s.charAt(i)-\\'0\\');\\n            if( lastNumber == -1 || ( lastNumber - currNo ) == 1 )\\n            {\\n                cList.add( currNo);\\n                if( backTrack( s,i+1,cList) )\\n                    return true;\\n                cList.removeLast();\\n            }\\n        }\\n    return false;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        return backTrack( s , 0, -1, 0 );\\n    }\\n    \\n    public boolean backTrack( String s, int index, long prevNumber, int count )\\n    {\\n        if( index >= s.length() )\\n        {\\n            if( count >= 2) \\n                return true;\\n            return false;\\n        }\\n        \\n        long currNo=0;\\n        for( int i = index; i < s.length() ;i++ )\\n        {\\n            currNo = currNo*10+(s.charAt(i)-\\'0\\');\\n            if( prevNumber == -1 || ( prevNumber - currNo ) == 1 )\\n                if( backTrack( s,i+1,currNo, count+1) )\\n                    return true;\\n        }\\n    return false;\\n    }\\n}\\n```\n```\\n\\nclass Solution {\\n    public boolean splitString(String s) {\\n        return backTrack( s , 0, new LinkedList() );\\n    }\\n    \\n    public boolean backTrack( String s, int index, LinkedList<Long> cList )\\n    {\\n        if( index >= s.length() )\\n        {\\n            if( cList.size() >= 2) \\n                return true;\\n            return false;\\n        }\\n        \\n        long currNo=0;\\n        for( int i = index; i < s.length() ;i++ )\\n        {\\n            long lastNumber = cList.size() > 0 ? cList.getLast() :-1;\\n            currNo = currNo*10+(s.charAt(i)-\\'0\\');\\n            if( lastNumber == -1 || ( lastNumber - currNo ) == 1 )\\n            {\\n                cList.add( currNo);\\n                if( backTrack( s,i+1,cList) )\\n                    return true;\\n                cList.removeLast();\\n            }\\n        }\\n    return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186808,
                "title": "python-backtracking-solution",
                "content": "```\\n    def splitString(self, s: str) -> bool:\\n        def backtrack(s, x):\\n            if x == None:\\n                for i in range(1, len(s)):\\n                    if backtrack(s[i:], int(s[:i])):\\n                        return True\\n                return False\\n            else:\\n                if s == \"\" or int(s) == x - 1:\\n                    return True\\n                for i in range(1, len(s)):\\n                    if int(s[:i]) == x - 1:\\n                        return backtrack(s[i:], x - 1)\\n                return False\\n        \\n        return backtrack(s, None)\\n```",
                "solutionTags": [],
                "code": "```\\n    def splitString(self, s: str) -> bool:\\n        def backtrack(s, x):\\n            if x == None:\\n                for i in range(1, len(s)):\\n                    if backtrack(s[i:], int(s[:i])):\\n                        return True\\n                return False\\n            else:\\n                if s == \"\" or int(s) == x - 1:\\n                    return True\\n                for i in range(1, len(s)):\\n                    if int(s[:i]) == x - 1:\\n                        return backtrack(s[i:], x - 1)\\n                return False\\n        \\n        return backtrack(s, None)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2434966,
                "title": "c-simple-c-code",
                "content": "\\n\\n# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\n    int n;\\n    bool split(int idx, string &s, unsigned long long num)\\n    {\\n        if(idx == n)\\n            return true;\\n        string ans = \"\";\\n        for(int i = idx; i < n; i++)\\n        {\\n            ans += s[i];\\n            unsigned long long val = stoull(ans);\\n            if(val != num-1)\\n                continue;\\n            if(split(i+1, s, val))\\n                return true;\\n        }\\n        return false;\\n    }\\npublic:\\n    bool splitString(string s) {\\n        n = s.size();\\n        string ans = \"\";\\n        for(int i = 0; i < n-1; i++)\\n        {\\n            ans += s[i];\\n            unsigned long long num = stoull(ans);\\n            if(split(i+1, s, num))\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int n;\\n    bool split(int idx, string &s, unsigned long long num)\\n    {\\n        if(idx == n)\\n            return true;\\n        string ans = \"\";\\n        for(int i = idx; i < n; i++)\\n        {\\n            ans += s[i];\\n            unsigned long long val = stoull(ans);\\n            if(val != num-1)\\n                continue;\\n            if(split(i+1, s, val))\\n                return true;\\n        }\\n        return false;\\n    }\\npublic:\\n    bool splitString(string s) {\\n        n = s.size();\\n        string ans = \"\";\\n        for(int i = 0; i < n-1; i++)\\n        {\\n            ans += s[i];\\n            unsigned long long num = stoull(ans);\\n            if(split(i+1, s, num))\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1188541,
                "title": "simple-python-3",
                "content": "This solution adds a default paramater to the given function to avoid having to define a dfs function inside the existing function.\\n\\n```python\\nclass Solution:\\n    def splitString(self, s: str, last_val: int = None) -> bool:\\n        # Base case, remaining string is a valid solution\\n        if last_val and int(s) == last_val - 1:\\n            return True\\n\\n\\t\\t# Iterate through increasingly larger slices of s\\n        for i in range(1, len(s)):\\n            cur = int(s[:i])\\n\\t\\t\\t# If current slice is equal to last_val - 1, make\\n\\t\\t\\t# recursive call with remaining string and updated last_val\\n            if last_val is None or cur == last_val - 1:\\n                if self.splitString(s[i:], cur):\\n                    return True\\n\\n        return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def splitString(self, s: str, last_val: int = None) -> bool:\\n        # Base case, remaining string is a valid solution\\n        if last_val and int(s) == last_val - 1:\\n            return True\\n\\n\\t\\t# Iterate through increasingly larger slices of s\\n        for i in range(1, len(s)):\\n            cur = int(s[:i])\\n\\t\\t\\t# If current slice is equal to last_val - 1, make\\n\\t\\t\\t# recursive call with remaining string and updated last_val\\n            if last_val is None or cur == last_val - 1:\\n                if self.splitString(s[i:], cur):\\n                    return True\\n\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1662405,
                "title": "simple-python-solution-dfs",
                "content": "```\\ndef splitString(self, s):\\n\\n\\tdef dfs(start, last):\\n\\t\\tres = False\\n\\t\\tfor k in range(1, len(s)-last+1):\\n\\t\\t\\tif (int(s[start:last])-int(s[last:last+k])) == 1:\\n\\t\\t\\t\\tif dfs(last, last+k):\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\tres = True\\n\\t\\t\\telse:\\n\\t\\t\\t\\tres = False\\n\\t\\treturn res\\n\\n\\tfor i in range(1, len(s)):\\n\\t\\tif dfs(0, i):\\n\\t\\t\\treturn True\\n\\t\\t\\t\\n\\treturn False\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\ndef splitString(self, s):\\n\\n\\tdef dfs(start, last):\\n\\t\\tres = False\\n\\t\\tfor k in range(1, len(s)-last+1):\\n\\t\\t\\tif (int(s[start:last])-int(s[last:last+k])) == 1:\\n\\t\\t\\t\\tif dfs(last, last+k):\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\tres = True\\n\\t\\t\\telse:\\n\\t\\t\\t\\tres = False\\n\\t\\treturn res\\n\\n\\tfor i in range(1, len(s)):\\n\\t\\tif dfs(0, i):\\n\\t\\t\\treturn True\\n\\t\\t\\t\\n\\treturn False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1191740,
                "title": "simple-basic-backtracking-solution-bf-faster-than-70-c-solution-c",
                "content": "\\n\\t  void fun(string &s,int start,vector<vector<string>> &res,vector<string> &cont)\\n    {\\n        //PRUNING\\n         if(cont.size()>0 && cont[0].size()==s.size())return;\\n        if(cont.size()>=2)\\n        {\\n            for(int j=0;j<cont.size()-1;j++)\\n            {\\n                unsigned long long int x1= stoull(cont[j]);\\n               unsigned long long int x2= stoull(cont[j+1]);\\n                if(x1!=x2+1)return;}\\n        }\\n        //base case\\n        if(start==s.size())\\n        {\\n            res.push_back(cont);\\n            return;\\n        }\\n        \\n        //resursive step\\n        for(int i=1;i<=s.size()-start;i++)\\n        {\\n            cont.push_back(s.substr(start,i));\\n            fun(s,start+i,res,cont);\\n            cont.pop_back();\\n        }\\n    }\\n    bool splitString(string s) {\\n        vector<vector<string>> res;\\n        vector<string> cont;\\n        fun(s,0,res,cont);\\n        return res.size()>=1?true:false;\\n    }",
                "solutionTags": [
                    "C",
                    "String",
                    "Recursion"
                ],
                "code": "\\n\\t  void fun(string &s,int start,vector<vector<string>> &res,vector<string> &cont)\\n    {\\n        //PRUNING\\n         if(cont.size()>0 && cont[0].size()==s.size())return;\\n        if(cont.size()>=2)\\n        {\\n            for(int j=0;j<cont.size()-1;j++)\\n            {\\n                unsigned long long int x1= stoull(cont[j]);\\n               unsigned long long int x2= stoull(cont[j+1]);\\n                if(x1!=x2+1)return;}\\n        }\\n        //base case\\n        if(start==s.size())\\n        {\\n            res.push_back(cont);\\n            return;\\n        }\\n        \\n        //resursive step\\n        for(int i=1;i<=s.size()-start;i++)\\n        {\\n            cont.push_back(s.substr(start,i));\\n            fun(s,start+i,res,cont);\\n            cont.pop_back();\\n        }\\n    }\\n    bool splitString(string s) {\\n        vector<vector<string>> res;\\n        vector<string> cont;\\n        fun(s,0,res,cont);\\n        return res.size()>=1?true:false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2923088,
                "title": "java-runtime-0-ms-beats-100-easy-to-understand",
                "content": "# please up-vote:)\\n```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        long num = 0;\\n        for(int i = 0; i < s.length() - 1; i++){\\n            num = num * 10 + (int)(s.charAt(i) - \\'0\\');\\n            if(canSplitString(s, i+1, num - 1))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    private boolean canSplitString(String s, int index, long nextVal){\\n        if(index == s.length())\\n            return true;\\n        long num = 0;\\n        for(int i = index; i < s.length(); i++){\\n            num = num * 10 + (int)(s.charAt(i) - \\'0\\');\\n            if(num == nextVal) \\n                return canSplitString(s, i+1, nextVal == 0? 0 : nextVal - 1);\\n            if(num > nextVal)\\n                break;\\n        }\\n        return false;\\n    }\\n}\\n```\\nthis line: ```nextVal == 0? 0 : nextVal - 1``` \\nis for handling cases like \"20010000\" with trailing zeros.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        long num = 0;\\n        for(int i = 0; i < s.length() - 1; i++){\\n            num = num * 10 + (int)(s.charAt(i) - \\'0\\');\\n            if(canSplitString(s, i+1, num - 1))\\n                return true;\\n        }\\n        return false;\\n    }\\n\\n    private boolean canSplitString(String s, int index, long nextVal){\\n        if(index == s.length())\\n            return true;\\n        long num = 0;\\n        for(int i = index; i < s.length(); i++){\\n            num = num * 10 + (int)(s.charAt(i) - \\'0\\');\\n            if(num == nextVal) \\n                return canSplitString(s, i+1, nextVal == 0? 0 : nextVal - 1);\\n            if(num > nextVal)\\n                break;\\n        }\\n        return false;\\n    }\\n}\\n```\n```nextVal == 0? 0 : nextVal - 1```",
                "codeTag": "Java"
            },
            {
                "id": 2726640,
                "title": "python-3-9-lines-dfs-slices-t-m-100-74",
                "content": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n\\n        def dfs(s, prev = None):\\n\\n            if int(s) == prev - 1: return True\\n\\n            for i in range(1, len(s)+1):\\n                curr = int(s[:i])\\n                if curr == prev - 1 and dfs(s[i:], curr): return True\\n                \\n            return False\\n        \\n        for i in range(1, len(s)):\\n            if dfs(s[i:], int(s[:i])): return True\\n\\n        return False\\n```\\n[https://leetcode.com/submissions/detail/826781820/](http://)",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n\\n        def dfs(s, prev = None):\\n\\n            if int(s) == prev - 1: return True\\n\\n            for i in range(1, len(s)+1):\\n                curr = int(s[:i])\\n                if curr == prev - 1 and dfs(s[i:], curr): return True\\n                \\n            return False\\n        \\n        for i in range(1, len(s)):\\n            if dfs(s[i:], int(s[:i])): return True\\n\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194674,
                "title": "100-faster-cpp-solution-backtracking-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    long long int mx=9999999999; // as max of s.size()==20 so if any number exceeds mx it will not be valid as we will not be able to make two partitions then, according to the situation given. \\n    bool helper(string& s,int i,int j,long long int prev,int n)\\n    {\\n       // if we are at the last index then, we have to just check if the (prev-pres)==1.\\n       // if that condition is true, then it means we got a correct match\\n        if(j==n-1)\\n        {\\n            string str=s.substr(i,j-i+1);\\n            long long int pres=stoll(str);\\n            if(prev-pres==1)\\n                return true;\\n            return false;\\n        }\\n           bool m=false;\\n           string str=s.substr(i,j-i+1);\\n           long long int pres=stoll(str); \\n           if(pres>mx)\\n               return false;\\n            if(prev==-1 || prev-pres==1)\\n                m=m || helper(s,j+1,j+1,pres,n); // in this step we are calling the function  keeping in mind that we have found the integer till this index and freshly calculating the integer from the next index, that\\'s why passed (j+1,j+1) inside the function. \\n            \\n        m=m || helper(s,i,j+1,prev,n);  // in this step we are calling the function keeping in mind that we will extend the integer to the next index and passing the prev val as it is. \\n        \\n        return m; \\n    }\\n    bool splitString(string s) {\\n        int n=s.size();\\n        long long int prev=-1;\\n        return helper(s,0,0,prev,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long int mx=9999999999; // as max of s.size()==20 so if any number exceeds mx it will not be valid as we will not be able to make two partitions then, according to the situation given. \\n    bool helper(string& s,int i,int j,long long int prev,int n)\\n    {\\n       // if we are at the last index then, we have to just check if the (prev-pres)==1.\\n       // if that condition is true, then it means we got a correct match\\n        if(j==n-1)\\n        {\\n            string str=s.substr(i,j-i+1);\\n            long long int pres=stoll(str);\\n            if(prev-pres==1)\\n                return true;\\n            return false;\\n        }\\n           bool m=false;\\n           string str=s.substr(i,j-i+1);\\n           long long int pres=stoll(str); \\n           if(pres>mx)\\n               return false;\\n            if(prev==-1 || prev-pres==1)\\n                m=m || helper(s,j+1,j+1,pres,n); // in this step we are calling the function  keeping in mind that we have found the integer till this index and freshly calculating the integer from the next index, that\\'s why passed (j+1,j+1) inside the function. \\n            \\n        m=m || helper(s,i,j+1,prev,n);  // in this step we are calling the function keeping in mind that we will extend the integer to the next index and passing the prev val as it is. \\n        \\n        return m; \\n    }\\n    bool splitString(string s) {\\n        int n=s.size();\\n        long long int prev=-1;\\n        return helper(s,0,0,prev,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194544,
                "title": "c-greedy-method-0-ms-faster-than-100-00-of-c-online-submissions",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Splitting a String Into Descending Consecutive Values.\\nMemory Usage: 5.9 MB, less than 78.87% of C++ online submissions for Splitting a String Into Descending Consecutive Values.\\n\\n```\\nclass Solution {\\n\\tbool dfs(int index, long long firstVal, string& str)\\n\\t{\\n\\t\\tif (index == str.length())\\n\\t\\t\\treturn true;\\n\\n\\t\\tfor (int j = index; j < str.length(); j++) {\\n\\t\\t\\tlong long secondVal = stoll(str.substr(index, j - index + 1));\\n\\n\\t\\t\\t//If current val is 1 less than prev, then proceed for further valuation\\n\\t\\t\\tif (secondVal + 1 == firstVal && dfs(j + 1, secondVal, str))\\n\\t\\t\\t\\treturn true;\\n\\n\\t\\t\\t//if current val is greater than prev value then no point in proceeding further\\n\\t\\t\\telse if (secondVal > firstVal)\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\npublic:\\n\\n\\tbool splitString(string s)\\n\\t{\\n\\t\\t//take out leading zeros\\n\\t\\twhile (s[0] == \\'0\\') {\\n\\t\\t\\ts.erase(0, 1);\\n\\t\\t}\\n\\n\\t\\tint len = s.length();\\n\\n\\t\\t//special case: if len is 1 then it has to be false\\n\\t\\tif (len == 1)\\n\\t\\t\\treturn false;\\n\\n\\t\\t//max length of first number can be half of original string length\\n\\t\\tif (len % 2 == 0)\\n\\t\\t\\tlen = len / 2;\\n\\t\\telse\\n\\t\\t\\tlen = (len / 2) + 1;\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tlong long firstVal = stoll(s.substr(0, i + 1));\\n\\t\\t\\tif (dfs(i + 1, firstVal, s))\\n\\t\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n\\tbool dfs(int index, long long firstVal, string& str)\\n\\t{\\n\\t\\tif (index == str.length())\\n\\t\\t\\treturn true;\\n\\n\\t\\tfor (int j = index; j < str.length(); j++) {\\n\\t\\t\\tlong long secondVal = stoll(str.substr(index, j - index + 1));\\n\\n\\t\\t\\t//If current val is 1 less than prev, then proceed for further valuation\\n\\t\\t\\tif (secondVal + 1 == firstVal && dfs(j + 1, secondVal, str))\\n\\t\\t\\t\\treturn true;\\n\\n\\t\\t\\t//if current val is greater than prev value then no point in proceeding further\\n\\t\\t\\telse if (secondVal > firstVal)\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\npublic:\\n\\n\\tbool splitString(string s)\\n\\t{\\n\\t\\t//take out leading zeros\\n\\t\\twhile (s[0] == \\'0\\') {\\n\\t\\t\\ts.erase(0, 1);\\n\\t\\t}\\n\\n\\t\\tint len = s.length();\\n\\n\\t\\t//special case: if len is 1 then it has to be false\\n\\t\\tif (len == 1)\\n\\t\\t\\treturn false;\\n\\n\\t\\t//max length of first number can be half of original string length\\n\\t\\tif (len % 2 == 0)\\n\\t\\t\\tlen = len / 2;\\n\\t\\telse\\n\\t\\t\\tlen = (len / 2) + 1;\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tlong long firstVal = stoll(s.substr(0, i + 1));\\n\\t\\t\\tif (dfs(i + 1, firstVal, s))\\n\\t\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1190201,
                "title": "simple-recursion-do-take-care-of-overflow",
                "content": "If you know recursion well then you know how easy it was to come up with simple recursive logic, just one line - \"Make the first number and check and buil on it\"\\nBut were you able to manage the Overflows !?\\n\\n**Hint for recursion :**\\n* start building the very first number from string and check if it is possible to complete the sequence , (make previous number from remaining string)\\n* isPossible function takes few parameters ( string s, currIndex i, targetNumber)\\n* if index has reached the end then return true as we have finished the string successfully\\n* if we have made the number then call for recursion again from next index and targetNumber-1\\n\\n**-> points to remember** \\n1. make sure that you are managing the overflows, if at any point your firstNumber or currNumber becomes greater than 10^11 then return false as maxLength Constraints is given to be 20 characters\\n```\\nbool isPossible(string &s, int index, unsigned long long targetNumber)\\n{\\n    if(index == s.length())            \\n        return 1;\\n    unsigned long long currNumber = 0;\\n    while(index < s.length())\\n    {\\n        currNumber = currNumber*10 + s[index] - \\'0\\';\\n        if(currNumber == targetNumber and isPossible(s , index+1 , targetNumber-1))\\n            return true;\\n        if(currNumber > targetNumber)\\n            return false;\\n        index++;\\n    }\\n    return 0;\\n}\\nbool splitString(string s) \\n{\\n    unsigned long long firstNumber = 0;\\n    for(int index=0; index<s.length()-1 ; index++)\\n    {\\n        firstNumber = firstNumber*10 + (s[index] - \\'0\\');            \\n        if(firstNumber > 1e17+1)\\n            return false;\\n        if(isPossible(s , index+1 , firstNumber-1))\\n            return 1;\\n    }\\n    return 0;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool isPossible(string &s, int index, unsigned long long targetNumber)\\n{\\n    if(index == s.length())            \\n        return 1;\\n    unsigned long long currNumber = 0;\\n    while(index < s.length())\\n    {\\n        currNumber = currNumber*10 + s[index] - \\'0\\';\\n        if(currNumber == targetNumber and isPossible(s , index+1 , targetNumber-1))\\n            return true;\\n        if(currNumber > targetNumber)\\n            return false;\\n        index++;\\n    }\\n    return 0;\\n}\\nbool splitString(string s) \\n{\\n    unsigned long long firstNumber = 0;\\n    for(int index=0; index<s.length()-1 ; index++)\\n    {\\n        firstNumber = firstNumber*10 + (s[index] - \\'0\\');            \\n        if(firstNumber > 1e17+1)\\n            return false;\\n        if(isPossible(s , index+1 , firstNumber-1))\\n            return 1;\\n    }\\n    return 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1187660,
                "title": "python-recursive-with-my-intuition",
                "content": "Intuition\\n\\n1.  Given a string \"050043\"\\n2.  Find a 1st possible number (05) with the string \"050043\"\\n3.  Call dfs() function to see if there is a number 5\\n4.  If so, then find the next number \"004\" (which is smaller than 5 by 1) and \"0043\" & continue to call dfs() until the end\\n5.  If 3 and \"3\" are the same and it\\'s the last string, set ans = True\\n* Use the level for edge cases, since 100 => True but 00 => False (maybe it\\'s the last test case)\\n\\nMy approach solved 172 out of 173 test cases and failed for the last one.\\nThe most tricky part of this problem for me was how to handle zeros because they can either (1) form a part of numbers or (2) just sit there as leading or trailing zeros.\\n* (1) 200100 => True [2,1] , 10110099 => True [101,100,99]\\n* (2) 1000 => True [1,0] , 00 => False\\n* (3) 10100010099 => True [101,100,99] (mixed with (1) and (2) cases)\\n\\n```\\n    def splitString(self, s: str) -> bool:\\n\\n        ans = False\\n\\t\\t# recursive call\\n        def dfs(x:int, y:str, level: int):\\n            nonlocal ans\\n\\n            if x < 0 : return\\n            if len(y) == 0 or  (x == int(y) and level > 0):\\n                ans = True\\n\\n            for j in range(1,len(y)):\\n                if x == int(y[:j]):\\n                    dfs(x-1, y[j:], level + 1)\\n\\t\\t\\t\\t\\n\\t\\t# main \\n        for i in range(1,len(s)):\\n            dfs(int(s[:i]),s, 0)\\n\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\n    def splitString(self, s: str) -> bool:\\n\\n        ans = False\\n\\t\\t# recursive call\\n        def dfs(x:int, y:str, level: int):\\n            nonlocal ans\\n\\n            if x < 0 : return\\n            if len(y) == 0 or  (x == int(y) and level > 0):\\n                ans = True\\n\\n            for j in range(1,len(y)):\\n                if x == int(y[:j]):\\n                    dfs(x-1, y[j:], level + 1)\\n\\t\\t\\t\\t\\n\\t\\t# main \\n        for i in range(1,len(s)):\\n            dfs(int(s[:i]),s, 0)\\n\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1786073,
                "title": "backtracking-in-python",
                "content": "Split the input string `s` into possible pieces, and check recursively when it\\'s 1 smaller than the previous value.\\nNote that the string must be split into two or more pieces, so I added an argument `parts` to manage the number of split pieces.\\n\\n```\\nimport math\\n\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        def rec(idx, parts, prev_val):\\n            if idx == L:\\n                return parts >= 2\\n            \\n            for i in range(idx, L):\\n                num = int(s[idx : i + 1])\\n                if prev_val == math.inf or num == prev_val - 1:\\n                    if rec(i + 1, parts + 1, num):\\n                        return True\\n            return False\\n        \\n        L = len(s)\\n        return rec(0, 0, math.inf)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nimport math\\n\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        def rec(idx, parts, prev_val):\\n            if idx == L:\\n                return parts >= 2\\n            \\n            for i in range(idx, L):\\n                num = int(s[idx : i + 1])\\n                if prev_val == math.inf or num == prev_val - 1:\\n                    if rec(i + 1, parts + 1, num):\\n                        return True\\n            return False\\n        \\n        L = len(s)\\n        return rec(0, 0, math.inf)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1720660,
                "title": "java-post-my-one-pass-dfs-solution-with-pruning-0ms-runtime-beat-100",
                "content": "Post my 0ms runtime solution.\\n\\nThe idea is to generate a starting number so that we don\\'t need to backtrack, and the target number can also be used for tree pruning.\\n\\n```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        long currNum = 0;\\n        for (int i = 0; i < s.length() - 1; i++) { // must split into at least two numbers, so i < s.length() - 1\\n            currNum = currNum * 10 + (s.charAt(i) - \\'0\\');\\n            if (currNum > 0 && splitStringAfter(s, i + 1, currNum - 1)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private boolean splitStringAfter(String s, int index, long targetNum) {\\n        if (index == s.length()) {\\n            return true;\\n        }\\n        \\n        long currNum = 0;\\n        for (int i = index; i < s.length(); i++) {\\n            currNum = currNum * 10 + (s.charAt(i) - \\'0\\');\\n\\t\\t\\t// If targetNum == 0, we need to check all the remaining characters instead of spliting another number\\n            if (currNum == targetNum && targetNum > 0) {\\n                return splitStringAfter(s, i + 1, currNum - 1);\\n            } else if (currNum > targetNum) { // Stop the loop if the current number is greater than target.\\n                return false;\\n            }\\n        }\\n        return currNum == targetNum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        long currNum = 0;\\n        for (int i = 0; i < s.length() - 1; i++) { // must split into at least two numbers, so i < s.length() - 1\\n            currNum = currNum * 10 + (s.charAt(i) - \\'0\\');\\n            if (currNum > 0 && splitStringAfter(s, i + 1, currNum - 1)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    private boolean splitStringAfter(String s, int index, long targetNum) {\\n        if (index == s.length()) {\\n            return true;\\n        }\\n        \\n        long currNum = 0;\\n        for (int i = index; i < s.length(); i++) {\\n            currNum = currNum * 10 + (s.charAt(i) - \\'0\\');\\n\\t\\t\\t// If targetNum == 0, we need to check all the remaining characters instead of spliting another number\\n            if (currNum == targetNum && targetNum > 0) {\\n                return splitStringAfter(s, i + 1, currNum - 1);\\n            } else if (currNum > targetNum) { // Stop the loop if the current number is greater than target.\\n                return false;\\n            }\\n        }\\n        return currNum == targetNum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1187926,
                "title": "python-beat-100-super-simple",
                "content": "Recursion logic:\\n- if the last number is x, then we need to check if the string contains a number x - 1 after x, if we found a number ,we increment the count and make sure we can at least find 2 substring\\n\\nEdge cases:\\n - numbers with leading zero, need not to count the zeros,  in python, simply do **len(str(num))**\\n```\\n    def splitString(self, s: str) -> bool:\\n        def dfs(last, cur, count):\\n            if cur == len(s) and count > 1:\\n                return True \\n            for j in range(cur, len(s) + 1):\\n                try:\\n                    num = int(s[cur:j])\\n                    if num == last - 1:\\n                        if dfs(num, j, count + 1):\\n                            return True \\n                except:\\n                    pass \\n            return False \\n        for l in range(len(s)):\\n            try:\\n                num = int(s[:l])\\n                if dfs(num, l, 1):\\n                    return True\\n            except:\\n                pass\\n        return False \\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n    def splitString(self, s: str) -> bool:\\n        def dfs(last, cur, count):\\n            if cur == len(s) and count > 1:\\n                return True \\n            for j in range(cur, len(s) + 1):\\n                try:\\n                    num = int(s[cur:j])\\n                    if num == last - 1:\\n                        if dfs(num, j, count + 1):\\n                            return True \\n                except:\\n                    pass \\n            return False \\n        for l in range(len(s)):\\n            try:\\n                num = int(s[:l])\\n                if dfs(num, l, 1):\\n                    return True\\n            except:\\n                pass\\n        return False \\n                \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1187486,
                "title": "java-recursion-beats-100-0ms-t-c-o-2-n-s-c-o-n",
                "content": "\\n    // O(2^n) O(n)\\n    public boolean splitString(String s) {\\n\\t\\n\\t\\tint len = s.length(), curr = 0;\\n\\t\\tfor (int i = 0; i < len - 1; i++) {\\n\\t\\t\\tcurr = curr * 10 + (s.charAt(i) - \\'0\\');\\n\\t\\t\\tboolean flag = splitStringHelper(s, i + 1, curr, len);\\n\\t\\t\\tif (flag)\\n\\t\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\n    // O(2^n) O(n)\\n\\tpublic boolean splitStringHelper(String s, int idx, int prev, int len) {\\n\\n\\t\\tif (idx == len)\\n\\t\\t\\treturn true;\\n\\n\\t\\tint curr = 0;\\n\\t\\tfor (int i = idx; i < len; i++) {\\n\\t\\t\\tcurr = curr * 10 + (s.charAt(i) - \\'0\\');\\n\\t\\t\\tif (prev - curr == 1) {\\n\\t\\t\\t\\tboolean flag = splitStringHelper(s, i + 1, curr, len);\\n\\t\\t\\t\\tif (flag)\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}",
                "solutionTags": [],
                "code": "\\n    // O(2^n) O(n)\\n    public boolean splitString(String s) {\\n\\t\\n\\t\\tint len = s.length(), curr = 0;\\n\\t\\tfor (int i = 0; i < len - 1; i++) {\\n\\t\\t\\tcurr = curr * 10 + (s.charAt(i) - \\'0\\');\\n\\t\\t\\tboolean flag = splitStringHelper(s, i + 1, curr, len);\\n\\t\\t\\tif (flag)\\n\\t\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n\\n    // O(2^n) O(n)\\n\\tpublic boolean splitStringHelper(String s, int idx, int prev, int len) {\\n\\n\\t\\tif (idx == len)\\n\\t\\t\\treturn true;\\n\\n\\t\\tint curr = 0;\\n\\t\\tfor (int i = idx; i < len; i++) {\\n\\t\\t\\tcurr = curr * 10 + (s.charAt(i) - \\'0\\');\\n\\t\\t\\tif (prev - curr == 1) {\\n\\t\\t\\t\\tboolean flag = splitStringHelper(s, i + 1, curr, len);\\n\\t\\t\\t\\tif (flag)\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1186878,
                "title": "python-3-backtracking",
                "content": "Split the string at i, progress when the previous num is greater then the current number by 1.\\nUse extra space to store where we are at, so it is easier to end the recursion, backtract if it doesn\\'t work out.\\n\\n```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        for i in range(len(s)-1):\\n            if self.backtrack(s, int(s[:i+1]), i+1, [s[:i+1]]):\\n                return True\\n        \\n        return False\\n        \\n    \\n    def backtrack(self, s, pre, index, cur):\\n        if \"\".join(cur) == s:\\n            return True\\n        \\n        for i in range(index, len(s)):\\n            if pre - 1 == int(s[index:i+1]):\\n                cur.append(s[index:i+1])\\n                if self.backtrack(s, int(s[index:i+1]), i+1, cur):\\n                    return True\\n                cur.pop()\\n        \\n        return False",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "Split the string at i, progress when the previous num is greater then the current number by 1.\\nUse extra space to store where we are at, so it is easier to end the recursion, backtract if it doesn\\'t work out.\\n\\n```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        for i in range(len(s)-1):\\n            if self.backtrack(s, int(s[:i+1]), i+1, [s[:i+1]]):\\n                return True\\n        \\n        return False\\n        \\n    \\n    def backtrack(self, s, pre, index, cur):\\n        if \"\".join(cur) == s:\\n            return True\\n        \\n        for i in range(index, len(s)):\\n            if pre - 1 == int(s[index:i+1]):\\n                cur.append(s[index:i+1])\\n                if self.backtrack(s, int(s[index:i+1]), i+1, cur):\\n                    return True\\n                cur.pop()\\n        \\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 3223985,
                "title": "python3-easiest-solution-beats-85-users-simplest-backtracking",
                "content": "```\\n\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        def dfs(index,prevVal):\\n            if index==len(s):\\n                return True\\n            for j in range(index,len(s)):\\n                val=int(s[index:j+1])\\n                if prevVal-val==1 and dfs(j+1,val):\\n                    return True\\n            return False\\n        for i in range(len(s)-1):\\n            val=int(s[:i+1])\\n            if dfs(i+1,val):\\n                return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        def dfs(index,prevVal):\\n            if index==len(s):\\n                return True\\n            for j in range(index,len(s)):\\n                val=int(s[index:j+1])\\n                if prevVal-val==1 and dfs(j+1,val):\\n                    return True\\n            return False\\n        for i in range(len(s)-1):\\n            val=int(s[:i+1])\\n            if dfs(i+1,val):\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1256113,
                "title": "c-java-python-easy-and-clean-backtracking",
                "content": "**C++**\\n\\n```cpp\\nclass Solution {\\n public:\\n  bool splitString(string s) {\\n    return isValid(s, 0, -1, 0);\\n  }\\n\\n private:\\n  bool isValid(const string& s, int start, long prev, int segment) {\\n    if (start == s.length() && segment > 1)\\n      return true;\\n\\n    long curr = 0;\\n    for (int i = start; i < s.length(); ++i) {\\n      curr = curr * 10 + s[i] - \\'0\\';\\n      if (curr > 9999999999L)\\n        return false;\\n      if ((prev == -1 || curr == prev - 1) &&\\n          isValid(s, i + 1, curr, segment + 1)) {\\n        return true;\\n      }\\n    }\\n\\n    return false;\\n  }\\n};\\n```\\n\\n**Java**\\n\\n```java\\nclass Solution {\\n  public boolean splitString(String s) {\\n    return isValid(s, 0, -1, 0);\\n  }\\n\\n  private boolean isValid(final String s, int start, long prev, int segment) {\\n    if (start == s.length() && segment > 1)\\n      return true;\\n\\n    long curr = 0;\\n    for (int i = start; i < s.length(); ++i) {\\n      curr = curr * 10 + s.charAt(i) - \\'0\\';\\n      if (curr > 9999999999)\\n        return false;\\n      if ((prev == -1 || curr == prev - 1) && isValid(s, i + 1, curr, segment + 1))\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n}\\n```\\n\\n**Python**\\n\\n```python\\nclass Solution:\\n  def splitString(self, s: str) -> bool:\\n    def isValid(s: str, start: int, prev: int, segment: int) -> bool:\\n      if start == len(s) and segment > 1:\\n        return True\\n\\n      curr = 0\\n      for i in range(start, len(s)):\\n        curr = curr * 10 + ord(s[i]) - ord(\\'0\\')\\n        if curr > 9999999999:\\n          return False\\n        if (prev == -1 or curr == prev - 1) and isValid(s, i + 1, curr, segment + 1):\\n          return True\\n\\n      return False\\n\\n    return isValid(s, 0, -1, 0)\\n```\\n\\nTime: `O(2^n)`\\nSpace: `O(n)`",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\n public:\\n  bool splitString(string s) {\\n    return isValid(s, 0, -1, 0);\\n  }\\n\\n private:\\n  bool isValid(const string& s, int start, long prev, int segment) {\\n    if (start == s.length() && segment > 1)\\n      return true;\\n\\n    long curr = 0;\\n    for (int i = start; i < s.length(); ++i) {\\n      curr = curr * 10 + s[i] - \\'0\\';\\n      if (curr > 9999999999L)\\n        return false;\\n      if ((prev == -1 || curr == prev - 1) &&\\n          isValid(s, i + 1, curr, segment + 1)) {\\n        return true;\\n      }\\n    }\\n\\n    return false;\\n  }\\n};\\n```\n```java\\nclass Solution {\\n  public boolean splitString(String s) {\\n    return isValid(s, 0, -1, 0);\\n  }\\n\\n  private boolean isValid(final String s, int start, long prev, int segment) {\\n    if (start == s.length() && segment > 1)\\n      return true;\\n\\n    long curr = 0;\\n    for (int i = start; i < s.length(); ++i) {\\n      curr = curr * 10 + s.charAt(i) - \\'0\\';\\n      if (curr > 9999999999)\\n        return false;\\n      if ((prev == -1 || curr == prev - 1) && isValid(s, i + 1, curr, segment + 1))\\n        return true;\\n    }\\n\\n    return false;\\n  }\\n}\\n```\n```python\\nclass Solution:\\n  def splitString(self, s: str) -> bool:\\n    def isValid(s: str, start: int, prev: int, segment: int) -> bool:\\n      if start == len(s) and segment > 1:\\n        return True\\n\\n      curr = 0\\n      for i in range(start, len(s)):\\n        curr = curr * 10 + ord(s[i]) - ord(\\'0\\')\\n        if curr > 9999999999:\\n          return False\\n        if (prev == -1 or curr == prev - 1) and isValid(s, i + 1, curr, segment + 1):\\n          return True\\n\\n      return False\\n\\n    return isValid(s, 0, -1, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1227555,
                "title": "java-backtracking-easy-to-understand-4ms",
                "content": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        for(int i = 1; i <= s.length(); i++){\\n            for(int j = i+1; j <= s.length(); j++){\\n                if(s.substring(0, i).length() > 0 && s.substring(i, j).length() > 0  ) \\n                {\\n                    try{\\n                        long a = Long.parseLong(s.substring(0, i));\\n                        long b = Long.parseLong(s.substring(i, j));\\n                        if(a == b+1 && gg(s.substring(j), b)){\\n                            return true;\\n                        }    \\n                    }\\n                    catch(Exception e){\\n                        \\n                    }\\n                    \\n                }\\n                \\n            }\\n        }\\n        return false;\\n    }\\n    \\n    \\n    public boolean gg(String s, long prev){\\n        \\n        if(s.length() == 0) return true;\\n        \\n        for(int i = 1; i <= s.length(); i++){\\n            if(s.substring(0, i).length() > 0 ) {\\n                long a = Long.parseLong(s.substring(0, i));\\n                if(prev == a + 1){\\n                    if(gg(s.substring(i), a))\\n                        return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        for(int i = 1; i <= s.length(); i++){\\n            for(int j = i+1; j <= s.length(); j++){\\n                if(s.substring(0, i).length() > 0 && s.substring(i, j).length() > 0  ) \\n                {\\n                    try{\\n                        long a = Long.parseLong(s.substring(0, i));\\n                        long b = Long.parseLong(s.substring(i, j));\\n                        if(a == b+1 && gg(s.substring(j), b)){\\n                            return true;\\n                        }    \\n                    }\\n                    catch(Exception e){\\n                        \\n                    }\\n                    \\n                }\\n                \\n            }\\n        }\\n        return false;\\n    }\\n    \\n    \\n    public boolean gg(String s, long prev){\\n        \\n        if(s.length() == 0) return true;\\n        \\n        for(int i = 1; i <= s.length(); i++){\\n            if(s.substring(0, i).length() > 0 ) {\\n                long a = Long.parseLong(s.substring(0, i));\\n                if(prev == a + 1){\\n                    if(gg(s.substring(i), a))\\n                        return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1202698,
                "title": "c-backtracking-0ms-simple-solution",
                "content": "```\\n bool Word(string s,long long num){\\n        if(s.size()==0){\\n            return true;\\n        }\\n        for(int i=0;i<s.size();i++){\\n            string lfw=s.substr(0,i+1);\\n            string right=s.substr(i+1);\\n            unsigned long long l2=stoull(lfw);\\n            if(num-l2==1 && Word(right,l2) ){\\n                return true;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n    bool splitString(string s) {\\n       for(int i=0;i<s.size()-1;i++){\\n           string tmp=s.substr(0,i+1);\\n           unsigned long long num=stoull(tmp);\\n           if(Word(s.substr(i+1),num)){\\n               return true;\\n           }\\n       }\\n       \\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n bool Word(string s,long long num){\\n        if(s.size()==0){\\n            return true;\\n        }\\n        for(int i=0;i<s.size();i++){\\n            string lfw=s.substr(0,i+1);\\n            string right=s.substr(i+1);\\n            unsigned long long l2=stoull(lfw);\\n            if(num-l2==1 && Word(right,l2) ){\\n                return true;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n    bool splitString(string s) {\\n       for(int i=0;i<s.size()-1;i++){\\n           string tmp=s.substr(0,i+1);\\n           unsigned long long num=stoull(tmp);\\n           if(Word(s.substr(i+1),num)){\\n               return true;\\n           }\\n       }\\n       \\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1195215,
                "title": "python3-dfs-memo",
                "content": "```\\nclass Solution:\\n    def splitString(self, s: str, sentinel = int(1e9 + 7)) -> bool:\\n        N = len(s)\\n        ok = lambda pre, cur: pre == sentinel or pre == 1 + cur  # \\u2705 monotonically decreasing\\n        @cache                                                   # \\uD83E\\uDD14 memo\\n        def go(i = 0, pre = sentinel, steps = -1):\\n            if i == N:\\n                return 0 < steps                                 # \\uD83D\\uDED1 base case\\n            for j in range(i + 1, N + 1):\\n                cur = int(s[i:j])\\n                if ok(pre, cur) and go(j, cur, 1 + steps):       # \\uD83D\\uDE80 recursive case\\n                    return True\\n            return False\\n        return go()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str, sentinel = int(1e9 + 7)) -> bool:\\n        N = len(s)\\n        ok = lambda pre, cur: pre == sentinel or pre == 1 + cur  # \\u2705 monotonically decreasing\\n        @cache                                                   # \\uD83E\\uDD14 memo\\n        def go(i = 0, pre = sentinel, steps = -1):\\n            if i == N:\\n                return 0 < steps                                 # \\uD83D\\uDED1 base case\\n            for j in range(i + 1, N + 1):\\n                cur = int(s[i:j])\\n                if ok(pre, cur) and go(j, cur, 1 + steps):       # \\uD83D\\uDE80 recursive case\\n                    return True\\n            return False\\n        return go()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1190158,
                "title": "easy-c-solution",
                "content": "```\\nbool splitString(string s) {\\n        bool ans = false;\\n        for(int i=0;i<s.length()-1;i++){\\n            ans = ans || helper(s.substr(i+1),stoull(s.substr(0,i+1))-1);\\n            if(ans) return ans;\\n        }\\n        return ans;        \\n    }\\n    \\n    bool helper(string s, long long target){\\n        if(s.empty()){\\n            return true;\\n        }\\n        if(target==0){\\n            return stoull(s) == target;\\n        }\\n        \\n        for(int i=0;i<s.length();i++){\\n            if(stoull(s.substr(0,i+1))==target){\\n                return helper(s.substr(i+1),target-1);\\n            }\\n        }\\n        \\n        return false;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nbool splitString(string s) {\\n        bool ans = false;\\n        for(int i=0;i<s.length()-1;i++){\\n            ans = ans || helper(s.substr(i+1),stoull(s.substr(0,i+1))-1);\\n            if(ans) return ans;\\n        }\\n        return ans;        \\n    }\\n    \\n    bool helper(string s, long long target){\\n        if(s.empty()){\\n            return true;\\n        }\\n        if(target==0){\\n            return stoull(s) == target;\\n        }\\n        \\n        for(int i=0;i<s.length();i++){\\n            if(stoull(s.substr(0,i+1))==target){\\n                return helper(s.substr(i+1),target-1);\\n            }\\n        }\\n        \\n        return false;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1188655,
                "title": "backtracking-o-n-2-self-evident",
                "content": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        //backtracking\\n        return dfs(s,0,0,-1);\\n    }\\n    private boolean dfs(String s, int prev, int i, int lastNum){\\n        int cur=prev*10+s.charAt(i)-\\'0\\';\\n        if (cur==lastNum-1){\\n            if (i+1>=s.length()){\\n                return true;\\n            }\\n            if (dfs(s,0,i+1,cur))\\n                return true;\\n            if (dfs(s,cur,i+1,lastNum))\\n                return true;\\n        } else {\\n            if (i+1>=s.length()){\\n                return false;\\n            }\\n            if (dfs(s,cur,i+1,lastNum))\\n                return true;\\n            if (lastNum==-1 && dfs(s,0,i+1,cur)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        //backtracking\\n        return dfs(s,0,0,-1);\\n    }\\n    private boolean dfs(String s, int prev, int i, int lastNum){\\n        int cur=prev*10+s.charAt(i)-\\'0\\';\\n        if (cur==lastNum-1){\\n            if (i+1>=s.length()){\\n                return true;\\n            }\\n            if (dfs(s,0,i+1,cur))\\n                return true;\\n            if (dfs(s,cur,i+1,lastNum))\\n                return true;\\n        } else {\\n            if (i+1>=s.length()){\\n                return false;\\n            }\\n            if (dfs(s,cur,i+1,lastNum))\\n                return true;\\n            if (lastNum==-1 && dfs(s,0,i+1,cur)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1187320,
                "title": "c-recursion-with-condition-of-all-possible-substrings",
                "content": "```\\n#define ll long long int\\n\\nclass Solution {\\npublic:\\n    bool flag=false;\\n    void secondsubstring(string s, int idx, ll prev)\\n    {\\n        ll x = 0;\\n        if(idx>=s.size() || flag)\\n        {\\n            flag = true;\\n            return;\\n        }\\n        for(int i=idx; i<s.size(); i++)\\n        {\\n            x = x*10 + (s[i]-48);\\n            if(x>=1e11)\\n            {\\n                break;\\n            }\\n            if(x==prev-1)\\n            {\\n                secondsubstring(s, i+1, x);\\n            }\\n        }\\n        return;\\n    }\\n    bool splitString(string s) \\n    {\\n        ll x = 0;\\n        for (int i=0; i<s.size()-1; i++)\\n        {\\n            x = x*10 + (s[i]-48);\\n            if(x>=1e11)\\n            {\\n                break;\\n            }\\n            secondsubstring(s, i+1, x);\\n        }\\n        return flag;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n#define ll long long int\\n\\nclass Solution {\\npublic:\\n    bool flag=false;\\n    void secondsubstring(string s, int idx, ll prev)\\n    {\\n        ll x = 0;\\n        if(idx>=s.size() || flag)\\n        {\\n            flag = true;\\n            return;\\n        }\\n        for(int i=idx; i<s.size(); i++)\\n        {\\n            x = x*10 + (s[i]-48);\\n            if(x>=1e11)\\n            {\\n                break;\\n            }\\n            if(x==prev-1)\\n            {\\n                secondsubstring(s, i+1, x);\\n            }\\n        }\\n        return;\\n    }\\n    bool splitString(string s) \\n    {\\n        ll x = 0;\\n        for (int i=0; i<s.size()-1; i++)\\n        {\\n            x = x*10 + (s[i]-48);\\n            if(x>=1e11)\\n            {\\n                break;\\n            }\\n            secondsubstring(s, i+1, x);\\n        }\\n        return flag;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186928,
                "title": "c-try-all-splits-that-has-diff-1-with-custom-diff-method",
                "content": "```csharp\\npublic bool SplitString(string s)\\n{\\n\\tbool result = canSplit(\"0\", s, 0, 0);\\n\\treturn result;\\n}\\n\\nprivate bool canSplit(string firstPart, string s, int start, int currentLength)\\n{\\n\\tif (start >= s.Length && currentLength != s.Length)\\n\\t{\\n\\t\\treturn true;\\n\\t}\\n\\n\\tfor (int length = 1; length <= s.Length - start; length++)\\n\\t{\\n\\t\\tstring nextPart = s.Substring(start, length);\\n\\t\\tif ((start == 0 || hasDiffOne(firstPart, nextPart)) && canSplit(nextPart, s, start + length, length))\\n\\t\\t{\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}\\n\\n\\treturn false;\\n}\\n\\nprivate bool hasDiffOne(string first, string second)\\n{\\n\\tfirst = first.TrimStart(\\'0\\');\\n\\tsecond = second.TrimStart(\\'0\\');\\n\\n\\tif (string.IsNullOrEmpty(first) && string.IsNullOrEmpty(second))\\n\\t{\\n\\t\\treturn false;\\n\\t}\\n\\n\\tif (string.IsNullOrEmpty(second))\\n\\t{\\n\\t\\treturn first == \"1\";\\n\\t}\\n\\n\\tif (string.IsNullOrEmpty(first))\\n\\t{\\n\\t\\treturn false;\\n\\t}\\n\\n\\tbool isLast = first[^1] - \\'0\\' == (second[^1]  - \\'0\\'  + 1) % 10;\\n\\tint carry = (second[^1] - \\'0\\' + 1) >= 10 ? 1 : 0;\\n\\n\\tif (!isLast)\\n\\t{\\n\\t\\treturn false;\\n\\t}\\n\\n\\tint i = first.Length - 2, j = second.Length - 2;\\n\\n\\twhile (i >= 0 && j >= 0)\\n\\t{\\n\\t\\tif ((first[i] - \\'0\\') != (second[j] - \\'0\\' + carry) % 10)\\n\\t\\t{\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tcarry = (second[j] - \\'0\\' + carry) >= 10 ? 1 : 0;\\n\\t\\ti--;\\n\\t\\tj--;\\n\\t}\\n\\n\\tif (carry > 0)\\n\\t{\\n\\t\\treturn j == -1 && i == 0 && first[i] == \\'1\\';\\n\\t}\\n\\n\\treturn i == j;\\n}\\n```\\n\\nHowever, since there is requirement of atleast two string so max valid string length = 10, which easily fit into long and ignore otherwise.\\n\\n```csharp\\npublic bool SplitString(string s)\\n{\\n\\tbool result = canSplit(-1L, s, 0, 0);\\n\\treturn result;\\n}\\n\\nprivate bool canSplit(long firstPart, string s, int start, int currentLength)\\n{\\n\\tif (start >= s.Length && currentLength != s.Length)\\n\\t{\\n\\t\\treturn true;\\n\\t}      \\n\\n\\tfor (int length = 1; length <= s.Length - start; length++)\\n\\t{            \\n\\t\\tlong nextPart = 0L;\\n\\t\\tlong.TryParse(s.Substring(start, length), out nextPart);\\n\\n\\t\\tif ((start == 0 || firstPart - nextPart == 1L) && canSplit(nextPart, s, start + length, length))\\n\\t\\t{\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}        \\n\\n\\treturn false;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic bool SplitString(string s)\\n{\\n\\tbool result = canSplit(\"0\", s, 0, 0);\\n\\treturn result;\\n}\\n\\nprivate bool canSplit(string firstPart, string s, int start, int currentLength)\\n{\\n\\tif (start >= s.Length && currentLength != s.Length)\\n\\t{\\n\\t\\treturn true;\\n\\t}\\n\\n\\tfor (int length = 1; length <= s.Length - start; length++)\\n\\t{\\n\\t\\tstring nextPart = s.Substring(start, length);\\n\\t\\tif ((start == 0 || hasDiffOne(firstPart, nextPart)) && canSplit(nextPart, s, start + length, length))\\n\\t\\t{\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}\\n\\n\\treturn false;\\n}\\n\\nprivate bool hasDiffOne(string first, string second)\\n{\\n\\tfirst = first.TrimStart(\\'0\\');\\n\\tsecond = second.TrimStart(\\'0\\');\\n\\n\\tif (string.IsNullOrEmpty(first) && string.IsNullOrEmpty(second))\\n\\t{\\n\\t\\treturn false;\\n\\t}\\n\\n\\tif (string.IsNullOrEmpty(second))\\n\\t{\\n\\t\\treturn first == \"1\";\\n\\t}\\n\\n\\tif (string.IsNullOrEmpty(first))\\n\\t{\\n\\t\\treturn false;\\n\\t}\\n\\n\\tbool isLast = first[^1] - \\'0\\' == (second[^1]  - \\'0\\'  + 1) % 10;\\n\\tint carry = (second[^1] - \\'0\\' + 1) >= 10 ? 1 : 0;\\n\\n\\tif (!isLast)\\n\\t{\\n\\t\\treturn false;\\n\\t}\\n\\n\\tint i = first.Length - 2, j = second.Length - 2;\\n\\n\\twhile (i >= 0 && j >= 0)\\n\\t{\\n\\t\\tif ((first[i] - \\'0\\') != (second[j] - \\'0\\' + carry) % 10)\\n\\t\\t{\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t\\tcarry = (second[j] - \\'0\\' + carry) >= 10 ? 1 : 0;\\n\\t\\ti--;\\n\\t\\tj--;\\n\\t}\\n\\n\\tif (carry > 0)\\n\\t{\\n\\t\\treturn j == -1 && i == 0 && first[i] == \\'1\\';\\n\\t}\\n\\n\\treturn i == j;\\n}\\n```\n```csharp\\npublic bool SplitString(string s)\\n{\\n\\tbool result = canSplit(-1L, s, 0, 0);\\n\\treturn result;\\n}\\n\\nprivate bool canSplit(long firstPart, string s, int start, int currentLength)\\n{\\n\\tif (start >= s.Length && currentLength != s.Length)\\n\\t{\\n\\t\\treturn true;\\n\\t}      \\n\\n\\tfor (int length = 1; length <= s.Length - start; length++)\\n\\t{            \\n\\t\\tlong nextPart = 0L;\\n\\t\\tlong.TryParse(s.Substring(start, length), out nextPart);\\n\\n\\t\\tif ((start == 0 || firstPart - nextPart == 1L) && canSplit(nextPart, s, start + length, length))\\n\\t\\t{\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}        \\n\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3357528,
                "title": "python-backtracking-solutions-2-branches-vs-n-branches",
                "content": "Solution 1: Path from source to node represents a candidate split of the string. Each node has two branches -- either include the current char in the split or don\\'t include and start a new split. Prune unnecessary paths by checking if the condition of consecutive and descending is maintained. Time complexity -- O(2^N) but in practice much faster due to pruning and early return once we find a valid split.\\n\\n# Code\\n```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        def dfs(index, path):\\n            # pruning: checks if path breaks consecutive descending order\\n            if len(path) > 2 and int(path[-3]) != int(path[-2]) + 1:\\n                return False\\n\\n            # reaching leaf node means path has satisfied the requirements\\n            if index == len(s):\\n                return len(path) > 1 and int(path[-2]) == int(path[-1]) + 1\\n            \\n            # try to take this digit\\n            path[-1] += s[index]\\n            if dfs(index + 1, path.copy()):\\n                return True\\n            path[-1] = path[-1][:-1] # backtrack step\\n\\n            # try to start a new split \\n            path += s[index]\\n            if dfs(index + 1, path.copy()):\\n                return True\\n            path.pop() # backtrack step\\n\\n            # we cannot reach a leaf starting from this index and path\\n            return False\\n        \\n        if len(s) == 1: return False\\n        return dfs(1, [s[0]])\\n```\\n\\nSolution 2: Each node has `n` branches denoting where to split the string `s[i:]` into two substrings. Time complexity is O(N^N) but in practice much faster due to pruning. \\n```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        def dfs(i, path):\\n            if i == len(s):\\n                return len(path) > 1\\n\\n            for j in range(i, len(s)):\\n                path.append(s[i:j + 1])\\n                if len(path) == 1 or int(path[-2]) == int(path[-1]) + 1:\\n                    if dfs(j + 1, path.copy()):\\n                        return True\\n                path.pop()\\n            \\n            return False\\n\\n        if len(s) == 1: return False\\n        return dfs(0, [])\\n```\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        def dfs(index, path):\\n            # pruning: checks if path breaks consecutive descending order\\n            if len(path) > 2 and int(path[-3]) != int(path[-2]) + 1:\\n                return False\\n\\n            # reaching leaf node means path has satisfied the requirements\\n            if index == len(s):\\n                return len(path) > 1 and int(path[-2]) == int(path[-1]) + 1\\n            \\n            # try to take this digit\\n            path[-1] += s[index]\\n            if dfs(index + 1, path.copy()):\\n                return True\\n            path[-1] = path[-1][:-1] # backtrack step\\n\\n            # try to start a new split \\n            path += s[index]\\n            if dfs(index + 1, path.copy()):\\n                return True\\n            path.pop() # backtrack step\\n\\n            # we cannot reach a leaf starting from this index and path\\n            return False\\n        \\n        if len(s) == 1: return False\\n        return dfs(1, [s[0]])\\n```\n```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        def dfs(i, path):\\n            if i == len(s):\\n                return len(path) > 1\\n\\n            for j in range(i, len(s)):\\n                path.append(s[i:j + 1])\\n                if len(path) == 1 or int(path[-2]) == int(path[-1]) + 1:\\n                    if dfs(j + 1, path.copy()):\\n                        return True\\n                path.pop()\\n            \\n            return False\\n\\n        if len(s) == 1: return False\\n        return dfs(0, [])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3291155,
                "title": "1849-splitting-a-string-into-descending-consecutive-values",
                "content": "\\tclass Solution:\\n\\t\\tdef splitString(self, s: str) -> bool:\\n\\t\\t\\tself.ans = False\\n\\t\\t\\tself.length = len(s)\\n\\t\\t\\tself.helper([],s,0)\\n\\t\\t\\treturn self.ans\\n\\n\\t\\tdef helper(self,arr,s,ind):    \\n\\t\\t\\tif not self.ans and ind < self.length:\\n\\t\\t\\t\\ttemp = \\'\\'\\n\\t\\t\\t\\tfor i in range(ind,self.length):\\n\\t\\t\\t\\t\\ttemp += s[i]\\n\\t\\t\\t\\t\\tif arr and int(arr[-1]) < int(temp):\\n\\t\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\t\\tif arr and int(arr[-1]) - int(temp) != 1:\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tself.helper(arr+[temp],s,i+1)\\n\\t\\t\\t\\treturn\\n\\n\\t\\t\\tif len(arr)>1:\\n\\t\\t\\t\\tself.ans = True",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef splitString(self, s: str) -> bool:\\n\\t\\t\\tself.ans = False\\n\\t\\t\\tself.length = len(s)\\n\\t\\t\\tself.helper([],s,0)\\n\\t\\t\\treturn self.ans\\n\\n\\t\\tdef helper(self,arr,s,ind):    \\n\\t\\t\\tif not self.ans and ind < self.length:\\n\\t\\t\\t\\ttemp = \\'\\'\\n\\t\\t\\t\\tfor i in range(ind,self.length):\\n\\t\\t\\t\\t\\ttemp += s[i]\\n\\t\\t\\t\\t\\tif arr and int(arr[-1]) < int(temp):\\n\\t\\t\\t\\t\\t\\treturn\\n\\t\\t\\t\\t\\tif arr and int(arr[-1]) - int(temp) != 1:\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tself.helper(arr+[temp],s,i+1)\\n\\t\\t\\t\\treturn\\n\\n\\t\\t\\tif len(arr)>1:\\n\\t\\t\\t\\tself.ans = True",
                "codeTag": "Java"
            },
            {
                "id": 3127835,
                "title": "python-simple-dfs",
                "content": "```python\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        \\n        def dfs(i, n, p):\\n            if i == len(s):\\n                return n > 1\\n\\n            r = False\\n            for j in range(i, len(s)):\\n                v = int(s[i:j+1])\\n\\n                if p is None or p - 1 == v:\\n                    if dfs(j + 1,  n + 1, v):\\n                        return True\\n\\n            return False\\n            \\n        return dfs(0, 0, None)\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        \\n        def dfs(i, n, p):\\n            if i == len(s):\\n                return n > 1\\n\\n            r = False\\n            for j in range(i, len(s)):\\n                v = int(s[i:j+1])\\n\\n                if p is None or p - 1 == v:\\n                    if dfs(j + 1,  n + 1, v):\\n                        return True\\n\\n            return False\\n            \\n        return dfs(0, 0, None)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2938172,
                "title": "python3-beats-95-87-with-o-n-2-solution",
                "content": "**Intuition**\\n        1.Assume all prefixes(all substrings starting from index 0) as first number\\n        2.Assign the first number as curr and find a number(next substring) greater than by 1 next to it\\n        3.if we can reach the end of the string return True at least theres is one possible case\\n        4.edge case string with a lot of zeros at the ending ... in this case if previous is one return True\\n\\n```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n\\n        for i in range(len(s)-1):\\n            curr = int(s[:i+1])\\n            k = j = i+1\\n\\n            while j < len(s):\\n                while j < len(s) and curr - int(s[k:j+1]) > 1:\\n                    j += 1\\n                if curr - int(s[k:j+1]) != 1:\\n                    break\\n                #edge case such as a number with a lot of ending zeros .... 200100,1000\\n                if curr == 1 and int(s[k:len(s)]) == 0:\\n                    j = len(s)\\n                curr = int(s[k:j+1])\\n                j += 1\\n                k = j\\n\\n            else:\\n                return True\\n            \\n        return False\\n        \\n        ```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n\\n        for i in range(len(s)-1):\\n            curr = int(s[:i+1])\\n            k = j = i+1\\n\\n            while j < len(s):\\n                while j < len(s) and curr - int(s[k:j+1]) > 1:\\n                    j += 1\\n                if curr - int(s[k:j+1]) != 1:\\n                    break\\n                #edge case such as a number with a lot of ending zeros .... 200100,1000\\n                if curr == 1 and int(s[k:len(s)]) == 0:\\n                    j = len(s)\\n                curr = int(s[k:j+1])\\n                j += 1\\n                k = j\\n\\n            else:\\n                return True\\n            \\n        return False\\n        \\n        ```",
                "codeTag": "Java"
            },
            {
                "id": 2728029,
                "title": "runtime-0-ms-faster-than-100-00-c-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    bool splitString(string s) \\n{   \\n    int idx=0;\\n    vector<long long int>v;\\n    return fun(s,idx,v);\\n}\\nlong long int maxval=99999999991;   //9999999998\\nbool fun(string &s,int idx,vector<long long int>&v)\\n{\\n\\tif(idx >= s.length())\\n\\t{\\n\\t\\tif(v.size()>=2)\\n\\t\\t{\\n\\t\\t\\tfor(int i=0;i<v.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcout<<v[i]<<\" \";\\n\\t\\t\\t}\\n\\t\\t\\tcout<<endl;\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n    long long int num=0;\\n\\tstring str=\"\";\\n\\t\\n\\tfor(int i=idx;i<s.length();i++)\\n\\t{\\n\\t\\tchar ch = s[i];\\n\\t\\t\\n\\t\\tnum = (num*10LL) + (ch-\\'0\\') + 0LL;\\n\\n\\t\\tstr.push_back(ch);\\n\\t\\t\\n\\t\\tif(num >= maxval)\\n\\t\\t{\\n\\t\\t    return false;\\n\\t\\t}\\n\\t\\t\\n\\t\\tif(v.size()==0)\\n\\t\\t{\\n\\t\\t\\tv.push_back(num);\\n\\t\\t\\tif(fun(s,i+1,v)==true)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\tv.pop_back();   //backtracking\\n\\t\\t}\\n\\t\\telse if(v.size()>0)\\n\\t\\t{\\n\\t\\t\\tlong long int currnum = num;\\n\\t\\t\\tlong long int lastnum = v[v.size()-1];\\n\\t\\t\\t\\n\\t\\t\\tif( (lastnum - currnum)==1 )\\n\\t\\t\\t{\\n\\t\\t\\t   v.push_back(num);\\n\\t\\t\\t   if(fun(s,i+1,v)==true)\\n\\t\\t\\t   {\\n\\t\\t\\t      return true;\\n\\t\\t\\t   }\\n\\t\\t\\t   v.pop_back();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn false;\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool splitString(string s) \\n{   \\n    int idx=0;\\n    vector<long long int>v;\\n    return fun(s,idx,v);\\n}\\nlong long int maxval=99999999991;   //9999999998\\nbool fun(string &s,int idx,vector<long long int>&v)\\n{\\n\\tif(idx >= s.length())\\n\\t{\\n\\t\\tif(v.size()>=2)\\n\\t\\t{\\n\\t\\t\\tfor(int i=0;i<v.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcout<<v[i]<<\" \";\\n\\t\\t\\t}\\n\\t\\t\\tcout<<endl;\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n    long long int num=0;\\n\\tstring str=\"\";\\n\\t\\n\\tfor(int i=idx;i<s.length();i++)\\n\\t{\\n\\t\\tchar ch = s[i];\\n\\t\\t\\n\\t\\tnum = (num*10LL) + (ch-\\'0\\') + 0LL;\\n\\n\\t\\tstr.push_back(ch);\\n\\t\\t\\n\\t\\tif(num >= maxval)\\n\\t\\t{\\n\\t\\t    return false;\\n\\t\\t}\\n\\t\\t\\n\\t\\tif(v.size()==0)\\n\\t\\t{\\n\\t\\t\\tv.push_back(num);\\n\\t\\t\\tif(fun(s,i+1,v)==true)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\tv.pop_back();   //backtracking\\n\\t\\t}\\n\\t\\telse if(v.size()>0)\\n\\t\\t{\\n\\t\\t\\tlong long int currnum = num;\\n\\t\\t\\tlong long int lastnum = v[v.size()-1];\\n\\t\\t\\t\\n\\t\\t\\tif( (lastnum - currnum)==1 )\\n\\t\\t\\t{\\n\\t\\t\\t   v.push_back(num);\\n\\t\\t\\t   if(fun(s,i+1,v)==true)\\n\\t\\t\\t   {\\n\\t\\t\\t      return true;\\n\\t\\t\\t   }\\n\\t\\t\\t   v.pop_back();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn false;\\n}\\n\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2639488,
                "title": "simple-backtracking-solution-0-ms-faster-than-100-00-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool func(string s,unsigned long long prev)\\n    {\\n\\t//If no string left then return true;\\n        if(s==\"\") return true; \\n\\t\\t//That splitting can happen at any position. so we iterate at each position\\n        for(int i=0;i<s.length();i++)\\n        {\\n\\t\\t\\t//if prev value is one more than current left partition then we check recursively for right substring and prev is updated to unsigned long long value of current left string\\n            if(stoull(s.substr(0,i+1))==prev-1) \\n                if(func(s.substr(i+1),prev-1)) \\n                    return true; \\n        }\\n\\t\\t//If nothing works we return false;\\n        return false;\\n    }\\n    bool splitString(string s) {       \\n        for(int i=0;i<s.length()-1;i++)\\n        {\\n            if(func(s.substr(i+1),stoull(s.substr(0,i+1)))) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool func(string s,unsigned long long prev)\\n    {\\n\\t//If no string left then return true;\\n        if(s==\"\") return true; \\n\\t\\t//That splitting can happen at any position. so we iterate at each position\\n        for(int i=0;i<s.length();i++)\\n        {\\n\\t\\t\\t//if prev value is one more than current left partition then we check recursively for right substring and prev is updated to unsigned long long value of current left string\\n            if(stoull(s.substr(0,i+1))==prev-1) \\n                if(func(s.substr(i+1),prev-1)) \\n                    return true; \\n        }\\n\\t\\t//If nothing works we return false;\\n        return false;\\n    }\\n    bool splitString(string s) {       \\n        for(int i=0;i<s.length()-1;i++)\\n        {\\n            if(func(s.substr(i+1),stoull(s.substr(0,i+1)))) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2077769,
                "title": "backtracking-explain",
                "content": "# Backtracking\\n\\n> from brute force step by step optimize\\n\\nOne picture is worth a thousand words.\\n\\n![image](https://assets.leetcode.com/users/images/fe3ec39b-79bf-408b-9843-08d513194b0b_1653619479.069864.png)\\n\\n\\n## 1. Solution1 Brute force DFS\\n\\nUse DFS generate all possible split substrings and check to descend.\\n\\n````\\n//\\t\\t\\t\\t\\t 1234\\n//     1,234\\t\\t 12,34\\t\\t123,4\\n// 1,2,34  1,23,4    12,3,4\\n// 1,2,3,4\\n\\n// S1:) TLE 182 / 196 test cases passed.\\nfunc splitString(s string) bool {\\n\\tif len(s) <= 1 {\\n\\t\\treturn false\\n\\t}\\n\\tres := make([][]int, 0)\\n\\tbacktrack(s, 0, &[]int{}, &res)\\n\\tfor _, lst := range res {\\n\\t\\tif isDescending(lst) {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n\\nfunc backtrack(s string, start int, tmp *[]int, res *[][]int) {\\n\\tif start == len(s) && len(*tmp) > 1 {\\n\\t\\tlst := make([]int, len(*tmp))\\n\\t\\tcopy(lst, *tmp)\\n\\t\\t*res = append(*res, lst)\\n\\t}\\n\\tfor i := start; i < len(s); i++ {\\n\\t\\tx, _ := strconv.Atoi(s[start : i+1])\\n\\t\\t*tmp = append(*tmp, x)\\n\\t\\tbacktrack(s, i+1, tmp, res)\\n\\t\\t*tmp = (*tmp)[:len(*tmp)-1]\\n\\t}\\n}\\n\\nfunc isDescending(lst []int) bool {\\n\\tif len(lst) < 2 {\\n\\t\\treturn false\\n\\t}\\n\\tfor i := 1; i < len(lst); i++ {\\n\\t\\tif lst[i-1]-lst[i] == 1 {\\n\\t\\t\\tcontinue\\n\\t\\t} else {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n\\n\\n````\\n\\n## 2. Optimize solution 1\\n\\nBecause solution 1 generates all possible substrings, there are many substrings\\nis not descend, so we drop this substring.\\n\\n```\\n// S2:) Optimize S1\\nfunc splitString(s string) bool {\\n\\tif len(s) <= 1 {\\n\\t\\treturn false\\n\\t}\\n\\treturn isDesc(s, 0, &[]int{})\\n}\\n\\n// Backtracking\\nfunc isDesc(s string, start int, tmp *[]int) bool {\\n\\tif start == len(s) {\\n\\t\\treturn len(*tmp) >= 2\\n\\t}\\n\\tfor i := start; i < len(s); i++ {\\n\\t\\tcurr, _ := strconv.Atoi(s[start : i+1])\\n\\t\\tif len(*tmp) == 0 || (*tmp)[len(*tmp)-1]-curr == 1 { // prev - curr == 1\\n\\t\\t\\t*tmp = append(*tmp, curr)\\n\\t\\t\\tif isDesc(s, i+1, tmp) {\\n\\t\\t\\t\\treturn true\\n\\t\\t\\t}\\n\\t\\t\\t*tmp = (*tmp)[:len(*tmp)-1]\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n\\n```\\n",
                "solutionTags": [
                    "Go",
                    "Backtracking"
                ],
                "code": "````\\n//\\t\\t\\t\\t\\t 1234\\n//     1,234\\t\\t 12,34\\t\\t123,4\\n// 1,2,34  1,23,4    12,3,4\\n// 1,2,3,4\\n\\n// S1:) TLE 182 / 196 test cases passed.\\nfunc splitString(s string) bool {\\n\\tif len(s) <= 1 {\\n\\t\\treturn false\\n\\t}\\n\\tres := make([][]int, 0)\\n\\tbacktrack(s, 0, &[]int{}, &res)\\n\\tfor _, lst := range res {\\n\\t\\tif isDescending(lst) {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n\\nfunc backtrack(s string, start int, tmp *[]int, res *[][]int) {\\n\\tif start == len(s) && len(*tmp) > 1 {\\n\\t\\tlst := make([]int, len(*tmp))\\n\\t\\tcopy(lst, *tmp)\\n\\t\\t*res = append(*res, lst)\\n\\t}\\n\\tfor i := start; i < len(s); i++ {\\n\\t\\tx, _ := strconv.Atoi(s[start : i+1])\\n\\t\\t*tmp = append(*tmp, x)\\n\\t\\tbacktrack(s, i+1, tmp, res)\\n\\t\\t*tmp = (*tmp)[:len(*tmp)-1]\\n\\t}\\n}\\n\\nfunc isDescending(lst []int) bool {\\n\\tif len(lst) < 2 {\\n\\t\\treturn false\\n\\t}\\n\\tfor i := 1; i < len(lst); i++ {\\n\\t\\tif lst[i-1]-lst[i] == 1 {\\n\\t\\t\\tcontinue\\n\\t\\t} else {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n\\n\\n```\n```\\n// S2:) Optimize S1\\nfunc splitString(s string) bool {\\n\\tif len(s) <= 1 {\\n\\t\\treturn false\\n\\t}\\n\\treturn isDesc(s, 0, &[]int{})\\n}\\n\\n// Backtracking\\nfunc isDesc(s string, start int, tmp *[]int) bool {\\n\\tif start == len(s) {\\n\\t\\treturn len(*tmp) >= 2\\n\\t}\\n\\tfor i := start; i < len(s); i++ {\\n\\t\\tcurr, _ := strconv.Atoi(s[start : i+1])\\n\\t\\tif len(*tmp) == 0 || (*tmp)[len(*tmp)-1]-curr == 1 { // prev - curr == 1\\n\\t\\t\\t*tmp = append(*tmp, curr)\\n\\t\\t\\tif isDesc(s, i+1, tmp) {\\n\\t\\t\\t\\treturn true\\n\\t\\t\\t}\\n\\t\\t\\t*tmp = (*tmp)[:len(*tmp)-1]\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2015681,
                "title": "javascript-concise-faster-than-100",
                "content": "Explanantion:\\nCreate a recursive function that accepts the following parameters:\\nprev: the prev number, initialised as null\\ni: the current starting index\\ncount: the count of numbers we identify from the string so far\\n\\nEach recursion, we aim to identify a substring that can be translated to a number that satisfies the criteria (i.e. number === prev-1), if that is possible, we recursively call the function split, until we reach the end of the string. \\n```\\nfunction splitString(s){\\n  \\n  function split(prev,i,count){\\n    if (i === s.length && count >= 2) return true\\n\\n    for (let j=i+1; j<=s.length; j++){\\n      const currNum = parseInt(s.slice(i,j))\\n      if (prev === null && currNum !== 0 || currNum === prev - 1){\\n        if (split(currNum,j,count+1)) return true\\n      }\\n    }\\n    return false\\n  }\\n  return split(null,0,0)\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nfunction splitString(s){\\n  \\n  function split(prev,i,count){\\n    if (i === s.length && count >= 2) return true\\n\\n    for (let j=i+1; j<=s.length; j++){\\n      const currNum = parseInt(s.slice(i,j))\\n      if (prev === null && currNum !== 0 || currNum === prev - 1){\\n        if (split(currNum,j,count+1)) return true\\n      }\\n    }\\n    return false\\n  }\\n  return split(null,0,0)\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1996679,
                "title": "javascript-backtracking-dfs-very-simple",
                "content": "```\\nvar splitString = function (s) {\\n    const len = s.length;\\n\\n    function dfs(idx, prev) {\\n        if (idx === len) return true;\\n\\n        for (let i = idx; i < len; i++) {\\n            const num = parseInt(s.substring(idx, i + 1));\\n            if (num === prev - 1 && dfs(i + 1, num)) return true;\\n        }\\n        return false;\\n    }\\n\\n    for (let i = 0; i < len - 1; i++) {\\n        const num = parseInt(s.substring(0, i + 1));\\n        if (dfs(i + 1, num)) return true;\\n    }\\n\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nvar splitString = function (s) {\\n    const len = s.length;\\n\\n    function dfs(idx, prev) {\\n        if (idx === len) return true;\\n\\n        for (let i = idx; i < len; i++) {\\n            const num = parseInt(s.substring(idx, i + 1));\\n            if (num === prev - 1 && dfs(i + 1, num)) return true;\\n        }\\n        return false;\\n    }\\n\\n    for (let i = 0; i < len - 1; i++) {\\n        const num = parseInt(s.substring(0, i + 1));\\n        if (dfs(i + 1, num)) return true;\\n    }\\n\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1973743,
                "title": "python-dfs-backtracking-simple-solution",
                "content": "DFS:\\n```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n\\t\\n        def DFS(index, prev):\\n\\t\\t\\t# base case: no character left to split\\n            if index == n:\\n                return True\\n\\t\\t\\t# split the left substrings\\n            for j in range(index, n):\\n                val = int(s[index:j+1])\\n                if prev - val == 1 and DFS(j+1, val):\\n                    return True\\n\\t\\t\\n\\t\\t# split s to get prev\\n\\t\\tn = len(s)\\n        for i in range(n-1):       # at least two substring\\n            val = int(s[:i+1])\\n            if DFS(i+1, val):\\n                return True\\n        return False \\n```\\n\\nBacktracking:\\n\\n```\\n    def splitString(self, s: str) -> bool:\\n        \\n        def backtrack(i, comb):\\n            if i == len(s) and len(comb) > 1:\\n                return True\\n            for j in range(i, len(s)):\\n                if not comb or comb[-1] - int(s[i:j+1]) == 1:\\n                    comb.append(int(s[i:j+1]))\\n                    if backtrack(j+1, comb):\\n                        return True\\n                    comb.pop()\\n            return False\\n\\n        return backtrack(0, [])\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n\\t\\n        def DFS(index, prev):\\n\\t\\t\\t# base case: no character left to split\\n            if index == n:\\n                return True\\n\\t\\t\\t# split the left substrings\\n            for j in range(index, n):\\n                val = int(s[index:j+1])\\n                if prev - val == 1 and DFS(j+1, val):\\n                    return True\\n\\t\\t\\n\\t\\t# split s to get prev\\n\\t\\tn = len(s)\\n        for i in range(n-1):       # at least two substring\\n            val = int(s[:i+1])\\n            if DFS(i+1, val):\\n                return True\\n        return False \\n```\n```\\n    def splitString(self, s: str) -> bool:\\n        \\n        def backtrack(i, comb):\\n            if i == len(s) and len(comb) > 1:\\n                return True\\n            for j in range(i, len(s)):\\n                if not comb or comb[-1] - int(s[i:j+1]) == 1:\\n                    comb.append(int(s[i:j+1]))\\n                    if backtrack(j+1, comb):\\n                        return True\\n                    comb.pop()\\n            return False\\n\\n        return backtrack(0, [])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1926166,
                "title": "c-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool dfs(int idx, unsigned long long t, string s){\\n        if(idx == s.size()) return 1;\\n        \\n        for(int j=idx; j<s.size(); j++){\\n            \\n            string suffix = s.substr(idx, j-idx+1);\\n            \\n            unsigned long long val =  stoull(suffix);\\n            \\n            if(val+1 == t and dfs(j+1, val, s)) return 1;\\n            \\n        }\\n        \\n        return 0;\\n    }\\n    \\n    bool splitString(string s) {\\n        \\n        int n = s.size();\\n        \\n        for(int i=0; i<n-1; i++){\\n            string prefix = s.substr(0,i+1);\\n            \\n            unsigned long long val =  stoull(prefix);\\n            \\n            if(dfs(i+1 , val, s)) return 1;\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool dfs(int idx, unsigned long long t, string s){\\n        if(idx == s.size()) return 1;\\n        \\n        for(int j=idx; j<s.size(); j++){\\n            \\n            string suffix = s.substr(idx, j-idx+1);\\n            \\n            unsigned long long val =  stoull(suffix);\\n            \\n            if(val+1 == t and dfs(j+1, val, s)) return 1;\\n            \\n        }\\n        \\n        return 0;\\n    }\\n    \\n    bool splitString(string s) {\\n        \\n        int n = s.size();\\n        \\n        for(int i=0; i<n-1; i++){\\n            string prefix = s.substr(0,i+1);\\n            \\n            unsigned long long val =  stoull(prefix);\\n            \\n            if(dfs(i+1 , val, s)) return 1;\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1915438,
                "title": "simple-solution-in-java-elegant-and-concise-100-faster",
                "content": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        return find(0, -1, s);\\n    }\\n    \\n    private boolean find(int index, long prevVal, String s){\\n        \\n        long currVal = 0;\\n        for(int i=index; i<s.length(); i++){\\n            currVal = currVal*10 + (long)(s.charAt(i) - \\'0\\');\\n            if(currVal >= 1_000_000_000_0L) return false; // As the max length is 20\\n            \\n            if(prevVal == -1){\\n                if(find(i+1, currVal, s)) return true;\\n                continue;\\n            }\\n            if(i == s.length() - 1){\\n                return prevVal - currVal == 1;\\n            }\\n            \\n            if(prevVal - currVal == 1){\\n                if(find(i+1, currVal, s)) return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        return find(0, -1, s);\\n    }\\n    \\n    private boolean find(int index, long prevVal, String s){\\n        \\n        long currVal = 0;\\n        for(int i=index; i<s.length(); i++){\\n            currVal = currVal*10 + (long)(s.charAt(i) - \\'0\\');\\n            if(currVal >= 1_000_000_000_0L) return false; // As the max length is 20\\n            \\n            if(prevVal == -1){\\n                if(find(i+1, currVal, s)) return true;\\n                continue;\\n            }\\n            if(i == s.length() - 1){\\n                return prevVal - currVal == 1;\\n            }\\n            \\n            if(prevVal - currVal == 1){\\n                if(find(i+1, currVal, s)) return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1740505,
                "title": "python-clean-recursive-solution",
                "content": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        @lru_cache(None)\\n        def helper(prev, s):\\n            if not s:\\n                return True\\n            \\n            for i in range(1, len(s)+1):\\n                x = int(s[:i])\\n\\n                if prev - x == 1:\\n                    if helper(x, s[i:]):\\n                        return True\\n            \\n            return False\\n        \\n        for i in range(1, len(s)):\\n            if helper(int(s[:i]), s[i:]):\\n                return True\\n        \\n        return False",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        @lru_cache(None)\\n        def helper(prev, s):\\n            if not s:\\n                return True\\n            \\n            for i in range(1, len(s)+1):\\n                x = int(s[:i])\\n\\n                if prev - x == 1:\\n                    if helper(x, s[i:]):\\n                        return True\\n            \\n            return False\\n        \\n        for i in range(1, len(s)):\\n            if helper(int(s[:i]), s[i:]):\\n                return True\\n        \\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 1723386,
                "title": "easy-peasy-backtracking-solution-c",
                "content": "class Solution {\\npublic:\\n    \\n    bool ans=false;\\n    void fun(string s, long long int prev, int count)\\n    {\\n        if(!s.length())\\n        {\\n            if(count>1)\\n                ans=true;\\n            return;\\n        }\\n        for(int i=0;i<s.length();i++)\\n        {\\n            string str=s.substr(0,i+1);\\n            long long int val=stoll(str);\\n            if(val>99999999999) // According to question, there should be atleast 2 substrings, that means atleast 2 values.\\n                break;          // The max length of string is 20 which means the length of max val of any substring shouldn\\'t be more than 10 \\n            if(prev==-1)\\n            {\\n                fun(s.substr(i+1),val,count+1);\\n            }\\n            else\\n            {\\n                if(val>=prev)\\n                    break;\\n                if((prev-val)==1)\\n                {\\n                    fun(s.substr(i+1),val,count+1);\\n                }\\n            }\\n        }\\n    }\\n    \\n    bool splitString(string s) { \\n        fun(s,-1,0); // s -> input string \\n        return ans;  // -1 -> previous value of the substring\\n    }                // 0 -> count to track number of substrings included\\n};",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    bool ans=false;\\n    void fun(string s, long long int prev, int count)\\n    {\\n        if(!s.length())\\n        {\\n            if(count>1)\\n                ans=true;\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1428460,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n   \\n    bool find(int index,long long int sum,string &s)\\n    {\\n        if(index>=s.size())\\n        {\\n            return 1;\\n        }\\n        long long int val=0;\\n        for(int i=index;i<s.size();i++)\\n        {\\n            val=val*10+(s[i]-\\'0\\');\\n            if(val>=1e11)\\n            {\\n                return 0;\\n            }\\n            if((sum-val==1)&&find(i+1,val,s))\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    bool splitString(string s) \\n    {\\n        long long int sum=0;\\n        for(int i=0;i<s.size()-1;i++)\\n        {\\n            sum=sum*10+(s[i]-\\'0\\');\\n            if(sum>=1e11)\\n            {\\n                return false;\\n            }\\n            if(find(i+1,sum,s))\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    bool find(int index,long long int sum,string &s)\\n    {\\n        if(index>=s.size())\\n        {\\n            return 1;\\n        }\\n        long long int val=0;\\n        for(int i=index;i<s.size();i++)\\n        {\\n            val=val*10+(s[i]-\\'0\\');\\n            if(val>=1e11)\\n            {\\n                return 0;\\n            }\\n            if((sum-val==1)&&find(i+1,val,s))\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    bool splitString(string s) \\n    {\\n        long long int sum=0;\\n        for(int i=0;i<s.size()-1;i++)\\n        {\\n            sum=sum*10+(s[i]-\\'0\\');\\n            if(sum>=1e11)\\n            {\\n                return false;\\n            }\\n            if(find(i+1,sum,s))\\n            {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1327432,
                "title": "simple-backtracking-solution",
                "content": "```\\nclass Solution {\\n    boolean backtrack(int index, String s, double prev, double diff){\\n        // true if reached end with diff as 1\\n        if (index == s.length() && diff == 1)\\n            return true;\\n        \\n        for (int i = index; i < s.length(); i++){\\n            double tmp = Double.parseDouble(s.substring(index, i+1));\\n            // check if diff is 1 or base case\\n            if (prev == -1 || prev - tmp == 1){\\n                if (backtrack(i+1, s, tmp, prev - tmp))\\n                    return true;\\n            }\\n            // avoid checking if diff is greater than 1\\n            else if (tmp - prev > 1)\\n                break;\\n        }\\n        return false;\\n    }\\n    \\n    public boolean splitString(String s) {\\n        return backtrack(0, s, -1, -1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    boolean backtrack(int index, String s, double prev, double diff){\\n        // true if reached end with diff as 1\\n        if (index == s.length() && diff == 1)\\n            return true;\\n        \\n        for (int i = index; i < s.length(); i++){\\n            double tmp = Double.parseDouble(s.substring(index, i+1));\\n            // check if diff is 1 or base case\\n            if (prev == -1 || prev - tmp == 1){\\n                if (backtrack(i+1, s, tmp, prev - tmp))\\n                    return true;\\n            }\\n            // avoid checking if diff is greater than 1\\n            else if (tmp - prev > 1)\\n                break;\\n        }\\n        return false;\\n    }\\n    \\n    public boolean splitString(String s) {\\n        return backtrack(0, s, -1, -1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1218541,
                "title": "c-backtracking-100-faster-small",
                "content": "```\\nclass Solution {\\npublic:\\n    bool helper(string s,unsigned long long prev){\\n      int n= s.size();\\n      if(n == 0){\\n        return true;\\n      }\\n      unsigned long long current = 0;\\n      for(int i=0;i<n;i++){\\n         current = current*10  + (s[i] - \\'0\\') ;\\n       if((i != n-1 && prev == -9999 || prev-current == 1)  && helper(s.substr(i+1,n-(i+1)),current))\\n          return true;\\n      }\\n      return false;\\n    }\\n    bool splitString(string s) {\\n      return helper(s,-9999);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool helper(string s,unsigned long long prev){\\n      int n= s.size();\\n      if(n == 0){\\n        return true;\\n      }\\n      unsigned long long current = 0;\\n      for(int i=0;i<n;i++){\\n         current = current*10  + (s[i] - \\'0\\') ;\\n       if((i != n-1 && prev == -9999 || prev-current == 1)  && helper(s.substr(i+1,n-(i+1)),current))\\n          return true;\\n      }\\n      return false;\\n    }\\n    bool splitString(string s) {\\n      return helper(s,-9999);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1203431,
                "title": "python-clean-backtracking-4-liner",
                "content": "```py\\ndef splitString(self, s: str, num=None) -> bool:\\n    if num is None:\\n        return any(self.splitString(s[i:], int(s[:i]) - 1) for i in range(1, len(s)))\\n    else:\\n        return len(s) == 0 or any(self.splitString(s[i:], num - 1) for i in range(1, len(s) + 1) if int(s[:i]) == num)\\n```\\n\\n1. Added extra optional **parameter**, or create another function.\\n2. Split strings into left(**current number**), right (recurse)\\n    a. if num is None (First function call), range(1, len(s)) to guarantees it has at least 2 parts.\\n    b. else, only recurse when **current number** is same as **parameter**. (base is when string is empty)\\n\\t",
                "solutionTags": [],
                "code": "```py\\ndef splitString(self, s: str, num=None) -> bool:\\n    if num is None:\\n        return any(self.splitString(s[i:], int(s[:i]) - 1) for i in range(1, len(s)))\\n    else:\\n        return len(s) == 0 or any(self.splitString(s[i:], num - 1) for i in range(1, len(s) + 1) if int(s[:i]) == num)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1188141,
                "title": "python-100",
                "content": "***Topic::\\nDynamic Programming\\nOwing to a really small string size (20), we split the string into tuples containing the current substring, the ending index(j) and the starting index(i) with a span of j - i + 1.\\nFor example, \"50049048\" is processed into\\n(5, 0, 0), (50, 1, 0), (500, 2, 0), (5004, 3, 0), (50049, 4, 0), (500490, 5, 0), (5004904, 6, 0), (50049048, 7, 0), (0, 0, 1), (00, 1, 1), ...\\nNow all you have to do is to check whether there exits a subsequence (a1, b1, c1),(a2, b2, c2), etc.. that matches the constraints below :: \\ni)    a1 - a2 = a2 - a3 = a3 - a4 = ... = 1 (strictly decreasing)\\nii)   b1 = c2 - 1, b2 = c3 - 1, b3 = c4 - 1, ... (the ending index of a former substring has to be 1 less than the starting index of the next substring)\\niii)  bn = len(s) - 1 (the last substring has to terminate at the very end)\\niv)   n is not equal to 1 (since we want to split s into atleast two such substrings)\\nNow, this problem clearly boils down to a O(n^2) dynamic programming problem, which is nothing but a clever brute force! Do consider upvoting if you like the explanation. Thanks.***\\n```\\nclass Solution:\\n    def solve(self, numbers, number):\\n        dp = []\\n        for i in range(len(numbers)):\\n            dp.append(0) if numbers[i][2] else dp.append(numbers[i][1] + 1)\\n            for j in range(i - 1, -1, -1):\\n                if numbers[j][2] == numbers[i][2]:\\n                    continue\\n                if numbers[i][0] == numbers[j][0] - 1 and numbers[i][2] == (numbers[j][1] + 1):\\n                    dp[i] = max(dp[i], dp[j] + numbers[i][1] - numbers[i][2] + 1)\\n\\n        for i, entry in enumerate(dp):\\n            if numbers[i][2] and entry == len(number):\\n                return True\\n        return False\\n                \\n        \\n    def splitString(self, s: str) -> bool:\\n        start = 0\\n        while start < len(s) and s[start] == \\'0\\':\\n            start += 1\\n        s = s[start:]\\n        numbers_seen_so_far = []\\n        for i in range(len(s)):\\n            for j in range(i + 1, len(s) + 1):\\n                numbers_seen_so_far.append((int(s[i : j]), j - 1, i))\\n\\n        return self.solve(numbers_seen_so_far, s)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def solve(self, numbers, number):\\n        dp = []\\n        for i in range(len(numbers)):\\n            dp.append(0) if numbers[i][2] else dp.append(numbers[i][1] + 1)\\n            for j in range(i - 1, -1, -1):\\n                if numbers[j][2] == numbers[i][2]:\\n                    continue\\n                if numbers[i][0] == numbers[j][0] - 1 and numbers[i][2] == (numbers[j][1] + 1):\\n                    dp[i] = max(dp[i], dp[j] + numbers[i][1] - numbers[i][2] + 1)\\n\\n        for i, entry in enumerate(dp):\\n            if numbers[i][2] and entry == len(number):\\n                return True\\n        return False\\n                \\n        \\n    def splitString(self, s: str) -> bool:\\n        start = 0\\n        while start < len(s) and s[start] == \\'0\\':\\n            start += 1\\n        s = s[start:]\\n        numbers_seen_so_far = []\\n        for i in range(len(s)):\\n            for j in range(i + 1, len(s) + 1):\\n                numbers_seen_so_far.append((int(s[i : j]), j - 1, i))\\n\\n        return self.solve(numbers_seen_so_far, s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1188042,
                "title": "python3-recursion-solution-for-reference",
                "content": "The question looks like permuations and split problem at first sight but if we dig into details strings is a bad way to deal with the problem since it consumes conversion. If we use the digit conversion method as below, it will help faster. \\n\\n1234 = (10** 3 * 1) + (10 ** 2 * 2) + (10**1 * 3) + (10 ** 0 * 4)) = 1000 + 200 + 30 + 4\\n\\nThe below variant uses recursion and moves forward only when it finds a value just 1 more than the base value. \\n```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        # convert the string into digits.\\n        s = [int(i) for i in list(s)]\\n        \\n        def r(base, index, nums):\\n\\t\\t\\t## increment power of 10. \\n            d = 0\\n\\t\\t\\t## accumulate the value for 10. \\n            acc = 0\\n            res = False\\n\\t\\t\\t## check the value from reverse from the index -1 where we calculated base.\\n            for x in range(index,-1,-1):\\n                acc += (10**d)*nums[x]\\n\\n                if base + 1 == acc:\\n                    if x-1 >= 0:\\n\\t\\t\\t\\t\\t\\t## collect recursion output\\n                        res = res or r(acc, x-1, s)\\n                    else:\\n                        res = True\\n                d+=1\\n            return res\\n                \\n        d = 0\\n        ans = False\\n        acc = 0\\n        ## same logic as recursion - just driver outside the recusion function. \\n\\t\\t## The logic below could possibly also be included ithe same recursion solution with some effort. \\n        for x in range(len(s)-1,-1,-1):\\n            acc += (10**d)*s[x]\\n            ans = ans or r(acc, x-1, s)\\n            d+=1\\n        return ans\\n```\\n#Runtime: 32 ms, faster than 100.00% of Python3 online submissions for Splitting a String Into Descending Consecutive Values.\\n#Memory Usage: 14.5 MB, less than 100.00% of Python3 online submissions for Splitting a String Into Descending Consecutive Values.",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        # convert the string into digits.\\n        s = [int(i) for i in list(s)]\\n        \\n        def r(base, index, nums):\\n\\t\\t\\t## increment power of 10. \\n            d = 0\\n\\t\\t\\t## accumulate the value for 10. \\n            acc = 0\\n            res = False\\n\\t\\t\\t## check the value from reverse from the index -1 where we calculated base.\\n            for x in range(index,-1,-1):\\n                acc += (10**d)*nums[x]\\n\\n                if base + 1 == acc:\\n                    if x-1 >= 0:\\n\\t\\t\\t\\t\\t\\t## collect recursion output\\n                        res = res or r(acc, x-1, s)\\n                    else:\\n                        res = True\\n                d+=1\\n            return res\\n                \\n        d = 0\\n        ans = False\\n        acc = 0\\n        ## same logic as recursion - just driver outside the recusion function. \\n\\t\\t## The logic below could possibly also be included ithe same recursion solution with some effort. \\n        for x in range(len(s)-1,-1,-1):\\n            acc += (10**d)*s[x]\\n            ans = ans or r(acc, x-1, s)\\n            d+=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1187861,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    bool dfs(string &s, int idx, long prev, int dep) {\\n        if (idx == s.size() && dep != 1)\\n            return true;\\n        long num = 0;\\n        for (int i = idx; i < s.size() && log10(num) < 10; i++) {\\n            num = 10 * num + s[i] - \\'0\\';\\n            if (prev == -1 || num == prev - 1) {\\n                if (dfs(s, i + 1, num, dep + 1))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n    bool splitString(string s) {\\n        return dfs(s, 0, -1, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(string &s, int idx, long prev, int dep) {\\n        if (idx == s.size() && dep != 1)\\n            return true;\\n        long num = 0;\\n        for (int i = idx; i < s.size() && log10(num) < 10; i++) {\\n            num = 10 * num + s[i] - \\'0\\';\\n            if (prev == -1 || num == prev - 1) {\\n                if (dfs(s, i + 1, num, dep + 1))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n    bool splitString(string s) {\\n        return dfs(s, 0, -1, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1187566,
                "title": "c-very-easy-to-understand-intuitive",
                "content": "```\\nclass Solution {\\n  public:\\n    bool f = false;\\n  void recurse(string & s, int start, vector < string > & v) {\\n    if (start == s.size()) {\\n      if (v.size() > 1) {\\n        bool pos = true;\\n        unsigned long long prev = stoull(v[0]);\\n        for (int i = 1; i < v.size(); i++) {\\n          unsigned long long curr = stoull(v[i]);\\n          if ((prev - curr) != 1) {\\n            pos = false;\\n            break;\\n          }\\n          prev = curr;\\n        }\\n        f |= pos;\\n      }\\n    }\\n\\n    for (int si = 1; si <= s.size() - start; si++) {\\n      v.push_back(s.substr(start, si));\\n      recurse(s, start + si, v);\\n      v.pop_back();\\n    }\\n  }\\n\\n  bool splitString(string s) {\\n    vector < string > v;\\n    recurse(s, 0, v);\\n    return f;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n  public:\\n    bool f = false;\\n  void recurse(string & s, int start, vector < string > & v) {\\n    if (start == s.size()) {\\n      if (v.size() > 1) {\\n        bool pos = true;\\n        unsigned long long prev = stoull(v[0]);\\n        for (int i = 1; i < v.size(); i++) {\\n          unsigned long long curr = stoull(v[i]);\\n          if ((prev - curr) != 1) {\\n            pos = false;\\n            break;\\n          }\\n          prev = curr;\\n        }\\n        f |= pos;\\n      }\\n    }\\n\\n    for (int si = 1; si <= s.size() - start; si++) {\\n      v.push_back(s.substr(start, si));\\n      recurse(s, start + si, v);\\n      v.pop_back();\\n    }\\n  }\\n\\n  bool splitString(string s) {\\n    vector < string > v;\\n    recurse(s, 0, v);\\n    return f;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186930,
                "title": "javascript-dp-with-explanation-o-n-2",
                "content": "For example:\\n`dp[i]`  = a set of last values that can be totally split = \\n- at least including one integer value from `s[i] to s[n-1]`\\n- other valid value which has a `j, j>=i+1, that s[i ... j-1] === dp[j] + 1`\\n\\nFinal condition: `dp[0].size>1`, since we want to split at least 2 nums.\\n\\n**For example:**\\n```text\\n050043   |   n = 6\\ndp[5] = {3}\\ndp[4] = {4, 43}\\ndp[3] = {4, 43}\\ndp[2] = {4, 43}\\ndp[1] = {5, 50043}\\ndp[0] = {5, 50043}\\n```\\n**JavaScript code:**\\n\\n```js\\nvar splitString = function(s) {\\n    var n = s.length;\\n    if(n<2)\\n    {\\n        return false;\\n    }\\n    var dp = new Array(n).fill(-1).map(el=>new Set());\\n    dp[n-1].add(parseInt(s[n-1])); \\n    for(var i = n-2; i>=0; i--)\\n    {\\n        for(var j=i+1; j<n;j++)\\n        {\\n            var cur = parseInt(s.slice(i,j));\\n            if(cur===0)\\n            {\\n                continue;\\n            }\\n            if(dp[j].size>=0 && dp[j].has(cur-1))\\n            {\\n                dp[i].add(cur);\\n            }\\n        }\\n        dp[i].add(parseInt(s.slice(i))); // Note: add substring s[i, n-1] after each index\\n    }\\n    return dp[0].size > 1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```text\\n050043   |   n = 6\\ndp[5] = {3}\\ndp[4] = {4, 43}\\ndp[3] = {4, 43}\\ndp[2] = {4, 43}\\ndp[1] = {5, 50043}\\ndp[0] = {5, 50043}\\n```\n```js\\nvar splitString = function(s) {\\n    var n = s.length;\\n    if(n<2)\\n    {\\n        return false;\\n    }\\n    var dp = new Array(n).fill(-1).map(el=>new Set());\\n    dp[n-1].add(parseInt(s[n-1])); \\n    for(var i = n-2; i>=0; i--)\\n    {\\n        for(var j=i+1; j<n;j++)\\n        {\\n            var cur = parseInt(s.slice(i,j));\\n            if(cur===0)\\n            {\\n                continue;\\n            }\\n            if(dp[j].size>=0 && dp[j].has(cur-1))\\n            {\\n                dp[i].add(cur);\\n            }\\n        }\\n        dp[i].add(parseInt(s.slice(i))); // Note: add substring s[i, n-1] after each index\\n    }\\n    return dp[0].size > 1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1186917,
                "title": "c-solution-using-simple-recursion",
                "content": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    //Max value of long long int . one can get it with use of LONG_MAX\\n    string LMAX=\"9223372036854775807\";\\n    // Converting string to long long int\\n    ll con(string &s){\\n        ll ans;\\n        int i=0;\\n        //For loop to determine index of first non-zero digit\\n        for(;i<(int)s.size();i++){\\n            if(s[i]==\\'0\\'){\\n                continue;\\n            }\\n            else\\n                break;\\n        }\\n        if(i==(int)s.size())\\n            return 0;\\n        string res=s.substr(i);\\n        ll sz=res.size();\\n        //if resultant string contains more than 19 digits: NOT POSSIBLE\\n        if(sz>19)\\n            return -1;\\n        bool f1=false;\\n        // if resultant string contains exactly 19 digits, we need to check whether it is smaller or larger than LONG_MAX\\n        if(sz==19){\\n            for(int i=0;i<sz;i++){\\n                if(res[i]>LMAX[i]){\\n                    if(f1==false){\\n                        return -1;\\n                    }\\n                }\\n                else if(res[i]<LMAX[i]){\\n                    f1=true;\\n                }\\n            }\\n            //If greater than LONG_MAX :-> NOT POSSIBLE\\n            if(!f1)\\n            return -1;\\n        }\\n        //convert string to long long int\\n        ans=stoll(res);\\n        return ans; \\n    }\\n    //ind -> current index, s-> original string, n-> size of string , prev-> previous number\\n    bool find(int ind,string &s,int &n,ll prev){\\n        //If we reach end of the string ,it means we got the answer\\n        if(ind==n){\\n            return true;\\n        }\\n        string z=\"\";\\n        bool res=false;\\n        for(int i=ind;i<n;i++){\\n            z+=s[i];\\n            ll num=con(z);\\n            //Check for descending order and difference of adjacent element should be 1, then only proceed forward\\n            if(prev-num==1){\\n                res=res or find(i+1,s,n,num);\\n            }\\n        }\\n        return res;\\n    }\\n    bool splitString(string s) {\\n        int n=s.size();\\n        bool res=false;\\n        string curr=\"\";\\n        if(n==1)\\n        {\\n            return false;\\n        }\\n        if(n==2){\\n            ll z=s[0]-\\'0\\';\\n            ll y=s[1]-\\'0\\';\\n            if(z-y==1){\\n                return true;\\n            }\\n            return false;\\n        }\\n        //We need to run the loop till n-1 only\\n        for(int i=0;i<n-1;i++){\\n            curr+=s[i];\\n            ll num=con(curr);\\n            res=res or find(i+1,s,n,num);\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    //Max value of long long int . one can get it with use of LONG_MAX\\n    string LMAX=\"9223372036854775807\";\\n    // Converting string to long long int\\n    ll con(string &s){\\n        ll ans;\\n        int i=0;\\n        //For loop to determine index of first non-zero digit\\n        for(;i<(int)s.size();i++){\\n            if(s[i]==\\'0\\'){\\n                continue;\\n            }\\n            else\\n                break;\\n        }\\n        if(i==(int)s.size())\\n            return 0;\\n        string res=s.substr(i);\\n        ll sz=res.size();\\n        //if resultant string contains more than 19 digits: NOT POSSIBLE\\n        if(sz>19)\\n            return -1;\\n        bool f1=false;\\n        // if resultant string contains exactly 19 digits, we need to check whether it is smaller or larger than LONG_MAX\\n        if(sz==19){\\n            for(int i=0;i<sz;i++){\\n                if(res[i]>LMAX[i]){\\n                    if(f1==false){\\n                        return -1;\\n                    }\\n                }\\n                else if(res[i]<LMAX[i]){\\n                    f1=true;\\n                }\\n            }\\n            //If greater than LONG_MAX :-> NOT POSSIBLE\\n            if(!f1)\\n            return -1;\\n        }\\n        //convert string to long long int\\n        ans=stoll(res);\\n        return ans; \\n    }\\n    //ind -> current index, s-> original string, n-> size of string , prev-> previous number\\n    bool find(int ind,string &s,int &n,ll prev){\\n        //If we reach end of the string ,it means we got the answer\\n        if(ind==n){\\n            return true;\\n        }\\n        string z=\"\";\\n        bool res=false;\\n        for(int i=ind;i<n;i++){\\n            z+=s[i];\\n            ll num=con(z);\\n            //Check for descending order and difference of adjacent element should be 1, then only proceed forward\\n            if(prev-num==1){\\n                res=res or find(i+1,s,n,num);\\n            }\\n        }\\n        return res;\\n    }\\n    bool splitString(string s) {\\n        int n=s.size();\\n        bool res=false;\\n        string curr=\"\";\\n        if(n==1)\\n        {\\n            return false;\\n        }\\n        if(n==2){\\n            ll z=s[0]-\\'0\\';\\n            ll y=s[1]-\\'0\\';\\n            if(z-y==1){\\n                return true;\\n            }\\n            return false;\\n        }\\n        //We need to run the loop till n-1 only\\n        for(int i=0;i<n-1;i++){\\n            curr+=s[i];\\n            ll num=con(curr);\\n            res=res or find(i+1,s,n,num);\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186879,
                "title": "js-easy-recursion",
                "content": "```\\nvar splitString = function(s) {\\n    let ret = false;\\n    \\n    const helper = (pos, count, pre) => {\\n        if (ret) return;\\n        if (pos == s.length && count >= 2) {\\n            ret = true;\\n            return;\\n        }\\n        for (let i = pos+1; i <= s.length; i++) {\\n            let n = parseInt(s.substring(pos, i));\\n            if (pre == n + 1 || count == 0) {\\n                helper(i, count+1, n);\\n            } else if (n > pre){\\n                break;\\n            }\\n        }\\n    }\\n    \\n    helper(0, 0, -1);\\n    return ret;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar splitString = function(s) {\\n    let ret = false;\\n    \\n    const helper = (pos, count, pre) => {\\n        if (ret) return;\\n        if (pos == s.length && count >= 2) {\\n            ret = true;\\n            return;\\n        }\\n        for (let i = pos+1; i <= s.length; i++) {\\n            let n = parseInt(s.substring(pos, i));\\n            if (pre == n + 1 || count == 0) {\\n                helper(i, count+1, n);\\n            } else if (n > pre){\\n                break;\\n            }\\n        }\\n    }\\n    \\n    helper(0, 0, -1);\\n    return ret;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1186875,
                "title": "python-3-top-down-dp",
                "content": "Time: `O(N^3)`\\nSpace: `O(N)`\\n```\\nimport functools\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        @functools.cache\\n        def dfs(ss: str, target: int) -> bool:\\n            if int(ss) == target: return True\\n            for i in range(1, len(ss)):\\n                curr, nxt = int(ss[:i]), ss[i:]\\n                if target == curr and dfs(nxt, curr - 1): return True\\n            return False\\n\\n        for i in range(1, len(s)):\\n            curr, nxt = int(s[:i]), s[i:]\\n            if dfs(nxt, curr - 1): return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nimport functools\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        @functools.cache\\n        def dfs(ss: str, target: int) -> bool:\\n            if int(ss) == target: return True\\n            for i in range(1, len(ss)):\\n                curr, nxt = int(ss[:i]), ss[i:]\\n                if target == curr and dfs(nxt, curr - 1): return True\\n            return False\\n\\n        for i in range(1, len(s)):\\n            curr, nxt = int(s[:i]), s[i:]\\n            if dfs(nxt, curr - 1): return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186852,
                "title": "python-dfs-backtracking-solution",
                "content": "Python DFS+backtracking solution\\n```\\nclass Solution(object):\\n    def splitString(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        def dfs(index, cur):\\n            \\n            if len(cur) > 1 and int(cur[-2]) - int(cur[-1]) != 1:\\n                return False\\n            if index == len(s):\\n                if len(cur) == 1:\\n                    return False\\n                return True\\n            for i in range(index, len(s)):\\n                cur.append(s[index:i+1])\\n                if dfs(i+1, cur):\\n                    return True\\n                cur.pop()\\n            return False\\n        \\n        return dfs(0, [])\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution(object):\\n    def splitString(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        def dfs(index, cur):\\n            \\n            if len(cur) > 1 and int(cur[-2]) - int(cur[-1]) != 1:\\n                return False\\n            if index == len(s):\\n                if len(cur) == 1:\\n                    return False\\n                return True\\n            for i in range(index, len(s)):\\n                cur.append(s[index:i+1])\\n                if dfs(i+1, cur):\\n                    return True\\n                cur.pop()\\n            return False\\n        \\n        return dfs(0, [])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186788,
                "title": "watch-out-for-trailing-zeros-like-100-no-recursion-o-n-2",
                "content": "\\u201C100\\u201D returns true as it can split into [\\u201C1\\u201D, \\u201C00\\u201D], wasted a lot of time during contest\\u2026\\n\\nIterative\\nFind next correct number, if reach the end of string then return True\\ni.e. 9897\\nthe code will first try 1 digit numbers: 9,8,9 -> wrong\\nthen try 2 digit numbers: 98, 97 -> correct\\n```\\nclass Solution(object):\\n    def splitString(self, s):\\n        # find next starting index if target is found, otherwise return -1\\n        def findIdx(s,startI,target):\\n            step = 1\\n            num = int(s[startI])\\n            while startI + step < len(s) and num < target:\\n                num = num * 10 + int(s[startI+step])\\n                step += 1\\n            if num == target:\\n                return startI + step\\n            return -1\\n        \\n        i = 1 # first i digit of s\\n        while i < len(s):\\n            next =  int(s[:i]) - 1 \\n            if next < 0:\\n                i += 1\\n                continue\\n\\t\\t\\t# finding next correct number until end of string\\n            j = i\\n            while j >= 0 and j < len(s):\\n                nextI = findIdx(s, j, next)\\n                if nextI == len(s): return True\\n                if nextI != -1 and int(s[j:nextI]) == next:\\n                    if next == 0 and all(s[v] == \"0\" for v in range(nextI, len(s))): return True # watch out here\\n                    next = next - 1\\n                j = nextI\\n            i += 1\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def splitString(self, s):\\n        # find next starting index if target is found, otherwise return -1\\n        def findIdx(s,startI,target):\\n            step = 1\\n            num = int(s[startI])\\n            while startI + step < len(s) and num < target:\\n                num = num * 10 + int(s[startI+step])\\n                step += 1\\n            if num == target:\\n                return startI + step\\n            return -1\\n        \\n        i = 1 # first i digit of s\\n        while i < len(s):\\n            next =  int(s[:i]) - 1 \\n            if next < 0:\\n                i += 1\\n                continue\\n\\t\\t\\t# finding next correct number until end of string\\n            j = i\\n            while j >= 0 and j < len(s):\\n                nextI = findIdx(s, j, next)\\n                if nextI == len(s): return True\\n                if nextI != -1 and int(s[j:nextI]) == next:\\n                    if next == 0 and all(s[v] == \"0\" for v in range(nextI, len(s))): return True # watch out here\\n                    next = next - 1\\n                j = nextI\\n            i += 1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186787,
                "title": "c-recursive-backtracking-faster-than-70-memory-less-than-80",
                "content": "Solved this problem using recursion. \\nThe helper recursive function is helper(input string, current index of the string, the last number that was made).\\nI would check whether the next digits of the number that is going to be created is one integer less than the last number, if so, I would update the last number and continue.\\nThe base conditions would determine the return statements.\\nAlso, used a lot of ```stod``` (string to double) function. Check it out! It is a cool function :P\\n```\\nclass Solution {\\npublic:\\n    bool splitString(string s) {\\n        return helper(s,0,-1);\\n    }\\n    bool helper (string & s , int ind , double last){\\n        // Base return cases\\n        if (ind >=s.size()){\\n            if (last==-1 ||  last==stod(s)){\\n                return false;\\n            }\\n            return true;\\n        }\\n\\t\\t// Check if the number to be created is the first number ever \\n        if (last == -1){\\n            for (int i = 1; i<=s.size()-ind; i++){\\n                if (helper(s,i,stod(s.substr(0,i)))){\\n                    return true;\\n                }\\n            }\\n            return false;\\n        }\\n\\t\\t// Check for the next numbers to be created\\n        for (int i = 1; i<=s.size()-ind; i++){\\n            if ( (double)last - stod(s.substr(ind,i)) == 1){\\n                if (helper(s,ind+i,stod(s.substr(ind,i)))){\\n                    return true;\\n                }\\n            }\\n            if ( (double)last - stod(s.substr(ind,i)) < 1 ){\\n                break;\\n            }\\n        }\\n\\t\\t// If we exit last loop, we should return false since we couldn\\'t create a number!\\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "```stod```",
                "codeTag": "Unknown"
            },
            {
                "id": 4068930,
                "title": "easy-explanation-beats-100",
                "content": "start building the current number, and make sure you go ahead in the recursion if and only if you are just 1 smaller than the previous number, and make sure you take atleast 2 step(i.e dividing in atleast 2 numbers).\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        return util1(s);\\n    }\\n    public boolean util1(String str) {\\n        return helper(str.toCharArray(), 0, -1,0);\\n    }\\n\\n    public boolean helper(char arr[], int index, long prev, int steps) {\\n        if (index == arr.length) {\\n            if(steps>1){\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }\\n        long current = 0;\\n        for (int i = index; i < arr.length; i++) {\\n            current = (current * 10) + (arr[i] - 48);\\n            if (current == prev-1 || prev == -1) {\\n                boolean smallAns = helper(arr, i + 1, current,steps+1);\\n                if (smallAns) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\nyou can check out my github repository where i am uploading famous interview questions topic wise with solutions.\\nlink-- https://github.com/Abhaydutt2003/DataStructureAndAlgoPractice \\nkindly upvote if you like my solution. you can ask doubts below.\\xAF\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        return util1(s);\\n    }\\n    public boolean util1(String str) {\\n        return helper(str.toCharArray(), 0, -1,0);\\n    }\\n\\n    public boolean helper(char arr[], int index, long prev, int steps) {\\n        if (index == arr.length) {\\n            if(steps>1){\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }\\n        long current = 0;\\n        for (int i = index; i < arr.length; i++) {\\n            current = (current * 10) + (arr[i] - 48);\\n            if (current == prev-1 || prev == -1) {\\n                boolean smallAns = helper(arr, i + 1, current,steps+1);\\n                if (smallAns) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990780,
                "title": "easy-solution-using-backtracking",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n\\n        def backtrack(index,prev):\\n            if index == len(s):\\n                return True\\n\\n            for j in range(index,len(s)):\\n                val = int(s[index:j+1])\\n                if val + 1 == prev and backtrack(j+1,val):\\n                    return True\\n            return False\\n\\n        for i in range(len(s)-1):\\n            val = int(s[:i+1])\\n            if backtrack(i+1,val) : return True\\n\\n        return False\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n\\n        def backtrack(index,prev):\\n            if index == len(s):\\n                return True\\n\\n            for j in range(index,len(s)):\\n                val = int(s[index:j+1])\\n                if val + 1 == prev and backtrack(j+1,val):\\n                    return True\\n            return False\\n\\n        for i in range(len(s)-1):\\n            val = int(s[:i+1])\\n            if backtrack(i+1,val) : return True\\n\\n        return False\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982510,
                "title": "recursive-java-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(2^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int count = 0;\\n    public boolean splitString(String s) {\\n        if (s.length() < 2) {\\n            return false;\\n        } else if (s.length() == 2) {\\n            if (Integer.valueOf(s.charAt(0)) - Integer.valueOf(s.charAt(1)) == 1) {\\n                return true;\\n            }\\n            return false;\\n        }\\n        for (int i = 1; i < s.length(); i++) {\\n            double prev = Double.valueOf(s.substring(0, i)); \\n            helper(s, i, prev); \\n        }\\n        return count >= 1;\\n    }\\n\\n    private void helper (String s, int index, double prev) {\\n        if (index == s.length()) {\\n            count++;\\n            return;\\n        }\\n        for (int i = 1; i <= s.length() - index; i++) {\\n            double curr = Double.valueOf(s.substring(index, index + i));\\n            if (prev - curr == 1) {\\n                helper(s, index + i, curr);\\n            } \\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    int count = 0;\\n    public boolean splitString(String s) {\\n        if (s.length() < 2) {\\n            return false;\\n        } else if (s.length() == 2) {\\n            if (Integer.valueOf(s.charAt(0)) - Integer.valueOf(s.charAt(1)) == 1) {\\n                return true;\\n            }\\n            return false;\\n        }\\n        for (int i = 1; i < s.length(); i++) {\\n            double prev = Double.valueOf(s.substring(0, i)); \\n            helper(s, i, prev); \\n        }\\n        return count >= 1;\\n    }\\n\\n    private void helper (String s, int index, double prev) {\\n        if (index == s.length()) {\\n            count++;\\n            return;\\n        }\\n        for (int i = 1; i <= s.length() - index; i++) {\\n            double curr = Double.valueOf(s.substring(index, index + i));\\n            if (prev - curr == 1) {\\n                helper(s, index + i, curr);\\n            } \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962338,
                "title": "python-backtracking-easy-solution",
                "content": "Code should be easy to understand\\n`start` is the starting index of `last`\\nfor example `s = \"050043\"`\\n`start` is 0, `end` is 3, `last = s[start:end+1]`, which is 5\\n```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        def dfs(i, start, last):\\n            if i == len(s):\\n                return start != 0 \\n            for j in range(i, len(s)):\\n                num = int(s[i:j + 1])\\n                if last == float(\"inf\") or last - num == 1:\\n                    if dfs(j + 1, i, num):\\n                        return True\\n            return False\\n        return dfs(0, 0, float(\"inf\"))\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        def dfs(i, start, last):\\n            if i == len(s):\\n                return start != 0 \\n            for j in range(i, len(s)):\\n                num = int(s[i:j + 1])\\n                if last == float(\"inf\") or last - num == 1:\\n                    if dfs(j + 1, i, num):\\n                        return True\\n            return False\\n        return dfs(0, 0, float(\"inf\"))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933574,
                "title": "python-95-simple-and-detailed-code-dfs",
                "content": "# Intuition\\nThe main idea of solving this problem is this idea of \"chunking\" your input string into every possible substring all the while keeping track of the remaining part of the string. These chunks of possible solution and remaining will be passed into futher recursive calls.\\n\\nI.E. take the string \"05004\" which should return true.\\nWe want to split this into every possible substring\\nChunk | Remaining\\n0     |  5004\\n05    |  004\\n050   |  04\\n0500  |  4\\n05004 |  _\\n\\nWe then \"bound/bind\" when we make futher recursive calls. In this case, we want each valid substring chunk to have a difference of 1.\\n\\nThus the current \"chunk\" we have becomes the previous value we pass into the recursive call. *This makes more sense when reading the code*\\n# Approach\\n*In-depth comments in the code*\\n\\n# Complexity\\n- Time complexity:\\n    The time complexity is O(2^N), where N is the length of the input string s.\\n\\n    Explanation:\\n\\n    The recursive function dfs(prev, remaining) explores all possible splits of the input string.\\nIn the worst case, each character can be a part of a split or not, leading to 2 possibilities per character.\\nSince you\\'re exploring all possible combinations of splits, the number of recursive calls grows exponentially with the length of the input string.\\n\\n- Space complexity:\\nThe space complexity of your code is O(N), where N is the length of the input string s.\\n\\n    Explanation:\\n\\n    The space used by the recursion stack is directly proportional to the depth of recursion.\\nSince the maximum depth of recursion is determined by the length of the input string, the space complexity is O(N).\\n\\n# Code\\n```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        # This is the dfs code\\n        # We pass in the previous value, and the remaining s\\n        # *Note*: It\\'s worth scrolling to the bottom where the DFS function\\n        # is called to see what the initial values are to have a better understanding\\n        def dfs(prev, remaining):\\n\\n            # if the length of the remaining string is zero we return false\\n            # this makes sure there is at least 2 seperate values as stated by the\\n            # problem: \"two or more non-empty substrings\"\\n            if len(remaining) == 0:\\n                return False\\n\\n            # Next we directly check if the remaining s once converted to a int is \\n            # 1 less then prev. If so we return true.\\n            # We know this to be valid because we only call recursive calls when\\n            # all previous values are descending and a difference of 1\\n            if int(remaining) == prev - 1:\\n                return True\\n\\n            # If we reach this spot then it is time to iterate acorss the remaining\\n            # search space\\n            # We iterate from across the length of the remaining string\\n            for i in range(len(remaining)):\\n\\n                # Create every single \"chunk\" of size i to check\\n                # Convert into an int\\n                chunk = int(remaining[:i+1])\\n\\n                # Grab the remaining part of the string and MAKE SURE TO NAME IT \\n                # DIFFERENTLY. This and chunk will be passed into the recursive call\\n                remaining2 = remaining[i+1:]\\n\\n                # We want to make sure that the \"chunk\" we have satisfies the difference\\n                # condition of 1, otherwise there is no point in making futher recursive\\n                # calls. Also, since we initialize the recursive call below with Infinity\\n                # we make sure to still make calls when there is no \"previous\" value\\n                if chunk == prev - 1 or prev == float(\"inf\"):\\n\\n                    # Make the recursive call using the chunk as the previous value, and \\n                    # passing in the new formed remaining2\\n                    # If the recursive call returns True, we make sure to return from this\\n                    # current recursive call as True\\n                    if dfs(chunk,remaining2):\\n                        return True\\n\\n            # If we reach the end of the function without returning True, then there must\\n            # be no valid splitting, thus return False\\n            return False\\n        \\n        # Make the initial call to the DFS function using Infinity as the prev value, and \\n        # the whole s as the \"remaining\"\\n        return dfs(float(\"inf\"),s)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        # This is the dfs code\\n        # We pass in the previous value, and the remaining s\\n        # *Note*: It\\'s worth scrolling to the bottom where the DFS function\\n        # is called to see what the initial values are to have a better understanding\\n        def dfs(prev, remaining):\\n\\n            # if the length of the remaining string is zero we return false\\n            # this makes sure there is at least 2 seperate values as stated by the\\n            # problem: \"two or more non-empty substrings\"\\n            if len(remaining) == 0:\\n                return False\\n\\n            # Next we directly check if the remaining s once converted to a int is \\n            # 1 less then prev. If so we return true.\\n            # We know this to be valid because we only call recursive calls when\\n            # all previous values are descending and a difference of 1\\n            if int(remaining) == prev - 1:\\n                return True\\n\\n            # If we reach this spot then it is time to iterate acorss the remaining\\n            # search space\\n            # We iterate from across the length of the remaining string\\n            for i in range(len(remaining)):\\n\\n                # Create every single \"chunk\" of size i to check\\n                # Convert into an int\\n                chunk = int(remaining[:i+1])\\n\\n                # Grab the remaining part of the string and MAKE SURE TO NAME IT \\n                # DIFFERENTLY. This and chunk will be passed into the recursive call\\n                remaining2 = remaining[i+1:]\\n\\n                # We want to make sure that the \"chunk\" we have satisfies the difference\\n                # condition of 1, otherwise there is no point in making futher recursive\\n                # calls. Also, since we initialize the recursive call below with Infinity\\n                # we make sure to still make calls when there is no \"previous\" value\\n                if chunk == prev - 1 or prev == float(\"inf\"):\\n\\n                    # Make the recursive call using the chunk as the previous value, and \\n                    # passing in the new formed remaining2\\n                    # If the recursive call returns True, we make sure to return from this\\n                    # current recursive call as True\\n                    if dfs(chunk,remaining2):\\n                        return True\\n\\n            # If we reach the end of the function without returning True, then there must\\n            # be no valid splitting, thus return False\\n            return False\\n        \\n        # Make the initial call to the DFS function using Infinity as the prev value, and \\n        # the whole s as the \"remaining\"\\n        return dfs(float(\"inf\"),s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3931564,
                "title": "o-n-n-time-o-n-space-solution-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are given a string of digits and need to split it into substrings such that the substrings are in descending order with a difference of 1 between the values that the adjacent substrings represent.\\n\\nUse backtracking to explore all possible splits and check if it is valid. A split is valid if the resulting substring values are in descending order and the difference is 1 i.e substring2 is 1 less than substring1.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- define a helper function for backtracking\\nbacktrack(current index, current partitions, previous substring value)\\n    - if the current index is the last, we have considered all digits, and check if we were able to split the string i.e current partitions >= 2\\n    - for each next digit including the current index digit\\n    - get the current substring value\\n    - if the previous substring value is greater or the difference between the previous and current is 1, backtrack to explore whether we can make another split. Return true if we can\\n    - if the loop completes without returning true, we can\\'t make any split, return false\\n- start backtracking from the first digit at index 0 and return the result\\n\\n# Complexity\\n- Time complexity: O(recursion breadth) \\u2192 O(calls at each levele ^ total levels) \\u2192 O(n$^n$) but the program runs much faster due to pruning \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(recursion stack) \\u2192 O(recursion depth/levels) \\u2192 O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n    \\n        def backtrack(i: int, k: int, prev: int) -> bool:\\n            if i == len(s):\\n                return k >= 2\\n            for j in range(i, len(s)):\\n                cur = int(s[i:j + 1])\\n                if prev == math.inf or cur == prev - 1:\\n                    if backtrack(j + 1, k + 1, cur):\\n                        return True\\n            return False\\n        \\n        return backtrack(0, 0, math.inf)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n    \\n        def backtrack(i: int, k: int, prev: int) -> bool:\\n            if i == len(s):\\n                return k >= 2\\n            for j in range(i, len(s)):\\n                cur = int(s[i:j + 1])\\n                if prev == math.inf or cur == prev - 1:\\n                    if backtrack(j + 1, k + 1, cur):\\n                        return True\\n            return False\\n        \\n        return backtrack(0, 0, math.inf)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905802,
                "title": "virendra-keshri-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    private:\\n    bool solve(int index,string &str,long long int val,int parts){\\n        if(index>=str.length()){\\n            if(parts>=2){\\n                return true;\\n            }\\n            return false;\\n        }\\n        long long int val1=0;\\n        for(int i=index;i<str.length();i++){\\n            int k=str[i]-\\'0\\';\\n            if(val1>=INT_MAX){\\n                break;\\n            }\\n            val1=(long long)((long long)(val1*10)+(long long)k);\\n            cout<<val1<<endl;\\n            if(parts==0){\\n                if(solve(i+1,str,val1,parts+1)){\\n                    return 1;\\n                }\\n            }\\n            else if((long long )val-1==(long long)val1){\\n                if(solve(i+1,str,val1,parts+1)){\\n                    return 1;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\npublic:\\n    bool splitString(string s) {\\n   bool ans=solve(0,s,0,0);\\n   return ans;\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    private:\\n    bool solve(int index,string &str,long long int val,int parts){\\n        if(index>=str.length()){\\n            if(parts>=2){\\n                return true;\\n            }\\n            return false;\\n        }\\n        long long int val1=0;\\n        for(int i=index;i<str.length();i++){\\n            int k=str[i]-\\'0\\';\\n            if(val1>=INT_MAX){\\n                break;\\n            }\\n            val1=(long long)((long long)(val1*10)+(long long)k);\\n            cout<<val1<<endl;\\n            if(parts==0){\\n                if(solve(i+1,str,val1,parts+1)){\\n                    return 1;\\n                }\\n            }\\n            else if((long long )val-1==(long long)val1){\\n                if(solve(i+1,str,val1,parts+1)){\\n                    return 1;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\npublic:\\n    bool splitString(string s) {\\n   bool ans=solve(0,s,0,0);\\n   return ans;\\n       \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3751353,
                "title": "using-front-partitioning",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    long StringToInt(String s, int j)\\n    {\\n        long digit = 0;\\n        for(int i = 0 ; i <= j ; i++)\\n            digit = digit * 10 + (int)(s.charAt(i) - \\'0\\');\\n        return digit;\\n    }\\n    boolean find(String s, long preValue, int count)\\n    {\\n        if(s.length() == 0)\\n        {\\n            if(count == 1)\\n                return false;\\n            return true;\\n        }\\n        for(int j = 0 ; j < s.length() ; j++)\\n        {\\n            long currvalue = StringToInt(s, j);\\n            if(preValue == -1 || preValue-currvalue == 1)\\n                if(find(s.substring(j+1), currvalue, count+1))\\n                    return true;\\n            else if(preValue != -1 && preValue-currvalue < 0)    \\n                return false;\\n        }\\n        return false;\\n    }\\n    public boolean splitString(String s) {\\n        return find(s, -1, 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    long StringToInt(String s, int j)\\n    {\\n        long digit = 0;\\n        for(int i = 0 ; i <= j ; i++)\\n            digit = digit * 10 + (int)(s.charAt(i) - \\'0\\');\\n        return digit;\\n    }\\n    boolean find(String s, long preValue, int count)\\n    {\\n        if(s.length() == 0)\\n        {\\n            if(count == 1)\\n                return false;\\n            return true;\\n        }\\n        for(int j = 0 ; j < s.length() ; j++)\\n        {\\n            long currvalue = StringToInt(s, j);\\n            if(preValue == -1 || preValue-currvalue == 1)\\n                if(find(s.substring(j+1), currvalue, count+1))\\n                    return true;\\n            else if(preValue != -1 && preValue-currvalue < 0)    \\n                return false;\\n        }\\n        return false;\\n    }\\n    public boolean splitString(String s) {\\n        return find(s, -1, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713139,
                "title": "elegant-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    bool solve(string& s,int n,long int w,int i){\\n        if(i>=n) return true;\\n        bool ans=false;\\n      for(int p=1;p<n-i+1;p++){\\n        string f=s.substr(i,p);\\n        long int d=stoul(f);\\n\\n        if(w-d==1){\\n         ans=ans|solve(s,n,d,i+p);\\n        }\\n      }\\n      return ans;\\n    }\\npublic:\\n    bool splitString(string s) {\\n        int n=s.length();\\n        bool ans;\\n        for(int i=0;i<n-1;i++){\\n            string l=s.substr(0,i+1);\\n           long int w=stoul(l);\\n            ans=ans|solve(s,n,w,i+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    bool solve(string& s,int n,long int w,int i){\\n        if(i>=n) return true;\\n        bool ans=false;\\n      for(int p=1;p<n-i+1;p++){\\n        string f=s.substr(i,p);\\n        long int d=stoul(f);\\n\\n        if(w-d==1){\\n         ans=ans|solve(s,n,d,i+p);\\n        }\\n      }\\n      return ans;\\n    }\\npublic:\\n    bool splitString(string s) {\\n        int n=s.length();\\n        bool ans;\\n        for(int i=0;i<n-1;i++){\\n            string l=s.substr(0,i+1);\\n           long int w=stoul(l);\\n            ans=ans|solve(s,n,w,i+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691119,
                "title": "python-backtracking",
                "content": "For the must be split into 2 or more substrings requirement we can just check that the last value is not equal to our full value, this works because even if the substring starts with 0 there are no valid follow up answers. We can just loop over our options and exit early if the value becomes larger than our previous.\\n\\n```py\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        al = int(s)\\n        \\n        \\n        def dfs(i,last):\\n            nonlocal al\\n            if i >= len(s):\\n                return last != al\\n            res = False\\n            for j in range(i, len(s)):\\n                v = int(s[i:j+1])\\n                if v < last:\\n                    if abs(last - v) == 1 or last == float(\\'inf\\'):\\n                        res = res or dfs(j + 1, int(s[i:j+1]))\\n                else:\\n                    break\\n            \\n            return res\\n        \\n        \\n        return dfs(0,float(\\'inf\\'))",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "For the must be split into 2 or more substrings requirement we can just check that the last value is not equal to our full value, this works because even if the substring starts with 0 there are no valid follow up answers. We can just loop over our options and exit early if the value becomes larger than our previous.\\n\\n```py\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        al = int(s)\\n        \\n        \\n        def dfs(i,last):\\n            nonlocal al\\n            if i >= len(s):\\n                return last != al\\n            res = False\\n            for j in range(i, len(s)):\\n                v = int(s[i:j+1])\\n                if v < last:\\n                    if abs(last - v) == 1 or last == float(\\'inf\\'):\\n                        res = res or dfs(j + 1, int(s[i:j+1]))\\n                else:\\n                    break\\n            \\n            return res\\n        \\n        \\n        return dfs(0,float(\\'inf\\'))",
                "codeTag": "Java"
            },
            {
                "id": 3652789,
                "title": "java-easier-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n*2^n)$$\\n\\n- Space complexity: $$O(n*2^n)$$\\n\\n# Code\\n```\\nimport java.math.*;\\nclass Solution {\\n    public boolean splitString(String s) {\\n      // I have used BigInteger over here because the long limit will break when the string length gets bigger\\n        return splitString(new BigInteger(\"-1\"), s, 0);\\n    }\\n\\n    private boolean splitString(BigInteger prevNum, String s, int part) {\\n      if (s.isEmpty() && part > 1) return true;\\n      for (int i = 0; i < s.length(); i++) {\\n        var currentNum = new BigInteger(s.substring(0, i + 1));\\n        if ((part == 0 || prevNum.subtract(currentNum).equals(new BigInteger(\"1\"))) && splitString(currentNum, s.substring(i + 1), part + 1)) {\\n          return true;\\n        }\\n      }\\n      return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Backtracking"
                ],
                "code": "```\\nimport java.math.*;\\nclass Solution {\\n    public boolean splitString(String s) {\\n      // I have used BigInteger over here because the long limit will break when the string length gets bigger\\n        return splitString(new BigInteger(\"-1\"), s, 0);\\n    }\\n\\n    private boolean splitString(BigInteger prevNum, String s, int part) {\\n      if (s.isEmpty() && part > 1) return true;\\n      for (int i = 0; i < s.length(); i++) {\\n        var currentNum = new BigInteger(s.substring(0, i + 1));\\n        if ((part == 0 || prevNum.subtract(currentNum).equals(new BigInteger(\"1\"))) && splitString(currentNum, s.substring(i + 1), part + 1)) {\\n          return true;\\n        }\\n      }\\n      return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602258,
                "title": "python3-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        def backtrack(currIdx, currVal):\\n            if currIdx == len(s) and currVal != int(s):\\n                return True\\n            for i in range(currIdx, len(s)):\\n                nextVal = int(s[currIdx:i + 1])\\n                if currVal == float(\\'inf\\') or (currVal - nextVal == 1):\\n                    if backtrack(i + 1, nextVal):\\n                        return True\\n            return False\\n\\n        return backtrack(0, float(\\'inf\\'))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        def backtrack(currIdx, currVal):\\n            if currIdx == len(s) and currVal != int(s):\\n                return True\\n            for i in range(currIdx, len(s)):\\n                nextVal = int(s[currIdx:i + 1])\\n                if currVal == float(\\'inf\\') or (currVal - nextVal == 1):\\n                    if backtrack(i + 1, nextVal):\\n                        return True\\n            return False\\n\\n        return backtrack(0, float(\\'inf\\'))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580108,
                "title": "python-simple-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def splitString(self, s):\\n\\n        def backtrack(s,path):\\n            if not s and len(path) >= 2:\\n                res.append(path)\\n\\n            for i in range(1,len(s)+1):\\n                if path and (int(s[:i]) > int(path[-1]) or (int(s[:i]) - int(path[-1]) != -1)):\\n                    continue\\n                backtrack(s[i:],path+[s[:i]])\\n\\n        res = []\\n        backtrack(s,[])\\n        return len(res) > 0\\n                \\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s):\\n\\n        def backtrack(s,path):\\n            if not s and len(path) >= 2:\\n                res.append(path)\\n\\n            for i in range(1,len(s)+1):\\n                if path and (int(s[:i]) > int(path[-1]) or (int(s[:i]) - int(path[-1]) != -1)):\\n                    continue\\n                backtrack(s[i:],path+[s[:i]])\\n\\n        res = []\\n        backtrack(s,[])\\n        return len(res) > 0\\n                \\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490389,
                "title": "c-recursive-solution-o-n-2",
                "content": "```\\n    bool CanSplit(string_view s, uint64_t prev)\\n    {\\n        if (s.empty()) return true;\\n        if (prev == 0) return false;\\n        if (prev == 1) return s.find_first_not_of(\\'0\\') == string_view::npos;\\n\\n        uint64_t curr{ 0 };\\n        while (!s.empty() && curr < prev - 1)\\n        {        \\n            curr = curr * 10 + (s[0] - \\'0\\');\\n            s.remove_prefix(1);            \\n        }\\n\\n        return curr == prev - 1? CanSplit(s, curr) : false;\\n    }\\n\\n    bool splitString(string_view s) \\n    {\\n        uint64_t curr{ 0 };\\n        while (s.size() > 1)\\n        {\\n            curr = curr * 10 + (s[0] - \\'0\\');\\n            s.remove_prefix(1);\\n\\n            if (CanSplit(s, curr)) return true;\\n        }\\n\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    bool CanSplit(string_view s, uint64_t prev)\\n    {\\n        if (s.empty()) return true;\\n        if (prev == 0) return false;\\n        if (prev == 1) return s.find_first_not_of(\\'0\\') == string_view::npos;\\n\\n        uint64_t curr{ 0 };\\n        while (!s.empty() && curr < prev - 1)\\n        {        \\n            curr = curr * 10 + (s[0] - \\'0\\');\\n            s.remove_prefix(1);            \\n        }\\n\\n        return curr == prev - 1? CanSplit(s, curr) : false;\\n    }\\n\\n    bool splitString(string_view s) \\n    {\\n        uint64_t curr{ 0 };\\n        while (s.size() > 1)\\n        {\\n            curr = curr * 10 + (s[0] - \\'0\\');\\n            s.remove_prefix(1);\\n\\n            if (CanSplit(s, curr)) return true;\\n        }\\n\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3410090,
                "title": "python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->Check if every digit segments are in decreasing order and differ by one\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBacktracking\\n# Complexity\\n- Time complexity: O(n^2)/n! (?)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        def backtrack(prevSum,i,segmentCount):\\n            if i==len(s) and segmentCount > 1:\\n                return True\\n            \\n            currSum=0\\n            for j in range(i,len(s)):\\n                currSum=currSum*10+ord(s[j])-ord(\\'0\\')\\n                if (prevSum==-1 or currSum==prevSum-1) and \\\\\\n                    backtrack(currSum,j+1,segmentCount+1):\\n                    return True\\n            return False\\n        return backtrack(-1,0,0)\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        def backtrack(prevSum,i,segmentCount):\\n            if i==len(s) and segmentCount > 1:\\n                return True\\n            \\n            currSum=0\\n            for j in range(i,len(s)):\\n                currSum=currSum*10+ord(s[j])-ord(\\'0\\')\\n                if (prevSum==-1 or currSum==prevSum-1) and \\\\\\n                    backtrack(currSum,j+1,segmentCount+1):\\n                    return True\\n            return False\\n        return backtrack(-1,0,0)\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3403221,
                "title": "splitting-a-string-into-descending-consecutive-values-leetcode-java-solution-by-priyanka",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nRecusive, Backtracking approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(2^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public Boolean dfs(List<Long> list,String str,int start){\\n        if(start == str.length()){\\n            return list.size()>=2;\\n        }\\n        long num=0;\\n        for(int i= start;i<str.length();i++){\\n            num=num*10+str.charAt(i)-\\'0\\';\\n            if(list.size() == 0 || list.get(list.size()-1) - num == 1){\\n                list.add(num);\\n                if(dfs(list,str,i+1)) return true;\\n                list.remove(list.size() - 1); \\n            }\\n        }\\n        return false;\\n    }\\n\\n    public boolean splitString(String s) {\\n        return dfs(new ArrayList<>(),s,0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public Boolean dfs(List<Long> list,String str,int start){\\n        if(start == str.length()){\\n            return list.size()>=2;\\n        }\\n        long num=0;\\n        for(int i= start;i<str.length();i++){\\n            num=num*10+str.charAt(i)-\\'0\\';\\n            if(list.size() == 0 || list.get(list.size()-1) - num == 1){\\n                list.add(num);\\n                if(dfs(list,str,i+1)) return true;\\n                list.remove(list.size() - 1); \\n            }\\n        }\\n        return false;\\n    }\\n\\n    public boolean splitString(String s) {\\n        return dfs(new ArrayList<>(),s,0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396087,
                "title": "c-recursive-brute-force-string-subtraction-and-comparison-code-for-beginners",
                "content": "```\\nclass Solution {\\npublic:\\n    string Trimmer(string &str){  // to remove trailing zeros\\n        int i=0;\\n        while(i<str.size() && str[i]==\\'0\\'){\\n            i++;\\n        }\\n        return str.substr(i);\\n    }\\n    \\n    bool isSmaller(string str1, string str2){\\n        str1=Trimmer(str1);\\n        str2=Trimmer(str2);\\n        \\n        int n1=str1.size();\\n        int n2=str2.size();\\n \\n        if(n1<n2){\\n            return true;\\n        }\\n        if(n2<n1){\\n            return false;\\n        } \\n        \\n        for(int i=0;i<n1;i++){\\n            if(str1[i]<str2[i]){\\n                return true;\\n            }\\n            if(str1[i]>str2[i]){\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n \\n    string findDiff(string str1, string str2){\\n        if(isSmaller(str1,str2)==true){\\n            return \"-1\";\\n        }\\n        \\n        str1=Trimmer(str1);\\n        str2=Trimmer(str2);\\n\\n        string str=\"\";\\n \\n        int n1=str1.size();\\n        int n2=str2.size();\\n \\n        reverse(str1.begin(),str1.end());\\n        reverse(str2.begin(),str2.end());\\n \\n        int carry=0;\\n        for(int i=0;i<n2;i++){\\n            int sub=(str1[i]-\\'0\\')-(str2[i]-\\'0\\')-carry;\\n            if(sub<0){\\n                sub=sub+10;\\n                carry=1;\\n            }\\n            else{\\n                carry=0;\\n            }\\n            str.push_back(sub + \\'0\\');\\n        }\\n        \\n        for(int i=n2;i<n1;i++){\\n            int sub=(str1[i]-\\'0\\')-carry;\\n            if(sub<0){\\n                sub=sub+10;\\n                carry=1;\\n            }\\n            else{\\n                carry=0;\\n            }\\n            str.push_back(sub+\\'0\\');\\n        }\\n\\n        reverse(str.begin(),str.end());\\n\\n        return Trimmer(str);\\n    }\\n    \\n    bool helper(string &s, int curr, string prevNum){\\n        if(curr==s.size()){\\n            return true;\\n        }\\n        string currNum=\"\";\\n        for(int i=curr;i<s.size();i++){\\n            currNum+=s[i];\\n            if(findDiff(prevNum,currNum)==\"1\" && helper(s,i+1,currNum)==true){\\n                return true;\\n            }\\n        }\\n        return false;\\n    } \\n    \\n    bool splitString(string s) {\\n        string num=\"\";\\n        for(int i=0;i<s.size()-1;i++){\\n            num+=s[i];\\n            if(helper(s,i+1,num)==true){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string Trimmer(string &str){  // to remove trailing zeros\\n        int i=0;\\n        while(i<str.size() && str[i]==\\'0\\'){\\n            i++;\\n        }\\n        return str.substr(i);\\n    }\\n    \\n    bool isSmaller(string str1, string str2){\\n        str1=Trimmer(str1);\\n        str2=Trimmer(str2);\\n        \\n        int n1=str1.size();\\n        int n2=str2.size();\\n \\n        if(n1<n2){\\n            return true;\\n        }\\n        if(n2<n1){\\n            return false;\\n        } \\n        \\n        for(int i=0;i<n1;i++){\\n            if(str1[i]<str2[i]){\\n                return true;\\n            }\\n            if(str1[i]>str2[i]){\\n                return false;\\n            }\\n        }\\n        return false;\\n    }\\n \\n    string findDiff(string str1, string str2){\\n        if(isSmaller(str1,str2)==true){\\n            return \"-1\";\\n        }\\n        \\n        str1=Trimmer(str1);\\n        str2=Trimmer(str2);\\n\\n        string str=\"\";\\n \\n        int n1=str1.size();\\n        int n2=str2.size();\\n \\n        reverse(str1.begin(),str1.end());\\n        reverse(str2.begin(),str2.end());\\n \\n        int carry=0;\\n        for(int i=0;i<n2;i++){\\n            int sub=(str1[i]-\\'0\\')-(str2[i]-\\'0\\')-carry;\\n            if(sub<0){\\n                sub=sub+10;\\n                carry=1;\\n            }\\n            else{\\n                carry=0;\\n            }\\n            str.push_back(sub + \\'0\\');\\n        }\\n        \\n        for(int i=n2;i<n1;i++){\\n            int sub=(str1[i]-\\'0\\')-carry;\\n            if(sub<0){\\n                sub=sub+10;\\n                carry=1;\\n            }\\n            else{\\n                carry=0;\\n            }\\n            str.push_back(sub+\\'0\\');\\n        }\\n\\n        reverse(str.begin(),str.end());\\n\\n        return Trimmer(str);\\n    }\\n    \\n    bool helper(string &s, int curr, string prevNum){\\n        if(curr==s.size()){\\n            return true;\\n        }\\n        string currNum=\"\";\\n        for(int i=curr;i<s.size();i++){\\n            currNum+=s[i];\\n            if(findDiff(prevNum,currNum)==\"1\" && helper(s,i+1,currNum)==true){\\n                return true;\\n            }\\n        }\\n        return false;\\n    } \\n    \\n    bool splitString(string s) {\\n        string num=\"\";\\n        for(int i=0;i<s.size()-1;i++){\\n            num+=s[i];\\n            if(helper(s,i+1,num)==true){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3387724,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool rec(int ind,string &s,vector<long long>&temp)\\n    {\\n        if (ind==s.size()){ \\n            if (temp.size()>1)\\n            return true;\\n            return false;\\n            }\\n        long long val=0;\\n        for (int i=ind;i<s.size();i++)\\n        {\\n            val=val*10 + (long long)(s[i]-\\'0\\');\\n            if (val>1e13 || (temp.size()>1 && val>=temp.back())) return false;\\n            if (temp.size()==0 || temp.back()-val==1)\\n            {\\n                temp.push_back(val);\\n                if (rec(i+1,s,temp)) return true;\\n                temp.pop_back();\\n            }\\n        }\\n        return false;\\n    }\\n    bool splitString(string s) \\n    {\\n        vector<long long>temp;\\n        return rec(0,s,temp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool rec(int ind,string &s,vector<long long>&temp)\\n    {\\n        if (ind==s.size()){ \\n            if (temp.size()>1)\\n            return true;\\n            return false;\\n            }\\n        long long val=0;\\n        for (int i=ind;i<s.size();i++)\\n        {\\n            val=val*10 + (long long)(s[i]-\\'0\\');\\n            if (val>1e13 || (temp.size()>1 && val>=temp.back())) return false;\\n            if (temp.size()==0 || temp.back()-val==1)\\n            {\\n                temp.push_back(val);\\n                if (rec(i+1,s,temp)) return true;\\n                temp.pop_back();\\n            }\\n        }\\n        return false;\\n    }\\n    bool splitString(string s) \\n    {\\n        vector<long long>temp;\\n        return rec(0,s,temp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3383493,
                "title": "0ms-c-backtracking",
                "content": "\\n```\\nclass Solution {\\n    unordered_map<string , bool> m;\\npublic:\\n    Solution():m{}{}\\n    bool dfs(int index , string& s ,unsigned long long  prevN ,string prevS){\\n        if(index == s.size()){\\n            //cout << prevN << \" \" << s  << endl ;\\n         \\n            if( prevS == s ) return false;\\n            return true;\\n        }\\n        //if(s.size() - index <= index) return false ;\\n        //if(m.find(s) != m.end()) return m[s];\\n        string st{}; int sze = s.size(); bool flag{false};\\n        for(int i = index ; i < sze ; i++){\\n            st+= s[i];\\n            if(st.size() <=19)\\n            if(( prevN == INT_MIN || (prevN > stoull(st,nullptr , 10) && (prevN - stoull(st,nullptr , 10) ) == 1) ))    \\n                 flag = flag || dfs(i + 1 , s , stoull(st,nullptr , 10)  , st);  \\n \\n     \\n        }\\n        return flag ; \\n\\n    }\\n    bool splitString(string s) {\\n        return dfs(0 , s , INT_MIN , \"\");\\n    }\\n}; \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    unordered_map<string , bool> m;\\npublic:\\n    Solution():m{}{}\\n    bool dfs(int index , string& s ,unsigned long long  prevN ,string prevS){\\n        if(index == s.size()){\\n            //cout << prevN << \" \" << s  << endl ;\\n         \\n            if( prevS == s ) return false;\\n            return true;\\n        }\\n        //if(s.size() - index <= index) return false ;\\n        //if(m.find(s) != m.end()) return m[s];\\n        string st{}; int sze = s.size(); bool flag{false};\\n        for(int i = index ; i < sze ; i++){\\n            st+= s[i];\\n            if(st.size() <=19)\\n            if(( prevN == INT_MIN || (prevN > stoull(st,nullptr , 10) && (prevN - stoull(st,nullptr , 10) ) == 1) ))    \\n                 flag = flag || dfs(i + 1 , s , stoull(st,nullptr , 10)  , st);  \\n \\n     \\n        }\\n        return flag ; \\n\\n    }\\n    bool splitString(string s) {\\n        return dfs(0 , s , INT_MIN , \"\");\\n    }\\n}; \\n```",
                "codeTag": "C++"
            },
            {
                "id": 3365569,
                "title": "python-backtracking-solution-with-explanation",
                "content": "```python\\n\\'\\'\\'\\nenumerate all of possible way to split string.\\ntrack stores numbers we have splited from string.\\ndfs(i) split string from position i to the end.\\nif pisition i is at the end and size of track > 1, return True\\nif pisition i is at the end and size of track == 1, return False\\n\\nwe can split string[i:] at the postion j >= i, seperated string is s[i: j+1], and turn into integer.\\nif track is empty, put integer into track, go to dfs(j+1), notice that poping track with backtrack\\nif integer == last number of track -1, go to dfs(j+1), notice that poping track with backtrack\\n\\nif there has no valid way to split string, return False\\n\\ntc is O(n^2), sc is O(n)\\n\\'\\'\\'\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        track = []\\n        def dfs(i):\\n            if i == len(s):\\n                if len(track) > 1: return True\\n                return False\\n\\n            for j in range(i, len(s)):\\n                num = int(s[i: j+1])\\n                if len(track) == 0 or (track[-1] - 1 == num):\\n                    track.append(num)\\n                    if dfs(j+1): return True\\n                    track.pop()\\n            return False\\n\\n        return dfs(0)   \\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```python\\n\\'\\'\\'\\nenumerate all of possible way to split string.\\ntrack stores numbers we have splited from string.\\ndfs(i) split string from position i to the end.\\nif pisition i is at the end and size of track > 1, return True\\nif pisition i is at the end and size of track == 1, return False\\n\\nwe can split string[i:] at the postion j >= i, seperated string is s[i: j+1], and turn into integer.\\nif track is empty, put integer into track, go to dfs(j+1), notice that poping track with backtrack\\nif integer == last number of track -1, go to dfs(j+1), notice that poping track with backtrack\\n\\nif there has no valid way to split string, return False\\n\\ntc is O(n^2), sc is O(n)\\n\\'\\'\\'\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        track = []\\n        def dfs(i):\\n            if i == len(s):\\n                if len(track) > 1: return True\\n                return False\\n\\n            for j in range(i, len(s)):\\n                num = int(s[i: j+1])\\n                if len(track) == 0 or (track[-1] - 1 == num):\\n                    track.append(num)\\n                    if dfs(j+1): return True\\n                    track.pop()\\n            return False\\n\\n        return dfs(0)   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3304423,
                "title": "c-solution-fast-solution-easy-solution",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n    public bool SplitString(string s) {\\n\\n        bool solve(int idx,long prev){\\n            if(idx >= s.Length) return true;\\n            for(int i = 1;i <= s.Length - idx;i++){\\n                string val = s.Substring(idx,i).TrimStart(\\'0\\');\\n                if(val.Length > 11)break;\\n                long cur = (val.Length == 0)? 0 : Int64.Parse(val);\\n                if(cur + 1 == prev && solve(idx + i,cur)) return true;        \\n            }\\n            return false;\\n        }\\n\\n        s = s.TrimStart(\\'0\\');\\n        for(int i = 1;i < s.Length;i++){\\n            string s2 = s.Substring(0,i);\\n            if(s2.Length > 11)break;\\n            if(solve(i,Int64.Parse(s2))) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Backtracking"
                ],
                "code": "```\\npublic class Solution {\\n    public bool SplitString(string s) {\\n\\n        bool solve(int idx,long prev){\\n            if(idx >= s.Length) return true;\\n            for(int i = 1;i <= s.Length - idx;i++){\\n                string val = s.Substring(idx,i).TrimStart(\\'0\\');\\n                if(val.Length > 11)break;\\n                long cur = (val.Length == 0)? 0 : Int64.Parse(val);\\n                if(cur + 1 == prev && solve(idx + i,cur)) return true;        \\n            }\\n            return false;\\n        }\\n\\n        s = s.TrimStart(\\'0\\');\\n        for(int i = 1;i < s.Length;i++){\\n            string s2 = s.Substring(0,i);\\n            if(s2.Length > 11)break;\\n            if(solve(i,Int64.Parse(s2))) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207625,
                "title": "typescript-recursion",
                "content": "# Code\\n```\\nfunction splitString(s) {\\n    return recSplitStr(\\'\\', s) ? true : false;\\n};\\n\\nfunction recSplitStr(p, up) {\\n    debugger;\\n    if (up == \\'\\') {\\n        return true;\\n    }\\n    if (p != \"\" && +p == 0 && +up == 0) {\\n        return true;\\n    }\\n    let flag = false;\\n    for (let i = 0; i < ((p == \"\") ? up.length - 1 : up.length); i++) {\\n        let pNew = up.substring(0, i + 1)\\n        let upNew = up.substring(i + 1, up.length)\\n\\n        if (+pNew != 0 && p == \"\") {\\n            flag = flag || recSplitStr(pNew, upNew) ? true : false;\\n        }\\n        if (+p == 1 && +pNew == 0) {\\n            flag = flag || recSplitStr(pNew, upNew) ? true : false;\\n        } \\n        else if (+pNew != 0 && (+p - +pNew == 1)) {\\n            flag = flag || recSplitStr(pNew, upNew) ? true : false;\\n        }\\n    }\\n    return flag;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction splitString(s) {\\n    return recSplitStr(\\'\\', s) ? true : false;\\n};\\n\\nfunction recSplitStr(p, up) {\\n    debugger;\\n    if (up == \\'\\') {\\n        return true;\\n    }\\n    if (p != \"\" && +p == 0 && +up == 0) {\\n        return true;\\n    }\\n    let flag = false;\\n    for (let i = 0; i < ((p == \"\") ? up.length - 1 : up.length); i++) {\\n        let pNew = up.substring(0, i + 1)\\n        let upNew = up.substring(i + 1, up.length)\\n\\n        if (+pNew != 0 && p == \"\") {\\n            flag = flag || recSplitStr(pNew, upNew) ? true : false;\\n        }\\n        if (+p == 1 && +pNew == 0) {\\n            flag = flag || recSplitStr(pNew, upNew) ? true : false;\\n        } \\n        else if (+pNew != 0 && (+p - +pNew == 1)) {\\n            flag = flag || recSplitStr(pNew, upNew) ? true : false;\\n        }\\n    }\\n    return flag;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3182788,
                "title": "c",
                "content": "```\\nusing ll = long long ;\\nclass Solution {\\npublic:\\n    bool splitString(string s) {\\n        for(int len = 1; len < s.size(); len++)\\n        {\\n            ll num = stoll(s.substr(0, len) ) ;\\n            if(num >= 1e10)\\n                break ;\\n            if(dfs(s, len, num-1))\\n                return true ;\\n        }   \\n        return false ;\\n    }\\n    \\n    bool dfs(string&s, int cur, ll num)\\n    {\\n        if(cur == s.size())\\n            return true ;\\n        for(int len = 1; cur+len <= s.size(); len++)\\n        {\\n            ll num2 = stoll(s.substr(cur, len)) ;\\n            if(num2 > num)\\n                break ;\\n            if( num2 == num && dfs(s, cur+len, num2-1))  \\n                return true ;\\n        }\\n        return false ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nusing ll = long long ;\\nclass Solution {\\npublic:\\n    bool splitString(string s) {\\n        for(int len = 1; len < s.size(); len++)\\n        {\\n            ll num = stoll(s.substr(0, len) ) ;\\n            if(num >= 1e10)\\n                break ;\\n            if(dfs(s, len, num-1))\\n                return true ;\\n        }   \\n        return false ;\\n    }\\n    \\n    bool dfs(string&s, int cur, ll num)\\n    {\\n        if(cur == s.size())\\n            return true ;\\n        for(int len = 1; cur+len <= s.size(); len++)\\n        {\\n            ll num2 = stoll(s.substr(cur, len)) ;\\n            if(num2 > num)\\n                break ;\\n            if( num2 == num && dfs(s, cur+len, num2-1))  \\n                return true ;\\n        }\\n        return false ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3166077,
                "title": "79-ms",
                "content": "```ruby\\ndef split_string s\\n    return false if (x = s[/0*\\\\d/].size) == (z = s.size)\\n    f = -> i, t do\\n        !!(y = s[i..][/0*#{t}/]&.size) &&\\n            ((i += y) == z || f.(i, t - 1))\\n    end\\n    (x...z).any? { f.call _1, s[0, _1].to_i - 1 }\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef split_string s\\n    return false if (x = s[/0*\\\\d/].size) == (z = s.size)\\n    f = -> i, t do\\n        !!(y = s[i..][/0*#{t}/]&.size) &&\\n            ((i += y) == z || f.(i, t - 1))\\n    end\\n    (x...z).any? { f.call _1, s[0, _1].to_i - 1 }\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3161849,
                "title": "python-backtracking-solution",
                "content": "\\n```\\nclass Solution(object):\\n    def splitString(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        def backtrack(stack, substr):\\n\\t\\t\\t# Made it to the end of s\\n            if not substr:\\n                return True\\n\\t\\t\\t\\n\\t\\t\\t# Try all substrings of length 1 to len(substr) for a valid decreasing substring\\n            for i in range(1, len(substr)+1):\\n\\t\\t\\t\\n\\t\\t\\t\\t# Push to stack if no initial value or current substring is one less than previously seen substring\\n                if not stack or int(substr[:i]) == stack[-1] - 1:\\n                    stack.append(int(substr[:i]))\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# Made it to the end of s and s can be split into at least two substrings\\n                    if backtrack(stack, substr[i:]) and len(stack) > 1:\\n                        return True\\n                    stack.pop()\\n\\n            return False\\n\\n        return backtrack([], s)\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution(object):\\n    def splitString(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: bool\\n        \"\"\"\\n        def backtrack(stack, substr):\\n\\t\\t\\t# Made it to the end of s\\n            if not substr:\\n                return True\\n\\t\\t\\t\\n\\t\\t\\t# Try all substrings of length 1 to len(substr) for a valid decreasing substring\\n            for i in range(1, len(substr)+1):\\n\\t\\t\\t\\n\\t\\t\\t\\t# Push to stack if no initial value or current substring is one less than previously seen substring\\n                if not stack or int(substr[:i]) == stack[-1] - 1:\\n                    stack.append(int(substr[:i]))\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# Made it to the end of s and s can be split into at least two substrings\\n                    if backtrack(stack, substr[i:]) and len(stack) > 1:\\n                        return True\\n                    stack.pop()\\n\\n            return False\\n\\n        return backtrack([], s)\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 3161164,
                "title": "backtracking-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    using ull = unsigned long long;\\n\\n    bool solve(vector<ull>& path, string& s, int i) {\\n        if(i == s.size()) return true;\\n\\n        ull num = 0;\\n\\n        for(int j=i; j<s.size()-1+(not path.empty()); j++) {\\n            num = 10*num + (s[j]-\\'0\\');\\n\\n            if(path.empty() or path.back()-num == 1) {\\n                path.push_back(num);\\n\\n                if(solve(path, s, j+1)) return true;\\n\\n                path.pop_back();\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    bool splitString(string s) {\\n        vector<ull> path;\\n        return solve(path, s, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using ull = unsigned long long;\\n\\n    bool solve(vector<ull>& path, string& s, int i) {\\n        if(i == s.size()) return true;\\n\\n        ull num = 0;\\n\\n        for(int j=i; j<s.size()-1+(not path.empty()); j++) {\\n            num = 10*num + (s[j]-\\'0\\');\\n\\n            if(path.empty() or path.back()-num == 1) {\\n                path.push_back(num);\\n\\n                if(solve(path, s, j+1)) return true;\\n\\n                path.pop_back();\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    bool splitString(string s) {\\n        vector<ull> path;\\n        return solve(path, s, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148183,
                "title": "slow-scala-dfs-with-foldleft-and-memoizations",
                "content": "# Code\\n```\\nobject Solution {\\n  import math.BigInt\\n  def splitString(s: String): Boolean = {\\n    val cache = collection.mutable.Map.empty[Seq[Char],Seq[Seq[Seq[Char]]]]\\n    val cache2 = collection.mutable.Map.empty[(Seq[Char],Seq[Char]),Boolean]\\n    val cache3 = collection.mutable.Map.empty[Seq[Char],BigInt]\\n    def dropZeros(seq: Seq[Char]): Seq[Char] =\\n      if(seq.size <=1) seq\\n      else if (seq.head == \\'0\\') dropZeros(seq.tail)\\n      else seq\\n    def impl(seq:Seq[Char]): Seq[Seq[Seq[Char]]] = {\\n      if(seq.isEmpty) Seq()\\n      else if(cache.contains(seq)) cache(seq)\\n       else {\\n        val rc = List(List(seq)) ++ (1 until (seq.size)).to(List).flatMap{case i =>\\n          lazy val (d0,t0) = seq.splitAt(i)\\n          lazy val (d,t) = (dropZeros(d0),dropZeros(t0))\\n          impl(t).map(d +: _)\\n        }\\n        cache += (seq -> rc)\\n        rc\\n      }\\n    }\\n    def toBigInt(s: Seq[Char]): BigInt = {\\n      if(cache3.contains(s)) cache3(s) else {\\n        lazy val t = s.dropWhile(_ == \\'0\\')\\n        val rc = if(t.isEmpty) BigInt(0) else BigInt(s.mkString)\\n        cache3 += (s -> rc)\\n        rc\\n      }\\n    }\\n    def compare2(a: Seq[Char], b: Seq[Char]): Boolean = {\\n      if(cache2.contains(a,b)) cache2(a,b) else {\\n        val rc = toBigInt(a) - toBigInt(b) == BigInt(1)\\n        cache2 += ((a,b) -> rc)\\n        rc\\n      }\\n    }\\n    def check(seq: Seq[Seq[Char]]): Boolean = \\n      (seq.size > 1) && seq.sliding(2,1).forall{l => compare2(l(0),l(1)) }\\n    lazy val y0 = dropZeros(s) //s.dropWhile(_ == \\'0\\')\\n    if(y0.size<2) false else { \\n      impl(y0).exists(check)\\n    }\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  import math.BigInt\\n  def splitString(s: String): Boolean = {\\n    val cache = collection.mutable.Map.empty[Seq[Char],Seq[Seq[Seq[Char]]]]\\n    val cache2 = collection.mutable.Map.empty[(Seq[Char],Seq[Char]),Boolean]\\n    val cache3 = collection.mutable.Map.empty[Seq[Char],BigInt]\\n    def dropZeros(seq: Seq[Char]): Seq[Char] =\\n      if(seq.size <=1) seq\\n      else if (seq.head == \\'0\\') dropZeros(seq.tail)\\n      else seq\\n    def impl(seq:Seq[Char]): Seq[Seq[Seq[Char]]] = {\\n      if(seq.isEmpty) Seq()\\n      else if(cache.contains(seq)) cache(seq)\\n       else {\\n        val rc = List(List(seq)) ++ (1 until (seq.size)).to(List).flatMap{case i =>\\n          lazy val (d0,t0) = seq.splitAt(i)\\n          lazy val (d,t) = (dropZeros(d0),dropZeros(t0))\\n          impl(t).map(d +: _)\\n        }\\n        cache += (seq -> rc)\\n        rc\\n      }\\n    }\\n    def toBigInt(s: Seq[Char]): BigInt = {\\n      if(cache3.contains(s)) cache3(s) else {\\n        lazy val t = s.dropWhile(_ == \\'0\\')\\n        val rc = if(t.isEmpty) BigInt(0) else BigInt(s.mkString)\\n        cache3 += (s -> rc)\\n        rc\\n      }\\n    }\\n    def compare2(a: Seq[Char], b: Seq[Char]): Boolean = {\\n      if(cache2.contains(a,b)) cache2(a,b) else {\\n        val rc = toBigInt(a) - toBigInt(b) == BigInt(1)\\n        cache2 += ((a,b) -> rc)\\n        rc\\n      }\\n    }\\n    def check(seq: Seq[Seq[Char]]): Boolean = \\n      (seq.size > 1) && seq.sliding(2,1).forall{l => compare2(l(0),l(1)) }\\n    lazy val y0 = dropZeros(s) //s.dropWhile(_ == \\'0\\')\\n    if(y0.size<2) false else { \\n      impl(y0).exists(check)\\n    }\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3109263,
                "title": "go-beats-100-runtime-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n^3)$$ (n=s.length)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npackage main\\n\\nimport (\\n\\t\"fmt\"\\n\\t\"strconv\"\\n)\\n\\nfunc valid(s string, t string) bool {\\n\\tsi, _ := strconv.Atoi(s)\\n\\tti, _ := strconv.Atoi(t)\\n\\treturn si-ti == 1\\n}\\n\\nfunc splitString(s string) bool {\\n\\tvar dfs func(i int, prev string, cnt int) bool\\n\\tdfs = func(i int, prev string, cnt int) bool {\\n\\n\\t\\tif i == len(s) && cnt > 1 {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\n\\t\\tfor j := i; j < len(s); j++ {\\n\\t\\t\\tif prev == \"\" || valid(prev, s[i:j+1]) {\\n\\t\\t\\t\\tif dfs(j+1, s[i:j+1], i+1) {\\n\\t\\t\\t\\t\\treturn true\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false\\n\\t}\\n\\treturn dfs(0, \"\", 0)\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\npackage main\\n\\nimport (\\n\\t\"fmt\"\\n\\t\"strconv\"\\n)\\n\\nfunc valid(s string, t string) bool {\\n\\tsi, _ := strconv.Atoi(s)\\n\\tti, _ := strconv.Atoi(t)\\n\\treturn si-ti == 1\\n}\\n\\nfunc splitString(s string) bool {\\n\\tvar dfs func(i int, prev string, cnt int) bool\\n\\tdfs = func(i int, prev string, cnt int) bool {\\n\\n\\t\\tif i == len(s) && cnt > 1 {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\n\\t\\tfor j := i; j < len(s); j++ {\\n\\t\\t\\tif prev == \"\" || valid(prev, s[i:j+1]) {\\n\\t\\t\\t\\tif dfs(j+1, s[i:j+1], i+1) {\\n\\t\\t\\t\\t\\treturn true\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false\\n\\t}\\n\\treturn dfs(0, \"\", 0)\\n}\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3103709,
                "title": "c-concise-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> v;\\n    bool ans = false;\\n    void solve(const string& s, int i = 0) {\\n        if (s.size() == i and v.size() > 1) {\\n            ans = true;\\n        }\\n        for (unsigned long long c = 0; i < s.size() and !ans; i++) {\\n            c = c * 10 + (s[i] - \\'0\\');\\n            if (v.empty() or v.back() - 1 == c) {\\n                v.push_back(c);\\n                solve(s, i + 1);\\n                v.pop_back();\\n            }\\n        }\\n    }\\n    bool splitString(string s) {\\n        solve(s);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> v;\\n    bool ans = false;\\n    void solve(const string& s, int i = 0) {\\n        if (s.size() == i and v.size() > 1) {\\n            ans = true;\\n        }\\n        for (unsigned long long c = 0; i < s.size() and !ans; i++) {\\n            c = c * 10 + (s[i] - \\'0\\');\\n            if (v.empty() or v.back() - 1 == c) {\\n                v.push_back(c);\\n                solve(s, i + 1);\\n                v.pop_back();\\n            }\\n        }\\n    }\\n    bool splitString(string s) {\\n        solve(s);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103473,
                "title": "java-easy-updated-top-voted-solution-beats-100",
                "content": "I could not finish my code and looked discussion. I saw @vikrant_pc \\' s java solution which was top voted. I changed it a little bit to make it faster and easier to understand. Hope this helps somebody else!\\n\\n```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        return isRemainingValid(s, -1); // input is positive so we can use negative temp value as previous\\n    }\\n    private boolean isRemainingValid(String s, double previous) {\\n\\t   // \"21474836482147483647\" max true input so double should be enough\\n        double current =0;\\n        for(int i=0;i<s.length();i++) {\\n            current = current * 10 + s.charAt(i)-\\'0\\';\\n            if(previous != -1 && previous < current) return false; // prev always should be bigger, since decreasing expected\\n            if(previous == -1) {\\n                if (isRemainingValid(s.substring(i+1), current)) \\n                    return true;\\n            } else if(current == previous - 1 && (i==s.length()-1 || isRemainingValid(s.substring(i+1), current)))\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```\\n`if(previous != null && previous < current) return false;`  this avoids a lot of unnecessary conditions. Like if current =10 and prev = 5 , there is no way you can return true because eventually we want it to be decreasing.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        return isRemainingValid(s, -1); // input is positive so we can use negative temp value as previous\\n    }\\n    private boolean isRemainingValid(String s, double previous) {\\n\\t   // \"21474836482147483647\" max true input so double should be enough\\n        double current =0;\\n        for(int i=0;i<s.length();i++) {\\n            current = current * 10 + s.charAt(i)-\\'0\\';\\n            if(previous != -1 && previous < current) return false; // prev always should be bigger, since decreasing expected\\n            if(previous == -1) {\\n                if (isRemainingValid(s.substring(i+1), current)) \\n                    return true;\\n            } else if(current == previous - 1 && (i==s.length()-1 || isRemainingValid(s.substring(i+1), current)))\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3099338,
                "title": "simple-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool dfs(string s, int index, long long int prev){\\n        if(index == s.length()) return true;\\n        for(int i = index ;  i < s.length() ; i++){\\n            long long int val = stoull(s.substr(index,i-index+1));\\n            if((val+1 == prev) && dfs(s,i+1,val)) return true;\\n        }\\n        return false;\\n    }\\n    bool splitString(string s) {\\n        int index = 0;\\n        // As we need two splits every time so not going upto one less than length\\n        for(int i = 0 ; i < s.length()-1;i++){\\n            long long int val = stoull(s.substr(index,i-index+1));\\n            if(dfs(s,i+1,val)) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(string s, int index, long long int prev){\\n        if(index == s.length()) return true;\\n        for(int i = index ;  i < s.length() ; i++){\\n            long long int val = stoull(s.substr(index,i-index+1));\\n            if((val+1 == prev) && dfs(s,i+1,val)) return true;\\n        }\\n        return false;\\n    }\\n    bool splitString(string s) {\\n        int index = 0;\\n        // As we need two splits every time so not going upto one less than length\\n        for(int i = 0 ; i < s.length()-1;i++){\\n            long long int val = stoull(s.substr(index,i-index+1));\\n            if(dfs(s,i+1,val)) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084934,
                "title": "on-time-on-space-0ms-my-fastest-solution-explained",
                "content": "\\n```\\nlong long MX = 999999999999;\\nclass Solution {\\npublic:\\n    bool dfs(string &s, long long prev, int idx, int cnt) {\\n        if(idx == s.size() ) return cnt > 1;\\n        long long num = 0;\\n        for(int i = idx; i < s.size(); i++) {\\n            num = num *  10l + s[i] - \\'0\\';\\n            if(num > MX) break;\\n            if(num == prev - 1 || prev == -1) {\\n                if(dfs(s, num, i + 1, cnt + 1)) return true;\\n            }\\n            if(num > prev && prev != -1) break;\\n        }\\n        return false;\\n    }\\n    \\n    bool splitString(string s) {\\n        if(s.size() <= 1) return false;\\n        return dfs(s, -1, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nlong long MX = 999999999999;\\nclass Solution {\\npublic:\\n    bool dfs(string &s, long long prev, int idx, int cnt) {\\n        if(idx == s.size() ) return cnt > 1;\\n        long long num = 0;\\n        for(int i = idx; i < s.size(); i++) {\\n            num = num *  10l + s[i] - \\'0\\';\\n            if(num > MX) break;\\n            if(num == prev - 1 || prev == -1) {\\n                if(dfs(s, num, i + 1, cnt + 1)) return true;\\n            }\\n            if(num > prev && prev != -1) break;\\n        }\\n        return false;\\n    }\\n    \\n    bool splitString(string s) {\\n        if(s.size() <= 1) return false;\\n        return dfs(s, -1, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084556,
                "title": "easy-to-understand-python",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    \\n    def helper(self,s,prev,idx):\\n        \\n        if(idx == len(s) and prev != s ):\\n            \\n            \\n            return True \\n        \\n        c = \"\"\\n    \\n        for i in range(idx,len(s)):\\n            \\n            c += s[i]\\n            \\n            if(prev != \"\"):\\n                \\n                if(int(prev) - int(c) == 1 ):\\n            \\n                    if(self.helper(s,c,i+1)): \\n                        \\n                        return True \\n                    \\n            else:\\n                \\n                if(self.helper(s,c,i+1)):\\n                    \\n                    return True \\n                \\n        \\n        return False \\n        \\n        \\n    \\n    def splitString(self, s: str) -> bool:\\n        \\n        return self.helper(s,\"\",0)\\n        \\n    \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def helper(self,s,prev,idx):\\n        \\n        if(idx == len(s) and prev != s ):\\n            \\n            \\n            return True \\n        \\n        c = \"\"\\n    \\n        for i in range(idx,len(s)):\\n            \\n            c += s[i]\\n            \\n            if(prev != \"\"):\\n                \\n                if(int(prev) - int(c) == 1 ):\\n            \\n                    if(self.helper(s,c,i+1)): \\n                        \\n                        return True \\n                    \\n            else:\\n                \\n                if(self.helper(s,c,i+1)):\\n                    \\n                    return True \\n                \\n        \\n        return False \\n        \\n        \\n    \\n    def splitString(self, s: str) -> bool:\\n        \\n        return self.helper(s,\"\",0)\\n        \\n    \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3074532,
                "title": "python-short-dfs-solution",
                "content": "```\\ndef splitString(self, s: str) -> bool:\\n\\tdef dfs(p, idx):\\n\\t\\tif idx==len(s):\\n\\t\\t\\treturn True\\n\\t\\tfor i in range(idx, len(s)):\\n\\t\\t\\tif p-1==int(s[idx:i+1]) and dfs(int(s[idx:i+1]), i+1):\\n\\t\\t\\t\\treturn True\\n\\t\\treturn False\\n\\n\\treturn any(dfs(int(s[:i+1]), i+1) for i in range(len(s)-1))\\n```",
                "solutionTags": [],
                "code": "```\\ndef splitString(self, s: str) -> bool:\\n\\tdef dfs(p, idx):\\n\\t\\tif idx==len(s):\\n\\t\\t\\treturn True\\n\\t\\tfor i in range(idx, len(s)):\\n\\t\\t\\tif p-1==int(s[idx:i+1]) and dfs(int(s[idx:i+1]), i+1):\\n\\t\\t\\t\\treturn True\\n\\t\\treturn False\\n\\n\\treturn any(dfs(int(s[:i+1]), i+1) for i in range(len(s)-1))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3026296,
                "title": "java-dfs-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        \\n     for(int i = 0; i < s.length()-1; i++){ // needs to be split to atleast two partions so iterating up until len - 1\\n         Double  val = Double.parseDouble(s.substring(0, i+1));\\n\\n        if(dfs(i+1, s, val)) // for each partition size check the other remaining string with varying partition\\n            return true;\\n     }\\n     return false;\\n    }\\n\\n    public boolean dfs(int index, String s, Double prev){\\n\\n        if(index == s.length())\\n            return true;\\n\\n        for(int j = index ;j < s.length(); j++) {\\n             Double  val = Double.parseDouble(s.substring(index, j+1));\\n             if(prev == val+1 && dfs(j+1, s, val) ){\\n                 return true;\\n             }\\n        }\\n    return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        \\n     for(int i = 0; i < s.length()-1; i++){ // needs to be split to atleast two partions so iterating up until len - 1\\n         Double  val = Double.parseDouble(s.substring(0, i+1));\\n\\n        if(dfs(i+1, s, val)) // for each partition size check the other remaining string with varying partition\\n            return true;\\n     }\\n     return false;\\n    }\\n\\n    public boolean dfs(int index, String s, Double prev){\\n\\n        if(index == s.length())\\n            return true;\\n\\n        for(int j = index ;j < s.length(); j++) {\\n             Double  val = Double.parseDouble(s.substring(index, j+1));\\n             if(prev == val+1 && dfs(j+1, s, val) ){\\n                 return true;\\n             }\\n        }\\n    return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2960365,
                "title": "python-top-down-dp-o-n-3",
                "content": "\\n# Code\\n```\\nfrom functools import cache\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        @cache\\n        def dfs(prev, s):\\n            if not s: return True\\n            res = False\\n            for i in range(len(s)):\\n                cur = int(s[:i+1])\\n                if prev - 1 == cur:\\n                    res = res or dfs(cur, s[i+1:])\\n            return res\\n        for i in range(len(s)-1):\\n            if dfs(int(s[:i+1]), s[i+1:]): return True\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom functools import cache\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        @cache\\n        def dfs(prev, s):\\n            if not s: return True\\n            res = False\\n            for i in range(len(s)):\\n                cur = int(s[:i+1])\\n                if prev - 1 == cur:\\n                    res = res or dfs(cur, s[i+1:])\\n            return res\\n        for i in range(len(s)-1):\\n            if dfs(int(s[:i+1]), s[i+1:]): return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2958847,
                "title": "hardcoded",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHardcode\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHardcoded, but be ware of the cringe edgecases.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1) as the size of string is 20 at max\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool splitString(string s) {\\n        string head = \"\";\\n        int n = s.size();\\n        bool mt = false;\\n        int l = 0;\\n        for(int i = 0; i < n; i++){\\n            head = head+s[i];\\n            if(s[i] != \\'0\\') mt = true;\\n            if(mt) l++;\\n            if(2*l - 1> n) break;\\n            long long x = stoll(head);\\n            long long y = 0;\\n            long long c = x;\\n            for(int j = i+1; j < n; j++){\\n                y = y*10+s[j]-\\'0\\';\\n                if(y == c-1){\\n                    c = y;\\n                    if(c == 0) c = 1;\\n                    y = 0;\\n                    if(j == n-1) return true;\\n                }\\n                if(y >= c) break;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool splitString(string s) {\\n        string head = \"\";\\n        int n = s.size();\\n        bool mt = false;\\n        int l = 0;\\n        for(int i = 0; i < n; i++){\\n            head = head+s[i];\\n            if(s[i] != \\'0\\') mt = true;\\n            if(mt) l++;\\n            if(2*l - 1> n) break;\\n            long long x = stoll(head);\\n            long long y = 0;\\n            long long c = x;\\n            for(int j = i+1; j < n; j++){\\n                y = y*10+s[j]-\\'0\\';\\n                if(y == c-1){\\n                    c = y;\\n                    if(c == 0) c = 1;\\n                    y = 0;\\n                    if(j == n-1) return true;\\n                }\\n                if(y >= c) break;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2932480,
                "title": "java-rec-big-integer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.math.*;\\n\\nclass Solution {\\n    public boolean splitString(String s) {\\n\\t\\treturn f(0, new BigInteger(\"0\"),0, s);\\n\\t}\\n\\n\\tboolean f(int i, BigInteger prev,int size , String s) {\\n\\t\\tif (i == s.length())\\n\\t\\t\\treturn size >= 2;\\n\\t\\tfor (int j = i; j < s.length(); j++) {\\n\\t\\t\\tBigInteger temp = new BigInteger(s.substring(i, j + 1));\\n\\t\\t\\tif (i == 0 || prev.subtract(temp).equals(new BigInteger(\"1\"))) \\n\\t\\t\\t\\tif (f(j + 1, temp,size + 1, s))\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.math.*;\\n\\nclass Solution {\\n    public boolean splitString(String s) {\\n\\t\\treturn f(0, new BigInteger(\"0\"),0, s);\\n\\t}\\n\\n\\tboolean f(int i, BigInteger prev,int size , String s) {\\n\\t\\tif (i == s.length())\\n\\t\\t\\treturn size >= 2;\\n\\t\\tfor (int j = i; j < s.length(); j++) {\\n\\t\\t\\tBigInteger temp = new BigInteger(s.substring(i, j + 1));\\n\\t\\t\\tif (i == 0 || prev.subtract(temp).equals(new BigInteger(\"1\"))) \\n\\t\\t\\t\\tif (f(j + 1, temp,size + 1, s))\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898689,
                "title": "c-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nlong long MX = 999999999999;\\nclass Solution {\\npublic:\\n    bool dfs(string &s, long long prev, int idx, int cnt) {\\n        if(idx == s.size() ) return cnt > 1;\\n        long long num = 0;\\n        for(int i = idx; i < s.size(); i++) {\\n            num = num *  10l + s[i] - \\'0\\';\\n            if(num > MX) break;\\n            if(num == prev - 1 || prev == -1) {\\n                if(dfs(s, num, i + 1, cnt + 1)) return true;\\n            }\\n            if(num > prev && prev != -1) break;\\n        }\\n        return false;\\n    }\\n    \\n    bool splitString(string s) {\\n        if(s.size() <= 1) return false;\\n        return dfs(s, -1, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nlong long MX = 999999999999;\\nclass Solution {\\npublic:\\n    bool dfs(string &s, long long prev, int idx, int cnt) {\\n        if(idx == s.size() ) return cnt > 1;\\n        long long num = 0;\\n        for(int i = idx; i < s.size(); i++) {\\n            num = num *  10l + s[i] - \\'0\\';\\n            if(num > MX) break;\\n            if(num == prev - 1 || prev == -1) {\\n                if(dfs(s, num, i + 1, cnt + 1)) return true;\\n            }\\n            if(num > prev && prev != -1) break;\\n        }\\n        return false;\\n    }\\n    \\n    bool splitString(string s) {\\n        if(s.size() <= 1) return false;\\n        return dfs(s, -1, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2867636,
                "title": "c-backtracking-palindromic-partitioning-follow-up",
                "content": "```\\nvoid fun(string &s,int ind,vector<vector<string>> &res,vector<string> &cont)\\n{\\n    \\n    if(cont.size()>0 && cont[0].size()==s.size())return;\\n    if(cont.size()>=2)\\n    {\\n        for(int j=0;j<cont.size()-1;j++)\\n        {\\n            unsigned long long int x1= stoull(cont[j]);\\n           unsigned long long int x2= stoull(cont[j+1]);\\n            if(x1!=x2+1)return;}\\n    }\\n    if(ind==s.size())\\n    {\\n        res.push_back(cont);\\n        return;\\n    }\\n\\n    for(int i=ind;i<s.size();i++)\\n        {\\n            \\n                cont.push_back(s.substr(ind,i-ind+1));\\n                fun(s,i+1,res,cont);\\n                cont.pop_back();\\n            \\n        }    \\n}\\nbool splitString(string s) {\\n    vector<vector<string>> res;\\n    vector<string> cont;\\n    fun(s,0,res,cont);\\n    return res.size()>=1?true:false;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nvoid fun(string &s,int ind,vector<vector<string>> &res,vector<string> &cont)\\n{\\n    \\n    if(cont.size()>0 && cont[0].size()==s.size())return;\\n    if(cont.size()>=2)\\n    {\\n        for(int j=0;j<cont.size()-1;j++)\\n        {\\n            unsigned long long int x1= stoull(cont[j]);\\n           unsigned long long int x2= stoull(cont[j+1]);\\n            if(x1!=x2+1)return;}\\n    }\\n    if(ind==s.size())\\n    {\\n        res.push_back(cont);\\n        return;\\n    }\\n\\n    for(int i=ind;i<s.size();i++)\\n        {\\n            \\n                cont.push_back(s.substr(ind,i-ind+1));\\n                fun(s,i+1,res,cont);\\n                cont.pop_back();\\n            \\n        }    \\n}\\nbool splitString(string s) {\\n    vector<vector<string>> res;\\n    vector<string> cont;\\n    fun(s,0,res,cont);\\n    return res.size()>=1?true:false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2812513,
                "title": "python-backtracking",
                "content": "\\n    def splitString(self, s: str) -> bool:\\n        \\n        def backtrack(idx, preVal):\\n            if idx == len(s):\\n                return True\\n            \\n            for j in range(idx, len(s)):\\n                val = int(s[idx:j+1])\\n                if val+1 == preVal and backtrack(j+1, val): # as descending. so val +1 compare with pre val\\n                    return True\\n            return False\\n        \\n        for i in range(len(s)-1):\\n            val = int(s[:i+1])\\n            if backtrack(i+1, val):\\n                return True\\n        return False",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "\\n    def splitString(self, s: str) -> bool:\\n        \\n        def backtrack(idx, preVal):\\n            if idx == len(s):\\n                return True\\n            \\n            for j in range(idx, len(s)):\\n                val = int(s[idx:j+1])\\n                if val+1 == preVal and backtrack(j+1, val): # as descending. so val +1 compare with pre val\\n                    return True\\n            return False\\n        \\n        for i in range(len(s)-1):\\n            val = int(s[:i+1])\\n            if backtrack(i+1, val):\\n                return True\\n        return False",
                "codeTag": "Python3"
            },
            {
                "id": 2736181,
                "title": "greedy-intuition-c-explained-in-hindi",
                "content": "```\\n vector<long long> curr;\\n    bool solve(string s,int start)\\n    {\\n        //base case --> if curr vector size > 2 then we have splitted correctly\\n        if(start>=s.size())\\n            return curr.size()>=2;\\n        \\n        for(int i=start;i<s.size();i++)\\n        {\\n            long long val=stoll(s.substr(start,i-start+1));\\n            \\n            //Step 1 --> If ek number hi 1e11 ka hai to iske agla number b 1e11 ka hi hoga as (difference bw the 2 numbers should be 1 and s.size()<=20 constraints)\\n            \\n            if(val>1e11)\\n                return false;\\n            \\n            // Step 2 -> If curr vector me kuch hai to bakc() se chota hona chiye current value (WE HAVE TO FORM DECREASING)  \\n            \\n            //IMPORTANT --> If previous wali ek bdi nahi hai to koi aur ho skti bdi aage return false thodi krdege aage dhundo koi\\n            \\n            if(curr.size()>0 and curr.back()-val!=1)\\n                continue;    \\n            \\n            curr.push_back(val);  //push into vector\\n            \\n            if(solve(s,i+1))  // recursively solve\\n                return true;\\n            \\n            curr.pop_back();  //backtracking step\\n        }\\n        return false;  //kahi bhi ans nahi mila\\n    }\\n    \\n    bool splitString(string s) {\\n        \\n        return solve(s,0);\\n    }",
                "solutionTags": [],
                "code": "```\\n vector<long long> curr;\\n    bool solve(string s,int start)\\n    {\\n        //base case --> if curr vector size > 2 then we have splitted correctly\\n        if(start>=s.size())\\n            return curr.size()>=2;\\n        \\n        for(int i=start;i<s.size();i++)\\n        {\\n            long long val=stoll(s.substr(start,i-start+1));\\n            \\n            //Step 1 --> If ek number hi 1e11 ka hai to iske agla number b 1e11 ka hi hoga as (difference bw the 2 numbers should be 1 and s.size()<=20 constraints)\\n            \\n            if(val>1e11)\\n                return false;\\n            \\n            // Step 2 -> If curr vector me kuch hai to bakc() se chota hona chiye current value (WE HAVE TO FORM DECREASING)  \\n            \\n            //IMPORTANT --> If previous wali ek bdi nahi hai to koi aur ho skti bdi aage return false thodi krdege aage dhundo koi\\n            \\n            if(curr.size()>0 and curr.back()-val!=1)\\n                continue;    \\n            \\n            curr.push_back(val);  //push into vector\\n            \\n            if(solve(s,i+1))  // recursively solve\\n                return true;\\n            \\n            curr.pop_back();  //backtracking step\\n        }\\n        return false;  //kahi bhi ans nahi mila\\n    }\\n    \\n    bool splitString(string s) {\\n        \\n        return solve(s,0);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2730767,
                "title": "strip-zeros-to-make-your-life-easy-python",
                "content": "After stripping zeros you can use `startsWith` check to see if string starts with a number you need\\n\\n```\\n    def splitString(self, s: str) -> bool:\\n        def solve(i, num):\\n            if i == len(s): return True\\n            if num == 0: return \"0\"*(len(s) - i) == s[i:]\\n            \\n            # strip zeros\\n            while i < len(s) and s[i] == \\'0\\': i += 1 \\n                \\n            numStr = str(num)\\n            if not s.startswith(numStr, i): return False\\n            return solve(i + len(numStr), num - 1)\\n        \\n        for i in range(1, len(s)):\\n            if solve(i, int(s[:i]) - 1): return True\\n        \\n        return False",
                "solutionTags": [],
                "code": "After stripping zeros you can use `startsWith` check to see if string starts with a number you need\\n\\n```\\n    def splitString(self, s: str) -> bool:\\n        def solve(i, num):\\n            if i == len(s): return True\\n            if num == 0: return \"0\"*(len(s) - i) == s[i:]\\n            \\n            # strip zeros\\n            while i < len(s) and s[i] == \\'0\\': i += 1 \\n                \\n            numStr = str(num)\\n            if not s.startswith(numStr, i): return False\\n            return solve(i + len(numStr), num - 1)\\n        \\n        for i in range(1, len(s)):\\n            if solve(i, int(s[:i]) - 1): return True\\n        \\n        return False",
                "codeTag": "Python3"
            },
            {
                "id": 2704048,
                "title": "js-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar splitString = function(s) {\\n    if (parseInt(s, 10) < 10) return false\\n\\n    const stripFirstZeroes = str => {\\n        while (str[0] === \\'0\\' && str.length > 1) {\\n            str = str.substring(1)\\n        }\\n        return str\\n    }\\n\\n    s = stripFirstZeroes(s)\\n\\n    const checkNumValid = (num, str) => {\\n        if (str.length === 0) return true\\n\\n        str = stripFirstZeroes(str)\\n\\n        if (num === 1) return str === \\'0\\'\\n\\n        var nextNum = num - 1\\n        if (str.startsWith(nextNum.toString())) {\\n            return checkNumValid(nextNum, str.replace(nextNum.toString(), \\'\\'))\\n        }\\n\\n        return false\\n    }\\n\\n    let firstNum = \\'\\'\\n    for (var i = 0; i < Math.ceil(s.length / 2); i++) {\\n        firstNum += s[i]\\n        if (checkNumValid(parseInt(firstNum, 10), s.replace(firstNum, \\'\\'))) {\\n            return true\\n        }\\n    }\\n\\n    return false\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar splitString = function(s) {\\n    if (parseInt(s, 10) < 10) return false\\n\\n    const stripFirstZeroes = str => {\\n        while (str[0] === \\'0\\' && str.length > 1) {\\n            str = str.substring(1)\\n        }\\n        return str\\n    }\\n\\n    s = stripFirstZeroes(s)\\n\\n    const checkNumValid = (num, str) => {\\n        if (str.length === 0) return true\\n\\n        str = stripFirstZeroes(str)\\n\\n        if (num === 1) return str === \\'0\\'\\n\\n        var nextNum = num - 1\\n        if (str.startsWith(nextNum.toString())) {\\n            return checkNumValid(nextNum, str.replace(nextNum.toString(), \\'\\'))\\n        }\\n\\n        return false\\n    }\\n\\n    let firstNum = \\'\\'\\n    for (var i = 0; i < Math.ceil(s.length / 2); i++) {\\n        firstNum += s[i]\\n        if (checkNumValid(parseInt(firstNum, 10), s.replace(firstNum, \\'\\'))) {\\n            return true\\n        }\\n    }\\n\\n    return false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2681403,
                "title": "python-backtracking-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        @cache\\n        def backtrack(remaining: str, prev: int) -> bool:\\n            if remaining == \\'\\':\\n                return True\\n            for i in range(len(remaining)):\\n                if int(remaining[:i + 1]) == prev - 1:\\n                    if backtrack(remaining[i + 1:], prev - 1):\\n                        return True\\n            return False\\n        \\n        for i in range(len(s) - 1):\\n            if backtrack(s[i + 1:], int(s[:i + 1])):\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        @cache\\n        def backtrack(remaining: str, prev: int) -> bool:\\n            if remaining == \\'\\':\\n                return True\\n            for i in range(len(remaining)):\\n                if int(remaining[:i + 1]) == prev - 1:\\n                    if backtrack(remaining[i + 1:], prev - 1):\\n                        return True\\n            return False\\n        \\n        for i in range(len(s) - 1):\\n            if backtrack(s[i + 1:], int(s[:i + 1])):\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2660476,
                "title": "python-easy-to-understand",
                "content": "```\\nclass Solution:\\n    \\n    def helper(self,s,idx,idx2,prev):\\n        \\n        if(idx == len(s) and idx2 == 1):\\n            \\n            return True \\n        \\n        c = \"\"\\n        for i in range(idx,len(s)):\\n            \\n            c += s[i]\\n            \\n            if(idx != 0 ):\\n                \\n                val = int(prev) - int(c)\\n                \\n                \\n                \\n                if(val == 1):\\n                    \\n                    if(self.helper(s,i+1,val,c)):\\n                        \\n                        return True \\n                \\n            else:\\n                \\n                if(self.helper(s,i+1,0,c)):\\n                    \\n                    return True \\n        \\n        \\n        return False \\n            \\n            \\n    \\n    def splitString(self, s: str) -> bool:\\n        \\n        \\n        return self.helper(s,0,0,\"\")\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def helper(self,s,idx,idx2,prev):\\n        \\n        if(idx == len(s) and idx2 == 1):\\n            \\n            return True \\n        \\n        c = \"\"\\n        for i in range(idx,len(s)):\\n            \\n            c += s[i]\\n            \\n            if(idx != 0 ):\\n                \\n                val = int(prev) - int(c)\\n                \\n                \\n                \\n                if(val == 1):\\n                    \\n                    if(self.helper(s,i+1,val,c)):\\n                        \\n                        return True \\n                \\n            else:\\n                \\n                if(self.helper(s,i+1,0,c)):\\n                    \\n                    return True \\n        \\n        \\n        return False \\n            \\n            \\n    \\n    def splitString(self, s: str) -> bool:\\n        \\n        \\n        return self.helper(s,0,0,\"\")\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2634916,
                "title": "c-backtracking",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool splitString(string s) {\\n\\t\\t\\tint n=s.length();\\n\\t\\t\\tint c=0;\\n\\t\\t\\tfunction<bool(long,int)> recur=[&](long val,int x){\\n\\t\\t\\t\\tif(x==n) {\\n\\t\\t\\t\\t\\treturn c>1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tstring str=\"\";\\n\\t\\t\\t\\tbool res=false;\\n\\t\\t\\t\\twhile(x<n-1&&s[x]==\\'0\\'&&s[x+1]==\\'0\\') x++;\\n\\t\\t\\t\\tfor(int i=x;i<min(x+10,n);i++) {\\n\\t\\t\\t\\t\\tstr+=s[i];\\n\\t\\t\\t\\t\\tif(val==LONG_MAX||val-stol(str)==1) {\\n\\t\\t\\t\\t\\t\\tc++;\\n\\t\\t\\t\\t\\t\\tres=res||recur(stol(str),i+1);\\n\\t\\t\\t\\t\\t\\tc--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn res;\\n\\t\\t\\t};\\n\\t\\t\\treturn recur(LONG_MAX,0);\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool splitString(string s) {\\n\\t\\t\\tint n=s.length();\\n\\t\\t\\tint c=0;\\n\\t\\t\\tfunction<bool(long,int)> recur=[&](long val,int x){\\n\\t\\t\\t\\tif(x==n) {\\n\\t\\t\\t\\t\\treturn c>1;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2632013,
                "title": "clear-python-dfs-with-comments",
                "content": "```python\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        \\n        \"\"\"\\n        Time = O(2^N)\\n        Space = O(N) space from stack\\n        \\n        \"\"\"\\n        def dfs(index: int, last: int) -> bool:\\n            if index == len(s):\\n                return True\\n            \\n\\t\\t\\t# j: [index, len(s)-1]\\n            for j in range(index, len(s)):\\n\\t\\t\\t\\t# cur: [index, index] ~ [index, len(s)-1]\\n                cur = int(s[index:j + 1])\\n\\t\\t\\t\\t# last: [...,index-1]\\n\\t\\t\\t\\t# cur: [index+1, j]\\n\\t\\t\\t\\t# last = cur -> next: [j+1,...)\\n\\t\\t\\t\\t# DFS condition: cur = last - 1 && dfs(j+1, cur) == true\\n                if cur == last - 1 and dfs(j + 1, cur):\\n                    return True\\n            return False\\n        \\n        for i in range(len(s) - 1):\\n            last = int(s[:i+1])\\n            if dfs(i + 1, last):\\n                return True\\n        return False\\n\\n```\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        \\n        \"\"\"\\n        Time = O(2^N)\\n        Space = O(N) space from stack\\n        \\n        \"\"\"\\n        def dfs(index: int, last: int) -> bool:\\n            if index == len(s):\\n                return True\\n            \\n\\t\\t\\t# j: [index, len(s)-1]\\n            for j in range(index, len(s)):\\n\\t\\t\\t\\t# cur: [index, index] ~ [index, len(s)-1]\\n                cur = int(s[index:j + 1])\\n\\t\\t\\t\\t# last: [...,index-1]\\n\\t\\t\\t\\t# cur: [index+1, j]\\n\\t\\t\\t\\t# last = cur -> next: [j+1,...)\\n\\t\\t\\t\\t# DFS condition: cur = last - 1 && dfs(j+1, cur) == true\\n                if cur == last - 1 and dfs(j + 1, cur):\\n                    return True\\n            return False\\n        \\n        for i in range(len(s) - 1):\\n            last = int(s[:i+1])\\n            if dfs(i + 1, last):\\n                return True\\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2619890,
                "title": "simple-backtracking-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool helper(string a, string b){\\n        if(stoull(a)-stoull(b)==1) return true;\\n        for(int i=1; i<b.length(); i++){\\n            string x=b.substr(0, i);\\n            string y=b.substr(i, b.length()-i);\\n            if(stoull(b.substr(0, i)) != stoull(a)-1) continue;\\n            if(helper(x, y)) return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool splitString(string s) {\\n        for(int i=1; i<s.length(); i++){\\n            string a=s.substr(0, i);\\n            string b=s.substr(i, s.length()-i);\\n            if(helper(a, b))\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool helper(string a, string b){\\n        if(stoull(a)-stoull(b)==1) return true;\\n        for(int i=1; i<b.length(); i++){\\n            string x=b.substr(0, i);\\n            string y=b.substr(i, b.length()-i);\\n            if(stoull(b.substr(0, i)) != stoull(a)-1) continue;\\n            if(helper(x, y)) return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool splitString(string s) {\\n        for(int i=1; i<s.length(); i++){\\n            string a=s.substr(0, i);\\n            string b=s.substr(i, s.length()-i);\\n            if(helper(a, b))\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2573352,
                "title": "golang-simple-backtracking-solution",
                "content": "```go\\nfunc splitString(s string) bool {\\n  return backtrack(s, 0, -1)\\n}\\n\\nfunc backtrack(s string, pos int, prev int) bool {\\n  if len(s) == pos {\\n    return true\\n  }\\n  var x int\\n  // We want at least two non-empty substrings, so if we\\'re\\n  // starting from position 0, we don\\'t want to go till the end.\\n  end := len(s)\\n  if pos == 0 {\\n    end = len(s)-1\\n  }\\n  for i := pos; i < end; i++ {\\n    x = x * 10 + int(s[i]-\\'0\\')\\n    if prev != -1 && x != prev-1 {\\n      continue\\n    }\\n    if backtrack(s, i+1, x) {\\n      return true\\n    }\\n  }\\n  return false\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Backtracking"
                ],
                "code": "```go\\nfunc splitString(s string) bool {\\n  return backtrack(s, 0, -1)\\n}\\n\\nfunc backtrack(s string, pos int, prev int) bool {\\n  if len(s) == pos {\\n    return true\\n  }\\n  var x int\\n  // We want at least two non-empty substrings, so if we\\'re\\n  // starting from position 0, we don\\'t want to go till the end.\\n  end := len(s)\\n  if pos == 0 {\\n    end = len(s)-1\\n  }\\n  for i := pos; i < end; i++ {\\n    x = x * 10 + int(s[i]-\\'0\\')\\n    if prev != -1 && x != prev-1 {\\n      continue\\n    }\\n    if backtrack(s, i+1, x) {\\n      return true\\n    }\\n  }\\n  return false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2569971,
                "title": "simple-java-backtracking-solution",
                "content": "```\\n/**\\n * time complexity : O(N^2)\\n * space complexity: O(N)\\n */\\n\\nclass Solution {\\n\\tprivate String s;\\n\\n\\tpublic boolean splitString(String s) {\\n\\t\\tthis.s = s;\\n\\t\\treturn backTrack(-1l, 0);\\n\\t}\\n\\n\\tprivate boolean backTrack(long last, int j) {\\n\\n\\t\\tif (j == s.length()) // found it\\n\\t\\t\\treturn true;\\n\\n\\t\\tlong cur = 0l;\\n\\n\\t\\tfor (int i = j; i < s.length(); i++) {\\n\\n\\t\\t\\tcur = cur * 10 + (s.charAt(i) - \\'0\\'); // add current char\\n\\n\\t\\t\\tif (cur > 10000000000L || last == -1 && i + 1 == s.length()) // will make overflow || found only one substring\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tif ((last == -1 || last - cur == 1) && backTrack(cur, i + 1)) // first substring || difference between last,cur numbers is 1\\n\\t\\t\\t\\treturn true;\\n\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn false;\\n\\t}\\n}",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "class Solution {\\n\\tprivate String s;\\n\\n\\tpublic boolean splitString(String s) {\\n\\t\\tthis.s = s;\\n\\t\\treturn backTrack(-1l, 0);\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2556816,
                "title": "c-recoursion",
                "content": "```\\npublic class Solution {\\n    \\n    bool Solve(string s, long prev){\\n        if (s.Length <= 0)\\n            return true;\\n\\n        for (long i = 0, current = 0; i < s.Length && current < long.MaxValue / 10; ++i){\\n            current = current * 10 + (s[(int)i] - \\'0\\');\\n            \\n            if ((i != s.Length - 1 && prev == -1 || prev - current == 1) && \\n\\t\\t\\t     Solve(s.Substring((int)i + 1), current))\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public bool SplitString(string s) => Solve(s, -1);\\n        \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    \\n    bool Solve(string s, long prev){\\n        if (s.Length <= 0)\\n            return true;\\n\\n        for (long i = 0, current = 0; i < s.Length && current < long.MaxValue / 10; ++i){\\n            current = current * 10 + (s[(int)i] - \\'0\\');\\n            \\n            if ((i != s.Length - 1 && prev == -1 || prev - current == 1) && \\n\\t\\t\\t     Solve(s.Substring((int)i + 1), current))\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public bool SplitString(string s) => Solve(s, -1);\\n        \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2507858,
                "title": "rust-recursion",
                "content": "```\\nimpl Solution {\\n    fn c_to_i(ch: char) -> i128 {\\n        match ch {\\n            \\'0\\' => 0,\\n            \\'1\\' => 1,\\n            \\'2\\' => 2,\\n            \\'3\\' => 3,\\n            \\'4\\' => 4,\\n            \\'5\\' => 5,\\n            \\'6\\' => 6,\\n            \\'7\\' => 7,\\n            \\'8\\' => 8,\\n            \\'9\\' => 9,\\n            _ => panic!(\"Invalid character in ctoi\")\\n        }\\n    }\\n\\n    fn str_to_i(str: &str) -> i128 {\\n        let mut num: i128 = 0;\\n        for ch in str.chars() {\\n            num = num * 10 + Self::c_to_i(ch);\\n        }\\n        return num;\\n    }\\n\\n    fn rec(str: &str, start: usize, end: usize, prev_num: i128) -> bool {\\n        let len = str.len();\\n        if end >= len {\\n            return false;\\n        }\\n\\n        let num = Solution::str_to_i(&str[start..=end]);\\n        if start != 0 && prev_num - num != 1 {\\n            return false;\\n        }\\n        if end == len - 1 {\\n            return true;\\n        }\\n\\n        for i in 0..(len - end) {\\n            let ret = Solution::rec(str, end + 1, end + 1 + i, num);\\n            if ret {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    pub fn split_string(s: String) -> bool {\\n        let len = s.len();\\n        for i in 0..(len - 1) {\\n            let ret = Solution::rec(&s, 0, i, -1);\\n            if ret {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Recursion"
                ],
                "code": "```\\nimpl Solution {\\n    fn c_to_i(ch: char) -> i128 {\\n        match ch {\\n            \\'0\\' => 0,\\n            \\'1\\' => 1,\\n            \\'2\\' => 2,\\n            \\'3\\' => 3,\\n            \\'4\\' => 4,\\n            \\'5\\' => 5,\\n            \\'6\\' => 6,\\n            \\'7\\' => 7,\\n            \\'8\\' => 8,\\n            \\'9\\' => 9,\\n            _ => panic!(\"Invalid character in ctoi\")\\n        }\\n    }\\n\\n    fn str_to_i(str: &str) -> i128 {\\n        let mut num: i128 = 0;\\n        for ch in str.chars() {\\n            num = num * 10 + Self::c_to_i(ch);\\n        }\\n        return num;\\n    }\\n\\n    fn rec(str: &str, start: usize, end: usize, prev_num: i128) -> bool {\\n        let len = str.len();\\n        if end >= len {\\n            return false;\\n        }\\n\\n        let num = Solution::str_to_i(&str[start..=end]);\\n        if start != 0 && prev_num - num != 1 {\\n            return false;\\n        }\\n        if end == len - 1 {\\n            return true;\\n        }\\n\\n        for i in 0..(len - end) {\\n            let ret = Solution::rec(str, end + 1, end + 1 + i, num);\\n            if ret {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    pub fn split_string(s: String) -> bool {\\n        let len = s.len();\\n        for i in 0..(len - 1) {\\n            let ret = Solution::rec(&s, 0, i, -1);\\n            if ret {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2457579,
                "title": "c-solution-backtracking",
                "content": "```\\n#define MAX_SPLIT_VAL   10000000000         // at least 2 splits should be there and per split cannot have value greater than 10 digits\\nbool backtrack(char *s, int len, int idx, long preVal) {\\n    \\n    // success: end of the string which means we have found all\\n    // valid splits previously\\n    if(idx >= len) return true;\\n    \\n    char sPart[21] = {\\'\\\\0\\'};\\n    for(int i = idx; i < len; i++) {\\n        strncpy(sPart, s+idx, i - idx + 1);\\n        long long cVal = atol(sPart);\\n        if(cVal >= MAX_SPLIT_VAL) return false;\\n        \\n        // the previous value should be 1 greater than current value\\n        // and further splits after current should follow same condition\\n        if(preVal == cVal + 1 && backtrack(s, len, i+1, cVal))\\n            return true;\\n    }\\n    return false;\\n}\\n\\nbool splitString(char * s){\\n    int len = strlen(s);\\n    \\n    if(1 == len) return false;\\n    \\n    char split[21] = {\\'\\\\0\\'}, *ptr;\\n    // check single, double, triple digits\\n    for(int i = 0; i < len-1; i++) {\\n        strncpy(split, s, i+1);\\n        long long val = atol(split);\\n        if(val >= MAX_SPLIT_VAL) return false;\\n        // printf(\"split string is %s val is %ld\\\\n\", split, val);\\n        if(backtrack(s, len, i+1, val)) return true;\\n    }\\n    return false;\\n}\\n```\\n\\n**Time:** O(N^2), \\n**Space:** O(N) for recursion call stack",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\n#define MAX_SPLIT_VAL   10000000000         // at least 2 splits should be there and per split cannot have value greater than 10 digits\\nbool backtrack(char *s, int len, int idx, long preVal) {\\n    \\n    // success: end of the string which means we have found all\\n    // valid splits previously\\n    if(idx >= len) return true;\\n    \\n    char sPart[21] = {\\'\\\\0\\'};\\n    for(int i = idx; i < len; i++) {\\n        strncpy(sPart, s+idx, i - idx + 1);\\n        long long cVal = atol(sPart);\\n        if(cVal >= MAX_SPLIT_VAL) return false;\\n        \\n        // the previous value should be 1 greater than current value\\n        // and further splits after current should follow same condition\\n        if(preVal == cVal + 1 && backtrack(s, len, i+1, cVal))\\n            return true;\\n    }\\n    return false;\\n}\\n\\nbool splitString(char * s){\\n    int len = strlen(s);\\n    \\n    if(1 == len) return false;\\n    \\n    char split[21] = {\\'\\\\0\\'}, *ptr;\\n    // check single, double, triple digits\\n    for(int i = 0; i < len-1; i++) {\\n        strncpy(split, s, i+1);\\n        long long val = atol(split);\\n        if(val >= MAX_SPLIT_VAL) return false;\\n        // printf(\"split string is %s val is %ld\\\\n\", split, val);\\n        if(backtrack(s, len, i+1, val)) return true;\\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2442835,
                "title": "java-recursion-and-backtracking-explained-tc-sc-explained",
                "content": "// This is a classic recursion question\\n// Each time we FORM a number and then RECURSIVELY check if the \"remianing substring\" and this \"number\" satisfies ALL the rules, otherwise keep appending the  rest of the chars from string to this number\\n\\n// TC : O(N^2); N = s.length()\\n// SC : O(N); recursion stack\\n```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        return isPossible(s, null);\\n    }\\n    \\n    // Long and not long in parameter because \\'long\\' cannot take \\'null\\' but \\'Long\\' can\\n    private boolean isPossible(String s, Long previousNum) {\\n        long currentNum = 0;\\n        \\n        // ALWAYS starting making num for o idx only because each time the string \\'s\\' has changed to s.substring(i + 1)\\n        for(int i = 0; i < s.length(); i++) {\\n            currentNum = currentNum * 10 + s.charAt(i) - \\'0\\'; // form the number\\n            if(currentNum >= 10000000000L) { // longer than long range; avoids overflow\\n                return false;\\n            }\\n            \\n            if(previousNum == null) { // no previous num exists, meaning making the fresh current num\\n                if(isPossible(s.substring(i + 1), currentNum)) { // recursively check if the remaining substring and current num satisifes the rules\\n                    return true;\\n                }\\n            } // if there exists a number FORMED previously then check if the current num and previous num have a diff of 1 with (previous num > current num) AND\\n            // if either we have reached the end to string \\'s\\' OR\\n            // the remaining substring ALSO satisfies the rules,\\n            // then return TRUE otherwise keep forming number and checking ALL the rules\\n            else if (currentNum == previousNum - 1 && (i == s.length() - 1 || isPossible(s.substring(i + 1), currentNum))) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        return isPossible(s, null);\\n    }\\n    \\n    // Long and not long in parameter because \\'long\\' cannot take \\'null\\' but \\'Long\\' can\\n    private boolean isPossible(String s, Long previousNum) {\\n        long currentNum = 0;\\n        \\n        // ALWAYS starting making num for o idx only because each time the string \\'s\\' has changed to s.substring(i + 1)\\n        for(int i = 0; i < s.length(); i++) {\\n            currentNum = currentNum * 10 + s.charAt(i) - \\'0\\'; // form the number\\n            if(currentNum >= 10000000000L) { // longer than long range; avoids overflow\\n                return false;\\n            }\\n            \\n            if(previousNum == null) { // no previous num exists, meaning making the fresh current num\\n                if(isPossible(s.substring(i + 1), currentNum)) { // recursively check if the remaining substring and current num satisifes the rules\\n                    return true;\\n                }\\n            } // if there exists a number FORMED previously then check if the current num and previous num have a diff of 1 with (previous num > current num) AND\\n            // if either we have reached the end to string \\'s\\' OR\\n            // the remaining substring ALSO satisfies the rules,\\n            // then return TRUE otherwise keep forming number and checking ALL the rules\\n            else if (currentNum == previousNum - 1 && (i == s.length() - 1 || isPossible(s.substring(i + 1), currentNum))) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424344,
                "title": "python-backtrack-clean",
                "content": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        def dfs(i, last_value):\\n            if i == len(s):\\n                return last_value != int(s)\\n            \\n            for j in range(i, len(s)):\\n                if (last_value is None or last_value - int(s[i:j + 1]) == 1) and dfs(j + 1, int(s[i:j + 1])):\\n                    return True\\n            return False\\n        return dfs(0, None)",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        def dfs(i, last_value):\\n            if i == len(s):\\n                return last_value != int(s)\\n            \\n            for j in range(i, len(s)):\\n                if (last_value is None or last_value - int(s[i:j + 1]) == 1) and dfs(j + 1, int(s[i:j + 1])):\\n                    return True\\n            return False\\n        return dfs(0, None)",
                "codeTag": "Java"
            },
            {
                "id": 2419111,
                "title": "ruby-backtracing",
                "content": "```\\n# @param {String} s\\n# @return {Boolean}\\ndef split_string(s)\\n    @path = []\\n    @result = []\\n    @string = s\\n    dfs(0)\\n    return !@result.empty?\\nend\\n\\ndef dfs(i)\\n    if i == @string.length && @path.length > 1\\n       @result << @path[0..-1] \\n       return \\n    end\\n    j = i\\n    while(j < @string.length)\\n       @path << @string[i..j]\\n       if condition \\n         dfs(j+1) \\n       end\\n       @path.pop \\n       j = j + 1 \\n    end\\nend\\n\\ndef condition\\n   @path.length == 1 || (@path[-1].to_i + 1 == @path[-2].to_i)\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {String} s\\n# @return {Boolean}\\ndef split_string(s)\\n    @path = []\\n    @result = []\\n    @string = s\\n    dfs(0)\\n    return !@result.empty?\\nend\\n\\ndef dfs(i)\\n    if i == @string.length && @path.length > 1\\n       @result << @path[0..-1] \\n       return \\n    end\\n    j = i\\n    while(j < @string.length)\\n       @path << @string[i..j]\\n       if condition \\n         dfs(j+1) \\n       end\\n       @path.pop \\n       j = j + 1 \\n    end\\nend\\n\\ndef condition\\n   @path.length == 1 || (@path[-1].to_i + 1 == @path[-2].to_i)\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2384619,
                "title": "typescript-100",
                "content": "```\\nfunction splitString(s: string): boolean {\\n    \\n    let n = s.length;\\n    \\n    function isValid(i, last) {\\n        if(i>=n) {\\n            return true;\\n        }\\n        \\n        for(let j= 1; j<=n; j++) {\\n            let val = +s.substr(i,j);\\n            if(val == last -1 && isValid(i+j, val)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    for(let i=1; i<n; i++) {\\n        if(isValid(i, +s.substr(0,i))) {\\n            return true;\\n        }\\n    }\\n    return false;\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/660dedc7-e7f9-4bad-bcf3-7b4d5724fb63_1659729260.4821222.png)\\n",
                "solutionTags": [],
                "code": "```\\nfunction splitString(s: string): boolean {\\n    \\n    let n = s.length;\\n    \\n    function isValid(i, last) {\\n        if(i>=n) {\\n            return true;\\n        }\\n        \\n        for(let j= 1; j<=n; j++) {\\n            let val = +s.substr(i,j);\\n            if(val == last -1 && isValid(i+j, val)) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    for(let i=1; i<n; i++) {\\n        if(isValid(i, +s.substr(0,i))) {\\n            return true;\\n        }\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2370716,
                "title": "python-3-dfs-short-and-concise",
                "content": "choose the first No. and corrensponding to that do the DFS\\n\\n\\tclass Solution:\\n\\t\\tdef splitString(self, s: str) -> bool:\\n\\t\\t\\tn=len(s)\\n\\t\\t\\tdef solve(i,last):\\n\\t\\t\\t\\tif i==n:\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\tfor j in range(i+1,n+1):\\n\\t\\t\\t\\t\\tk=int(s[i:j])\\n\\t\\t\\t\\t\\tif last-k==1 and solve(j,k):\\n\\t\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\treturn False\\n\\t\\t\\tfor i in range(1,n):\\n\\t\\t\\t\\tif solve(i,int(s[:i])):\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\treturn False",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "choose the first No. and corrensponding to that do the DFS\\n\\n\\tclass Solution:\\n\\t\\tdef splitString(self, s: str) -> bool:\\n\\t\\t\\tn=len(s)\\n\\t\\t\\tdef solve(i,last):\\n\\t\\t\\t\\tif i==n:\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\tfor j in range(i+1,n+1):\\n\\t\\t\\t\\t\\tk=int(s[i:j])\\n\\t\\t\\t\\t\\tif last-k==1 and solve(j,k):\\n\\t\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\treturn False\\n\\t\\t\\tfor i in range(1,n):\\n\\t\\t\\t\\tif solve(i,int(s[:i])):\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\treturn False",
                "codeTag": "Java"
            },
            {
                "id": 2353252,
                "title": "c-recursive-code",
                "content": "```\\nclass Solution {\\npublic:\\n    bool flag=false;\\n    \\n    void func(string &s,int idx,int ct,long long prev){\\n        if (idx>=s.length()){\\n            if (ct<=1){\\n                return;\\n            }\\n\\n            flag=true;\\n            return;\\n        }\\n        \\n        string str;\\n        for (int i=idx; i<s.length(); i++){\\n            str+=s[i];\\n            if (str.length()>18){\\n                reverse(str.begin(),str.end());\\n                while (str.back()==\\'0\\'){\\n                    str.pop_back();\\n                }\\n                reverse(str.begin(),str.end());\\n                \\n                if (str.length()>18){\\n                   continue;\\n                }\\n            }\\n                \\n            long long val=stoll(str);\\n            \\n            if (prev==-1 || prev-val==1){\\n                func(s,i+1,ct+1,val);\\n            }\\n        }\\n        \\n    }\\n    \\n    bool splitString(string s) {\\n       func(s,0,0,-1);\\n     return flag;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool flag=false;\\n    \\n    void func(string &s,int idx,int ct,long long prev){\\n        if (idx>=s.length()){\\n            if (ct<=1){\\n                return;\\n            }\\n\\n            flag=true;\\n            return;\\n        }\\n        \\n        string str;\\n        for (int i=idx; i<s.length(); i++){\\n            str+=s[i];\\n            if (str.length()>18){\\n                reverse(str.begin(),str.end());\\n                while (str.back()==\\'0\\'){\\n                    str.pop_back();\\n                }\\n                reverse(str.begin(),str.end());\\n                \\n                if (str.length()>18){\\n                   continue;\\n                }\\n            }\\n                \\n            long long val=stoll(str);\\n            \\n            if (prev==-1 || prev-val==1){\\n                func(s,i+1,ct+1,val);\\n            }\\n        }\\n        \\n    }\\n    \\n    bool splitString(string s) {\\n       func(s,0,0,-1);\\n     return flag;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2353193,
                "title": "runtime-0-ms-faster-than-100-00-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    bool helper(string s,long long int prev){\\n        if(s.size()==0){\\n            return true;\\n        }\\n        long long int curr=0;\\n        for(int i=0;i<s.size();i++){\\n            if(curr>=1e17){\\n                break;\\n            }\\n            curr=curr*(long long)10+(s[i]-\\'0\\');\\n            if((i!=s.size()-1&&prev==-1||prev-curr==1)&&helper(s.substr(i+1),curr)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    bool splitString(string s) {\\n        return helper(s,-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool helper(string s,long long int prev){\\n        if(s.size()==0){\\n            return true;\\n        }\\n        long long int curr=0;\\n        for(int i=0;i<s.size();i++){\\n            if(curr>=1e17){\\n                break;\\n            }\\n            curr=curr*(long long)10+(s[i]-\\'0\\');\\n            if((i!=s.size()-1&&prev==-1||prev-curr==1)&&helper(s.substr(i+1),curr)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    bool splitString(string s) {\\n        return helper(s,-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2305778,
                "title": "elegant-c-faster-than-100",
                "content": "```\\n\\nclass Solution\\n{\\npublic:\\n    typedef long long ll;\\n    bool cansplit(int sidx, ll prev, string &s)\\n    {\\n        if (sidx >= s.size())\\n            return true;\\n\\n        ll num = 0;\\n\\n        for (int i = sidx; i < s.size(); i++)\\n        {\\n            if (sidx == 0 && i + 1 == s.size())\\n                break;\\n\\n                if(num>=1e17)\\n                    break;\\n                    \\n            num = num * (ll)10 +   (s[i] - \\'0\\');\\n\\n            if (prev == -1 || prev - num == 1)\\n            {\\n\\n                if (cansplit(i + 1, num, s))\\n                    return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    bool splitString(string s)\\n    {\\n        return cansplit(0, -1, s);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution\\n{\\npublic:\\n    typedef long long ll;\\n    bool cansplit(int sidx, ll prev, string &s)\\n    {\\n        if (sidx >= s.size())\\n            return true;\\n\\n        ll num = 0;\\n\\n        for (int i = sidx; i < s.size(); i++)\\n        {\\n            if (sidx == 0 && i + 1 == s.size())\\n                break;\\n\\n                if(num>=1e17)\\n                    break;\\n                    \\n            num = num * (ll)10 +   (s[i] - \\'0\\');\\n\\n            if (prev == -1 || prev - num == 1)\\n            {\\n\\n                if (cansplit(i + 1, num, s))\\n                    return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    bool splitString(string s)\\n    {\\n        return cansplit(0, -1, s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2305679,
                "title": "java-backtracking-with-try-catch-for-parselong-d",
                "content": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        \\n        for(int i=0; i<s.length()-1; i++){\\n            \\n            \\n            if(backtrack(s,i+1,s.substring(0,i+1))){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    \\n    boolean backtrack(String s, int i, String prev){\\n        \\n        if(i == s.length()){\\n            return true;\\n        }\\n        \\n        if(prev.length() >= 20){\\n            return false;\\n        }\\n        \\n        long prevVal;\\n        \\n        try{\\n            prevVal = Long.parseLong(prev);\\n        }catch(NumberFormatException e){\\n            return false;\\n        }\\n        \\n        \\n        for(int j=i; j<s.length(); j++){\\n            \\n            String curr = s.substring(i,j+1);\\n            Long val;\\n            \\n            try{\\n                val = Long.parseLong(curr);\\n            }catch(NumberFormatException e){\\n                continue;\\n            }\\n             \\n            \\n            if(val + 1 == prevVal && backtrack(s,j+1,curr)){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        \\n        for(int i=0; i<s.length()-1; i++){\\n            \\n            \\n            if(backtrack(s,i+1,s.substring(0,i+1))){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    \\n    boolean backtrack(String s, int i, String prev){\\n        \\n        if(i == s.length()){\\n            return true;\\n        }\\n        \\n        if(prev.length() >= 20){\\n            return false;\\n        }\\n        \\n        long prevVal;\\n        \\n        try{\\n            prevVal = Long.parseLong(prev);\\n        }catch(NumberFormatException e){\\n            return false;\\n        }\\n        \\n        \\n        for(int j=i; j<s.length(); j++){\\n            \\n            String curr = s.substring(i,j+1);\\n            Long val;\\n            \\n            try{\\n                val = Long.parseLong(curr);\\n            }catch(NumberFormatException e){\\n                continue;\\n            }\\n             \\n            \\n            if(val + 1 == prevVal && backtrack(s,j+1,curr)){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2299660,
                "title": "backtracking-python-easy",
                "content": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        tmp = []\\n        def isValid(tmp):\\n            for i in range(1, len(tmp)):\\n                if tmp[i]  != tmp[i-1] - 1: # 2 != 1 -1\\n                    return False\\n            return True\\n        def helper(i):\\n            if i >= len(s):\\n                if isValid(tmp):\\n                    return True\\n                return False\\n            for j in range(1, len(s)):\\n                if len(tmp) >= 2:\\n                    if tmp[-1] + 1 != tmp[-2]:\\n                        return False\\n                tmp.append(int(s[i: i+j]))\\n                if helper(i+j):\\n                    return True\\n                tmp.pop()\\n            return False        \\n\\n        return helper(0)\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        tmp = []\\n        def isValid(tmp):\\n            for i in range(1, len(tmp)):\\n                if tmp[i]  != tmp[i-1] - 1: # 2 != 1 -1\\n                    return False\\n            return True\\n        def helper(i):\\n            if i >= len(s):\\n                if isValid(tmp):\\n                    return True\\n                return False\\n            for j in range(1, len(s)):\\n                if len(tmp) >= 2:\\n                    if tmp[-1] + 1 != tmp[-2]:\\n                        return False\\n                tmp.append(int(s[i: i+j]))\\n                if helper(i+j):\\n                    return True\\n                tmp.pop()\\n            return False        \\n\\n        return helper(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2279891,
                "title": "javascript-fast-simple-memory-efficient-solution",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar splitString = function (s, previous) {\\n    if (s.length === 1) return false;\\n\\n    for (let i = 1; i < s.length; i++) {\\n        const first = Number(s.substring(0, i));\\n\\n        if (first === previous - 1 || previous === undefined) {\\n\\n            for (let j = i + 1; j <= s.length; j++) {\\n                const second = Number(s.substring(i, j));\\n\\n                if (second === first - 1) {\\n                    if (j === s.length || Number(s.substring(j)) === second - 1) return true;\\n                    else {\\n                        const found = splitString(s.substring(j), second);\\n                        if (found) return true;\\n                    }\\n                }\\n            }\\n        }\\n        // if no such substring found return false\\n        if (i === s.length - 1) return false\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar splitString = function (s, previous) {\\n    if (s.length === 1) return false;\\n\\n    for (let i = 1; i < s.length; i++) {\\n        const first = Number(s.substring(0, i));\\n\\n        if (first === previous - 1 || previous === undefined) {\\n\\n            for (let j = i + 1; j <= s.length; j++) {\\n                const second = Number(s.substring(i, j));\\n\\n                if (second === first - 1) {\\n                    if (j === s.length || Number(s.substring(j)) === second - 1) return true;\\n                    else {\\n                        const found = splitString(s.substring(j), second);\\n                        if (found) return true;\\n                    }\\n                }\\n            }\\n        }\\n        // if no such substring found return false\\n        if (i === s.length - 1) return false\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2211155,
                "title": "c-backtracking-4ms",
                "content": "```\\nbool recurse(string s, int i, long long prev, long long curr) {\\n    if (i>=s.size()) {\\n        return curr <= prev && prev-curr==1;\\n    }\\n    if (curr<=prev && curr*10+s[i]-48 <= prev) {\\n        if (recurse(s, i+1, prev, curr*10+s[i]-48)){\\n            return true;\\n        }\\n    }\\n    if (s[i]-48 <= curr && prev-curr == 1) {\\n        return recurse(s, i+1, curr, s[i]-48);\\n    }\\n    return false;\\n}\\n\\nbool splitString(string s) {\\n    long long n=s.size();\\n    if (n<2) {\\n        return false;\\n    }\\n    if (n==2) {\\n        return s[0]-s[1]==1;\\n    }\\n    long long prev=0;\\n    for (int i=0;i<n-1;i++) {\\n        if (i==n-2 && prev>100) {\\n            return false;\\n        }\\n        prev = prev*10+s[i]-48;\\n        if (recurse(s, i+2, prev, s[i+1]-48)) {\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nbool recurse(string s, int i, long long prev, long long curr) {\\n    if (i>=s.size()) {\\n        return curr <= prev && prev-curr==1;\\n    }\\n    if (curr<=prev && curr*10+s[i]-48 <= prev) {\\n        if (recurse(s, i+1, prev, curr*10+s[i]-48)){\\n            return true;\\n        }\\n    }\\n    if (s[i]-48 <= curr && prev-curr == 1) {\\n        return recurse(s, i+1, curr, s[i]-48);\\n    }\\n    return false;\\n}\\n\\nbool splitString(string s) {\\n    long long n=s.size();\\n    if (n<2) {\\n        return false;\\n    }\\n    if (n==2) {\\n        return s[0]-s[1]==1;\\n    }\\n    long long prev=0;\\n    for (int i=0;i<n-1;i++) {\\n        if (i==n-2 && prev>100) {\\n            return false;\\n        }\\n        prev = prev*10+s[i]-48;\\n        if (recurse(s, i+2, prev, s[i+1]-48)) {\\n            return true;\\n        }\\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2152720,
                "title": "backtracking-solution-for-java-with-comments",
                "content": "```\\n\\t/*\\n        Returns true if \\'s\\' from index \\'start\\' can be split\\n    */\\n    public boolean backtrack(String s, int start, long previous) {\\n        if (start == s.length()) { // Base Case: If we reach end of string, then we found a valid split\\n            return true;\\n        }\\n        \\n        StringBuilder current = new StringBuilder();\\n        int end = s.length() - 1;\\n        if (previous == -1) // This is needed to ensure that there will always be at two substrings in the split\\n            end -= 1;\\n        \\n        long val = 0;\\n        for (int i = start; i <= end; i++) {\\n            current.append(s.charAt(i)); // Try s[:i], s[:i+1], s[:i+2]....\\n            \\n            val = val*10 + (s.charAt(i) - \\'0\\');\\n            \\n            // If s[:i] == previous-1, and s[i+1:] can be split up, then return true\\n            if ((previous-val == 1 || previous == -1) && backtrack(s, i+1, val)) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\n\\t/*\\n        Returns true if \\'s\\' from index \\'start\\' can be split\\n    */\\n    public boolean backtrack(String s, int start, long previous) {\\n        if (start == s.length()) { // Base Case: If we reach end of string, then we found a valid split\\n            return true;\\n        }\\n        \\n        StringBuilder current = new StringBuilder();\\n        int end = s.length() - 1;\\n        if (previous == -1) // This is needed to ensure that there will always be at two substrings in the split\\n            end -= 1;\\n        \\n        long val = 0;\\n        for (int i = start; i <= end; i++) {\\n            current.append(s.charAt(i)); // Try s[:i], s[:i+1], s[:i+2]....\\n            \\n            val = val*10 + (s.charAt(i) - \\'0\\');\\n            \\n            // If s[:i] == previous-1, and s[i+1:] can be split up, then return true\\n            if ((previous-val == 1 || previous == -1) && backtrack(s, i+1, val)) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2112950,
                "title": "rust-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn split_string(s: String) -> bool {\\n        if s.len() == 0 || Self::parse_int(&s) == 0 {\\n            return false;\\n        }\\n        for i in 0..s.len() {\\n            let prev = Self::parse_int(&s[(s.len() - i - 1)..s.len()]);\\n            if Self::helper(&s[..(s.len() - i - 1)], prev) {\\n                return true;\\n            }\\n        }\\n        false\\n    }\\n\\n    fn helper(s: &str, prev: i128) -> bool {\\n        if s.len() == 0 {\\n            return false;\\n        }\\n        for i in 0..s.len() {\\n            let current = Self::parse_int(&s[(s.len() - i - 1)..s.len()]);\\n            if current - prev == 1 {\\n                let sl = &s[..(s.len()) - i - 1];\\n                if sl.len() == 0 || Self::helper(sl, current) {\\n                    return true;\\n                }\\n            }\\n        }\\n        false\\n    }\\n\\n    fn parse_int(s: &str) -> i128 {\\n        s.parse::<i128>().unwrap()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Recursion"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn split_string(s: String) -> bool {\\n        if s.len() == 0 || Self::parse_int(&s) == 0 {\\n            return false;\\n        }\\n        for i in 0..s.len() {\\n            let prev = Self::parse_int(&s[(s.len() - i - 1)..s.len()]);\\n            if Self::helper(&s[..(s.len() - i - 1)], prev) {\\n                return true;\\n            }\\n        }\\n        false\\n    }\\n\\n    fn helper(s: &str, prev: i128) -> bool {\\n        if s.len() == 0 {\\n            return false;\\n        }\\n        for i in 0..s.len() {\\n            let current = Self::parse_int(&s[(s.len() - i - 1)..s.len()]);\\n            if current - prev == 1 {\\n                let sl = &s[..(s.len()) - i - 1];\\n                if sl.len() == 0 || Self::helper(sl, current) {\\n                    return true;\\n                }\\n            }\\n        }\\n        false\\n    }\\n\\n    fn parse_int(s: &str) -> i128 {\\n        s.parse::<i128>().unwrap()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2071939,
                "title": "javascript-backtracking",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar splitString = function(s) {\\n    \\n    const backtracking = (index, prevStringValue) => {\\n        if(index === s.length) {\\n            return true;\\n        }\\n        for(let i = index; i < s.length; i++) {    \\n            const currStringValue = s.slice(index ,i + 1);\\n            \\n            if(parseInt(prevStringValue, 10) === parseInt(currStringValue, 10) + 1) {\\n                if(backtracking(i + 1, currStringValue)) {\\n                    return true;\\n                }\\n            }\\n        }\\n    }\\n    // we need to have at least two values to compare, so we start with the for outside the backtracking function\\n    for (let i = 1; i <= s.length - 1; i++) {\\n        const currStringValue = s.slice(0, i);\\n        if (backtracking(i, currStringValue)) {\\n            return true;\\n        }\\n    }\\n    return false\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {boolean}\\n */\\nvar splitString = function(s) {\\n    \\n    const backtracking = (index, prevStringValue) => {\\n        if(index === s.length) {\\n            return true;\\n        }\\n        for(let i = index; i < s.length; i++) {    \\n            const currStringValue = s.slice(index ,i + 1);\\n            \\n            if(parseInt(prevStringValue, 10) === parseInt(currStringValue, 10) + 1) {\\n                if(backtracking(i + 1, currStringValue)) {\\n                    return true;\\n                }\\n            }\\n        }\\n    }\\n    // we need to have at least two values to compare, so we start with the for outside the backtracking function\\n    for (let i = 1; i <= s.length - 1; i++) {\\n        const currStringValue = s.slice(0, i);\\n        if (backtracking(i, currStringValue)) {\\n            return true;\\n        }\\n    }\\n    return false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2035755,
                "title": "java-backtracking-with-binary-search",
                "content": "```\\nclass Solution {\\n    char[] sc;\\n    public boolean splitString(String s) {\\n        sc = s.toCharArray();\\n        for (int i = 0; i < sc.length -1 ; i++) {\\n            if (dfs(i+1, toLong(0, i))) return true;\\n        }\\n        return false;\\n    }\\n    \\n    boolean dfs(int start, long prev) {\\n        if (start == sc.length) return true;\\n        int low = start;\\n        int high = sc.length - 1;\\n        while (low <= high) {\\n            int mid = low + (high - low)/2;\\n            long curr = toLong(start, mid);\\n            if (curr + 1 == prev) {\\n                if (dfs(mid+1, curr)) return true;\\n                low++;\\n            } else if (curr > prev) {\\n                high = mid -1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    long toLong(int start, int end) {\\n        long curr = 0;\\n        while (start <= end) {\\n            curr = curr*10 + Character.getNumericValue(sc[start++]);\\n        }\\n        return curr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    char[] sc;\\n    public boolean splitString(String s) {\\n        sc = s.toCharArray();\\n        for (int i = 0; i < sc.length -1 ; i++) {\\n            if (dfs(i+1, toLong(0, i))) return true;\\n        }\\n        return false;\\n    }\\n    \\n    boolean dfs(int start, long prev) {\\n        if (start == sc.length) return true;\\n        int low = start;\\n        int high = sc.length - 1;\\n        while (low <= high) {\\n            int mid = low + (high - low)/2;\\n            long curr = toLong(start, mid);\\n            if (curr + 1 == prev) {\\n                if (dfs(mid+1, curr)) return true;\\n                low++;\\n            } else if (curr > prev) {\\n                high = mid -1;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    long toLong(int start, int end) {\\n        long curr = 0;\\n        while (start <= end) {\\n            curr = curr*10 + Character.getNumericValue(sc[start++]);\\n        }\\n        return curr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2010385,
                "title": "go-backtracking-solution",
                "content": "This question is similar to https://leetcode.com/problems/palindrome-partitioning/\\n\\nAt each iteration, we check if the comb is valid, and recursively call the next index if it is.\\n\\nAt the base case, we set result to true if length is more than 1.\\n\\n```\\nfunc splitString(s string) bool {\\n    n := len(s)\\n    \\n    res := false\\n    \\n    var iter func(start int, comb []string)\\n    iter = func(start int, comb []string) {\\n        if start == n {\\n            if len(comb) > 1 {\\n                res = true            \\n            }\\n            return\\n        }\\n        \\n        for i := start; i < n; i++ {\\n            comb = append(comb, s[start:i+1])\\n            \\n            if isValid(comb) {\\n                iter(i+1, comb)\\n            }\\n            \\n            comb = comb[:len(comb)-1]\\n        }\\n    }\\n    \\n    iter(0, nil)\\n    \\n    return res\\n}\\n\\nfunc isValid(comb []string) bool {\\n    n := len(comb)\\n    \\n    if n >= 2 {\\n        first, _ := strconv.Atoi(comb[n-2])\\n        second, _ := strconv.Atoi(comb[n-1])\\n        return first - second == 1\\n    }\\n    \\n    return true\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Backtracking"
                ],
                "code": "```\\nfunc splitString(s string) bool {\\n    n := len(s)\\n    \\n    res := false\\n    \\n    var iter func(start int, comb []string)\\n    iter = func(start int, comb []string) {\\n        if start == n {\\n            if len(comb) > 1 {\\n                res = true            \\n            }\\n            return\\n        }\\n        \\n        for i := start; i < n; i++ {\\n            comb = append(comb, s[start:i+1])\\n            \\n            if isValid(comb) {\\n                iter(i+1, comb)\\n            }\\n            \\n            comb = comb[:len(comb)-1]\\n        }\\n    }\\n    \\n    iter(0, nil)\\n    \\n    return res\\n}\\n\\nfunc isValid(comb []string) bool {\\n    n := len(comb)\\n    \\n    if n >= 2 {\\n        first, _ := strconv.Atoi(comb[n-2])\\n        second, _ := strconv.Atoi(comb[n-1])\\n        return first - second == 1\\n    }\\n    \\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2003042,
                "title": "java-short-backtracking",
                "content": "We check all possible combinations and backtrack whenever the current combo couldn\\'t be valid.\\n\\nDue to max length being 20, it technically can overflow at length 19 and produce incorrect result when comparing to the string at length 20, but it passes the test cases still without the check.\\n```Java\\nclass Solution {\\n    public boolean splitString(String s) {\\n        return solve(0, -1, s, 0);\\n    }\\n\\n    private boolean solve(int i, long prev, String s, int k){\\n        if (i == s.length())\\n            return k >= 2; // We need at least 2 groups.\\n        long cur = 0;\\n        for (int j = i; j < s.length(); j++){\\n            // if ((Long.MAX_VALUE - (s.charAt(j) - \\'0\\'))/10 < cur)\\n            //     return false;\\n            cur = cur * 10 + s.charAt(j) - \\'0\\';\\n            if ((prev == -1 || prev - cur == 1) && solve(j + 1, cur, s, k + 1))\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public boolean splitString(String s) {\\n        return solve(0, -1, s, 0);\\n    }\\n\\n    private boolean solve(int i, long prev, String s, int k){\\n        if (i == s.length())\\n            return k >= 2; // We need at least 2 groups.\\n        long cur = 0;\\n        for (int j = i; j < s.length(); j++){\\n            // if ((Long.MAX_VALUE - (s.charAt(j) - \\'0\\'))/10 < cur)\\n            //     return false;\\n            cur = cur * 10 + s.charAt(j) - \\'0\\';\\n            if ((prev == -1 || prev - cur == 1) && solve(j + 1, cur, s, k + 1))\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1921014,
                "title": "c-recursive-with-pruning-faster-that-100",
                "content": "```\\npublic class Solution {\\n    public bool SplitString(string s)\\n    {\\n        long first = 0;\\n        for (int i = 0; i < s.Length - 1; i++)\\n        {\\n            first *= 10;\\n            first += s[i] - \\'0\\';\\n            \\n            if (CanSplit(i + 1, first)) return true;\\n        }\\n        \\n        return false;\\n\\n        bool CanSplit(int start, long previous)\\n        {\\n            if (start == s.Length) return true;\\n\\n            long current = 0;             \\n            for (int i = start; i < s.Length; i++)\\n            {\\n                current *= 10;\\n                current += s[i] - \\'0\\';\\n                \\n                if (current >= previous) break;\\n                \\n                if (previous - current != 1) continue;\\n                \\n                if (CanSplit(i + 1, current)) return true;\\n            }\\n\\n            return false;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool SplitString(string s)\\n    {\\n        long first = 0;\\n        for (int i = 0; i < s.Length - 1; i++)\\n        {\\n            first *= 10;\\n            first += s[i] - \\'0\\';\\n            \\n            if (CanSplit(i + 1, first)) return true;\\n        }\\n        \\n        return false;\\n\\n        bool CanSplit(int start, long previous)\\n        {\\n            if (start == s.Length) return true;\\n\\n            long current = 0;             \\n            for (int i = start; i < s.Length; i++)\\n            {\\n                current *= 10;\\n                current += s[i] - \\'0\\';\\n                \\n                if (current >= previous) break;\\n                \\n                if (previous - current != 1) continue;\\n                \\n                if (CanSplit(i + 1, current)) return true;\\n            }\\n\\n            return false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1918162,
                "title": "python-backtracking-best-solution",
                "content": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        return self.help(s, 0, None)\\n    \\n    def help(self, s, i, last):\\n        if i == len(s):\\n            return True\\n        \\n        for j in range(i + 1, len(s) + 1 if last != None else len(s)):\\n            intVal = int(s[i:j])\\n            \\n            if (last == None or intVal == last - 1) and self.help(s, j, intVal):\\n                return True\\n                \\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        return self.help(s, 0, None)\\n    \\n    def help(self, s, i, last):\\n        if i == len(s):\\n            return True\\n        \\n        for j in range(i + 1, len(s) + 1 if last != None else len(s)):\\n            intVal = int(s[i:j])\\n            \\n            if (last == None or intVal == last - 1) and self.help(s, j, intVal):\\n                return True\\n                \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1898913,
                "title": "javascript-solution-backtracking",
                "content": "I forgoed using the parseInt() method to trim off the leading zero and converting the string to an actual integer.\\n\\n```\\nvar splitString = function(s) {\\n    const n = s.length;\\n    \\n    let i = 0;\\n    \\n    while (i < n) {\\n        if (s.charAt(i) === \"0\") ++i;\\n        else break;\\n    }\\n    \\n    if (i === n) return false;\\n    \\n    const start = i;\\n    \\n    for (let i = start; i < n - 1; ++i) {\\n        const substr = s.substring(start, i + 1);\\n        const prevNum = subtractOne(substr);\\n        const restStr = s.substring(i + 1);\\n       \\n        if (checkRest(restStr, prevNum)) return true;\\n    }\\n    \\n    return false;\\n\\n    \\n    function checkRest(str, prevNum) {\\n        const n = str.length;\\n        \\n        if (n === 0) return true;\\n        \\n        for (let i = 0; i < n; ++i) {\\n            const currNum = str.substring(0, i + 1);\\n            \\n            if (areSame(prevNum, currNum)) {\\n                if (isZero(currNum) && i < n - 1) continue;\\n                \\n                const nextNum = subtractOne(currNum);\\n                const restStr = str.substring(i + 1);\\n                \\n                if (checkRest(restStr, nextNum)) return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n      \\n    function subtractOne(substr) {\\n        const digits = substr.split(\"\");\\n        \\n        let i = digits.length - 1;\\n        \\n        while (i >= 0) {\\n            const dig = digits[i];\\n            \\n            if (dig === \"0\") {\\n                digits[i] = \"9\";\\n            }\\n            else {\\n                digits[i] = parseInt(digits[i]) - 1;\\n                break;\\n            }\\n            i--;\\n        }\\n        \\n        let res = \"\";\\n        \\n        i = 0;\\n        \\n        while (i < n) {\\n            if (digits[i] === \"0\") ++i;\\n            else break;\\n        }\\n        \\n        for (; i < digits.length; ++i) {\\n            res += digits[i];\\n        }\\n        \\n        return res;\\n    }\\n    \\n    function isZero(str) {\\n        for (let i = 0; i < str.length; ++i) {\\n            if (str.charAt(i) != \"0\") return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    function areSame(num1, num2) {\\n        const m = num1.length; // We are going to want m to be longer\\n        const n = num2.length; // We want n to be shorter\\n        \\n        if (m < n) return areSame(num2, num1);\\n        \\n        let i = m - 1; // for num1\\n        let j = n - 1; // for num2\\n        \\n        while (j >= 0) {\\n            const dig1 = num1[i];\\n            const dig2 = num2[j];\\n            \\n            if (dig1 != dig2) return false;\\n            --i;\\n            --j;\\n        }\\n        \\n        \\n        while (i >= 0) {\\n            if (num1[i] != \"0\") return false;\\n            --i;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\nvar splitString = function(s) {\\n    const n = s.length;\\n    \\n    let i = 0;\\n    \\n    while (i < n) {\\n        if (s.charAt(i) === \"0\") ++i;\\n        else break;\\n    }\\n    \\n    if (i === n) return false;\\n    \\n    const start = i;\\n    \\n    for (let i = start; i < n - 1; ++i) {\\n        const substr = s.substring(start, i + 1);\\n        const prevNum = subtractOne(substr);\\n        const restStr = s.substring(i + 1);\\n       \\n        if (checkRest(restStr, prevNum)) return true;\\n    }\\n    \\n    return false;\\n\\n    \\n    function checkRest(str, prevNum) {\\n        const n = str.length;\\n        \\n        if (n === 0) return true;\\n        \\n        for (let i = 0; i < n; ++i) {\\n            const currNum = str.substring(0, i + 1);\\n            \\n            if (areSame(prevNum, currNum)) {\\n                if (isZero(currNum) && i < n - 1) continue;\\n                \\n                const nextNum = subtractOne(currNum);\\n                const restStr = str.substring(i + 1);\\n                \\n                if (checkRest(restStr, nextNum)) return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n      \\n    function subtractOne(substr) {\\n        const digits = substr.split(\"\");\\n        \\n        let i = digits.length - 1;\\n        \\n        while (i >= 0) {\\n            const dig = digits[i];\\n            \\n            if (dig === \"0\") {\\n                digits[i] = \"9\";\\n            }\\n            else {\\n                digits[i] = parseInt(digits[i]) - 1;\\n                break;\\n            }\\n            i--;\\n        }\\n        \\n        let res = \"\";\\n        \\n        i = 0;\\n        \\n        while (i < n) {\\n            if (digits[i] === \"0\") ++i;\\n            else break;\\n        }\\n        \\n        for (; i < digits.length; ++i) {\\n            res += digits[i];\\n        }\\n        \\n        return res;\\n    }\\n    \\n    function isZero(str) {\\n        for (let i = 0; i < str.length; ++i) {\\n            if (str.charAt(i) != \"0\") return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    function areSame(num1, num2) {\\n        const m = num1.length; // We are going to want m to be longer\\n        const n = num2.length; // We want n to be shorter\\n        \\n        if (m < n) return areSame(num2, num1);\\n        \\n        let i = m - 1; // for num1\\n        let j = n - 1; // for num2\\n        \\n        while (j >= 0) {\\n            const dig1 = num1[i];\\n            const dig2 = num2[j];\\n            \\n            if (dig1 != dig2) return false;\\n            --i;\\n            --j;\\n        }\\n        \\n        \\n        while (i >= 0) {\\n            if (num1[i] != \"0\") return false;\\n            --i;\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1889311,
                "title": "js-solution-backtracking",
                "content": "var splitString = function(s) {\\n    for( let i=0; i < s.length-1; i++ ) {\\n        let val = parseInt(s.substring(0, i+1));\\n        if( valid(i+1, val) )\\n            return true\\n    }\\n    return false;\\n    \\n    function valid(i, prev ) {\\n        if( i === s.length )\\n            return true\\n        \\n        for( let j=i; j < s.length; j++ ) {\\n            let val = parseInt(s.substring(i, j+1));\\n            if( val + 1 === prev && valid(j+1, val) )\\n                return true\\n        }\\n        \\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "var splitString = function(s) {\\n    for( let i=0; i < s.length-1; i++ ) {\\n        let val = parseInt(s.substring(0, i+1));\\n        if( valid(i+1, val) )\\n            return true\\n    }\\n    return false;\\n    \\n    function valid(i, prev ) {\\n        if( i === s.length )\\n            return true\\n        \\n        for( let j=i; j < s.length; j++ ) {\\n            let val = parseInt(s.substring(i, j+1));\\n            if( val + 1 === prev && valid(j+1, val) )\\n                return true\\n        }\\n        \\n        return false;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1875910,
                "title": "python-solution-recursion-backtrack-suitable-comments",
                "content": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        l, n = len(s), int(s)\\n        def dfs(i, prev=None):\\n            if i == l:  # reach end (nothing to Explore)\\n                return prev != n  # As we need to split string atleast\\n\\n            for j in range(i, l):  \\n                e = j+1  # end index\\n                val = int(s[i:e]) # current extraction\\n                if prev != None:\\n                    if val+1 == prev and dfs(e, val):  # curr val becomes {prev} & seek for next number \\n                        return True \\n                else:\\n                    if dfs(e, val):\\n                        return True \\n\\n            return False \\n\\n        return dfs(0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        l, n = len(s), int(s)\\n        def dfs(i, prev=None):\\n            if i == l:  # reach end (nothing to Explore)\\n                return prev != n  # As we need to split string atleast\\n\\n            for j in range(i, l):  \\n                e = j+1  # end index\\n                val = int(s[i:e]) # current extraction\\n                if prev != None:\\n                    if val+1 == prev and dfs(e, val):  # curr val becomes {prev} & seek for next number \\n                        return True \\n                else:\\n                    if dfs(e, val):\\n                        return True \\n\\n            return False \\n\\n        return dfs(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1859427,
                "title": "python-recursion-no-explanation-faster-than-90-83",
                "content": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        L = len(s)\\n        for i in range(1, L):\\n            curr = int(str(s[:i]))\\n            if self.helper(curr - 1, i , s, L) == True:\\n                return True\\n        return False\\n    \\n    def helper(self, curr, i, s, L):\\n        if i >= L :\\n            return True\\n\\n        # Get rid of any leading 0s\\n        for j in range(i, L):\\n            if s[j] == \\'0\\':\\n                continue\\n            else:\\n                break\\n        \\n        # And check if the starting portion matches curr\\n        if s[j:j + len(str(curr))] != str(curr):\\n            return False\\n        return self.helper(curr - 1, j + len(str(curr)), s, L)\\n```\\nRuntime: 35 ms\\nMemory: 13.9 MB\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        L = len(s)\\n        for i in range(1, L):\\n            curr = int(str(s[:i]))\\n            if self.helper(curr - 1, i , s, L) == True:\\n                return True\\n        return False\\n    \\n    def helper(self, curr, i, s, L):\\n        if i >= L :\\n            return True\\n\\n        # Get rid of any leading 0s\\n        for j in range(i, L):\\n            if s[j] == \\'0\\':\\n                continue\\n            else:\\n                break\\n        \\n        # And check if the starting portion matches curr\\n        if s[j:j + len(str(curr))] != str(curr):\\n            return False\\n        return self.helper(curr - 1, j + len(str(curr)), s, L)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1837563,
                "title": "slow-but-easy-solution",
                "content": "I know the below solution is not so **fast** but I have applied my backtracking template and after many TLE\\'s it is working just fine so that\\'s why I am sharing it.\\n```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        s = str(int(s))\\n        def check(l):\\n            if len(l)<2:\\n                return False \\n            #print(l)\\n            for i in range(len(l)-1):\\n                if int(l[i])!=int(l[i+1])+1:\\n                    return False\\n            return True\\n        \\n        def backtrack(start,t,s):\\n            if start==len(s):\\n                if check(t):\\n                    return True\\n            for i in range(start,len(s)):\\n                if len(s[start:i+1])>1 and len(s[i+1:])>1 and int(s[start:i+1])<int(s[i+1:i+len(s[start:i+1])]):\\n                    continue\\n                if len(t)>1 and int(t[-1])<int(s[start:i+1]):\\n                    return\\n                t.append(s[start:i+1])\\n                if backtrack(i+1,t,s):\\n                    return True\\n                t.pop()\\n                \\n            return False    \\n        return backtrack(0,[],s)\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        s = str(int(s))\\n        def check(l):\\n            if len(l)<2:\\n                return False \\n            #print(l)\\n            for i in range(len(l)-1):\\n                if int(l[i])!=int(l[i+1])+1:\\n                    return False\\n            return True\\n        \\n        def backtrack(start,t,s):\\n            if start==len(s):\\n                if check(t):\\n                    return True\\n            for i in range(start,len(s)):\\n                if len(s[start:i+1])>1 and len(s[i+1:])>1 and int(s[start:i+1])<int(s[i+1:i+len(s[start:i+1])]):\\n                    continue\\n                if len(t)>1 and int(t[-1])<int(s[start:i+1]):\\n                    return\\n                t.append(s[start:i+1])\\n                if backtrack(i+1,t,s):\\n                    return True\\n                t.pop()\\n                \\n            return False    \\n        return backtrack(0,[],s)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1812599,
                "title": "dfs-easy-java-recursion",
                "content": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        int n = s.length();\\n\\n        if (n == 1) {\\n            return false;\\n        }\\n        \\n        long first = 0;\\n        for (int r = 0; r < n - 1; r++) {\\n            first = first * 10 + (s.charAt(r) - \\'0\\');\\n            if (dfs(s, first, r + 1)) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    private boolean dfs(String s, long prev, int l) {\\n        if (l == s.length()) {\\n            return true;\\n        }\\n\\n        boolean result = false;\\n        long current = 0;\\n        for (int r = l; r < s.length(); r++) {\\n            current = current * 10 + (s.charAt(r) - \\'0\\');\\n            if (prev - current == 1) {\\n                result |= dfs(s, current, r + 1);\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        int n = s.length();\\n\\n        if (n == 1) {\\n            return false;\\n        }\\n        \\n        long first = 0;\\n        for (int r = 0; r < n - 1; r++) {\\n            first = first * 10 + (s.charAt(r) - \\'0\\');\\n            if (dfs(s, first, r + 1)) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    private boolean dfs(String s, long prev, int l) {\\n        if (l == s.length()) {\\n            return true;\\n        }\\n\\n        boolean result = false;\\n        long current = 0;\\n        for (int r = l; r < s.length(); r++) {\\n            current = current * 10 + (s.charAt(r) - \\'0\\');\\n            if (prev - current == 1) {\\n                result |= dfs(s, current, r + 1);\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1782553,
                "title": "c-0ms-100-simple-dfs",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Splitting a String Into Descending Consecutive Values.\\nMemory Usage: 5.8 MB, less than 98.02% of C++ online submissions for Splitting a String Into Descending Consecutive Values.\\n```\\nclass Solution {\\npublic:\\n  inline long update(long &n, char &ch){return n = n*10 + ch - \\'0\\';}\\n  \\n  bool check(long N, int j, string &s){\\n    if(j == s.size()) return true;\\n    \\n    for(long i = j, n = 0; i != s.size() && N - n >= 1; i++)\\n      if(N - update(n,s[i]) == 1) \\n        if(n == 0) return count(s.begin() + j, s.end(), \\'0\\') == s.size() - j;\\n        else return check(n, i + 1, s);\\n        \\n    return false;\\n  }\\n  \\n  \\n  bool splitString(string s) {\\n    for(long i = 0, n = 0, lim = LONG_MAX / 10; i != s.size() - 1; i++)\\n      if( update(n,s[i]) >= lim) return false;\\n      else if(check(n, i + 1, s)) return true;\\n    \\n    return false;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  inline long update(long &n, char &ch){return n = n*10 + ch - \\'0\\';}\\n  \\n  bool check(long N, int j, string &s){\\n    if(j == s.size()) return true;\\n    \\n    for(long i = j, n = 0; i != s.size() && N - n >= 1; i++)\\n      if(N - update(n,s[i]) == 1) \\n        if(n == 0) return count(s.begin() + j, s.end(), \\'0\\') == s.size() - j;\\n        else return check(n, i + 1, s);\\n        \\n    return false;\\n  }\\n  \\n  \\n  bool splitString(string s) {\\n    for(long i = 0, n = 0, lim = LONG_MAX / 10; i != s.size() - 1; i++)\\n      if( update(n,s[i]) >= lim) return false;\\n      else if(check(n, i + 1, s)) return true;\\n    \\n    return false;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1763932,
                "title": "simple-javascript-solution",
                "content": "```\\nvar splitString = function(s) {    \\n    const help = (i, prev, next) => {\\n        if (i >= s.length) {\\n            return parseInt(prev) - parseInt(next) === 1;\\n        }\\n        \\n        let concat = false;\\n        if (prev && next && +prev - (+next) === 1) {\\n            concat = help(i+1, next, s[i]);\\n        } else if (!prev && next){\\n            concat = help(i+1, next, s[i]);\\n        }\\n        let keep = help(i+1, prev, next+s[i]);\\n        \\n        return concat || keep;\\n    }\\n    return help(0, \\'\\', \\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar splitString = function(s) {    \\n    const help = (i, prev, next) => {\\n        if (i >= s.length) {\\n            return parseInt(prev) - parseInt(next) === 1;\\n        }\\n        \\n        let concat = false;\\n        if (prev && next && +prev - (+next) === 1) {\\n            concat = help(i+1, next, s[i]);\\n        } else if (!prev && next){\\n            concat = help(i+1, next, s[i]);\\n        }\\n        let keep = help(i+1, prev, next+s[i]);\\n        \\n        return concat || keep;\\n    }\\n    return help(0, \\'\\', \\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1760702,
                "title": "java-o-n-2-dfs",
                "content": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        long t = 0;//first number, since s might have 20 digits, we use long\\n        \\n        for(int i=0;i<s.length()-1;i++){\\n            t = t*10+s.charAt(i)-\\'0\\';\\n            if(dfs(s,t,i+1))\\n                return true;\\n        }\\n        return false;\\n    }\\n    \\n    private boolean dfs(String s, long pre, int k){\\n        if(k==s.length())\\n            return true;\\n        \\n        long t=0;\\n        for(int i=k;i<s.length();i++){\\n            t = t*10+s.charAt(i)-\\'0\\';\\n            if(pre-1==t&&dfs(s,t,i+1)){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n\\n\\n//O(n) possible initial value, and for every initial value, \\n//we traverse the whole string in the worse case, which takes\\n//O(n) complexity. -> O(n^2) total complexity\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean splitString(String s) {\\n        long t = 0;//first number, since s might have 20 digits, we use long\\n        \\n        for(int i=0;i<s.length()-1;i++){\\n            t = t*10+s.charAt(i)-\\'0\\';\\n            if(dfs(s,t,i+1))\\n                return true;\\n        }\\n        return false;\\n    }\\n    \\n    private boolean dfs(String s, long pre, int k){\\n        if(k==s.length())\\n            return true;\\n        \\n        long t=0;\\n        for(int i=k;i<s.length();i++){\\n            t = t*10+s.charAt(i)-\\'0\\';\\n            if(pre-1==t&&dfs(s,t,i+1)){\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n\\n\\n//O(n) possible initial value, and for every initial value, \\n//we traverse the whole string in the worse case, which takes\\n//O(n) complexity. -> O(n^2) total complexity\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1756906,
                "title": "100-runtime-cpp-backtracking-try-catch",
                "content": "Using backtracking and bailing out if current number is greater than my digit where we split previously.\\n\\n```\\nclass Solution {\\npublic:\\n    bool splitString(string s) {\\n        for(int i = 1; i < s.size(); i++) {\\n            if(helper(s, i, s.substr(0,i)))\\n                return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool helper(string& s, int i, string d) {\\n        long long digit = 0;\\n        long long curr = 0;\\n        try {\\n            digit = stoll(d);\\n            curr = digit - stoll(s.substr(i));\\n            if(curr == 1) return true;\\n        }\\n        catch(...) {return false;};\\n        for(int j = i; j < s.size(); j++) {\\n            curr = digit - stoll(s.substr(i, j-i+1));\\n            if(curr <= 0) return false;\\n            if(curr == 1) {\\n                return helper(s, j+1, s.substr(i, j-i+1));\\n            }\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool splitString(string s) {\\n        for(int i = 1; i < s.size(); i++) {\\n            if(helper(s, i, s.substr(0,i)))\\n                return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1755227,
                "title": "python3-recursive-solution-with-a-helper-function-24ms-beats-99-24",
                "content": "Took me some time to debug since I was passing j instead of j - (k+1) in the recursion. Not very elegant at all, I know, but it still is pretty efficient.\\n```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        self.res = False\\n        def helper(s, k):\\n            n1 = int(s[:k+1])\\n            for j in range(k+1, len(s)):\\n                n2 = int(s[k+1:j+1])\\n                if n1 - n2 == 1:\\n                    if j == len(s)-1:\\n                        self.res = True \\n                    else: \\n                        helper(s[k+1:], j-(k+1))\\n                if n2 >= n1:\\n                    break\\n                        \\n        for i in range(len(s)):\\n            helper(s, i)\\n        return self.res\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        self.res = False\\n        def helper(s, k):\\n            n1 = int(s[:k+1])\\n            for j in range(k+1, len(s)):\\n                n2 = int(s[k+1:j+1])\\n                if n1 - n2 == 1:\\n                    if j == len(s)-1:\\n                        self.res = True \\n                    else: \\n                        helper(s[k+1:], j-(k+1))\\n                if n2 >= n1:\\n                    break\\n                        \\n        for i in range(len(s)):\\n            helper(s, i)\\n        return self.res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1733322,
                "title": "c-backtracking-solution-beats-100",
                "content": "```\\nclass Solution {\\nprivate:\\n    bool backtrack(string s,vector<long double>&curr){\\n        if(s.empty()){\\n            return curr.size()>=2;\\n        } else {\\n            for(int i=0;i<s.size();i++){\\n                long double num=stold(s.substr(0,i+1));\\n                if(curr.empty() or curr.back()-num==1.0){\\n                    curr.push_back(num);\\n                    if(backtrack(s.substr(i+1),curr)){\\n                        return true;\\n                    }\\n                    curr.pop_back();\\n                }\\n            }\\n            return false;\\n        }\\n    }\\npublic:\\n    bool splitString(string s) {\\n        vector<long double>curr;\\n        return backtrack(s,curr);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\nprivate:\\n    bool backtrack(string s,vector<long double>&curr){\\n        if(s.empty()){\\n            return curr.size()>=2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1718922,
                "title": "python-backtracking",
                "content": "It seems there is no better way than the bruteforce recursion with complexity of `O(N^2)` (Analysis: https://leetcode.com/problems/splitting-a-string-into-descending-consecutive-values/discuss/1186795/C%2B%2B-Backtracking-solution.-O(N-2)-and-time-complexity-analytics)\\n\\n```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        def find_split(cur_idx, n_splits, target):\\n            if cur_idx == len(s) and n_splits >= 2:\\n                return True\\n\\n            val = 0\\n            for i in range(cur_idx, len(s)):\\n                val = val * 10 + int(s[i])\\n                if target is None and val == 0:  # Skip leading 0s.\\n                    continue\\n                if target is None or val == target:\\n                    if find_split(i + 1, n_splits + 1, val - 1):\\n                        return True\\n                if target and val > target:  # Early break.\\n                    break\\n\\n            return False\\n    \\n        return find_split(0, 0, None)\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        def find_split(cur_idx, n_splits, target):\\n            if cur_idx == len(s) and n_splits >= 2:\\n                return True\\n\\n            val = 0\\n            for i in range(cur_idx, len(s)):\\n                val = val * 10 + int(s[i])\\n                if target is None and val == 0:  # Skip leading 0s.\\n                    continue\\n                if target is None or val == target:\\n                    if find_split(i + 1, n_splits + 1, val - 1):\\n                        return True\\n                if target and val > target:  # Early break.\\n                    break\\n\\n            return False\\n    \\n        return find_split(0, 0, None)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1680034,
                "title": "python-memo-dp-100-runtime",
                "content": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        \\n        n = len(s);\\n        \\n        @lru_cache(None)\\n        def dp(i,j):\\n\\t\\t\\t#when j hit to the last position, we know we finished partition\\n            if j == n:\\n\\t\\t\\t\\t#if i == 0 means we didn\\'t do partition, we just get whole string from 0-n\\n                if i == 0:\\n                    return False;\\n                return True;\\n\\t\\t\\t\\t\\n            #initial first lastNum as maximum;\\n            lastNum = float(\\'inf\\');\\n            if j != 0:\\n                lastNum = int(s[i:j]);\\n\\t\\t\\t\\t\\n\\t\\t\\t#iterate the nextNum as [j:k], and k will be the next j if valid\\n            for k in range(j+1,n+1):\\n                nextNum = int(s[j:k]);\\n                # ignore 0 but the last partition is an exception\\n                if nextNum == 0 and k != n:\\n                    continue;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t#if the lastNum is init val we can continue partition\\n                if lastNum == float(\\'inf\\') or nextNum + 1 == lastNum:\\n                    subProblem = dp(j,k);\\n                    if subProblem:\\n                        return True\\n                else:\\n\\t\\t\\t\\t\\t#since the nextNum already >= lastNum, we don\\'t need to append more char to get larger nextNum\\n                    if nextNum >= lastNum:\\n                        break;\\n                    \\n            return False;\\n        \\n        return dp(0,0)\\n        \\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def splitString(self, s: str) -> bool:\\n        \\n        n = len(s);\\n        \\n        @lru_cache(None)\\n        def dp(i,j):\\n\\t\\t\\t#when j hit to the last position, we know we finished partition\\n            if j == n:\\n\\t\\t\\t\\t#if i == 0 means we didn\\'t do partition, we just get whole string from 0-n\\n                if i == 0:\\n                    return False;\\n                return True;\\n\\t\\t\\t\\t\\n            #initial first lastNum as maximum;\\n            lastNum = float(\\'inf\\');\\n            if j != 0:\\n                lastNum = int(s[i:j]);\\n\\t\\t\\t\\t\\n\\t\\t\\t#iterate the nextNum as [j:k], and k will be the next j if valid\\n            for k in range(j+1,n+1):\\n                nextNum = int(s[j:k]);\\n                # ignore 0 but the last partition is an exception\\n                if nextNum == 0 and k != n:\\n                    continue;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t#if the lastNum is init val we can continue partition\\n                if lastNum == float(\\'inf\\') or nextNum + 1 == lastNum:\\n                    subProblem = dp(j,k);\\n                    if subProblem:\\n                        return True\\n                else:\\n\\t\\t\\t\\t\\t#since the nextNum already >= lastNum, we don\\'t need to append more char to get larger nextNum\\n                    if nextNum >= lastNum:\\n                        break;\\n                    \\n            return False;\\n        \\n        return dp(0,0)\\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1659591,
                "title": "go-brute",
                "content": "```\\nfunc splitString(s string) bool {\\n    return dfs(s, -1, 0)\\n}\\n\\nfunc dfs(s string, last int, cnt int) bool {\\n    if len(s) == 0 {\\n        return cnt >= 2\\n    }\\n    if last == 0 {\\n        return false\\n    }\\n    \\n    cur := 0\\n    for i, r := range s {\\n        cur = cur * 10 + int(r - \\'0\\')\\n        if cur == last - 1 || last == -1 {\\n            if dfs(s[i + 1:], cur, cnt + 1) {\\n                return true\\n            }\\n        }\\n        if cur > last && last != -1 {\\n            break\\n        }\\n    }\\n    return false\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc splitString(s string) bool {\\n    return dfs(s, -1, 0)\\n}\\n\\nfunc dfs(s string, last int, cnt int) bool {\\n    if len(s) == 0 {\\n        return cnt >= 2\\n    }\\n    if last == 0 {\\n        return false\\n    }\\n    \\n    cur := 0\\n    for i, r := range s {\\n        cur = cur * 10 + int(r - \\'0\\')\\n        if cur == last - 1 || last == -1 {\\n            if dfs(s[i + 1:], cur, cnt + 1) {\\n                return true\\n            }\\n        }\\n        if cur > last && last != -1 {\\n            break\\n        }\\n    }\\n    return false\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1949318,
                "content": [
                    {
                        "username": "leetcode199",
                        "content": "this should be a hard"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "A bit tricky but still a good question to brush up backtracking concept!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases\\n\\n```\\n000100098700065\\n9080701\\n20191817161514131211\\n1009998979695949392\\n22\\n```"
                    }
                ]
            },
            {
                "id": 1921544,
                "content": [
                    {
                        "username": "leetcode199",
                        "content": "this should be a hard"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "A bit tricky but still a good question to brush up backtracking concept!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases\\n\\n```\\n000100098700065\\n9080701\\n20191817161514131211\\n1009998979695949392\\n22\\n```"
                    }
                ]
            },
            {
                "id": 1986785,
                "content": [
                    {
                        "username": "leetcode199",
                        "content": "this should be a hard"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "A bit tricky but still a good question to brush up backtracking concept!"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases\\n\\n```\\n000100098700065\\n9080701\\n20191817161514131211\\n1009998979695949392\\n22\\n```"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Adjacent Swaps to Reach the Kth Smallest Number",
        "question_content": "<p>You are given a string <code>num</code>, representing a large integer, and an integer <code>k</code>.</p>\n\n<p>We call some integer <strong>wonderful</strong> if it is a <strong>permutation</strong> of the digits in <code>num</code> and is <strong>greater in value</strong> than <code>num</code>. There can be many wonderful integers. However, we only care about the <strong>smallest-valued</strong> ones.</p>\n\n<ul>\n\t<li>For example, when <code>num = &quot;5489355142&quot;</code>:\n\n\t<ul>\n\t\t<li>The 1<sup>st</sup> smallest wonderful integer is <code>&quot;5489355214&quot;</code>.</li>\n\t\t<li>The 2<sup>nd</sup> smallest wonderful integer is <code>&quot;5489355241&quot;</code>.</li>\n\t\t<li>The 3<sup>rd</sup> smallest wonderful integer is <code>&quot;5489355412&quot;</code>.</li>\n\t\t<li>The 4<sup>th</sup> smallest wonderful integer is <code>&quot;5489355421&quot;</code>.</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>Return <em>the <strong>minimum number of adjacent digit swaps</strong> that needs to be applied to </em><code>num</code><em> to reach the </em><code>k<sup>th</sup></code><em><strong> smallest wonderful</strong> integer</em>.</p>\n\n<p>The tests are generated in such a way that <code>k<sup>th</sup></code>&nbsp;smallest wonderful integer exists.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = &quot;5489355142&quot;, k = 4\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The 4<sup>th</sup> smallest wonderful number is &quot;5489355421&quot;. To get this number:\n- Swap index 7 with index 8: &quot;5489355<u>14</u>2&quot; -&gt; &quot;5489355<u>41</u>2&quot;\n- Swap index 8 with index 9: &quot;54893554<u>12</u>&quot; -&gt; &quot;54893554<u>21</u>&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = &quot;11112&quot;, k = 4\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> The 4<sup>th</sup> smallest wonderful number is &quot;21111&quot;. To get this number:\n- Swap index 3 with index 4: &quot;111<u>12</u>&quot; -&gt; &quot;111<u>21</u>&quot;\n- Swap index 2 with index 3: &quot;11<u>12</u>1&quot; -&gt; &quot;11<u>21</u>1&quot;\n- Swap index 1 with index 2: &quot;1<u>12</u>11&quot; -&gt; &quot;1<u>21</u>11&quot;\n- Swap index 0 with index 1: &quot;<u>12</u>111&quot; -&gt; &quot;<u>21</u>111&quot;\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = &quot;00123&quot;, k = 1\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The 1<sup>st</sup> smallest wonderful number is &quot;00132&quot;. To get this number:\n- Swap index 3 with index 4: &quot;001<u>23</u>&quot; -&gt; &quot;001<u>32</u>&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= num.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= k &lt;= 1000</code></li>\n\t<li><code>num</code> only consists of digits.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1186818,
                "title": "c-simple-solution-using-next-permutation",
                "content": "We\\'ll first find out kth permutation using next_permutation function.\\n\\n```\\noriginal: 5489355142 and kth-permutation: 5489355421\\n```\\n\\n**CATCH : Just find the min no. of steps to make original == kth-permutation  \\uD83D\\uDC40**\\n```\\nclass Solution {\\npublic:\\n    \\n    // GREEDY APPROACH\\n    // min steps to make strings equal\\n    \\n    int minSteps(string s1, string s2) {\\n        int size = s1.length();\\n        int i = 0, j = 0;\\n        int result = 0;\\n  \\n        while (i < size) {\\n            j = i;\\n            while (s1[j] != s2[i]) j++;\\n\\t\\t\\t\\n            while (i < j) {\\n                swap(s1[j], s1[j-1]);\\n                j--;\\n                result++;\\n            }\\n            i++;\\n        }\\n        return result;\\n    }\\n    \\n    int getMinSwaps(string num, int k) {\\n        string original = num;\\n        \\n        while(k--) {\\n            next_permutation(num.begin(), num.end());\\n        }\\n        \\n        return minSteps(original, num);\\n    }\\n};\\n```\\n\\n**Qn: WHY IS GREEDY APPROACH WORKING HERE?**\\n\\nFirst, we are not doing anything if the characters are at their original place.  \\n\\nSecond, Since we are bringing character to its original position (if it was not), that was the minimum effort (steps) we will have to put in since there is no other way of bringing it to original position **with only adjacent swaps.**\\n\\nAnd now we can apply same thing to the rest of the string. Plus we are swapping end to start, which shifts characters towards the end, and ultimately close to their original position, *because everything before that is already in their original position.*\\n\\nPS - I did it quickly, please let me know in comments if something seems off or not understandable. Thanks!",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\noriginal: 5489355142 and kth-permutation: 5489355421\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    // GREEDY APPROACH\\n    // min steps to make strings equal\\n    \\n    int minSteps(string s1, string s2) {\\n        int size = s1.length();\\n        int i = 0, j = 0;\\n        int result = 0;\\n  \\n        while (i < size) {\\n            j = i;\\n            while (s1[j] != s2[i]) j++;\\n\\t\\t\\t\\n            while (i < j) {\\n                swap(s1[j], s1[j-1]);\\n                j--;\\n                result++;\\n            }\\n            i++;\\n        }\\n        return result;\\n    }\\n    \\n    int getMinSwaps(string num, int k) {\\n        string original = num;\\n        \\n        while(k--) {\\n            next_permutation(num.begin(), num.end());\\n        }\\n        \\n        return minSteps(original, num);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1187098,
                "title": "next-permutation-adjacent-swapping",
                "content": "My 1st Google onsite interview question.\\n\\nAlgorithm:\\n\\t1. We use the *nextPermutation* to find the kth target permutation\\n\\t2. We use *countSteps* to count how many steps we need to perform to reach that kth permutation. \\n\\n**Java:**\\n\\n```\\n    public int getMinSwaps(String num, int k) {\\n        char[] arr = num.toCharArray();\\n        for (int i = 0; i < k; i++) {\\n            nextPermutation(arr);\\n        }\\n        char[] ori = num.toCharArray();\\n        return CountSteps(ori, arr, arr.length);\\n    }\\n    \\n    public void nextPermutation(char[] nums) {\\n        if (nums.length == 0) return;\\n        int len = nums.length;\\n        for (int i = len - 1; i >= 1; i--) {\\n            if (nums[i] > nums[i - 1]) {\\n                reverse(nums, i);\\n                for (int j = i; j < len; j++) {\\n                    if (nums[j] > nums[i - 1]) {\\n                        swap(nums, i - 1, j);\\n                        return;\\n                    }\\n                }\\n            }\\n        }\\n        reverse(nums, 0);\\n    }\\n    \\n    public void reverse(char[] nums, int i) {\\n        int j = nums.length - 1;\\n        while (i < j) {\\n            swap(nums, i, j);\\n            i++;\\n            j--;\\n        }\\n    }\\n    \\n    public void swap(char[] nums, int i, int j) {\\n        char temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp; \\n    }\\n    \\n    private int CountSteps(char []s1, char[] s2, int size) {\\n        int i = 0, j = 0;\\n        int count = 0;\\n\\n        while (i < size) {\\n            j = i;\\n\\n            while (s1[j] != s2[i]) {\\n                j += 1;\\n            }\\n            while (i < j) {\\n                swap(s1, j, j - 1);\\n                j -= 1;\\n                count++;\\n            }\\n            i++;\\n        }\\n        return count;\\n    }\\n```\\n\\n**C++:**\\n```\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string target(num);\\n        for (int i = 0; i < k; ++i)\\n            next_permutation(target.begin(), target.end());\\n        int res = 0, n = num.size();\\n        for (int i = 0; i < n; ++i) {\\n            if (num[i] != target[i]) {\\n                int j = i + 1;\\n                while (num[j] != target[i])\\n                    j++;\\n                for (; j > i; --j)\\n                    swap(num[j], num[j - 1]), res++;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int getMinSwaps(String num, int k) {\\n        char[] arr = num.toCharArray();\\n        for (int i = 0; i < k; i++) {\\n            nextPermutation(arr);\\n        }\\n        char[] ori = num.toCharArray();\\n        return CountSteps(ori, arr, arr.length);\\n    }\\n    \\n    public void nextPermutation(char[] nums) {\\n        if (nums.length == 0) return;\\n        int len = nums.length;\\n        for (int i = len - 1; i >= 1; i--) {\\n            if (nums[i] > nums[i - 1]) {\\n                reverse(nums, i);\\n                for (int j = i; j < len; j++) {\\n                    if (nums[j] > nums[i - 1]) {\\n                        swap(nums, i - 1, j);\\n                        return;\\n                    }\\n                }\\n            }\\n        }\\n        reverse(nums, 0);\\n    }\\n    \\n    public void reverse(char[] nums, int i) {\\n        int j = nums.length - 1;\\n        while (i < j) {\\n            swap(nums, i, j);\\n            i++;\\n            j--;\\n        }\\n    }\\n    \\n    public void swap(char[] nums, int i, int j) {\\n        char temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp; \\n    }\\n    \\n    private int CountSteps(char []s1, char[] s2, int size) {\\n        int i = 0, j = 0;\\n        int count = 0;\\n\\n        while (i < size) {\\n            j = i;\\n\\n            while (s1[j] != s2[i]) {\\n                j += 1;\\n            }\\n            while (i < j) {\\n                swap(s1, j, j - 1);\\n                j -= 1;\\n                count++;\\n            }\\n            i++;\\n        }\\n        return count;\\n    }\\n```\n```\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string target(num);\\n        for (int i = 0; i < k; ++i)\\n            next_permutation(target.begin(), target.end());\\n        int res = 0, n = num.size();\\n        for (int i = 0; i < n; ++i) {\\n            if (num[i] != target[i]) {\\n                int j = i + 1;\\n                while (num[j] != target[i])\\n                    j++;\\n                for (; j > i; --j)\\n                    swap(num[j], num[j - 1]), res++;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1186823,
                "title": "python-3-brute-force",
                "content": "Time: `O(N^2 + N * K)`\\nSpace: `O(N)`\\n```\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        def nxt_perm(num: list) -> list:\\n            i = n - 1\\n            while i > 0 and num[i-1] >= num[i]:\\n                i -= 1\\n            j = i\\n            while j < n and num[i-1] < num[j]:\\n                j += 1\\n            num[i-1], num[j-1] = num[j-1], num[i-1]\\n            num[i:] = num[i:][::-1] # credit to @ye15, reduce time from nlogn to n\\n            return num\\n\\n        n = len(num)\\n        nxt_k_num = list(num)\\n        for _ in range(k):\\n            nxt_k_num = nxt_perm(nxt_k_num)\\n\\n        ans = 0\\n        num = list(num)\\n        for i in range(n):\\n            j = i\\n            while j < n and nxt_k_num[i] != num[j]:\\n                j += 1\\n            ans += j - i\\n            num[i:j+1] = [num[j]] + num[i:j]\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        def nxt_perm(num: list) -> list:\\n            i = n - 1\\n            while i > 0 and num[i-1] >= num[i]:\\n                i -= 1\\n            j = i\\n            while j < n and num[i-1] < num[j]:\\n                j += 1\\n            num[i-1], num[j-1] = num[j-1], num[i-1]\\n            num[i:] = num[i:][::-1] # credit to @ye15, reduce time from nlogn to n\\n            return num\\n\\n        n = len(num)\\n        nxt_k_num = list(num)\\n        for _ in range(k):\\n            nxt_k_num = nxt_perm(nxt_k_num)\\n\\n        ans = 0\\n        num = list(num)\\n        for i in range(n):\\n            j = i\\n            while j < n and nxt_k_num[i] != num[j]:\\n                j += 1\\n            ans += j - i\\n            num[i:j+1] = [num[j]] + num[i:j]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186921,
                "title": "c-next-permutation",
                "content": "We use STL to permute our string k times. Then, we compare the orignal and permuted string. When we see a mismatch, we locate the needed character in the permuted string, add the distance to it. Finally, we shift the permuted string accordingly.\\n\\n```cpp\\nint getMinSwaps(string n, int k) {\\n    string n1 = n;\\n    int res = 0;\\n    while (--k >= 0)\\n        next_permutation(begin(n1), end(n1));\\n    for (auto i = 0; i < n.size(); ++i) {\\n        if (n[i] != n1[i]) {\\n            for (auto j = i + 1; j < n.size(); ++j) {\\n                if (n[i] == n1[j]) {\\n                    res += j - i;\\n                    n1 = n1.substr(0, i + 1) + n1.substr(i, j - i) + n1.substr(j + 1);\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint getMinSwaps(string n, int k) {\\n    string n1 = n;\\n    int res = 0;\\n    while (--k >= 0)\\n        next_permutation(begin(n1), end(n1));\\n    for (auto i = 0; i < n.size(); ++i) {\\n        if (n[i] != n1[i]) {\\n            for (auto j = i + 1; j < n.size(); ++j) {\\n                if (n[i] == n1[j]) {\\n                    res += j - i;\\n                    n1 = n1.substr(0, i + 1) + n1.substr(i, j - i) + n1.substr(j + 1);\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1206569,
                "title": "java-simple-and-easy-to-understand-solution-1-ms-faster-than-85-85-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n```\\nclass Solution {\\n    public int getMinSwaps(String num, int k) {\\n        int n = num.length();\\n        \\n        //store index \\n        int[] number = new int[n];\\n        for(int i = 0; i < n; i++){\\n            int digit = num.charAt(i) - \\'0\\';\\n            number[i] = digit;\\n        }\\n        \\n        //compute kth smallest number\\n        int[] kthSmallestNumber = getKthSmallestNumber(number.clone(), k);\\n        \\n        return getMinSwaps(number, kthSmallestNumber);\\n    }\\n    \\n    private int[] getKthSmallestNumber(int[] nums, int k){\\n        while(k --> 0){\\n            computeNextPermutation(nums);\\n        }\\n        return nums;\\n    }\\n    \\n    private void computeNextPermutation(int[] nums){\\n        int n = nums.length;\\n        int i = n - 2;\\n        \\n        //find first index from last which value smaller than next element \\n        while(i >= 0 && nums[i] >= nums[i + 1]){\\n            i--;\\n        }\\n        \\n\\n        if(i >= 0){\\n            //find index which is just greater than that index value (e.g i)\\n            int j = n - 1;\\n            while(j > i && nums[j] <= nums[i]){\\n                j--;\\n            }\\n            swap(nums, i, j);\\n        }\\n        \\n        //sort all element which index greater than <i>\\n        Arrays.sort(nums, i + 1, n);\\n    }\\n    \\n    private void swap(int[] arr, int i, int j){\\n        int temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n    \\n    private int getMinSwaps(int[] number, int[] kthSmallestNumber){\\n        int swapCount = 0;\\n        int n = number.length;\\n        \\n        for(int i = 0; i < n; i++){\\n            //ignore, as it already in correct position, no need for swap\\n            if(number[i] == kthSmallestNumber[i]) continue;\\n            \\n            //find the coorect position\\n            int j = i + 1;\\n            while(j < n && number[i] != kthSmallestNumber[j]){\\n                j++;\\n            }\\n            \\n            //swift to correct position\\n            while(j > i){\\n                swap(kthSmallestNumber, j - 1, j);\\n                swapCount++;\\n                j--;\\n            }\\n            \\n        }\\n        \\n        return swapCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinSwaps(String num, int k) {\\n        int n = num.length();\\n        \\n        //store index \\n        int[] number = new int[n];\\n        for(int i = 0; i < n; i++){\\n            int digit = num.charAt(i) - \\'0\\';\\n            number[i] = digit;\\n        }\\n        \\n        //compute kth smallest number\\n        int[] kthSmallestNumber = getKthSmallestNumber(number.clone(), k);\\n        \\n        return getMinSwaps(number, kthSmallestNumber);\\n    }\\n    \\n    private int[] getKthSmallestNumber(int[] nums, int k){\\n        while(k --> 0){\\n            computeNextPermutation(nums);\\n        }\\n        return nums;\\n    }\\n    \\n    private void computeNextPermutation(int[] nums){\\n        int n = nums.length;\\n        int i = n - 2;\\n        \\n        //find first index from last which value smaller than next element \\n        while(i >= 0 && nums[i] >= nums[i + 1]){\\n            i--;\\n        }\\n        \\n\\n        if(i >= 0){\\n            //find index which is just greater than that index value (e.g i)\\n            int j = n - 1;\\n            while(j > i && nums[j] <= nums[i]){\\n                j--;\\n            }\\n            swap(nums, i, j);\\n        }\\n        \\n        //sort all element which index greater than <i>\\n        Arrays.sort(nums, i + 1, n);\\n    }\\n    \\n    private void swap(int[] arr, int i, int j){\\n        int temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n    \\n    private int getMinSwaps(int[] number, int[] kthSmallestNumber){\\n        int swapCount = 0;\\n        int n = number.length;\\n        \\n        for(int i = 0; i < n; i++){\\n            //ignore, as it already in correct position, no need for swap\\n            if(number[i] == kthSmallestNumber[i]) continue;\\n            \\n            //find the coorect position\\n            int j = i + 1;\\n            while(j < n && number[i] != kthSmallestNumber[j]){\\n                j++;\\n            }\\n            \\n            //swift to correct position\\n            while(j > i){\\n                swap(kthSmallestNumber, j - 1, j);\\n                swapCount++;\\n                j--;\\n            }\\n            \\n        }\\n        \\n        return swapCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186910,
                "title": "clean-java",
                "content": "With the helper method from 31. next permutation. \\nhttps://leetcode.com/problems/next-permutation/ \\nwe can use brute force to calculate the minimal adjacent swap to make 2 arrays equal\\n```\\n    public int getMinSwaps(String num, int k) {\\n        int N = num.length();\\n        int[] origin = new int[num.length()];\\n        int[] nums = new int[num.length()];\\n        for (int i = 0; i < num.length(); i++) {\\n            nums[i] = num.charAt(i) - \\'0\\';\\n            origin[i] = num.charAt(i) - \\'0\\';\\n        }\\n        while (k-- > 0) nextPermutation(nums);\\n        int res = 0;\\n        for (int i = 0; i < N; i++)\\n            if (nums[i] != origin[i]) {\\n                int j = i;\\n                while (nums[j] != origin[i]) j++;\\n                for (int x = j; x > i; x--) {\\n                    swap(nums, x, x - 1);\\n                    res++;\\n                }\\n            }\\n        return res;\\n    }\\n    public void nextPermutation(int[] nums) {\\n        if (nums.length <= 1) return;\\n        int i = nums.length - 2;\\n        while (i >= 0 && nums[i] >= nums[i + 1]) i--; \\n        if (i >= 0) {\\n            int j = nums.length - 1;\\n            while (j > i && nums[j] <= nums[i]) j--; \\n            swap(nums, i, j);\\n        }\\n        reverse(nums, i + 1, nums.length - 1);\\n    }\\n    private void reverse(int[] nums, int left, int right) {\\n        while (left < right)\\n            swap(nums, left++, right--);\\n    }\\n    private void swap (int[] nums, int i, int j) {\\n        int tmp = nums[j];\\n        nums[j] = nums[i];\\n        nums[i] = tmp;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int getMinSwaps(String num, int k) {\\n        int N = num.length();\\n        int[] origin = new int[num.length()];\\n        int[] nums = new int[num.length()];\\n        for (int i = 0; i < num.length(); i++) {\\n            nums[i] = num.charAt(i) - \\'0\\';\\n            origin[i] = num.charAt(i) - \\'0\\';\\n        }\\n        while (k-- > 0) nextPermutation(nums);\\n        int res = 0;\\n        for (int i = 0; i < N; i++)\\n            if (nums[i] != origin[i]) {\\n                int j = i;\\n                while (nums[j] != origin[i]) j++;\\n                for (int x = j; x > i; x--) {\\n                    swap(nums, x, x - 1);\\n                    res++;\\n                }\\n            }\\n        return res;\\n    }\\n    public void nextPermutation(int[] nums) {\\n        if (nums.length <= 1) return;\\n        int i = nums.length - 2;\\n        while (i >= 0 && nums[i] >= nums[i + 1]) i--; \\n        if (i >= 0) {\\n            int j = nums.length - 1;\\n            while (j > i && nums[j] <= nums[i]) j--; \\n            swap(nums, i, j);\\n        }\\n        reverse(nums, i + 1, nums.length - 1);\\n    }\\n    private void reverse(int[] nums, int left, int right) {\\n        while (left < right)\\n            swap(nums, left++, right--);\\n    }\\n    private void swap (int[] nums, int i, int j) {\\n        int tmp = nums[j];\\n        nums[j] = nums[i];\\n        nums[i] = tmp;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1186887,
                "title": "python3-brute-force",
                "content": "\\n```\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        num = list(num)\\n        orig = num.copy()\\n        \\n        for _ in range(k): \\n            for i in reversed(range(len(num)-1)): \\n                if num[i] < num[i+1]: \\n                    ii = i+1 \\n                    while ii < len(num) and num[i] < num[ii]: ii += 1\\n                    num[i], num[ii-1] = num[ii-1], num[i]\\n                    lo, hi = i+1, len(num)-1\\n                    while lo < hi: \\n                        num[lo], num[hi] = num[hi], num[lo]\\n                        lo += 1\\n                        hi -= 1\\n                    break \\n        \\n        ans = 0\\n        for i in range(len(num)): \\n            ii = i\\n            while orig[i] != num[i]: \\n                ans += 1\\n                ii += 1\\n                num[i], num[ii] = num[ii], num[i]\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        num = list(num)\\n        orig = num.copy()\\n        \\n        for _ in range(k): \\n            for i in reversed(range(len(num)-1)): \\n                if num[i] < num[i+1]: \\n                    ii = i+1 \\n                    while ii < len(num) and num[i] < num[ii]: ii += 1\\n                    num[i], num[ii-1] = num[ii-1], num[i]\\n                    lo, hi = i+1, len(num)-1\\n                    while lo < hi: \\n                        num[lo], num[hi] = num[hi], num[lo]\\n                        lo += 1\\n                        hi -= 1\\n                    break \\n        \\n        ans = 0\\n        for i in range(len(num)): \\n            ii = i\\n            while orig[i] != num[i]: \\n                ans += 1\\n                ii += 1\\n                num[i], num[ii] = num[ii], num[i]\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910886,
                "title": "c-intuitions-commented-next-permuatation-explained-clearly",
                "content": "```\\n  int getMinSwaps(string num, int k) {\\n\\n       int n=num.size();\\n        string x = num;\\n        \\n        while(k--)\\n        {\\n            next_permutation(x.begin(),x.end());\\n        }\\n        \\n        int ans=0;\\n          for(int i=0;i<n;i++)\\n          {\\n              if(num[i]!=x[i])\\n              {\\n                  // as we know we have to check the swappings , its original position \\n                  // will be somewhere to the right in original string num as compared \\n                  // to permutated string x, so find it out and swap one by one \\n                  // makes it to its newly permutataed position in  original string \\n                  // swap one by one just makes it to position as it in permuated string\\n                  \\n                  int j=i+1 ;// j will be moving in original string\\n                      \\n                      while(num[j]!=x[i])\\n                      {\\n                          j++;\\n                      }\\n                  \\n                     // now we find it out at some jth index where the (value x[i]  )exists in original string  at index j in string num\\n                  // its time to swap now \\n                  \\n                  while(j>i)\\n                  {\\n                      swap(num[j] , num[j-1]);\\n                      j--;\\n                      ans++;\\n                  }\\n                  \\n                  \\n              }\\n          }\\n        \\n        \\n        return ans;\\n        \\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\n  int getMinSwaps(string num, int k) {\\n\\n       int n=num.size();\\n        string x = num;\\n        \\n        while(k--)\\n        {\\n            next_permutation(x.begin(),x.end());\\n        }\\n        \\n        int ans=0;\\n          for(int i=0;i<n;i++)\\n          {\\n              if(num[i]!=x[i])\\n              {\\n                  // as we know we have to check the swappings , its original position \\n                  // will be somewhere to the right in original string num as compared \\n                  // to permutated string x, so find it out and swap one by one \\n                  // makes it to its newly permutataed position in  original string \\n                  // swap one by one just makes it to position as it in permuated string\\n                  \\n                  int j=i+1 ;// j will be moving in original string\\n                      \\n                      while(num[j]!=x[i])\\n                      {\\n                          j++;\\n                      }\\n                  \\n                     // now we find it out at some jth index where the (value x[i]  )exists in original string  at index j in string num\\n                  // its time to swap now \\n                  \\n                  while(j>i)\\n                  {\\n                      swap(num[j] , num[j-1]);\\n                      j--;\\n                      ans++;\\n                  }\\n                  \\n                  \\n              }\\n          }\\n        \\n        \\n        return ans;\\n        \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1190281,
                "title": "explanation-for-adjacent-swapping",
                "content": "There are a lot of great explaination for the next permutation, but I did not found a proof for the correctness of the minimum adjacent swapping. So I spent some time thinking about it and shared my thought. Correct me if it is wrong.\\n\\nHere is my code for count minimum swapping to get `dest` from `src`. The main idea is to go through `dest`, comparing the `dest[i]` with `src[i]`, if they are not the same, find the nearest `src[j]` at right that equals to `dest[i]` and swap `j - i` times to make `src[i] == dest[i]`. Finally, we will convert `src` to `dest` and the number of swapping is minimum.\\n```\\n    private int count(int[] dest, int[] src) {\\n        int count = 0;\\n        for (int i = 0; i < dest.length; i++) {\\n            if (dest[i] != src[i]) {\\n                for (int j = i + 1; j < src.length; j++) {\\n                    if (dest[i] == src[j]) {\\n                        for (int k = j; k > i; k--) {\\n                            swap(src, k, k - 1); // swap  src[k] with src[k - 1]\\n                            count++;\\n                        }\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n```\\n\\nTo prove its correctness, we need the conception [**Inversion Number**](https://en.wikipedia.org/wiki/Inversion_(discrete_mathematics)), basically the number of pairs out of their natural order. Here we can let the `dest` define the natual order, and by adjacent swapping, we can reduce the inversion number of `src`. While `inv(src) = inv(dest) = 0`, two permutation are the same:\\n```\\nsrc = 42135\\ndest = 45132\\n2 shows before 1, 3, 5\\n1 shows before 5\\n3 shows before 5\\nSo, inv(src) = 3 + 1 + 1 = 5\\n```\\n\\nThen we can find that each adjacent swapping can reduce `inv(src)` by 1 at most:\\n```\\n...left chunk, i, j, right chunk...\\n```\\nSwapping `i` and `j` only affect the order between themselves, the inversion number can be increased by 1(destroy the natural order), decreased by 1(become natural order) or doesn\\'t change(i == j). After swapping, `i, j` are still behind the left chunk, in front of the right chunk. Hence, to convert `src` to `dest`, we need at least `inv(src)` adjacent swapping.\\nIn above greedy strategy, everytime `src[i] != dest[i]`, we will find the `src[j] == dest[i], j > i`. Every element from `src[i]` to `src[j - 1]`  is in inverse order with `src[j]`. So, each adjacent swapping always reduces the `inv(src)` by 1, e.g:\\n```\\n42135 -> 45213, 3 adjacent swappings, and reduce the inversion number by 3.\\n```\\nNote: since we always find the nearest target element, so we won\\'t waste swapping on identical elements, e.g:\\n```\\n4, 2, 1, 5_1, 3,  5_2 -> 4, 5_1, 5_2, 2, 1, 3, here 5_1 and 5_2 are both 5, just added a suffix to differentiate them.\\nStategy 1: 4, 2, 1, 5_1, 3,  5_2  -> 4, 5_1, 2, 1, 3, 5_2  ->  4, 5_1, 5_2, 2, 1, 3;                          2 + 3 = 5 swap\\nStategy 2: 4, 2, 1, 5_1, 3,  5_2  -> 4, 5_2, 2, 1, 5_1, 3  ->  4, 5_2, 5_1, 2, 1, 3;                          4 + 2 = 6 swap\\n```\\nIn above example, stategy2 wasted a swapping when move `5_2` to the correct position.\\n\\nSince every swapping reduces the inversion number by 1, the number of swapping in this strategy is exactly `inv(src)`, which is also the possible minimum number of swapping. Therefore, this strategy is optimal.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    private int count(int[] dest, int[] src) {\\n        int count = 0;\\n        for (int i = 0; i < dest.length; i++) {\\n            if (dest[i] != src[i]) {\\n                for (int j = i + 1; j < src.length; j++) {\\n                    if (dest[i] == src[j]) {\\n                        for (int k = j; k > i; k--) {\\n                            swap(src, k, k - 1); // swap  src[k] with src[k - 1]\\n                            count++;\\n                        }\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n```\n```\\nsrc = 42135\\ndest = 45132\\n2 shows before 1, 3, 5\\n1 shows before 5\\n3 shows before 5\\nSo, inv(src) = 3 + 1 + 1 = 5\\n```\n```\\n...left chunk, i, j, right chunk...\\n```\n```\\n42135 -> 45213, 3 adjacent swappings, and reduce the inversion number by 3.\\n```\n```\\n4, 2, 1, 5_1, 3,  5_2 -> 4, 5_1, 5_2, 2, 1, 3, here 5_1 and 5_2 are both 5, just added a suffix to differentiate them.\\nStategy 1: 4, 2, 1, 5_1, 3,  5_2  -> 4, 5_1, 2, 1, 3, 5_2  ->  4, 5_1, 5_2, 2, 1, 3;                          2 + 3 = 5 swap\\nStategy 2: 4, 2, 1, 5_1, 3,  5_2  -> 4, 5_2, 2, 1, 5_1, 3  ->  4, 5_2, 5_1, 2, 1, 3;                          4 + 2 = 6 swap\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1186790,
                "title": "c-next-permutation-solution-greedy",
                "content": "\\n#### Idea\\n- use C++ next_permutation to get the k-th permutation.\\n- start from the last element(j) and find the closest char(i) which is equal to it. and swap the adjacent elements from i to j. each step we apply ans += 1\\n\\n#### Complexity\\n- Time O(n^2)\\n- Space O(n)\\n\\n#### Solution\\n- C++\\n```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string src = num;\\n        int ans = 0;\\n        for(int i = 0; i < k; i++) {\\n            next_permutation(num.begin(), num.end());\\n        }\\n        for(int i = num.size() - 1; i >= 0; i--) {\\n            int j = i;\\n            while(src[j] != num[i])--j;\\n            for(int l = j; l < i; l++) {\\n                swap(src[l], src[l + 1]);\\n                ++ans;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string src = num;\\n        int ans = 0;\\n        for(int i = 0; i < k; i++) {\\n            next_permutation(num.begin(), num.end());\\n        }\\n        for(int i = num.size() - 1; i >= 0; i--) {\\n            int j = i;\\n            while(src[j] != num[i])--j;\\n            for(int l = j; l < i; l++) {\\n                swap(src[l], src[l + 1]);\\n                ++ans;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1262666,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string s, int k) {\\n        string x=s;\\n        while(k--)\\n        {\\n            next_permutation(x.begin(),x.end());\\n        }\\n        int cnt=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]!=x[i])\\n            {\\n                int j=i+1;\\n                while(s[j]!=x[i])\\n                {\\n                    j++;\\n                }\\n                while(j>i)\\n                {\\n                    swap(s[j],s[j-1]);\\n                    j--;\\n                    cnt++;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string s, int k) {\\n        string x=s;\\n        while(k--)\\n        {\\n            next_permutation(x.begin(),x.end());\\n        }\\n        int cnt=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]!=x[i])\\n            {\\n                int j=i+1;\\n                while(s[j]!=x[i])\\n                {\\n                    j++;\\n                }\\n                while(j>i)\\n                {\\n                    swap(s[j],s[j-1]);\\n                    j--;\\n                    cnt++;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186837,
                "title": "python-3-permutation-simulation",
                "content": "```\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        \\n        # 1: get the kth value\\n        # 2: count the steps to swap\\n        \\n        def get_swap_count(nums, nums0) -> int:\\n            count = 0\\n            for i in range(len(nums)):\\n                if nums[i] != nums0[i]:\\n                    \\n                    index = i + 1\\n                    while nums0[index] != nums[i]:\\n                        index += 1\\n\\n                    # print(i, index)\\n                    while index != i:\\n                        nums0[index], nums0[index-1] = nums0[index-1], nums0[index]\\n                        #print(\"after swap: \", (\"\").join(nums0))\\n                        count += 1\\n                        index -= 1\\n            return count\\n            \\n            \\n        \\n        def get_next_smart_num(nums) -> str:\\n            # find the rightest one to swap\\n            i = len(nums) - 2\\n            while i > 0 and int(nums[i]) >= int(nums[i+1]):\\n                i -= 1\\n            \\n            #print(\"first digit need to swap: \", nums[i])\\n            \\n            j = len(nums) - 1\\n            while int(nums[j]) <= int(nums[i]):\\n                j -= 1\\n            \\n            #print(\"second digit need to swap with first one: \", nums[j])\\n            \\n            # swap i an j\\n            nums[i], nums[j] = nums[j], nums[i]\\n            #print(\"after swapped: \", (\"\").join(nums))\\n            \\n            # we need to sort all digit after i\\n            nums = nums[:i+1] + sorted(nums[i+1:])\\n            #print(\"after sorted: \", (\"\").join(nums))\\n            \\n            return nums\\n        \\n        #print(\"original: \", num)\\n        nums = [c for c in num]\\n        nums0 = [c for c in num]\\n        for i in range(k):\\n            nums = get_next_smart_num(nums)\\n            #print(\"{}-th smart num is: {}\".format(i+1, (\"\").join(nums)))\\n            \\n        \\n        return get_swap_count(nums, nums0)\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        \\n        # 1: get the kth value\\n        # 2: count the steps to swap\\n        \\n        def get_swap_count(nums, nums0) -> int:\\n            count = 0\\n            for i in range(len(nums)):\\n                if nums[i] != nums0[i]:\\n                    \\n                    index = i + 1\\n                    while nums0[index] != nums[i]:\\n                        index += 1\\n\\n                    # print(i, index)\\n                    while index != i:\\n                        nums0[index], nums0[index-1] = nums0[index-1], nums0[index]\\n                        #print(\"after swap: \", (\"\").join(nums0))\\n                        count += 1\\n                        index -= 1\\n            return count\\n            \\n            \\n        \\n        def get_next_smart_num(nums) -> str:\\n            # find the rightest one to swap\\n            i = len(nums) - 2\\n            while i > 0 and int(nums[i]) >= int(nums[i+1]):\\n                i -= 1\\n            \\n            #print(\"first digit need to swap: \", nums[i])\\n            \\n            j = len(nums) - 1\\n            while int(nums[j]) <= int(nums[i]):\\n                j -= 1\\n            \\n            #print(\"second digit need to swap with first one: \", nums[j])\\n            \\n            # swap i an j\\n            nums[i], nums[j] = nums[j], nums[i]\\n            #print(\"after swapped: \", (\"\").join(nums))\\n            \\n            # we need to sort all digit after i\\n            nums = nums[:i+1] + sorted(nums[i+1:])\\n            #print(\"after sorted: \", (\"\").join(nums))\\n            \\n            return nums\\n        \\n        #print(\"original: \", num)\\n        nums = [c for c in num]\\n        nums0 = [c for c in num]\\n        for i in range(k):\\n            nums = get_next_smart_num(nums)\\n            #print(\"{}-th smart num is: {}\".format(i+1, (\"\").join(nums)))\\n            \\n        \\n        return get_swap_count(nums, nums0)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186993,
                "title": "c-next-permutation-with-idea-from-insertion-sort",
                "content": "```C++\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string target = num;\\n        while(k--) next_permutation(begin(target), end(target));\\n        int res = 0, pos = 0;\\n        while(num != target) {\\n            if(num[pos] != target[pos]) {\\n                int find = target.find(num[pos], pos);\\n                while(find != pos) {\\n                    swap(target[find], target[find - 1]);\\n                    res++;\\n                    find--;\\n                }\\n            } \\n            pos++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string target = num;\\n        while(k--) next_permutation(begin(target), end(target));\\n        int res = 0, pos = 0;\\n        while(num != target) {\\n            if(num[pos] != target[pos]) {\\n                int find = target.find(num[pos], pos);\\n                while(find != pos) {\\n                    swap(target[find], target[find - 1]);\\n                    res++;\\n                    find--;\\n                }\\n            } \\n            pos++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186972,
                "title": "c-next-permutation-count-inversions-simple",
                "content": "```\\nint countInv(vector<int>& arr, int n)\\n    {\\n        int count = 0;\\n        for (int i = 0; i < n - 1; i++)\\n            for (int j = i + 1; j < n; j++)\\n                if (arr[i] > arr[j])\\n                  count++;\\n \\n        return count;\\n    }\\n    int getMinSwaps(string num, int k) {\\n        int n = num.size();\\n        string next = num;\\n        while(k--){\\n            next_permutation(next.begin(),next.end());\\n        }\\n        vector<deque<int>> digits(10);\\n        for (int i =0;i<n;i++){\\n            digits[num[i]-\\'0\\'].push_back(i);\\n        }\\n        vector<int> arr;\\n        for (int i =0;i<n;i++){\\n            arr.push_back(digits[next[i]-\\'0\\'].front());\\n             digits[next[i]-\\'0\\'].pop_front();\\n        }\\n        return countInv(arr,(int)arr.size());\\n    }",
                "solutionTags": [],
                "code": "```\\nint countInv(vector<int>& arr, int n)\\n    {\\n        int count = 0;\\n        for (int i = 0; i < n - 1; i++)\\n            for (int j = i + 1; j < n; j++)\\n                if (arr[i] > arr[j])\\n                  count++;\\n \\n        return count;\\n    }\\n    int getMinSwaps(string num, int k) {\\n        int n = num.size();\\n        string next = num;\\n        while(k--){\\n            next_permutation(next.begin(),next.end());\\n        }\\n        vector<deque<int>> digits(10);\\n        for (int i =0;i<n;i++){\\n            digits[num[i]-\\'0\\'].push_back(i);\\n        }\\n        vector<int> arr;\\n        for (int i =0;i<n;i++){\\n            arr.push_back(digits[next[i]-\\'0\\'].front());\\n             digits[next[i]-\\'0\\'].pop_front();\\n        }\\n        return countInv(arr,(int)arr.size());\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1218613,
                "title": "c-1850-minimum-adjacent-swaps-to-reach-the-kth-smallest-number",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string perm = num; \\n        while (k--) \\n            next_permutation(perm.begin(), perm.end()); \\n        \\n        int ans = 0; \\n        for (int i = 0; i < num.size(); ++i) {\\n            int ii = i; \\n            while (num[i] != perm[i]) {\\n                ++ans; \\n                swap(perm[i], perm[++ii]); \\n            }\\n        }\\n        return ans;         \\n    }\\n};\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string perm = num; \\n        while (k--) {\\n            for (int i = perm.size()-1; i > 0; --i) {\\n                if (perm[i-1] < perm[i]) {\\n                    int ii = i, j = perm.size()-1; \\n                    for (; ii < perm.size() && perm[i-1] < perm[ii]; ++ii); \\n                    swap(perm[i-1], perm[ii-1]); \\n                    while (i < j) swap(perm[i++], perm[j--]); \\n                    break; \\n                } \\n            }\\n        }\\n        \\n        int ans = 0; \\n        for (int i = 0; i < num.size(); ++i) {\\n            int ii = i+1; \\n            while (num[i] != perm[i]) {\\n                ++ans; \\n                swap(perm[i], perm[ii++]); \\n            }\\n        }\\n        return ans;         \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string perm = num; \\n        while (k--) \\n            next_permutation(perm.begin(), perm.end()); \\n        \\n        int ans = 0; \\n        for (int i = 0; i < num.size(); ++i) {\\n            int ii = i; \\n            while (num[i] != perm[i]) {\\n                ++ans; \\n                swap(perm[i], perm[++ii]); \\n            }\\n        }\\n        return ans;         \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string perm = num; \\n        while (k--) {\\n            for (int i = perm.size()-1; i > 0; --i) {\\n                if (perm[i-1] < perm[i]) {\\n                    int ii = i, j = perm.size()-1; \\n                    for (; ii < perm.size() && perm[i-1] < perm[ii]; ++ii); \\n                    swap(perm[i-1], perm[ii-1]); \\n                    while (i < j) swap(perm[i++], perm[j--]); \\n                    break; \\n                } \\n            }\\n        }\\n        \\n        int ans = 0; \\n        for (int i = 0; i < num.size(); ++i) {\\n            int ii = i+1; \\n            while (num[i] != perm[i]) {\\n                ++ans; \\n                swap(perm[i], perm[ii++]); \\n            }\\n        }\\n        return ans;         \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1195404,
                "title": "the-fastest-100-python-solution-52ms-60ms",
                "content": "Rather than doing `k` iterations of `next_permutation`, we can find the permutation number of `num`. That is out of all permutations of the digits in `num` where does this one fall. E.g. for `num` is `213`, all permutations of `1`, `2`, and `3`, in order, are:\\n\\n`123`\\n`132`\\n`213` <- the `2`th permutation\\n`231`\\n`312`\\n`321`\\n\\nNow that we know the `p`, the permutation number of `num` (in this case it\\'s `2`), we need to find the `p+k`th permutation of `1`, `2`, and `3`.\\n\\nBoth, `permutation_num` and `ith_permutation` can be done mathematically, though special care must be taken to account for duplicities of digits.\\n\\nActually, what I\\'ve done below with my code is a bit more clever than what I described above, though the above would certainly work, what I\\'ve done is faster: Instead of finding the permutation number of the entire `num`, I expand `num` from the back, computing at each turn, `p` the permutation number of `str(num)[L:]` and also `P` the total number of possible permutations of the digits in `str(num)[L:]`. I decrement `L` until I have reached a `p` and `P` s.t. `p + k < P`, then I can stop expanding. Now I just need to find the `p+k`th permutation of `str(num)[L:]`. At the end I compare `str(num)[L:]` and `ith_permutation(str(num)[L:], p+k)` to find the min number of adjacent swaps.\\n\\n```\\n# By joseville\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        A = str(num)\\n        \"\"\"\\n        Given a permutation `A`, find the permutation that is `k` positions after `A`.\\n        \"\"\"\\n        L = len(A) - 1\\n        N = 1\\n        C = Counter(A[L:])\\n        O = [A[L]]\\n\\n        F = 1\\n        PCF = 1\\n\\n        P = F // PCF # num of `N`-permutations of `A[L:]`\\n        p = 0\\n        L -= 1\\n        while L >= 0 and p + k >= P:\\n            b = A[L]\\n            C[b] += 1\\n            PCF *= C[b]\\n\\n            p_prev = 0\\n            j = bisect_left(O, b)\\n            if j == len(O) or O[j] != b:\\n                O.insert(j, b)\\n            for i in range(j):\\n                a = O[i]\\n                Ca = C[a]\\n                p_prev += (F * Ca) // PCF\\n\\n            N += 1\\n            F *= N\\n\\n            P = F // PCF\\n            p += p_prev\\n            L -= 1\\n\\n        if p + k >= P:\\n            return None\\n\\n        L += 1\\n        F //= N\\n        perm = []\\n        perm_num = 0\\n        PERM_NUM = p + k\\n        while perm_num != PERM_NUM:\\n            for i in range(len(O)):\\n                a = O[i]\\n                Ca = C[a]\\n\\n                # num of `N`-permutations starting with `a`\\n                a_perms = (F * Ca) // PCF\\n                if (pn := perm_num + a_perms) <= PERM_NUM:\\n                    perm_num = pn\\n                    continue\\n                if pn == PERM_NUM:\\n                    perm_num = PERM_NUM\\n                    i += 1\\n                    a = O[i]\\n                N -= 1\\n                F //= N\\n                PCF //= C[a]\\n                perm.append(a)\\n                C[a] -= 1\\n                if not C[a]:\\n                    # del C[a]\\n                    O.pop(i)\\n                break\\n\\n        # perm_num == PERM_NUM\\n\\n        # traverse the remaining elements in increasing order\\n        # appending them to ans\\n        for a in O:\\n            perm += [a] * C[a]\\n\\n        perm_plus_k = perm\\n        swaps = 0\\n        for i in range(len(perm)):\\n            swaps += (j := perm_plus_k.index(A[L+i]))\\n            perm_plus_k.pop(j)\\n        return swaps\\n```",
                "solutionTags": [],
                "code": "```\\n# By joseville\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        A = str(num)\\n        \"\"\"\\n        Given a permutation `A`, find the permutation that is `k` positions after `A`.\\n        \"\"\"\\n        L = len(A) - 1\\n        N = 1\\n        C = Counter(A[L:])\\n        O = [A[L]]\\n\\n        F = 1\\n        PCF = 1\\n\\n        P = F // PCF # num of `N`-permutations of `A[L:]`\\n        p = 0\\n        L -= 1\\n        while L >= 0 and p + k >= P:\\n            b = A[L]\\n            C[b] += 1\\n            PCF *= C[b]\\n\\n            p_prev = 0\\n            j = bisect_left(O, b)\\n            if j == len(O) or O[j] != b:\\n                O.insert(j, b)\\n            for i in range(j):\\n                a = O[i]\\n                Ca = C[a]\\n                p_prev += (F * Ca) // PCF\\n\\n            N += 1\\n            F *= N\\n\\n            P = F // PCF\\n            p += p_prev\\n            L -= 1\\n\\n        if p + k >= P:\\n            return None\\n\\n        L += 1\\n        F //= N\\n        perm = []\\n        perm_num = 0\\n        PERM_NUM = p + k\\n        while perm_num != PERM_NUM:\\n            for i in range(len(O)):\\n                a = O[i]\\n                Ca = C[a]\\n\\n                # num of `N`-permutations starting with `a`\\n                a_perms = (F * Ca) // PCF\\n                if (pn := perm_num + a_perms) <= PERM_NUM:\\n                    perm_num = pn\\n                    continue\\n                if pn == PERM_NUM:\\n                    perm_num = PERM_NUM\\n                    i += 1\\n                    a = O[i]\\n                N -= 1\\n                F //= N\\n                PCF //= C[a]\\n                perm.append(a)\\n                C[a] -= 1\\n                if not C[a]:\\n                    # del C[a]\\n                    O.pop(i)\\n                break\\n\\n        # perm_num == PERM_NUM\\n\\n        # traverse the remaining elements in increasing order\\n        # appending them to ans\\n        for a in O:\\n            perm += [a] * C[a]\\n\\n        perm_plus_k = perm\\n        swaps = 0\\n        for i in range(len(perm)):\\n            swaps += (j := perm_plus_k.index(A[L+i]))\\n            perm_plus_k.pop(j)\\n        return swaps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2927080,
                "title": "c-faster-than-95-two-pointer-greedy-very-easy-approach-clean-code",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n\\n    int getMinSwaps(string num, int k) {\\n        \\n        string s = num;\\n\\n        int res = 0;\\n\\n        while(k--) next_permutation(s.begin(),s.end());\\n\\n    \\n        for(int i = 0; i < num.size(); ++i)\\n        {\\n            if(num[i] != s[i])\\n            {\\n               int j = i + 1;\\n\\n               while(num[j] != s[i]) j++;\\n               \\n               while(j > i)\\n               {\\n                   swap(num[j], num[j-1]);\\n                   res++;\\n                   j--;\\n               }\\n               \\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\n    int getMinSwaps(string num, int k) {\\n        \\n        string s = num;\\n\\n        int res = 0;\\n\\n        while(k--) next_permutation(s.begin(),s.end());\\n\\n    \\n        for(int i = 0; i < num.size(); ++i)\\n        {\\n            if(num[i] != s[i])\\n            {\\n               int j = i + 1;\\n\\n               while(num[j] != s[i]) j++;\\n               \\n               while(j > i)\\n               {\\n                   swap(num[j], num[j-1]);\\n                   res++;\\n                   j--;\\n               }\\n               \\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2602968,
                "title": "not-so-easy-but-understandable-python-solution-explained",
                "content": "This is a difficult question so lets understand it in parts:\\n1. Finding the next permutation: Its explained over here: https://leetcode.com/problems/next-permutation/discuss/2602889/Simple-python-solution-with-comments-or-O(n)-or-Explained\\n\\n2. Finding the number of swaps: Once we get the proper permutation, we compare every index between the original and the permuation. If we find any mismatch in a given index, we try to make the permutation equal to the original, so we find the index in the permutation where the original number exists at a given position and pop it and insert it in the current index. The difference between this found index and the current index is the number of swaps needed, so we add it to the answer. We repeat it untill we get back the original string.\\n\\nUpvote if you understood the logic :)\\n\\n```\\nclass Solution:\\n    def getMinSwaps(self, orig: str, k: int) -> int:\\n        def nextPermutation(nums):\\n            i = len(nums) - 2\\n\\n            while i > -1 and nums[i] >= nums[i + 1]:\\n                i -= 1\\n\\n            j = len(nums) - 1\\n\\n            while nums[j] <= nums[i]:\\n                j -= 1\\n\\n            nums[i], nums[j] = nums[j], nums[i]\\n            nums[i + 1:] = reversed(nums[i + 1:])\\n            return nums\\n\\n        nums = list(orig)\\n        res = None\\n\\n        for _ in range(k):\\n            res = nextPermutation(nums)\\n\\n        ans = i = 0\\n\\t\\t# finding the number of swaps needed\\n        while i < len(res) - 1:\\n            if res[i] != orig[i]:\\n                index = res.index(orig[i], i + 1)\\n                res.insert(i, res.pop(index))\\n                ans += index - i\\n\\n            i += 1\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def getMinSwaps(self, orig: str, k: int) -> int:\\n        def nextPermutation(nums):\\n            i = len(nums) - 2\\n\\n            while i > -1 and nums[i] >= nums[i + 1]:\\n                i -= 1\\n\\n            j = len(nums) - 1\\n\\n            while nums[j] <= nums[i]:\\n                j -= 1\\n\\n            nums[i], nums[j] = nums[j], nums[i]\\n            nums[i + 1:] = reversed(nums[i + 1:])\\n            return nums\\n\\n        nums = list(orig)\\n        res = None\\n\\n        for _ in range(k):\\n            res = nextPermutation(nums)\\n\\n        ans = i = 0\\n\\t\\t# finding the number of swaps needed\\n        while i < len(res) - 1:\\n            if res[i] != orig[i]:\\n                index = res.index(orig[i], i + 1)\\n                res.insert(i, res.pop(index))\\n                ans += index - i\\n\\n            i += 1\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2126764,
                "title": "easy-cpp-code-explained-line-by-line-cpp-adjacent-swap-logic",
                "content": "```\\nclass Solution {\\n    void nextpermut(string &s)\\n    {\\n        int i = s.size()-1;\\n        int k,l;\\n        //find first element less than its next from the last\\n        for(k=s.size()-2;k>=0;k--)\\n        {\\n            if(s[k]<s[k+1]) break;\\n        }\\n        if (k < 0) return ;\\n        \\n        //find first element which is greater than the element found from the last\\n        for(l=s.size()-1;l>k;l--)\\n        {\\n            if(s[k]<s[l]) break;\\n        }\\n        swap(s[k], s[l]);\\n        reverse(s.begin()+k+1, s.end());\\n        \\n    }\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        \\n        string s=num;        \\n        while(k--)\\n        {\\n            nextpermut(s);\\n        }\\n        int count=0;\\n        int i=0,j=0;\\n        while(i<num.size() and j<num.size())\\n        {\\n            if(num[i]!=s[i])\\n            {\\n                int c=j;\\n                //finding element where can we perform swap\\n                while(s[c]!=num[i] and c<num.size())\\n                {\\n                    c++;\\n                    count++;\\n                }\\n                //making the swaps \\n                while(c!=j) {\\n                    swap(s[c],s[c-1]);\\n                    c--;\\n                }\\n                \\n            }\\n            i++;\\n            j++;\\n        }\\n        \\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    void nextpermut(string &s)\\n    {\\n        int i = s.size()-1;\\n        int k,l;\\n        //find first element less than its next from the last\\n        for(k=s.size()-2;k>=0;k--)\\n        {\\n            if(s[k]<s[k+1]) break;\\n        }\\n        if (k < 0) return ;\\n        \\n        //find first element which is greater than the element found from the last\\n        for(l=s.size()-1;l>k;l--)\\n        {\\n            if(s[k]<s[l]) break;\\n        }\\n        swap(s[k], s[l]);\\n        reverse(s.begin()+k+1, s.end());\\n        \\n    }\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        \\n        string s=num;        \\n        while(k--)\\n        {\\n            nextpermut(s);\\n        }\\n        int count=0;\\n        int i=0,j=0;\\n        while(i<num.size() and j<num.size())\\n        {\\n            if(num[i]!=s[i])\\n            {\\n                int c=j;\\n                //finding element where can we perform swap\\n                while(s[c]!=num[i] and c<num.size())\\n                {\\n                    c++;\\n                    count++;\\n                }\\n                //making the swaps \\n                while(c!=j) {\\n                    swap(s[c],s[c-1]);\\n                    c--;\\n                }\\n                \\n            }\\n            i++;\\n            j++;\\n        }\\n        \\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1509907,
                "title": "easy-to-understand-with-explanation",
                "content": "**Prerequisites : The next_permutation() function in C++ STL. This function basically changes the string or array to the next greater permutation of the current state.**\\n\\nWe use the next_permutation function on the string k times. Once we have the kth permutation, all we have to do it to count the number of swaps. \\n* For this we use two pointer i and j, and at any instance where num[i] != src[j], we increase the value of j until num[i] == src[j].\\n* Then we have to perform the swapsif the adj elements until j == i and simultaneously count the number of swaps too.\\n**This is the greedy approach for this question**\\n\\n**Time Complexity : O(N * N)**\\n**Space Complexity : O(N)**\\n\\n```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {    \\n        \\n        int cnt = 0;\\n        string src = num;\\n        \\n        while( k -- ) \\n            next_permutation(num.begin(), num.end());\\n        \\n        cout << num << endl;\\n        for(int i = 0; i < num.length(); ++i) {\\n            \\n            int j = i;\\n            if(src[i] != num[j]) {\\n                \\n                while(num[j] != src[i]) \\n                    i += 1;\\n                \\n                while(i > j) {\\n                    swap(src[i], src[i-1]);\\n                    i -= 1;\\n                    cnt += 1;\\n                }\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```\\nPlease do upvote if you like the explanation.\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {    \\n        \\n        int cnt = 0;\\n        string src = num;\\n        \\n        while( k -- ) \\n            next_permutation(num.begin(), num.end());\\n        \\n        cout << num << endl;\\n        for(int i = 0; i < num.length(); ++i) {\\n            \\n            int j = i;\\n            if(src[i] != num[j]) {\\n                \\n                while(num[j] != src[i]) \\n                    i += 1;\\n                \\n                while(i > j) {\\n                    swap(src[i], src[i-1]);\\n                    i -= 1;\\n                    cnt += 1;\\n                }\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1467322,
                "title": "python-3-permutation-brute-force-explanation",
                "content": "### Explanation\\n- Essentailly [31. Next Permutation](https://leetcode.com/problems/next-permutation/) + Brute Force on finding swaps\\n- See below comments for more detail\\n### Implementation\\n```\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        def next_permutation(nums):\\n            small = len(nums) - 2\\n            while small >= 0 and nums[small] >= nums[small+1]: small -= 1 # find last place there is an increase\\n            if small == -1: nums.reverse()                                # mono-decrease\\n            else:\\n                next_larger = small+1\\n                for i in range(len(nums)-1, small, -1):\\n                    # find smallest number larger than `nums[small]` from right side of `small`, \\n                    #   if there are same value, take the most right one\\n                    if nums[small] < nums[i]: next_larger = i; break\\n                nums[small], nums[next_larger] = nums[next_larger], nums[small]\\n                start = small+1\\n                nums[start:] = nums[start:][::-1]\\n            return nums\\n\\n        origin, num = list(num), list(num)\\n        for _ in range(k):                    # O(n*k)\\n            num = next_permutation(num)\\n        ans, n = 0, len(origin)\\n        for i in range(n):                    # O(n*n)\\n            j = num.index(origin[i], i)\\n            ans += j - i\\n            num[i:j+1] = [num[j]] + num[i:j]\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Probability and Statistics"
                ],
                "code": "```\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        def next_permutation(nums):\\n            small = len(nums) - 2\\n            while small >= 0 and nums[small] >= nums[small+1]: small -= 1 # find last place there is an increase\\n            if small == -1: nums.reverse()                                # mono-decrease\\n            else:\\n                next_larger = small+1\\n                for i in range(len(nums)-1, small, -1):\\n                    # find smallest number larger than `nums[small]` from right side of `small`, \\n                    #   if there are same value, take the most right one\\n                    if nums[small] < nums[i]: next_larger = i; break\\n                nums[small], nums[next_larger] = nums[next_larger], nums[small]\\n                start = small+1\\n                nums[start:] = nums[start:][::-1]\\n            return nums\\n\\n        origin, num = list(num), list(num)\\n        for _ in range(k):                    # O(n*k)\\n            num = next_permutation(num)\\n        ans, n = 0, len(origin)\\n        for i in range(n):                    # O(n*n)\\n            j = num.index(origin[i], i)\\n            ans += j - i\\n            num[i:j+1] = [num[j]] + num[i:j]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1188352,
                "title": "javascript-next-permutation-w-explanation",
                "content": "```javascript\\nvar getMinSwaps = function(num, k) {\\n    \\n    const digits = [...num]\\n    const len = digits.length;\\n    \\n    // helper function to swap elements in digits in place\\n    const swap = (i, j) => [digits[i], digits[j]] = [digits[j], digits[i]]\\n    \\n    // helper function to reverse elements in digits from i to the end of digits\\n    const reverse = (i) => {\\n        for (let j = len - 1; i < j; ++i && --j) {\\n            swap(i, j);\\n        }\\n    }\\n    \\n    // helper to get the next smallest permutation for digits\\n    const nextPermutation = () => {\\n        // from right to left, find the first decreasing index\\n        // in digits and store it as i\\n        let i = len - 2;\\n        while (digits[i] >= digits[i + 1]) {\\n            i--;\\n        }\\n        \\n        // from right to left, find the first index in digits\\n        // that is greater than element at i\\n        let j = len - 1;\\n        while (digits[j] <= digits[i]) {\\n            j--;\\n        }\\n        \\n        // swap the 2 elements at i and j\\n        swap(i, j);\\n        // reverse all elements after i because we know that\\n        // all elements after i are in ascending order\\n        // from right to left\\n        reverse(i + 1);\\n    }\\n    \\n    // find the next permutation k times\\n    for (let i = 0; i < k; i++) {\\n        nextPermutation();\\n    }\\n\\n    // find out how many swaps it will take to get to the\\n    // kth permutation by finding out how many swaps\\n    // it takes to put digits back to its original state\\n    let numSwaps = 0;\\n    for (let i = 0; i < len; i++) {\\n        let j = i;\\n        // find the first element in digits to matches\\n        // num[i] and hold its place at j\\n        while (num[i] !== digits[j]) {\\n            j++;\\n        }\\n        \\n        // move the element at j to i while counting the\\n        // number of swaps\\n        while (i < j) {\\n            swap(j, j - 1);\\n            numSwaps++;\\n            j--;\\n        }\\n    }\\n    return numSwaps;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar getMinSwaps = function(num, k) {\\n    \\n    const digits = [...num]\\n    const len = digits.length;\\n    \\n    // helper function to swap elements in digits in place\\n    const swap = (i, j) => [digits[i], digits[j]] = [digits[j], digits[i]]\\n    \\n    // helper function to reverse elements in digits from i to the end of digits\\n    const reverse = (i) => {\\n        for (let j = len - 1; i < j; ++i && --j) {\\n            swap(i, j);\\n        }\\n    }\\n    \\n    // helper to get the next smallest permutation for digits\\n    const nextPermutation = () => {\\n        // from right to left, find the first decreasing index\\n        // in digits and store it as i\\n        let i = len - 2;\\n        while (digits[i] >= digits[i + 1]) {\\n            i--;\\n        }\\n        \\n        // from right to left, find the first index in digits\\n        // that is greater than element at i\\n        let j = len - 1;\\n        while (digits[j] <= digits[i]) {\\n            j--;\\n        }\\n        \\n        // swap the 2 elements at i and j\\n        swap(i, j);\\n        // reverse all elements after i because we know that\\n        // all elements after i are in ascending order\\n        // from right to left\\n        reverse(i + 1);\\n    }\\n    \\n    // find the next permutation k times\\n    for (let i = 0; i < k; i++) {\\n        nextPermutation();\\n    }\\n\\n    // find out how many swaps it will take to get to the\\n    // kth permutation by finding out how many swaps\\n    // it takes to put digits back to its original state\\n    let numSwaps = 0;\\n    for (let i = 0; i < len; i++) {\\n        let j = i;\\n        // find the first element in digits to matches\\n        // num[i] and hold its place at j\\n        while (num[i] !== digits[j]) {\\n            j++;\\n        }\\n        \\n        // move the element at j to i while counting the\\n        // number of swaps\\n        while (i < j) {\\n            swap(j, j - 1);\\n            numSwaps++;\\n            j--;\\n        }\\n    }\\n    return numSwaps;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1186968,
                "title": "python-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef getMinSwaps(self, num: str, k: int) -> int:\\n\\t\\t\\tnums = list(num)\\n\\t\\t\\tfor i in range(k):\\n\\t\\t\\t\\tl = -1\\n\\t\\t\\t\\tfor j in range(len(nums) - 2, -1, -1):\\n\\t\\t\\t\\t\\tif nums[j] < nums[j + 1]:\\n\\t\\t\\t\\t\\t\\tl = j\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\tif l == -1:\\n\\t\\t\\t\\t\\tnums.reverse()\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tr = len(nums) - 1\\n\\t\\t\\t\\t\\tfor j in range(len(nums) - 1, -1, -1):\\n\\t\\t\\t\\t\\t\\tif nums[j] > nums[l]:\\n\\t\\t\\t\\t\\t\\t\\tnums[l], nums[j] = nums[j], nums[l]\\n\\t\\t\\t\\t\\t\\t\\tl += 1\\n\\t\\t\\t\\t\\t\\t\\twhile l < r:\\n\\t\\t\\t\\t\\t\\t\\t\\tnums[l], nums[r] = nums[r], nums[l]\\n\\t\\t\\t\\t\\t\\t\\t\\tl += 1\\n\\t\\t\\t\\t\\t\\t\\t\\tr -= 1\\n\\t\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor i in range(len(nums)):\\n\\t\\t\\t\\tif nums[i] != num[i]:\\n\\t\\t\\t\\t\\tj = i\\n\\t\\t\\t\\t\\twhile j < len(nums) and nums[i] != num[j]:\\n\\t\\t\\t\\t\\t\\tj += 1\\n\\t\\t\\t\\t\\tres += j - i\\n\\t\\t\\t\\t\\tnum = num[:i] + num[j] + num[i:j] + num[j + 1:]\\n\\t\\t\\treturn res",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef getMinSwaps(self, num: str, k: int) -> int:\\n\\t\\t\\tnums = list(num)\\n\\t\\t\\tfor i in range(k):\\n\\t\\t\\t\\tl = -1\\n\\t\\t\\t\\tfor j in range(len(nums) - 2, -1, -1):\\n\\t\\t\\t\\t\\tif nums[j] < nums[j + 1]:\\n\\t\\t\\t\\t\\t\\tl = j\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\tif l == -1:\\n\\t\\t\\t\\t\\tnums.reverse()\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tr = len(nums) - 1\\n\\t\\t\\t\\t\\tfor j in range(len(nums) - 1, -1, -1):\\n\\t\\t\\t\\t\\t\\tif nums[j] > nums[l]:\\n\\t\\t\\t\\t\\t\\t\\tnums[l], nums[j] = nums[j], nums[l]\\n\\t\\t\\t\\t\\t\\t\\tl += 1\\n\\t\\t\\t\\t\\t\\t\\twhile l < r:\\n\\t\\t\\t\\t\\t\\t\\t\\tnums[l], nums[r] = nums[r], nums[l]\\n\\t\\t\\t\\t\\t\\t\\t\\tl += 1\\n\\t\\t\\t\\t\\t\\t\\t\\tr -= 1\\n\\t\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor i in range(len(nums)):\\n\\t\\t\\t\\tif nums[i] != num[i]:\\n\\t\\t\\t\\t\\tj = i\\n\\t\\t\\t\\t\\twhile j < len(nums) and nums[i] != num[j]:\\n\\t\\t\\t\\t\\t\\tj += 1\\n\\t\\t\\t\\t\\tres += j - i\\n\\t\\t\\t\\t\\tnum = num[:i] + num[j] + num[i:j] + num[j + 1:]\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 3170241,
                "title": "c-greedy-solution-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first thought to solve this problem is to use a greedy algorithm. We can keep track of the number of swaps we need to make by looping through the two strings and swapping any characters that are out of order.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMy approach to solving this problem is to use a greedy algorithm. We will loop through both strings and keep track of the number of swaps we need to make. To do this, we will compare the characters of each string and swap any that are out of order. We will continue this loop until all the characters are in the correct order.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\n#pragma GCC optimize(\"Ofast\",\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\",\"f16c\")\\nstatic const auto fast = []() {ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); return 0; } ();\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string s = num;\\n        while (k--) {\\n            next_permutation(s.begin(), s.end());\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < num.size(); i++) {\\n            if (num[i] == s[i]) continue;\\n            for (int j = i + 1; j < num.size(); j++) {\\n                if (num[j] == s[i]) {\\n                    ans += j - i;\\n                    while (j > i) {\\n                        swap(num[j], num[j - 1]);\\n                        j--;\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String",
                    "Greedy"
                ],
                "code": "```\\n#pragma GCC optimize(\"Ofast\",\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\",\"f16c\")\\nstatic const auto fast = []() {ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); return 0; } ();\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string s = num;\\n        while (k--) {\\n            next_permutation(s.begin(), s.end());\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < num.size(); i++) {\\n            if (num[i] == s[i]) continue;\\n            for (int j = i + 1; j < num.size(); j++) {\\n                if (num[j] == s[i]) {\\n                    ans += j - i;\\n                    while (j > i) {\\n                        swap(num[j], num[j - 1]);\\n                        j--;\\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2209103,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int getMinSwaps(String num, int k) {\\n        return this.sol(num,k);\\n    }\\n    public int sol(String s,int k) {\\n        char[] array = s.toCharArray();\\n        for(int i =0; i< k;i++) {\\n            s = new String(this.nextPermuatation(s));\\n        }\\n        int count =0;\\n        char[] arrayor = s.toCharArray();\\n        int  i =0,j =0;\\n        while(i <= s.length() - 1) {\\n            if(arrayor[i] == array[j]) {\\n                i++;\\n                j++;\\n            }\\n            else {\\n                char temp  = arrayor[i];\\n                while(array[j] != temp && j <= s.length() - 1) {\\n                    j++;\\n                }\\n                while(j >= (i + 1)) {\\n                    char tmp = array[j];\\n                    array[j] = array[j - 1];\\n                    array[j - 1] = tmp;\\n                    j--;\\n                    count = count + 1;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    public char[] nextPermuatation(String s) {\\n        char[] chararray = s.toCharArray();\\n        int i;\\n        for(i  =s.length() - 1;i >= 1;i--) {\\n            if(chararray[i - 1] - \\'0\\' < chararray[i] - \\'0\\') {\\n                break;\\n            }\\n        }\\n        if(i > 0) {\\n            int storer = i - 1;\\n            int great = chararray.length - 1;\\n            for(int j = chararray.length - 1;j > storer;j--) {\\n                if(chararray[j] > chararray[storer]) {\\n                    great = j;\\n                    break;\\n                }\\n            }\\n            char temp = chararray[storer];\\n            chararray[storer] = chararray[great];\\n            chararray[great] = temp;\\n            int lower = storer + 1;\\n            int higher = chararray.length - 1;\\n            while(lower < higher) {\\n                char e = chararray[lower];\\n                chararray[lower] = chararray[higher];\\n                chararray[higher] = e;\\n                lower++;\\n                higher--;\\n            }\\n        }\\n        return chararray;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinSwaps(String num, int k) {\\n        return this.sol(num,k);\\n    }\\n    public int sol(String s,int k) {\\n        char[] array = s.toCharArray();\\n        for(int i =0; i< k;i++) {\\n            s = new String(this.nextPermuatation(s));\\n        }\\n        int count =0;\\n        char[] arrayor = s.toCharArray();\\n        int  i =0,j =0;\\n        while(i <= s.length() - 1) {\\n            if(arrayor[i] == array[j]) {\\n                i++;\\n                j++;\\n            }\\n            else {\\n                char temp  = arrayor[i];\\n                while(array[j] != temp && j <= s.length() - 1) {\\n                    j++;\\n                }\\n                while(j >= (i + 1)) {\\n                    char tmp = array[j];\\n                    array[j] = array[j - 1];\\n                    array[j - 1] = tmp;\\n                    j--;\\n                    count = count + 1;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    public char[] nextPermuatation(String s) {\\n        char[] chararray = s.toCharArray();\\n        int i;\\n        for(i  =s.length() - 1;i >= 1;i--) {\\n            if(chararray[i - 1] - \\'0\\' < chararray[i] - \\'0\\') {\\n                break;\\n            }\\n        }\\n        if(i > 0) {\\n            int storer = i - 1;\\n            int great = chararray.length - 1;\\n            for(int j = chararray.length - 1;j > storer;j--) {\\n                if(chararray[j] > chararray[storer]) {\\n                    great = j;\\n                    break;\\n                }\\n            }\\n            char temp = chararray[storer];\\n            chararray[storer] = chararray[great];\\n            chararray[great] = temp;\\n            int lower = storer + 1;\\n            int higher = chararray.length - 1;\\n            while(lower < higher) {\\n                char e = chararray[lower];\\n                chararray[lower] = chararray[higher];\\n                chararray[higher] = e;\\n                lower++;\\n                higher--;\\n            }\\n        }\\n        return chararray;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1975125,
                "title": "easy-solution-using-c",
                "content": "```\\n\\n``\\n`class Solution {\\npublic:\\n    int minSteps(string s1, string s2) {\\n        int size = s1.length();\\n        \\n        int i = 0, j = 0;\\n        \\n        int result = 0;\\n        \\n        \\n        while (i < size) {\\n            j = i;\\n            while (s1[j] != s2[i]) j++;\\n\\t\\t\\t\\n            while (i < j) {\\n                swap(s1[j], s1[j-1]);\\n                j--;\\n                result++;\\n            }\\n            i++;\\n        }\\n        return result;\\n    }\\n    \\n    int getMinSwaps(string num, int k) {\\n        string original = num;\\n        \\n        while(k--) {\\n            next_permutation(num.begin(), num.end());\\n        }\\n        \\n        return minSteps(original, num);\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minSteps(string s1, string s2) {\\n        int size = s1.length();\\n        \\n        int i = 0, j = 0;\\n        \\n        int result = 0;\\n        \\n        \\n        while (i < size) {\\n            j = i;\\n            while (s1[j] != s2[i]) j++;\\n\\t\\t\\t\\n            while (i < j) {\\n                swap(s1[j], s1[j-1]);\\n                j--;\\n                result++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1954087,
                "title": "java-easy-solution",
                "content": "### **Used next Permutation Problem to solve this one.**\\n#### next Permutation Problem Link : https://leetcode.com/problems/next-permutation/\\n\\n\\n\\n```\\nclass Solution {\\n    public int getMinSwaps(String num, int k) {\\n        int[] nums=new int[num.length()];\\n        int[] org=new int[num.length()];\\n        \\n        for(int i=0;i<num.length();i++){\\n            int e=Character.getNumericValue(num.charAt(i));\\n            nums[i]=e;\\n            org[i]=e;\\n        }\\n        \\n        while(k!=0){\\n        nextPermutation(nums);\\n         k--;   \\n        }\\n        \\n        int ans=0;\\n        \\n        \\n        for(int i=0;i<nums.length;i++){\\n             \\n            if(nums[i]!=org[i]){\\n                int j=0;\\n                for(j=i+1;j<nums.length;j++)\\n                    if(org[j]==nums[i])\\n                        break;\\n             \\n                while(j>0 && j!=i){\\n                    swap(org,j,j-1);\\n                    ans++;\\n                    j--;\\n                }\\n                \\n            }\\n            \\n  \\n    }\\n           \\n      return ans;    \\n\\n    }\\n    \\n    \\npublic void nextPermutation(int[] nums) {\\n        \\n        if(nums.length<=1)\\n            return;\\n         \\n        int j=nums.length-2;\\n       while(j>=0 && nums[j]>=nums[j+1])\\n           j--;\\n        \\n        if(j>=0){\\n        int k=nums.length-1;\\n        while(nums[j]>=nums[k])\\n            k--;\\n    \\n        swap(nums,j,k);\\n        \\n        }\\n        \\n        reverse(nums,j+1,nums.length-1);\\n    \\n      \\n    }\\n    \\n    public void swap(int[] nums,int j,int k){\\n        int temp=nums[j];\\n            nums[j]=nums[k];\\n            nums[k]=temp;\\n    }\\n    \\n    public void reverse(int[] nums,int i,int j){\\n        while(i<=j){\\n            swap(nums,i,j);\\n                i++;\\n                j--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinSwaps(String num, int k) {\\n        int[] nums=new int[num.length()];\\n        int[] org=new int[num.length()];\\n        \\n        for(int i=0;i<num.length();i++){\\n            int e=Character.getNumericValue(num.charAt(i));\\n            nums[i]=e;\\n            org[i]=e;\\n        }\\n        \\n        while(k!=0){\\n        nextPermutation(nums);\\n         k--;   \\n        }\\n        \\n        int ans=0;\\n        \\n        \\n        for(int i=0;i<nums.length;i++){\\n             \\n            if(nums[i]!=org[i]){\\n                int j=0;\\n                for(j=i+1;j<nums.length;j++)\\n                    if(org[j]==nums[i])\\n                        break;\\n             \\n                while(j>0 && j!=i){\\n                    swap(org,j,j-1);\\n                    ans++;\\n                    j--;\\n                }\\n                \\n            }\\n            \\n  \\n    }\\n           \\n      return ans;    \\n\\n    }\\n    \\n    \\npublic void nextPermutation(int[] nums) {\\n        \\n        if(nums.length<=1)\\n            return;\\n         \\n        int j=nums.length-2;\\n       while(j>=0 && nums[j]>=nums[j+1])\\n           j--;\\n        \\n        if(j>=0){\\n        int k=nums.length-1;\\n        while(nums[j]>=nums[k])\\n            k--;\\n    \\n        swap(nums,j,k);\\n        \\n        }\\n        \\n        reverse(nums,j+1,nums.length-1);\\n    \\n      \\n    }\\n    \\n    public void swap(int[] nums,int j,int k){\\n        int temp=nums[j];\\n            nums[j]=nums[k];\\n            nums[k]=temp;\\n    }\\n    \\n    public void reverse(int[] nums,int i,int j){\\n        while(i<=j){\\n            swap(nums,i,j);\\n                i++;\\n                j--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1928733,
                "title": "python-using-next-perm-with-explanation",
                "content": "```\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        #find kth\\n\\t\\ttarget=num\\n        for i in range(k):\\n            target=self.next_perm(target)\\n        \\n\\t\\t#count step\\n        res=0\\n        num=list(num)\\n        for i in range(len(num)):\\n            if num[i]!=target[i]:\\n                j=i\\n\\t\\t\\t\\t#num[j]==target[i]\\n                while num[j]!=target[i]:\\n                    j+=1\\n\\t\\t\\t\\t#swap (j-i) times\\n                while j>i:\\n                    num[j-1],num[j]=num[j],num[j-1]\\n                    res+=1\\n                    j-=1\\n        return res                    \\n        \\n    def next_perm(self,num):\\n        num=list(num)\\n        \\n        # find first non-ascending digit num[i-1] from right to left\\n        i=len(num)-1\\n        while i>0 and num[i-1]>=num[i]:\\n            i-=1\\n            \\n        # find first larger digit num[j] from right to left\\n        if i>0:\\n            for j in range(len(num)-1,i-1,-1):\\n                if num[j]>num[i-1]:\\n                    break        \\n        #swap\\n        num[i-1],num[j]=num[j],num[i-1]\\n        \\n        #reverse\\n        return \\'\\'.join(num[:i]+sorted(num[i:]))             \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        #find kth\\n\\t\\ttarget=num\\n        for i in range(k):\\n            target=self.next_perm(target)\\n        \\n\\t\\t#count step\\n        res=0\\n        num=list(num)\\n        for i in range(len(num)):\\n            if num[i]!=target[i]:\\n                j=i\\n\\t\\t\\t\\t#num[j]==target[i]\\n                while num[j]!=target[i]:\\n                    j+=1\\n\\t\\t\\t\\t#swap (j-i) times\\n                while j>i:\\n                    num[j-1],num[j]=num[j],num[j-1]\\n                    res+=1\\n                    j-=1\\n        return res                    \\n        \\n    def next_perm(self,num):\\n        num=list(num)\\n        \\n        # find first non-ascending digit num[i-1] from right to left\\n        i=len(num)-1\\n        while i>0 and num[i-1]>=num[i]:\\n            i-=1\\n            \\n        # find first larger digit num[j] from right to left\\n        if i>0:\\n            for j in range(len(num)-1,i-1,-1):\\n                if num[j]>num[i-1]:\\n                    break        \\n        #swap\\n        num[i-1],num[j]=num[j],num[i-1]\\n        \\n        #reverse\\n        return \\'\\'.join(num[:i]+sorted(num[i:]))             \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1870500,
                "title": "c-nextpermutation-adjacent-swaps",
                "content": "**Approach**\\n\\n***Step 1***\\nwe will find the kth permutation by simply by finding the nextPermutation k times or by simply using the STL function given\\n\\n***Step 2***\\nnow we will find the adjacent swaps needed by comparing the original and permutated string\\nwe compare both the string and try to bring all the characters in the permutated string to the same index as in the original string by performing swaps\\n\\n--if nums[i] != dupl[j]\\nthen we find nums[i] in dupl string\\nnow we bring the character in dupl string to the ith index by swapping with adjacent elements and keep the count of swaps\\nwe repeat these steps till we reach the last index\\n**Code**\\n```\\nint getMinSwaps(string &nums, int k) {\\n        \\n        string dupl = kthPerm(nums,k);\\n        \\n        int n = nums.size();\\n        \\n        \\n        //adjacent swaps\\n        int j=0,swaps=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            j=i;\\n            \\n            while(nums[i]!=dupl[j])\\n                j++;\\n            \\n            while(i<j)\\n            {\\n                swap(dupl[j],dupl[j-1]);\\n                j--;\\n                swaps++;\\n            }\\n            \\n        }\\n        return swaps;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nint getMinSwaps(string &nums, int k) {\\n        \\n        string dupl = kthPerm(nums,k);\\n        \\n        int n = nums.size();\\n        \\n        \\n        //adjacent swaps\\n        int j=0,swaps=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            j=i;\\n            \\n            while(nums[i]!=dupl[j])\\n                j++;\\n            \\n            while(i<j)\\n            {\\n                swap(dupl[j],dupl[j-1]);\\n                j--;\\n                swaps++;\\n            }\\n            \\n        }\\n        return swaps;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1833927,
                "title": "simple-c-solution-next-permutation",
                "content": "# Approach:- \\n1.) First we will find the Kth largest permutation of the given string.\\n2.) we will calculate no. of swaps required to make original string to our ans string.\\n\\n**Approach to calculate minimum no. of swaps:-** \\nUse two pointers i and j for first and second strings respectively. Initialise i and j to 0. \\nIterate over the first string and find the position j such that s1[j] = s2[i] by incrementing the value to j. Keep on swapping the adjacent elements j and j \\u2013 1 and decrement j until it is greater than i. \\nNow the ith element of the first string is equal to the second string, hence increment the value of i. \\nThis technique will give the minimum number of steps as there are zero unnecessary swaps.\\n```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string s, int k) {\\n        \\n        string ans = s;\\n        // Calculating Kth next permutation\\n        for(int i=0; i<k; i++) next_permutation(ans.begin(), ans.end());\\n        \\n        int count = 0;\\n        int i = 0, n = s.length();\\n        // Calculating swaps to convert string s to string ans\\n        while(i < n) {\\n            int j = i;\\n            while(s[j] != ans[i]) j++;\\n            while(i < j) {\\n                swap(s[j], s[j-1]);\\n                j--;\\n                count++;\\n            }\\n            i++;\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n**Please upvote it if you find it useful.**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string s, int k) {\\n        \\n        string ans = s;\\n        // Calculating Kth next permutation\\n        for(int i=0; i<k; i++) next_permutation(ans.begin(), ans.end());\\n        \\n        int count = 0;\\n        int i = 0, n = s.length();\\n        // Calculating swaps to convert string s to string ans\\n        while(i < n) {\\n            int j = i;\\n            while(s[j] != ans[i]) j++;\\n            while(i < j) {\\n                swap(s[j], s[j-1]);\\n                j--;\\n                count++;\\n            }\\n            i++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1819177,
                "title": "c-simple-solution-next-permutation",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n          string p_String = num; \\n        while (k--) {\\n            next_permutation(p_String.begin(), p_String.end()); \\n        }\\n    \\n        int ans = 0; \\n        for (int i = 0; i < num.size(); ++i) {\\n            int ii = i+1; \\n            while (num[i] != p_String[i]) {\\n                ++ans; \\n                swap(p_String[i], p_String[ii++]); \\n            }\\n        }\\n        return ans;  \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n          string p_String = num; \\n        while (k--) {\\n            next_permutation(p_String.begin(), p_String.end()); \\n        }\\n    \\n        int ans = 0; \\n        for (int i = 0; i < num.size(); ++i) {\\n            int ii = i+1; \\n            while (num[i] != p_String[i]) {\\n                ++ans; \\n                swap(p_String[i], p_String[ii++]); \\n            }\\n        }\\n        return ans;  \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1814110,
                "title": "c-easy-to-understand-simple-solution-using-next-permutation-o-n-2",
                "content": "Firstly, we find the next kth permutation using next_permutation which is an inbuilt function .\\nThen , we think greedily and try to put every digit to its correct position and count the swaps needed for each and place the digit in front and similarly traverse for the rest of the digits.\\n\\ne.g. we have num=1234 , k=5\\nthen the required number will be 1432\\nthen after first iteration it will remain the same as 1==1\\non 2!=4 we will count 2 swaps and put 4 in its correct position then num becomes 1423.. similarly we will do for the upcoming digits.\\n\\n\\n\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n       string a=num;\\n        int c=0;\\n        while(k--)\\n        {\\n          next_permutation(num.begin(),num.end());       //finding next kth permutation\\n        }\\n        int j;\\n        for(int i=0;i<a.length();i++)\\n        {\\n            if(a[i]!=num[i])\\n            {\\n                for( j=i+1;j<a.length();j++)\\n                {\\n                     c++;                   // counting how much ahead the current digit is from its required position\\n                    if(num[i]==a[j])\\n                    {\\n                        break;\\n                    }\\n                }\\n                char t=a[j];\\n                for(int k=j-1;k>=i;k--) \\n                {\\n                    a[k+1]=a[k];                             //placing the digit to its correct position\\n                }\\n                a[i]=t;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n\\tThe above solution requires O(n^2) time...\\n\\tFeel free to comment below if you have any doubt :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n       string a=num;\\n        int c=0;\\n        while(k--)\\n        {\\n          next_permutation(num.begin(),num.end());       //finding next kth permutation\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1804193,
                "title": "c-next-permutation-and-greedy-swapping",
                "content": "\\t\\t\\tnext_permutation(s.begin(), s.end()) gives the next string which comes in the dictionary oder\\n            after the string s\\n            so for the kth smallest wonderful string, we have to go k places next\\n\\n            and then after that, we just have to find the minimum number of adjacent swaps required\\n            to convert the string nums to the string target (this can be done using two pointer method)\\n\\n            lets say we have to convert 3 4 5 -> 4 5 3\\n\\n            nums\\n            i\\n            3 4 5\\n\\n            target\\n            j\\n            4 5 3\\n            keep advancing j till you nums[i] and nums[j] become different\\n\\n            nums\\n            i\\n            3 4 5\\n\\n            target\\n                j\\n            4 5 3\\n\\n            now keep swapping to bring the guy at j to the position i in the target\\n\\n                j                      j                      j\\n            4 5 3 --> (swap and j--) 4 3 5 --> (swap and j--) 3 4 5\\n            now move i forward\\n\\n\\n            try one yourself by doing the dry run\\n\\n            3 4 5 --> 5 4 3\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string nums, int k) {\\n        \\n        // we want the kth smallest wonderful string first\\n\\n        string target = nums;\\n        while (k--) next_permutation(target.begin(), target.end());\\n\\n        int i = 0, j = 0;\\n        int len = nums.length();\\n\\n        while (i < len &&  nums[i] == target[j]) {\\n            i++; j++;\\n        }\\n        int swapCount = 0;\\n\\n        while (i < len) {\\n            j = i;\\n            while (j < len && nums[i] != target[j]) j++;\\n            while (j > i) {\\n                swap(target[j], target[j - 1]);\\n                j--; swapCount++;\\n            } i++;\\n\\n        }\\n\\n        return swapCount;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string nums, int k) {\\n        \\n        // we want the kth smallest wonderful string first\\n\\n        string target = nums;\\n        while (k--) next_permutation(target.begin(), target.end());\\n\\n        int i = 0, j = 0;\\n        int len = nums.length();\\n\\n        while (i < len &&  nums[i] == target[j]) {\\n            i++; j++;\\n        }\\n        int swapCount = 0;\\n\\n        while (i < len) {\\n            j = i;\\n            while (j < len && nums[i] != target[j]) j++;\\n            while (j > i) {\\n                swap(target[j], target[j - 1]);\\n                j--; swapCount++;\\n            } i++;\\n\\n        }\\n\\n        return swapCount;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1641101,
                "title": "python-solution-with-explaination",
                "content": "Basically, we need to implement 2 algorithms here:\\n1. Get the next permutation.\\n2. Find the minimum adjacent swap to transfrom one string to another.\\n\\n```python\\nclass Solution:\\n    def next_permutation(self, nums: List[int]) -> List[int]:\\n        \"\"\"\\n        returns the next permutation\\n        \"\"\"    \\n        # the size is 1, no next permutation\\n        if len(nums) == 1:\\n            raise ValueError(\"invalid input!\")\\n        \\n        # search the first decrease\\n        found_i = False\\n        for i in range(len(nums)-2, -1, -1):\\n            if nums[i] < nums[i+1]:\\n                found_i = True\\n                break\\n                \\n        # it\\'s sorted, no next permutation\\n        if not found_i:\\n            raise ValueError(\"invalid input!\")\\n        \\n        # use the minimum among those greater than nums[i] for swapping\\n        to_swap = i + 1\\n        for j in range(i+1, len(nums)):\\n            if nums[j] > nums[i] and nums[j] < nums[to_swap]:\\n                to_swap = j\\n        nums[i], nums[to_swap] = nums[to_swap], nums[i]\\n        \\n        # sort the rest part to minimize it\\n        nums[i+1:] = sorted(nums[i+1:])\\n        return nums    \\n    \\n    def minimum_swap(self, s1: List[str], s2: List[str]) -> int:\\n        \"\"\"\\n        returns the minimum number of swaps\\n        \"\"\"        \\n        ret = 0\\n        p1, p2 = 0, 0\\n        while p2 < len(s2):\\n            if s1[p1] == s2[p2]:\\n                p1 += 1\\n                p2 += 1\\n            # not same, keep increasing p1 to get the target\\n            else:\\n                while True:\\n                    p1 += 1\\n                    if s1[p1] == s2[p2]:\\n                        ret += p1 - p2\\n                        # move s1[p1] to s1[p2], push the rest ahead\\n                        s1[p2:p1+1] = [s1[p1]] + s1[p2:p1]\\n                        break\\n                p2 += 1\\n                p1 = p2\\n        \\n        return ret\\n        \\n    \\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        \"\"\"\\n        1. find the k-th next permutation\\n        2. find the num of swaps to take.\\n        \"\"\"\\n        origin = [x for x in num]\\n        target = [int(x) for x in num]\\n        \\n        # get the k-th next permutation\\n        for i in range(k):\\n            target = self.next_permutation(target)\\n\\n        # get the minimum swap\\n        target = [str(x) for x in target]\\n        return self.minimum_swap(origin, target)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def next_permutation(self, nums: List[int]) -> List[int]:\\n        \"\"\"\\n        returns the next permutation\\n        \"\"\"    \\n        # the size is 1, no next permutation\\n        if len(nums) == 1:\\n            raise ValueError(\"invalid input!\")\\n        \\n        # search the first decrease\\n        found_i = False\\n        for i in range(len(nums)-2, -1, -1):\\n            if nums[i] < nums[i+1]:\\n                found_i = True\\n                break\\n                \\n        # it\\'s sorted, no next permutation\\n        if not found_i:\\n            raise ValueError(\"invalid input!\")\\n        \\n        # use the minimum among those greater than nums[i] for swapping\\n        to_swap = i + 1\\n        for j in range(i+1, len(nums)):\\n            if nums[j] > nums[i] and nums[j] < nums[to_swap]:\\n                to_swap = j\\n        nums[i], nums[to_swap] = nums[to_swap], nums[i]\\n        \\n        # sort the rest part to minimize it\\n        nums[i+1:] = sorted(nums[i+1:])\\n        return nums    \\n    \\n    def minimum_swap(self, s1: List[str], s2: List[str]) -> int:\\n        \"\"\"\\n        returns the minimum number of swaps\\n        \"\"\"        \\n        ret = 0\\n        p1, p2 = 0, 0\\n        while p2 < len(s2):\\n            if s1[p1] == s2[p2]:\\n                p1 += 1\\n                p2 += 1\\n            # not same, keep increasing p1 to get the target\\n            else:\\n                while True:\\n                    p1 += 1\\n                    if s1[p1] == s2[p2]:\\n                        ret += p1 - p2\\n                        # move s1[p1] to s1[p2], push the rest ahead\\n                        s1[p2:p1+1] = [s1[p1]] + s1[p2:p1]\\n                        break\\n                p2 += 1\\n                p1 = p2\\n        \\n        return ret\\n        \\n    \\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        \"\"\"\\n        1. find the k-th next permutation\\n        2. find the num of swaps to take.\\n        \"\"\"\\n        origin = [x for x in num]\\n        target = [int(x) for x in num]\\n        \\n        # get the k-th next permutation\\n        for i in range(k):\\n            target = self.next_permutation(target)\\n\\n        # get the minimum swap\\n        target = [str(x) for x in target]\\n        return self.minimum_swap(origin, target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1533970,
                "title": "c-solution-using-next-permutation-explained",
                "content": "First get the kth smallest using next_permutation.\\nCounting adjacent swaps:\\nIn a for loop, keep checking if `s[i]==t[i]`. In case `s[i]!=t[i]`, go ahead and find the index of that character in the `string t`. Now we need to bring that character to index i by swapping only adjacent characters. Do that in a while loop and keep incrementing the final answer.\\n```\\nint getMinSwaps(string s, int k) {\\n        int n = s.size();\\n        string t = s;\\n        while(k--)\\n            next_permutation(t.begin(),t.end());\\n        \\n        int ans = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i] != t[i])\\n            {\\n                int j=i+1;\\n                while(j<n && t[j] != s[i])\\n                    j++;\\n                while(j>i)\\n                {\\n                    swap(t[j],t[j-1]);\\n                    j--;\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint getMinSwaps(string s, int k) {\\n        int n = s.size();\\n        string t = s;\\n        while(k--)\\n            next_permutation(t.begin(),t.end());\\n        \\n        int ans = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i] != t[i])\\n            {\\n                int j=i+1;\\n                while(j<n && t[j] != s[i])\\n                    j++;\\n                while(j>i)\\n                {\\n                    swap(t[j],t[j-1]);\\n                    j--;\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1466245,
                "title": "c-solution-with-comments-and-idea",
                "content": "\\n        //Idea is that find the next permutation for \"k\" times and then after that swap the\\n\\t\\t//characters untill the original string and permutation\\n\\t\\t//become equal and everytime u swap increment the count and once the strings become\\n\\t\\t//equal return count.\\n\\t\\t\\'\\'\\'\\n\\t\\t\\n        string res=num;\\n        for(int i=0;i<k;i++) next_permutation(num.begin(),num.end());\\n        int swap_count=0;\\n        for(int i=0;i<res.length();i++){\\n            if(res[i]!=num[i]){\\n                int start=i+1;   // search from i+1 index\\n                while(res[i]!=num[start]) start++;    //find the index to swap \\n                while(i!=start){\\n                    swap(num[start],num[start-1]);    // swap untill the characters are at same index\\n                    start--;\\n                    swap_count++;\\n                }\\n            }\\n        }\\n        return swap_count;\\n    }\\n}; \\n\\n\\'\\'\\'",
                "solutionTags": [
                    "C++"
                ],
                "code": "\\n        //Idea is that find the next permutation for \"k\" times and then after that swap the\\n\\t\\t//characters untill the original string and permutation\\n\\t\\t//become equal and everytime u swap increment the count and once the strings become\\n\\t\\t//equal return count.\\n\\t\\t\\'\\'\\'\\n\\t\\t\\n        string res=num;\\n        for(int i=0;i<k;i++) next_permutation(num.begin(),num.end());\\n        int swap_count=0;\\n        for(int i=0;i<res.length();i++){\\n            if(res[i]!=num[i]){\\n                int start=i+1;   // search from i+1 index\\n                while(res[i]!=num[start]) start++;    //find the index to swap \\n                while(i!=start){\\n                    swap(num[start],num[start-1]);    // swap untill the characters are at same index\\n                    start--;\\n                    swap_count++;\\n                }\\n            }\\n        }\\n        return swap_count;\\n    }\\n}; \\n\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1436453,
                "title": "python-a-bit-long-but-clear-comments",
                "content": "Split the issue into two parts\\n1. Find the number of kth smallest, this is same problem with leetcode  https://leetcode.com/problems/next-permutation/\\n2. Check how many steps needed to make the two numbers same. Use greedy\\nEg:  \\noriginal number:     $$$@=&=&=**\\ntarget number:       $$$=&&==@**\\nHow can you make them same: From the position which the number is different, always choose the cheaper cost(the nearest same character) to swap.\\n\\n$$$@=&=&=**  => $$$=@&=&=**  => $$$=&@=&=**  =>$$$=&&@==** => $$$=&&=@=** => $$$=&&==@**\\n\\n```\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        target = [int(c) for c in list(num)]\\n        while k > 0:\\n            self.nextPermutation(target)\\n            k -= 1\\n        return self.minSwap([int(c) for c in list(num)], target)\\n\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        n = len(nums)\\n        if n > 1:\\n            flag = False  # flag to check whether there is element exist that <\\n            for i in range(n - 1, -1, -1):\\n                if i >= 1 and nums[i - 1] < nums[i]:\\n                    flag = True\\n                    break\\n            if not flag:  # nums is descending order\\n                self.reverseList(nums, 0, n - 1)\\n            else:\\n                for j in range(n - 1, i - 1, -1):  # find first element bigger than i - 1 and swap\\n                    if nums[j] > nums[i - 1]:\\n                        break\\n                nums[i - 1], nums[j] = nums[j], nums[i - 1]\\n                self.reverseList(nums, i, n - 1)\\n\\n    def reverseList(self, nums, start, end) -> None:\\n        if end >= start + 1:\\n            i, j = start, end\\n            while i < j:\\n                nums[i], nums[j] = nums[j], nums[i]\\n                i += 1\\n                j -= 1\\n\\n    def minSwap(self, origin, target) -> int:  # get the min swap steps to reach from origin to target\\n        if origin == target:\\n            return 0\\n        \\n        ans = 0\\n        org, tag = deque(origin), deque(target)\\n        while tag:\\n            while tag and org[0] == tag[0]:  # check from left, if elements are same pop\\n                org.popleft()\\n                tag.popleft()\\n\\n            if not tag:  # if tag is empty, no swap needed\\n                return ans\\n            else:  # tag differs from org                  \\n                for i in range(1, len(org)): # search in the orginal list from index 1 to find the nearest\\n                    if org[i] == tag[0]:                        \\n                        break  # find the same character\\n                for j in range(i - 1, -1, -1):  # move the characters in org, one by one\\n                    org[j + 1] = org[j]\\n                    ans += 1  # for each move, add 1 to ans\\n                org[0] = tag[0]\\n\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        target = [int(c) for c in list(num)]\\n        while k > 0:\\n            self.nextPermutation(target)\\n            k -= 1\\n        return self.minSwap([int(c) for c in list(num)], target)\\n\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        n = len(nums)\\n        if n > 1:\\n            flag = False  # flag to check whether there is element exist that <\\n            for i in range(n - 1, -1, -1):\\n                if i >= 1 and nums[i - 1] < nums[i]:\\n                    flag = True\\n                    break\\n            if not flag:  # nums is descending order\\n                self.reverseList(nums, 0, n - 1)\\n            else:\\n                for j in range(n - 1, i - 1, -1):  # find first element bigger than i - 1 and swap\\n                    if nums[j] > nums[i - 1]:\\n                        break\\n                nums[i - 1], nums[j] = nums[j], nums[i - 1]\\n                self.reverseList(nums, i, n - 1)\\n\\n    def reverseList(self, nums, start, end) -> None:\\n        if end >= start + 1:\\n            i, j = start, end\\n            while i < j:\\n                nums[i], nums[j] = nums[j], nums[i]\\n                i += 1\\n                j -= 1\\n\\n    def minSwap(self, origin, target) -> int:  # get the min swap steps to reach from origin to target\\n        if origin == target:\\n            return 0\\n        \\n        ans = 0\\n        org, tag = deque(origin), deque(target)\\n        while tag:\\n            while tag and org[0] == tag[0]:  # check from left, if elements are same pop\\n                org.popleft()\\n                tag.popleft()\\n\\n            if not tag:  # if tag is empty, no swap needed\\n                return ans\\n            else:  # tag differs from org                  \\n                for i in range(1, len(org)): # search in the orginal list from index 1 to find the nearest\\n                    if org[i] == tag[0]:                        \\n                        break  # find the same character\\n                for j in range(i - 1, -1, -1):  # move the characters in org, one by one\\n                    org[j + 1] = org[j]\\n                    ans += 1  # for each move, add 1 to ans\\n                org[0] = tag[0]\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1428734,
                "title": "c",
                "content": "```\\n\\n```public:\\n    int solve(string temp,string s)\\n    {\\n        int count=0,j;\\n        for(int i=0;i<temp.length();i++)\\n        {\\n            if(temp[i]!=s[i])\\n            {\\n                j=i+1;\\n                while(temp[i]!=s[j])\\n                {\\n                    j++;\\n                }\\n                while(j>i)\\n                {\\n                    count++;\\n                    swap(s[j-1],s[j]);\\n                    j--;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    int getMinSwaps(string num, int k) {\\n        string s=num;\\n        while(k>0&&next_permutation(s.begin(),s.end()))\\n        {\\n            k--;\\n        }\\n        return solve(s,num);\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1379338,
                "title": "c-without-using-inbuilt-next-permutation",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void permutation(string &arr){\\n        int n = arr.size();\\n        int i;\\n        for(i = n-2;i>=0;i--){\\n            if(arr[i] < arr[i+1])\\n                break;\\n        }\\n        //it is guaranteed that a valid next permutation exists\\n        int j;\\n        for(j=n-1;j>i;j--){\\n            if(arr[j]>arr[i]) \\n                break;\\n        }\\n        swap(arr[i] , arr[j]);\\n        reverse(arr.begin() + i + 1 , arr.end());\\n    }\\n    \\n    int getMinSwaps(string num, int k) {\\n        string val = num;\\n        while(k--)\\n            permutation(val);\\n        int ans = 0 , n = num.length();\\n\\t\\t//now compare num and val to find minimum number of adjancent swappings\\n\\t\\t//for each num[i] move it to its corresponding position in \\'val\\' by swapping adjacent elements.\\n\\t\\t//Count each such swap\\n        for(int i=0;i<n;i++){\\n            if(num[i] != val[i]) {\\n                int j = i+1;\\n                while(num[j] != val[i]) \\n                    j++;\\n                while(i<j) {\\n                    swap(num[j] , num[j-1]);\\n                    j--;\\n                    ans++;\\n                }\\n            }\\n        }        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void permutation(string &arr){\\n        int n = arr.size();\\n        int i;\\n        for(i = n-2;i>=0;i--){\\n            if(arr[i] < arr[i+1])\\n                break;\\n        }\\n        //it is guaranteed that a valid next permutation exists\\n        int j;\\n        for(j=n-1;j>i;j--){\\n            if(arr[j]>arr[i]) \\n                break;\\n        }\\n        swap(arr[i] , arr[j]);\\n        reverse(arr.begin() + i + 1 , arr.end());\\n    }\\n    \\n    int getMinSwaps(string num, int k) {\\n        string val = num;\\n        while(k--)\\n            permutation(val);\\n        int ans = 0 , n = num.length();\\n\\t\\t//now compare num and val to find minimum number of adjancent swappings\\n\\t\\t//for each num[i] move it to its corresponding position in \\'val\\' by swapping adjacent elements.\\n\\t\\t//Count each such swap\\n        for(int i=0;i<n;i++){\\n            if(num[i] != val[i]) {\\n                int j = i+1;\\n                while(num[j] != val[i]) \\n                    j++;\\n                while(i<j) {\\n                    swap(num[j] , num[j-1]);\\n                    j--;\\n                    ans++;\\n                }\\n            }\\n        }        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1282568,
                "title": "python-solution-skipping-factorials",
                "content": "\\tclass Solution(object):\\n\\t\\tdef getMinSwaps(self, num, k):\\n\\t\\t\\tn=len(num)\\n\\t\\t\\tdp={1:1}\\n\\t\\t\\tdpindex={}\\n\\t\\t\\tdef findPermutation(num,k,n):\\n\\t\\t\\t\\td={num[n-1]:1}\\n\\t\\t\\t\\tfor i in range(n-2,-1,-1):\\n\\t\\t\\t\\t\\tcurrent=num[i]\\n\\t\\t\\t\\t\\tif(current not in d):\\n\\t\\t\\t\\t\\t\\td[current]=1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\td[current]+=1\\n\\t\\t\\t\\t\\tif(current<num[i+1]):\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\tcurrent=num[i]    \\n\\t\\t\\t\\tfor j in range(n-1,i,-1):\\n\\t\\t\\t\\t\\tif(k==0):\\n\\t\\t\\t\\t\\t\\treturn num\\n\\t\\t\\t\\t\\tif(current<num[j]):\\n\\t\\t\\t\\t\\t\\tnum[i]=num[j]\\n\\t\\t\\t\\t\\t\\tnum[j]=current\\n\\t\\t\\t\\t\\t\\ttotal=1\\n\\t\\t\\t\\t\\t\\td[num[i]]-=1\\n\\t\\t\\t\\t\\t\\tfor z in d.values():\\n\\t\\t\\t\\t\\t\\t\\tif(z>1):\\n\\t\\t\\t\\t\\t\\t\\t\\ttotal*=factorial(z)\\n\\n\\t\\t\\t\\t\\t\\tfact=factorial(n-i-1)\\n\\t\\t\\t\\t\\t\\tfact=fact/total\\n\\t\\t\\t\\t\\t\\tif(fact==1 and k>1):\\n\\t\\t\\t\\t\\t\\t\\treturn findPermutation(num,k-1,n)\\n\\n\\t\\t\\t\\t\\t\\tif(fact<=k):\\n\\t\\t\\t\\t\\t\\t\\tk=k-fact\\n\\t\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t\\tsnum=list(num)\\n\\t\\t\\t\\t\\t\\t\\tindex=i+1\\n\\t\\t\\t\\t\\t\\t\\tk=k-1\\n\\t\\t\\t\\t\\t\\t\\tfor m in range(n-1,i,-1):\\n\\t\\t\\t\\t\\t\\t\\t\\tnum[m]=snum[index]\\n\\t\\t\\t\\t\\t\\t\\t\\tindex+=1\\n\\t\\t\\t\\t\\t\\treturn findPermutation(num,k,n)\\n\\n\\t\\t\\tdef factorial(number):\\n\\t\\t\\t\\tif(number in dp):\\n\\t\\t\\t\\t\\treturn dp[number]\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tans=number*factorial(number-1)\\n\\t\\t\\t\\t\\tdp[number]=ans\\n\\t\\t\\t\\t\\treturn ans\\n\\n\\n\\t\\t\\tdef findSwaps(inlist,z,index,n,swapCount):\\n\\t\\t\\t\\tif(index==n):\\n\\t\\t\\t\\t\\treturn swapCount\\n\\t\\t\\t\\tcurrent=inlist[index]\\n\\t\\t\\t\\tflag=True\\n\\t\\t\\t\\tfor i in range(index,n):\\n\\t\\t\\t\\t\\tif(current==z[i]):\\n\\t\\t\\t\\t\\t\\tflag=False\\n\\t\\t\\t\\t\\t\\tfor j in range(i,index,-1):\\n\\t\\t\\t\\t\\t\\t\\ttemp=z[j-1]\\n\\t\\t\\t\\t\\t\\t\\tz[j-1]=z[j]\\n\\t\\t\\t\\t\\t\\t\\tz[j]=temp\\n\\t\\t\\t\\t\\t\\t\\tswapCount+=1\\n\\t\\t\\t\\t\\t\\treturn findSwaps(inlist,z,index+1,n,swapCount)\\n\\t\\t\\t\\tif(flag):\\n\\t\\t\\t\\t\\treturn -1\\n\\n\\t\\t\\tintlist=[]\\n\\t\\t\\tfor char in num:\\n\\t\\t\\t\\tintlist.append(int(char))\\n\\n\\t\\t\\tinlist=list(intlist)\\n\\t\\t\\tz=findPermutation(intlist,k,n)\\n\\t\\t\\tans=findSwaps(inlist,z,0,len(inlist),0)\\n\\t\\t\\treturn ans",
                "solutionTags": [],
                "code": "class Solution(object):\\n\\t\\tdef getMinSwaps(self, num, k):\\n\\t\\t\\tn=len(num)\\n\\t\\t\\tdp={1:1}",
                "codeTag": "Java"
            },
            {
                "id": 1231992,
                "title": "c-easy-solution-90-beat",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string ll=num;\\n        while(k!=0)\\n        {\\n            next_permutation(num.begin(),num.end());\\n            k--;\\n        }\\n        int ans=0;\\n        for(int i=0;i<ll.size()-1;i++)\\n        {\\n            if(ll[i]!=num[i])\\n            {\\n                int j=i+1;\\n                while(j<ll.size() && num[i]!=ll[j])\\n                {\\n                    j++;\\n                }\\n                ans+=j-i;\\n                ll.insert(ll.begin()+i,num[i]);\\n                ll.erase(ll.begin()+j+1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string ll=num;\\n        while(k!=0)\\n        {\\n            next_permutation(num.begin(),num.end());\\n            k--;\\n        }\\n        int ans=0;\\n        for(int i=0;i<ll.size()-1;i++)\\n        {\\n            if(ll[i]!=num[i])\\n            {\\n                int j=i+1;\\n                while(j<ll.size() && num[i]!=ll[j])\\n                {\\n                    j++;\\n                }\\n                ans+=j-i;\\n                ll.insert(ll.begin()+i,num[i]);\\n                ll.erase(ll.begin()+j+1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1204627,
                "title": "c-cpp-max-k-n-2-complexity",
                "content": "class Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        \\n        int arr[num.size()];\\n        string store = num;\\n        \\n        for(int i = 0; i < k; ++i){ //k!\\n            next_permutation(num.begin(), num.end());\\n        }\\n        \\n        for(int i = 0; i < num.size(); ++i){\\n            for(int j = 0; j < store.size(); ++j){ //n^2\\n                if(num[i] == store[j]){\\n                    arr[j] = i;\\n                    store[j] = \\'.\\';\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        int inv_count = 0;\\n        multiset<int> mset;\\n        mset.insert(arr[num.size()-1]);\\n        //Finding inversion count\\n\\t\\t\\n        for(int i = num.size()-2; i >= 0; --i){//nlongn\\n            if(arr[i] > *mset.begin()){\\n                auto it = mset.begin();\\n                while(it != mset.end() and *it < arr[i]){\\n                    inv_count++, it++;\\n                }\\n            }\\n            mset.insert(arr[i]);\\n        }\\n        \\n        return inv_count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        \\n        int arr[num.size()];\\n        string store = num;\\n        \\n        for(int i = 0; i < k; ++i){ //k!\\n            next_permutation(num.begin(), num.end());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1202160,
                "title": "python-permutation-indexchange",
                "content": "```\\nclass Solution:\\n    def getMinSwaps(self, num, k):\\n        \\n        def permutation(num,k):\\n            num=list(num)\\n            for i in range(k):\\n                j= len(num)-2\\n                while j>=0 and num[j]>=num[j+1]:\\n                    j-=1\\n                k= len(num)-1\\n                while num[k] <= num[j]:\\n                    k-=1\\n                \\n                num[k],num[j] = num[j],num[k]\\n                num=num[:j+1]+sorted(num[j+1:])\\n            return num\\n                \\n\\n        def indexcount(main,perm):\\n\\n            n = len(main)\\n            cnt=0\\n            for i in range(n):\\n                \\n                if main[i] != perm[i]:\\n                    \\n                    tmp = i+1\\n                    while main[i]!=perm[tmp]:\\n                        tmp+=1\\n\\n                    while i!=tmp:\\n                        perm[tmp], perm[tmp-1] = perm[tmp-1],perm[tmp]\\n                        tmp-=1\\n                        cnt+=1\\n\\n            return cnt\\n\\n        return indexcount(list(num),permutation(num,k))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def getMinSwaps(self, num, k):\\n        \\n        def permutation(num,k):\\n            num=list(num)\\n            for i in range(k):\\n                j= len(num)-2\\n                while j>=0 and num[j]>=num[j+1]:\\n                    j-=1\\n                k= len(num)-1\\n                while num[k] <= num[j]:\\n                    k-=1\\n                \\n                num[k],num[j] = num[j],num[k]\\n                num=num[:j+1]+sorted(num[j+1:])\\n            return num\\n                \\n\\n        def indexcount(main,perm):\\n\\n            n = len(main)\\n            cnt=0\\n            for i in range(n):\\n                \\n                if main[i] != perm[i]:\\n                    \\n                    tmp = i+1\\n                    while main[i]!=perm[tmp]:\\n                        tmp+=1\\n\\n                    while i!=tmp:\\n                        perm[tmp], perm[tmp-1] = perm[tmp-1],perm[tmp]\\n                        tmp-=1\\n                        cnt+=1\\n\\n            return cnt\\n\\n        return indexcount(list(num),permutation(num,k))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194245,
                "title": "simple-c-o-n-2-greedy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        vector<int> nums;\\n        for (int i = 0; i < num.length(); i++)  nums.push_back(num[i] - \\'0\\');\\n        vector<int> temp = nums;\\n        int count = 0, len = nums.size();\\n        \\n        while (k--) {\\n            bool flag = false;\\n            for (int i = len - 1;  i >= 0; i--) {\\n                if ((i >= 1) && nums[i - 1] < nums[i]) {\\n                    i = i - 1;\\n                    flag = true;\\n                }\\n                if (flag) {\\n                    int maxi, idx;\\n                    maxi = nums[i + 1];\\n                    idx = i + 1;\\n                    for (int j = i + 1; j < len; j++) {\\n                        if (nums[j] > nums[i] && (maxi >= nums[j])) {\\n                            maxi = nums[j];\\n                            idx = j;\\n                        }   \\n                    }\\n                        swap(nums[i], nums[idx]);\\n                        sort(nums.begin() + i + 1, nums.end());\\n                        break;\\n                }\\n                flag = false;\\n            }\\n        }\\n        \\n        int id = 0;\\n        for (; id < nums.size(); id++) {\\n            if (temp[id] != nums[id])   break;\\n        }\\n        \\n        for (int i = id; i < nums.size(); i++) {\\n            //cout << nums[i] << endl;\\n            vector<int> :: iterator it = find(temp.begin() + i, temp.end(), nums[i]);\\n            count += it - (temp.begin() + i);\\n            temp.erase(it);\\n            temp.insert(temp.begin() + i, nums[id]);\\n        }\\n        \\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        vector<int> nums;\\n        for (int i = 0; i < num.length(); i++)  nums.push_back(num[i] - \\'0\\');\\n        vector<int> temp = nums;\\n        int count = 0, len = nums.size();\\n        \\n        while (k--) {\\n            bool flag = false;\\n            for (int i = len - 1;  i >= 0; i--) {\\n                if ((i >= 1) && nums[i - 1] < nums[i]) {\\n                    i = i - 1;\\n                    flag = true;\\n                }\\n                if (flag) {\\n                    int maxi, idx;\\n                    maxi = nums[i + 1];\\n                    idx = i + 1;\\n                    for (int j = i + 1; j < len; j++) {\\n                        if (nums[j] > nums[i] && (maxi >= nums[j])) {\\n                            maxi = nums[j];\\n                            idx = j;\\n                        }   \\n                    }\\n                        swap(nums[i], nums[idx]);\\n                        sort(nums.begin() + i + 1, nums.end());\\n                        break;\\n                }\\n                flag = false;\\n            }\\n        }\\n        \\n        int id = 0;\\n        for (; id < nums.size(); id++) {\\n            if (temp[id] != nums[id])   break;\\n        }\\n        \\n        for (int i = id; i < nums.size(); i++) {\\n            //cout << nums[i] << endl;\\n            vector<int> :: iterator it = find(temp.begin() + i, temp.end(), nums[i]);\\n            count += it - (temp.begin() + i);\\n            temp.erase(it);\\n            temp.insert(temp.begin() + i, nums[id]);\\n        }\\n        \\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1191938,
                "title": "java-mathematical-solution",
                "content": "**Idea:**\\nRather than popular approach of \"next permutation\", I\\'m thinking about **\"next set of permutation\"**. It\\'s acually matematical problem to be solved. \\n\\nLet\\'s get started with \"49872\".\\n\\nWhat\\'s the next permutation\\uFF1F \\n72498\\n\\nHow do we get it? \\n1. We scan from right to left(2->7->8->9), and find the first digit which is less than its right(9->4)\\n2. Now we know we need to replace 4, but with what?\\n3. Replacement is the the least digit that is strictly greater than 4, which is 7\\n\\n**[Key question]** How many permutations are started with \"7\", then?\\nThe motivation is if the **number(n)** of permutation is less than k, we know target permutation can\\'t be started with 7. Thus, we skip to **next set of permutation** started with 8. Otherwise, we can be sure first digit is 7. Then do the same thing recursively.\\n\\nHow to calculate the number(n)?\\nAs I said, it\\'s time to test your math. \\n\\n72498?\\nn=**P**(4,4)=4!=24. Great!\\n724498?\\nn=**P**(5,5)/**P**(2,2) = 5!/2! = 60, where **P**(2,2) represents duplicate of 4\\n722449988?\\nn=**P**(8,8)/(**P**(2,2)***P**(2,2)***P**(2,2)***P**(2,2)) = 8!/(2!*2!*2!*2!)\\n\\nTherefore, we need Map to store digit and it\\'s frequence. Meawhile, it\\'s better to sort digit, so that it\\'s easier to get 7, 8, 9.\\nIn short, we need to TreeMap :)\\n\\nAbout Swap.\\nIt\\'s greedy algorithm core. Others have introduced that, we can skip it.\\n\\n\\n```\\nimport java.util.NavigableMap;\\nimport java.util.Map.Entry;\\nclass Solution {\\n    public int getMinSwaps(String s, int k) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        int leftNum = 0;\\n        int left = 0;\\n\\t\\t//Get \"4\", and initialize map to be\\n\\t\\t//{2=1, 4=1, 7=1, 8=1, 9=1}\\n        for(int i=s.length()-1;i>=0;i--){\\n            int num=s.charAt(i)-\\'0\\';\\n            add(map, num);\\n            if(s.charAt(i-1)<s.charAt(i)){\\n                leftNum=s.charAt(i-1)-\\'0\\';\\n                left = i-1;\\n                add(map, leftNum);\\n                break;\\n            }\\n        }\\n        String res = helper(s.substring(0,left), map, k, leftNum);\\n        return count(s, res);\\n        \\n    }\\n    private String helper(String s, TreeMap<Integer, Integer> map, int k, int leftNum){\\n\\t\\t//Get sub map whose keys are greater than 4. {7=1, 8=1, 9=1}\\n        NavigableMap<Integer, Integer> tailMap = map.tailMap(leftNum, false);\\n        List<Integer> candidates = tailMap.keySet().stream().collect(Collectors.toList());\\n        for(int candidate:candidates){\\n\\t\\t    //if we get started with 7, we need to reduce 7\\'s frequence by 1.\\n            remove(map, candidate);\\n            int size = getSize(map);\\n            if(k>size){\\n                k-=size;\\n                add(map, candidate);\\n            }\\n            else if(k<size){\\n                char ch = (char)(candidate+\\'0\\');\\n                return helper(s+ch, map, k, -1);\\n            }\\n            else{\\n                char ch = (char)(candidate+\\'0\\');\\n                String part = \"\";\\n                for(Entry<Integer, Integer> e:map.entrySet()){\\n                    for(int i=0;i<e.getValue();i++){\\n                        part = e.getKey()+ part;\\n                    }\\n                }\\n                return s+ch+part;\\n            }\\n        }\\n\\t\\t// If we don\\'t find target, that means we need to move one more digit left\\n\\t\\t// 49872 -> *49872\\n        int num=s.charAt(s.length()-1)-\\'0\\';\\n        add(map, num);\\n        return helper(s.substring(0,s.length()-1), map, k, num);\\n    }\\n    private void add(TreeMap<Integer, Integer> map, int key){\\n        map.put(key, map.getOrDefault(key, 0)+1);\\n    }\\n    private void remove(TreeMap<Integer, Integer> map, int key){\\n        int value = map.get(key);\\n        if(value==1){\\n            map.remove(key);\\n        }\\n        else{\\n            map.put(key,value-1);\\n        }\\n    }\\n    \\n    private int getSize(TreeMap<Integer, Integer> map){\\n        int num = 0;\\n        PriorityQueue<Integer> denominator = new PriorityQueue<>();\\n\\t\\t/*\\n\\t\\t* This is the tricky part, it\\'s impossible to calculate factory of large number, like 80!\\n\\t\\t* So my approach is to store all factors in advance, and divide numerator as soon as possible to avoid overflow.\\n\\t\\t*/\\n        for(int value: map.values()){\\n            num+=value;\\n            for(int i=2;i<=value;i++){\\n                denominator.add(i);\\n            }\\n        }\\n        int res = 1;\\n        for(int i=1;i<=num;i++){\\n            res*=i;\\n            while(!denominator.isEmpty() && res % denominator.peek()==0){\\n                int key = denominator.poll();\\n                res/= key;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n\\n    private int count(String s, String t){\\n        char[] c1 = s.toCharArray();\\n        char[] c2 = t.toCharArray();\\n        int cur = 0;\\n        int n = s.length();\\n        int res = 0;\\n        while(cur<n){\\n\\t\\t\\t/*\\n\\t\\t\\t*  43578965\\n\\t\\t\\t*  43596857\\n\\t\\t\\t* ->\\n\\t\\t\\t* 78965\\n\\t\\t\\t* 96758\\n\\t\\t\\t*/\\n            while(cur<n && c1[cur]==c2[cur]){\\n                cur++;\\n            }\\n            if(cur>=n){\\n                break;\\n            }\\n            char last = c2[cur];\\n\\t\\t\\t/*\\n\\t\\t\\t* 78965\\n\\t\\t\\t* 96758\\n\\t\\t\\t* ->\\n\\t\\t\\t* 78965\\n\\t\\t\\t* 79658\\n\\t\\t\\t*/\\n            for(int below = cur+1; below<n; below++){\\n                char tmp = c2[below];\\n                c2[below]=last;\\n                last = tmp;\\n                if(tmp==c1[cur]){\\n                    res+=below-cur;\\n                    c2[cur]=tmp;\\n                    break;\\n                }\\n            }\\n            cur++;\\n        }\\n        return res;\\n    } \\n}\\n```",
                "solutionTags": [
                    "Math",
                    "Probability and Statistics"
                ],
                "code": "```\\nimport java.util.NavigableMap;\\nimport java.util.Map.Entry;\\nclass Solution {\\n    public int getMinSwaps(String s, int k) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        int leftNum = 0;\\n        int left = 0;\\n\\t\\t//Get \"4\", and initialize map to be\\n\\t\\t//{2=1, 4=1, 7=1, 8=1, 9=1}\\n        for(int i=s.length()-1;i>=0;i--){\\n            int num=s.charAt(i)-\\'0\\';\\n            add(map, num);\\n            if(s.charAt(i-1)<s.charAt(i)){\\n                leftNum=s.charAt(i-1)-\\'0\\';\\n                left = i-1;\\n                add(map, leftNum);\\n                break;\\n            }\\n        }\\n        String res = helper(s.substring(0,left), map, k, leftNum);\\n        return count(s, res);\\n        \\n    }\\n    private String helper(String s, TreeMap<Integer, Integer> map, int k, int leftNum){\\n\\t\\t//Get sub map whose keys are greater than 4. {7=1, 8=1, 9=1}\\n        NavigableMap<Integer, Integer> tailMap = map.tailMap(leftNum, false);\\n        List<Integer> candidates = tailMap.keySet().stream().collect(Collectors.toList());\\n        for(int candidate:candidates){\\n\\t\\t    //if we get started with 7, we need to reduce 7\\'s frequence by 1.\\n            remove(map, candidate);\\n            int size = getSize(map);\\n            if(k>size){\\n                k-=size;\\n                add(map, candidate);\\n            }\\n            else if(k<size){\\n                char ch = (char)(candidate+\\'0\\');\\n                return helper(s+ch, map, k, -1);\\n            }\\n            else{\\n                char ch = (char)(candidate+\\'0\\');\\n                String part = \"\";\\n                for(Entry<Integer, Integer> e:map.entrySet()){\\n                    for(int i=0;i<e.getValue();i++){\\n                        part = e.getKey()+ part;\\n                    }\\n                }\\n                return s+ch+part;\\n            }\\n        }\\n\\t\\t// If we don\\'t find target, that means we need to move one more digit left\\n\\t\\t// 49872 -> *49872\\n        int num=s.charAt(s.length()-1)-\\'0\\';\\n        add(map, num);\\n        return helper(s.substring(0,s.length()-1), map, k, num);\\n    }\\n    private void add(TreeMap<Integer, Integer> map, int key){\\n        map.put(key, map.getOrDefault(key, 0)+1);\\n    }\\n    private void remove(TreeMap<Integer, Integer> map, int key){\\n        int value = map.get(key);\\n        if(value==1){\\n            map.remove(key);\\n        }\\n        else{\\n            map.put(key,value-1);\\n        }\\n    }\\n    \\n    private int getSize(TreeMap<Integer, Integer> map){\\n        int num = 0;\\n        PriorityQueue<Integer> denominator = new PriorityQueue<>();\\n\\t\\t/*\\n\\t\\t* This is the tricky part, it\\'s impossible to calculate factory of large number, like 80!\\n\\t\\t* So my approach is to store all factors in advance, and divide numerator as soon as possible to avoid overflow.\\n\\t\\t*/\\n        for(int value: map.values()){\\n            num+=value;\\n            for(int i=2;i<=value;i++){\\n                denominator.add(i);\\n            }\\n        }\\n        int res = 1;\\n        for(int i=1;i<=num;i++){\\n            res*=i;\\n            while(!denominator.isEmpty() && res % denominator.peek()==0){\\n                int key = denominator.poll();\\n                res/= key;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n\\n    private int count(String s, String t){\\n        char[] c1 = s.toCharArray();\\n        char[] c2 = t.toCharArray();\\n        int cur = 0;\\n        int n = s.length();\\n        int res = 0;\\n        while(cur<n){\\n\\t\\t\\t/*\\n\\t\\t\\t*  43578965\\n\\t\\t\\t*  43596857\\n\\t\\t\\t* ->\\n\\t\\t\\t* 78965\\n\\t\\t\\t* 96758\\n\\t\\t\\t*/\\n            while(cur<n && c1[cur]==c2[cur]){\\n                cur++;\\n            }\\n            if(cur>=n){\\n                break;\\n            }\\n            char last = c2[cur];\\n\\t\\t\\t/*\\n\\t\\t\\t* 78965\\n\\t\\t\\t* 96758\\n\\t\\t\\t* ->\\n\\t\\t\\t* 78965\\n\\t\\t\\t* 79658\\n\\t\\t\\t*/\\n            for(int below = cur+1; below<n; below++){\\n                char tmp = c2[below];\\n                c2[below]=last;\\n                last = tmp;\\n                if(tmp==c1[cur]){\\n                    res+=below-cur;\\n                    c2[cur]=tmp;\\n                    break;\\n                }\\n            }\\n            cur++;\\n        }\\n        return res;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1188425,
                "title": "java-next-permutation-greedy-beats-95",
                "content": "This problem can be broken into 2 parts\\n1. Find the permutation (see https://leetcode.com/problems/next-permutation/)\\n\\t2. And my solution with explanation: https://leetcode.com/problems/next-permutation/discuss/1188189/java-provided-on-solution-with-comments\\n2. Find the minimal number of swaps\\n\\n```\\nclass Solution {\\n    public int getMinSwaps(String s, int k) {\\n        int[] nums = toArray(s);\\n        \\n        while (k > 0) {\\n            k--;\\n            nextPermutation(nums);\\n        }\\n        \\n        // find minimal count of swap\\n        int count = 0;\\n        final int[] original = toArray(s);\\n        for (int i = 0; i < original.length; i++) {\\n            if (original[i] == nums[i]) {\\n                continue;\\n            }\\n            \\n            // find a equal num in nums[i + 1:]\\n            int j = i + 1;\\n            while (original[i] != nums[j]) {\\n                j++;\\n            }\\n            \\n            // swap j all the way to i\\n            while (i < j) {\\n                swap(nums, j - 1, j);\\n                j--;\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n\\t\\n\\tvoid nextPermutation(int[] num) {\\n        if (num.length <= 1) {\\n            return;\\n        }\\n        \\n        // check if all descending order\\n        int i = num.length - 2;\\n        while (i >= 0 && num[i] >= num[i + 1]) {\\n            i--;\\n        }\\n        \\n        if (i >= 0) {\\n            // find the first number > i\\n            int j = num.length - 1;\\n            while (i < j && num[i] >= num[j]) {\\n                j--;\\n            }\\n            swap(num, i, j);\\n        }\\n        \\n        reverse(num, i + 1);\\n    }\\n    \\n    void reverse(int[] num, int start) {\\n        int i = start, j = num.length - 1;\\n        while (i < j) {\\n            swap(num, i, j);\\n            i++;\\n            j--;\\n        }\\n    }\\n    \\n    void swap(int[] num, int i, int j) {\\n        int tmp = num[i];\\n        num[i] = num[j];\\n        num[j] = tmp;\\n    }\\n        \\n    int[] toArray(String s) {\\n        int[] nums = new int[s.length()];\\n        for (int i = 0; i < s.length(); i++) {\\n            nums[i] = s.charAt(i) - \\'0\\';\\n        }\\n        \\n        return nums;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int getMinSwaps(String s, int k) {\\n        int[] nums = toArray(s);\\n        \\n        while (k > 0) {\\n            k--;\\n            nextPermutation(nums);\\n        }\\n        \\n        // find minimal count of swap\\n        int count = 0;\\n        final int[] original = toArray(s);\\n        for (int i = 0; i < original.length; i++) {\\n            if (original[i] == nums[i]) {\\n                continue;\\n            }\\n            \\n            // find a equal num in nums[i + 1:]\\n            int j = i + 1;\\n            while (original[i] != nums[j]) {\\n                j++;\\n            }\\n            \\n            // swap j all the way to i\\n            while (i < j) {\\n                swap(nums, j - 1, j);\\n                j--;\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n\\t\\n\\tvoid nextPermutation(int[] num) {\\n        if (num.length <= 1) {\\n            return;\\n        }\\n        \\n        // check if all descending order\\n        int i = num.length - 2;\\n        while (i >= 0 && num[i] >= num[i + 1]) {\\n            i--;\\n        }\\n        \\n        if (i >= 0) {\\n            // find the first number > i\\n            int j = num.length - 1;\\n            while (i < j && num[i] >= num[j]) {\\n                j--;\\n            }\\n            swap(num, i, j);\\n        }\\n        \\n        reverse(num, i + 1);\\n    }\\n    \\n    void reverse(int[] num, int start) {\\n        int i = start, j = num.length - 1;\\n        while (i < j) {\\n            swap(num, i, j);\\n            i++;\\n            j--;\\n        }\\n    }\\n    \\n    void swap(int[] num, int i, int j) {\\n        int tmp = num[i];\\n        num[i] = num[j];\\n        num[j] = tmp;\\n    }\\n        \\n    int[] toArray(String s) {\\n        int[] nums = new int[s.length()];\\n        for (int i = 0; i < s.length(); i++) {\\n            nums[i] = s.charAt(i) - \\'0\\';\\n        }\\n        \\n        return nums;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1187071,
                "title": "java-o-nk-next-permutation-o-nlogn-min-adjacent-swaps-to-align-two-permutations",
                "content": "## Step 1: repeate finding next greater permutaiton k times to find k-th smallest wonderful number.\\nTo find next greater permutation see, https://leetcode.com/problems/next-permutation/\\nTime `O(Nk)`, space `O(1)`\\n\\n## Step 2: find the minimum adjacent swaps required to make two permutations A and B identical.\\n1. Create integer array `X` where `X[i]` is the smallest index of remaining `A[i]` in B, i.e. `X[i] = j` where `B[j] == A[i]` and `j` is as small as possible.\\nTo do that, we can put B\\'s element to index mapping into a `Map<Character, Queue<Integer>>`, and iterate over `A[i]` to dequeue the smallest index in `map.get(A[i])`\\n2. Count number of inverted pairs in X, this can be done similar to merge sort in `O(NlogN)` time.\\nTime `O(NlogN)`, space O(N)\\n    \\nOverall time complexity is `O(N(k + logN))`, space `O(N)`\\n\\n\\n```java\\nclass Solution {\\n    public int getMinSwaps(String num, int k) {\\n        // find k-th smallest wonderful number\\n        String s = num;\\n        for (int i = 0; i < k; i++) {\\n            s = nextGreaterPermutation(s);\\n        }\\n        return getMinSwaps(num, s);\\n    }\\n    \\n    private String nextGreaterPermutation(String num) {\\n        char[] A = num.toCharArray();\\n        // Find last i so that A[i] < A[i + 1]\\n        int i = A.length - 2;\\n        while (i >= 0 && A[i] >= A[i + 1]) {\\n            i--;\\n        }\\n\\n        // swap A[i] with the smallest A[j] > A[i] where j > i\\n        int j = i;\\n        while (j + 1 < A.length && A[j + 1] > A[i]) {\\n            j++;\\n        }\\n        swap(A, i, j);\\n        // sort A[i+1:-1]\\n        reverse(A, i + 1, A.length - 1);\\n        return String.valueOf(A);\\n    }\\n    \\n    private void swap(char[] c, int i, int j) {\\n        char tmp = c[i];\\n        c[i] = c[j];\\n        c[j] = tmp;\\n    }\\n    \\n    private void reverse(char[] c, int start, int end) {\\n        while (start < end) {\\n            swap(c, start++, end--);\\n        }\\n    }\\n    \\n    // Count minimum number of adjacent swaps needed to make two permutations identical\\n    private int getMinSwaps(String a, String b) {\\n        int N = a.length();\\n        Map<Character, Queue<Integer>> charToBIdx = new HashMap<>();\\n        for (int j = 0; j < N; j++) {\\n            charToBIdx.computeIfAbsent(b.charAt(j), ignored -> new LinkedList<>()).offer(j);\\n        }\\n        \\n        int[] X = new int[N];\\n        for (int i = 0; i < N; i++) {\\n            X[i] = charToBIdx.get(a.charAt(i)).poll();\\n        }\\n        return getMinSwapsToSort(X, 0, N - 1);\\n    }\\n    \\n    // sort A[start...end] and return minimum adjacent swaps required\\n    private int getMinSwapsToSort(int[] A, int start, int end) {\\n        if (start >= end) {\\n            return 0;\\n        }\\n\\n        int mid = start + (end - start) / 2;\\n        int res = getMinSwapsToSort(A, start, mid) + getMinSwapsToSort(A, mid + 1, end);\\n\\n        // Two pointer count inverted pairs between left and right sorted subarrays\\n        int[] left = Arrays.copyOfRange(A, start, mid + 1);\\n        int[] right = Arrays.copyOfRange(A, mid + 1, end + 1);\\n        int l = 0;\\n        int r = 0;\\n        int i = start;\\n        while (l < left.length || r < right.length) {\\n            if (r >= right.length || l < left.length && left[l] <= right[r]) {\\n                res += r; // numbers in the right subarray that\\'s smaller than A[l] is equal to the steps r pointer\\n                // has advanced\\n                A[i++] = left[l++];\\n            } else {\\n                A[i++] = right[r++];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int getMinSwaps(String num, int k) {\\n        // find k-th smallest wonderful number\\n        String s = num;\\n        for (int i = 0; i < k; i++) {\\n            s = nextGreaterPermutation(s);\\n        }\\n        return getMinSwaps(num, s);\\n    }\\n    \\n    private String nextGreaterPermutation(String num) {\\n        char[] A = num.toCharArray();\\n        // Find last i so that A[i] < A[i + 1]\\n        int i = A.length - 2;\\n        while (i >= 0 && A[i] >= A[i + 1]) {\\n            i--;\\n        }\\n\\n        // swap A[i] with the smallest A[j] > A[i] where j > i\\n        int j = i;\\n        while (j + 1 < A.length && A[j + 1] > A[i]) {\\n            j++;\\n        }\\n        swap(A, i, j);\\n        // sort A[i+1:-1]\\n        reverse(A, i + 1, A.length - 1);\\n        return String.valueOf(A);\\n    }\\n    \\n    private void swap(char[] c, int i, int j) {\\n        char tmp = c[i];\\n        c[i] = c[j];\\n        c[j] = tmp;\\n    }\\n    \\n    private void reverse(char[] c, int start, int end) {\\n        while (start < end) {\\n            swap(c, start++, end--);\\n        }\\n    }\\n    \\n    // Count minimum number of adjacent swaps needed to make two permutations identical\\n    private int getMinSwaps(String a, String b) {\\n        int N = a.length();\\n        Map<Character, Queue<Integer>> charToBIdx = new HashMap<>();\\n        for (int j = 0; j < N; j++) {\\n            charToBIdx.computeIfAbsent(b.charAt(j), ignored -> new LinkedList<>()).offer(j);\\n        }\\n        \\n        int[] X = new int[N];\\n        for (int i = 0; i < N; i++) {\\n            X[i] = charToBIdx.get(a.charAt(i)).poll();\\n        }\\n        return getMinSwapsToSort(X, 0, N - 1);\\n    }\\n    \\n    // sort A[start...end] and return minimum adjacent swaps required\\n    private int getMinSwapsToSort(int[] A, int start, int end) {\\n        if (start >= end) {\\n            return 0;\\n        }\\n\\n        int mid = start + (end - start) / 2;\\n        int res = getMinSwapsToSort(A, start, mid) + getMinSwapsToSort(A, mid + 1, end);\\n\\n        // Two pointer count inverted pairs between left and right sorted subarrays\\n        int[] left = Arrays.copyOfRange(A, start, mid + 1);\\n        int[] right = Arrays.copyOfRange(A, mid + 1, end + 1);\\n        int l = 0;\\n        int r = 0;\\n        int i = start;\\n        while (l < left.length || r < right.length) {\\n            if (r >= right.length || l < left.length && left[l] <= right[r]) {\\n                res += r; // numbers in the right subarray that\\'s smaller than A[l] is equal to the steps r pointer\\n                // has advanced\\n                A[i++] = left[l++];\\n            } else {\\n                A[i++] = right[r++];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186850,
                "title": "python-3-with-next-permutation",
                "content": "Use next_permutation to find the target, then compute the number of swaps directly.\\n```\\ndef next_perm(s):\\n    for i in range(len(s)-2, -1, -1):\\n        if s[i]<s[i+1]:\\n            for j in range(i, len(s)):\\n                if j+1 < len(s) and s[j+1] <= s[i]:\\n                    break\\n            return s[:i] + s[j] + \\'\\'.join(sorted([s[k] for k in range(i, len(s)) if k != j]))\\n    return sorted(s)\\n\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        target_num = num\\n        for _ in range(k):\\n            target_num = next_perm(target_num)\\n                \\n        target = list(target_num)\\n        cur = list(num)\\n        swaps = 0\\n        for i in range(len(cur)):\\n            if target[i] == cur[i]: continue\\n                \\n            for j in range(i, len(num)):\\n                if cur[j] == target[i]:\\n                    swaps += j-i\\n                    cur = cur[:i] + [cur[j]] + [cur[x] for x in range(i, len(num)) if x!=j]\\n                    break\\n        return swaps\\n ```",
                "solutionTags": [],
                "code": "```\\ndef next_perm(s):\\n    for i in range(len(s)-2, -1, -1):\\n        if s[i]<s[i+1]:\\n            for j in range(i, len(s)):\\n                if j+1 < len(s) and s[j+1] <= s[i]:\\n                    break\\n            return s[:i] + s[j] + \\'\\'.join(sorted([s[k] for k in range(i, len(s)) if k != j]))\\n    return sorted(s)\\n\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        target_num = num\\n        for _ in range(k):\\n            target_num = next_perm(target_num)\\n                \\n        target = list(target_num)\\n        cur = list(num)\\n        swaps = 0\\n        for i in range(len(cur)):\\n            if target[i] == cur[i]: continue\\n                \\n            for j in range(i, len(num)):\\n                if cur[j] == target[i]:\\n                    swaps += j-i\\n                    cur = cur[:i] + [cur[j]] + [cur[x] for x in range(i, len(num)) if x!=j]\\n                    break\\n        return swaps\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 3944570,
                "title": "c-2-pointers",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void swap(string &a,int i,int j){\\n        int temp=a[i];\\n        a[i]=a[j];\\n        a[j]=temp;\\n    }\\n    void reverse(string &a,int s,int e){\\n        while(s<=e){\\n            swap(a,s,e);\\n            s++;e--;\\n        }\\n    }\\n    void nextPermutation(string &a) {\\n        int n=a.size();\\n        //from the right find the first pair where a[i]<a[i+1]\\n        int i;\\n        for(i=n-2;i>=0;i--){\\n            if(a[i]<a[i+1]) break;\\n        }\\n        if(i<0){\\n            reverse(a,0,n-1);\\n            return;\\n        } \\n        //swap a[i] with number just larger than it from right part\\n        int j;\\n        for(j=n-1;j>=i;j--){\\n            if(a[j]>a[i]){\\n                swap(a,i,j);\\n                break;\\n            }   \\n        }\\n        //reverse the right part \\n        reverse(a,i+1,n-1);\\n    }\\n    int getMinSwaps(string num, int k) {\\n        int count=0;\\n        string next=num;\\n        //next permutation of given number\\n        while(k--){\\n            nextPermutation(next);\\n        }\\n        //i points to num and next\\n        //k is used to find the mismatched character in next\\n        //num:  0 5 9\\n        //next: 9 5 0(k)\\n        for(int i=0;i<num.size();i++){\\n            if(num[i]!=next[i]){\\n                int k=i+1;\\n                while(next[k]!=num[i])  k++;\\n                while(k>i){\\n                    swap(next,k,k-1);\\n                    count++;\\n                    k--;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n//0 5 9\\n//0 9 5\\n//5 0 9\\n//5 9 0\\n//9 0 5\\n//9 5 0  --ans: 3\\n\\n//0 0 1 2 3\\n//0 0 1 3 2  --ans: 1\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void swap(string &a,int i,int j){\\n        int temp=a[i];\\n        a[i]=a[j];\\n        a[j]=temp;\\n    }\\n    void reverse(string &a,int s,int e){\\n        while(s<=e){\\n            swap(a,s,e);\\n            s++;e--;\\n        }\\n    }\\n    void nextPermutation(string &a) {\\n        int n=a.size();\\n        //from the right find the first pair where a[i]<a[i+1]\\n        int i;\\n        for(i=n-2;i>=0;i--){\\n            if(a[i]<a[i+1]) break;\\n        }\\n        if(i<0){\\n            reverse(a,0,n-1);\\n            return;\\n        } \\n        //swap a[i] with number just larger than it from right part\\n        int j;\\n        for(j=n-1;j>=i;j--){\\n            if(a[j]>a[i]){\\n                swap(a,i,j);\\n                break;\\n            }   \\n        }\\n        //reverse the right part \\n        reverse(a,i+1,n-1);\\n    }\\n    int getMinSwaps(string num, int k) {\\n        int count=0;\\n        string next=num;\\n        //next permutation of given number\\n        while(k--){\\n            nextPermutation(next);\\n        }\\n        //i points to num and next\\n        //k is used to find the mismatched character in next\\n        //num:  0 5 9\\n        //next: 9 5 0(k)\\n        for(int i=0;i<num.size();i++){\\n            if(num[i]!=next[i]){\\n                int k=i+1;\\n                while(next[k]!=num[i])  k++;\\n                while(k>i){\\n                    swap(next,k,k-1);\\n                    count++;\\n                    k--;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n//0 5 9\\n//0 9 5\\n//5 0 9\\n//5 9 0\\n//9 0 5\\n//9 5 0  --ans: 3\\n\\n//0 0 1 2 3\\n//0 0 1 3 2  --ans: 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885034,
                "title": "solution-using-next-permutation-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n      string temp  = num;\\n      int count  = 0;\\n      while( count != k )\\n      {\\n          int ind = -1;\\n          int n = num.size();\\n          for( int i = n-1; i >=0; i-- )\\n          {\\n            if( num[i] < num[i+1] )\\n            {\\n                ind = i;\\n                break;\\n            }\\n          }\\n          if( ind == -1)  reverse( num.begin(), num.end());\\n          for( int i = n-1; i>=ind; i-- )\\n          {\\n              if( num[i] > num[ind] )\\n              {\\n                  swap( num[i],num[ind] );\\n                  break;\\n              }\\n          }\\n          reverse( num.begin()+ind+1, num.end());\\n          count++;\\n      } \\n      for ( int i = 0; i<num.size(); i++ )\\n      {\\n          cout<<num[i];\\n      }\\n      \\n      int ans = 0;\\n      for( int i = 0; i < num.size(); i++ )\\n      {\\n          if(num[i] != temp[i])\\n          {\\n              int j = i+1;\\n              while( num[j] != temp[i] ) j++;\\n              while( j>i )\\n              {\\n                  swap( num[j],num[j-1] );\\n                  ans++;\\n                  j--;\\n              }\\n          }\\n      }\\n     return ans;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n      string temp  = num;\\n      int count  = 0;\\n      while( count != k )\\n      {\\n          int ind = -1;\\n          int n = num.size();\\n          for( int i = n-1; i >=0; i-- )\\n          {\\n            if( num[i] < num[i+1] )\\n            {\\n                ind = i;\\n                break;\\n            }\\n          }\\n          if( ind == -1)  reverse( num.begin(), num.end());\\n          for( int i = n-1; i>=ind; i-- )\\n          {\\n              if( num[i] > num[ind] )\\n              {\\n                  swap( num[i],num[ind] );\\n                  break;\\n              }\\n          }\\n          reverse( num.begin()+ind+1, num.end());\\n          count++;\\n      } \\n      for ( int i = 0; i<num.size(); i++ )\\n      {\\n          cout<<num[i];\\n      }\\n      \\n      int ans = 0;\\n      for( int i = 0; i < num.size(); i++ )\\n      {\\n          if(num[i] != temp[i])\\n          {\\n              int j = i+1;\\n              while( num[j] != temp[i] ) j++;\\n              while( j>i )\\n              {\\n                  swap( num[j],num[j-1] );\\n                  ans++;\\n                  j--;\\n              }\\n          }\\n      }\\n     return ans;  \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3863684,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string temp = num;\\n        while(k>0){\\n            k--;\\n            next_permutation(num.begin(),num.end());\\n        }\\n        int res = 0;\\n        for(int i = 0; i<num.size(); i++){\\n            if(num[i]!=temp[i]){\\n                int j = i+1;\\n                while(num[i]!=temp[j] and j<num.size()) j++;\\n                while(j>i){\\n                    swap(temp[j], temp[j-1]);\\n                    j--;\\n                    res++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string temp = num;\\n        while(k>0){\\n            k--;\\n            next_permutation(num.begin(),num.end());\\n        }\\n        int res = 0;\\n        for(int i = 0; i<num.size(); i++){\\n            if(num[i]!=temp[i]){\\n                int j = i+1;\\n                while(num[i]!=temp[j] and j<num.size()) j++;\\n                while(j>i){\\n                    swap(temp[j], temp[j-1]);\\n                    j--;\\n                    res++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3818894,
                "title": "my-solution",
                "content": "**1. Use the function `std::next_permutation`**\\n```\\n/**\\n * Time Complexity: O(n * (n + k))\\n * Space Complexity: O(n)\\n * where `n` is the length of the string `num`\\n */\\nclass Solution {\\n public:\\n  int getMinSwaps(const string &num, const int k) {\\n    string target(num);\\n    for (int i = 0; i < k; ++i) {\\n      next_permutation(target.begin(), target.end());\\n    }\\n    \\n    const int n = static_cast<int>(num.size());\\n    int ret = 0;\\n    string original(num);\\n    for (int i = 0; i < n; ++i) {\\n      int j = i;\\n      for (; j < n && target[i] != original[j]; ++j) {\\n      }\\n      \\n      ret += j - i;\\n      for (; j > i; --j) {\\n        swap(original[j], original[j - 1]);\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```\\n**2. Implement the function `std::next_permutation` manually**\\n```\\n/**\\n * Time Complexity: O(n * (n + k))\\n * Space Complexity: O(n)\\n * where `n` is the length of the string `num`\\n */\\nclass Solution {\\n public:\\n  int getMinSwaps(const string &num, const int k) {\\n    string target(num);\\n    for (int i = 0; i < k; ++i) {\\n      next_permutation(target);\\n    }\\n    \\n    const int n = static_cast<int>(num.size());\\n    int ret = 0;\\n    string original(num);\\n    for (int i = 0; i < n; ++i) {\\n      int j = i;\\n      for (; j < n && target[i] != original[j]; ++j) {\\n      }\\n      \\n      ret += j - i;\\n      for (; j > i; --j) {\\n        swap(original[j], original[j - 1]);\\n      }\\n    }\\n    return ret;\\n  }\\n  \\n private:\\n  void next_permutation(string &num) {\\n    const int n = static_cast<int>(num.size());\\n    int p = n - 2;\\n    for (; p > -1 && num[p] >= num[p + 1]; --p) {\\n    }\\n    int q = n - 1;\\n    for (; num[p] >= num[q]; --q) {\\n    }\\n    swap(num[p], num[q]);\\n    reverse(num.begin() + p + 1, num.end());\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n * (n + k))\\n * Space Complexity: O(n)\\n * where `n` is the length of the string `num`\\n */\\nclass Solution {\\n public:\\n  int getMinSwaps(const string &num, const int k) {\\n    string target(num);\\n    for (int i = 0; i < k; ++i) {\\n      next_permutation(target.begin(), target.end());\\n    }\\n    \\n    const int n = static_cast<int>(num.size());\\n    int ret = 0;\\n    string original(num);\\n    for (int i = 0; i < n; ++i) {\\n      int j = i;\\n      for (; j < n && target[i] != original[j]; ++j) {\\n      }\\n      \\n      ret += j - i;\\n      for (; j > i; --j) {\\n        swap(original[j], original[j - 1]);\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```\n```\\n/**\\n * Time Complexity: O(n * (n + k))\\n * Space Complexity: O(n)\\n * where `n` is the length of the string `num`\\n */\\nclass Solution {\\n public:\\n  int getMinSwaps(const string &num, const int k) {\\n    string target(num);\\n    for (int i = 0; i < k; ++i) {\\n      next_permutation(target);\\n    }\\n    \\n    const int n = static_cast<int>(num.size());\\n    int ret = 0;\\n    string original(num);\\n    for (int i = 0; i < n; ++i) {\\n      int j = i;\\n      for (; j < n && target[i] != original[j]; ++j) {\\n      }\\n      \\n      ret += j - i;\\n      for (; j > i; --j) {\\n        swap(original[j], original[j - 1]);\\n      }\\n    }\\n    return ret;\\n  }\\n  \\n private:\\n  void next_permutation(string &num) {\\n    const int n = static_cast<int>(num.size());\\n    int p = n - 2;\\n    for (; p > -1 && num[p] >= num[p + 1]; --p) {\\n    }\\n    int q = n - 1;\\n    for (; num[p] >= num[q]; --q) {\\n    }\\n    swap(num[p], num[q]);\\n    reverse(num.begin() + p + 1, num.end());\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783808,
                "title": "greedy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom bisect import bisect\\n\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n\\n        #Generate Kth smallest number\\n        arr = [*num]\\n        for _ in range(k):\\n            brr = [arr.pop()]\\n            while arr[-1] >= brr[-1]:\\n                brr.append(arr.pop())\\n            i = bisect(brr, arr[-1])\\n            arr[-1], brr[i] = brr[i], arr[-1]\\n            arr += brr\\n        \\n        #Calculate adjacent swaps\\n        count = 0\\n        for item in num:\\n            i = arr.index(item)\\n            count += i\\n            arr.pop(i)\\n\\n        return count\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Binary Search",
                    "Greedy"
                ],
                "code": "```\\nfrom bisect import bisect\\n\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n\\n        #Generate Kth smallest number\\n        arr = [*num]\\n        for _ in range(k):\\n            brr = [arr.pop()]\\n            while arr[-1] >= brr[-1]:\\n                brr.append(arr.pop())\\n            i = bisect(brr, arr[-1])\\n            arr[-1], brr[i] = brr[i], arr[-1]\\n            arr += brr\\n        \\n        #Calculate adjacent swaps\\n        count = 0\\n        for item in num:\\n            i = arr.index(item)\\n            count += i\\n            arr.pop(i)\\n\\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777773,
                "title": "next-permutation",
                "content": "**time: `O(N*(N+k))`; space: `O(N)`**\\n```\\nclass Solution\\n{\\n    bool nextPermutation(string& n)\\n    {\\n        int i(size(n)-1);\\n        for( ; i and n[i-1]>=n[i]; --i);\\n        if(auto j=i)\\n        {\\n            for( ; j<size(n) and n[j]>n[i-1]; ++j);\\n            swap(n[i-1], n[j-1]);\\n            reverse(begin(n)+i, end(n));\\n        }\\n        else return false;\\n        return true;\\n    }\\npublic:   \\n    int getMinSwaps(string n, int k)\\n    {\\n        auto N = n;\\n        for( ; k--; nextPermutation(n));\\n        int out{};\\n        for(int i{}; i<size(N); ++i)\\n        {   \\n            int j{i};\\n            for( ; j<size(n) and n[j]!=N[i]; ++j);\\n            for( ; i<j; swap(n[j-1], n[j]), --j, ++out);\\n        }\\n        return out;\\n    }\\n};\\n```\\n**Similar problems:**\\n[47. Permutations II](https://leetcode.com/problems/permutations-ii/discuss/3694713/next_permutation)\\n[31. Next Permutation](https://leetcode.com/problems/next-permutation/discuss/3415522/U-turn-(findswapreverse))\\n[1850. Minimum Adjacent Swaps to Reach the Kth Smallest Number](https://leetcode.com/problems/minimum-adjacent-swaps-to-reach-the-kth-smallest-number/discuss/3777773/next_permutation)\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\n    bool nextPermutation(string& n)\\n    {\\n        int i(size(n)-1);\\n        for( ; i and n[i-1]>=n[i]; --i);\\n        if(auto j=i)\\n        {\\n            for( ; j<size(n) and n[j]>n[i-1]; ++j);\\n            swap(n[i-1], n[j-1]);\\n            reverse(begin(n)+i, end(n));\\n        }\\n        else return false;\\n        return true;\\n    }\\npublic:   \\n    int getMinSwaps(string n, int k)\\n    {\\n        auto N = n;\\n        for( ; k--; nextPermutation(n));\\n        int out{};\\n        for(int i{}; i<size(N); ++i)\\n        {   \\n            int j{i};\\n            for( ; j<size(n) and n[j]!=N[i]; ++j);\\n            for( ; i<j; swap(n[j-1], n[j]), --j, ++out);\\n        }\\n        return out;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3756049,
                "title": "java-easy-to-understand-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    int n;\\n    public void nextPermutation(char[]arr){\\n        int i = n-2;\\n        while(i >= 0 && arr[i] >= arr[i + 1])\\n            i--;\\n        int j = n-1;\\n        if(i >= 0){\\n            while(j > i && arr[j] <= arr[i])\\n                j--;\\n            swap(arr,i,j);\\n        }\\n        reverse(arr,i+1,arr.length-1);\\n    }\\n\\n    void swap(char[]arr,int i,int j){\\n        char ch = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = ch;\\n    }\\n\\n    void reverse(char[]arr,int i,int j){\\n        while(i < j){\\n            swap(arr,i,j);\\n            i++;\\n            j--;\\n        }\\n    }\\n    public int getMinSwaps(String num, int k) {\\n        n = num.length();\\n        char[]arr = num.toCharArray();\\n        char[]res = num.toCharArray();\\n\\n        for(int i = 0;i < k;i++)\\n            nextPermutation(res);\\n        int count = 0;\\n        for(int i = 0;i < n;i++){\\n            int j = i;\\n            while(arr[j] != res[i])\\n                j++;\\n            while(j > i){\\n                swap(arr,j,j-1);\\n                j--;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int n;\\n    public void nextPermutation(char[]arr){\\n        int i = n-2;\\n        while(i >= 0 && arr[i] >= arr[i + 1])\\n            i--;\\n        int j = n-1;\\n        if(i >= 0){\\n            while(j > i && arr[j] <= arr[i])\\n                j--;\\n            swap(arr,i,j);\\n        }\\n        reverse(arr,i+1,arr.length-1);\\n    }\\n\\n    void swap(char[]arr,int i,int j){\\n        char ch = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = ch;\\n    }\\n\\n    void reverse(char[]arr,int i,int j){\\n        while(i < j){\\n            swap(arr,i,j);\\n            i++;\\n            j--;\\n        }\\n    }\\n    public int getMinSwaps(String num, int k) {\\n        n = num.length();\\n        char[]arr = num.toCharArray();\\n        char[]res = num.toCharArray();\\n\\n        for(int i = 0;i < k;i++)\\n            nextPermutation(res);\\n        int count = 0;\\n        for(int i = 0;i < n;i++){\\n            int j = i;\\n            while(arr[j] != res[i])\\n                j++;\\n            while(j > i){\\n                swap(arr,j,j-1);\\n                j--;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3719877,
                "title": "java-soln-using-next-permutation",
                "content": "```\\nclass Solution {\\n    public int getMinSwaps(String num, int k) {\\n        int len = num.length();\\n        int[] nums = new int[len];\\n        int[] original = new int[len];\\n        \\n        int idx = 0;\\n        for(char c : num.toCharArray()) {\\n            int digit = (int) (c - \\'0\\');\\n            nums[idx] = digit;\\n            original[idx] = digit;\\n            idx++;\\n        }\\n        \\n        while (k != 0) {\\n            nextPermutation(nums);\\n            k--;\\n        }\\n        \\n        int minSwaps = 0;\\n        \\n        for(int i = 0; i < len; i++) {\\n            if(nums[i] != original[i]) {\\n                int j = i + 1;\\n                while (j < len) {\\n                    if(original[j] == nums[i]) {\\n                        break;\\n                    }\\n                    j++;\\n                }\\n                \\n                while(j > 0 && j != i) {\\n                    swap(original, j, j - 1);\\n                    minSwaps++;\\n                    j--;\\n                }\\n            }\\n        }\\n        \\n        return minSwaps;\\n    }\\n    \\n    public void nextPermutation(int[] nums) {\\n        int i = nums.length - 2;\\n        while (i >= 0 && nums[i + 1] <= nums[i]) {\\n            i--;\\n        }\\n        if (i >= 0) {\\n            int j = nums.length - 1;\\n            while (nums[j] <= nums[i]) {\\n                j--;\\n            }\\n            swap(nums, i, j);\\n        }\\n        reverse(nums, i + 1);\\n    }\\n\\n    private void reverse(int[] nums, int start) {\\n        int i = start, j = nums.length - 1;\\n        while (i < j) {\\n            swap(nums, i, j);\\n            i++;\\n            j--;\\n        }\\n    }\\n\\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int getMinSwaps(String num, int k) {\\n        int len = num.length();\\n        int[] nums = new int[len];\\n        int[] original = new int[len];\\n        \\n        int idx = 0;\\n        for(char c : num.toCharArray()) {\\n            int digit = (int) (c - \\'0\\');\\n            nums[idx] = digit;\\n            original[idx] = digit;\\n            idx++;\\n        }\\n        \\n        while (k != 0) {\\n            nextPermutation(nums);\\n            k--;\\n        }\\n        \\n        int minSwaps = 0;\\n        \\n        for(int i = 0; i < len; i++) {\\n            if(nums[i] != original[i]) {\\n                int j = i + 1;\\n                while (j < len) {\\n                    if(original[j] == nums[i]) {\\n                        break;\\n                    }\\n                    j++;\\n                }\\n                \\n                while(j > 0 && j != i) {\\n                    swap(original, j, j - 1);\\n                    minSwaps++;\\n                    j--;\\n                }\\n            }\\n        }\\n        \\n        return minSwaps;\\n    }\\n    \\n    public void nextPermutation(int[] nums) {\\n        int i = nums.length - 2;\\n        while (i >= 0 && nums[i + 1] <= nums[i]) {\\n            i--;\\n        }\\n        if (i >= 0) {\\n            int j = nums.length - 1;\\n            while (nums[j] <= nums[i]) {\\n                j--;\\n            }\\n            swap(nums, i, j);\\n        }\\n        reverse(nums, i + 1);\\n    }\\n\\n    private void reverse(int[] nums, int start) {\\n        int i = start, j = nums.length - 1;\\n        while (i < j) {\\n            swap(nums, i, j);\\n            i++;\\n            j--;\\n        }\\n    }\\n\\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3627616,
                "title": "c-next-permutation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string s, int k) {\\n        string x=s;\\n        while(k--)  next_permutation(x.begin(),x.end());\\n        \\n        int cnt=0,j;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            j=i;\\n            while(s[j]!=x[i]){ j++; }\\n\\n            while(j>i){\\n            swap(s[j],s[j-1]);\\n            j--,cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string s, int k) {\\n        string x=s;\\n        while(k--)  next_permutation(x.begin(),x.end());\\n        \\n        int cnt=0,j;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            j=i;\\n            while(s[j]!=x[i]){ j++; }\\n\\n            while(j>i){\\n            swap(s[j],s[j-1]);\\n            j--,cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3622612,
                "title": "javascript-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar getMinSwaps = function(num, k) {\\n    const n = num.length;\\n    \\n    let swapDigs = num.split(\"\");\\n    \\n    for (let i = 0; i < k; ++i) {\\n        \\n        for (let j = n - 2; j >= 0; --j) {\\n            const currDig = swapDigs[j];\\n            const prevDig = swapDigs[j + 1];\\n            \\n            if (currDig < prevDig) {\\n                let right = n - 1;\\n                \\n                while (right > j && swapDigs[right] <= currDig) --right;  \\n                \\n                [swapDigs[j], swapDigs[right]] = [swapDigs[right], swapDigs[j]];\\n                swapDigs = flip(swapDigs, j + 1, n - 1);\\n                break;\\n            }\\n        }\\n    }\\n    \\n    const origDigs = num.split(\"\");\\n    \\n    let swaps = 0;\\n    \\n    for (let i = 0; i < n; ++i) {\\n        const dig1 = swapDigs[i];\\n        const dig2 = origDigs[i];\\n        \\n        if (dig2 != dig1) {\\n            let j = i + 1;\\n            \\n            while (j < n && origDigs[j] != dig1) j++;\\n            \\n            swaps += (j - i);\\n            origDigs.splice(j, 1);\\n            origDigs.splice(i, 0, dig1);\\n        }\\n    } \\n    \\n    return swaps;\\n    \\n    \\n    function flip(arr, left, right) {\\n        while (left < right) {\\n            [arr[left], arr[right]] = [arr[right], arr[left]];\\n            left++;\\n            right--;\\n        }\\n        \\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar getMinSwaps = function(num, k) {\\n    const n = num.length;\\n    \\n    let swapDigs = num.split(\"\");\\n    \\n    for (let i = 0; i < k; ++i) {\\n        \\n        for (let j = n - 2; j >= 0; --j) {\\n            const currDig = swapDigs[j];\\n            const prevDig = swapDigs[j + 1];\\n            \\n            if (currDig < prevDig) {\\n                let right = n - 1;\\n                \\n                while (right > j && swapDigs[right] <= currDig) --right;  \\n                \\n                [swapDigs[j], swapDigs[right]] = [swapDigs[right], swapDigs[j]];\\n                swapDigs = flip(swapDigs, j + 1, n - 1);\\n                break;\\n            }\\n        }\\n    }\\n    \\n    const origDigs = num.split(\"\");\\n    \\n    let swaps = 0;\\n    \\n    for (let i = 0; i < n; ++i) {\\n        const dig1 = swapDigs[i];\\n        const dig2 = origDigs[i];\\n        \\n        if (dig2 != dig1) {\\n            let j = i + 1;\\n            \\n            while (j < n && origDigs[j] != dig1) j++;\\n            \\n            swaps += (j - i);\\n            origDigs.splice(j, 1);\\n            origDigs.splice(i, 0, dig1);\\n        }\\n    } \\n    \\n    return swaps;\\n    \\n    \\n    function flip(arr, left, right) {\\n        while (left < right) {\\n            [arr[left], arr[right]] = [arr[right], arr[left]];\\n            left++;\\n            right--;\\n        }\\n        \\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3601884,
                "title": "without-using-next-permutation-inbuilt-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem is like a follow-up to the classic \"Next Permutation\" problem.\\nIf you haven\\'t solved \"Next Permutation\" yet, I would you recommend you to try it:\\n[https://leetcode.com/problems/next-permutation/]()\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAssuming you have followed the \"Next Permutation\" approach k times. We come to the swapping part.\\nIt is efficient to simply use the greedy swapping as our time complexity is not hindered by it and also it is very easy to implement.\\n\\nSimply, whenever you encounter mismatching elements in the two strings, keep a pointer at that element in string 2 and move a pointer on string 1 until you reach the string 2\\'s element in string 1. Then keep swapping the adjacent elements till the initial pointer\\'s position.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*k)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) to store a copy of the kth permutation of given number string.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minswaps(string s1, string s2)\\n    {\\n        int n=s1.size();\\n        int ctr=0;\\n        int i=0;\\n        while(i<n)\\n        {\\n            int j=i;\\n            if(s1[i]!=s2[i])\\n            {\\n                int j=i;\\n                while(s1[j]!=s2[i])\\n                    j++;\\n                while(j>i)\\n                {\\n                    swap(s1[j], s1[j-1]);\\n                    j--;\\n                    ctr++;\\n                }   \\n            }\\n            i++;\\n        }\\n\\n        return ctr;\\n    }\\n    int getMinSwaps(string num, int k) \\n    {\\n        string arr=num;\\n        int N=arr.size();\\n        while(k--)\\n        {\\n            int index=-1;\\n            for(int i=N-1; i>=1; i--)\\n            {\\n                if(arr[i]>arr[i-1])\\n                {\\n                    index=i-1;\\n                    break;\\n                }\\n            }\\n            \\n            if(index!=-1)\\n            {\\n                int p=index+1;\\n                for(int i=index+1; i<N; i++)\\n                {\\n                    if(arr[i]>arr[index])\\n                    {\\n                        if(arr[i]<arr[p])\\n                            p=i;\\n                    }\\n                }\\n                \\n                int t=arr[index];\\n                arr[index]=arr[p];\\n                arr[p]=t;\\n            }\\n            \\n            index++;\\n            sort(arr.begin()+index, arr.end());\\n        }\\n        \\n        return minswaps(num, arr);  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minswaps(string s1, string s2)\\n    {\\n        int n=s1.size();\\n        int ctr=0;\\n        int i=0;\\n        while(i<n)\\n        {\\n            int j=i;\\n            if(s1[i]!=s2[i])\\n            {\\n                int j=i;\\n                while(s1[j]!=s2[i])\\n                    j++;\\n                while(j>i)\\n                {\\n                    swap(s1[j], s1[j-1]);\\n                    j--;\\n                    ctr++;\\n                }   \\n            }\\n            i++;\\n        }\\n\\n        return ctr;\\n    }\\n    int getMinSwaps(string num, int k) \\n    {\\n        string arr=num;\\n        int N=arr.size();\\n        while(k--)\\n        {\\n            int index=-1;\\n            for(int i=N-1; i>=1; i--)\\n            {\\n                if(arr[i]>arr[i-1])\\n                {\\n                    index=i-1;\\n                    break;\\n                }\\n            }\\n            \\n            if(index!=-1)\\n            {\\n                int p=index+1;\\n                for(int i=index+1; i<N; i++)\\n                {\\n                    if(arr[i]>arr[index])\\n                    {\\n                        if(arr[i]<arr[p])\\n                            p=i;\\n                    }\\n                }\\n                \\n                int t=arr[index];\\n                arr[index]=arr[p];\\n                arr[p]=t;\\n            }\\n            \\n            index++;\\n            sort(arr.begin()+index, arr.end());\\n        }\\n        \\n        return minswaps(num, arr);  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3465665,
                "title": "simple-and-easy-solution-to-understand-c-solution-greedy",
                "content": "# Intuition\\n**Prerequiste** : **NEXT PERMUTATION**\\nhttps://leetcode.com/problems/next-permutation/\\nIf You Didn\\'t Solve Next Permutation Problem Solve It First.\\nIf We Carefully Observe The Example Explained In the description On Question ,The Next Smallest Beautiful String Is The Next Permutation Of The String . \\nSo For Kth Smallest String We Need To Find The Next  Kth permutaion Of Current String\\n# Approach\\nUsing kthperm Function Generating Next K Permutations After That And  Finding The Required Number Of Swaps Using Original String And permuted String In a Brute Force Manner.\\n# Complexity\\n- Time complexity:\\nO(K * N) - For Generating Permutations\\nO(N * N) - In Worst Case For Finding Number Of Swaps.\\nTotal : O(K * N + N * N) ===> O(N * N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     void reverse(string &arr,int i,int j)\\n     {\\n         while(i<j) swap(arr[i++],arr[j--]);\\n     }\\n     void kthperm(string &arr,int k,int n)\\n     {\\n         if(k==0) return;\\n         int ind=-1;\\n         for(int i=n-2;i>=0;i--)\\n         {\\n             if(arr[i+1]>arr[i])\\n             {\\n                 ind=i;\\n                 break;\\n             }\\n         }\\n             if(ind==-1)\\n             {\\n                 reverse(arr,0,n-1);\\n                 return;\\n             }\\n             for(int i=n-1;i>ind;i--)\\n             {\\n                 if(arr[i]>arr[ind])\\n                 {\\n                     swap(arr[i],arr[ind]);\\n                     break;\\n                 }\\n             }\\n             reverse(arr,ind+1,n-1);\\n             \\n             kthperm(arr,k-1,n);\\n             return;\\n         \\n     }\\n   \\n    int getMinSwaps(string num, int k) {\\n        string arr=\"\";\\n        int i=0,n=0;\\n        for(char &a:num)\\n        {\\n            arr+=a;\\n            n++;\\n        }  \\n        kthperm(arr,k,n);\\n        while(arr[i]==num[i]&&i<n) i++;\\n        int swaps=0,j;\\n        while(i<n)\\n        {\\n            j=i;\\n            while(arr[j]!=num[i]&&j<n) j++;\\n            while(j>i)\\n            {\\n                swap(arr[j],arr[j-1]);\\n                j--;\\n                swaps++;\\n            }\\n            if(arr==num) break;\\n            i++;\\n        }\\n         return swaps;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     void reverse(string &arr,int i,int j)\\n     {\\n         while(i<j) swap(arr[i++],arr[j--]);\\n     }\\n     void kthperm(string &arr,int k,int n)\\n     {\\n         if(k==0) return;\\n         int ind=-1;\\n         for(int i=n-2;i>=0;i--)\\n         {\\n             if(arr[i+1]>arr[i])\\n             {\\n                 ind=i;\\n                 break;\\n             }\\n         }\\n             if(ind==-1)\\n             {\\n                 reverse(arr,0,n-1);\\n                 return;\\n             }\\n             for(int i=n-1;i>ind;i--)\\n             {\\n                 if(arr[i]>arr[ind])\\n                 {\\n                     swap(arr[i],arr[ind]);\\n                     break;\\n                 }\\n             }\\n             reverse(arr,ind+1,n-1);\\n             \\n             kthperm(arr,k-1,n);\\n             return;\\n         \\n     }\\n   \\n    int getMinSwaps(string num, int k) {\\n        string arr=\"\";\\n        int i=0,n=0;\\n        for(char &a:num)\\n        {\\n            arr+=a;\\n            n++;\\n        }  \\n        kthperm(arr,k,n);\\n        while(arr[i]==num[i]&&i<n) i++;\\n        int swaps=0,j;\\n        while(i<n)\\n        {\\n            j=i;\\n            while(arr[j]!=num[i]&&j<n) j++;\\n            while(j>i)\\n            {\\n                swap(arr[j],arr[j-1]);\\n                j--;\\n                swaps++;\\n            }\\n            if(arr==num) break;\\n            i++;\\n        }\\n         return swaps;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450977,
                "title": "next-greater-value",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        def findGreatest(nums):\\n            nums = list(nums)\\n            # 1 find pivot\\n            pivot = None\\n            for i in range(len(nums) - 1, 0, -1):\\n                if nums[i] > nums[i - 1]:\\n                    pivot = i - 1\\n                    break\\n            # 2 swap with pivot if larger than pivot\\n            for i in range(len(nums) - 1, pivot, -1):\\n                if nums[i] > nums[pivot]:\\n                    nums[i], nums[pivot] = nums[pivot], nums[i]\\n                    break\\n            # 3 reverse nums after pivot\\n            nums[pivot +1: ] = nums[pivot +1: ][::-1]\\n            return \\'\\'.join(nums)\\n            \\n        origin = list(num[::])\\n        for i in range(k):\\n            num = findGreatest(num)\\n        # swap adjacent greedy\\n        ans, n = 0, len(num)\\n        for i in range(n):\\n            j = origin.index(num[i], i)\\n            ans += j - i\\n            origin[i:j+1] = [origin[j]] + origin[i:j]\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        def findGreatest(nums):\\n            nums = list(nums)\\n            # 1 find pivot\\n            pivot = None\\n            for i in range(len(nums) - 1, 0, -1):\\n                if nums[i] > nums[i - 1]:\\n                    pivot = i - 1\\n                    break\\n            # 2 swap with pivot if larger than pivot\\n            for i in range(len(nums) - 1, pivot, -1):\\n                if nums[i] > nums[pivot]:\\n                    nums[i], nums[pivot] = nums[pivot], nums[i]\\n                    break\\n            # 3 reverse nums after pivot\\n            nums[pivot +1: ] = nums[pivot +1: ][::-1]\\n            return \\'\\'.join(nums)\\n            \\n        origin = list(num[::])\\n        for i in range(k):\\n            num = findGreatest(num)\\n        # swap adjacent greedy\\n        ans, n = 0, len(num)\\n        for i in range(n):\\n            j = origin.index(num[i], i)\\n            ans += j - i\\n            origin[i:j+1] = [origin[j]] + origin[i:j]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3443596,
                "title": "simple-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int getMinSwaps(String num, int k) {\\n        char c[]=num.toCharArray();\\n        int count=0;\\n        while(count<k)\\n        {\\n           ArrayList<Character> l=new ArrayList<Character>();\\n           HashMap<Character,Integer> h=new HashMap<Character,Integer>();\\n            h.put(c[c.length-1],c.length-1);\\n            l.add(c[c.length-1]);\\n            int index=0;\\n            for(int i=c.length-2;i>=0;i--)\\n            {\\n                if(!h.containsKey(c[i]))\\n                {\\n                    h.put(c[i],i);\\n                    if(l.size()==1)\\n                    {\\n                        if(l.get(0)>c[i])\\n                        {\\n                            l.add(0,c[i]);\\n                            index=0;\\n                        }\\n                        else\\n                        {\\n                            l.add(c[i]);\\n                            index=1;\\n                        }\\n                    }\\n                    else\\n                    {\\n                        int low=0,high=l.size()-1;\\n                        while(low<=high)\\n                        {\\n                            int mid=(low+high)/2;\\n                            if(l.get(mid)<c[i])\\n                            {\\n                                index=mid+1;\\n                                low=mid+1;\\n                            }\\n                            else\\n                            {\\n                                index=mid;\\n                                high=mid-1;\\n                            }\\n                        }\\n                        l.add(index,c[i]);\\n                    }\\n                    \\n                }\\n                if(c[i]<c[i+1])\\n                {\\n                    int currentElementIndex=l.indexOf(c[i]); // in ArrayList l\\n                    char nextGreaterElement=l.get(currentElementIndex+1);\\n                    int nextGreaterElement_Index=h.get(nextGreaterElement);\\n                    char temp=c[i];\\n                    c[i]=c[nextGreaterElement_Index];\\n                    c[nextGreaterElement_Index]=temp;\\n                    Arrays.sort(c,i+1,c.length);\\n                    break;\\n                }\\n            }\\n            count++;\\n        }\\n        ArrayList<Character> l=new ArrayList<Character>();\\n        for(int i=0;i<c.length;i++)\\n        {\\n            l.add(c[i]);\\n        }\\n        char ch[]=num.toCharArray();\\n        int result=0;\\n        for(int i=0;i<ch.length;i++)\\n        {\\n            if(ch[i]!=l.get(i))\\n            {\\n                int r=-1;\\n               for(int j=i+1;j<c.length;j++)\\n               {\\n                   if(l.get(j)==ch[i])\\n                   {\\n                        r=j;\\n                        break;\\n                   }\\n               }\\n               result+=(r-i);\\n               l.remove(r);\\n               l.add(i,ch[i]);\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinSwaps(String num, int k) {\\n        char c[]=num.toCharArray();\\n        int count=0;\\n        while(count<k)\\n        {\\n           ArrayList<Character> l=new ArrayList<Character>();\\n           HashMap<Character,Integer> h=new HashMap<Character,Integer>();\\n            h.put(c[c.length-1],c.length-1);\\n            l.add(c[c.length-1]);\\n            int index=0;\\n            for(int i=c.length-2;i>=0;i--)\\n            {\\n                if(!h.containsKey(c[i]))\\n                {\\n                    h.put(c[i],i);\\n                    if(l.size()==1)\\n                    {\\n                        if(l.get(0)>c[i])\\n                        {\\n                            l.add(0,c[i]);\\n                            index=0;\\n                        }\\n                        else\\n                        {\\n                            l.add(c[i]);\\n                            index=1;\\n                        }\\n                    }\\n                    else\\n                    {\\n                        int low=0,high=l.size()-1;\\n                        while(low<=high)\\n                        {\\n                            int mid=(low+high)/2;\\n                            if(l.get(mid)<c[i])\\n                            {\\n                                index=mid+1;\\n                                low=mid+1;\\n                            }\\n                            else\\n                            {\\n                                index=mid;\\n                                high=mid-1;\\n                            }\\n                        }\\n                        l.add(index,c[i]);\\n                    }\\n                    \\n                }\\n                if(c[i]<c[i+1])\\n                {\\n                    int currentElementIndex=l.indexOf(c[i]); // in ArrayList l\\n                    char nextGreaterElement=l.get(currentElementIndex+1);\\n                    int nextGreaterElement_Index=h.get(nextGreaterElement);\\n                    char temp=c[i];\\n                    c[i]=c[nextGreaterElement_Index];\\n                    c[nextGreaterElement_Index]=temp;\\n                    Arrays.sort(c,i+1,c.length);\\n                    break;\\n                }\\n            }\\n            count++;\\n        }\\n        ArrayList<Character> l=new ArrayList<Character>();\\n        for(int i=0;i<c.length;i++)\\n        {\\n            l.add(c[i]);\\n        }\\n        char ch[]=num.toCharArray();\\n        int result=0;\\n        for(int i=0;i<ch.length;i++)\\n        {\\n            if(ch[i]!=l.get(i))\\n            {\\n                int r=-1;\\n               for(int j=i+1;j<c.length;j++)\\n               {\\n                   if(l.get(j)==ch[i])\\n                   {\\n                        r=j;\\n                        break;\\n                   }\\n               }\\n               result+=(r-i);\\n               l.remove(r);\\n               l.add(i,ch[i]);\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432614,
                "title": "java-next-permutation-of-c-implementation",
                "content": "# Code\\n```\\nclass Solution {\\n    public int getMinSwaps(String num, int k) {\\n        char[] a = num.toCharArray();\\n        int res = 0;\\n        while (k-- > 0)\\n            next(a);\\n        char[] b = num.toCharArray();\\n        for (int i = 0; i < a.length; i++) {\\n            int j = i;\\n            while (b[j] != a[i]) j++;\\n            while (j > i) {\\n                swap(b, j, j - 1);\\n                j--;\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n\\n    void next(char[] a) {\\n        int i = a.length - 2;\\n        while (i >= 0 && a[i] >= a[i + 1]) i--;\\n        if (i >= 0) {\\n            int j = a.length - 1;\\n            while (a[j] <= a[i]) j--;\\n            swap(a, i, j);\\n        }\\n        reverse(a, i + 1, a.length - 1);\\n    }\\n\\n    void swap(char[] a, int i, int j) {\\n        char t = a[i];\\n        a[i] = a[j];\\n        a[j] = t;\\n    }\\n\\n    void reverse(char[] a, int i, int j) {\\n        while (i < j) {\\n            swap(a, i, j);\\n            i++;\\n            j--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinSwaps(String num, int k) {\\n        char[] a = num.toCharArray();\\n        int res = 0;\\n        while (k-- > 0)\\n            next(a);\\n        char[] b = num.toCharArray();\\n        for (int i = 0; i < a.length; i++) {\\n            int j = i;\\n            while (b[j] != a[i]) j++;\\n            while (j > i) {\\n                swap(b, j, j - 1);\\n                j--;\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n\\n    void next(char[] a) {\\n        int i = a.length - 2;\\n        while (i >= 0 && a[i] >= a[i + 1]) i--;\\n        if (i >= 0) {\\n            int j = a.length - 1;\\n            while (a[j] <= a[i]) j--;\\n            swap(a, i, j);\\n        }\\n        reverse(a, i + 1, a.length - 1);\\n    }\\n\\n    void swap(char[] a, int i, int j) {\\n        char t = a[i];\\n        a[i] = a[j];\\n        a[j] = t;\\n    }\\n\\n    void reverse(char[] a, int i, int j) {\\n        while (i < j) {\\n            swap(a, i, j);\\n            i++;\\n            j--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3414796,
                "title": "c-two-pointer",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string copy = num;\\n        while (k-- > 0) next_permutation(copy.begin(), copy.end());\\n        int ans = 0;\\n        for (int f = 0, s = 0; f < num.size(); ++f){\\n            while (copy[s] == \\'#\\') ++s;\\n            if (num[f] != copy[s]){\\n                int dif = 1, ind = s;\\n                while (copy[++ind] != num[f]) dif += copy[ind] != \\'#\\';\\n                ans += dif;\\n                copy[ind] = \\'#\\';\\n            }\\n            else ++s;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string copy = num;\\n        while (k-- > 0) next_permutation(copy.begin(), copy.end());\\n        int ans = 0;\\n        for (int f = 0, s = 0; f < num.size(); ++f){\\n            while (copy[s] == \\'#\\') ++s;\\n            if (num[f] != copy[s]){\\n                int dif = 1, ind = s;\\n                while (copy[++ind] != num[f]) dif += copy[ind] != \\'#\\';\\n                ans += dif;\\n                copy[ind] = \\'#\\';\\n            }\\n            else ++s;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3394818,
                "title": "two-pointer-swaping",
                "content": "# Intuition\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n\\n        string s=num;\\n        int c=0;\\n        \\n        for(int i=0;i<k;i++)\\n            next_permutation(num.begin(),num.end());\\n\\n        for(int i=0;i<num.size();i++)\\n        {\\n            if(s[i]!=num[i])\\n            {\\n                int j=i+1;\\n\\n                while(num[j] != s[i]) \\n                j++;\\n               \\n               while(j > i)\\n               {\\n                   swap(num[j], num[j-1]);\\n                   c++;\\n                   j--;\\n               }\\n            }\\n        }\\n\\n        return c;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n\\n        string s=num;\\n        int c=0;\\n        \\n        for(int i=0;i<k;i++)\\n            next_permutation(num.begin(),num.end());\\n\\n        for(int i=0;i<num.size();i++)\\n        {\\n            if(s[i]!=num[i])\\n            {\\n                int j=i+1;\\n\\n                while(num[j] != s[i]) \\n                j++;\\n               \\n               while(j > i)\\n               {\\n                   swap(num[j], num[j-1]);\\n                   c++;\\n                   j--;\\n               }\\n            }\\n        }\\n\\n        return c;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3301884,
                "title": "next-permutation-with-binary-search",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int getMinSwaps(String num, int k) {\\n        int[] nums = new int[num.length()];\\n        int[] original = new int[num.length()];\\n        int index = 0;\\n\\n        for (char ch : num.toCharArray()) {\\n            nums[index] = ch - \\'0\\';\\n            original[index++] = ch - \\'0\\';\\n        }\\n\\n        while (k-- > 0) {\\n            nextPermutation(nums);\\n        }\\n        int ans = 0;\\n\\n        for (int i = 0; i < num.length(); i++) {\\n            // Meaning swap happened    \\n            if (nums[i] != original[i]) {\\n                int anchor = i;\\n                \\n                while (nums[anchor] != original[i]) {\\n                    anchor++;\\n                }\\n                while (anchor > i) {\\n                    swap(nums, anchor, anchor - 1);\\n                    ans++;\\n                    anchor--;\\n                }       \\n            }\\n        }\\n        return ans;\\n    }\\n    // next greater permutation\\n    private void nextPermutation(int[] arr) {\\n        int index = arr.length - 2;\\n\\n        while (index >= 0 && arr[index] >= arr[index + 1]) {\\n            index--;\\n        }\\n        int justGreaterThanEqualToIndex = binarySearchJustGreaterThanEqualTo(arr, index + 1, arr[index]);\\n        swap(arr, index, justGreaterThanEqualToIndex);\\n        reverse(arr, index + 1);\\n    }\\n\\n    private int binarySearchJustGreaterThanEqualTo(int[] arr, int index, int target) {\\n        int lo = index;\\n        int hi = arr.length - 1;\\n        int ans = index;\\n\\n        while (lo <= hi) {\\n            int pivot = lo + (hi - lo) / 2;\\n\\n            if(arr[pivot] > target) {\\n                ans = pivot;\\n                lo = pivot + 1;\\n            } else {\\n                hi = pivot - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private void swap(int[] arr, int x, int y) {\\n        int temp = arr[x];\\n        arr[x] = arr[y];\\n        arr[y] = temp;\\n    }\\n\\n    private void reverse(int[] arr, int index) {\\n        int eIndex = arr.length - 1;\\n\\n        while (index < eIndex) {\\n            swap(arr, index++, eIndex--);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinSwaps(String num, int k) {\\n        int[] nums = new int[num.length()];\\n        int[] original = new int[num.length()];\\n        int index = 0;\\n\\n        for (char ch : num.toCharArray()) {\\n            nums[index] = ch - \\'0\\';\\n            original[index++] = ch - \\'0\\';\\n        }\\n\\n        while (k-- > 0) {\\n            nextPermutation(nums);\\n        }\\n        int ans = 0;\\n\\n        for (int i = 0; i < num.length(); i++) {\\n            // Meaning swap happened    \\n            if (nums[i] != original[i]) {\\n                int anchor = i;\\n                \\n                while (nums[anchor] != original[i]) {\\n                    anchor++;\\n                }\\n                while (anchor > i) {\\n                    swap(nums, anchor, anchor - 1);\\n                    ans++;\\n                    anchor--;\\n                }       \\n            }\\n        }\\n        return ans;\\n    }\\n    // next greater permutation\\n    private void nextPermutation(int[] arr) {\\n        int index = arr.length - 2;\\n\\n        while (index >= 0 && arr[index] >= arr[index + 1]) {\\n            index--;\\n        }\\n        int justGreaterThanEqualToIndex = binarySearchJustGreaterThanEqualTo(arr, index + 1, arr[index]);\\n        swap(arr, index, justGreaterThanEqualToIndex);\\n        reverse(arr, index + 1);\\n    }\\n\\n    private int binarySearchJustGreaterThanEqualTo(int[] arr, int index, int target) {\\n        int lo = index;\\n        int hi = arr.length - 1;\\n        int ans = index;\\n\\n        while (lo <= hi) {\\n            int pivot = lo + (hi - lo) / 2;\\n\\n            if(arr[pivot] > target) {\\n                ans = pivot;\\n                lo = pivot + 1;\\n            } else {\\n                hi = pivot - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private void swap(int[] arr, int x, int y) {\\n        int temp = arr[x];\\n        arr[x] = arr[y];\\n        arr[y] = temp;\\n    }\\n\\n    private void reverse(int[] arr, int index) {\\n        int eIndex = arr.length - 1;\\n\\n        while (index < eIndex) {\\n            swap(arr, index++, eIndex--);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3299912,
                "title": "c-simple-stl-next-permutation",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        \\n         string s = num;\\n        int ans=0;\\n        \\n        while(k--) {\\n            next_permutation(num.begin(), num.end());\\n        }\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]!=num[i])\\n            {\\n                int a=0;\\n                int j;\\n                for( j=i+1;j<s.length();j++)\\n                {\\n                    if(num[i]==s[j])\\n                    {\\n                     break;\\n                    }\\n                        \\n                }\\n                ans+=j-i;\\n                \\n                while(j-1>=i)\\n                {\\n                    swap(s[j],s[j-1]);\\n                    j--;\\n                }\\n                \\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        \\n         string s = num;\\n        int ans=0;\\n        \\n        while(k--) {\\n            next_permutation(num.begin(), num.end());\\n        }\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]!=num[i])\\n            {\\n                int a=0;\\n                int j;\\n                for( j=i+1;j<s.length();j++)\\n                {\\n                    if(num[i]==s[j])\\n                    {\\n                     break;\\n                    }\\n                        \\n                }\\n                ans+=j-i;\\n                \\n                while(j-1>=i)\\n                {\\n                    swap(s[j],s[j-1]);\\n                    j--;\\n                }\\n                \\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3277952,
                "title": "c-simple-solution-with-comments",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string s = num;\\n        //finding kth smallest number that is kth next permutation(next permutation is the next largest number)\\n        while(k--){\\n            next_permutation(s.begin(), s.end()); //finding \\n        }\\n        int minSwaps = 0; //for counting the number of swaps\\n        //traversing in the nums\\n        for(int i = 0; i<num.size(); i++){\\n            if(num[i]!= s[i]){ //if the digits of new string are not in their actual position, we need to find their position in the original array.\\n                int j = i+1; //for finding the index of the current digit of s in the right of the nums\\n                while(num[j]!=s[i])j++; //we will keep incrementing j until we find it\\'s actual position.\\n                //as soon as we find the actual position we need to swap them\\n                \\n                while(j>i){\\n                    swap(num[j], num[j-1]);\\n                    j--;\\n                    minSwaps++;\\n                    \\n                }\\n            }\\n        }\\n        return minSwaps;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string s = num;\\n        //finding kth smallest number that is kth next permutation(next permutation is the next largest number)\\n        while(k--){\\n            next_permutation(s.begin(), s.end()); //finding \\n        }\\n        int minSwaps = 0; //for counting the number of swaps\\n        //traversing in the nums\\n        for(int i = 0; i<num.size(); i++){\\n            if(num[i]!= s[i]){ //if the digits of new string are not in their actual position, we need to find their position in the original array.\\n                int j = i+1; //for finding the index of the current digit of s in the right of the nums\\n                while(num[j]!=s[i])j++; //we will keep incrementing j until we find it\\'s actual position.\\n                //as soon as we find the actual position we need to swap them\\n                \\n                while(j>i){\\n                    swap(num[j], num[j-1]);\\n                    j--;\\n                    minSwaps++;\\n                    \\n                }\\n            }\\n        }\\n        return minSwaps;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3276492,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func getMinSwaps(_ num: String, _ k: Int) -> Int {\\n\\n        func wond(_ num: String = num, _ k: Int = k) -> String {\\n\\n            guard k != 0 else { return num }\\n\\n            var n = num.index(before: num.endIndex)\\n            var p = num.index(before: n)\\n\\n            while num[p] >= num[n] {\\n                n = p\\n                p = num.index(before: p)\\n            }\\n\\n            let ch = num[p...].sorted()\\n            let fi = ch.firstIndex(where: { $0 > num[p] })!\\n\\n            var rep = ch\\n            rep.remove(at: fi)\\n            rep.insert(ch[fi], at: 0)\\n\\n            return wond(num[..<p] + String(rep), k - 1)\\n        }\\n\\n        let target = wond()\\n        let d = target.indices.first(where: { target[$0] != num[$0] })!\\n\\n        var suf1 = num[d...].map { $0 }\\n        var suf2 = target[d...].map { $0 }\\n\\n        var res = 0\\n\\n        while suf1 != suf2 {\\n            let i = suf1.indices.first(where: { suf1[$0] != suf2[$0] })!\\n\\n            suf1.removeFirst(i)\\n            suf2.removeFirst(i)\\n\\n            let j = suf1.firstIndex(of: suf2[0])!\\n\\n            suf1.remove(at: j)\\n            suf1.insert(suf2[0], at: 0)\\n\\n            res += j\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func getMinSwaps(_ num: String, _ k: Int) -> Int {\\n\\n        func wond(_ num: String = num, _ k: Int = k) -> String {\\n\\n            guard k != 0 else { return num }\\n\\n            var n = num.index(before: num.endIndex)\\n            var p = num.index(before: n)\\n\\n            while num[p] >= num[n] {\\n                n = p\\n                p = num.index(before: p)\\n            }\\n\\n            let ch = num[p...].sorted()\\n            let fi = ch.firstIndex(where: { $0 > num[p] })!\\n\\n            var rep = ch\\n            rep.remove(at: fi)\\n            rep.insert(ch[fi], at: 0)\\n\\n            return wond(num[..<p] + String(rep), k - 1)\\n        }\\n\\n        let target = wond()\\n        let d = target.indices.first(where: { target[$0] != num[$0] })!\\n\\n        var suf1 = num[d...].map { $0 }\\n        var suf2 = target[d...].map { $0 }\\n\\n        var res = 0\\n\\n        while suf1 != suf2 {\\n            let i = suf1.indices.first(where: { suf1[$0] != suf2[$0] })!\\n\\n            suf1.removeFirst(i)\\n            suf2.removeFirst(i)\\n\\n            let j = suf1.firstIndex(of: suf2[0])!\\n\\n            suf1.remove(at: j)\\n            suf1.insert(suf2[0], at: 0)\\n\\n            res += j\\n        }\\n\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3263173,
                "title": "using-next-permutation",
                "content": "# First use next_permutation function to find the kth smallest string.\\n# After that traverse in both the string and count the no of swaps of adjacent characters.\\n```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        int n=num.length(), i=0;\\n        string target(num);\\n        while(next_permutation(target.begin(),target.end()) && i!=k-1){\\n            i++;\\n        }\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            if(num[i]!=target[i]){\\n                int j=i+1;\\n                while(num[j]!=target[i]){\\n                    j++;\\n                }\\n                for(;j>i;--j){\\n                    swap(num[j],num[j-1]);\\n                    count++;\\n                }\\n            }\\n        } \\n        return count;   \\n    }\\n};\\n```\\n# Upvote GUYs",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        int n=num.length(), i=0;\\n        string target(num);\\n        while(next_permutation(target.begin(),target.end()) && i!=k-1){\\n            i++;\\n        }\\n        int count=0;\\n        for(int i=0;i<n;i++){\\n            if(num[i]!=target[i]){\\n                int j=i+1;\\n                while(num[j]!=target[i]){\\n                    j++;\\n                }\\n                for(;j>i;--j){\\n                    swap(num[j],num[j-1]);\\n                    count++;\\n                }\\n            }\\n        } \\n        return count;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3245050,
                "title": "c-easy-code",
                "content": "\\n\\nclass Solution {\\npublic:\\n    int getMinSwaps(string s, int k) {\\n        string t=s;\\n        while(k--) next_permutation(begin(s), end(s));\\n        int ans=0;\\n        for(int i=0; i<s.size(); i++) {\\n            if(s[i]==t[i]) continue;\\n\\n            for(int j=t.find(s[i],i); j>i; j--) {\\n                swap(t[j],t[j-1]);\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int getMinSwaps(string s, int k) {\\n        string t=s;\\n        while(k--) next_permutation(begin(s), end(s));\\n        int ans=0;\\n        for(int i=0; i<s.size(); i++) {\\n            if(s[i]==t[i]) continue;\\n\\n            for(int j=t.find(s[i],i); j>i; j--) {\\n                swap(t[j],t[j-1]);\\n                ans++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3225946,
                "title": "c-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string s, int k) {\\n        auto t = s;\\n        while(k--) next_permutation(begin(t), end(t));\\n        int res = 0;\\n        for(int i = 0;i<s.size();i++){\\n            if(s[i] == t[i]) continue;\\n            for(int j = t.find(s[i], i); j>i; j--){\\n                swap(t[j], t[j-1]);\\n                res++;\\n            }            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string s, int k) {\\n        auto t = s;\\n        while(k--) next_permutation(begin(t), end(t));\\n        int res = 0;\\n        for(int i = 0;i<s.size();i++){\\n            if(s[i] == t[i]) continue;\\n            for(int j = t.find(s[i], i); j>i; j--){\\n                swap(t[j], t[j-1]);\\n                res++;\\n            }            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3221108,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn get_min_swaps(num: String, k: i32) -> i32 {\\n        fn nxt_perm(num: &[char]) -> Vec<char> {\\n            let mut num = num.to_vec();\\n            let n = num.len() as i32;\\n            let mut i = n - 1;\\n            while i > 0 && num[(i - 1) as usize] >= num[i as usize] {\\n                i -= 1;\\n            }\\n            let mut j = i;\\n            while j < n && num[(i - 1) as usize] < num[j as usize] {\\n                j += 1;\\n            }\\n            num.swap((i - 1) as usize, (j - 1) as usize);\\n            num[i as usize..].reverse();\\n            num\\n        }\\n\\n        let mut nxt_k_num = num.chars().collect::<Vec<char>>();\\n        let n = nxt_k_num.len();\\n        for _ in 0..k {\\n            nxt_k_num = nxt_perm(&nxt_k_num);\\n        }\\n        let mut ans = 0;\\n        let mut num = num.chars().collect::<Vec<char>>();\\n        for i in 0..n {\\n            let mut j = i;\\n            while j < n && nxt_k_num[i] != num[j] {\\n                j += 1;\\n            }\\n            ans += (j - i) as i32;\\n            num[i..=j].rotate_right(1);\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn get_min_swaps(num: String, k: i32) -> i32 {\\n        fn nxt_perm(num: &[char]) -> Vec<char> {\\n            let mut num = num.to_vec();\\n            let n = num.len() as i32;\\n            let mut i = n - 1;\\n            while i > 0 && num[(i - 1) as usize] >= num[i as usize] {\\n                i -= 1;\\n            }\\n            let mut j = i;\\n            while j < n && num[(i - 1) as usize] < num[j as usize] {\\n                j += 1;\\n            }\\n            num.swap((i - 1) as usize, (j - 1) as usize);\\n            num[i as usize..].reverse();\\n            num\\n        }\\n\\n        let mut nxt_k_num = num.chars().collect::<Vec<char>>();\\n        let n = nxt_k_num.len();\\n        for _ in 0..k {\\n            nxt_k_num = nxt_perm(&nxt_k_num);\\n        }\\n        let mut ans = 0;\\n        let mut num = num.chars().collect::<Vec<char>>();\\n        for i in 0..n {\\n            let mut j = i;\\n            while j < n && nxt_k_num[i] != num[j] {\\n                j += 1;\\n            }\\n            ans += (j - i) as i32;\\n            num[i..=j].rotate_right(1);\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3137229,
                "title": "easiest-solution-c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string s = num;\\n        int ans = 0;\\n        do{\\n            k--;\\n            next_permutation(num.begin(),num.end());\\n        }while(k );\\n        for(int i=0;i<num.length();i++){\\n            if(num[i]!=s[i]){\\n                int j = i + 1;\\n                while(num[j] != s[i]) j++;\\n                while(j>i){\\n                    swap(num[j], num[j-1]);\\n                    ans++;\\n                    j--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string s = num;\\n        int ans = 0;\\n        do{\\n            k--;\\n            next_permutation(num.begin(),num.end());\\n        }while(k );\\n        for(int i=0;i<num.length();i++){\\n            if(num[i]!=s[i]){\\n                int j = i + 1;\\n                while(num[j] != s[i]) j++;\\n                while(j>i){\\n                    swap(num[j], num[j-1]);\\n                    ans++;\\n                    j--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3102791,
                "title": "golang-greedy",
                "content": "# Code\\n```\\nfunc min_step(original string, num []byte) int {\\n    var ans int = 0\\n    var n int = len(original)\\n    for i := 0; i < n; i++ {\\n        j := i\\n        for num[j] != original[i] {j++}\\n        for i < j {\\n            num[j], num[j - 1] = num[j - 1], num[j]\\n            j--\\n            ans++\\n        }\\n    }\\n    return ans\\n}\\nfunc getMinSwaps(original string, k int) int {\\n    num := []byte(original)\\n    fmt.Println(num)\\n    var i, j int\\n    var n int = len(num)\\n    for ;k > 0; k-- {\\n        for i = n - 2; i >= 0; i-- {\\n            if num[i] < num[i + 1] {break}\\n        }\\n        for j = n - 1; j > i; j-- {\\n            if num[j] > num[i] {break}\\n        }\\n        num[i], num[j] = num[j], num[i]\\n        for p, q := i + 1, n - 1; p < q; p, q = p + 1, q - 1 {\\n            num[p], num[q] = num[q], num[p]\\n        }\\n    }\\n    return min_step(original, num)\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Two Pointers",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nfunc min_step(original string, num []byte) int {\\n    var ans int = 0\\n    var n int = len(original)\\n    for i := 0; i < n; i++ {\\n        j := i\\n        for num[j] != original[i] {j++}\\n        for i < j {\\n            num[j], num[j - 1] = num[j - 1], num[j]\\n            j--\\n            ans++\\n        }\\n    }\\n    return ans\\n}\\nfunc getMinSwaps(original string, k int) int {\\n    num := []byte(original)\\n    fmt.Println(num)\\n    var i, j int\\n    var n int = len(num)\\n    for ;k > 0; k-- {\\n        for i = n - 2; i >= 0; i-- {\\n            if num[i] < num[i + 1] {break}\\n        }\\n        for j = n - 1; j > i; j-- {\\n            if num[j] > num[i] {break}\\n        }\\n        num[i], num[j] = num[j], num[i]\\n        for p, q := i + 1, n - 1; p < q; p, q = p + 1, q - 1 {\\n            num[p], num[q] = num[q], num[p]\\n        }\\n    }\\n    return min_step(original, num)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3102720,
                "title": "c-greedy",
                "content": "# Code\\n```\\nclass Solution {\\n    int min_step(string &original, string &num) {\\n        int ans = 0, n = original.size();\\n        for(int i = 0; i < n; i++) {\\n            int j = i;\\n            while(num[j] != original[i]) j++;\\n            while(i < j) {\\n                swap(num[j], num[j - 1]);\\n                j--;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string original = num;\\n        int i, j, n = num.size();\\n        while(k--) {\\n            for(i = n - 2; i >= 0; i--) {\\n                if(num[i] < num[i + 1]) break;\\n            }\\n            for(j = n - 1; j > i; j--) {\\n                if(num[j] > num[i]) break;\\n            }\\n            swap(num[i], num[j]);\\n            reverse(num.begin() + i + 1, num.end());\\n        }\\n        return min_step(original, num);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    int min_step(string &original, string &num) {\\n        int ans = 0, n = original.size();\\n        for(int i = 0; i < n; i++) {\\n            int j = i;\\n            while(num[j] != original[i]) j++;\\n            while(i < j) {\\n                swap(num[j], num[j - 1]);\\n                j--;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string original = num;\\n        int i, j, n = num.size();\\n        while(k--) {\\n            for(i = n - 2; i >= 0; i--) {\\n                if(num[i] < num[i + 1]) break;\\n            }\\n            for(j = n - 1; j > i; j--) {\\n                if(num[j] > num[i]) break;\\n            }\\n            swap(num[i], num[j]);\\n            reverse(num.begin() + i + 1, num.end());\\n        }\\n        return min_step(original, num);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2999661,
                "title": "java-using-treemap",
                "content": "# Code\\n```\\nclass Solution {\\n    public int getMinSwaps(String num, int k) {\\n        char[] cnum = num.toCharArray();\\n        int right = cnum.length - 1;\\n        while (k > 0) {\\n            right = cnum.length - 1;\\n            TreeMap<Character, Integer> numberLine = new TreeMap<>();\\n            while (right > 0) {\\n                numberLine.put(cnum[right], numberLine.getOrDefault(cnum[right], 0) + 1);\\n                if (cnum[right - 1] < cnum[right]) {\\n                    char next = numberLine.ceilingKey((char)(cnum[right - 1] + 1));\\n                    numberLine.put(next, numberLine.get(next) - 1);\\n                    if (numberLine.get(next) == 0) numberLine.remove(next);\\n                    numberLine.put(cnum[right - 1], numberLine.getOrDefault(cnum[right - 1], 0) + 1);\\n                    cnum[right - 1] = next;\\n                    for (char ch : numberLine.keySet()) {\\n                        int n = numberLine.get(ch);\\n                        while (n > 0) {\\n                           cnum[right++] = ch;\\n                           n--;\\n                        }\\n                    }\\n                    break;\\n                }\\n                right--;\\n            }\\n            k--;\\n        }\\n        char[] src = num.toCharArray();\\n        char[] dest = cnum;\\n        return count(src, dest);\\n    }\\n    \\n    private int count(char[] src, char[] dest) {\\n        int count = 0;\\n        for (int i = 0; i < src.length; i++) {\\n            if (src[i] != dest[i]) {\\n                for (int j = i + 1; j < src.length; j++) {\\n                    if (src[j] == dest[i]) {\\n                        for (int k = j; k > i; k--) {\\n                            swap(src, k, k - 1);\\n                            count++;\\n                        }\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n\\n    private void swap(char[] src, int i, int j) {\\n        char temp = src[i];\\n        src[i] = src[j];\\n        src[j] = temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinSwaps(String num, int k) {\\n        char[] cnum = num.toCharArray();\\n        int right = cnum.length - 1;\\n        while (k > 0) {\\n            right = cnum.length - 1;\\n            TreeMap<Character, Integer> numberLine = new TreeMap<>();\\n            while (right > 0) {\\n                numberLine.put(cnum[right], numberLine.getOrDefault(cnum[right], 0) + 1);\\n                if (cnum[right - 1] < cnum[right]) {\\n                    char next = numberLine.ceilingKey((char)(cnum[right - 1] + 1));\\n                    numberLine.put(next, numberLine.get(next) - 1);\\n                    if (numberLine.get(next) == 0) numberLine.remove(next);\\n                    numberLine.put(cnum[right - 1], numberLine.getOrDefault(cnum[right - 1], 0) + 1);\\n                    cnum[right - 1] = next;\\n                    for (char ch : numberLine.keySet()) {\\n                        int n = numberLine.get(ch);\\n                        while (n > 0) {\\n                           cnum[right++] = ch;\\n                           n--;\\n                        }\\n                    }\\n                    break;\\n                }\\n                right--;\\n            }\\n            k--;\\n        }\\n        char[] src = num.toCharArray();\\n        char[] dest = cnum;\\n        return count(src, dest);\\n    }\\n    \\n    private int count(char[] src, char[] dest) {\\n        int count = 0;\\n        for (int i = 0; i < src.length; i++) {\\n            if (src[i] != dest[i]) {\\n                for (int j = i + 1; j < src.length; j++) {\\n                    if (src[j] == dest[i]) {\\n                        for (int k = j; k > i; k--) {\\n                            swap(src, k, k - 1);\\n                            count++;\\n                        }\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n\\n    private void swap(char[] src, int i, int j) {\\n        char temp = src[i];\\n        src[i] = src[j];\\n        src[j] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2969422,
                "title": "python-next-permutation-min-adj-swaps",
                "content": "# Code\\n```\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        num = list(num)\\n        def nextPerm(num):\\n            n = len(num)\\n            j = n - 1\\n            while j and num[j-1] >= num[j]:\\n                j -= 1\\n            pivot = num[j-1]\\n            k = j\\n            for i in range(j,n):\\n                if num[i] > pivot and num[i] < num[k]:\\n                    k = i\\n            num[j-1], num[k] = num[k], num[j-1]\\n            num[j:] = sorted(num[j:])\\n            return num\\n        org = num[:]\\n        while k > 0:\\n            num = nextPerm(num)\\n            k -= 1\\n        res = 0\\n        for i in range(len(num)):\\n            j = num.index(org[i], i)\\n            res += j - i\\n            num[i:j+1] = [num[j]] + num[i:j]\\n        return res\\n                \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        num = list(num)\\n        def nextPerm(num):\\n            n = len(num)\\n            j = n - 1\\n            while j and num[j-1] >= num[j]:\\n                j -= 1\\n            pivot = num[j-1]\\n            k = j\\n            for i in range(j,n):\\n                if num[i] > pivot and num[i] < num[k]:\\n                    k = i\\n            num[j-1], num[k] = num[k], num[j-1]\\n            num[j:] = sorted(num[j:])\\n            return num\\n        org = num[:]\\n        while k > 0:\\n            num = nextPerm(num)\\n            k -= 1\\n        res = 0\\n        for i in range(len(num)):\\n            j = num.index(org[i], i)\\n            res += j - i\\n            num[i:j+1] = [num[j]] + num[i:j]\\n        return res\\n                \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2893412,
                "title": "c-94-51-faster-simple-clean",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int getMinSwaps(string num, int k) {\\n        ll n=num.length(),answer=0;\\n        string temp=num;\\n        while(k--){\\n            next_permutation(temp.begin(),temp.end());\\n        }\\n        for(ll i=0,j=0;i<n && j<n;j++,i++){\\n            if(num[i]==temp[j]){\\n                continue;\\n            }\\n            else{\\n                ll k;\\n                for(k=i+1;k<n;k++){\\n                    if(num[k]==temp[j]){\\n                        break;\\n                    }\\n                }\\n                for(k;k>i;k--){\\n                    answer++;\\n                    swap(num[k],num[k-1]);\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int getMinSwaps(string num, int k) {\\n        ll n=num.length(),answer=0;\\n        string temp=num;\\n        while(k--){\\n            next_permutation(temp.begin(),temp.end());\\n        }\\n        for(ll i=0,j=0;i<n && j<n;j++,i++){\\n            if(num[i]==temp[j]){\\n                continue;\\n            }\\n            else{\\n                ll k;\\n                for(k=i+1;k<n;k++){\\n                    if(num[k]==temp[j]){\\n                        break;\\n                    }\\n                }\\n                for(k;k>i;k--){\\n                    answer++;\\n                    swap(num[k],num[k-1]);\\n                }\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782765,
                "title": "python-follow-up-on-the-next-permutation-for-pythoner",
                "content": "```\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int):\\n        def next_perm(num):\\n            n, j = len(num), 0\\n            for i in range(n - 2, -1, -1):\\n                if num[i] < num[i + 1]:\\n                    j = i\\n                    break\\n            for i in range(n - 1, j, -1):\\n                if num[i] > num[j]:\\n                    return num[:j] + num[i] + (num[j + 1: i] + num[j] + num[i + 1:])[::-1]\\n                \\n        def next_k_perm(num, k):\\n            if k == 0: return num\\n            return next_k_perm(next_perm(num), k - 1)\\n        \\n        tar, n, ans = next_k_perm(num, k), len(num), 0\\n        for i in range(n):\\n            if num[i] != tar[i]:\\n                for j in range(i + 1, n):\\n                    if num[j] == tar[i]:\\n                        ans += j - i\\n                        num = num[:i] + num[j] + num[i: j] + num[j + 1:]\\n                        break\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int):\\n        def next_perm(num):\\n            n, j = len(num), 0\\n            for i in range(n - 2, -1, -1):\\n                if num[i] < num[i + 1]:\\n                    j = i\\n                    break\\n            for i in range(n - 1, j, -1):\\n                if num[i] > num[j]:\\n                    return num[:j] + num[i] + (num[j + 1: i] + num[j] + num[i + 1:])[::-1]\\n                \\n        def next_k_perm(num, k):\\n            if k == 0: return num\\n            return next_k_perm(next_perm(num), k - 1)\\n        \\n        tar, n, ans = next_k_perm(num, k), len(num), 0\\n        for i in range(n):\\n            if num[i] != tar[i]:\\n                for j in range(i + 1, n):\\n                    if num[j] == tar[i]:\\n                        ans += j - i\\n                        num = num[:i] + num[j] + num[i: j] + num[j + 1:]\\n                        break\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2753604,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    // step : 1\\n    // find kth Permutation\\n    // step : 2\\n    // counts adj swaps\\n    \\n    void NextPermutation(string &s){\\n        int n = s.size();\\n        for(int i = n - 2 ; i >= 0 ; i--){\\n            if(s[i] < s[i + 1]){\\n                int val = s[i];\\n                int si = i + 1 , ei = n - 1 , x= 0;\\n                while(si <= ei){\\n                    int mid = (si + ei)/2;\\n                    if(s[mid] == val){\\n                        ei = mid - 1;\\n                    }\\n                    else if(s[mid] > val){\\n                        x = mid;\\n                        si = mid + 1;\\n                    }\\n                    else{\\n                        ei = mid - 1;\\n                    }\\n                }\\n                swap(s[i] , s[x]);\\n                reverse(s.begin() + i + 1 , s.end());\\n                return;\\n            }\\n        }\\n    }\\n    \\n    int getMinSwaps(string s, int k) {\\n        string s1 = s;\\n        while(k>0){\\n            NextPermutation(s);\\n            k--;\\n        }\\n        string s2 = s;\\n        \\n        int n = s1.size();\\n        int i = n - 1 , j = n - 1;\\n        \\n        int ans = 0; \\n        \\n        while(i >= 0){\\n            while(s2[j]!=s1[i]) j--;\\n            while(j + 1 < n){\\n                swap(s2[j] , s2[j+1]);\\n                ans++;\\n                j++;\\n            }\\n            i--;\\n            j = i;\\n            n--;\\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    // step : 1\\n    // find kth Permutation\\n    // step : 2\\n    // counts adj swaps\\n    \\n    void NextPermutation(string &s){\\n        int n = s.size();\\n        for(int i = n - 2 ; i >= 0 ; i--){\\n            if(s[i] < s[i + 1]){\\n                int val = s[i];\\n                int si = i + 1 , ei = n - 1 , x= 0;\\n                while(si <= ei){\\n                    int mid = (si + ei)/2;\\n                    if(s[mid] == val){\\n                        ei = mid - 1;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2635844,
                "title": "python-next-permutation-greedy-swap-from-target-to-original-num",
                "content": "```\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        \\n       \\n        def next_permutation(nums):\\n            for i in range(len(nums) - 2, -1, -1):\\n                if nums[i] < nums[i + 1]:\\n                    for k in range(len(nums) - 1, i, -1):\\n                        if nums[k] > nums[i]:\\n                            nums[i], nums[k] = nums[k], nums[i]\\n                            l = i+1\\n                            r = len(nums)-1\\n                            while l < r:\\n                                nums[l], nums[r] = nums[r], nums[l]\\n                                l+=1\\n                                r-=1\\n                            break\\n                    break\\n            else:\\n                nums.reverse()\\n   \\n        num = [int(i) for i in num]\\n        target = list(num)\\n        for _ in range(k):\\n            next_permutation(target)\\n\\n        \\n        ans = 0\\n        j = 0\\n        for i in range(len(num)):\\n            j = i\\n           \\n            while num[i] != target[j]:\\n                j+=1\\n            while i < j:\\n                target[j], target[j-1] = target[j-1], target[j]\\n                j-=1\\n                ans +=1\\n                \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        \\n       \\n        def next_permutation(nums):\\n            for i in range(len(nums) - 2, -1, -1):\\n                if nums[i] < nums[i + 1]:\\n                    for k in range(len(nums) - 1, i, -1):\\n                        if nums[k] > nums[i]:\\n                            nums[i], nums[k] = nums[k], nums[i]\\n                            l = i+1\\n                            r = len(nums)-1\\n                            while l < r:\\n                                nums[l], nums[r] = nums[r], nums[l]\\n                                l+=1\\n                                r-=1\\n                            break\\n                    break\\n            else:\\n                nums.reverse()\\n   \\n        num = [int(i) for i in num]\\n        target = list(num)\\n        for _ in range(k):\\n            next_permutation(target)\\n\\n        \\n        ans = 0\\n        j = 0\\n        for i in range(len(num)):\\n            j = i\\n           \\n            while num[i] != target[j]:\\n                j+=1\\n            while i < j:\\n                target[j], target[j-1] = target[j-1], target[j]\\n                j-=1\\n                ans +=1\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2610355,
                "title": "python-solution-beats-80",
                "content": "```\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        numCopy, ans = num, 0\\n        num, numCopy = list(num), list(numCopy)\\n        while k:\\n            left, right = len(num) - 2, len(num) - 1\\n            while left >= 0:\\n                if num[left] < num[left + 1]:  \\n                    break\\n                left -= 1\\n            while right >= 0:\\n                if num[left] < num[right]:\\n                    break\\n                right -= 1\\n            num[left], num[right] = num[right], num[left]\\n            num = num[:left + 1] + list(reversed(num[left + 1:]))\\n            k -= 1\\n        for i in range(len(num)):\\n            if numCopy[i] != num[i]:\\n                j = i\\n                while(numCopy[i] != num[j]): j += 1\\n                while j > i:\\n                    num[j], num[j - 1] = num[j - 1], num[j]\\n                    j -= 1\\n                    ans += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        numCopy, ans = num, 0\\n        num, numCopy = list(num), list(numCopy)\\n        while k:\\n            left, right = len(num) - 2, len(num) - 1\\n            while left >= 0:\\n                if num[left] < num[left + 1]:  \\n                    break\\n                left -= 1\\n            while right >= 0:\\n                if num[left] < num[right]:\\n                    break\\n                right -= 1\\n            num[left], num[right] = num[right], num[left]\\n            num = num[:left + 1] + list(reversed(num[left + 1:]))\\n            k -= 1\\n        for i in range(len(num)):\\n            if numCopy[i] != num[i]:\\n                j = i\\n                while(numCopy[i] != num[j]): j += 1\\n                while j > i:\\n                    num[j], num[j - 1] = num[j - 1], num[j]\\n                    j -= 1\\n                    ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2606048,
                "title": "short-concise-c",
                "content": "# Without STL\\n```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string t = num;\\n        while(k--) {\\n            int i, j;\\n            for(i=num.size()-2; i>=0; i--) {\\n                if(num[i] < num[i + 1]) break;\\n            }\\n            for(j=num.size()-1; i>=0; j--) {\\n                if(num[j] > num[i]) break;\\n            }\\n            swap(num[i], num[j]);\\n            reverse(num.begin() + i + 1, num.end());\\n        }\\n        \\n        int ans = 0;\\n        for(int i=0; i<num.size(); i++) {\\n            if(t[i] != num[i]) {\\n                int j = i;\\n                while(t[i] != num[j]) j++;\\n                while(j > i) swap(num[j], num[j - 1]), j--, ans++;\\n            }\\n        }\\n         \\n        return ans;\\n    }\\n};\\n```\\n\\n# Using STL\\n```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string t = num;\\n        while(k--) next_permutation(num.begin(), num.end());\\n        \\n        int ans = 0;\\n        for(int i=0; i<num.size(); i++) {\\n            if(t[i] != num[i]) {\\n                int j = i;\\n                while(t[i] != num[j]) j++;\\n                while(j > i) swap(num[j], num[j - 1]), j--, ans++;\\n            }\\n        }\\n         \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string t = num;\\n        while(k--) {\\n            int i, j;\\n            for(i=num.size()-2; i>=0; i--) {\\n                if(num[i] < num[i + 1]) break;\\n            }\\n            for(j=num.size()-1; i>=0; j--) {\\n                if(num[j] > num[i]) break;\\n            }\\n            swap(num[i], num[j]);\\n            reverse(num.begin() + i + 1, num.end());\\n        }\\n        \\n        int ans = 0;\\n        for(int i=0; i<num.size(); i++) {\\n            if(t[i] != num[i]) {\\n                int j = i;\\n                while(t[i] != num[j]) j++;\\n                while(j > i) swap(num[j], num[j - 1]), j--, ans++;\\n            }\\n        }\\n         \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string t = num;\\n        while(k--) next_permutation(num.begin(), num.end());\\n        \\n        int ans = 0;\\n        for(int i=0; i<num.size(); i++) {\\n            if(t[i] != num[i]) {\\n                int j = i;\\n                while(t[i] != num[j]) j++;\\n                while(j > i) swap(num[j], num[j - 1]), j--, ans++;\\n            }\\n        }\\n         \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2563658,
                "title": "c-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string s=num;\\n        while(k--)\\n        {\\n            next_permutation(num.begin(),num.end());\\n        }\\n        int n=num.size();\\n        int swaps=0;\\n\\n        int i=0, j=0;\\n        while(i<n)\\n        {\\n            if(s[i]!=num[j])\\n            {\\n                while(j<n and num[j]!=s[i])\\n                    j++;\\n                while(j>i)\\n                {\\n                    swap(num[j-1],num[j]);\\n                    swaps++;\\n                    j--;\\n                }                  \\n                \\n            }\\n            \\n                i++;\\n                j++;\\n            \\n        }\\n        return swaps;\\n\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string s=num;\\n        while(k--)\\n        {\\n            next_permutation(num.begin(),num.end());\\n        }\\n        int n=num.size();\\n        int swaps=0;\\n\\n        int i=0, j=0;\\n        while(i<n)\\n        {\\n            if(s[i]!=num[j])\\n            {\\n                while(j<n and num[j]!=s[i])\\n                    j++;\\n                while(j>i)\\n                {\\n                    swap(num[j-1],num[j]);\\n                    swaps++;\\n                    j--;\\n                }                  \\n                \\n            }\\n            \\n                i++;\\n                j++;\\n            \\n        }\\n        return swaps;\\n\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2561656,
                "title": "c",
                "content": "```\\nint cmpfunc(const void* a, const void* b){\\n    return *(char*)a - *(char*)b;\\n}\\n\\n//\\n//next Permutation\\nvoid nextPermutation(char* nums, int numsSize){\\n\\n    for(int i = numsSize - 2 ; i >= 0; i--){\\n        if(nums[i] < nums[i + 1]){\\n            qsort(&nums[i+1], numsSize-(i+1), sizeof(char), cmpfunc);\\n            for(int j = i+1; j < numsSize; j++){\\n                if(nums[j] > nums[i]){\\n                    char temp = nums[i];\\n                    nums[i] = nums[j];\\n                    nums[j] = temp;   \\n                    return;\\n                }\\n            }      \\n        }\\n    }\\n    \\n    qsort(nums, numsSize, sizeof(char), cmpfunc);\\n}\\n\\n//\\n//main function\\nint getMinSwaps(char * num, int k){\\n    int len = strlen(num);\\n    char* copy = malloc( (len+1) * sizeof(char));\\n    char* temp = malloc( (len+1) * sizeof(char));\\n    copy[len] = \\'\\\\0\\';\\n    strcpy(copy, num);\\n    \\n    //>>> produce kth number to \"char* copy\" \\n    for(int i = 0; i < k; i++){\\n        nextPermutation(copy, len);\\n    }\\n    //<<<<<\\n    \\n    //>>>> begin count swap times\\n    int ans = 0;\\n    for(int i = 0; i < len; i++){\\n        if(copy[i] == num[i])\\n            continue;\\n        for(int j = i+1; j < len; j++){\\n            if(copy[i] == num[j]){\\n                strncpy(temp, &num[i] , j-i);\\n                strncpy(&num[i+1], temp , j-i);\\n                num[i] = copy[i];   \\n                ans += (j-i) ;\\n                break;\\n            }\\n        }\\n    }\\n    //<<<<<\\n    \\n    free(copy);\\n    free(temp);\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint cmpfunc(const void* a, const void* b){\\n    return *(char*)a - *(char*)b;\\n}\\n\\n//\\n//next Permutation\\nvoid nextPermutation(char* nums, int numsSize){\\n\\n    for(int i = numsSize - 2 ; i >= 0; i--){\\n        if(nums[i] < nums[i + 1]){\\n            qsort(&nums[i+1], numsSize-(i+1), sizeof(char), cmpfunc);\\n            for(int j = i+1; j < numsSize; j++){\\n                if(nums[j] > nums[i]){\\n                    char temp = nums[i];\\n                    nums[i] = nums[j];\\n                    nums[j] = temp;   \\n                    return;\\n                }\\n            }      \\n        }\\n    }\\n    \\n    qsort(nums, numsSize, sizeof(char), cmpfunc);\\n}\\n\\n//\\n//main function\\nint getMinSwaps(char * num, int k){\\n    int len = strlen(num);\\n    char* copy = malloc( (len+1) * sizeof(char));\\n    char* temp = malloc( (len+1) * sizeof(char));\\n    copy[len] = \\'\\\\0\\';\\n    strcpy(copy, num);\\n    \\n    //>>> produce kth number to \"char* copy\" \\n    for(int i = 0; i < k; i++){\\n        nextPermutation(copy, len);\\n    }\\n    //<<<<<\\n    \\n    //>>>> begin count swap times\\n    int ans = 0;\\n    for(int i = 0; i < len; i++){\\n        if(copy[i] == num[i])\\n            continue;\\n        for(int j = i+1; j < len; j++){\\n            if(copy[i] == num[j]){\\n                strncpy(temp, &num[i] , j-i);\\n                strncpy(&num[i+1], temp , j-i);\\n                num[i] = copy[i];   \\n                ans += (j-i) ;\\n                break;\\n            }\\n        }\\n    }\\n    //<<<<<\\n    \\n    free(copy);\\n    free(temp);\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2557849,
                "title": "c-greedy-next-permutation",
                "content": "```\\n/*\\n\\nmin no of adjacent digit swaps to find kth smallest number ?\\n\\nnext permutation is always just greater number\\n\\nso \\n\\nans= min no of adjacent swaps to make the given string equals to its next kth permutation\\n\\n*/\\n\\n\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        \\n       string need=num;\\n        \\n        \\n        while(k--){   // O(k)\\n            next_permutation(need.begin(),need.end());  // O(n)\\n        }\\n        \\n        \\n        return find(num,need);\\n        \\n    }\\n    \\n    \\n    \\n  int find(string s1,string s2){\\n\\n    // s1=>s2\\n\\n    int n=s1.size();\\n\\n    int i=0;\\n\\n    int count=0;\\n\\n    while(i<n){\\n\\n       if(s2[i]!=s1[i]){\\n        int k=i;\\n          while(i<n && s2[k]!=s1[i]){\\n            i++;\\n          }\\n          int j=i-1;\\n\\n          while(j>=k){\\n             swap(s1[i],s1[j]);\\n             i--,j--;\\n             count++;\\n          }\\n          i=k+1;\\n       }\\n       else\\n        i++;\\n    }\\n\\n      \\n      return count;\\n   // cout<<count<<\" \"<<s1<<\" \"<<s2;\\n\\n  }\\n\\n    \\n};",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        \\n       string need=num;\\n        \\n        \\n        while(k--){   // O(k)\\n            next_permutation(need.begin(),need.end());  // O(n)\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2557348,
                "title": "c-simple-and-clean-solution-for-beginners",
                "content": "**Please Upvote if it helped you !!!\\nHappy Coding :)**\\n```\\nint getMinSwaps(string num, int k) \\n    {\\n        string temp=num;\\n        int count=0;\\n        while(k)\\n        {\\n            next_permutation(temp.begin(),temp.end());\\n            k--;\\n        }\\n        int i=0,j;\\n        while(i<num.size())\\n        {\\n            j=i;\\n            while(num[j] != temp[i])\\n                j++;\\n            while(i<j)\\n            {\\n                swap(num[j],num[j-1]);\\n                j--;\\n                count++;\\n            }\\n            i++;\\n        }\\n        return count;\\n    }\\n\\t",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "**Please Upvote if it helped you !!!\\nHappy Coding :)**\\n```\\nint getMinSwaps(string num, int k) \\n    {\\n        string temp=num;\\n        int count=0;\\n        while(k)\\n        {\\n            next_permutation(temp.begin(),temp.end());\\n            k--;\\n        }\\n        int i=0,j;\\n        while(i<num.size())\\n        {\\n            j=i;\\n            while(num[j] != temp[i])\\n                j++;\\n            while(i<j)\\n            {\\n                swap(num[j],num[j-1]);\\n                j--;\\n                count++;\\n            }\\n            i++;\\n        }\\n        return count;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2547368,
                "title": "my-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string temp=num;\\n        for(int i=0;i<k;i++){\\n            next_permutation(num.begin(),num.end());\\n        }\\n        int i=0;\\n        int count=0;\\n        while(i<temp.size()){\\n            if(temp==num){\\n                return count;\\n            }\\n            if(temp[i]!=num[i]){\\n                int j=i+1;\\n                while(num[j]!=temp[i]){\\n                    j++;\\n                }\\n                while(j>i){\\n                    swap(num[j],num[j-1]);\\n                    count++;\\n                    j--;\\n                }\\n            }\\n            i++;\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string temp=num;\\n        for(int i=0;i<k;i++){\\n            next_permutation(num.begin(),num.end());\\n        }\\n        int i=0;\\n        int count=0;\\n        while(i<temp.size()){\\n            if(temp==num){\\n                return count;\\n            }\\n            if(temp[i]!=num[i]){\\n                int j=i+1;\\n                while(num[j]!=temp[i]){\\n                    j++;\\n                }\\n                while(j>i){\\n                    swap(num[j],num[j-1]);\\n                    count++;\\n                    j--;\\n                }\\n            }\\n            i++;\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2517335,
                "title": "c-two-pointers-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string n, int k) \\n    {\\n        string n1=n;\\n        while(k--)\\n        {\\n            next_permutation(n1.begin(),n1.end());\\n        }\\n        int i=0,j=0;\\n        int ans=0;\\n        while(i<n.size())\\n        {\\n            j=i;\\n            while(n[i]!=n1[j])\\n                j++;\\n            while(i<j)\\n            {\\n                swap(n1[j],n1[j-1]);\\n                ans++;\\n                j--;\\n            }\\n            i++;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    int getMinSwaps(string n, int k) \\n    {\\n        string n1=n;\\n        while(k--)\\n        {\\n            next_permutation(n1.begin(),n1.end());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2497680,
                "title": "python3-100-63ms-very-fast-skip-next-perm",
                "content": "The question can be seperated to two part:\\n1. **get_k_next**: find the k-next permuation `num2`\\n2.  **get_swap** :compare the `num2` and `num` and find the min swap.\\n\\n## Simulate Adjacent Swapping\\nThe second part can be solved by simulate the swap and count, like following. The complexity is **O(N+swaps)**(worst **O(N^2)**)\\n```\\ndef get_swap(li1,li2):\\n\\tn,res = len(li1),0\\n\\tfor i in range(n):\\n\\t\\tj = i\\n\\t\\twhile li2[i]!=li1[j]:\\n\\t\\t\\tj += 1\\n\\t\\tres += (j-i)\\n\\t\\twhile j>i:\\n\\t\\t\\tli1[j],li1[j-1] = li1[j-1],li1[j]\\n\\t\\t\\tj -= 1\\n\\treturn res\\n```\\n\\n## Next-Permutation and Skip-Next-Permutation\\nFor the first part, there are two ways. \\n### Next Permutation \\n1. The first way is to find the next permutation and do it for k time. The complexity is **O(KN)**:\\n```\\nfrom bisect import bisect\\ndef next_perm(li):\\n\\tbuf = []\\n\\twhile li:\\n\\t\\te = li.pop()\\n\\t\\tif not buf or buf[-1]<=e:\\n\\t\\t\\tbuf.append(e)\\n\\t\\telse:\\n\\t\\t\\tind = bisect(buf,e)\\n\\t\\t\\te,buf[ind] = buf[ind],e\\n\\t\\t\\treturn li + [e] + buf\\n\\ndef get_k_next(num, k=k):\\n\\tfor _ in range(k):\\n\\t\\tnum = next_perm(num)\\n\\treturn num\\n```\\n### Skip Next Permutation\\n2. The second way is to calculate the possible number of wonderful permutations for current digit, skip those permutations if k is not reached, otherwise go to the next digit and calculate the again (need two turn, logics are slightly different).  \\n* \\tThe code also needs to calculate according to [Permutations of multisets](https://en.wikipedia.org/wiki/Permutation). The `get_fact` function do the calculation and optimize for this problem that k is much smaller than the possible number of permuation.\\n![image](https://assets.leetcode.com/users/images/a67fb4da-fb8d-4848-9852-5a6967eab94b_1661725841.6515608.png)\\n* The complexity is roughly **O(N+KlogK)**.\\n\\n```\\ndef get_fact(li,limit):\\n\\tres,total = 1,sum(li)\\n\\tli = sorted([e for e in li if e],reverse = True)\\n\\tif not li: \\n\\t\\treturn 0\\n\\twhile len(li)!=1:\\n\\t\\tn = li[-1]\\n\\t\\tli[-1] -= 1\\n\\t\\tif n==1:\\n\\t\\t\\tli.pop()\\n\\t\\tres = res*total//n\\n\\t\\ttotal -= 1\\n\\t\\tif res>limit:\\n\\t\\t\\treturn None\\n\\treturn res\\n\\ndef get_k_next(num, k=k):\\n\\tct,f = [0]*10,True\\n\\twhile num and f:\\n\\t\\tdig = int(num.pop())\\n\\t\\tct[dig] += 1\\n\\t\\tfor j in range(dig+1,10):\\n\\t\\t\\tif ct[j]>0:\\n\\t\\t\\t\\tct[j] -= 1\\n\\t\\t\\t\\tc = get_fact(ct,k)\\n\\t\\t\\t\\tif c is None or k==c:\\n\\t\\t\\t\\t\\tf = False\\n\\t\\t\\t\\t\\tnum.append(str(j))\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\tk -= c\\n\\t\\t\\t\\tct[j] += 1    \\n\\twhile k!=c:\\n\\t\\tfor i in range(10):\\n\\t\\t\\tif ct[i]>0:\\n\\t\\t\\t\\tct[i] -= 1\\n\\t\\t\\t\\tc = get_fact(ct,k)\\n\\t\\t\\t\\tif c is None or k==c:\\n\\t\\t\\t\\t\\tnum.append(str(i))\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\tk -= c\\n\\t\\t\\t\\tct[i] += 1\\n\\n\\tfor i in range(9,-1,-1):\\n\\t\\tif ct[i]>0:\\n\\t\\t\\tnum += [str(i)]*ct[i]\\n\\treturn num\\n```\\n\\n### Comparison and Summary\\nThe runtime comparision is like the screenshot. The second one beats 100% and is tens of times faster than other top rank submissions. However, the code and its logic are slightly complex and may not be suitable for interview.\\n![image](https://assets.leetcode.com/users/images/0937a857-8328-45fb-9ac3-de998106548e_1661726440.5405748.png)\\n![image](https://assets.leetcode.com/users/images/208bdef5-0f23-49cb-a321-b3d8d141ffa6_1661726540.5652432.png)\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\ndef get_swap(li1,li2):\\n\\tn,res = len(li1),0\\n\\tfor i in range(n):\\n\\t\\tj = i\\n\\t\\twhile li2[i]!=li1[j]:\\n\\t\\t\\tj += 1\\n\\t\\tres += (j-i)\\n\\t\\twhile j>i:\\n\\t\\t\\tli1[j],li1[j-1] = li1[j-1],li1[j]\\n\\t\\t\\tj -= 1\\n\\treturn res\\n```\n```\\nfrom bisect import bisect\\ndef next_perm(li):\\n\\tbuf = []\\n\\twhile li:\\n\\t\\te = li.pop()\\n\\t\\tif not buf or buf[-1]<=e:\\n\\t\\t\\tbuf.append(e)\\n\\t\\telse:\\n\\t\\t\\tind = bisect(buf,e)\\n\\t\\t\\te,buf[ind] = buf[ind],e\\n\\t\\t\\treturn li + [e] + buf\\n\\ndef get_k_next(num, k=k):\\n\\tfor _ in range(k):\\n\\t\\tnum = next_perm(num)\\n\\treturn num\\n```\n```\\ndef get_fact(li,limit):\\n\\tres,total = 1,sum(li)\\n\\tli = sorted([e for e in li if e],reverse = True)\\n\\tif not li: \\n\\t\\treturn 0\\n\\twhile len(li)!=1:\\n\\t\\tn = li[-1]\\n\\t\\tli[-1] -= 1\\n\\t\\tif n==1:\\n\\t\\t\\tli.pop()\\n\\t\\tres = res*total//n\\n\\t\\ttotal -= 1\\n\\t\\tif res>limit:\\n\\t\\t\\treturn None\\n\\treturn res\\n\\ndef get_k_next(num, k=k):\\n\\tct,f = [0]*10,True\\n\\twhile num and f:\\n\\t\\tdig = int(num.pop())\\n\\t\\tct[dig] += 1\\n\\t\\tfor j in range(dig+1,10):\\n\\t\\t\\tif ct[j]>0:\\n\\t\\t\\t\\tct[j] -= 1\\n\\t\\t\\t\\tc = get_fact(ct,k)\\n\\t\\t\\t\\tif c is None or k==c:\\n\\t\\t\\t\\t\\tf = False\\n\\t\\t\\t\\t\\tnum.append(str(j))\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\tk -= c\\n\\t\\t\\t\\tct[j] += 1    \\n\\twhile k!=c:\\n\\t\\tfor i in range(10):\\n\\t\\t\\tif ct[i]>0:\\n\\t\\t\\t\\tct[i] -= 1\\n\\t\\t\\t\\tc = get_fact(ct,k)\\n\\t\\t\\t\\tif c is None or k==c:\\n\\t\\t\\t\\t\\tnum.append(str(i))\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\tk -= c\\n\\t\\t\\t\\tct[i] += 1\\n\\n\\tfor i in range(9,-1,-1):\\n\\t\\tif ct[i]>0:\\n\\t\\t\\tnum += [str(i)]*ct[i]\\n\\treturn num\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2447297,
                "title": "clean-java-code-two-pointers",
                "content": "```\\npublic class MinSwaps {\\n    public int getMinSwaps(String num, int k) {\\n        if(num == null || num.length() == 0) return 0;\\n\\n\\n        int[] nums = Arrays.stream(num.chars().toArray())\\n                .map(Character::getNumericValue)\\n                .toArray();\\n\\n        int[] kthSmallest = nextPermutation(nums.clone(), k);\\n\\n        return countSteps(nums, kthSmallest);\\n    }\\n\\n    /**\\n     * Count the number of steps required to make second array back to the first array\\n     * @param first\\n     * @param second\\n     * @return\\n     */\\n    private int countSteps(int[] first, int[] second) {\\n        int i = 0, j = 0;\\n        int result = 0;\\n\\n        int len = first.length;\\n        while(i < len){\\n            j = i;\\n\\n            while(j < len && second[j] != first[i]){\\n                j++;\\n            }\\n\\n            // This will make the second array back to the original one.\\n            // while doing so, we\\'ll keep track of how many times we are doing this to reach the original\\n            // In simple words, bring the number at j-th position to i-th position.\\n            while(i < j){\\n                swap(second, j, j - 1);\\n                j--;\\n                result++;\\n            }\\n            i++;\\n        }\\n        return result;\\n    }\\n\\n    private int[] nextPermutation(int[] nums, int k) {\\n        if(nums == null || nums.length == 0) return new int[]{};\\n\\n        int n = nums.length;\\n\\n        while(k-- > 0) {\\n\\n            //Step 1: Find the breach\\n            int i = n - 2;\\n            while(i >= 0 && nums[i] >= nums[i + 1]) {\\n                i--;\\n            }\\n\\n            //Step 2: Find the next larger element than the current i\\n            if(i >= 0) { // for 5 4 3 2 1 (all in descending order), i will go to -1\\n                int j = n - 1;\\n                while(j >= 0 && nums[j] <= nums[i]) {\\n                    j--;\\n                }\\n                swap(nums, i, j);\\n            }\\n\\n            //Step 3: Reverse the sub-array starting from i + 1\\n            reverse(nums, i + 1, n - 1);\\n\\n        }\\n\\n        return nums;\\n    }\\n\\n    private void swap(int[] arr, int l, int r) {\\n        int temp = arr[l];\\n        arr[l] = arr[r];\\n        arr[r] = temp;\\n    }\\n\\n    private void reverse(int[] arr, int l, int r) {\\n        while(l <= r) {\\n            swap(arr, l, r);\\n            l++;\\n            r--;\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\npublic class MinSwaps {\\n    public int getMinSwaps(String num, int k) {\\n        if(num == null || num.length() == 0) return 0;\\n\\n\\n        int[] nums = Arrays.stream(num.chars().toArray())\\n                .map(Character::getNumericValue)\\n                .toArray();\\n\\n        int[] kthSmallest = nextPermutation(nums.clone(), k);\\n\\n        return countSteps(nums, kthSmallest);\\n    }\\n\\n    /**\\n     * Count the number of steps required to make second array back to the first array\\n     * @param first\\n     * @param second\\n     * @return\\n     */\\n    private int countSteps(int[] first, int[] second) {\\n        int i = 0, j = 0;\\n        int result = 0;\\n\\n        int len = first.length;\\n        while(i < len){\\n            j = i;\\n\\n            while(j < len && second[j] != first[i]){\\n                j++;\\n            }\\n\\n            // This will make the second array back to the original one.\\n            // while doing so, we\\'ll keep track of how many times we are doing this to reach the original\\n            // In simple words, bring the number at j-th position to i-th position.\\n            while(i < j){\\n                swap(second, j, j - 1);\\n                j--;\\n                result++;\\n            }\\n            i++;\\n        }\\n        return result;\\n    }\\n\\n    private int[] nextPermutation(int[] nums, int k) {\\n        if(nums == null || nums.length == 0) return new int[]{};\\n\\n        int n = nums.length;\\n\\n        while(k-- > 0) {\\n\\n            //Step 1: Find the breach\\n            int i = n - 2;\\n            while(i >= 0 && nums[i] >= nums[i + 1]) {\\n                i--;\\n            }\\n\\n            //Step 2: Find the next larger element than the current i\\n            if(i >= 0) { // for 5 4 3 2 1 (all in descending order), i will go to -1\\n                int j = n - 1;\\n                while(j >= 0 && nums[j] <= nums[i]) {\\n                    j--;\\n                }\\n                swap(nums, i, j);\\n            }\\n\\n            //Step 3: Reverse the sub-array starting from i + 1\\n            reverse(nums, i + 1, n - 1);\\n\\n        }\\n\\n        return nums;\\n    }\\n\\n    private void swap(int[] arr, int l, int r) {\\n        int temp = arr[l];\\n        arr[l] = arr[r];\\n        arr[r] = temp;\\n    }\\n\\n    private void reverse(int[] arr, int l, int r) {\\n        while(l <= r) {\\n            swap(arr, l, r);\\n            l++;\\n            r--;\\n        }\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 2446553,
                "title": "clean-java-code-easy-to-understand-greedy-approach",
                "content": "```\\nclass Solution {\\n    public int getMinSwaps(String num, int k) {\\n          int n =num.length();\\n        int [] org = new int [n];\\n        int [] nums = new int [n];\\n        for(int i =0;i<n;i++){\\n            org[i]=Character.getNumericValue(num.charAt(i));\\n            nums[i]=Character.getNumericValue(num.charAt(i));\\n        }\\n        while(k>=1){\\n            newPermutation(nums,n);\\n                k--;\\n        }\\n        int ans =0;\\n        \\n        \\n        for(int each :nums){\\n            System.out.print(each);\\n        }\\n         \\n        // below calculating min no of adjacent swaps required\\n         \\n    int i =0;\\n   for( i =0;i<n;i++){\\n       \\n       if(org[i]!=nums[i]){\\n           \\n           int j =0;\\n           for(j =i+1;j<n;j++){\\n               if(nums[i]==org[j])\\n                   break;\\n           }\\n           while(j>0 && j!=i)\\n           {\\n               swap(org,j-1,j);\\n                   ans++;\\n               j--;\\n           }\\n       }\\n       \\n       \\n   }\\n        \\n        \\n        \\n        \\n        \\n        \\n        return ans;\\n        \\n    }\\n    private void newPermutation(int [] nums,int n  ){\\n        \\n        if(nums.length==1)\\n            return ;\\n        int first =n-2;\\n        while(first>=0 && nums[first]>=nums[first+1])\\n            first--;\\n        if(first<0)\\n            return ;\\n        int second =n-1;\\n        while(first<second && nums[first]>=nums[second])\\n            second --;\\n        swap(nums,first,second);\\n            \\n            reverse(nums,first+1,n );\\n    }\\n    private void swap(int [] nums,int i ,int j){\\n        if(i==j)\\n            return ;\\n        int temp =nums[i];\\n        nums[i]=nums[j];\\n        nums[j]=temp;\\n    }\\n    private void reverse(int [] nums ,int i,int n ){\\n        int j =n-1;\\n        while(i<j){\\n            swap(nums,i,j);\\n            i++;\\n            j--;\\n        }\\n    }\\n}\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinSwaps(String num, int k) {\\n          int n =num.length();\\n        int [] org = new int [n];\\n        int [] nums = new int [n];\\n        for(int i =0;i<n;i++){\\n            org[i]=Character.getNumericValue(num.charAt(i));\\n            nums[i]=Character.getNumericValue(num.charAt(i));\\n        }\\n        while(k>=1){\\n            newPermutation(nums,n);\\n                k--;\\n        }\\n        int ans =0;\\n        \\n        \\n        for(int each :nums){\\n            System.out.print(each);\\n        }\\n         \\n        // below calculating min no of adjacent swaps required\\n         \\n    int i =0;\\n   for( i =0;i<n;i++){\\n       \\n       if(org[i]!=nums[i]){\\n           \\n           int j =0;\\n           for(j =i+1;j<n;j++){\\n               if(nums[i]==org[j])\\n                   break;\\n           }\\n           while(j>0 && j!=i)\\n           {\\n               swap(org,j-1,j);\\n                   ans++;\\n               j--;\\n           }\\n       }\\n       \\n       \\n   }\\n        \\n        \\n        \\n        \\n        \\n        \\n        return ans;\\n        \\n    }\\n    private void newPermutation(int [] nums,int n  ){\\n        \\n        if(nums.length==1)\\n            return ;\\n        int first =n-2;\\n        while(first>=0 && nums[first]>=nums[first+1])\\n            first--;\\n        if(first<0)\\n            return ;\\n        int second =n-1;\\n        while(first<second && nums[first]>=nums[second])\\n            second --;\\n        swap(nums,first,second);\\n            \\n            reverse(nums,first+1,n );\\n    }\\n    private void swap(int [] nums,int i ,int j){\\n        if(i==j)\\n            return ;\\n        int temp =nums[i];\\n        nums[i]=nums[j];\\n        nums[j]=temp;\\n    }\\n    private void reverse(int [] nums ,int i,int n ){\\n        int j =n-1;\\n        while(i<j){\\n            swap(nums,i,j);\\n            i++;\\n            j--;\\n        }\\n    }\\n}\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2409205,
                "title": "c-simple-solution-using-next-permutation",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    int minSteps(string s1, string s2) {\\n        int size = s1.length();\\n        \\n        int i = 0, j = 0;\\n        \\n        int result = 0;\\n        \\n        \\n        while (i < size) {\\n            j = i;\\n            while (s1[j] != s2[i]) j++;\\n\\t\\t\\t\\n            while (i < j) {\\n                swap(s1[j], s1[j-1]);\\n                j--;\\n                result++;\\n            }\\n            i++;\\n        }\\n        return result;\\n    }\\n    \\n    int getMinSwaps(string num, int k) {\\n        string original = num;\\n        \\n        while(k--) {\\n            next_permutation(num.begin(), num.end());\\n        }\\n        \\n        return minSteps(original, num);\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2406308,
                "title": "wrote-my-own-permutation-function-but-it-gives-me-tle-why",
                "content": "I used my own permutation function rather than using C++ in-built `next_permutation` method, I am unable to understand, how can I optimise my function. The snippet of the same is given below. Please help here.\\nThanks in advance.\\n```\\nvoid getKthNextPermutation(string&num,int size,int k){\\n        while(k--){\\n    \\n\\t\\t\\tint i = size-2;\\n            multiset<char>sArr={num[size-1]};\\n            \\n            while(i>=0){\\n                \\n                if(num[i]>=num[i+1]){\\n                    sArr.insert(num[i]);\\n                }\\n                else{\\n                    \\n                    auto it = upper_bound(sArr.begin(),sArr.end(),num[i]);\\n                    auto val = *it;\\n                    sArr.erase(it);\\n                    sArr.insert(num[i]);\\n                    num[i] = val;\\n                    i++;\\n                    \\n                    auto itt = sArr.begin();\\n                    \\n                    while(itt!=sArr.end()){\\n                        num[i] = *itt;\\n                        itt++;\\n                        i++;\\n                    }\\n                    break;\\n                }\\n                i--;\\n            }\\n        }\\n    }\\n```\\n**NOTE :** The string `num` above is passed by reference and no copy of it is being created. I have used a multi set to maintain next possible value with which `num[i]` can be replaced with , if the upper_bound of `num[i]` is not found the number from right to left already occur in an increasing sequence and next permutation cannot be determined.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid getKthNextPermutation(string&num,int size,int k){\\n        while(k--){\\n    \\n\\t\\t\\tint i = size-2;\\n            multiset<char>sArr={num[size-1]};\\n            \\n            while(i>=0){\\n                \\n                if(num[i]>=num[i+1]){\\n                    sArr.insert(num[i]);\\n                }\\n                else{\\n                    \\n                    auto it = upper_bound(sArr.begin(),sArr.end(),num[i]);\\n                    auto val = *it;\\n                    sArr.erase(it);\\n                    sArr.insert(num[i]);\\n                    num[i] = val;\\n                    i++;\\n                    \\n                    auto itt = sArr.begin();\\n                    \\n                    while(itt!=sArr.end()){\\n                        num[i] = *itt;\\n                        itt++;\\n                        i++;\\n                    }\\n                    break;\\n                }\\n                i--;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2346681,
                "title": "javascript-faster-than-100-commented",
                "content": "Thanks to @hqz3 for swapping logic.\\n![image](https://assets.leetcode.com/users/images/d11c6e1e-3841-4bd3-9bea-677e1c578c4e_1659025707.732035.png)\\n\\n\\tvar getMinSwaps = function(num, k) {\\n    let nextPermutation = (nums) => {// Permutation Calculator\\n        let i,j;\\n        //start from right and find the index where value is more than its succeeding value\\n        for(i = nums.length - 2; nums[i]>=nums[i+1] && i>=0; i--);\\n        //if no such value is present i = -1, already max permutation, next would me min permutation\\n        if(i>=0){\\n            //find an index from right where value is greater than value at i\\n            for(j = nums.length -1; nums[j]<=nums[i]; j--);\\n            //swap these index values\\n            [nums[i],nums[j]] = [nums[j],nums[i]];\\n        }\\n        i++;\\n        j = nums.length - 1;\\n        while(i<j){//reverse the array after index i, to get next permutation\\n            [nums[i],nums[j]] = [nums[j],nums[i]];\\n            i++;\\n            j--;\\n        }\\n    }\\n    let arr = num.split(\\'\\').map((x) => parseInt(x,10));\\n    while(k>0){//find kth permutation in place\\n         nextPermutation(arr);\\n         k--;\\n    }\\n    num = num.split(\\'\\').map((x) => parseInt(x));\\n    \\n    //Swapping Logic\\n    let count = 0;\\n    for(let i=0; i<num.length; i++){\\n        if(num[i]!=arr[i]){//where the two numbers dont match\\n            let j= (i+1);\\n            while(num[j]!=arr[i] && j<num.length) j++;//find actual value in num array\\n            count+= j-i;//add the difference of indices as these are the number of swaps needed\\n            num.splice(j, 1);//replace the value in array\\n            num.splice(i, 0, arr[i]);\\n        }\\n    }\\n    return count;\\n\\t};",
                "solutionTags": [
                    "JavaScript",
                    "Probability and Statistics"
                ],
                "code": "Thanks to @hqz3 for swapping logic.\\n![image](https://assets.leetcode.com/users/images/d11c6e1e-3841-4bd3-9bea-677e1c578c4e_1659025707.732035.png)\\n\\n\\tvar getMinSwaps = function(num, k) {\\n    let nextPermutation = (nums) => {// Permutation Calculator\\n        let i,j;\\n        //start from right and find the index where value is more than its succeeding value\\n        for(i = nums.length - 2; nums[i]>=nums[i+1] && i>=0; i--);\\n        //if no such value is present i = -1, already max permutation, next would me min permutation\\n        if(i>=0){\\n            //find an index from right where value is greater than value at i\\n            for(j = nums.length -1; nums[j]<=nums[i]; j--);\\n            //swap these index values\\n            [nums[i],nums[j]] = [nums[j],nums[i]];\\n        }\\n        i++;\\n        j = nums.length - 1;\\n        while(i<j){//reverse the array after index i, to get next permutation\\n            [nums[i],nums[j]] = [nums[j],nums[i]];\\n            i++;\\n            j--;\\n        }\\n    }\\n    let arr = num.split(\\'\\').map((x) => parseInt(x,10));\\n    while(k>0){//find kth permutation in place\\n         nextPermutation(arr);\\n         k--;\\n    }\\n    num = num.split(\\'\\').map((x) => parseInt(x));\\n    \\n    //Swapping Logic\\n    let count = 0;\\n    for(let i=0; i<num.length; i++){\\n        if(num[i]!=arr[i]){//where the two numbers dont match\\n            let j= (i+1);\\n            while(num[j]!=arr[i] && j<num.length) j++;//find actual value in num array\\n            count+= j-i;//add the difference of indices as these are the number of swaps needed\\n            num.splice(j, 1);//replace the value in array\\n            num.splice(i, 0, arr[i]);\\n        }\\n    }\\n    return count;\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 2289650,
                "title": "using-two-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(string a , string b){\\n        int i =a.length()-1;\\n        int j= a.length()-1;\\n        int ans=0;\\n        while(i>=0){\\n            if(a[i]==b[j]){i--;j--;}\\n            else{\\n             \\n                int l = i;\\n                while(l>0 and a[l]!=b[j])l--;\\n                \\n                \\n                for(int m=l;m<i;m++){\\n                    swap(a[m],a[m+1]);\\n                    ans++;\\n                }\\n                \\n                i--;\\n                j--;\\n            }\\n        }\\n        return ans;\\n    }\\n    int getMinSwaps(string num, int k) {\\n        string original =num;\\n        while(k--){\\n            next_permutation(num.begin(),num.end());\\n        }\\n        \\n       return  solve(original,num);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(string a , string b){\\n        int i =a.length()-1;\\n        int j= a.length()-1;\\n        int ans=0;\\n        while(i>=0){\\n            if(a[i]==b[j]){i--;j--;}\\n            else{\\n             \\n                int l = i;\\n                while(l>0 and a[l]!=b[j])l--;\\n                \\n                \\n                for(int m=l;m<i;m++){\\n                    swap(a[m],a[m+1]);\\n                    ans++;\\n                }\\n                \\n                i--;\\n                j--;\\n            }\\n        }\\n        return ans;\\n    }\\n    int getMinSwaps(string num, int k) {\\n        string original =num;\\n        while(k--){\\n            next_permutation(num.begin(),num.end());\\n        }\\n        \\n       return  solve(original,num);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2249426,
                "title": "permutation-function-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {    \\n        \\n        int cnt = 0;\\n        string src = num;\\n        \\n        while( k -- ) \\n            next_permutation(num.begin(), num.end());\\n        \\n        cout << num << endl;\\n        for(int i = 0; i < num.length(); ++i) {\\n            \\n            int j = i;\\n            if(src[i] != num[j]) {\\n                \\n                while(num[j] != src[i]) \\n                    i += 1;\\n                \\n                while(i > j) {\\n                    swap(src[i], src[i-1]);\\n                    i -= 1;\\n                    cnt += 1;\\n                }\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {    \\n        \\n        int cnt = 0;\\n        string src = num;\\n        \\n        while( k -- ) \\n            next_permutation(num.begin(), num.end());\\n        \\n        cout << num << endl;\\n        for(int i = 0; i < num.length(); ++i) {\\n            \\n            int j = i;\\n            if(src[i] != num[j]) {\\n                \\n                while(num[j] != src[i]) \\n                    i += 1;\\n                \\n                while(i > j) {\\n                    swap(src[i], src[i-1]);\\n                    i -= 1;\\n                    cnt += 1;\\n                }\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2242966,
                "title": "c-simple-solution-using-next-permutation",
                "content": "class Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string t=num;\\n        while(k)\\n        {\\n            bool f=next_permutation(num.begin(),num.end());\\n            k--;\\n        }\\n        string temp,org;\\n        \\n        int n=num.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(num[i]!=t[i]){\\n                \\n                temp=num.substr(i);\\n                org=t.substr(i);\\n                break;\\n            }\\n            \\n            \\n        }\\n      \\n            n=org.size();\\n            int ans=0;\\n        int i=0,j=0;\\n        while(i<n)\\n        {\\n            int j=i;\\n            while(temp[j]!=org[i])j++;\\n            ans+=j-i;\\n            while(j!=i){\\n                swap(temp[j-1],temp[j]);\\n                j--;\\n            \\n            }\\n            i++;\\n            \\n        }\\n        \\n        \\n        \\n       \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string t=num;\\n        while(k)\\n        {\\n            bool f=next_permutation(num.begin(),num.end());\\n            k--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2193920,
                "title": "1850-minimum-adjacent-swaps-to-reach-the-kth-smallest-number-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n      int l=num.length();\\n      string s=num;\\n        \\n        while(k--)\\n        next_permutation(num.begin(),num.end());\\n        \\n            \\n        \\n   \\n     int ct=0;\\n       \\n        for(int i=0;i<num.length();i++)\\n        {\\n            \\n            if(num[i]!=s[i])\\n            {  int j=i+1;\\n                for(j=i+1;j<num.length();j++)\\n                {\\n                    \\n                    if(num[i]==s[j])\\n                        break;\\n                }\\n                \\n             \\n              for(int l=j;l>i;l--)\\n              {\\n                  ct++;\\n                  swap(s[l],s[l-1]);\\n              }\\n            }\\n            \\n        }\\n            \\n   return ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n      int l=num.length();\\n      string s=num;\\n        \\n        while(k--)\\n        next_permutation(num.begin(),num.end());\\n        \\n            \\n        \\n   \\n     int ct=0;\\n       \\n        for(int i=0;i<num.length();i++)\\n        {\\n            \\n            if(num[i]!=s[i])\\n            {  int j=i+1;\\n                for(j=i+1;j<num.length();j++)\\n                {\\n                    \\n                    if(num[i]==s[j])\\n                        break;\\n                }\\n                \\n             \\n              for(int l=j;l>i;l--)\\n              {\\n                  ct++;\\n                  swap(s[l],s[l-1]);\\n              }\\n            }\\n            \\n        }\\n            \\n   return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2180061,
                "title": "c",
                "content": "```\\npublic class Solution\\n{\\n    public int GetMinSwaps(string num, int k)\\n    {\\n        char[] characters = num.ToCharArray();\\n        for (int index = 0; index < k; index++)\\n        {\\n            NextPermutation();\\n        }\\n\\n        return GetNumberOfSwaps();\\n\\n        void NextPermutation()\\n        {\\n            int n = characters.Length;\\n            for (int left = n - 2; left >= 0; left--)\\n            {\\n                if (characters[left] >= characters[left + 1]) continue;\\n\\n                int right = n - 1;\\n                while (characters[right] <= characters[left])\\n                {\\n                    right--;\\n                }\\n\\n                (characters[left], characters[right]) = (characters[right], characters[left]);\\n                Array.Reverse(characters, left + 1, n - left - 1);\\n                return;\\n            }\\n        }\\n\\n        int GetNumberOfSwaps()\\n        {\\n            int numberOfSwaps = 0;\\n            for (int left = 0; left < num.Length; left++)\\n            {\\n                int right = left;\\n                while (num[left] != characters[right])\\n                {\\n                    right++;\\n                }\\n\\n                while (right != left)\\n                {\\n                    (characters[right - 1], characters[right]) = (characters[right], characters[right - 1]);\\n                    right--;\\n                    numberOfSwaps++;\\n                }\\n            }\\n\\n            return numberOfSwaps;\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int GetMinSwaps(string num, int k)\\n    {\\n        char[] characters = num.ToCharArray();\\n        for (int index = 0; index < k; index++)\\n        {\\n            NextPermutation();\\n        }\\n\\n        return GetNumberOfSwaps();\\n\\n        void NextPermutation()\\n        {\\n            int n = characters.Length;\\n            for (int left = n - 2; left >= 0; left--)\\n            {\\n                if (characters[left] >= characters[left + 1]) continue;\\n\\n                int right = n - 1;\\n                while (characters[right] <= characters[left])\\n                {\\n                    right--;\\n                }\\n\\n                (characters[left], characters[right]) = (characters[right], characters[left]);\\n                Array.Reverse(characters, left + 1, n - left - 1);\\n                return;\\n            }\\n        }\\n\\n        int GetNumberOfSwaps()\\n        {\\n            int numberOfSwaps = 0;\\n            for (int left = 0; left < num.Length; left++)\\n            {\\n                int right = left;\\n                while (num[left] != characters[right])\\n                {\\n                    right++;\\n                }\\n\\n                while (right != left)\\n                {\\n                    (characters[right - 1], characters[right]) = (characters[right], characters[right - 1]);\\n                    right--;\\n                    numberOfSwaps++;\\n                }\\n            }\\n\\n            return numberOfSwaps;\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2169186,
                "title": "c-easy-approach",
                "content": "````\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string original = num;\\n        \\n        while(k--) {\\n            next_permutation(num.begin(), num.end());\\n        }\\n        \\n        return minSteps(original, num);\\n    }\\n    int minSteps(string s1, string s2){\\n        int count=0;\\n        int i=0;\\n        int j=0;\\n        \\n        int size=s1.length();\\n        \\n        while(i<size){\\n            j=i;\\n            while(s1[j]!=s2[i])j++;\\n            while (i < j) {\\n                swap(s1[j], s1[j-1]);\\n                j--;\\n                count++;\\n            }\\n            i++;\\n        }\\n        return count;\\n        }\\n    \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string original = num;\\n        \\n        while(k--) {\\n            next_permutation(num.begin(), num.end());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1993754,
                "title": "rust-next-permute",
                "content": "```rust\\n\\nimpl Solution {\\n    pub fn get_min_swaps(num: String, k: i32) -> i32 {\\n        let mut original: Vec<_> = num.into_bytes();\\n        let mut permute = original.clone();\\n\\n        for _ in 0..k {\\n            Self::next_permutation(&mut permute);\\n        }\\n\\n        let mut res = 0;\\n\\n        for i in 0..original.len() {\\n            if original[i] == permute[i] {\\n                continue;\\n            }\\n\\n            let mut j = i + 1;\\n            while original[j] != permute[j] {\\n                j += 1;\\n            }\\n\\n            while j > i {\\n                original.swap(j - 1, j);\\n                j -= 1;\\n                res += 1;\\n            }\\n        }\\n\\n        res\\n    }\\n\\n    fn next_permutation(chars: &mut Vec<u8>) {\\n        let mut index = chars.len() - 1;\\n        while index > 0 {\\n            if chars[index] > chars[index - 1] {\\n                break;\\n            }\\n\\n            index -= 1;\\n        }\\n\\n        let mut swap_index = chars.len() - 1;\\n        while swap_index >= index {\\n            if chars[swap_index] > chars[index - 1] {\\n                break;\\n            }\\n\\n            swap_index -= 1;\\n        }\\n\\n        chars.swap(index - 1, swap_index);\\n        chars[index..].reverse();\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```rust\\n\\nimpl Solution {\\n    pub fn get_min_swaps(num: String, k: i32) -> i32 {\\n        let mut original: Vec<_> = num.into_bytes();\\n        let mut permute = original.clone();\\n\\n        for _ in 0..k {\\n            Self::next_permutation(&mut permute);\\n        }\\n\\n        let mut res = 0;\\n\\n        for i in 0..original.len() {\\n            if original[i] == permute[i] {\\n                continue;\\n            }\\n\\n            let mut j = i + 1;\\n            while original[j] != permute[j] {\\n                j += 1;\\n            }\\n\\n            while j > i {\\n                original.swap(j - 1, j);\\n                j -= 1;\\n                res += 1;\\n            }\\n        }\\n\\n        res\\n    }\\n\\n    fn next_permutation(chars: &mut Vec<u8>) {\\n        let mut index = chars.len() - 1;\\n        while index > 0 {\\n            if chars[index] > chars[index - 1] {\\n                break;\\n            }\\n\\n            index -= 1;\\n        }\\n\\n        let mut swap_index = chars.len() - 1;\\n        while swap_index >= index {\\n            if chars[swap_index] > chars[index - 1] {\\n                break;\\n            }\\n\\n            swap_index -= 1;\\n        }\\n\\n        chars.swap(index - 1, swap_index);\\n        chars[index..].reverse();\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1911755,
                "title": "javascript-iterative-91-time-64-space",
                "content": "```\\nvar getMinSwaps = function(num, k) {\\n    let digits = [...num];\\n    const swap = (idx1, idx2) => {\\n        [digits[idx1], digits[idx2]] = [digits[idx2], digits[idx1]];\\n    }\\n    \\n    // Find the next wonderful permutation.\\n    function permutation() {\\n        for (let i = digits.length - 1; i >= 1; i--) {\\n            // Find the first i that is greater than i - 1.\\n            // When that i is found, this means all digits from i to the end are in descending order.\\n            if (digits[i] > digits[i - 1]) {\\n                // Swap the i - 1 digit with the smallest digit larger than i - 1 (see below).\\n                swap(i - 1, nextLarger(i, digits[i - 1]));\\n                reverse(i, digits.length - 1);\\n                return;\\n            }\\n        }\\n    }\\n\\n    // Since all digits from idx onwards are in descending order, \\n\\t// find and return the index of the last number that is greater than the currentVal (which represents the value of i - 1).\\n    const nextLarger = (idx, currentVal) => {\\n        let nextLargerIdx = idx;\\n        for (let i = idx; i < digits.length; i++) {\\n            if (digits[i] > currentVal) {\\n                nextLargerIdx = i;\\n            } else break;\\n        }\\n        return nextLargerIdx;\\n    }\\n    \\n    // Once nextLarger is found, swap i - 1 with the nextLarger index. \\n    // This way, the new i - 1 value is guaranteed to be the next smallest digit larger than the old i - 1 value.\\n    // Moreover, the rest of the array from i to the end is still in descending order.\\n    // Now reverse the rest of the array so that it will be in ascending order.\\n    const reverse = (start, end) => {\\n        while (start < end) {\\n            swap(start, end);\\n            start++, end--;\\n        }\\n    }\\n    \\n    // Find the next wonderful permutation k times.\\n    while (k--) permutation();\\n\\n    // Count the number of swaps.\\n    let swapCount = 0;\\n    for (let i = 0; i < num.length; i++) {\\n        if (num[i] != digits[i]) {\\n            let j = i;\\n            while (num[i] != digits[j]) j++;\\n            while (i < j) {\\n                swap(j, j - 1);\\n                j--;\\n                swapCount++;\\n            }\\n        }\\n    }\\n    return swapCount;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar getMinSwaps = function(num, k) {\\n    let digits = [...num];\\n    const swap = (idx1, idx2) => {\\n        [digits[idx1], digits[idx2]] = [digits[idx2], digits[idx1]];\\n    }\\n    \\n    // Find the next wonderful permutation.\\n    function permutation() {\\n        for (let i = digits.length - 1; i >= 1; i--) {\\n            // Find the first i that is greater than i - 1.\\n            // When that i is found, this means all digits from i to the end are in descending order.\\n            if (digits[i] > digits[i - 1]) {\\n                // Swap the i - 1 digit with the smallest digit larger than i - 1 (see below).\\n                swap(i - 1, nextLarger(i, digits[i - 1]));\\n                reverse(i, digits.length - 1);\\n                return;\\n            }\\n        }\\n    }\\n\\n    // Since all digits from idx onwards are in descending order, \\n\\t// find and return the index of the last number that is greater than the currentVal (which represents the value of i - 1).\\n    const nextLarger = (idx, currentVal) => {\\n        let nextLargerIdx = idx;\\n        for (let i = idx; i < digits.length; i++) {\\n            if (digits[i] > currentVal) {\\n                nextLargerIdx = i;\\n            } else break;\\n        }\\n        return nextLargerIdx;\\n    }\\n    \\n    // Once nextLarger is found, swap i - 1 with the nextLarger index. \\n    // This way, the new i - 1 value is guaranteed to be the next smallest digit larger than the old i - 1 value.\\n    // Moreover, the rest of the array from i to the end is still in descending order.\\n    // Now reverse the rest of the array so that it will be in ascending order.\\n    const reverse = (start, end) => {\\n        while (start < end) {\\n            swap(start, end);\\n            start++, end--;\\n        }\\n    }\\n    \\n    // Find the next wonderful permutation k times.\\n    while (k--) permutation();\\n\\n    // Count the number of swaps.\\n    let swapCount = 0;\\n    for (let i = 0; i < num.length; i++) {\\n        if (num[i] != digits[i]) {\\n            let j = i;\\n            while (num[i] != digits[j]) j++;\\n            while (i < j) {\\n                swap(j, j - 1);\\n                j--;\\n                swapCount++;\\n            }\\n        }\\n    }\\n    return swapCount;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1903965,
                "title": "c-using-stl",
                "content": "class Solution {\\npublic:\\n\\n    int getMinSwaps(string s, int k) {\\n        string res=s;\\n        while(k--)\\n        {\\n            next_permutation(s.begin(),s.end());\\n            }\\n        int count=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            int j=i;\\n            if(res[i]!=s[j])\\n            {\\n                while(res[i]!=s[j])i++;\\n                while(i>j)\\n                {\\n                    swap(res[i],res[i-1]);\\n                        i--;\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int getMinSwaps(string s, int k) {\\n        string res=s;\\n        while(k--)\\n        {\\n            next_permutation(s.begin(),s.end());\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1901038,
                "title": "javascript-solution-next-permutation",
                "content": "Initially, I was thinking of BFS. However, after looking at the first hint, I used what I learned from the Next Permutation problem to create the kth smallest wonderful number. Then, I compared the digits to the original number and if there was a mismatch, I initiated necessary the swaps and tallied up the total count of swaps.\\n\\n\\n```\\nvar getMinSwaps = function(num, k) {\\n    const n = num.length;\\n    \\n    let swapDigs = num.split(\"\");\\n    \\n    for (let i = 0; i < k; ++i) {\\n        \\n        for (let j = n - 2; j >= 0; --j) {\\n            const currDig = swapDigs[j];\\n            const prevDig = swapDigs[j + 1];\\n            \\n            if (currDig < prevDig) {\\n                let right = n - 1;\\n                \\n                while (right > j && swapDigs[right] <= currDig) --right;  \\n                \\n                [swapDigs[j], swapDigs[right]] = [swapDigs[right], swapDigs[j]];\\n                swapDigs = flip(swapDigs, j + 1, n - 1);\\n                break;\\n            }\\n        }\\n    }\\n    \\n    const origDigs = num.split(\"\");\\n    \\n    let swaps = 0;\\n    \\n    for (let i = 0; i < n; ++i) {\\n        const dig1 = swapDigs[i];\\n        const dig2 = origDigs[i];\\n        \\n        if (dig2 != dig1) {\\n            let j = i + 1;\\n            \\n            while (j < n && origDigs[j] != dig1) j++;\\n            \\n            swaps += (j - i);\\n            origDigs.splice(j, 1);\\n            origDigs.splice(i, 0, dig1);\\n        }\\n    } \\n    \\n    return swaps;\\n    \\n    \\n    function flip(arr, left, right) {\\n        while (left < right) {\\n            [arr[left], arr[right]] = [arr[right], arr[left]];\\n            left++;\\n            right--;\\n        }\\n        \\n        return arr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\nvar getMinSwaps = function(num, k) {\\n    const n = num.length;\\n    \\n    let swapDigs = num.split(\"\");\\n    \\n    for (let i = 0; i < k; ++i) {\\n        \\n        for (let j = n - 2; j >= 0; --j) {\\n            const currDig = swapDigs[j];\\n            const prevDig = swapDigs[j + 1];\\n            \\n            if (currDig < prevDig) {\\n                let right = n - 1;\\n                \\n                while (right > j && swapDigs[right] <= currDig) --right;  \\n                \\n                [swapDigs[j], swapDigs[right]] = [swapDigs[right], swapDigs[j]];\\n                swapDigs = flip(swapDigs, j + 1, n - 1);\\n                break;\\n            }\\n        }\\n    }\\n    \\n    const origDigs = num.split(\"\");\\n    \\n    let swaps = 0;\\n    \\n    for (let i = 0; i < n; ++i) {\\n        const dig1 = swapDigs[i];\\n        const dig2 = origDigs[i];\\n        \\n        if (dig2 != dig1) {\\n            let j = i + 1;\\n            \\n            while (j < n && origDigs[j] != dig1) j++;\\n            \\n            swaps += (j - i);\\n            origDigs.splice(j, 1);\\n            origDigs.splice(i, 0, dig1);\\n        }\\n    } \\n    \\n    return swaps;\\n    \\n    \\n    function flip(arr, left, right) {\\n        while (left < right) {\\n            [arr[left], arr[right]] = [arr[right], arr[left]];\\n            left++;\\n            right--;\\n        }\\n        \\n        return arr;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1900524,
                "title": "simple-c-with-explanation",
                "content": "```\\nclass Solution {\\n  public:\\n    int getMinSwaps(string num, int k) {\\n      string after = num;\\n      while (k--)\\n        nextPermutation(after);\\n      int ret = 0;\\n      while (num != after) {\\n        for (int i = 0; i < num.size(); i++) {\\n          if (num[i] == after[i]) // found not match pos\\n            continue;\\n          for (int j = i+1; j < num.size(); j++) {\\n            // move num[j] backward to num[i], finish one\\n            if (num[j] == after[i]) {\\n              for (int m = j; m > i; m--) {\\n                ret++;\\n                swap(num[m], num[m-1]);\\n              }\\n              break;\\n            }\\n          }\\n          break;\\n        }\\n      }\\n      return ret;\\n    }\\n\\n    void nextPermutation(string& num) {\\n      int i = num.size()-1;\\n      while (i > 0 && num[i-1] >= num[i])\\n        i--;\\n      for (int j = num.size()-1; i > 0 && j >= 0; j--) {\\n        if (num[j] > num[i-1]) {\\n          swap(num[j], num[i-1]);\\n          break;\\n        }\\n      }\\n      reverse(num.begin()+i, num.end());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  public:\\n    int getMinSwaps(string num, int k) {\\n      string after = num;\\n      while (k--)\\n        nextPermutation(after);\\n      int ret = 0;\\n      while (num != after) {\\n        for (int i = 0; i < num.size(); i++) {\\n          if (num[i] == after[i]) // found not match pos\\n            continue;\\n          for (int j = i+1; j < num.size(); j++) {\\n            // move num[j] backward to num[i], finish one\\n            if (num[j] == after[i]) {\\n              for (int m = j; m > i; m--) {\\n                ret++;\\n                swap(num[m], num[m-1]);\\n              }\\n              break;\\n            }\\n          }\\n          break;\\n        }\\n      }\\n      return ret;\\n    }\\n\\n    void nextPermutation(string& num) {\\n      int i = num.size()-1;\\n      while (i > 0 && num[i-1] >= num[i])\\n        i--;\\n      for (int j = num.size()-1; i > 0 && j >= 0; j--) {\\n        if (num[j] > num[i-1]) {\\n          swap(num[j], num[i-1]);\\n          break;\\n        }\\n      }\\n      reverse(num.begin()+i, num.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1892991,
                "title": "c-next-permutation-brute",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string &num, int k) {\\n        //permutation question \\n        int ans = 0 ;\\n        string orginal = num ;\\n        do{\\n            bool bl = next_permutation(begin(num),end(num));\\n        }while(--k); \\n        \\n        for(int idx = num.size()-1;idx>=0;--idx){\\n            int start = -1 ;\\n            for(int i = 0 ; i <= idx ;++i) if(orginal[i] == num[idx]) start = i ;\\n            while(start < num.size()-1 and orginal[idx] != num[idx]){\\n                ++ans ;\\n                swap(orginal[start],orginal[start+1]);\\n                ++start ;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string &num, int k) {\\n        //permutation question \\n        int ans = 0 ;\\n        string orginal = num ;\\n        do{\\n            bool bl = next_permutation(begin(num),end(num));\\n        }while(--k); \\n        \\n        for(int idx = num.size()-1;idx>=0;--idx){\\n            int start = -1 ;\\n            for(int i = 0 ; i <= idx ;++i) if(orginal[i] == num[idx]) start = i ;\\n            while(start < num.size()-1 and orginal[idx] != num[idx]){\\n                ++ans ;\\n                swap(orginal[start],orginal[start+1]);\\n                ++start ;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803043,
                "title": "single-pass-approach-java",
                "content": "before this solution check this out -> https://leetcode.com/problems/next-permutation/\\n\\n```\\n\\tchar[] numbers;\\n    int len;\\n    \\n    public int getMinSwaps(String num, int k) {\\n    \\n        if(num == null || num.length() == 0 || k == 0){\\n            return 0;\\n        }\\n        \\n        len = num.length();\\n        numbers = num.toCharArray();\\n        \\n        nextPermutation(k);\\n        \\n        return countSteps(num);\\n    }\\n    \\n    void nextPermutation(int k){\\n        \\n        for(int p = 0; p < k; p++){\\n            \\n            int i = len - 2;\\n            \\n            while(i >= 0 && numbers[i] >= numbers[i+1]){\\n                i--;\\n            }\\n            \\n            if(i >= 0){\\n                int j = len - 1;\\n                while(numbers[i] >= numbers[j]){\\n                    j--;\\n                }\\n                swap(i, j);\\n            }\\n            \\n            reverse(i + 1);\\n        }\\n    }\\n    \\n    int countSteps(String num){\\n        \\n        int i = 0, j = 0;\\n        int result = 0;\\n        \\n        while(i < len){\\n            j = i;\\n            \\n            while(j < len && numbers[j] != num.charAt(i)){\\n                j++;\\n            }\\n            \\n            while(i < j){\\n                swap(j, j - 1);\\n                j--;\\n                result++;\\n            }\\n            i++;\\n        }\\n        return result;\\n    }\\n    \\n    void reverse(int start){\\n        int s = start, e = len - 1;\\n        while(s < e){\\n            swap(s, e);\\n            s++;\\n            e--;\\n        }\\n    }\\n    \\n    void swap(int a, int b){\\n        if(a == b){\\n            return;\\n        }\\n        char tmp = numbers[a];\\n        numbers[a] = numbers[b];\\n        numbers[b]= tmp;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\tchar[] numbers;\\n    int len;\\n    \\n    public int getMinSwaps(String num, int k) {\\n    \\n        if(num == null || num.length() == 0 || k == 0){\\n            return 0;\\n        }\\n        \\n        len = num.length();\\n        numbers = num.toCharArray();\\n        \\n        nextPermutation(k);\\n        \\n        return countSteps(num);\\n    }\\n    \\n    void nextPermutation(int k){\\n        \\n        for(int p = 0; p < k; p++){\\n            \\n            int i = len - 2;\\n            \\n            while(i >= 0 && numbers[i] >= numbers[i+1]){\\n                i--;\\n            }\\n            \\n            if(i >= 0){\\n                int j = len - 1;\\n                while(numbers[i] >= numbers[j]){\\n                    j--;\\n                }\\n                swap(i, j);\\n            }\\n            \\n            reverse(i + 1);\\n        }\\n    }\\n    \\n    int countSteps(String num){\\n        \\n        int i = 0, j = 0;\\n        int result = 0;\\n        \\n        while(i < len){\\n            j = i;\\n            \\n            while(j < len && numbers[j] != num.charAt(i)){\\n                j++;\\n            }\\n            \\n            while(i < j){\\n                swap(j, j - 1);\\n                j--;\\n                result++;\\n            }\\n            i++;\\n        }\\n        return result;\\n    }\\n    \\n    void reverse(int start){\\n        int s = start, e = len - 1;\\n        while(s < e){\\n            swap(s, e);\\n            s++;\\n            e--;\\n        }\\n    }\\n    \\n    void swap(int a, int b){\\n        if(a == b){\\n            return;\\n        }\\n        char tmp = numbers[a];\\n        numbers[a] = numbers[b];\\n        numbers[b]= tmp;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1794646,
                "title": "c-24ms-95-simple-easy-small",
                "content": "Runtime: 24 ms, faster than 94.95% of C++ online submissions for Minimum Adjacent Swaps to Reach the Kth Smallest Number.\\nMemory Usage: 6.5 MB, less than 75.47% of C++ online submissions for Minimum Adjacent Swaps to Reach the Kth Smallest Number.\\n```\\nclass Solution {\\npublic:\\n  int getMinSwaps(string num, int k) {\\n    string s = num;\\n    int ans = 0;\\n    while(k--) next_permutation(s.begin(), s.end());\\n    \\n    \\n    for(int i = 0; i != s.size(); i++)\\n      if(s[i] != num[i]){\\n        int j = i + 1;\\n        while(s[j] != num[i]) j++;\\n        ans += j - i;\\n        while(j-- != i) swap(s[j], s[j+1]);\\n      }\\n    \\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int getMinSwaps(string num, int k) {\\n    string s = num;\\n    int ans = 0;\\n    while(k--) next_permutation(s.begin(), s.end());\\n    \\n    \\n    for(int i = 0; i != s.size(); i++)\\n      if(s[i] != num[i]){\\n        int j = i + 1;\\n        while(s[j] != num[i]) j++;\\n        ans += j - i;\\n        while(j-- != i) swap(s[j], s[j+1]);\\n      }\\n    \\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1763834,
                "title": "c-75-faster-sol-using-next-permutation",
                "content": "class Solution {\\npublic:\\n```\\n    int getMinSwaps(string num, int k) {\\n        vector<int>org;\\n        vector<int>dup;\\n        int sum=0;\\n        int n=num.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            org.push_back(num[i]);\\n        }\\n        for(int i=0;i<org.size();i++)\\n        {\\n            dup.push_back(org[i]);\\n        }\\n        while(k)\\n        {\\n            next_permutation(org.begin(),org.end());\\n            k--;\\n        }\\n       for(int i=0;i<org.size();i++)\\n       {\\n           if(org[i]==dup[i])\\n               continue;\\n           else{\\n               int j=i+1;\\n               while(org[i]!=dup[i]){\\n                   swap(dup[i],dup[j]);\\n                   j++;\\n                   sum++;\\n               }\\n           }\\n       }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    int getMinSwaps(string num, int k) {\\n        vector<int>org;\\n        vector<int>dup;\\n        int sum=0;\\n        int n=num.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            org.push_back(num[i]);\\n        }\\n        for(int i=0;i<org.size();i++)\\n        {\\n            dup.push_back(org[i]);\\n        }\\n        while(k)\\n        {\\n            next_permutation(org.begin(),org.end());\\n            k--;\\n        }\\n       for(int i=0;i<org.size();i++)\\n       {\\n           if(org[i]==dup[i])\\n               continue;\\n           else{\\n               int j=i+1;\\n               while(org[i]!=dup[i]){\\n                   swap(dup[i],dup[j]);\\n                   j++;\\n                   sum++;\\n               }\\n           }\\n       }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1762127,
                "title": "using-next-permutation-c-brute-force",
                "content": "class Solution {\\npublic:\\n  int getMinSwaps(string num, int k) {\\n       \\n\\t   string t = num;\\n        for(int i=0;i<k;i++){\\n            next_permutation(num.begin(),num.end());\\n        }\\n        \\n        int c = 0;\\n        for(int i=0;i<num.size();i++){\\n            if(num[i]!=t[i]){\\n                int j = i;\\n                while(t[j]!=num[i]) j++;\\n                while(t[i]!=num[i]){\\n                    swap(t[j],t[j-1]);\\n                    c++;\\n                    j--;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Probability and Statistics"
                ],
                "code": "class Solution {\\npublic:\\n  int getMinSwaps(string num, int k) {\\n       \\n\\t   string t = num;\\n        for(int i=0;i<k;i++){\\n            next_permutation(num.begin(),num.end());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1700251,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        int n = num.length();\\n        string temp = num;\\n        \\n        while(k--) {\\n            int id = n - 2;\\n            char prev = num[n - 1];\\n            map<char, int> mp;\\n            mp[prev] = n - 1;\\n            while (id >= 0 && prev <= num[id]) {\\n                //cout << id << \":\" << num[id] << endl;\\n                mp[num[id]] = id;\\n                prev = num[id];\\n                id--;\\n            }\\n            auto it = mp.upper_bound(num[id]);\\n            swap(num[id], num[it->second]);\\n            sort(num.begin() + id + 1, num.end());\\n            //cout << k << \":\" << num << endl;\\n        }\\n        \\n        int id = 0, count = 0;\\n        for (; id < num.length(); id++) {\\n            if (temp[id] != num[id])   break;\\n        }\\n        \\n        for (int i = id; i < num.size(); i++) {\\n            //cout << nums[i] << endl;\\n            auto it = find(temp.begin() + i, temp.end(), num[i]);\\n            count += it - (temp.begin() + i);\\n            temp.erase(it);\\n            temp.insert(temp.begin() + i, num[id]);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        int n = num.length();\\n        string temp = num;\\n        \\n        while(k--) {\\n            int id = n - 2;\\n            char prev = num[n - 1];\\n            map<char, int> mp;\\n            mp[prev] = n - 1;\\n            while (id >= 0 && prev <= num[id]) {\\n                //cout << id << \":\" << num[id] << endl;\\n                mp[num[id]] = id;\\n                prev = num[id];\\n                id--;\\n            }\\n            auto it = mp.upper_bound(num[id]);\\n            swap(num[id], num[it->second]);\\n            sort(num.begin() + id + 1, num.end());\\n            //cout << k << \":\" << num << endl;\\n        }\\n        \\n        int id = 0, count = 0;\\n        for (; id < num.length(); id++) {\\n            if (temp[id] != num[id])   break;\\n        }\\n        \\n        for (int i = id; i < num.size(); i++) {\\n            //cout << nums[i] << endl;\\n            auto it = find(temp.begin() + i, temp.end(), num[i]);\\n            count += it - (temp.begin() + i);\\n            temp.erase(it);\\n            temp.insert(temp.begin() + i, num[id]);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1678899,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string s, int k) {\\n        int n=s.size();\\n        string str=s;\\n        int count=0;\\n        while(k--) next_permutation(s.begin(),s.end());\\n        \\n        for(int i=0;i<n;i++){\\n            if(s[i]!=str[i]){\\n                int j=i+1;\\n                while(n>j and s[i]!=str[j]) j++;\\n                \\n                while(j>i){\\n                    swap(str[j],str[--j]); \\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string s, int k) {\\n        int n=s.size();\\n        string str=s;\\n        int count=0;\\n        while(k--) next_permutation(s.begin(),s.end());\\n        \\n        for(int i=0;i<n;i++){\\n            if(s[i]!=str[i]){\\n                int j=i+1;\\n                while(n>j and s[i]!=str[j]) j++;\\n                \\n                while(j>i){\\n                    swap(str[j],str[--j]); \\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1659637,
                "title": "go-brute",
                "content": "```\\nfunc getMinSwaps(num string, k int) int {\\n    old := num\\n    for k > 0 {\\n        num = next(num)\\n        k--\\n    }\\n    return swap(old, num)\\n}\\n\\nfunc next(s string) string {\\n    var res []byte\\n    var list []byte\\n    for i := len(s) - 1; i >= 1; i-- {\\n        list = append(list, s[i])\\n        if s[i] > s[i - 1] {\\n            list = append(list, s[i - 1])\\n            res = []byte(s[:i - 1])\\n            sort.Slice(list, func(i int, j int) bool {\\n                return list[i] < list[j]\\n            })\\n            \\n            tar := sort.Search(len(list), func(j int) bool {\\n                return list[j] > s[i - 1]\\n            })\\n            res = append(res, list[tar])\\n            res = append(res, list[:tar]...)\\n            res = append(res, list[tar + 1:]...)\\n            break\\n        }\\n    }\\n    return string(res)\\n}\\n\\nfunc swap(a string, b string) int {\\n    for i := 0; i < len(a); i++ {\\n        if a[i] != b[i] {\\n            for j := i + 1; j < len(b); j++ {\\n                if b[j] == a[i] {\\n                    return j - i + swap(a[i + 1:], b[i:j] + b[j + 1:])\\n                }\\n            }\\n        }\\n    }\\n    return 0\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc getMinSwaps(num string, k int) int {\\n    old := num\\n    for k > 0 {\\n        num = next(num)\\n        k--\\n    }\\n    return swap(old, num)\\n}\\n\\nfunc next(s string) string {\\n    var res []byte\\n    var list []byte\\n    for i := len(s) - 1; i >= 1; i-- {\\n        list = append(list, s[i])\\n        if s[i] > s[i - 1] {\\n            list = append(list, s[i - 1])\\n            res = []byte(s[:i - 1])\\n            sort.Slice(list, func(i int, j int) bool {\\n                return list[i] < list[j]\\n            })\\n            \\n            tar := sort.Search(len(list), func(j int) bool {\\n                return list[j] > s[i - 1]\\n            })\\n            res = append(res, list[tar])\\n            res = append(res, list[:tar]...)\\n            res = append(res, list[tar + 1:]...)\\n            break\\n        }\\n    }\\n    return string(res)\\n}\\n\\nfunc swap(a string, b string) int {\\n    for i := 0; i < len(a); i++ {\\n        if a[i] != b[i] {\\n            for j := i + 1; j < len(b); j++ {\\n                if b[j] == a[i] {\\n                    return j - i + swap(a[i + 1:], b[i:j] + b[j + 1:])\\n                }\\n            }\\n        }\\n    }\\n    return 0\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1653031,
                "title": "c-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        \\n        //next permutation is alwys greater than the previous one\\n        //e.g. first permutation = 12345 -> last perm 54321\\n        string original=num;\\n        while(k--) next_permutation(num.begin(),num.end());\\n        \\n        //bring every element from initial position to desired position\\n        int count=0;\\n        for(int j=0;j<num.size();j++)\\n        {\\n            if(num[j]!=original[j])\\n            {\\n                int i=j;\\n                while(original[i]!=num[j]) i++;\\n                while(num[j]!=original[j])\\n                {\\n                    swap(original[i],original[i-1]);\\n                    count++;\\n                    i--;\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Probability and Statistics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        \\n        //next permutation is alwys greater than the previous one\\n        //e.g. first permutation = 12345 -> last perm 54321\\n        string original=num;\\n        while(k--) next_permutation(num.begin(),num.end());\\n        \\n        //bring every element from initial position to desired position\\n        int count=0;\\n        for(int j=0;j<num.size();j++)\\n        {\\n            if(num[j]!=original[j])\\n            {\\n                int i=j;\\n                while(original[i]!=num[j]) i++;\\n                while(num[j]!=original[j])\\n                {\\n                    swap(original[i],original[i-1]);\\n                    count++;\\n                    i--;\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1632299,
                "title": "java-next-permutation-25-lines-comments",
                "content": "We need to find the next permutation, according to [Wikipedia](https://en.wikipedia.org/wiki/Permutation), this is how you find it: \\n1. Find the largest index k such that a[k] < a[k + 1]. If no such index exists, the permutation is the last permutation.\\n2. Find the largest index l greater than k such that a[k] < a[l].\\n3. Swap the value of a[k] with that of a[l].\\n4. Reverse the sequence from a[k + 1] up to and including the final element a[n].\\n\\nYou can also practice next permutation at https://leetcode.com/problems/next-permutation/. In fact, I recommend that you do that question first before even attempting this question.\\n\\nThe below is my solution: \\n```\\nclass Solution {\\n    public int getMinSwaps(String num, int k) {\\n        char[] result = num.toCharArray();\\n        while(--k >= 0){ //next permutation, do it k times\\n            int swap = result.length - 2; \\n            while(swap >= 0 && result[swap] >= result[swap + 1]) --swap;\\n            int pair = result.length - 1;\\n            while(pair > swap && result[swap] >= result[pair]) --pair;\\n            swap(result, swap, pair);\\n            int lo = swap + 1;\\n            int hi = result.length - 1;\\n            while(lo < hi) swap(result, lo++, hi--);\\n        }\\n\\n\\n        int ans = 0;\\n        char[] arr = num.toCharArray();\\n        for (int i = 0; i < arr.length; i++){\\n            if (arr[i] == result[i]) continue;\\n            int j = i;\\n            while(arr[i] != result[j]) ++j; //find the matching character \\n            ans += j - i; //number of swap needed to make it match\\n            while(--j >= i) swap(result, j, j + 1); //match it\\n        }\\n\\n        return ans;\\n    }\\n\\n    private static void swap(char[] arr, int a, int b){\\n        char tmp = arr[a];\\n        arr[a] = arr[b];\\n        arr[b] = tmp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int getMinSwaps(String num, int k) {\\n        char[] result = num.toCharArray();\\n        while(--k >= 0){ //next permutation, do it k times\\n            int swap = result.length - 2; \\n            while(swap >= 0 && result[swap] >= result[swap + 1]) --swap;\\n            int pair = result.length - 1;\\n            while(pair > swap && result[swap] >= result[pair]) --pair;\\n            swap(result, swap, pair);\\n            int lo = swap + 1;\\n            int hi = result.length - 1;\\n            while(lo < hi) swap(result, lo++, hi--);\\n        }\\n\\n\\n        int ans = 0;\\n        char[] arr = num.toCharArray();\\n        for (int i = 0; i < arr.length; i++){\\n            if (arr[i] == result[i]) continue;\\n            int j = i;\\n            while(arr[i] != result[j]) ++j; //find the matching character \\n            ans += j - i; //number of swap needed to make it match\\n            while(--j >= i) swap(result, j, j + 1); //match it\\n        }\\n\\n        return ans;\\n    }\\n\\n    private static void swap(char[] arr, int a, int b){\\n        char tmp = arr[a];\\n        arr[a] = arr[b];\\n        arr[b] = tmp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1613583,
                "title": "swift-solution-with-next-permutation-and-swapping",
                "content": "```\\nclass Solution {\\n    \\n    // MARK: - Reverse\\n    \\n    func reverse(_ num: inout [Character], _ i: Int) {\\n        var i = i\\n        var j = num.count - 1\\n        \\n        while i < j {\\n            num.swapAt(i, j)\\n            i += 1\\n            j -= 1\\n        }\\n    }\\n    \\n    // MARK: - Next Permutation\\n    \\n    func nextPermutation(_ num: inout [Character]) {\\n        if num.count == 0 {\\n            return\\n        }\\n        \\n        var i = num.count - 1\\n        \\n        while i >= 1 {\\n            if num[i] > num[i - 1] {\\n                reverse(&num, i)\\n                for j in i..<num.count {\\n                    if num[j] > num[i - 1] {\\n                        num.swapAt(j, i - 1)\\n                        return\\n                    }\\n                }\\n            }\\n            i -= 1\\n        }\\n        \\n        for i in 1..<num.count {\\n            if num[num.count - i - 1] > num[num.count - i - 2] {\\n                reverse(&num, i)\\n                for j in (num.count - i - 1)..<num.count {\\n                    if num[j] > num[num.count - i - 2] {\\n                        num.swapAt(j, num.count - i - 2)\\n                        return\\n                    }\\n                }\\n            }\\n        }\\n        \\n        reverse(&num, 0)\\n    }\\n    \\n    // MARK: - Min Swaps\\n    \\n    func minSwaps(_ nums: inout [Character], _ target: [Character], _ size: Int) -> Int {\\n        var j = 0\\n        var swaps = 0\\n        \\n        for i in 0..<size {\\n            j = i\\n            while nums[j] != target[i] {\\n                j += 1\\n            }\\n            \\n            while i < j {\\n                nums.swapAt(j, j - 1)\\n                j -= 1\\n                swaps += 1\\n            }\\n        }\\n        \\n        return swaps\\n    }\\n    \\n    // MARK: - Get Min Swaps\\n    \\n    func getMinSwaps(_ num: String, _ k: Int) -> Int {\\n        \\n        var target = Array(num)\\n        \\n        for i in 0..<k {\\n            nextPermutation(&target)\\n        }\\n        \\n        var nums = Array(num)\\n        \\n        return minSwaps(&nums, target, num.count)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    \\n    // MARK: - Reverse\\n    \\n    func reverse(_ num: inout [Character], _ i: Int) {\\n        var i = i\\n        var j = num.count - 1\\n        \\n        while i < j {\\n            num.swapAt(i, j)\\n            i += 1\\n            j -= 1\\n        }\\n    }\\n    \\n    // MARK: - Next Permutation\\n    \\n    func nextPermutation(_ num: inout [Character]) {\\n        if num.count == 0 {\\n            return\\n        }\\n        \\n        var i = num.count - 1\\n        \\n        while i >= 1 {\\n            if num[i] > num[i - 1] {\\n                reverse(&num, i)\\n                for j in i..<num.count {\\n                    if num[j] > num[i - 1] {\\n                        num.swapAt(j, i - 1)\\n                        return\\n                    }\\n                }\\n            }\\n            i -= 1\\n        }\\n        \\n        for i in 1..<num.count {\\n            if num[num.count - i - 1] > num[num.count - i - 2] {\\n                reverse(&num, i)\\n                for j in (num.count - i - 1)..<num.count {\\n                    if num[j] > num[num.count - i - 2] {\\n                        num.swapAt(j, num.count - i - 2)\\n                        return\\n                    }\\n                }\\n            }\\n        }\\n        \\n        reverse(&num, 0)\\n    }\\n    \\n    // MARK: - Min Swaps\\n    \\n    func minSwaps(_ nums: inout [Character], _ target: [Character], _ size: Int) -> Int {\\n        var j = 0\\n        var swaps = 0\\n        \\n        for i in 0..<size {\\n            j = i\\n            while nums[j] != target[i] {\\n                j += 1\\n            }\\n            \\n            while i < j {\\n                nums.swapAt(j, j - 1)\\n                j -= 1\\n                swaps += 1\\n            }\\n        }\\n        \\n        return swaps\\n    }\\n    \\n    // MARK: - Get Min Swaps\\n    \\n    func getMinSwaps(_ num: String, _ k: Int) -> Int {\\n        \\n        var target = Array(num)\\n        \\n        for i in 0..<k {\\n            nextPermutation(&target)\\n        }\\n        \\n        var nums = Array(num)\\n        \\n        return minSwaps(&nums, target, num.count)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1604524,
                "title": "golang-brute-force",
                "content": "```go\\nfunc getMinSwaps(num string, k int) int {\\n\\tafterSwap := []rune(num)\\n\\tfor i := 0; i < k; i++ {\\n\\t\\tnextBigger(afterSwap)\\n\\t}\\n\\tbeforeSwap := []rune(num)\\n\\tswaps := 0\\n\\tfor i := 0; i < len(afterSwap); i++ {\\n\\t\\tif afterSwap[i] == beforeSwap[i] {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tfor j := i+1; j < len(afterSwap); j++ {\\n\\t\\t\\tif afterSwap[i] == beforeSwap[j] {\\n\\t\\t\\t\\t// bubble j to i, need swap j-i times\\n\\t\\t\\t\\tswaps += j-i\\n\\t\\t\\t\\tcopy(beforeSwap[i+1:], beforeSwap[i:j])\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn swaps\\n}\\n\\nfunc nextBigger(num []rune) {\\n\\tmaxValue := num[len(num)-1]\\n\\tcounter := make([]rune, 10)\\n\\tcounter[maxValue-\\'0\\']++\\n\\tfor i := len(num)-2; i >= 0; i-- {\\n\\t\\tcounter[num[i]-\\'0\\']++\\n\\t\\tif num[i] >= maxValue {\\n\\t\\t\\t// greater or equal, refresh maxValue\\n\\t\\t\\tmaxValue = num[i]\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\t// less than max value, move next bigger value to num[i]\\n\\t\\tnext := num[i]+1\\n\\t\\tfor counter[next-\\'0\\'] == 0 {\\n\\t\\t\\tnext++\\n\\t\\t}\\n\\t\\tnum[i] = next\\n\\t\\tcounter[next-\\'0\\']--\\n\\t\\t// place other indexes\\n\\t\\tfor val, idx := \\'0\\', i+1; counter[val-\\'0\\'] != 0 || val < \\'9\\'; {\\n\\t\\t\\tif counter[val-\\'0\\'] != 0 {\\n\\t\\t\\t\\tnum[idx] = val\\n\\t\\t\\t\\tcounter[val-\\'0\\']--\\n\\t\\t\\t\\tidx++\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tval++\\n\\t\\t}\\n\\t\\tbreak\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc getMinSwaps(num string, k int) int {\\n\\tafterSwap := []rune(num)\\n\\tfor i := 0; i < k; i++ {\\n\\t\\tnextBigger(afterSwap)\\n\\t}\\n\\tbeforeSwap := []rune(num)\\n\\tswaps := 0\\n\\tfor i := 0; i < len(afterSwap); i++ {\\n\\t\\tif afterSwap[i] == beforeSwap[i] {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tfor j := i+1; j < len(afterSwap); j++ {\\n\\t\\t\\tif afterSwap[i] == beforeSwap[j] {\\n\\t\\t\\t\\t// bubble j to i, need swap j-i times\\n\\t\\t\\t\\tswaps += j-i\\n\\t\\t\\t\\tcopy(beforeSwap[i+1:], beforeSwap[i:j])\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn swaps\\n}\\n\\nfunc nextBigger(num []rune) {\\n\\tmaxValue := num[len(num)-1]\\n\\tcounter := make([]rune, 10)\\n\\tcounter[maxValue-\\'0\\']++\\n\\tfor i := len(num)-2; i >= 0; i-- {\\n\\t\\tcounter[num[i]-\\'0\\']++\\n\\t\\tif num[i] >= maxValue {\\n\\t\\t\\t// greater or equal, refresh maxValue\\n\\t\\t\\tmaxValue = num[i]\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\t// less than max value, move next bigger value to num[i]\\n\\t\\tnext := num[i]+1\\n\\t\\tfor counter[next-\\'0\\'] == 0 {\\n\\t\\t\\tnext++\\n\\t\\t}\\n\\t\\tnum[i] = next\\n\\t\\tcounter[next-\\'0\\']--\\n\\t\\t// place other indexes\\n\\t\\tfor val, idx := \\'0\\', i+1; counter[val-\\'0\\'] != 0 || val < \\'9\\'; {\\n\\t\\t\\tif counter[val-\\'0\\'] != 0 {\\n\\t\\t\\t\\tnum[idx] = val\\n\\t\\t\\t\\tcounter[val-\\'0\\']--\\n\\t\\t\\t\\tidx++\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tval++\\n\\t\\t}\\n\\t\\tbreak\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1531996,
                "title": "optimal-typescript-solution",
                "content": "**Runtime: 264 ms, faster than 100.00% of TypeScript online submissions for Minimum Adjacent Swaps to Reach the Kth Smallest Number.\\nMemory Usage: 47.1 MB, less than 100.00% of TypeScript online submissions for Minimum Adjacent Swaps to Reach the Kth Smallest Number.**\\n\\n```\\nfunction getMinSwaps(num: string, k: number): number {\\n    let nums: number[] = num.split(\"\").map(a => parseInt(a));\\n    let permutation: number[] = [...nums];\\n\\n    for (let i = 0; i < k; i++) {\\n        permutation = findSmallestGreater(permutation);\\n    }\\n\\n    return findMoves(nums, permutation);\\n};\\n\\nfunction findSmallestGreater(permutation: number[]): number[] {\\n    let buffer: number[] = [permutation[permutation.length - 1]];\\n    let index: number = permutation.length - 2;\\n    let num: number;\\n\\n    // find the place where the sub array should be updated\\n    for (; index >= 0; index--) {\\n        num = permutation[index];\\n\\n        if (num < buffer[buffer.length - 1]) {\\n            break;\\n        }\\n\\n        buffer.push(num);\\n    }\\n\\n    // remove the updated part\\n    permutation = permutation.slice(0, index);\\n\\n    // arrange the updated part\\n    for (let i = 0; i < buffer.length; i++) {\\n        if (buffer[i] > num) {\\n            permutation.push(buffer[i]);\\n            buffer[i] = num;\\n            break;\\n        }\\n    }\\n\\n    // append to the original array\\n    permutation.push(...buffer);\\n\\n    return permutation;\\n};\\n\\nfunction findMoves(nums: number[], permutation: number[]): number {\\n    let times: number = 0;\\n\\n    // pop the number to the desired place\\n    for (let i = 0; i < nums.length; i++) {\\n        for (let j = i; j < permutation.length; j++) {\\n            if (nums[i] == permutation[j]) {\\n                if (i == j) {\\n                    break;\\n                }\\n\\n                times += (j - i);\\n                permutation.splice(j, 1);\\n                permutation.splice(i, 0, nums[i]);\\n                break;\\n            }\\n        }\\n    }\\n\\n    return times;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nfunction getMinSwaps(num: string, k: number): number {\\n    let nums: number[] = num.split(\"\").map(a => parseInt(a));\\n    let permutation: number[] = [...nums];\\n\\n    for (let i = 0; i < k; i++) {\\n        permutation = findSmallestGreater(permutation);\\n    }\\n\\n    return findMoves(nums, permutation);\\n};\\n\\nfunction findSmallestGreater(permutation: number[]): number[] {\\n    let buffer: number[] = [permutation[permutation.length - 1]];\\n    let index: number = permutation.length - 2;\\n    let num: number;\\n\\n    // find the place where the sub array should be updated\\n    for (; index >= 0; index--) {\\n        num = permutation[index];\\n\\n        if (num < buffer[buffer.length - 1]) {\\n            break;\\n        }\\n\\n        buffer.push(num);\\n    }\\n\\n    // remove the updated part\\n    permutation = permutation.slice(0, index);\\n\\n    // arrange the updated part\\n    for (let i = 0; i < buffer.length; i++) {\\n        if (buffer[i] > num) {\\n            permutation.push(buffer[i]);\\n            buffer[i] = num;\\n            break;\\n        }\\n    }\\n\\n    // append to the original array\\n    permutation.push(...buffer);\\n\\n    return permutation;\\n};\\n\\nfunction findMoves(nums: number[], permutation: number[]): number {\\n    let times: number = 0;\\n\\n    // pop the number to the desired place\\n    for (let i = 0; i < nums.length; i++) {\\n        for (let j = i; j < permutation.length; j++) {\\n            if (nums[i] == permutation[j]) {\\n                if (i == j) {\\n                    break;\\n                }\\n\\n                times += (j - i);\\n                permutation.splice(j, 1);\\n                permutation.splice(i, 0, nums[i]);\\n                break;\\n            }\\n        }\\n    }\\n\\n    return times;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1521158,
                "title": "c-using-next-permutation-and-brute-force-swaps",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string initial_num = num;\\n        while(k--)\\n        {\\n            next_permutation(num.begin(), num.end());\\n        }\\n        int swaps=0;\\n        int n = num.size();\\n        for(int i=0; i<n; i++)\\n        {\\n            if(initial_num[i]!=num[i])\\n            {\\n                int change=num[i];\\n                int idx=i;\\n                while(idx<n && initial_num[idx]!=change)\\n                {\\n                    idx++;\\n                }\\n                while(idx!=i && idx<n)\\n                {\\n                    swap(initial_num[idx], initial_num[idx-1]);\\n                    idx--;\\n                    swaps++;\\n                }\\n            }\\n        }\\n        return swaps;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string initial_num = num;\\n        while(k--)\\n        {\\n            next_permutation(num.begin(), num.end());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1520930,
                "title": "java-solution",
                "content": "\\tclass Solution {\\n    public int getMinSwaps(String num, int k) \\n    {\\n        StringBuilder sb = new StringBuilder(num);\\n        while(k-- > 0)\\n        {\\n            int index = findNextGreaterNumber(sb);\\n            swapAndSort(sb, index);\\n        }\\n        \\n        return swapCount(num, sb);\\n    }\\n    \\n    int swapCount(String num, StringBuilder sb)\\n    {\\n        int res = 0, i = 0, j = 0, size = num.length();\\n        while(i < size)\\n        {\\n            j = i;\\n            while(num.charAt(i) != sb.charAt(j))\\n            {\\n                j++;\\n            }\\n            \\n            while(i < j)\\n            {\\n                swap(sb, j, j-1);\\n                j--;\\n                res++;\\n            }\\n            \\n            i++;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    void swap(StringBuilder sb, int i, int j)\\n    {\\n        char c = sb.charAt(i);\\n        sb.setCharAt(i, sb.charAt(j));\\n        sb.setCharAt(j, c);\\n    }\\n    \\n    int findNextGreaterNumber(StringBuilder sb)\\n    {\\n        int index = sb.length()-1;\\n        int minIndex = index;\\n        while(Character.getNumericValue(sb.charAt(index)) <= \\n              Character.getNumericValue(sb.charAt(index-1)))\\n        {\\n            index--;\\n        }\\n        \\n        return index-1;\\n    }\\n    \\n    void swapAndSort(StringBuilder sb, int index)\\n    {\\n        char toSwap = sb.charAt(index);\\n        char justGreater = sb.charAt(index+1);\\n        int greater = index+1;\\n        for(int i = index+2; i < sb.length(); i++)\\n        {\\n            if(toSwap < sb.charAt(i) && sb.charAt(i) < justGreater)\\n            {\\n                justGreater = sb.charAt(i);\\n                greater = i;\\n            }\\n        }\\n        \\n        char temp = sb.charAt(greater);\\n        sb.setCharAt(greater, sb.charAt(index));\\n        sb.setCharAt(index, temp);\\n        \\n        List<Character> res = new ArrayList<>();\\n        for(int i = index+1; i < sb.length(); i++)\\n        {\\n            res.add(sb.charAt(i));\\n        }\\n        \\n        Collections.sort(res);\\n        for(int i = index+1, j=0; i < sb.length(); i++,j++)\\n        {\\n            sb.setCharAt(i, res.get(j));\\n        }\\n    }\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int getMinSwaps(String num, int k) \\n    {\\n        StringBuilder sb = new StringBuilder(num);\\n        while(k-- > 0)\\n        {\\n            int index = findNextGreaterNumber(sb);\\n            swapAndSort(sb, index);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1495904,
                "title": "c-using-next-permutation-reverse-fast",
                "content": "```\\nint getMinSwaps(string num, int k) {\\n        string temp = num;\\n        int n = num.length();\\n        while(k--) \\n        {\\n            next_permutation(num.begin(),num.end());\\n        }\\n        int res = 0;\\n        for(int i = 0; i < n; ++ i)\\n        {\\n            if(num[i]!=temp[i])\\n            {\\n                size_t t = temp.find(num[i],i+1);\\n                res += t - i;\\n                reverse(temp.begin()+i, temp.begin()+t+1);\\n                reverse(temp.begin()+i+1, temp.begin()+t+1);\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\nHappy coding :)",
                "solutionTags": [],
                "code": "```\\nint getMinSwaps(string num, int k) {\\n        string temp = num;\\n        int n = num.length();\\n        while(k--) \\n        {\\n            next_permutation(num.begin(),num.end());\\n        }\\n        int res = 0;\\n        for(int i = 0; i < n; ++ i)\\n        {\\n            if(num[i]!=temp[i])\\n            {\\n                size_t t = temp.find(num[i],i+1);\\n                res += t - i;\\n                reverse(temp.begin()+i, temp.begin()+t+1);\\n                reverse(temp.begin()+i+1, temp.begin()+t+1);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1481193,
                "title": "o-n-2-c-no-next-permutation-function",
                "content": "Well, I kind of forgot **next_permutation**  function existed, so had to make something that\\'s still polynomial (even tho not nearly as fast as next_permutation). \\n\\n**PART1**: finding the kth permutation\\nWe start from the the last digit of **num** and keep going left and adding numbers to **dp array** until we find such number **x** that is smaller than **at least 1** previously added numbers. then, we add the first number that is bigger than x (which is O(1) since the size of tracking array is always N =10) then swap it with x. \\n\\nAfter that we sort the numbers to the right of swapped number to ensure that the new number is bigger than the previous one, but as small as possible. This can be done via **count sort** since all the characters are numbers from 0-9, which leads to linear time sorting.\\n\\nWe repeat this process k times.\\nI think the complexity becomes O(N * K)\\n\\n**PART 2**: finding minimum swaps\\nWell, this is pretty straight forward and there are plenty of great explanations in the discussion so I won\\'t comment on this one. This runs in O(N^2) time I think.\\n\\n```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string& num, int k) {\\n        string num_old = num;\\n        int N = (int)num.size();  \\n        for(int _ = 0; _ < k; ++_){\\n            bool dp[10] = {}; \\n            int  id[10] = {};  \\n            int count[10] = {};\\n            \\n            int idx = N -1; \\n            auto ptr = num.end() - 1; \\n            bool found = false; \\n            while(!found){   \\n                for(int i = (*ptr - \\'0\\') + 1; i < 10; ++i){\\n                    if(dp[i]){ \\n                        swap(num[id[i]], num[idx]);\\n                        for(int j = idx + 1; j < N; ++j) ++count[num[j] - \\'0\\'];       \\n                        int j = idx + 1;\\n                        int idx2 = 0; \\n                        while(idx2 < 10){\\n                            if(count[idx2]){\\n                                num[j++] = idx2 + 48;\\n                                --count[idx2];\\n                            } \\n                            else ++idx2;  \\n                        }    \\n                        found = true;\\n                        break;\\n                    }\\n                } \\n                dp[*ptr - \\'0\\'] = 1;\\n                id[*(ptr--) - \\'0\\'] = idx--;  \\n            }\\n        }   \\n        \\n        int cnt = 0, j;\\n        for(int i = 0; i < N; ++i){\\n            j = i; \\n            while(num_old[i] != num[j])  ++j;     \\n            for(; j > i; --j, ++cnt) swap(num[j], num[j-1]);     \\n            \\n        }   \\n       return cnt;    \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string& num, int k) {\\n        string num_old = num;\\n        int N = (int)num.size();  \\n        for(int _ = 0; _ < k; ++_){\\n            bool dp[10] = {}; \\n            int  id[10] = {};  \\n            int count[10] = {};\\n            \\n            int idx = N -1; \\n            auto ptr = num.end() - 1; \\n            bool found = false; \\n            while(!found){   \\n                for(int i = (*ptr - \\'0\\') + 1; i < 10; ++i){\\n                    if(dp[i]){ \\n                        swap(num[id[i]], num[idx]);\\n                        for(int j = idx + 1; j < N; ++j) ++count[num[j] - \\'0\\'];       \\n                        int j = idx + 1;\\n                        int idx2 = 0; \\n                        while(idx2 < 10){\\n                            if(count[idx2]){\\n                                num[j++] = idx2 + 48;\\n                                --count[idx2];\\n                            } \\n                            else ++idx2;  \\n                        }    \\n                        found = true;\\n                        break;\\n                    }\\n                } \\n                dp[*ptr - \\'0\\'] = 1;\\n                id[*(ptr--) - \\'0\\'] = idx--;  \\n            }\\n        }   \\n        \\n        int cnt = 0, j;\\n        for(int i = 0; i < N; ++i){\\n            j = i; \\n            while(num_old[i] != num[j])  ++j;     \\n            for(; j > i; --j, ++cnt) swap(num[j], num[j-1]);     \\n            \\n        }   \\n       return cnt;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1437775,
                "title": "c-solution",
                "content": "```\\npublic class Solution\\n{\\n    public int GetMinSwaps(string num, int k)\\n    {\\n        int counter = 0;\\n        var numArray = num.ToArray().Select(c => c - \\'0\\').ToArray();\\n        var targetArray = num.ToArray().Select(c => c - \\'0\\').ToArray();\\n\\n        for (int i = 0; i < k; i++)\\n        {\\n            NextPermutation(targetArray);\\n        }\\n\\n        for (int i = 0; i < numArray.Length; i++)\\n        {\\n            if (numArray[i] != targetArray[i])\\n            {\\n                var index = Array.IndexOf(numArray, targetArray[i], i + 1);\\n                for (int j = index; j > i; j--)\\n                {\\n                    counter++;\\n                    Swap(numArray, j, j - 1);\\n                }\\n            }\\n        }\\n\\n        return counter;\\n    }\\n\\n    public void NextPermutation(int[] array)\\n    {\\n        for (int i = array.Length - 2; i >= 0; i--)\\n        {\\n            if (array[i] < array[i + 1])\\n            {\\n                var current = array[i];\\n                var next = array.Skip(i + 1).Where(c => c > current).Min();\\n                for (int j = i + 1; j < array.Length; j++)\\n                {\\n                    if (array[j] == next)\\n                    {\\n                        Swap(array, i, j);\\n                        break;\\n                    }\\n                }\\n                Array.Sort(array, i + 1, array.Length - i - 1);\\n                return;\\n            }\\n        }\\n    }\\n\\n\\n    public void Swap(int[] array, int i, int j)\\n    {\\n        int tmp = array[i];\\n        array[i] = array[j];\\n        array[j] = tmp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public int GetMinSwaps(string num, int k)\\n    {\\n        int counter = 0;\\n        var numArray = num.ToArray().Select(c => c - \\'0\\').ToArray();\\n        var targetArray = num.ToArray().Select(c => c - \\'0\\').ToArray();\\n\\n        for (int i = 0; i < k; i++)\\n        {\\n            NextPermutation(targetArray);\\n        }\\n\\n        for (int i = 0; i < numArray.Length; i++)\\n        {\\n            if (numArray[i] != targetArray[i])\\n            {\\n                var index = Array.IndexOf(numArray, targetArray[i], i + 1);\\n                for (int j = index; j > i; j--)\\n                {\\n                    counter++;\\n                    Swap(numArray, j, j - 1);\\n                }\\n            }\\n        }\\n\\n        return counter;\\n    }\\n\\n    public void NextPermutation(int[] array)\\n    {\\n        for (int i = array.Length - 2; i >= 0; i--)\\n        {\\n            if (array[i] < array[i + 1])\\n            {\\n                var current = array[i];\\n                var next = array.Skip(i + 1).Where(c => c > current).Min();\\n                for (int j = i + 1; j < array.Length; j++)\\n                {\\n                    if (array[j] == next)\\n                    {\\n                        Swap(array, i, j);\\n                        break;\\n                    }\\n                }\\n                Array.Sort(array, i + 1, array.Length - i - 1);\\n                return;\\n            }\\n        }\\n    }\\n\\n\\n    public void Swap(int[] array, int i, int j)\\n    {\\n        int tmp = array[i];\\n        array[i] = array[j];\\n        array[j] = tmp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1431107,
                "title": "o-n-k-n-log-n-t-o-n-s-implicit-treap-next-permutation-python-3",
                "content": "```\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        import random\\n        \\n        class ImplicitTreap:\\n            class ImplicitTreapNode:\\n                def __init__(self, y, value, left=None, right=None):\\n                    self.y = y\\n                    self.value = value\\n                    self.left = left\\n                    self.right = right\\n                    self.size = 1\\n                \\n                def recalc(self):\\n                    self.size = (self.left.size if self.left is not None else 0) + (self.right.size if self.right is not None else 0) + 1\\n            \\n            def __init__(self, values=None):                \\n                self.root = None\\n                for value in values:\\n                    self.append(value)\\n            \\n            @staticmethod\\n            def _merge(left, right):\\n                if left is None:\\n                    return right\\n                if right is None:\\n                    return left\\n                \\n                if left.y > right.y:\\n                    left.right = ImplicitTreap._merge(left.right, right)\\n                    result = left\\n                else:\\n                    right.left = ImplicitTreap._merge(left, right.left)\\n                    result = right\\n                \\n                result.recalc()\\n                return result\\n            \\n            @staticmethod\\n            def _split(node, index):\\n                if node is None:\\n                    return None, None\\n                \\n                left_size = node.left.size if node.left is not None else 0\\n                if index >= left_size + 1:\\n                    left, right = ImplicitTreap._split(node.right, index - left_size - 1)\\n                    node.right = left\\n                    node.recalc()\\n                    return node, right\\n                else:\\n                    left, right = ImplicitTreap._split(node.left, index)\\n                    node.left = right\\n                    node.recalc()\\n                    return left, node\\n                \\n            def __getitem__(self, index):\\n                if self.root is None or index > self.root.size or index < -self.root.size:\\n                    raise Exception(\\'Index out of range\\')\\n                if index < 0:\\n                    index = -1 - index\\n                \\n                node = self.root\\n                while True:\\n                    left_size = node.left.size if node.left is not None else 0\\n                    if index < left_size:\\n                        node = node.left\\n                    elif node.left is not None and index == 0:\\n                        return node.value\\n                    elif index == left_size:\\n                        return node.value\\n                    else:\\n                        node = node.right\\n                        index -= left_size + 1\\n        \\n            def insert(self, index, value):\\n                if self.root is None:\\n                    self.root = ImplicitTreap.ImplicitTreapNode(random.random(), value)\\n                    return\\n                \\n                if index > self.root.size:\\n                    raise Exception(\\'Index out of range\\')\\n                \\n                left, right = ImplicitTreap._split(self.root, index)\\n                node = ImplicitTreap.ImplicitTreapNode(random.random(), value)\\n                self.root = ImplicitTreap._merge(ImplicitTreap._merge(left, node), right)\\n            \\n            def append(self, value):\\n                self.insert(self.root.size if self.root is not None else 0, value)\\n            \\n            def pop(self, index=None):\\n                if index is None:\\n                    index = self.root.size - 1\\n                \\n                left, right = ImplicitTreap._split(self.root, index)\\n                _, right = ImplicitTreap._split(right, 1)\\n                self.root = ImplicitTreap._merge(left, right)\\n            \\n            def __len__(self):\\n                return self.root.size if self.root is not None else 0\\n            \\n            def __str__(self):\\n                result = []\\n                def dfs(node):\\n                    nonlocal result\\n                    if node is None:\\n                        return\\n                    \\n                    dfs(node.left)\\n                    result.append(node.value)\\n                    dfs(node.right)\\n                dfs(self.root)\\n                return str(result)\\n        \\n        \\n        def next_permutation(permutation):\\n            for i in range(len(permutation)-2, -1, -1):\\n                if permutation[i] < permutation[i+1]:\\n                    k = i\\n                    break\\n            else:\\n                return\\n            \\n            for i in range(len(permutation)-1, k, -1):\\n                if permutation[k] < permutation[i]:\\n                    r = i\\n                    break\\n            \\n            permutation = list(permutation)\\n            permutation[k], permutation[r] = permutation[r], permutation[k]\\n            return \\'\\'.join(permutation[0:k+1] + list(reversed(permutation[k+1:])))\\n        \\n        permutation = num\\n        for _ in range(k):\\n            permutation = next_permutation(permutation)\\n        \\n        result = 0\\n        permutation = ImplicitTreap(permutation)\\n        for i in range(len(permutation)):\\n            if num[i] != permutation[i]:\\n                for j in range(i+1, len(permutation)):\\n                    if num[i] == permutation[j]:\\n                        result += j - i \\n                        permutation.pop(j)\\n                        permutation.insert(i, num[i])\\n                        break\\n        return result\\n        \\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        import random\\n        \\n        class ImplicitTreap:\\n            class ImplicitTreapNode:\\n                def __init__(self, y, value, left=None, right=None):\\n                    self.y = y\\n                    self.value = value\\n                    self.left = left\\n                    self.right = right\\n                    self.size = 1\\n                \\n                def recalc(self):\\n                    self.size = (self.left.size if self.left is not None else 0) + (self.right.size if self.right is not None else 0) + 1\\n            \\n            def __init__(self, values=None):                \\n                self.root = None\\n                for value in values:\\n                    self.append(value)\\n            \\n            @staticmethod\\n            def _merge(left, right):\\n                if left is None:\\n                    return right\\n                if right is None:\\n                    return left\\n                \\n                if left.y > right.y:\\n                    left.right = ImplicitTreap._merge(left.right, right)\\n                    result = left\\n                else:\\n                    right.left = ImplicitTreap._merge(left, right.left)\\n                    result = right\\n                \\n                result.recalc()\\n                return result\\n            \\n            @staticmethod\\n            def _split(node, index):\\n                if node is None:\\n                    return None, None\\n                \\n                left_size = node.left.size if node.left is not None else 0\\n                if index >= left_size + 1:\\n                    left, right = ImplicitTreap._split(node.right, index - left_size - 1)\\n                    node.right = left\\n                    node.recalc()\\n                    return node, right\\n                else:\\n                    left, right = ImplicitTreap._split(node.left, index)\\n                    node.left = right\\n                    node.recalc()\\n                    return left, node\\n                \\n            def __getitem__(self, index):\\n                if self.root is None or index > self.root.size or index < -self.root.size:\\n                    raise Exception(\\'Index out of range\\')\\n                if index < 0:\\n                    index = -1 - index\\n                \\n                node = self.root\\n                while True:\\n                    left_size = node.left.size if node.left is not None else 0\\n                    if index < left_size:\\n                        node = node.left\\n                    elif node.left is not None and index == 0:\\n                        return node.value\\n                    elif index == left_size:\\n                        return node.value\\n                    else:\\n                        node = node.right\\n                        index -= left_size + 1\\n        \\n            def insert(self, index, value):\\n                if self.root is None:\\n                    self.root = ImplicitTreap.ImplicitTreapNode(random.random(), value)\\n                    return\\n                \\n                if index > self.root.size:\\n                    raise Exception(\\'Index out of range\\')\\n                \\n                left, right = ImplicitTreap._split(self.root, index)\\n                node = ImplicitTreap.ImplicitTreapNode(random.random(), value)\\n                self.root = ImplicitTreap._merge(ImplicitTreap._merge(left, node), right)\\n            \\n            def append(self, value):\\n                self.insert(self.root.size if self.root is not None else 0, value)\\n            \\n            def pop(self, index=None):\\n                if index is None:\\n                    index = self.root.size - 1\\n                \\n                left, right = ImplicitTreap._split(self.root, index)\\n                _, right = ImplicitTreap._split(right, 1)\\n                self.root = ImplicitTreap._merge(left, right)\\n            \\n            def __len__(self):\\n                return self.root.size if self.root is not None else 0\\n            \\n            def __str__(self):\\n                result = []\\n                def dfs(node):\\n                    nonlocal result\\n                    if node is None:\\n                        return\\n                    \\n                    dfs(node.left)\\n                    result.append(node.value)\\n                    dfs(node.right)\\n                dfs(self.root)\\n                return str(result)\\n        \\n        \\n        def next_permutation(permutation):\\n            for i in range(len(permutation)-2, -1, -1):\\n                if permutation[i] < permutation[i+1]:\\n                    k = i\\n                    break\\n            else:\\n                return\\n            \\n            for i in range(len(permutation)-1, k, -1):\\n                if permutation[k] < permutation[i]:\\n                    r = i\\n                    break\\n            \\n            permutation = list(permutation)\\n            permutation[k], permutation[r] = permutation[r], permutation[k]\\n            return \\'\\'.join(permutation[0:k+1] + list(reversed(permutation[k+1:])))\\n        \\n        permutation = num\\n        for _ in range(k):\\n            permutation = next_permutation(permutation)\\n        \\n        result = 0\\n        permutation = ImplicitTreap(permutation)\\n        for i in range(len(permutation)):\\n            if num[i] != permutation[i]:\\n                for j in range(i+1, len(permutation)):\\n                    if num[i] == permutation[j]:\\n                        result += j - i \\n                        permutation.pop(j)\\n                        permutation.insert(i, num[i])\\n                        break\\n        return result\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1429816,
                "title": "letting-the-standard-c-library-do-all-the-work",
                "content": "```\\nclass Solution {\\npublic:\\n\\tint getMinSwaps(std::string number, int k) {\\n\\t\\tauto permuted = number;\\n\\t\\tfor (auto i = 0; i != k; ++i) {\\n\\t\\t\\tstd::next_permutation(std::begin(permuted), std::end(permuted));\\n\\t\\t}\\n\\n\\t\\tauto count = 0;\\n\\t\\twhile (number != permuted) {\\n\\t\\t\\tauto [iter, jter] = std::mismatch(std::begin(number), std::end(number), std::cbegin(permuted));\\n\\t\\t\\tauto value = *jter;\\n\\t\\t\\tauto kter = std::find(std::next(iter), std::end(number), value);\\n\\t\\t\\tstd::rotate(iter, kter, std::next(kter));\\n\\n\\t\\t\\tcount += static_cast<int>(std::distance(iter, kter));\\n\\t\\t}\\n\\n\\t\\treturn count;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint getMinSwaps(std::string number, int k) {\\n\\t\\tauto permuted = number;\\n\\t\\tfor (auto i = 0; i != k; ++i) {\\n\\t\\t\\tstd::next_permutation(std::begin(permuted), std::end(permuted));\\n\\t\\t}\\n\\n\\t\\tauto count = 0;\\n\\t\\twhile (number != permuted) {\\n\\t\\t\\tauto [iter, jter] = std::mismatch(std::begin(number), std::end(number), std::cbegin(permuted));\\n\\t\\t\\tauto value = *jter;\\n\\t\\t\\tauto kter = std::find(std::next(iter), std::end(number), value);\\n\\t\\t\\tstd::rotate(iter, kter, std::next(kter));\\n\\n\\t\\t\\tcount += static_cast<int>(std::distance(iter, kter));\\n\\t\\t}\\n\\n\\t\\treturn count;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1403356,
                "title": "effecient-cpp-solution",
                "content": "class Solution {\\npublic:\\n    int getMinSwaps(string num, int k)\\n    {\\n        string s=num;\\n        int z=0,count=0;\\n        for(int i=1;i<=k;i++)\\n        {\\n           next_permutation(num.begin(),num.end());\\n        }\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]!=num[i])\\n            {\\n                z=i;\\n                break;\\n            }\\n        }\\n        int l=z;\\n        while(l<s.size())\\n        {\\n            int n=find(s.begin()+l,s.end(),num[l])-s.begin();\\n            reverse(s.begin()+l,s.begin()+n);\\n            reverse(s.begin()+l,s.begin()+n+1);\\n            count+=abs(n-l);\\n            l++;\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int getMinSwaps(string num, int k)\\n    {\\n        string s=num;\\n        int z=0,count=0;\\n        for(int i=1;i<=k;i++)\\n        {\\n           next_permutation(num.begin(),num.end());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1394377,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int getMinSwaps(String num, int k) {\\n        int[] original = generateDigitArray(num);\\n        int[] copied = Arrays.copyOf(original, original.length);\\n        \\n        while (k > 0) {\\n            nextPermutation(copied);\\n            k--;\\n        }\\n        \\n        return findMinSwaps(original, copied);\\n    }\\n    \\n    private int findMinSwaps(int[] number, int[] kthSmallestNumber){\\n        int swapCount = 0;\\n        int n = number.length;\\n        \\n        for(int i = 0; i < n; i++){\\n            if(number[i] == kthSmallestNumber[i]) continue;\\n            \\n            int j = i + 1;\\n            while(j < n && number[i] != kthSmallestNumber[j]){\\n                j++;\\n            }\\n            \\n            while(j > i){\\n                swap(kthSmallestNumber, j - 1, j);\\n                swapCount++;\\n                j--;\\n            }\\n            \\n        }\\n        \\n        return swapCount;\\n    }\\n    \\n    private int[] generateDigitArray(String strnum) {\\n        List<Integer> result = new ArrayList();\\n        \\n        for (int i = 0; i < strnum.length(); i++) {\\n            result.add(strnum.charAt(i) - \\'0\\');\\n        }\\n        \\n        return result.stream().mapToInt(Integer::intValue).toArray();\\n    }\\n    \\n    private void nextPermutation(int[] nums) {\\n        int length = nums.length;\\n        \\n        int i = length - 2;\\n        while (i >= 0 && nums[i] >= nums[i+1]) i--;\\n        \\n        int j = length - 1;\\n        if (i >= 0) {\\n            while (j >= 0 && nums[i] >= nums[j]) j--;\\n            swap(nums, i, j);\\n        }\\n        \\n        reverse(nums, i+1, length - 1);\\n    }\\n    \\n    private void swap(int[] nums, int start, int end) {\\n        if (start > end) return;\\n        \\n        int t = nums[start];\\n        nums[start] = nums[end];\\n        nums[end] = t;\\n    }\\n    \\n    private void reverse(int[] nums, int start, int end) {\\n        while (start <= end) {\\n            swap(nums, start, end);\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int getMinSwaps(String num, int k) {\\n        int[] original = generateDigitArray(num);\\n        int[] copied = Arrays.copyOf(original, original.length);\\n        \\n        while (k > 0) {\\n            nextPermutation(copied);\\n            k--;\\n        }\\n        \\n        return findMinSwaps(original, copied);\\n    }\\n    \\n    private int findMinSwaps(int[] number, int[] kthSmallestNumber){\\n        int swapCount = 0;\\n        int n = number.length;\\n        \\n        for(int i = 0; i < n; i++){\\n            if(number[i] == kthSmallestNumber[i]) continue;\\n            \\n            int j = i + 1;\\n            while(j < n && number[i] != kthSmallestNumber[j]){\\n                j++;\\n            }\\n            \\n            while(j > i){\\n                swap(kthSmallestNumber, j - 1, j);\\n                swapCount++;\\n                j--;\\n            }\\n            \\n        }\\n        \\n        return swapCount;\\n    }\\n    \\n    private int[] generateDigitArray(String strnum) {\\n        List<Integer> result = new ArrayList();\\n        \\n        for (int i = 0; i < strnum.length(); i++) {\\n            result.add(strnum.charAt(i) - \\'0\\');\\n        }\\n        \\n        return result.stream().mapToInt(Integer::intValue).toArray();\\n    }\\n    \\n    private void nextPermutation(int[] nums) {\\n        int length = nums.length;\\n        \\n        int i = length - 2;\\n        while (i >= 0 && nums[i] >= nums[i+1]) i--;\\n        \\n        int j = length - 1;\\n        if (i >= 0) {\\n            while (j >= 0 && nums[i] >= nums[j]) j--;\\n            swap(nums, i, j);\\n        }\\n        \\n        reverse(nums, i+1, length - 1);\\n    }\\n    \\n    private void swap(int[] nums, int start, int end) {\\n        if (start > end) return;\\n        \\n        int t = nums[start];\\n        nums[start] = nums[end];\\n        nums[end] = t;\\n    }\\n    \\n    private void reverse(int[] nums, int start, int end) {\\n        while (start <= end) {\\n            swap(nums, start, end);\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1393848,
                "title": "c-explained-next-permutation-convert-string-a-to-b",
                "content": "This Problem is basically concatenation of 2 simple Problems\\n\\n1) Find kth permutation\\n      - Can be found using simple stl formula -  next_permutation(s.begin(),s.end());\\n\\n2)  Minimum swaps to convert string a to string b\\n    - As the constraints are small , you can use two for loops \\n      to convert easily.\\n\\t - The code is self explanatory\\n\\t - Dry run and you can easily understand the approach\\n\\n\\n```\\n\\nclass Solution {\\n    \\n    int swaps(string org,string num)\\n    {\\n        \\n        int cnt=0;\\n        \\n        for(int i=0;i<num.size();i++)\\n        {\\n            if(org[i]!=num[i])\\n            {\\n                for(int j=i+1;j<num.size();j++)\\n                {\\n                    cnt++;\\n                   swap(org[i],org[j]);\\n\\n                    if(org[i]==num[i])\\n                    {\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        \\n        \\n        return cnt;\\n    }\\n    \\n    \\npublic:\\n    int getMinSwaps(string num, int k) {\\n        \\n        \\n        string org=num;\\n        \\n        while(k--)\\n        {\\n            next_permutation(num.begin(),num.end());\\n        }\\n        \\n        cout<<\" org \"<<org<<endl;\\n        cout<<\" num \"<<num<<endl;\\n        return swaps(org,num);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    int swaps(string org,string num)\\n    {\\n        \\n        int cnt=0;\\n        \\n        for(int i=0;i<num.size();i++)\\n        {\\n            if(org[i]!=num[i])\\n            {\\n                for(int j=i+1;j<num.size();j++)\\n                {\\n                    cnt++;\\n                   swap(org[i],org[j]);\\n\\n                    if(org[i]==num[i])\\n                    {\\n                        break;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1340700,
                "title": "c-next-permutation",
                "content": "```\\nclass Solution {\\npublic:\\n    int f(string s1, string s2){\\n        int i=0,j,step=0,n=s1.size();\\n        while(i<n){\\n            j=i;\\n            while(s1[i]!=s2[j]) j++;\\n            while(i<j){\\n                swap(s2[j],s2[j-1]);\\n                j--;\\n                step++;\\n            }\\n            i++;\\n        }\\n        return step;\\n    }\\n    int getMinSwaps(string num, int k) {\\n        int i;\\n        string s=num;\\n        while(k--){\\n            next_permutation(num.begin(),num.end());\\n        }\\n        return f(s,num);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(string s1, string s2){\\n        int i=0,j,step=0,n=s1.size();\\n        while(i<n){\\n            j=i;\\n            while(s1[i]!=s2[j]) j++;\\n            while(i<j){\\n                swap(s2[j],s2[j-1]);\\n                j--;\\n                step++;\\n            }\\n            i++;\\n        }\\n        return step;\\n    }\\n    int getMinSwaps(string num, int k) {\\n        int i;\\n        string s=num;\\n        while(k--){\\n            next_permutation(num.begin(),num.end());\\n        }\\n        return f(s,num);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1318393,
                "title": "c-very-easy-with-explanations",
                "content": "first find kth `next permutation` (C++ has by default algorithm for it)\\nProbable internal implementation of `next_permutation` (just for fun)\\n```\\nvoid next_permutation(string& s) {\\n\\tauto it = is_sorted_until(rbegin(s), rend(s));\\n    if(it != rend(s)) swap(*it, *upper_bound(rbegin(s), it, *it));\\n    reverse(rbegin(s), it);\\n}\\n```\\nAfter that traverse both strings (original one and kth permutation one)\\nif it any position they differ. mark that position and find the number in other string,\\nMeans that .. suppose \\nstring is `s = \"5489355142\"`\\n```\\n\\t5 4 8 9 3 5 5 1 4 2  => original string\\n\\t5 4 8 9 3 5 5 4 2 1  => kth next permutation\\n\\t. . . . . . . *      => differing position (1 != 4)\\n\\twe find   1 (element from top string) in bottom string .\\n\\tin bottom string it is present at the end (last element of bottom string is 1)\\n\\t\\n\\twe mark this position as pos\\n\\tNow, we know that swap occurred between i and pos.\\n\\trun a loop from i to pos and swap s[pos] and s[pos - 1] and increase swap count\\n\\treturn count\\n```\\n##### Code\\n\\n```\\nint getMinSwaps(string s, int k) {\\n        string str = s;\\n        int count = 0;\\n        while(k--)\\n            next_permutation(begin(s), end(s));\\n        for(int i = 0; i < s.size(); i++) {\\n            if(s[i] != str[i]) {\\n                int pos = s.find(str[i], i);\\n                while(pos > i) {\\n                    swap(s[pos], s[pos - 1]);\\n                    count++;\\n                    pos--;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvoid next_permutation(string& s) {\\n\\tauto it = is_sorted_until(rbegin(s), rend(s));\\n    if(it != rend(s)) swap(*it, *upper_bound(rbegin(s), it, *it));\\n    reverse(rbegin(s), it);\\n}\\n```\n```\\n\\t5 4 8 9 3 5 5 1 4 2  => original string\\n\\t5 4 8 9 3 5 5 4 2 1  => kth next permutation\\n\\t. . . . . . . *      => differing position (1 != 4)\\n\\twe find   1 (element from top string) in bottom string .\\n\\tin bottom string it is present at the end (last element of bottom string is 1)\\n\\t\\n\\twe mark this position as pos\\n\\tNow, we know that swap occurred between i and pos.\\n\\trun a loop from i to pos and swap s[pos] and s[pos - 1] and increase swap count\\n\\treturn count\\n```\n```\\nint getMinSwaps(string s, int k) {\\n        string str = s;\\n        int count = 0;\\n        while(k--)\\n            next_permutation(begin(s), end(s));\\n        for(int i = 0; i < s.size(); i++) {\\n            if(s[i] != str[i]) {\\n                int pos = s.find(str[i], i);\\n                while(pos > i) {\\n                    swap(s[pos], s[pos - 1]);\\n                    count++;\\n                    pos--;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1308870,
                "title": "faster-than-99-c-small-code-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string s = num;\\n        while(k--) {\\n            next_permutation(s.begin(),s.end());\\n        }\\n        int i=0,j=0,count = 0;\\n        while(i<num.size()) {\\n            if(s[i] == num[j]) {\\n                i++;j++;\\n                continue;\\n            }\\n            while(s[i] != num[j]) j++;\\n            while(j>i) {\\n                swap(num[j],num[j-1]);\\n                count++;\\n                j--;\\n            }\\n            j = ++i;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string s = num;\\n        while(k--) {\\n            next_permutation(s.begin(),s.end());\\n        }\\n        int i=0,j=0,count = 0;\\n        while(i<num.size()) {\\n            if(s[i] == num[j]) {\\n                i++;j++;\\n                continue;\\n            }\\n            while(s[i] != num[j]) j++;\\n            while(j>i) {\\n                swap(num[j],num[j-1]);\\n                count++;\\n                j--;\\n            }\\n            j = ++i;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1293738,
                "title": "python3-leetcode-31-next-permutation",
                "content": "Basically the same solution as [LeetCode 31](https://leetcode.com/problems/next-permutation).\\n```\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        m = len(num)\\n        s = list(num)\\n        num = list(num)\\n        def next_permutation(n):\\n            i = m - 2\\n            while i >= 0 and n[i] >= n[i + 1]:\\n                i -= 1\\n            j = i + 1\\n            while j < m and n[i] < n[j]:\\n                j += 1\\n            j -= 1\\n            n[i], n[j] = n[j], n[i]\\n            i += 1\\n            j = m - 1\\n            while i < j:\\n                n[i], n[j] = n[j], n[i]\\n                i += 1\\n                j -= 1\\n            return n\\n        while k:\\n            num = next_permutation(num)\\n            k -= 1\\n        def calc(s, t):\\n            res = 0\\n            for i in range(m):\\n                if s[i] == t[i]:\\n                    continue\\n                j = i\\n                while j < m and s[j] != t[i]:\\n                    j += 1\\n                res += j - i\\n                s[i + 1:] = s[i:j] + s[j + 1:]\\n            return res\\n        return calc(s, num)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getMinSwaps(self, num: str, k: int) -> int:\\n        m = len(num)\\n        s = list(num)\\n        num = list(num)\\n        def next_permutation(n):\\n            i = m - 2\\n            while i >= 0 and n[i] >= n[i + 1]:\\n                i -= 1\\n            j = i + 1\\n            while j < m and n[i] < n[j]:\\n                j += 1\\n            j -= 1\\n            n[i], n[j] = n[j], n[i]\\n            i += 1\\n            j = m - 1\\n            while i < j:\\n                n[i], n[j] = n[j], n[i]\\n                i += 1\\n                j -= 1\\n            return n\\n        while k:\\n            num = next_permutation(num)\\n            k -= 1\\n        def calc(s, t):\\n            res = 0\\n            for i in range(m):\\n                if s[i] == t[i]:\\n                    continue\\n                j = i\\n                while j < m and s[j] != t[i]:\\n                    j += 1\\n                res += j - i\\n                s[i + 1:] = s[i:j] + s[j + 1:]\\n            return res\\n        return calc(s, num)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1284088,
                "title": "hint-if-you-need-it-this-problem-is-too-hard-for-medium",
                "content": "1. How to the smallest number that is larger than the input number(N)?\\n2. Do that for k times and get the target number X\\n3. To get X from N, how many swaps between adjacent digits are needed?\\n\\nI think both 1) and 3) alone justify a medium questions. This problem, asked as is, is obviously too hard for coding interview.",
                "solutionTags": [],
                "code": "1. How to the smallest number that is larger than the input number(N)?\\n2. Do that for k times and get the target number X\\n3. To get X from N, how many swaps between adjacent digits are needed?\\n\\nI think both 1) and 3) alone justify a medium questions. This problem, asked as is, is obviously too hard for coding interview.",
                "codeTag": "Unknown"
            },
            {
                "id": 1279012,
                "title": "c-solution-90-faster",
                "content": "```\\n\\n\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string num1=num;\\n        while(k--)\\n        {\\n            next_permutation(num.begin(),num.end());\\n        }\\n        int n=num.length();\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(num[i]!=num1[i])\\n            {\\n                int j=i+1;\\n                for(;j<n;j++)\\n                {\\n                    if(num1[j]==num[i])\\n                    {\\n                        ans+=j-i;\\n                        break ;\\n                    }\\n                }\\n                while(j!=i)\\n                {\\n                    swap(num1[j],num1[j-1]);\\n                    j--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        string num1=num;\\n        while(k--)\\n        {\\n            next_permutation(num.begin(),num.end());\\n        }\\n        int n=num.length();\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(num[i]!=num1[i])\\n            {\\n                int j=i+1;\\n                for(;j<n;j++)\\n                {\\n                    if(num1[j]==num[i])\\n                    {\\n                        ans+=j-i;\\n                        break ;\\n                    }\\n                }\\n                while(j!=i)\\n                {\\n                    swap(num1[j],num1[j-1]);\\n                    j--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1262439,
                "title": "c-easy-using-next-permutation-and-string-erase-and-insert",
                "content": "k the permutation of the array is being obtained by using next_permutation and then the string original string is compared with the modified string whenever the elements differ the difference between the positions is added to the ans and the original string is modified accordingly .The approach is given below \\n```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string s, int k) {\\n        string temp = s;\\n        while(k--)\\n        {\\n           next_permutation(temp.begin() , temp.end()); \\n        }\\n        int ans =0 ; \\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i] != temp[i])\\n            {\\n                int j = i+1;\\n                while(j < s.size())\\n                {\\n                    if(s[j] == temp[i]) break;\\n                    j++;\\n                }\\n                s.insert(i, 1, temp[i]);\\n             \\n                s.erase(j+1,1);\\n    \\n                ans += j-i;\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string s, int k) {\\n        string temp = s;\\n        while(k--)\\n        {\\n           next_permutation(temp.begin() , temp.end()); \\n        }\\n        int ans =0 ; \\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i] != temp[i])\\n            {\\n                int j = i+1;\\n                while(j < s.size())\\n                {\\n                    if(s[j] == temp[i]) break;\\n                    j++;\\n                }\\n                s.insert(i, 1, temp[i]);\\n             \\n                s.erase(j+1,1);\\n    \\n                ans += j-i;\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1258858,
                "title": "js-next-permutation",
                "content": "```\\n/**\\n * @param {string} num\\n * @param {number} k\\n * @return {number}\\n */\\nvar getMinSwaps = function(num, k) {\\n    const digits = num.split(\\'\\').map(ch => Number(ch))\\n    const len = digits.length\\n    \\n    function toNextPerm() {\\n        let i = -2 + len\\n        for (; i >= 0; i--)\\n            if (digits[i] < digits[1 + i])\\n                break\\n        \\n        let low = 1 + i, high = -1 + len\\n        const val = digits[i]\\n        while (low < high) {\\n            const mid = Math.ceil((low + high) / 2)\\n            if (digits[mid] > val)    low = mid\\n            else high = -1 + mid\\n        }\\n        \\n        const swapWith = low\\n        ;[digits[i], digits[swapWith]] = [digits[swapWith], digits[i]];\\n        \\n        for (let low = 1 + i, high = -1 + len;\\n        low < high; low++, high--) {\\n            [digits[low], digits[high]] = [digits[high], digits[low]]\\n        }\\n    }\\n    \\n    \\n    const snapshot = [...digits]\\n    for (let i = 0; i < k; i++)\\n        toNextPerm()\\n        \\n\\n    let result = 0\\n    for (let i = 0; i < len; i++) {\\n        const valA = snapshot[i]\\n        const valB = digits[i]\\n        if (valA === valB)  continue\\n        \\n        // let snapshot[i] <- valB\\n        const index = snapshot.indexOf(valB, 1 + i)\\n        const offset = index - i\\n        result += offset\\n        \\n        // swap\\n        for (let j = index; j > i; j--) {\\n            [snapshot[j], snapshot[j - 1]] = [snapshot[j - 1], snapshot[j]]\\n        }\\n    }\\n    \\n    \\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} num\\n * @param {number} k\\n * @return {number}\\n */\\nvar getMinSwaps = function(num, k) {\\n    const digits = num.split(\\'\\').map(ch => Number(ch))\\n    const len = digits.length\\n    \\n    function toNextPerm() {\\n        let i = -2 + len\\n        for (; i >= 0; i--)\\n            if (digits[i] < digits[1 + i])\\n                break\\n        \\n        let low = 1 + i, high = -1 + len\\n        const val = digits[i]\\n        while (low < high) {\\n            const mid = Math.ceil((low + high) / 2)\\n            if (digits[mid] > val)    low = mid\\n            else high = -1 + mid\\n        }\\n        \\n        const swapWith = low\\n        ;[digits[i], digits[swapWith]] = [digits[swapWith], digits[i]];\\n        \\n        for (let low = 1 + i, high = -1 + len;\\n        low < high; low++, high--) {\\n            [digits[low], digits[high]] = [digits[high], digits[low]]\\n        }\\n    }\\n    \\n    \\n    const snapshot = [...digits]\\n    for (let i = 0; i < k; i++)\\n        toNextPerm()\\n        \\n\\n    let result = 0\\n    for (let i = 0; i < len; i++) {\\n        const valA = snapshot[i]\\n        const valB = digits[i]\\n        if (valA === valB)  continue\\n        \\n        // let snapshot[i] <- valB\\n        const index = snapshot.indexOf(valB, 1 + i)\\n        const offset = index - i\\n        result += offset\\n        \\n        // swap\\n        for (let j = index; j > i; j--) {\\n            [snapshot[j], snapshot[j - 1]] = [snapshot[j - 1], snapshot[j]]\\n        }\\n    }\\n    \\n    \\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1256200,
                "title": "sharing-my-javascript-solution",
                "content": "```\\nvar getMinSwaps = function(num, k) {\\n  let nums = num.split(\"\");\\n  let perm = [...nums];\\n  for (let i = 0; i < k; i++) {\\n    perm = getNextPermutation(perm);\\n  }\\n  return countSwaps(nums, perm);\\n};\\n\\nfunction countSwaps(n1, n2) {\\n  let count = 0;\\n  for (let i = 0; i < n1.length; i++) {\\n    if (n1[i] !== n2[i]) {\\n      count += findAndSwap(n2, n1[i], i, i+1);\\n    } else {\\n      continue;\\n    }\\n  }\\n  return count;\\n}\\n\\nfunction findAndSwap(nums, val, swapIndex, start) {\\n  for (let i = start; i < nums.length; i++) {\\n    if (nums[i] === val) {\\n      return swapBetween(i, swapIndex, nums);\\n    }\\n  }\\n  throw new Error(`could not find elem to swap!`);\\n}\\n\\nfunction swapBetween(end, start, nums) {\\n  let count = 0;\\n  for (let i = end; i > start; i--) {\\n    [nums[i], nums[i-1]] = [nums[i-1], nums[i]];\\n    count += 1;\\n  }\\n  \\n  return count;\\n}\\n\\nfunction getNextPermutation(nums) {\\n  let count = 0;\\n  for (let i = nums.length-2; i >= 0; i--) {\\n    if (nums[i] < nums[i+1]) {\\n      for (let j = nums.length-1; j > i; j--) {\\n        if (nums[j] > nums[i]) {\\n          [nums[i], nums[j]] = [nums[j], nums[i]];\\n          reverse(i+1, nums.length-1, nums);\\n          return nums;\\n        }\\n      }\\n    }\\n  }\\n  \\n  throw new Error(`not a valid number: ${nums}`);\\n}\\n\\nfunction reverse(start, end, nums) {\\n  while (start < end) {\\n    [nums[start], nums[end]] = [nums[end], nums[start]];\\n    start += 1;\\n    end -= 1;\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar getMinSwaps = function(num, k) {\\n  let nums = num.split(\"\");\\n  let perm = [...nums];\\n  for (let i = 0; i < k; i++) {\\n    perm = getNextPermutation(perm);\\n  }\\n  return countSwaps(nums, perm);\\n};\\n\\nfunction countSwaps(n1, n2) {\\n  let count = 0;\\n  for (let i = 0; i < n1.length; i++) {\\n    if (n1[i] !== n2[i]) {\\n      count += findAndSwap(n2, n1[i], i, i+1);\\n    } else {\\n      continue;\\n    }\\n  }\\n  return count;\\n}\\n\\nfunction findAndSwap(nums, val, swapIndex, start) {\\n  for (let i = start; i < nums.length; i++) {\\n    if (nums[i] === val) {\\n      return swapBetween(i, swapIndex, nums);\\n    }\\n  }\\n  throw new Error(`could not find elem to swap!`);\\n}\\n\\nfunction swapBetween(end, start, nums) {\\n  let count = 0;\\n  for (let i = end; i > start; i--) {\\n    [nums[i], nums[i-1]] = [nums[i-1], nums[i]];\\n    count += 1;\\n  }\\n  \\n  return count;\\n}\\n\\nfunction getNextPermutation(nums) {\\n  let count = 0;\\n  for (let i = nums.length-2; i >= 0; i--) {\\n    if (nums[i] < nums[i+1]) {\\n      for (let j = nums.length-1; j > i; j--) {\\n        if (nums[j] > nums[i]) {\\n          [nums[i], nums[j]] = [nums[j], nums[i]];\\n          reverse(i+1, nums.length-1, nums);\\n          return nums;\\n        }\\n      }\\n    }\\n  }\\n  \\n  throw new Error(`not a valid number: ${nums}`);\\n}\\n\\nfunction reverse(start, end, nums) {\\n  while (start < end) {\\n    [nums[start], nums[end]] = [nums[end], nums[start]];\\n    start += 1;\\n    end -= 1;\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1242317,
                "title": "c-explained-implementation",
                "content": "Code has been commented below:\\n```\\nclass Solution {\\n   \\npublic:\\n    int getMinSwaps(string num, int k) {\\n        \\n        string temp = num; //store the string in temp to get process it \\n        int ans=0;\\n//next_permutation gives us the lexicographically greater permuatation, we repaeat it k times\\n        while(k--){\\n            next_permutation(temp.begin(), temp.end());\\n        }\\n        \\n// Now we loop & look for the first point of difference in temp & num string\\n        for(int i=0;i<num.size();i++){\\n//if i is the point of difference then we traverse further till we find the position in temp\\n//whose value equals num[i]\\n            if(temp[i] !=  num[i]){\\n                int j=i;\\n                while(num[i]!=temp[j]){\\n                    j++;\\n                }\\n// so once we have found the posiiton in temp the number of swap for this change will be j-i\\n                ans += j-i;\\n// we bring the nums[i] to same position in temp and remove the extra element at j+1\\n                temp.insert(temp.begin()+i, num[i]);\\n                temp.erase(temp.begin()+j+1);\\n            }\\n// we repeat this until all the char match in both num and temp\\n        }\\n        \\n        //finally return the ans\\n        return ans;\\n    }\\n};\\n```\\n**Do upvote if explanation was useful & you liked the code:) **",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n   \\npublic:\\n    int getMinSwaps(string num, int k) {\\n        \\n        string temp = num; //store the string in temp to get process it \\n        int ans=0;\\n//next_permutation gives us the lexicographically greater permuatation, we repaeat it k times\\n        while(k--){\\n            next_permutation(temp.begin(), temp.end());\\n        }\\n        \\n// Now we loop & look for the first point of difference in temp & num string\\n        for(int i=0;i<num.size();i++){\\n//if i is the point of difference then we traverse further till we find the position in temp\\n//whose value equals num[i]\\n            if(temp[i] !=  num[i]){\\n                int j=i;\\n                while(num[i]!=temp[j]){\\n                    j++;\\n                }\\n// so once we have found the posiiton in temp the number of swap for this change will be j-i\\n                ans += j-i;\\n// we bring the nums[i] to same position in temp and remove the extra element at j+1\\n                temp.insert(temp.begin()+i, num[i]);\\n                temp.erase(temp.begin()+j+1);\\n            }\\n// we repeat this until all the char match in both num and temp\\n        }\\n        \\n        //finally return the ans\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1231901,
                "title": "c-know-yo-algorithm-s",
                "content": "First off, note that this is not quite as fast as the usual coding competition versions with numerical indices.\\n\\nHowever, if you\\'re interviewing at a company, people really love to see use of the std library.\\n\\nNote: you can probably do purely forward iteration in the last bit.\\n\\nThis is a greedy version because we (correctly) assume that the next item we find that matches the correct version in `num` is the item we want (greedy proof: the items in the \"mismatched\" region must construct an identical bag).\\n\\n```\\n#include <algorithm>\\nclass Solution {\\npublic:\\n    static\\n    int getMinSwaps(string const &num, int const k) {\\n        auto permuted = num;\\n        for (int i{0}; i < k; ++i) {\\n            next_permutation(begin(permuted), end(permuted));\\n        }\\n        \\n\\t\\t// Find the first place where the two digits differ\\n        auto [num_b, perm_b] = mismatch(cbegin(num), cend(num), begin(permuted));\\n        \\n        // turn them into reverse iters so we can swap from the end\\n        auto perm_r = rbegin(permuted);\\n        auto perm_e = reverse_iterator(perm_b);\\n        \\n        int total_distance{};\\n        for (auto num_r = crbegin(num), num_e = reverse_iterator(num_b);\\n            num_r != num_e; advance(num_r, 1), advance(perm_r, 1)) {\\n            //cout << permuted << \\'\\\\n\\';\\n            // Find the first position where they mismatch\\n            auto [num_pos, perm_pos] = mismatch(num_r, num_e, perm_r);\\n            if (num_pos == num_e)\\n                break; // everything is fine!\\n            \\n            // search ahead in perm to find where it equals *num_pos\\n            auto perm_correct_pos = find(perm_pos, perm_e, *num_pos);\\n            assert(perm_correct_pos != perm_e); // it should ALWAYS find it\\n            \\n            total_distance += distance(perm_pos, perm_correct_pos);\\n\\t\\t\\t// change to a forward iterator so we only have to do a left rotate of distance 1\\n\\t\\t\\t// instead of a right rotate of distance N\\n            auto fwd = next(perm_correct_pos).base(); // flips it and subs 1\\n            auto rotate_result = rotate(fwd, fwd+1, perm_pos.base());\\n        }\\n        return total_distance;\\n    }\\n};\\n``",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    static\\n    int getMinSwaps(string const &num, int const k) {\\n        auto permuted = num;\\n        for (int i{0}",
                "codeTag": "Java"
            },
            {
                "id": 1205971,
                "title": "tried-next-permutation-bfs",
                "content": "\\'\\'\\'class Solution {\\npublic:\\n    int f=INT_MAX;\\n    void nextpermutation(string& s)\\n    { int j=s.length()-1;\\n        while(j>0&&(s[j-1]-\\'0\\')>=(s[j]-\\'0\\'))\\n        {j--;}\\n        int i=s.length()-1;\\n     int ans=10;\\n     int ans1;\\n        while((j-1)<i)\\n        { if((s[i]-\\'0\\')>(s[j-1]-\\'0\\')&&(s[i]-\\'0\\')<ans)\\n        {ans=(s[i]-\\'0\\');\\n         ans1=i;}\\n            i--;\\n        }\\n        swap(s[j-1],s[ans1]);\\n     reverse(s.begin()+j,s.end());\\n        f=min(f,j-1);\\n    }\\n    int getMinSwaps(string num, int k) {\\n       string s=num;\\n        vector <int> v1[10],v2[10];\\n        for(int i=0;i<k;i++)\\n        { nextpermutation(num);\\n        }\\n\\n      queue <string> q;\\n        unordered_set <string> se;\\n        se.insert(s);\\n        q.push(s);\\n        int l=0;\\n        while(!q.empty())\\n        { l++;\\n\\n         int m=q.size();\\n            for(int i=0;i<m;i++)\\n            {string z=q.front();\\n         q.pop();  \\n\\n            for(int j=f;j<z.length()-1;j++)\\n            {\\n            swap(z[j],z[j+1]);\\n             \\n             if(z==num)\\n                 return l;\\n            if(se.count(z)==0)\\n               q.push(z);\\n             se.insert(z);\\n             swap(z[j],z[j+1]);}\\n            }\\n        }\\n        \\n        }\\n        return 0;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int f=INT_MAX;\\n    void nextpermutation(string& s)\\n    { int j=s.length()-1;\\n        while(j>0&&(s[j-1]-\\'0\\')>=(s[j]-\\'0\\'))\\n        {j--;}",
                "codeTag": "Java"
            },
            {
                "id": 1205492,
                "title": "java-next-permutation-adjacentswap-o-n-2",
                "content": "```\\nclass Solution {\\n    public int getMinSwaps(String num, int k) {\\n        int[] numsOriginal = new int[num.length()];\\n        int[] nums = new int[num.length()];\\n        int i = 0;\\n        for(char ch : num.toCharArray()){\\n            nums[i] = Character.getNumericValue(ch);\\n            numsOriginal[i] = nums[i];\\n            i++;\\n        }\\n        for(i =0 ; i < k; i++){\\n            nextPermutation(nums); \\n        }\\n        return findDistance(nums, numsOriginal);\\n    }\\n    \\n    private int findDistance(int[] original, int[] nums){\\n        int ct = 0;\\n        int n = nums.length;\\n        for(int i = 0; i < n; i++){\\n            if(nums[i] == original[i]) continue;\\n            int fI = original[i];\\n            int k = i+1;\\n            for( ;k <n; k++){\\n                if(nums[k] == fI){\\n                    break;\\n                }\\n            }\\n            for(int j = k; j>i; j--){\\n                int tmp = nums[j];\\n                nums[j] = nums[j-1];\\n                nums[j-1] = tmp;\\n                ct++;\\n            }\\n        }\\n        \\n        return ct;\\n    }\\n    \\n    public void nextPermutation(int[] nums) {\\n        if(nums.length == 1) return;\\n        int i = nums.length -2;\\n        for( ; i >=0; i--){\\n            if(nums[i] <nums[i+1]){\\n                break;\\n            }\\n        }\\n        if(i>=0){\\n            int k = i+1;\\n            int index = -1;\\n            for(; k< nums.length; k++){\\n                if(nums[k] > nums[i]){\\n                    index = k;\\n                }\\n            }\\n            int temp = nums[i];\\n            nums[i] = nums[index];\\n            nums[index] = temp;\\n        }\\n        Arrays.sort(nums,i+1, nums.length);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int getMinSwaps(String num, int k) {\\n        int[] numsOriginal = new int[num.length()];\\n        int[] nums = new int[num.length()];\\n        int i = 0;\\n        for(char ch : num.toCharArray()){\\n            nums[i] = Character.getNumericValue(ch);\\n            numsOriginal[i] = nums[i];\\n            i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1203470,
                "title": "does-not-pass-all-test-cases-will-improve-on-it",
                "content": "```\\n\"\"\"\\nCreated on Mon May 10 14:35:50 2021\\n\\n@author: Utpal\\n\"\"\"\\n\\ndef swap_element(lst, k, num_swaps):\\n    \\n     last = lst[-1]\\n     cnt = 0       \\n     \\n     for index, c in enumerate(lst[-2::-1]):\\n\\n               if int(last) > int(c) and cnt<k:   \\n                      lst[-1-(index+1)], lst[-(index+1)] = lst[-(index+1)], lst[-1-(index+1)]\\n                      num_swaps +=1\\n                      cnt+=1\\n                      last = lst[-1-(index+1)]\\n               else:\\n                      cnt+=1\\n                      continue\\n               \\n     return lst, num_swaps\\n    \\nclass Solution(object):\\n    def getMinSwaps(self, num, k):\\n        \"\"\"\\n        :type num: str\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        if not (num.isdigit()):\\n            raise ValueError(\"Non-digit found\")\\n        elif not(2 <= len(num) <= 1000):\\n            raise ValueError(\"length of num out of bounds\")\\n        elif not(1 <= k <= 1000):\\n            raise ValueError(\"k is out of bounds\")\\n        else:\\n            lst = []\\n            for c in num:\\n                lst.append(c)\\n            num_swaps = 0    \\n            for cnt in range(0,k):\\n                lst, num_swaps = swap_element(lst, k, num_swaps)\\n        return num_swaps    \\n\\nnum = \"5489355142\"\\nk = 4\\n\\n# num = \"11112\"\\n# k = 4\\n\\n# num = \"00123\"\\n# k = 1\\n\\nnum_swaps = Solution().getMinSwaps(num, k)\\nprint (num_swaps)          \\n```",
                "solutionTags": [],
                "code": "```\\n\"\"\"\\nCreated on Mon May 10 14:35:50 2021\\n\\n@author: Utpal\\n\"\"\"\\n\\ndef swap_element(lst, k, num_swaps):\\n    \\n     last = lst[-1]\\n     cnt = 0       \\n     \\n     for index, c in enumerate(lst[-2::-1]):\\n\\n               if int(last) > int(c) and cnt<k:   \\n                      lst[-1-(index+1)], lst[-(index+1)] = lst[-(index+1)], lst[-1-(index+1)]\\n                      num_swaps +=1\\n                      cnt+=1\\n                      last = lst[-1-(index+1)]\\n               else:\\n                      cnt+=1\\n                      continue\\n               \\n     return lst, num_swaps\\n    \\nclass Solution(object):\\n    def getMinSwaps(self, num, k):\\n        \"\"\"\\n        :type num: str\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        if not (num.isdigit()):\\n            raise ValueError(\"Non-digit found\")\\n        elif not(2 <= len(num) <= 1000):\\n            raise ValueError(\"length of num out of bounds\")\\n        elif not(1 <= k <= 1000):\\n            raise ValueError(\"k is out of bounds\")\\n        else:\\n            lst = []\\n            for c in num:\\n                lst.append(c)\\n            num_swaps = 0    \\n            for cnt in range(0,k):\\n                lst, num_swaps = swap_element(lst, k, num_swaps)\\n        return num_swaps    \\n\\nnum = \"5489355142\"\\nk = 4\\n\\n# num = \"11112\"\\n# k = 4\\n\\n# num = \"00123\"\\n# k = 1\\n\\nnum_swaps = Solution().getMinSwaps(num, k)\\nprint (num_swaps)          \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1201220,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        int n = num.size();\\n        string s = num;\\n        while(k--) {\\n            next_permutation(s.begin(), s.end());\\n        }\\n        int pos = 0;\\n        while(pos < n && s[pos] == num[pos])\\n            pos++;\\n        int ans = 0;\\n        for(int i = pos; i < n; i++) {\\n            if(s[i] != num[i]) {\\n                int in;\\n                for(int j = i; j < n; j++) {\\n                    if(num[j] == s[i]) {\\n                        ans += j - i;\\n                        in = j;\\n                        break;\\n                    }\\n                }\\n                char a = num[in];\\n                while(in > i) {\\n                    num[in] = num[in - 1];\\n                    in--;\\n                }\\n                num[i] = a;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMinSwaps(string num, int k) {\\n        int n = num.size();\\n        string s = num;\\n        while(k--) {\\n            next_permutation(s.begin(), s.end());\\n        }\\n        int pos = 0;\\n        while(pos < n && s[pos] == num[pos])\\n            pos++;\\n        int ans = 0;\\n        for(int i = pos; i < n; i++) {\\n            if(s[i] != num[i]) {\\n                int in;\\n                for(int j = i; j < n; j++) {\\n                    if(num[j] == s[i]) {\\n                        ans += j - i;\\n                        in = j;\\n                        break;\\n                    }\\n                }\\n                char a = num[in];\\n                while(in > i) {\\n                    num[in] = num[in - 1];\\n                    in--;\\n                }\\n                num[i] = a;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1200296,
                "title": "ruby-next-permutation",
                "content": "**Idea**\\n\\n- The problem can be divided into two smaller one: generate the next permutation of the string and calculate the swapping operation to get there.\\n- Generate next permutation:\\n  - Take \"3421\" as an example.\\n  - Going from right to left, find the first number that is not in the descending order that is \"3\".\\n  - Find the next larger number to \"3\" in the right side that is \"4\" then swap them. Now we have \"4321\". This can be done with binary search for 0(log(n)) runtime.\\n  - Sort \"321\" in ascending order to get \"123\". Actually, we can just reverse it to save time since the order is maintained.\\n  - Now we get \"4123\" as the next permutation of \"3421\".\\n- Calculate swapping operation:\\n - Take \"a = 4123\" and \"b = 3421\" as an example.\\n - For each number in a, find the index of that number in b\\n - Calculate the different between the two index and add to the final result.\\n\\n**Complexity**\\n\\n- O(n**2) for both generating permutation and calculating the swap operation\\n\\n**Code**\\n\\n```ruby\\nclass Solution\\n  def self.get_min_swap(a, k)\\n    a = a.split(\"\").reverse\\n    b = a.map(&:clone)\\n    k.times { b = gen_next_permuation(b) }\\n    calc_diff(b, a)\\n  end\\n\\n  def self.gen_next_permuation(a)\\n    n = a.length\\n    i = (0..n-2).find { |x| a[x] > a[x + 1] } + 1\\n    j = a[0, i].bsearch_index { |x| x > a[i] }\\n    a[i], a[j] = a[j], a[i]\\n    a[0, i].reverse + a[i, n]\\n  end\\n\\n  def self.calc_diff(a, b)\\n    ans = 0\\n    n = a.length\\n    n.times do |i|\\n      if a[i] != b[i]\\n        j = i\\n        j += 1 while j < n && b[j] != a[i]\\n        ans += j - i\\n        while j > i\\n          b[j], b[j - 1] = b[j - 1], b[i]\\n          j -= 1\\n        end\\n      end\\n    end\\n\\n    ans\\n  end\\nend\\n```\\n",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\nclass Solution\\n  def self.get_min_swap(a, k)\\n    a = a.split(\"\").reverse\\n    b = a.map(&:clone)\\n    k.times { b = gen_next_permuation(b) }\\n    calc_diff(b, a)\\n  end\\n\\n  def self.gen_next_permuation(a)\\n    n = a.length\\n    i = (0..n-2).find { |x| a[x] > a[x + 1] } + 1\\n    j = a[0, i].bsearch_index { |x| x > a[i] }\\n    a[i], a[j] = a[j], a[i]\\n    a[0, i].reverse + a[i, n]\\n  end\\n\\n  def self.calc_diff(a, b)\\n    ans = 0\\n    n = a.length\\n    n.times do |i|\\n      if a[i] != b[i]\\n        j = i\\n        j += 1 while j < n && b[j] != a[i]\\n        ans += j - i\\n        while j > i\\n          b[j], b[j - 1] = b[j - 1], b[i]\\n          j -= 1\\n        end\\n      end\\n    end\\n\\n    ans\\n  end\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1192671,
                "title": "java-array-string-greedy-beats-92-next-permutation-adjacent-swapping",
                "content": "\\n    // O(n*k + n^2) O(n)\\n\\tpublic int getMinSwaps(String num, int k) {\\n\\n\\t\\tchar[] nums = num.toCharArray();\\n\\t\\tfor (int i = 0; i < k; i++)\\n\\t\\t\\tnextPermutation(nums);\\n\\n\\t\\treturn minKAdjacentSwaps(nums, num);\\n\\t}\\n\\n\\t// O(n) O(1)\\n\\tpublic void nextPermutation(char[] nums) {\\n\\n\\t\\tint len = nums.length, ei = -1;\\n\\t\\tfor (int i = len - 1; i >= 1; i--) {\\n\\t\\t\\tint m = (nums[i - 1] - \\'0\\') - (nums[i] - \\'0\\');\\n\\t\\t\\tif (m < 0) {\\n\\t\\t\\t\\tei = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (ei == -1) {\\n\\t\\t\\treverse(nums, 0, len - 1);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tint idx = ei - 1, temp = nums[idx] - \\'0\\';\\n\\t\\tei = binarySearch(nums, ei, len - 1, temp);\\n\\n\\t\\tswap(nums, idx, ei);\\n\\t\\treverse(nums, idx + 1, len - 1);\\n\\n\\t}\\n\\n\\t// O(logn) O(1)\\n\\tpublic int binarySearch(char[] nums, int hi, int lo, int target) {\\n\\n\\t\\tint ans = -1;\\n\\t\\twhile (lo >= hi) {\\n\\n\\t\\t\\tint mid = (lo + hi) / 2;\\n\\t\\t\\tif (nums[mid] - \\'0\\' > target) {\\n\\t\\t\\t\\tans = mid;\\n\\t\\t\\t\\thi = mid + 1;\\n\\t\\t\\t} else\\n\\t\\t\\t\\tlo = mid - 1;\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// O(n) O(1)\\n\\tpublic void reverse(char[] nums, int si, int ei) {\\n\\n\\t\\twhile (si < ei) {\\n\\t\\t\\tswap(nums, si, ei);\\n\\t\\t\\tsi++;\\n\\t\\t\\tei--;\\n\\t\\t}\\n\\n\\t}\\n\\n\\t// O(1) O(1)\\n\\tpublic void swap(char[] nums, int i, int j) {\\n\\n\\t\\tchar temp = nums[i];\\n\\t\\tnums[i] = nums[j];\\n\\t\\tnums[j] = temp;\\n\\t}\\n\\n\\t// O(n^2) O(1)\\n\\tpublic int minKAdjacentSwaps(char[] src, String target) {\\n\\n\\t\\tint len = src.length, i = 0, j = 0, count = 0;\\n\\t\\twhile (i < len) {\\n\\n\\t\\t\\tif (src[i] != target.charAt(j)) {\\n\\t\\t\\t\\tfor (int k = i + 1; k < len; k++) {\\n\\t\\t\\t\\t\\tif (src[k] == target.charAt(j)) {\\n\\t\\t\\t\\t\\t\\tfor (int l = k; l >= i + 1; l--) {\\n\\t\\t\\t\\t\\t\\t\\tswap(src, l, l - 1);\\n\\t\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\ti++;\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\n\\t\\treturn count;\\n\\t}",
                "solutionTags": [],
                "code": "\\n    // O(n*k + n^2) O(n)\\n\\tpublic int getMinSwaps(String num, int k) {\\n\\n\\t\\tchar[] nums = num.toCharArray();\\n\\t\\tfor (int i = 0; i < k; i++)\\n\\t\\t\\tnextPermutation(nums);\\n\\n\\t\\treturn minKAdjacentSwaps(nums, num);\\n\\t}\\n\\n\\t// O(n) O(1)\\n\\tpublic void nextPermutation(char[] nums) {\\n\\n\\t\\tint len = nums.length, ei = -1;\\n\\t\\tfor (int i = len - 1; i >= 1; i--) {\\n\\t\\t\\tint m = (nums[i - 1] - \\'0\\') - (nums[i] - \\'0\\');\\n\\t\\t\\tif (m < 0) {\\n\\t\\t\\t\\tei = i;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (ei == -1) {\\n\\t\\t\\treverse(nums, 0, len - 1);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tint idx = ei - 1, temp = nums[idx] - \\'0\\';\\n\\t\\tei = binarySearch(nums, ei, len - 1, temp);\\n\\n\\t\\tswap(nums, idx, ei);\\n\\t\\treverse(nums, idx + 1, len - 1);\\n\\n\\t}\\n\\n\\t// O(logn) O(1)\\n\\tpublic int binarySearch(char[] nums, int hi, int lo, int target) {\\n\\n\\t\\tint ans = -1;\\n\\t\\twhile (lo >= hi) {\\n\\n\\t\\t\\tint mid = (lo + hi) / 2;\\n\\t\\t\\tif (nums[mid] - \\'0\\' > target) {\\n\\t\\t\\t\\tans = mid;\\n\\t\\t\\t\\thi = mid + 1;\\n\\t\\t\\t} else\\n\\t\\t\\t\\tlo = mid - 1;\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n\\n\\t// O(n) O(1)\\n\\tpublic void reverse(char[] nums, int si, int ei) {\\n\\n\\t\\twhile (si < ei) {\\n\\t\\t\\tswap(nums, si, ei);\\n\\t\\t\\tsi++;\\n\\t\\t\\tei--;\\n\\t\\t}\\n\\n\\t}\\n\\n\\t// O(1) O(1)\\n\\tpublic void swap(char[] nums, int i, int j) {\\n\\n\\t\\tchar temp = nums[i];\\n\\t\\tnums[i] = nums[j];\\n\\t\\tnums[j] = temp;\\n\\t}\\n\\n\\t// O(n^2) O(1)\\n\\tpublic int minKAdjacentSwaps(char[] src, String target) {\\n\\n\\t\\tint len = src.length, i = 0, j = 0, count = 0;\\n\\t\\twhile (i < len) {\\n\\n\\t\\t\\tif (src[i] != target.charAt(j)) {\\n\\t\\t\\t\\tfor (int k = i + 1; k < len; k++) {\\n\\t\\t\\t\\t\\tif (src[k] == target.charAt(j)) {\\n\\t\\t\\t\\t\\t\\tfor (int l = k; l >= i + 1; l--) {\\n\\t\\t\\t\\t\\t\\t\\tswap(src, l, l - 1);\\n\\t\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\ti++;\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\n\\t\\treturn count;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1192032,
                "title": "go-golang-next-permutation",
                "content": "```\\nfunc getMinSwaps(num string, k int) int {\\n    num1 := []byte(num)\\n\\tfor i := 0; i < k; i++ {\\n\\t\\tnextPermutation(num1)\\n\\t}\\n\\n\\tvar res, j int\\n\\tfor i := 0; i < len(num); i++ {\\n\\t\\tif num[i] != num1[i] {\\n\\t\\t\\tfor j = i + 1; num[i] != num1[j]; j++ {\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ; j != i; j-- {\\n\\t\\t\\t\\tnum1[j], num1[j-1] = num1[j-1], num1[j]\\n\\n\\t\\t\\t\\tres++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn res\\n}\\n\\nfunc nextPermutation(arr []byte) {\\n\\tn := len(arr)\\n\\ti := n - 2\\n\\tfor ; i >= 0 && arr[i] >= arr[i+1]; i-- {\\n\\t}\\n\\n\\tif i >= 0 {\\n\\t\\tj := n - 1\\n\\t\\tfor ; j >= 0 && arr[j] <= arr[i]; j-- {\\n\\t\\t}\\n\\n\\t\\tarr[i], arr[j] = arr[j], arr[i]\\n\\t}\\n\\n\\tfor k, m := i+1, n-1; k < m; k, m = k+1, m-1 {\\n\\t\\tarr[k], arr[m] = arr[m], arr[k]\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc getMinSwaps(num string, k int) int {\\n    num1 := []byte(num)\\n\\tfor i := 0; i < k; i++ {\\n\\t\\tnextPermutation(num1)\\n\\t}\\n\\n\\tvar res, j int\\n\\tfor i := 0; i < len(num); i++ {\\n\\t\\tif num[i] != num1[i] {\\n\\t\\t\\tfor j = i + 1; num[i] != num1[j]; j++ {\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor ; j != i; j-- {\\n\\t\\t\\t\\tnum1[j], num1[j-1] = num1[j-1], num1[j]\\n\\n\\t\\t\\t\\tres++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn res\\n}\\n\\nfunc nextPermutation(arr []byte) {\\n\\tn := len(arr)\\n\\ti := n - 2\\n\\tfor ; i >= 0 && arr[i] >= arr[i+1]; i-- {\\n\\t}\\n\\n\\tif i >= 0 {\\n\\t\\tj := n - 1\\n\\t\\tfor ; j >= 0 && arr[j] <= arr[i]; j-- {\\n\\t\\t}\\n\\n\\t\\tarr[i], arr[j] = arr[j], arr[i]\\n\\t}\\n\\n\\tfor k, m := i+1, n-1; k < m; k, m = k+1, m-1 {\\n\\t\\tarr[k], arr[m] = arr[m], arr[k]\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1191993,
                "title": "javascript-next-permutation-adjacent-swap-160ms",
                "content": "```\\nconst getMinSwaps = (s, k) => {\\n    let a = s.split(\"\");\\n    let np = [...a];\\n    while (k--) nextPermutation(np);\\n    let n = a.length;\\n    let res = 0;\\n    let finish = Array(n).fill(false);\\n    for (let i = 0; i < n; i++) {\\n        let cnt = 0;\\n        for (let j = 0; j < n; j++) {\\n            if (!finish[j] && a[j] == np[i]) {\\n                finish[j] = true;\\n                res += cnt;\\n                break;\\n            }\\n            if (!finish[j]) cnt++;\\n        }\\n    }\\n    return res;\\n};\\n\\n// Another version 148ms\\nconst getMinSwaps = (s, k) => {\\n    let a = s.split(\"\");\\n    let np = [...a];\\n    while (k--) nextPermutation(np);\\n    let n = a.length;\\n    let res = 0;\\n    for (let i = 0; i < n; i++) {\\n        if (a[i] == np[i]) continue;\\n        let j;\\n        for (j = i + 1; j < n && a[j] != np[i]; j++);\\n        for (let k = j; k > i; k--) {\\n            [a[k], a[k - 1]] = [a[k - 1], a[k]];\\n            res++;\\n        }\\n    }\\n    return res;\\n};\\n\\n//////////////////////////////////////////////////////////////////////////////////////\\nconst nextPermutation = (a) => {\\n    let n = a.length;\\n    let i, j;\\n    for (i = n - 2; i >= 0 && a[i] >= a[i + 1]; i--);\\n    if (i == -1) return false;\\n    for (j = i + 1; j < n && a[i] < a[j]; j++);\\n    [a[i], a[j - 1]] = [a[j - 1], a[i]];\\n    for (let p = i + 1, q = n - 1; p < q; p++, q--)[a[p], a[q]] = [a[q], a[p]];\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst getMinSwaps = (s, k) => {\\n    let a = s.split(\"\");\\n    let np = [...a];\\n    while (k--) nextPermutation(np);\\n    let n = a.length;\\n    let res = 0;\\n    let finish = Array(n).fill(false);\\n    for (let i = 0; i < n; i++) {\\n        let cnt = 0;\\n        for (let j = 0; j < n; j++) {\\n            if (!finish[j] && a[j] == np[i]) {\\n                finish[j] = true;\\n                res += cnt;\\n                break;\\n            }\\n            if (!finish[j]) cnt++;\\n        }\\n    }\\n    return res;\\n};\\n\\n// Another version 148ms\\nconst getMinSwaps = (s, k) => {\\n    let a = s.split(\"\");\\n    let np = [...a];\\n    while (k--) nextPermutation(np);\\n    let n = a.length;\\n    let res = 0;\\n    for (let i = 0; i < n; i++) {\\n        if (a[i] == np[i]) continue;\\n        let j;\\n        for (j = i + 1; j < n && a[j] != np[i]; j++);\\n        for (let k = j; k > i; k--) {\\n            [a[k], a[k - 1]] = [a[k - 1], a[k]];\\n            res++;\\n        }\\n    }\\n    return res;\\n};\\n\\n//////////////////////////////////////////////////////////////////////////////////////\\nconst nextPermutation = (a) => {\\n    let n = a.length;\\n    let i, j;\\n    for (i = n - 2; i >= 0 && a[i] >= a[i + 1]; i--);\\n    if (i == -1) return false;\\n    for (j = i + 1; j < n && a[i] < a[j]; j++);\\n    [a[i], a[j - 1]] = [a[j - 1], a[i]];\\n    for (let p = i + 1, q = n - 1; p < q; p++, q--)[a[p], a[q]] = [a[q], a[p]];\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1191693,
                "title": "swift-solution",
                "content": "Swift solution\\n```\\nclass Solution {\\n    func getMinSwaps(_ num: String, _ k: Int) -> Int {\\n        let numOriginal = num.map({ Int($0.asciiValue ?? 48) - 48 }), n = numOriginal.count\\n        var num = numOriginal, result = 0\\n        for i in 0..<k {\\n            nextPermutation(&num)\\n        }\\n        main: while true {\\n            for i in 0..<n where numOriginal[i] != num[i] {\\n                var j = i\\n                while num[j] != numOriginal[i] { j += 1 }\\n                num.remove(at: j)\\n                num.insert(numOriginal[i], at: i)\\n                result += j - i\\n                continue main\\n            }\\n            break\\n        }\\n        return result\\n    }\\n    func nextPermutation(_ nums: inout [Int]) { // https://leetcode.com/problems/next-permutation/\\n        let c = nums.count\\n        var i: Int = c - 1, j: Int = 0\\n        while i > 0 { // try to find ascending sequence\\n            if nums[i] > nums[i - 1] {\\n                break\\n            }\\n            i -= 1\\n        }\\n        if i > 0 { // ascending sequence exists, let\\'s find next greater number\\n            j = i\\n            while j < c {\\n                if nums[i - 1] >= nums[j] {\\n                    break\\n                }\\n                j += 1\\n            }\\n            nums.swapAt(i - 1, j - 1) // swap\\n        }\\n        j = i\\n        while j <= (i + (c - i) / 2 - 1) && nums[j] > nums[c - 1 - (j - i)] { // final sort (swap desc to asc)\\n            nums.swapAt(j, c - 1 - (j - i))\\n            j += 1\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func getMinSwaps(_ num: String, _ k: Int) -> Int {\\n        let numOriginal = num.map({ Int($0.asciiValue ?? 48) - 48 }), n = numOriginal.count\\n        var num = numOriginal, result = 0\\n        for i in 0..<k {\\n            nextPermutation(&num)\\n        }\\n        main: while true {\\n            for i in 0..<n where numOriginal[i] != num[i] {\\n                var j = i\\n                while num[j] != numOriginal[i] { j += 1 }\\n                num.remove(at: j)\\n                num.insert(numOriginal[i], at: i)\\n                result += j - i\\n                continue main\\n            }\\n            break\\n        }\\n        return result\\n    }\\n    func nextPermutation(_ nums: inout [Int]) { // https://leetcode.com/problems/next-permutation/\\n        let c = nums.count\\n        var i: Int = c - 1, j: Int = 0\\n        while i > 0 { // try to find ascending sequence\\n            if nums[i] > nums[i - 1] {\\n                break\\n            }\\n            i -= 1\\n        }\\n        if i > 0 { // ascending sequence exists, let\\'s find next greater number\\n            j = i\\n            while j < c {\\n                if nums[i - 1] >= nums[j] {\\n                    break\\n                }\\n                j += 1\\n            }\\n            nums.swapAt(i - 1, j - 1) // swap\\n        }\\n        j = i\\n        while j <= (i + (c - i) / 2 - 1) && nums[j] > nums[c - 1 - (j - i)] { // final sort (swap desc to asc)\\n            nums.swapAt(j, c - 1 - (j - i))\\n            j += 1\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1576554,
                "content": [
                    {
                        "username": "oldjin",
                        "content": "Can anyone prove the greedy algorithm? I really can\\'t understand..."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "After solving this by myself and looking at others\\' solutions, I lately realized there exists an inbuilt next_permutation function."
                    },
                    {
                        "username": "Tammunur_Joshna",
                        "content": "my code is failing for numss=\"059\" test case please could anyone help on this ?\\nclass Solution {\\n    public int getMinSwaps(String num, int target) {\\n    \\n    char[] ch=num.toCharArray();\\n    char[] ch1=num.toCharArray(); \\n        for(int k=0;k<target;k++){\\n            nextPermutation(ch1);\\n        }\\n        int count=0;\\n        for(int i=0;i<ch.length-1;i++){\\n            if(ch1[i]!=ch[i]){\\n                for(int j=i;j<ch.length;j++){\\n                    if(ch[i]==ch1[j]){\\n                        swap(ch1,i,j);\\n                        count++;\\n                        break;\\n                    }\\n                }\\n            }            \\n        }\\n        return count;\\n    }\\n    public void swap(char[] ch,int m,int n){\\n        char temp=ch[m];\\n        ch[m]=ch[n];\\n        ch[n]=temp;\\n        \\n    }\\n    public void reverse(char[] ch2,int start){\\n        int end=ch2.length-1;\\n        while(start<end){\\n            swap(ch2,start,end);\\n            start++;\\n            end--;\\n        }\\n    }\\n    public void nextPermutation(char[] ch){\\n    \\n     \\n        int i=ch.length-2;\\n        while(i>=0 && ch[i]>=ch[i+1]){\\n            i--;\\n        }\\n        if(i>=0){\\n            int k=ch.length-1;\\n            while(k>=i && ch[i]>=ch[k]){\\n                k--;\\n            }\\n            swap(ch,i,k);\\n        }\\n        reverse(ch,i+1);\\n   \\n    \\n    }\\n    \\n    \\n}"
                    }
                ]
            },
            {
                "id": 1919039,
                "content": [
                    {
                        "username": "oldjin",
                        "content": "Can anyone prove the greedy algorithm? I really can\\'t understand..."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "After solving this by myself and looking at others\\' solutions, I lately realized there exists an inbuilt next_permutation function."
                    },
                    {
                        "username": "Tammunur_Joshna",
                        "content": "my code is failing for numss=\"059\" test case please could anyone help on this ?\\nclass Solution {\\n    public int getMinSwaps(String num, int target) {\\n    \\n    char[] ch=num.toCharArray();\\n    char[] ch1=num.toCharArray(); \\n        for(int k=0;k<target;k++){\\n            nextPermutation(ch1);\\n        }\\n        int count=0;\\n        for(int i=0;i<ch.length-1;i++){\\n            if(ch1[i]!=ch[i]){\\n                for(int j=i;j<ch.length;j++){\\n                    if(ch[i]==ch1[j]){\\n                        swap(ch1,i,j);\\n                        count++;\\n                        break;\\n                    }\\n                }\\n            }            \\n        }\\n        return count;\\n    }\\n    public void swap(char[] ch,int m,int n){\\n        char temp=ch[m];\\n        ch[m]=ch[n];\\n        ch[n]=temp;\\n        \\n    }\\n    public void reverse(char[] ch2,int start){\\n        int end=ch2.length-1;\\n        while(start<end){\\n            swap(ch2,start,end);\\n            start++;\\n            end--;\\n        }\\n    }\\n    public void nextPermutation(char[] ch){\\n    \\n     \\n        int i=ch.length-2;\\n        while(i>=0 && ch[i]>=ch[i+1]){\\n            i--;\\n        }\\n        if(i>=0){\\n            int k=ch.length-1;\\n            while(k>=i && ch[i]>=ch[k]){\\n                k--;\\n            }\\n            swap(ch,i,k);\\n        }\\n        reverse(ch,i+1);\\n   \\n    \\n    }\\n    \\n    \\n}"
                    }
                ]
            },
            {
                "id": 2007980,
                "content": [
                    {
                        "username": "oldjin",
                        "content": "Can anyone prove the greedy algorithm? I really can\\'t understand..."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "After solving this by myself and looking at others\\' solutions, I lately realized there exists an inbuilt next_permutation function."
                    },
                    {
                        "username": "Tammunur_Joshna",
                        "content": "my code is failing for numss=\"059\" test case please could anyone help on this ?\\nclass Solution {\\n    public int getMinSwaps(String num, int target) {\\n    \\n    char[] ch=num.toCharArray();\\n    char[] ch1=num.toCharArray(); \\n        for(int k=0;k<target;k++){\\n            nextPermutation(ch1);\\n        }\\n        int count=0;\\n        for(int i=0;i<ch.length-1;i++){\\n            if(ch1[i]!=ch[i]){\\n                for(int j=i;j<ch.length;j++){\\n                    if(ch[i]==ch1[j]){\\n                        swap(ch1,i,j);\\n                        count++;\\n                        break;\\n                    }\\n                }\\n            }            \\n        }\\n        return count;\\n    }\\n    public void swap(char[] ch,int m,int n){\\n        char temp=ch[m];\\n        ch[m]=ch[n];\\n        ch[n]=temp;\\n        \\n    }\\n    public void reverse(char[] ch2,int start){\\n        int end=ch2.length-1;\\n        while(start<end){\\n            swap(ch2,start,end);\\n            start++;\\n            end--;\\n        }\\n    }\\n    public void nextPermutation(char[] ch){\\n    \\n     \\n        int i=ch.length-2;\\n        while(i>=0 && ch[i]>=ch[i+1]){\\n            i--;\\n        }\\n        if(i>=0){\\n            int k=ch.length-1;\\n            while(k>=i && ch[i]>=ch[k]){\\n                k--;\\n            }\\n            swap(ch,i,k);\\n        }\\n        reverse(ch,i+1);\\n   \\n    \\n    }\\n    \\n    \\n}"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Interval to Include Each Query",
        "question_content": "<p>You are given a 2D integer array <code>intervals</code>, where <code>intervals[i] = [left<sub>i</sub>, right<sub>i</sub>]</code> describes the <code>i<sup>th</sup></code> interval starting at <code>left<sub>i</sub></code> and ending at <code>right<sub>i</sub></code> <strong>(inclusive)</strong>. The <strong>size</strong> of an interval is defined as the number of integers it contains, or more formally <code>right<sub>i</sub> - left<sub>i</sub> + 1</code>.</p>\n\n<p>You are also given an integer array <code>queries</code>. The answer to the <code>j<sup>th</sup></code> query is the <strong>size of the smallest interval</strong> <code>i</code> such that <code>left<sub>i</sub> &lt;= queries[j] &lt;= right<sub>i</sub></code>. If no such interval exists, the answer is <code>-1</code>.</p>\n\n<p>Return <em>an array containing the answers to the queries</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> intervals = [[1,4],[2,4],[3,6],[4,4]], queries = [2,3,4,5]\n<strong>Output:</strong> [3,3,1,4]\n<strong>Explanation:</strong> The queries are processed as follows:\n- Query = 2: The interval [2,4] is the smallest interval containing 2. The answer is 4 - 2 + 1 = 3.\n- Query = 3: The interval [2,4] is the smallest interval containing 3. The answer is 4 - 2 + 1 = 3.\n- Query = 4: The interval [4,4] is the smallest interval containing 4. The answer is 4 - 4 + 1 = 1.\n- Query = 5: The interval [3,6] is the smallest interval containing 5. The answer is 6 - 3 + 1 = 4.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> intervals = [[2,3],[2,5],[1,8],[20,25]], queries = [2,19,5,22]\n<strong>Output:</strong> [2,-1,4,6]\n<strong>Explanation:</strong> The queries are processed as follows:\n- Query = 2: The interval [2,3] is the smallest interval containing 2. The answer is 3 - 2 + 1 = 2.\n- Query = 19: None of the intervals contain 19. The answer is -1.\n- Query = 5: The interval [2,5] is the smallest interval containing 5. The answer is 5 - 2 + 1 = 4.\n- Query = 22: The interval [20,25] is the smallest interval containing 22. The answer is 25 - 20 + 1 = 6.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= intervals.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= queries.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>intervals[i].length == 2</code></li>\n\t<li><code>1 &lt;= left<sub>i</sub> &lt;= right<sub>i</sub> &lt;= 10<sup>7</sup></code></li>\n\t<li><code>1 &lt;= queries[j] &lt;= 10<sup>7</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1186817,
                "title": "java-c-python-priority-queue-solution",
                "content": "# **Explanation**\\nSort `queries` and intervals.\\nIterate `queries` from small to big,\\nand find out all open intervals `[l, r]`,\\nand we add them to a priority queue.\\nAlso, we need to remove all closed interval from the queue.\\n\\nIn the priority, we use\\n`[interval size, interval end] = [r-l+1, r]` as the key.\\n\\nThe head of the queue is the smallest interval we want to return for each query.\\n<br>\\n\\n# **Complexity**\\nTime `O(nlogn + qlogq)`\\nSpace `O(n+q)`\\nwhere `q = queries.size()`\\n<br>\\n**Java**\\nUsing TreeMap\\n```java\\n    public int[] minInterval(int[][] A, int[] queries) {\\n        TreeMap<Integer, Integer> pq = new TreeMap<>();\\n        HashMap<Integer, Integer> res = new HashMap<>();\\n        int i = 0, n = A.length, m = queries.length;\\n        int[] Q = queries.clone(), res2 = new int[m];\\n        Arrays.sort(A, (a, b) -> Integer.compare(a[0] , b[0]));\\n        Arrays.sort(Q);\\n        for (int q : Q) {\\n            while (i < n && A[i][0] <= q) {\\n                int l = A[i][0], r = A[i++][1];\\n                pq.put(r - l + 1, r);\\n            }\\n            while (!pq.isEmpty() && pq.firstEntry().getValue() < q)\\n                pq.pollFirstEntry();\\n            res.put(q, pq.isEmpty() ? -1 : pq.firstKey());\\n        }\\n        i = 0;\\n        for (int q : queries)\\n            res2[i++] = res.get(q);\\n        return res2;\\n    }\\n```\\n**C++**\\n```cpp\\n    vector<int> minInterval(vector<vector<int>>& A, vector<int>& queries) {\\n        priority_queue<vector<int>> pq;\\n        unordered_map<int, int> res;\\n        vector<int> Q = queries, res2;\\n        sort(A.begin(), A.end());\\n        sort(Q.begin(), Q.end());\\n        int i = 0, n = A.size();\\n        for (int q : Q) {\\n            while (i < n && A[i][0] <= q) {\\n                int l = A[i][0], r = A[i++][1];\\n                pq.push({l - r - 1, r});\\n            }\\n            while (pq.size() && pq.top()[1] < q)\\n                pq.pop();\\n            res[q] = pq.size() ? -pq.top()[0] : -1;\\n        }\\n        for (int q : queries)\\n            res2.push_back(res[q]);\\n        return res2;\\n    }\\n```\\n**Python**\\n```py\\n    def minInterval(self, A, queries):\\n        A = sorted(A)[::-1]\\n        h = []\\n        res = {}\\n        for q in sorted(queries):\\n            while A and A[-1][0] <= q:\\n                i, j = A.pop()\\n                if j >= q:\\n                    heapq.heappush(h, [j - i + 1, j])\\n            while h and h[0][1] < q:\\n                heapq.heappop(h)\\n            res[q] = h[0][0] if h else -1\\n        return [res[q] for q in queries]\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int[] minInterval(int[][] A, int[] queries) {\\n        TreeMap<Integer, Integer> pq = new TreeMap<>();\\n        HashMap<Integer, Integer> res = new HashMap<>();\\n        int i = 0, n = A.length, m = queries.length;\\n        int[] Q = queries.clone(), res2 = new int[m];\\n        Arrays.sort(A, (a, b) -> Integer.compare(a[0] , b[0]));\\n        Arrays.sort(Q);\\n        for (int q : Q) {\\n            while (i < n && A[i][0] <= q) {\\n                int l = A[i][0], r = A[i++][1];\\n                pq.put(r - l + 1, r);\\n            }\\n            while (!pq.isEmpty() && pq.firstEntry().getValue() < q)\\n                pq.pollFirstEntry();\\n            res.put(q, pq.isEmpty() ? -1 : pq.firstKey());\\n        }\\n        i = 0;\\n        for (int q : queries)\\n            res2[i++] = res.get(q);\\n        return res2;\\n    }\\n```\n```cpp\\n    vector<int> minInterval(vector<vector<int>>& A, vector<int>& queries) {\\n        priority_queue<vector<int>> pq;\\n        unordered_map<int, int> res;\\n        vector<int> Q = queries, res2;\\n        sort(A.begin(), A.end());\\n        sort(Q.begin(), Q.end());\\n        int i = 0, n = A.size();\\n        for (int q : Q) {\\n            while (i < n && A[i][0] <= q) {\\n                int l = A[i][0], r = A[i++][1];\\n                pq.push({l - r - 1, r});\\n            }\\n            while (pq.size() && pq.top()[1] < q)\\n                pq.pop();\\n            res[q] = pq.size() ? -pq.top()[0] : -1;\\n        }\\n        for (int q : queries)\\n            res2.push_back(res[q]);\\n        return res2;\\n    }\\n```\n```py\\n    def minInterval(self, A, queries):\\n        A = sorted(A)[::-1]\\n        h = []\\n        res = {}\\n        for q in sorted(queries):\\n            while A and A[-1][0] <= q:\\n                i, j = A.pop()\\n                if j >= q:\\n                    heapq.heappush(h, [j - i + 1, j])\\n            while h and h[0][1] < q:\\n                heapq.heappop(h)\\n            res[q] = h[0][0] if h else -1\\n        return [res[q] for q in queries]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1186911,
                "title": "iterate-through-queries-vs-intervals",
                "content": "#### Solution 1: Iterate through queries\\n\\nHere we sort queries by their position and intervals by their left point. Then we process queries in the increasing order, and maintain a set of intervals that can potentially overlap with each query. Intervals in that set are ordered by the interval size.\\n\\nFor each query, we first add overlapping intervals (`left <= query`) to our set. Then, we pick the first interval from the set (smallest, as intervals are sorted by their size in the set).\\n\\nHowever, we need to check if the smallest interval still overlaps with our query. We use the second value in our set (`right`) to check and remove intervals that no longer overlap.\\n\\n```cpp\\nvector<int> minInterval(vector<vector<int>>& ints, vector<int>& qs) {\\n    sort(begin(ints), end(ints));\\n    set<pair<int, int>> s;\\n    vector<int> ids(qs.size()), res(qs.size(), -1);\\n    iota(begin(ids), end(ids), 0);\\n    sort(begin(ids), end(ids), [&](const auto a, const auto b){ return qs[a] < qs[b]; });\\n    int j = 0;\\n    for (auto i : ids) {\\n        for (; j < ints.size() && ints[j][0] <= qs[i]; ++j)\\n            s.insert({ints[j][1] - ints[j][0] + 1, ints[j][1]});\\n        while (!s.empty() && begin(s)->second < qs[i])\\n            s.erase(begin(s));\\n        if (!s.empty())\\n            res[i] = begin(s)->first;\\n    }\\n    return res;\\n}\\n```\\n\\n#### Solution 2: Iterate through intervals\\nThis is another way to look at this problem. We process intervals from smaller to larger, and binary-search for queries that fit into the current interval.\\n\\nFor that, we store queries in a set; when a query fits into an interval, we record the answer and remote that query from the set. That way, we guarantee that we pick the smallest interval for that query.\\n\\n```cpp\\nvector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n    vector<int> res(queries.size(), -1);\\n    sort(intervals.begin(), intervals.end(), [](const auto &a, const auto &b) { return a[1] - a[0] < b[1] - b[0]; });\\n    set<pair<int, int>> s;\\n    for (int i = 0; i < queries.size(); ++i)\\n        s.insert({queries[i], i});\\n    for (auto &i : intervals) {\\n        auto it = s.lower_bound({i[0], 0});\\n        while (it != end(s) && it->first <= i[1]) {\\n            res[it->second] = i[1] - i[0] + 1;\\n            s.erase(it++);\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nvector<int> minInterval(vector<vector<int>>& ints, vector<int>& qs) {\\n    sort(begin(ints), end(ints));\\n    set<pair<int, int>> s;\\n    vector<int> ids(qs.size()), res(qs.size(), -1);\\n    iota(begin(ids), end(ids), 0);\\n    sort(begin(ids), end(ids), [&](const auto a, const auto b){ return qs[a] < qs[b]; });\\n    int j = 0;\\n    for (auto i : ids) {\\n        for (; j < ints.size() && ints[j][0] <= qs[i]; ++j)\\n            s.insert({ints[j][1] - ints[j][0] + 1, ints[j][1]});\\n        while (!s.empty() && begin(s)->second < qs[i])\\n            s.erase(begin(s));\\n        if (!s.empty())\\n            res[i] = begin(s)->first;\\n    }\\n    return res;\\n}\\n```\n```cpp\\nvector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n    vector<int> res(queries.size(), -1);\\n    sort(intervals.begin(), intervals.end(), [](const auto &a, const auto &b) { return a[1] - a[0] < b[1] - b[0]; });\\n    set<pair<int, int>> s;\\n    for (int i = 0; i < queries.size(); ++i)\\n        s.insert({queries[i], i});\\n    for (auto &i : intervals) {\\n        auto it = s.lower_bound({i[0], 0});\\n        while (it != end(s) && it->first <= i[1]) {\\n            res[it->second] = i[1] - i[0] + 1;\\n            s.erase(it++);\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1207571,
                "title": "java-simple-and-easy-to-understand-solution-109-ms-faster-than-85-05-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n\\n```\\nclass Solution {\\n    public int[] minInterval(int[][] intervals, int[] queries) {\\n        int numQuery = queries.length;\\n        \\n        //append index in query\\n        int[][] queriesWithIndex = new int[numQuery][2];\\n        for(int i = 0; i < numQuery; i++){\\n            queriesWithIndex[i] = new int[]{queries[i], i};\\n        }\\n        \\n        Arrays.sort(intervals, (a, b) -> (a[0] - b[0]));\\n        Arrays.sort(queriesWithIndex, (a, b) -> (a[0] - b[0]));\\n        \\n        //sort interval in increasing order of size\\n        PriorityQueue<int[]> minHeap = new PriorityQueue<int[]>((a, b) -> ((a[1] - a[0]) - (b[1] - b[0])));\\n        \\n        int[] result = new int[numQuery];\\n        \\n        int j = 0;\\n        for(int i = 0; i < queries.length; i++){\\n            int queryVal = queriesWithIndex[i][0];\\n            int queryIndex = queriesWithIndex[i][1];\\n            \\n            //add all the interval which start is less or equal than current query value \\n            while(j < intervals.length && intervals[j][0] <= queryVal){\\n                minHeap.add(intervals[j]);\\n                j++;\\n            }\\n            \\n            //remove all the smallest size interval which end val is less than current query value\\n            while(!minHeap.isEmpty() && minHeap.peek()[1] < queryVal){\\n                minHeap.remove();\\n            }\\n            //now if heap is empty it means there is no interval which satisfy query val\\n            result[queryIndex] = minHeap.isEmpty() ? -1 : (minHeap.peek()[1] - minHeap.peek()[0] + 1); \\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] minInterval(int[][] intervals, int[] queries) {\\n        int numQuery = queries.length;\\n        \\n        //append index in query\\n        int[][] queriesWithIndex = new int[numQuery][2];\\n        for(int i = 0; i < numQuery; i++){\\n            queriesWithIndex[i] = new int[]{queries[i], i};\\n        }\\n        \\n        Arrays.sort(intervals, (a, b) -> (a[0] - b[0]));\\n        Arrays.sort(queriesWithIndex, (a, b) -> (a[0] - b[0]));\\n        \\n        //sort interval in increasing order of size\\n        PriorityQueue<int[]> minHeap = new PriorityQueue<int[]>((a, b) -> ((a[1] - a[0]) - (b[1] - b[0])));\\n        \\n        int[] result = new int[numQuery];\\n        \\n        int j = 0;\\n        for(int i = 0; i < queries.length; i++){\\n            int queryVal = queriesWithIndex[i][0];\\n            int queryIndex = queriesWithIndex[i][1];\\n            \\n            //add all the interval which start is less or equal than current query value \\n            while(j < intervals.length && intervals[j][0] <= queryVal){\\n                minHeap.add(intervals[j]);\\n                j++;\\n            }\\n            \\n            //remove all the smallest size interval which end val is less than current query value\\n            while(!minHeap.isEmpty() && minHeap.peek()[1] < queryVal){\\n                minHeap.remove();\\n            }\\n            //now if heap is empty it means there is no interval which satisfy query val\\n            result[queryIndex] = minHeap.isEmpty() ? -1 : (minHeap.peek()[1] - minHeap.peek()[0] + 1); \\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186840,
                "title": "python-union-find",
                "content": "We can first sort the queries, also sort the intervals by their sizes. \\n\\nNow loop over the intervals from smaller sizes to larger sizes, for each interval we can use binary search to find the query positions that lie inside, assign them with the size of the interval and mark as assigned, we simply skip those query positions if they are included in some intervals later as those intervals all have larger sizes.\\n\\nThis process can be implemented with union find, you can find more details [here](https://cp-algorithms.com/data_structures/disjoint_set_union.html#toc-tgt-10) (see section Compress jumps along a segment / Painting subarrays offline).\\n\\nTime complexity: `O(n log n + (n+q) log q)`\\n```\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        q=sorted(set(queries))\\n        n=len(q)\\n               \\n        intervals.sort(key=lambda x:x[1]-x[0])\\n        \\n        ans=[-1]*n\\n        par=list(range(n+1))    \\n        def find(x):\\n            if par[x]!=x:\\n                par[x]=find(par[x])\\n            return par[x]\\n        \\n        for a,b in intervals:\\n            l,r=bisect_left(q,a),bisect_right(q,b)\\n            v=find(l)\\n            while v<r:\\n                ans[v]=b-a+1\\n                par[v]=v+1\\n                v=find(v)\\n        \\n        d={n:i for i,n in enumerate(q)}\\n        return [ans[d[qi]] for qi in queries]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        q=sorted(set(queries))\\n        n=len(q)\\n               \\n        intervals.sort(key=lambda x:x[1]-x[0])\\n        \\n        ans=[-1]*n\\n        par=list(range(n+1))    \\n        def find(x):\\n            if par[x]!=x:\\n                par[x]=find(par[x])\\n            return par[x]\\n        \\n        for a,b in intervals:\\n            l,r=bisect_left(q,a),bisect_right(q,b)\\n            v=find(l)\\n            while v<r:\\n                ans[v]=b-a+1\\n                par[v]=v+1\\n                v=find(v)\\n        \\n        d={n:i for i,n in enumerate(q)}\\n        return [ans[d[qi]] for qi in queries]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186792,
                "title": "python-a-classic-heap-question-explained",
                "content": "**Explanation:**\\n\\nWhile this question has many possible approaches, two of the most natural are the Interval Tree and the Heap. If you have an interval tree implementation handy, and want to handle online queries, that\\'s your best bet. You might also try a complicated setup with binary searches over endpoints, but the code gets messy if you want to avoid iterating over all intervals on each query. \\n\\nHow can you tell that a heap is a good choice? \\n\\n* We\\'re interested in finding a minimum, and elements (intervals [start, end]) are active for a fixed period of time from start to end. \\n* **For repeatedly querying a minimum, with elements entering and leaving, a heap is the most natural data structure.**\\n*  In fact, we can be lazy about removing elements from our heap: we only care about the minimum size interval being active, so other old elements in the middle of the heap make no difference. \\n\\n\\nAfter sorting the queries and intervals, the rest of the code pretty much writes itself. It helps to think of [start, end] as an interval that arrives at time *start* and leaves at time *end*, with a certain value *size*.\\n\\n\\n**Python Code:**\\n```python\\ndef minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n    # Sort intervals in decreasing order of left end\\n    intervals.sort(reverse=True)\\n\\n    # Sort queries and track their original index\\n    sorted_queries = sorted(enumerate(queries), key=lambda y: y[1])\\n    ans = [-1] * len(queries)\\n\\n    # Heap of (size, right_end) pairs\\n    active_intervals = []\\n\\n    for orig_index, point in sorted_queries:\\n\\n        # Clear all \"expired\" intervals [start, end] with end < point\\n        while active_intervals and active_intervals[0][1] < point:\\n            heapq.heappop(active_intervals)\\n\\n        # Process new intervals in order of start; add (size, end) of interval to heap\\n        while intervals and intervals[-1][0] <= point:\\n            x, y = intervals.pop()\\n            # If interval is not expired\\n            if y >= point:\\n                heapq.heappush(active_intervals, (y - x + 1, y))\\n\\n        if active_intervals:\\n            ans[orig_index] = active_intervals[0][0]\\n\\n    return ans\\n```\\n\\n**Complexity Analysis:**\\nTime complexity: **O(N log N + Q log Q)** for sorting both lists, and the N heappops and heappushes in each loop iteration cost log N. Here, N is the number of intervals, and Q is the number of queries. Edit: Thanks to @gautham6 for suggesting an improvement to the complexity analysis.\\nSpace complexity: O(N+Q), for the heap and for sorting overhead.\\n\\nFeel free to ask any questions. If you found this explanation helpful, upvotes are always appreciated :)",
                "solutionTags": [],
                "code": "```python\\ndef minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n    # Sort intervals in decreasing order of left end\\n    intervals.sort(reverse=True)\\n\\n    # Sort queries and track their original index\\n    sorted_queries = sorted(enumerate(queries), key=lambda y: y[1])\\n    ans = [-1] * len(queries)\\n\\n    # Heap of (size, right_end) pairs\\n    active_intervals = []\\n\\n    for orig_index, point in sorted_queries:\\n\\n        # Clear all \"expired\" intervals [start, end] with end < point\\n        while active_intervals and active_intervals[0][1] < point:\\n            heapq.heappop(active_intervals)\\n\\n        # Process new intervals in order of start; add (size, end) of interval to heap\\n        while intervals and intervals[-1][0] <= point:\\n            x, y = intervals.pop()\\n            # If interval is not expired\\n            if y >= point:\\n                heapq.heappush(active_intervals, (y - x + 1, y))\\n\\n        if active_intervals:\\n            ans[orig_index] = active_intervals[0][0]\\n\\n    return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1186856,
                "title": "c-smart-sorting",
                "content": "- This can be solved using some clever sorting (missed this by less than a minute during the contest :O/ )\\n- This is both 100% faster and 100% more memory efficient than other C++ solutions\\n- Sort the intervals by their range (shorter ranges first)\\n- Then take each range one by one, find all queries that belong in that range and set their value to (end - start + 1)\\n- For implementation, I used a set to track queries and after populating each query, I\\'d remove it from the set as we no longer need to worry about it\\n- To enhance performance, once I find the lower_bound, I increment the iterator and keep deleting any values that are within the interval.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        sort(intervals.begin(), intervals.end(), [&](const vector<int> &x, const vector<int> &y) {\\n            return x[1] - x[0] < y[1] - y[0];\\n        });\\n        int i, n = queries.size();\\n        vector<int> ret(n, -1);\\n        set<pair<int, int>> st;\\n        for(i=0; i<n; i++)\\n            st.insert({queries[i], i});\\n        for(i=0; i<intervals.size(); i++) {\\n            int start = intervals[i][0], end = intervals[i][1];\\n            auto it = st.lower_bound({start, 0});\\n            while(it != st.end() && it->first <= end) {\\n                auto it2 = next(it);\\n                ret[it->second] = end - start + 1;\\n                st.erase(it);\\n                it = it2;\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        sort(intervals.begin(), intervals.end(), [&](const vector<int> &x, const vector<int> &y) {\\n            return x[1] - x[0] < y[1] - y[0];\\n        });\\n        int i, n = queries.size();\\n        vector<int> ret(n, -1);\\n        set<pair<int, int>> st;\\n        for(i=0; i<n; i++)\\n            st.insert({queries[i], i});\\n        for(i=0; i<intervals.size(); i++) {\\n            int start = intervals[i][0], end = intervals[i][1];\\n            auto it = st.lower_bound({start, 0});\\n            while(it != st.end() && it->first <= end) {\\n                auto it2 = next(it);\\n                ret[it->second] = end - start + 1;\\n                st.erase(it);\\n                it = it2;\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1187616,
                "title": "python-heap-2-pointers-explained",
                "content": "When you see that you need to find minimum among some set of elements, you should immedietly think about heaps. Let us sort our `intervals` and also add infinite point to the end to avoid some border cases, denote sorted list `A`. Also we sort our queires but also we want to keep indexes, so create sorted list `Q` of pairs `query, index of this query`.\\n\\nLet `n` be the length of `A` and `m` be the length of `Q`. \\n\\nNow, we want to use `2` pointers approach: we use `p1` to traverse intervals `A` and we use `p2` to traverse queries `Q`. At the beginning both pointers start with `0`. Also we keep heap `h`, where we will keep possible candidates: we will keep pairs `(y-x+1, y)` in our heap, because we want to work with lengths of segments. Because we can not delete any element from heap with good complexity, we will do so-called **lazy** updates: each time we look at the smallest element in our heap and if `h[0][1] < q`, this means, that we need to remove this segment from heap, it is not active. Then we have two options:\\n\\n1. `x <= q` means that the start of current interval we working with is smaller than `q`, so potentially `q` can be covered by this interval, so we put new element to our heap and increase `p1`.\\n2. In the opposite case, we need to move pointer `p2` and if heap is not empty, that is we have candidates, update `h[idx]`.\\n\\n#### Complexity\\nTime complexity is `O(n log n + m log m)` to perform sorts and `O((n+m)*log n)` to perform all pops and pushed from our heap. So, total time complexity is `O(n log n + m log m + m log n)`, which can be simplified to `O(n log n + m log m)`. Space complexity is `O(m + n)`.\\n\\n```python\\nclass Solution:\\n    def minInterval(self, intervals, queries):\\n        A = sorted(intervals) + [(float(\"inf\") , 0)]\\n        Q = sorted((j, i) for i, j in enumerate(queries))\\n        n, m = len(A), len(Q)\\n        h, ans, p1, p2 = [], [-1] * m, 0, 0\\n       \\n        while p1 < n and p2 < m:\\n            (x, y), (q, idx) = A[p1], Q[p2]\\n            while h and h[0][1] < q: heappop(h)\\n            \\n            if x <= q:\\n                heappush(h, (y - x + 1, y))\\n                p1 += 1\\n            else:\\n                if h: ans[idx] = h[0][0]\\n                p2 += 1\\n                \\n        return ans\\n```",
                "solutionTags": [
                    "Two Pointers",
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\nclass Solution:\\n    def minInterval(self, intervals, queries):\\n        A = sorted(intervals) + [(float(\"inf\") , 0)]\\n        Q = sorted((j, i) for i, j in enumerate(queries))\\n        n, m = len(A), len(Q)\\n        h, ans, p1, p2 = [], [-1] * m, 0, 0\\n       \\n        while p1 < n and p2 < m:\\n            (x, y), (q, idx) = A[p1], Q[p2]\\n            while h and h[0][1] < q: heappop(h)\\n            \\n            if x <= q:\\n                heappush(h, (y - x + 1, y))\\n                p1 += 1\\n            else:\\n                if h: ans[idx] = h[0][0]\\n                p2 += 1\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1190778,
                "title": "c-simple-sweep-line",
                "content": "**Explanation**\\n\\nWe can combine the two arrays from input into one.\\n\\nLet\\'s call it events. Each event has a form of `[value, type, index_of_query/size_of_interval]`.\\nThen we just sort this array and go event by event from the beginning.\\n\\nWhen we see a new interval, we add it\\'s size to multiset or minheap, when interval closes. we erase it from our data structure and if we encounter query we just look at the beginning of our data structure to see the smallest interval. Important is assigning the right type to each event.\\n\\nInterval openings must be of smallest type, interval endings of biggest type and queries in the middle, because if type of query would be bigger than type of ending of an interval, after sorting we would not consider the query being inside that interval.\\n\\n\\n\\n**Time Complexity**\\n\\nSorting the events array takes `O((n + q) log (n + q) + n log n)`, where `n` is size of intervals array and `q` is size of queries array, since we just need to sort the combined array and then go through it. Then for each event we need to either insert it, erase it or check for minimum, all of which are `O(log n)` operations, since at most `n` elements will be inside the data structure.\\n\\n\\n\\n**Space Complexity**\\n\\nSpace complexity is `O(n + q)`, since the combined array has a size of `n + q`. The data structures take `O(n)` space, but that would make the complexity `O(2 * n + q)`, which is just  `O(n + q)`.\\n\\n\\n\\n**Code**\\n```\\nvector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n\\tvector<vector<int>> events;\\n\\n\\tfor (int i = 0; i < intervals.size(); i++) {\\n\\t\\tevents.push_back({intervals[i][0], 0, intervals[i][1] - intervals[i][0] + 1});\\n\\t\\tevents.push_back({intervals[i][1], 2, intervals[i][1] - intervals[i][0] + 1});\\n\\t}\\n\\tfor (int i = 0; i < queries.size(); i++) {\\n\\t\\tevents.push_back({queries[i], 1, i});\\n\\t}\\n\\n\\tsort(events.begin(), events.end());\\n\\n\\tmultiset<int> sizes;\\n\\tvector<int> ans(queries.size(), -1);\\n\\n\\tfor (auto event : events) {\\n\\t\\tif (event[1] == 0) sizes.insert(event[2]);\\n\\t\\telse if (event[1] == 1) { if (sizes.size() > 0) ans[event[2]] = (*sizes.begin()); }\\n\\t\\telse sizes.erase(sizes.lower_bound(event[2]));\\n\\t}\\n\\n\\treturn ans;\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nvector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n\\tvector<vector<int>> events;\\n\\n\\tfor (int i = 0; i < intervals.size(); i++) {\\n\\t\\tevents.push_back({intervals[i][0], 0, intervals[i][1] - intervals[i][0] + 1});\\n\\t\\tevents.push_back({intervals[i][1], 2, intervals[i][1] - intervals[i][0] + 1});\\n\\t}\\n\\tfor (int i = 0; i < queries.size(); i++) {\\n\\t\\tevents.push_back({queries[i], 1, i});\\n\\t}\\n\\n\\tsort(events.begin(), events.end());\\n\\n\\tmultiset<int> sizes;\\n\\tvector<int> ans(queries.size(), -1);\\n\\n\\tfor (auto event : events) {\\n\\t\\tif (event[1] == 0) sizes.insert(event[2]);\\n\\t\\telse if (event[1] == 1) { if (sizes.size() > 0) ans[event[2]] = (*sizes.begin()); }\\n\\t\\telse sizes.erase(sizes.lower_bound(event[2]));\\n\\t}\\n\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1187744,
                "title": "c-segment-tree-solution-with-lazy-propagation",
                "content": "Let\\'s denote n = Length of points I need to keep track of, which is equal to maximum value of \\'right\\' of all intervals and all queries.\\n\\nTime Complexity: O(intervals.length * logn + queries.length * logn)\\nSpace Complexity: O(n) [Made a tree of 4 * n size and a lazy tree of 4 * n size, so 8 * n space to be exact]\\n\\nn <= 10^7\\n\\n```\\nclass Solution {\\npublic:\\n    void update(int *tree, int *lazy, int treeidx, int left, int right, int lo, int hi, int val){\\n        int lidx = 2*treeidx + 1;\\n        int ridx = 2*treeidx + 2;\\n        int mid = (lo + hi)/2;\\n        if(lazy[treeidx] != INT_MAX){\\n            if(lazy[treeidx] < tree[treeidx]){\\n                tree[treeidx] = lazy[treeidx];\\n                if(lo != hi){\\n                    lazy[lidx] = min(lazy[treeidx] , lazy[lidx]);\\n                    lazy[ridx] = min(lazy[treeidx] , lazy[ridx]);\\n                }\\n            }\\n            lazy[treeidx] = INT_MAX;\\n        }\\n        \\n        // completely outside\\n        if(lo > right || hi < left){\\n            return;\\n        }\\n        // completely inside\\n        if(lo >= left && hi <= right){\\n            lazy[treeidx] = min(lazy[treeidx] , val);\\n            return;\\n        }\\n        // partial\\n        update(tree, lazy, lidx, left, right, lo, mid, val);\\n        update(tree, lazy, ridx, left, right, mid + 1, hi, val);\\n    }\\n    \\n    int query(int *tree, int *lazy, int treeidx, int lo, int hi, int idx){\\n        int lidx = 2*treeidx + 1;\\n        int ridx = 2*treeidx + 2;\\n        int mid = (lo + hi)/2;\\n        if(lazy[treeidx] != INT_MAX){\\n            if(lazy[treeidx] < tree[treeidx]){\\n                tree[treeidx] = lazy[treeidx];\\n                if(lo != hi){\\n                    lazy[lidx] = min(lazy[treeidx] , lazy[lidx]);\\n                    lazy[ridx] = min(lazy[treeidx] , lazy[ridx]);\\n                }\\n            }\\n            lazy[treeidx] = INT_MAX;\\n        }\\n        if(lo == hi){\\n            return tree[treeidx];\\n        }\\n        if(idx <= mid){\\n            return query(tree, lazy, lidx, lo, mid, idx);\\n        } else {\\n            return query(tree, lazy, ridx, mid + 1, hi, idx);\\n        }\\n    }\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        int n = 0;\\n        for(int i=0;i<intervals.size();i++){\\n            n = max(n,intervals[i][1]);\\n        }\\n        for(int i=0;i<queries.size();i++){\\n            n = max(n,queries[i]);\\n        }\\n        n++;\\n        int *tree = new int[4*n];\\n        int *lazy = new int[4*n];\\n        for(int i=0;i<4*n;i++){\\n            tree[i] = INT_MAX;\\n            lazy[i] = INT_MAX;\\n        }\\n        for(int i=0;i<intervals.size();i++){\\n            int val = intervals[i][1] - intervals[i][0] + 1;\\n            update(tree, lazy, 0, intervals[i][0], intervals[i][1], 0, n-1, val);\\n        }\\n        vector<int> ans(queries.size());\\n        for(int i=0;i<queries.size();i++){\\n            int temp = query(tree, lazy, 0, 0, n-1, queries[i]);\\n            if(temp == INT_MAX){\\n                ans[i] = -1;\\n            } else {\\n                ans[i] = temp;\\n            }\\n        }\\n        \\n        delete[] tree;\\n        delete[] lazy;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void update(int *tree, int *lazy, int treeidx, int left, int right, int lo, int hi, int val){\\n        int lidx = 2*treeidx + 1;\\n        int ridx = 2*treeidx + 2;\\n        int mid = (lo + hi)/2;\\n        if(lazy[treeidx] != INT_MAX){\\n            if(lazy[treeidx] < tree[treeidx]){\\n                tree[treeidx] = lazy[treeidx];\\n                if(lo != hi){\\n                    lazy[lidx] = min(lazy[treeidx] , lazy[lidx]);\\n                    lazy[ridx] = min(lazy[treeidx] , lazy[ridx]);\\n                }\\n            }\\n            lazy[treeidx] = INT_MAX;\\n        }\\n        \\n        // completely outside\\n        if(lo > right || hi < left){\\n            return;\\n        }\\n        // completely inside\\n        if(lo >= left && hi <= right){\\n            lazy[treeidx] = min(lazy[treeidx] , val);\\n            return;\\n        }\\n        // partial\\n        update(tree, lazy, lidx, left, right, lo, mid, val);\\n        update(tree, lazy, ridx, left, right, mid + 1, hi, val);\\n    }\\n    \\n    int query(int *tree, int *lazy, int treeidx, int lo, int hi, int idx){\\n        int lidx = 2*treeidx + 1;\\n        int ridx = 2*treeidx + 2;\\n        int mid = (lo + hi)/2;\\n        if(lazy[treeidx] != INT_MAX){\\n            if(lazy[treeidx] < tree[treeidx]){\\n                tree[treeidx] = lazy[treeidx];\\n                if(lo != hi){\\n                    lazy[lidx] = min(lazy[treeidx] , lazy[lidx]);\\n                    lazy[ridx] = min(lazy[treeidx] , lazy[ridx]);\\n                }\\n            }\\n            lazy[treeidx] = INT_MAX;\\n        }\\n        if(lo == hi){\\n            return tree[treeidx];\\n        }\\n        if(idx <= mid){\\n            return query(tree, lazy, lidx, lo, mid, idx);\\n        } else {\\n            return query(tree, lazy, ridx, mid + 1, hi, idx);\\n        }\\n    }\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        int n = 0;\\n        for(int i=0;i<intervals.size();i++){\\n            n = max(n,intervals[i][1]);\\n        }\\n        for(int i=0;i<queries.size();i++){\\n            n = max(n,queries[i]);\\n        }\\n        n++;\\n        int *tree = new int[4*n];\\n        int *lazy = new int[4*n];\\n        for(int i=0;i<4*n;i++){\\n            tree[i] = INT_MAX;\\n            lazy[i] = INT_MAX;\\n        }\\n        for(int i=0;i<intervals.size();i++){\\n            int val = intervals[i][1] - intervals[i][0] + 1;\\n            update(tree, lazy, 0, intervals[i][0], intervals[i][1], 0, n-1, val);\\n        }\\n        vector<int> ans(queries.size());\\n        for(int i=0;i<queries.size();i++){\\n            int temp = query(tree, lazy, 0, 0, n-1, queries[i]);\\n            if(temp == INT_MAX){\\n                ans[i] = -1;\\n            } else {\\n                ans[i] = temp;\\n            }\\n        }\\n        \\n        delete[] tree;\\n        delete[] lazy;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186786,
                "title": "c-min-heap",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Min Heap\\n\\n**Intuition**: We can sort the intervals and queries in ascending order. For each query `q`, we can maintain a sliding window on the intervals array covering the range of intervals that might contain the query `q`.\\n\\n**Algorithm**\\n\\nSort both the intervals array `A` and the queries array `QQ` in ascending order.\\n\\nAssume the current query is `q`, we use a read pointer `i` as the right edge of the sliding window to keep reading intervals whose left edge `<= q`. For each interval we read, we increment the count of the interval length in map `m` and push the right edge and length into a min heap `pq`.\\n\\nThen we keep popping intervals from the min heap whose right edge `< q`, and decrement the count.\\n\\nIn this way, the map `m` stores the lengths of all valid intervals covering the current query, and their corresponding count. We use the smallest length as the answer to the current query.\\n\\n### Complexity Analysis\\n\\nSorting both arrays take `O(NlogN + QlogQ)` time and `O(Q)` space.\\n\\nFor each query, we need to access the map `m` and the min heap `pq` which could contain `O(N)` elements (i.e. takes `O(N)` space), so updating them takes `O(logN)` time.\\n\\nNote that each interval enters the min heap at most once, so this takes amortized `O(NlogN)` time.\\n\\nSo overall, this solution takes `O(NlogN + QlogQ)` time and `O(N + Q)` space\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-239/problems/minimum-interval-to-include-each-query/\\n// Author: github.com/lzl124631x\\n// Time: O(NlogN + QlogQ)\\n// Space: O(N + Q)\\nclass Solution {\\n    typedef pair<int, int> T;\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& A, vector<int>& Q) {\\n        vector<pair<int, int>> QQ; // each element is a pair of query and the corresponding index\\n        for (int i = 0; i < Q.size(); ++i) QQ.emplace_back(Q[i], i); \\n        sort(begin(QQ), end(QQ)); // sort in ascending order of query\\n        sort(begin(A), end(A)); // sort intervals in ascending order\\n        int i = 0, N = A.size(); // `i` is a read pointer scanning `A`.\\n        vector<int> ans(Q.size(), -1);\\n        map<int, int> m; // map `m` stores the mapping from a interval length to its corresponding count.\\n        priority_queue<T, vector<T>, greater<>> pq; // min-heap. Each element is a pair of right edge and interval length\\n        for (auto &[q, index] : QQ) {\\n            for (; i < N && A[i][0] <= q; ++i) { // extend the window\\'s right edge -- cover all the intervals whose left edge <= q\\n                int len = A[i][1] - A[i][0] + 1;\\n                m[len]++;\\n                pq.emplace(A[i][1], len);\\n            }\\n            while (pq.size() && pq.top().first < q) { // shrink the window\\'s left edge -- pop all the intervals whose right edge < q\\n                auto [right, len] = pq.top();\\n                if (--m[len] == 0) m.erase(len);\\n                pq.pop();\\n            }\\n            if (m.size()) ans[index] = m.begin()->first; // the map `m` stores the length of all the valid intervals and their corresponding count. We use the smallest length.\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-239/problems/minimum-interval-to-include-each-query/\\n// Author: github.com/lzl124631x\\n// Time: O(NlogN + QlogQ)\\n// Space: O(N + Q)\\nclass Solution {\\n    typedef pair<int, int> T;\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& A, vector<int>& Q) {\\n        vector<pair<int, int>> QQ; // each element is a pair of query and the corresponding index\\n        for (int i = 0; i < Q.size(); ++i) QQ.emplace_back(Q[i], i); \\n        sort(begin(QQ), end(QQ)); // sort in ascending order of query\\n        sort(begin(A), end(A)); // sort intervals in ascending order\\n        int i = 0, N = A.size(); // `i` is a read pointer scanning `A`.\\n        vector<int> ans(Q.size(), -1);\\n        map<int, int> m; // map `m` stores the mapping from a interval length to its corresponding count.\\n        priority_queue<T, vector<T>, greater<>> pq; // min-heap. Each element is a pair of right edge and interval length\\n        for (auto &[q, index] : QQ) {\\n            for (; i < N && A[i][0] <= q; ++i) { // extend the window\\'s right edge -- cover all the intervals whose left edge <= q\\n                int len = A[i][1] - A[i][0] + 1;\\n                m[len]++;\\n                pq.emplace(A[i][1], len);\\n            }\\n            while (pq.size() && pq.top().first < q) { // shrink the window\\'s left edge -- pop all the intervals whose right edge < q\\n                auto [right, len] = pq.top();\\n                if (--m[len] == 0) m.erase(len);\\n                pq.pop();\\n            }\\n            if (m.size()) ans[index] = m.begin()->first; // the map `m` stores the length of all the valid intervals and their corresponding count. We use the smallest length.\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1373829,
                "title": "c-solution-using-sorting-minheap-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& in, vector<int>& queries) {\\n        \\n        //sort the intervals\\n        //sort the query\\n        sort(in.begin(),in.end());\\n        \\n        //store the indices along with the values\\n        vector<pair<int,int>> q;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            q.push_back({queries[i],i});\\n        }\\n        \\n        sort(q.begin(),q.end());\\n        \\n        vector<int> res(q.size());\\n        //use min heap\\n        using pi=pair<int,int>;\\n        //pi.first stores the size of interval\\n        //pi.second stores the ending value of interval\\n        \\n        //min heap\\n        priority_queue<pi,vector<pi>,greater<pi>> pq;\\n        \\n        \\n        int i=0,len=in.size();\\n        //for every query insert the possible intervals in which the query lies \\n        //into min heap\\n\\n        \\n        for(int j=0;j<q.size();j++)\\n        {\\n            auto[val,ind]=q[j];\\n            \\n            while(i<len && in[i][0]<=val)\\n            {\\n                pq.push({in[i][1]-in[i][0] +1 , in[i][1]});\\n                i++;\\n            }\\n            \\n            //pop out the intervals in minHealw which doesnot include the current  val\\n            while(!pq.empty() && pq.top().second<val)\\n                pq.pop();\\n            \\n            res[ind]=(pq.empty()) ? -1 : pq.top().first;\\n                \\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```\\n**Upvote if this helps you :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& in, vector<int>& queries) {\\n        \\n        //sort the intervals\\n        //sort the query\\n        sort(in.begin(),in.end());\\n        \\n        //store the indices along with the values\\n        vector<pair<int,int>> q;\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            q.push_back({queries[i],i});\\n        }\\n        \\n        sort(q.begin(),q.end());\\n        \\n        vector<int> res(q.size());\\n        //use min heap\\n        using pi=pair<int,int>;\\n        //pi.first stores the size of interval\\n        //pi.second stores the ending value of interval\\n        \\n        //min heap\\n        priority_queue<pi,vector<pi>,greater<pi>> pq;\\n        \\n        \\n        int i=0,len=in.size();\\n        //for every query insert the possible intervals in which the query lies \\n        //into min heap\\n\\n        \\n        for(int j=0;j<q.size();j++)\\n        {\\n            auto[val,ind]=q[j];\\n            \\n            while(i<len && in[i][0]<=val)\\n            {\\n                pq.push({in[i][1]-in[i][0] +1 , in[i][1]});\\n                i++;\\n            }\\n            \\n            //pop out the intervals in minHealw which doesnot include the current  val\\n            while(!pq.empty() && pq.top().second<val)\\n                pq.pop();\\n            \\n            res[ind]=(pq.empty()) ? -1 : pq.top().first;\\n                \\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186956,
                "title": "java-sort-min-heap-with-explanation",
                "content": "Since we want the smallest size of the interval, we can use Priority Queue sorted by the size of the window. But we should only have valid intervals in the queue. So we need to sort both intervals and queries in the first place. \\n\\n`n`: length of intervals\\n`q`: length of queries\\nTime: `O(nLogn + qLogn)`\\nSpace: `O(q + n)`\\n\\n```\\nclass Solution {\\n    public int[] minInterval(int[][] intervals, int[] queries) {\\n        //This is a good question, actually you can not have a very good way, such as binary search or something else\\n        //to independently get result for each query\\n        \\n        //we can use priority queue to sort by size of the interval\\n        //but only valid intervals in the queue\\n        //so we need to sort intervals by starting point and also sort queries\\n        \\n        int[] res = new int[queries.length];\\n        List<Integer> sortedQueryIndex = new ArrayList<>();\\n        for (int i = 0; i < queries.length; i++) sortedQueryIndex.add(i);\\n        Collections.sort(sortedQueryIndex, (a, b)->(queries[a] - queries[b]));\\n        int i = 0;\\n        Arrays.sort(intervals, (a, b)->(a[0] - b[0]));\\n        //[size of interval, end of interval]\\n        PriorityQueue<int[]> q = new PriorityQueue<>((a, b)->(a[0] - b[0]));\\n        for (int j = 0; j < queries.length; j++) {\\n            int query = queries[sortedQueryIndex.get(j)];\\n            while (i < intervals.length && intervals[i][0] <= query) {\\n                q.add(new int[] {intervals[i][1] - intervals[i][0]+1, intervals[i][1]});\\n                i++;\\n            }\\n            while (!q.isEmpty() && q.peek()[1] < query) q.poll();\\n            if (q.isEmpty()) {\\n                res[sortedQueryIndex.get(j)] = -1;\\n            } else {\\n                res[sortedQueryIndex.get(j)] = q.peek()[0];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] minInterval(int[][] intervals, int[] queries) {\\n        //This is a good question, actually you can not have a very good way, such as binary search or something else\\n        //to independently get result for each query\\n        \\n        //we can use priority queue to sort by size of the interval\\n        //but only valid intervals in the queue\\n        //so we need to sort intervals by starting point and also sort queries\\n        \\n        int[] res = new int[queries.length];\\n        List<Integer> sortedQueryIndex = new ArrayList<>();\\n        for (int i = 0; i < queries.length; i++) sortedQueryIndex.add(i);\\n        Collections.sort(sortedQueryIndex, (a, b)->(queries[a] - queries[b]));\\n        int i = 0;\\n        Arrays.sort(intervals, (a, b)->(a[0] - b[0]));\\n        //[size of interval, end of interval]\\n        PriorityQueue<int[]> q = new PriorityQueue<>((a, b)->(a[0] - b[0]));\\n        for (int j = 0; j < queries.length; j++) {\\n            int query = queries[sortedQueryIndex.get(j)];\\n            while (i < intervals.length && intervals[i][0] <= query) {\\n                q.add(new int[] {intervals[i][1] - intervals[i][0]+1, intervals[i][1]});\\n                i++;\\n            }\\n            while (!q.isEmpty() && q.peek()[1] < query) q.poll();\\n            if (q.isEmpty()) {\\n                res[sortedQueryIndex.get(j)] = -1;\\n            } else {\\n                res[sortedQueryIndex.get(j)] = q.peek()[0];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481339,
                "title": "simple-readable-and-fast-with-explanation-108ms-100-fast",
                "content": "# Intuition\\nPriority Queue / heap\\n\\n# Approach\\nlet me explain the line\\n`PriorityQueue<int[]> pq = new PriorityQueue<>((x,y)->((x[1]-x[0]) - (y[1]-y[0])));`\\ntry to understand other parts of code by yourself.\\n\\nso, `(x,y)->((x[1]-x[0]) - (y[1]-y[0]))` this line is a lamda expression which will compare difference between distance of two points and it will provide order pair\\nlets try to understand it using 3 cases.\\n1. if we add [1,2] then [3,5]\\n[1,2] will be in heap considering heap was previoulsy empty when we will add [3,5] lambda expression will return (2-1)-(5-3)=-1\\nwhich means it is not the smallest and it will not be head of the heap. , `so if it gets any negative result it will add below head.`\\n\\n2. if we add [2,5] then [3,5]\\n[2,5] will be in heap considering heap was previoulsy empty when we will add [3,4] lambda expression will return (5-2)-(5-3)=1\\nwhich means new pair is going to be the head, `so if it gets any positive result it will make it head.`\\n\\n3. if we add [1,2] then [3,4]\\n[1,2] will be in heap considering heap was previoulsy empty when we will add [3,5] lambda expression will return (2-1)-(4-3)=0\\nwhich means it is not the smallest and it will not be head of the heap. In this case head will be the pair which was inserted into heap first. `so if it get 0 new pair will added below head of heap.`\\n# Complexity\\n- Time complexity:\\nO(IlogI + QlogQ)\\n\\n- Space complexity:\\nO(I + Q)\\n\\n// here I is size of interval and Q is size of queries\\n# Code\\n```\\nclass Solution {\\n    public int[] minInterval(int[][] intervals, int[] queries) {\\n        HashMap<Integer,Integer> map = new HashMap<>(); \\n        Arrays.sort(intervals,(x,y)->(x[0]-y[0]));\\n        int arr[] = new int[queries.length],i=0;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((x,y)->((x[1]-x[0]) - (y[1]-y[0])));\\n        for(int j=0;j<arr.length;j++) arr[j]=queries[j];\\n        Arrays.sort(arr);\\n        for(int q : arr){\\n            while(i<intervals.length && intervals[i][0]<=q){\\n                pq.offer(intervals[i++]);\\n            }\\n            while(pq.size()!=0 && pq.peek()[1]<q){\\n                pq.poll();\\n            }\\n            map.put(q,(pq.size()==0)?-1:pq.peek()[1]-pq.peek()[0]+1);\\n        }\\n        for(i=0;i<queries.length;i++){\\n            queries[i]=map.get(queries[i]);\\n        }\\n        return queries;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int[] minInterval(int[][] intervals, int[] queries) {\\n        HashMap<Integer,Integer> map = new HashMap<>(); \\n        Arrays.sort(intervals,(x,y)->(x[0]-y[0]));\\n        int arr[] = new int[queries.length],i=0;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((x,y)->((x[1]-x[0]) - (y[1]-y[0])));\\n        for(int j=0;j<arr.length;j++) arr[j]=queries[j];\\n        Arrays.sort(arr);\\n        for(int q : arr){\\n            while(i<intervals.length && intervals[i][0]<=q){\\n                pq.offer(intervals[i++]);\\n            }\\n            while(pq.size()!=0 && pq.peek()[1]<q){\\n                pq.poll();\\n            }\\n            map.put(q,(pq.size()==0)?-1:pq.peek()[1]-pq.peek()[0]+1);\\n        }\\n        for(i=0;i<queries.length;i++){\\n            queries[i]=map.get(queries[i]);\\n        }\\n        return queries;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1791227,
                "title": "c-sweep-line-solution",
                "content": "- treat ends of intervals and query as event points.\\n- sort points in increasing order, notice that points with same value and different types have priority START > QUERY > END;\\n- sweeping from left to right\\n\\t- ```sweep``` maintains the intervals intersecting with current sweep line.\\n\\t- if we meet a ```START``` point, add size of the interval into ```sweep``` .\\n\\t- if we meet a ```END``` point, remove the interval from ```sweep```.\\n\\t- if we meet a ```QUERY``` point, the smallest value in ```sweep``` is the answer.\\n\\n```c++\\nclass Solution {\\npublic:\\n    enum { START, QUERY, END };\\n    \\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        vector<vector<int>> points;\\n        int i = 0;\\n        \\n        for (auto &interval: intervals) {\\n            points.push_back({interval[0], START, i});\\n            points.push_back({interval[1], END, i});\\n            \\n            i++;\\n        }\\n        \\n        i = 0;\\n        for (auto q: queries) {\\n            points.push_back({q, QUERY, i});\\n            \\n            i++;\\n        }\\n\\n        sort(points.begin(), points.end());\\n\\n        vector<int> ans(queries.size(), -1);\\n        // list of size of current intervals intersecting with sweeping line.\\n        multiset<int> sweep;\\n        int psize = points.size();\\n        \\n        for (int i = 0; i < psize; ++i) {\\n            if (points[i][1] == START) {\\n                int line = points[i][2];\\n                int size = intervals[line][1] - intervals[line][0] + 1;\\n            \\n                sweep.insert(size);\\n            } else if (points[i][1] == END) {\\n                int line = points[i][2];\\n                int size = intervals[line][1] - intervals[line][0] + 1;\\n            \\n                sweep.erase(sweep.lower_bound(size));\\n            } else if (sweep.size()) {\\n                int query = points[i][2];\\n                \\n                ans[query] = (*sweep.begin());\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```sweep```\n```START```\n```sweep```\n```END```\n```sweep```\n```QUERY```\n```sweep```\n```c++\\nclass Solution {\\npublic:\\n    enum { START, QUERY, END };\\n    \\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        vector<vector<int>> points;\\n        int i = 0;\\n        \\n        for (auto &interval: intervals) {\\n            points.push_back({interval[0], START, i});\\n            points.push_back({interval[1], END, i});\\n            \\n            i++;\\n        }\\n        \\n        i = 0;\\n        for (auto q: queries) {\\n            points.push_back({q, QUERY, i});\\n            \\n            i++;\\n        }\\n\\n        sort(points.begin(), points.end());\\n\\n        vector<int> ans(queries.size(), -1);\\n        // list of size of current intervals intersecting with sweeping line.\\n        multiset<int> sweep;\\n        int psize = points.size();\\n        \\n        for (int i = 0; i < psize; ++i) {\\n            if (points[i][1] == START) {\\n                int line = points[i][2];\\n                int size = intervals[line][1] - intervals[line][0] + 1;\\n            \\n                sweep.insert(size);\\n            } else if (points[i][1] == END) {\\n                int line = points[i][2];\\n                int size = intervals[line][1] - intervals[line][0] + 1;\\n            \\n                sweep.erase(sweep.lower_bound(size));\\n            } else if (sweep.size()) {\\n                int query = points[i][2];\\n                \\n                ans[query] = (*sweep.begin());\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1422509,
                "title": "for-beginners-easy-approach-well-explained-clean-concise",
                "content": "## IDEA:\\n\\uD83D\\uDC49 *Sort the intervals by size and the queries in increasing order, then iterate over the intervals.\\n\\uD83D\\uDC49 For each interval (left, right) binary search for the queries (q) that are contained in the interval (left <= q <=  right), pop them from the array queries and insert them in the array answers (with size = right - left +1).\\n\\uD83D\\uDC49 Since you\\'re looking at the interval from the smallest to the largest, the first answer found is correct.*\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        \\n        intervals.sort(key = lambda x:x[1]-x[0])\\n        q = sorted([qu,i] for i,qu in enumerate(queries))\\n        res=[-1]*len(queries)\\n\\t\\t\\n        for left,right in intervals:\\n            ind = bisect.bisect(q,[left])\\n            while ind<len(q) and q[ind][0]<=right:\\n                res[q.pop(ind)[1]]=right-left+1\\n        return res\\n\\t\\t\\nFeel free to ask if you have any doubt. \\uD83E\\uDD17\\n**Thanku** and do **Upvote** if you got any help !!\\uD83E\\uDD1E",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "## IDEA:\\n\\uD83D\\uDC49 *Sort the intervals by size and the queries in increasing order, then iterate over the intervals.\\n\\uD83D\\uDC49 For each interval (left, right) binary search for the queries (q) that are contained in the interval (left <= q <=  right), pop them from the array queries and insert them in the array answers (with size = right - left +1).\\n\\uD83D\\uDC49 Since you\\'re looking at the interval from the smallest to the largest, the first answer found is correct.*\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        \\n        intervals.sort(key = lambda x:x[1]-x[0])\\n        q = sorted([qu,i] for i,qu in enumerate(queries))\\n        res=[-1]*len(queries)\\n\\t\\t\\n        for left,right in intervals:\\n            ind = bisect.bisect(q,[left])\\n            while ind<len(q) and q[ind][0]<=right:\\n                res[q.pop(ind)[1]]=right-left+1\\n        return res\\n\\t\\t\\nFeel free to ask if you have any doubt. \\uD83E\\uDD17\\n**Thanku** and do **Upvote** if you got any help !!\\uD83E\\uDD1E",
                "codeTag": "Java"
            },
            {
                "id": 1186785,
                "title": "c-solution-ordered-map-and-priority-queue-solution-similar-idea-as-the-biweekly-contest",
                "content": "\\n#### Idea\\nThe idea is similar as the 4th questions of today\\'s biweekly contest.\\n- sort queries and intervals.\\n- start from the smallest query value, \\n- dealing with the current query and put all the valid intervals into `cnt` ordered map, the key is the interval value, and remove all the invalid interval from `cnt`, to find out the invalid intervals, we use priority_queue here.\\n- get the smallest element from `cnt` and the key is current query answer.\\n- notice that we push negative number into pq because the default pq in C++ is maxHeap.\\n\\n#### Complexity\\n- Time O(nLog(n))\\n- Space O(n)\\n    \\n\\n#### Solution\\n- C++\\n```\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& _queries) {\\n        sort(intervals.begin(), intervals.end(), [](auto &a, auto &b){\\n            if(a[0] == b[0]) return a[1] < b[1];\\n            return a[0] < b[0];\\n        });\\n        priority_queue< pair<int, int> > pq;\\n        vector<vector<int> > queries(_queries.size());\\n        for(int i = 0; i < queries.size(); i++) queries[i] = {_queries[i], i};\\n        sort(queries.begin(), queries.end());\\n        int j = 0;\\n        map<int, int> cnt; \\n        vector<int> ans(queries.size());\\n        for(auto &q : queries) {\\n            int val = q[0], idx = q[1];\\n            while(j < intervals.size() && intervals[j][0] <= val) {\\n                ++cnt[intervals[j][1] - intervals[j][0]];\\n                pq.push({-intervals[j][1], j}); //use negative number here so that we can get the smallest right interval.\\n                j++;\\n            }\\n            while(pq.size() && -pq.top().first < val) {\\n                int i = pq.top().second;\\n                pq.pop();\\n                int d = intervals[i][1] - intervals[i][0];\\n                if(--cnt[d] == 0) {\\n                    cnt.erase(d);\\n                }\\n            }\\n            if(cnt.size()){\\n                ans[idx] = cnt.begin()->first + 1;\\n            }else\\n                ans[idx] = -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& _queries) {\\n        sort(intervals.begin(), intervals.end(), [](auto &a, auto &b){\\n            if(a[0] == b[0]) return a[1] < b[1];\\n            return a[0] < b[0];\\n        });\\n        priority_queue< pair<int, int> > pq;\\n        vector<vector<int> > queries(_queries.size());\\n        for(int i = 0; i < queries.size(); i++) queries[i] = {_queries[i], i};\\n        sort(queries.begin(), queries.end());\\n        int j = 0;\\n        map<int, int> cnt; \\n        vector<int> ans(queries.size());\\n        for(auto &q : queries) {\\n            int val = q[0], idx = q[1];\\n            while(j < intervals.size() && intervals[j][0] <= val) {\\n                ++cnt[intervals[j][1] - intervals[j][0]];\\n                pq.push({-intervals[j][1], j}); //use negative number here so that we can get the smallest right interval.\\n                j++;\\n            }\\n            while(pq.size() && -pq.top().first < val) {\\n                int i = pq.top().second;\\n                pq.pop();\\n                int d = intervals[i][1] - intervals[i][0];\\n                if(--cnt[d] == 0) {\\n                    cnt.erase(d);\\n                }\\n            }\\n            if(cnt.size()){\\n                ans[idx] = cnt.begin()->first + 1;\\n            }else\\n                ans[idx] = -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1560169,
                "title": "python-line-sweep-similar-to-skyline-problem",
                "content": "In case of a tiebreaker, the action order should be: Add first, then Query, then Remove\\n\\nThis handles cases like: interval - [4,4] | queries - [4]\\n\\n```\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        heap = []\\n        \\n        for index, (left, right) in enumerate(intervals):\\n            heappush(heap, (left, -1, index))\\n            heappush(heap, (right, 1, index))\\n            \\n        for index, query in enumerate(queries):\\n            heappush(heap, (query, 0, index))\\n            \\n        res = [-1 for _ in queries]\\n        \\n        active = set()\\n        activeIntervals = []\\n        while heap:\\n            location, action, index = heappop(heap)\\n\\n            if action == -1:\\n                size = 1 + intervals[index][1] - intervals[index][0]\\n                heappush(activeIntervals, (size, index))\\n                active.add(index)\\n            elif action == 0:\\n                while activeIntervals and activeIntervals[0][1] not in active:\\n                    heappop(activeIntervals)\\n                \\n                if activeIntervals:\\n                    res[index] = activeIntervals[0][0]\\n            else:\\n                active.remove(index)\\n\\n        return res\\n```\\n\\n---\\n\\nWith Enum\\n\\n```\\nclass Action:\\n    ADD = -1\\n    QUERY = 0\\n    REMOVE = 1\\n\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        heap = []\\n\\n        for index, (left, right) in enumerate(intervals):\\n            heap.append((left, Action.ADD, index))\\n            heap.append((right, Action.REMOVE, index))\\n            \\n        for index, query in enumerate(queries):\\n            heap.append((query, Action.QUERY, index))\\n        heapify(heap)\\n            \\n        res = [-1 for _ in queries]\\n        \\n        active = set()\\n        activeIntervals = []\\n        while heap:\\n            location, action, index = heappop(heap)\\n                            \\n            if action == Action.ADD:\\n                size = 1 + intervals[index][1] - intervals[index][0]\\n                heappush(activeIntervals, (size, index))\\n                active.add(index)\\n            elif action == Action.QUERY:\\n                while activeIntervals and activeIntervals[0][1] not in active:\\n                    heappop(activeIntervals)\\n                \\n                if activeIntervals:\\n                    res[index] = activeIntervals[0][0]\\n            elif action == Action.REMOVE:\\n                active.remove(index)\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        heap = []\\n        \\n        for index, (left, right) in enumerate(intervals):\\n            heappush(heap, (left, -1, index))\\n            heappush(heap, (right, 1, index))\\n            \\n        for index, query in enumerate(queries):\\n            heappush(heap, (query, 0, index))\\n            \\n        res = [-1 for _ in queries]\\n        \\n        active = set()\\n        activeIntervals = []\\n        while heap:\\n            location, action, index = heappop(heap)\\n\\n            if action == -1:\\n                size = 1 + intervals[index][1] - intervals[index][0]\\n                heappush(activeIntervals, (size, index))\\n                active.add(index)\\n            elif action == 0:\\n                while activeIntervals and activeIntervals[0][1] not in active:\\n                    heappop(activeIntervals)\\n                \\n                if activeIntervals:\\n                    res[index] = activeIntervals[0][0]\\n            else:\\n                active.remove(index)\\n\\n        return res\\n```\n```\\nclass Action:\\n    ADD = -1\\n    QUERY = 0\\n    REMOVE = 1\\n\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        heap = []\\n\\n        for index, (left, right) in enumerate(intervals):\\n            heap.append((left, Action.ADD, index))\\n            heap.append((right, Action.REMOVE, index))\\n            \\n        for index, query in enumerate(queries):\\n            heap.append((query, Action.QUERY, index))\\n        heapify(heap)\\n            \\n        res = [-1 for _ in queries]\\n        \\n        active = set()\\n        activeIntervals = []\\n        while heap:\\n            location, action, index = heappop(heap)\\n                            \\n            if action == Action.ADD:\\n                size = 1 + intervals[index][1] - intervals[index][0]\\n                heappush(activeIntervals, (size, index))\\n                active.add(index)\\n            elif action == Action.QUERY:\\n                while activeIntervals and activeIntervals[0][1] not in active:\\n                    heappop(activeIntervals)\\n                \\n                if activeIntervals:\\n                    res[index] = activeIntervals[0][0]\\n            elif action == Action.REMOVE:\\n                active.remove(index)\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1187639,
                "title": "c-clean-code-heap-100-time-100-space",
                "content": "Edit :  Added explanation.\\nHere we need to keep complexity below O(n^2) else it will TLE as per given constraints. Hence no brute force.\\nThe next best option I will check for array questions is to sort and bring complexity to O(n log(n))\\nLets sort the queries and intervals.\\nNow for each query, we need to find in which interval this query will fall into.\\nstore that interval into a priority queue(min heap). the min heap I chose is of pair<int, int> where first is (size of interval) and second is the end of interval.\\nnow once all such intervals are added, the  priority queue\\'s top will contain the smallest interval and the intervals end.\\nwe can continue for each query.\\nfor the next query, we can continue adding in all the intervals it will fall into by continuing our traversal of the sorted array of intervals and add the same into the prioriy queue.\\nNow the top will contain the minimum Interval. But, this may not be valid because this interval could have ended before the query, so we pop until we find a minimum interval that can hold the current query.\\nObviously, there will be invalid intervals in the priority queue and we are not bothered as long as this is not the smallest interval, if it is the smallest interval, we pop it out based on the end value stored in pair.second.\\nif the priority queue is empty at any stage, we understand that the query does not fall into any interval, hence  -1.\\n```\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        unordered_map<int, int> result;\\n\\t\\tvector<int> res;\\n\\t\\tpriority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>  > pq;\\n\\t\\tint i = 0;\\n\\t\\tint n = intervals.size();\\n        vector<int> copyQueries = queries;\\n\\t\\t\\n        sort(queries.begin(), queries.end());\\n        sort(intervals.begin(), intervals.end());\\n   \\t\\t\\t\\t\\n        for (int q: queries) {\\n            while (i < n && intervals[i][0] <= q) {\\n                if(intervals[i][1] >= q){\\n                    int size = intervals[i][1] - intervals[i][0] + 1;\\n                    pq.push({size, intervals[i][1]});\\n                }\\n                i++;\\n            }\\n            while (!pq.empty() && pq.top().second < q) {\\n                    pq.pop();\\n            }\\n            if (!pq.empty()) {\\n                result[q] = pq.top().first;\\n            } else {\\n                result[q]= -1;\\n            }\\n        }\\n        for (int i = 0; i < copyQueries.size(); i++) {\\n            res.push_back(result[copyQueries[i]]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        unordered_map<int, int> result;\\n\\t\\tvector<int> res;\\n\\t\\tpriority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>  > pq;\\n\\t\\tint i = 0;\\n\\t\\tint n = intervals.size();\\n        vector<int> copyQueries = queries;\\n\\t\\t\\n        sort(queries.begin(), queries.end());\\n        sort(intervals.begin(), intervals.end());\\n   \\t\\t\\t\\t\\n        for (int q: queries) {\\n            while (i < n && intervals[i][0] <= q) {\\n                if(intervals[i][1] >= q){\\n                    int size = intervals[i][1] - intervals[i][0] + 1;\\n                    pq.push({size, intervals[i][1]});\\n                }\\n                i++;\\n            }\\n            while (!pq.empty() && pq.top().second < q) {\\n                    pq.pop();\\n            }\\n            if (!pq.empty()) {\\n                result[q] = pq.top().first;\\n            } else {\\n                result[q]= -1;\\n            }\\n        }\\n        for (int i = 0; i < copyQueries.size(); i++) {\\n            res.push_back(result[copyQueries[i]]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2303790,
                "title": "go-clear-solution-324ms-beats-100-speed",
                "content": "```\\n\\ntype IntHeap [][2]int\\n\\nfunc (h IntHeap) Len() int {\\n\\treturn len(h)\\n}\\n\\nfunc (h IntHeap) Less(i, j int) bool {\\n\\treturn h[i][0] < h[j][0]\\n}\\n\\nfunc (h IntHeap) Swap(i, j int) {\\n\\th[i], h[j] = h[j], h[i]\\n}\\n\\nfunc (h *IntHeap) Push(x interface{}) {\\n\\t*h = append(*h, x.([2]int))\\n}\\n\\nfunc (h *IntHeap) Pop() interface{} {\\n\\told := *h\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*h = old[:n-1]\\n\\treturn x\\n}\\n\\nfunc minInterval(intervals [][]int, queries []int) []int {\\n\\t//sorted array by start\\n\\tsort.Slice(intervals, func(i, j int) bool {\\n\\t\\treturn intervals[i][0] < intervals[j][0]\\n\\t})\\n\\n\\t//sorted queries\\n\\t//store unsorted queries to return results\\n\\tsorted_queries := make([]int, len(queries))\\n\\tcopy(sorted_queries, queries)\\n\\tsort.Ints(sorted_queries)\\n\\n\\t// mapping result to unsorted_queries\\n\\tmapQueries := map[int]int{}\\n\\n\\t// O(n)\\n\\th := IntHeap{}\\n\\theap.Init(&h)\\n\\n\\ti := 0\\n\\tfor j := 0; j < len(sorted_queries); j++ {\\n\\t\\tfor j+1 < len(sorted_queries) && sorted_queries[j] == sorted_queries[j+1] {\\n\\t\\t\\tj++\\n\\t\\t}\\n\\t\\tqj := sorted_queries[j]\\n\\n\\t\\tfor i < len(intervals) && (intervals[i][0] <= qj) {\\n\\t\\t\\tend := intervals[i][1]\\n\\t\\t\\tsize := end - intervals[i][0] + 1\\n\\t\\t\\t// O(logn)\\n\\t\\t\\theap.Push(&h, [2]int{size, end})\\n\\t\\t\\ti++\\n\\t\\t}\\n\\n\\t\\t// pop intervals is oubounded\\n\\t\\t// O(logn)\\n\\t\\tfor h.Len() > 0 && qj > h[0][1] {\\n\\t\\t\\theap.Pop(&h)\\n\\t\\t}\\n\\n\\t\\tif len(h) > 0 {\\n\\t\\t\\tmapQueries[qj] = h[0][0]\\n\\t\\t} else {\\n\\t\\t\\tmapQueries[qj] = -1\\n\\t\\t}\\n\\n\\t}\\n\\n\\tres := []int{}\\n\\tfor _, q := range queries {\\n\\t\\tres = append(res, mapQueries[q])\\n\\t}\\n\\treturn res\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\ntype IntHeap [][2]int\\n\\nfunc (h IntHeap) Len() int {\\n\\treturn len(h)\\n}\\n\\nfunc (h IntHeap) Less(i, j int) bool {\\n\\treturn h[i][0] < h[j][0]\\n}\\n\\nfunc (h IntHeap) Swap(i, j int) {\\n\\th[i], h[j] = h[j], h[i]\\n}\\n\\nfunc (h *IntHeap) Push(x interface{}) {\\n\\t*h = append(*h, x.([2]int))\\n}\\n\\nfunc (h *IntHeap) Pop() interface{} {\\n\\told := *h\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*h = old[:n-1]\\n\\treturn x\\n}\\n\\nfunc minInterval(intervals [][]int, queries []int) []int {\\n\\t//sorted array by start\\n\\tsort.Slice(intervals, func(i, j int) bool {\\n\\t\\treturn intervals[i][0] < intervals[j][0]\\n\\t})\\n\\n\\t//sorted queries\\n\\t//store unsorted queries to return results\\n\\tsorted_queries := make([]int, len(queries))\\n\\tcopy(sorted_queries, queries)\\n\\tsort.Ints(sorted_queries)\\n\\n\\t// mapping result to unsorted_queries\\n\\tmapQueries := map[int]int{}\\n\\n\\t// O(n)\\n\\th := IntHeap{}\\n\\theap.Init(&h)\\n\\n\\ti := 0\\n\\tfor j := 0; j < len(sorted_queries); j++ {\\n\\t\\tfor j+1 < len(sorted_queries) && sorted_queries[j] == sorted_queries[j+1] {\\n\\t\\t\\tj++\\n\\t\\t}\\n\\t\\tqj := sorted_queries[j]\\n\\n\\t\\tfor i < len(intervals) && (intervals[i][0] <= qj) {\\n\\t\\t\\tend := intervals[i][1]\\n\\t\\t\\tsize := end - intervals[i][0] + 1\\n\\t\\t\\t// O(logn)\\n\\t\\t\\theap.Push(&h, [2]int{size, end})\\n\\t\\t\\ti++\\n\\t\\t}\\n\\n\\t\\t// pop intervals is oubounded\\n\\t\\t// O(logn)\\n\\t\\tfor h.Len() > 0 && qj > h[0][1] {\\n\\t\\t\\theap.Pop(&h)\\n\\t\\t}\\n\\n\\t\\tif len(h) > 0 {\\n\\t\\t\\tmapQueries[qj] = h[0][0]\\n\\t\\t} else {\\n\\t\\t\\tmapQueries[qj] = -1\\n\\t\\t}\\n\\n\\t}\\n\\n\\tres := []int{}\\n\\tfor _, q := range queries {\\n\\t\\tres = append(res, mapQueries[q])\\n\\t}\\n\\treturn res\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1202402,
                "title": "java-solution-with-priorityqueue-comment-explained",
                "content": "```\\nclass Solution {\\n    public int[] minInterval(int[][] intervals, int[] queries) {\\n\\t    //sort intervals\\n        Arrays.sort(intervals, (a,b) -> a[0] - b[0]);\\n        //add [index,query]\\n        int[][] q = new int[queries.length][2];\\n        for (int i=0;i<queries.length;i++){\\n            q[i][0] = i;\\n            q[i][1] = queries[i];\\n        }\\n        //sort the queries by query val\\n        Arrays.sort(q, (a,b) -> a[1]-b[1]);\\n        //store the minimum intervals in the priority queue, min heap\\n        Queue<int[]> pq = new PriorityQueue<>((a,b) -> (a[1]-a[0])-(b[1]-b[0]));\\n        int[] result = new int[queries.length];\\n        int j = 0;\\n        for (int i=0;i<q.length;i++){\\n            int index = q[i][0];\\n            int val = q[i][1];\\n            // if start is less than query val, then add to pq\\n            while (j < intervals.length && intervals[j][0] <= val) pq.offer(intervals[j++]);\\n            //anything which has the end lesser than the val then remove it\\n            while (!pq.isEmpty() && pq.peek()[1] < val) pq.poll();\\n            //add difference to the result\\n            result[index]= pq.isEmpty() ? -1 : pq.peek()[1] - pq.peek()[0] + 1;\\n        }\\n    return result;\\n    }\\n}\\n```\\n**Brute force which gave TLE**\\n```\\nclass Solution {\\n    public int[] minInterval(int[][] intervals, int[] queries) {\\n     //   TLE 32 / 42\\n         Map<Integer, Integer> map  = new HashMap<>();\\n         for (int[] i : intervals){\\n             int start = i[0];\\n             int end = i[1];\\n             int val = end - start + 1;\\n             for (int j = start; j <= end;j++)\\n                 map.put(j, Math.min(map.getOrDefault(j, Integer.MAX_VALUE), val));\\n         }\\n        \\n         int[] result = new int[queries.length];\\n         int index = 0;\\n         for (int i : queries)\\n             result[index++] = map.getOrDefault(i, -1);\\n         return result;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int[] minInterval(int[][] intervals, int[] queries) {\\n\\t    //sort intervals\\n        Arrays.sort(intervals, (a,b) -> a[0] - b[0]);\\n        //add [index,query]\\n        int[][] q = new int[queries.length][2];\\n        for (int i=0;i<queries.length;i++){\\n            q[i][0] = i;\\n            q[i][1] = queries[i];\\n        }\\n        //sort the queries by query val\\n        Arrays.sort(q, (a,b) -> a[1]-b[1]);\\n        //store the minimum intervals in the priority queue, min heap\\n        Queue<int[]> pq = new PriorityQueue<>((a,b) -> (a[1]-a[0])-(b[1]-b[0]));\\n        int[] result = new int[queries.length];\\n        int j = 0;\\n        for (int i=0;i<q.length;i++){\\n            int index = q[i][0];\\n            int val = q[i][1];\\n            // if start is less than query val, then add to pq\\n            while (j < intervals.length && intervals[j][0] <= val) pq.offer(intervals[j++]);\\n            //anything which has the end lesser than the val then remove it\\n            while (!pq.isEmpty() && pq.peek()[1] < val) pq.poll();\\n            //add difference to the result\\n            result[index]= pq.isEmpty() ? -1 : pq.peek()[1] - pq.peek()[0] + 1;\\n        }\\n    return result;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] minInterval(int[][] intervals, int[] queries) {\\n     //   TLE 32 / 42\\n         Map<Integer, Integer> map  = new HashMap<>();\\n         for (int[] i : intervals){\\n             int start = i[0];\\n             int end = i[1];\\n             int val = end - start + 1;\\n             for (int j = start; j <= end;j++)\\n                 map.put(j, Math.min(map.getOrDefault(j, Integer.MAX_VALUE), val));\\n         }\\n        \\n         int[] result = new int[queries.length];\\n         int index = 0;\\n         for (int i : queries)\\n             result[index++] = map.getOrDefault(i, -1);\\n         return result;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1192271,
                "title": "java-segment-tree-no-sort",
                "content": "\\n```\\nclass Solution {\\n    \\n    // define the segment tree structure\\n    class SegmentTreeNode {\\n        int start;\\n        int end;\\n        int min;\\n        SegmentTreeNode left;\\n        SegmentTreeNode right;\\n        public SegmentTreeNode(int start, int end){\\n            this.start = start;\\n            this.end = end;\\n            this.min = Integer.MAX_VALUE;\\n        }\\n    }\\n    \\n    private SegmentTreeNode root = null;\\n   \\n    public int[] minInterval(int[][] intervals, int[] queries) {\\n        // initial segement root\\n        root = new SegmentTreeNode(1, (int)(1e7+1));\\n            \\n        // insert interval into segment tree\\n        for(int[] interval : intervals){\\n            int size = interval[1] - interval[0] + 1;\\n            update(root, interval[0], interval[1], size);\\n        }\\n        \\n        // query the result\\n        int[] result = new int[queries.length];\\n        for(int i=0; i<queries.length; i++){\\n            result[i] = getMinSize(queries[i]);\\n        }\\n        return result;\\n    }\\n    \\n    private void update(SegmentTreeNode root, int left, int right, int val) {\\n        if (left > root.end || right < root.start) {\\n            return;\\n        }\\n        // if current segment is between [left, right], update the min interval\\n        if (left <= root.start && root.end <= right) {\\n            root.min = Math.min(root.min, val);\\n            return;\\n        }\\n        \\n        // if [left, right] is covered in both side segemets, update the both children segments\\n        int mid = root.start + (root.end - root.start) / 2;\\n        // add the left child segment node if required\\n        if(root.left == null){\\n            root.left = new SegmentTreeNode(root.start, mid);\\n        }\\n        update(root.left, left, right, val);\\n        // add the right child segment node if required\\n        if(root.right == null){\\n           root.right = new SegmentTreeNode(mid+1, root.end); \\n        }\\n        update(root.right, left, right, val);\\n    }\\n    \\n    private int getMinSize(int query) {\\n        int result = getMinSize(root, query);\\n        return result == Integer.MAX_VALUE ? -1 : result;\\n    }\\n    \\n\\t// find all the segment node which include query, return the min interval of them\\n    private int getMinSize(SegmentTreeNode root, int query) {\\n        if(root == null) {\\n            return Integer.MAX_VALUE; \\n        }\\n        if(query > root.end || query < root.start) {\\n            return Integer.MAX_VALUE;\\n        } \\n        if (root.start == root.end) {\\n            return root.min;\\n        } else {\\n            // since query is a single point, so go to left/right segment based on its index\\n            int mid = root.start + (root.end - root.start) / 2;\\n            if(query <= mid) {\\n                return Math.min(root.min, getMinSize(root.left, query));\\n            } else {\\n                return Math.min(root.min, getMinSize(root.right, query));\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    \\n    // define the segment tree structure\\n    class SegmentTreeNode {\\n        int start;\\n        int end;\\n        int min;\\n        SegmentTreeNode left;\\n        SegmentTreeNode right;\\n        public SegmentTreeNode(int start, int end){\\n            this.start = start;\\n            this.end = end;\\n            this.min = Integer.MAX_VALUE;\\n        }\\n    }\\n    \\n    private SegmentTreeNode root = null;\\n   \\n    public int[] minInterval(int[][] intervals, int[] queries) {\\n        // initial segement root\\n        root = new SegmentTreeNode(1, (int)(1e7+1));\\n            \\n        // insert interval into segment tree\\n        for(int[] interval : intervals){\\n            int size = interval[1] - interval[0] + 1;\\n            update(root, interval[0], interval[1], size);\\n        }\\n        \\n        // query the result\\n        int[] result = new int[queries.length];\\n        for(int i=0; i<queries.length; i++){\\n            result[i] = getMinSize(queries[i]);\\n        }\\n        return result;\\n    }\\n    \\n    private void update(SegmentTreeNode root, int left, int right, int val) {\\n        if (left > root.end || right < root.start) {\\n            return;\\n        }\\n        // if current segment is between [left, right], update the min interval\\n        if (left <= root.start && root.end <= right) {\\n            root.min = Math.min(root.min, val);\\n            return;\\n        }\\n        \\n        // if [left, right] is covered in both side segemets, update the both children segments\\n        int mid = root.start + (root.end - root.start) / 2;\\n        // add the left child segment node if required\\n        if(root.left == null){\\n            root.left = new SegmentTreeNode(root.start, mid);\\n        }\\n        update(root.left, left, right, val);\\n        // add the right child segment node if required\\n        if(root.right == null){\\n           root.right = new SegmentTreeNode(mid+1, root.end); \\n        }\\n        update(root.right, left, right, val);\\n    }\\n    \\n    private int getMinSize(int query) {\\n        int result = getMinSize(root, query);\\n        return result == Integer.MAX_VALUE ? -1 : result;\\n    }\\n    \\n\\t// find all the segment node which include query, return the min interval of them\\n    private int getMinSize(SegmentTreeNode root, int query) {\\n        if(root == null) {\\n            return Integer.MAX_VALUE; \\n        }\\n        if(query > root.end || query < root.start) {\\n            return Integer.MAX_VALUE;\\n        } \\n        if (root.start == root.end) {\\n            return root.min;\\n        } else {\\n            // since query is a single point, so go to left/right segment based on its index\\n            int mid = root.start + (root.end - root.start) / 2;\\n            if(query <= mid) {\\n                return Math.min(root.min, getMinSize(root.left, query));\\n            } else {\\n                return Math.min(root.min, getMinSize(root.right, query));\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1187762,
                "title": "python-8-lines-sort-the-intervals-by-size-then-binary-search-on-the-queries",
                "content": "Sort the intervals by size and the queries in increasing order, then iterate over the intervals.\\nFor each interval (left, right) binary search for the queries (q) that are contained in the interval (left <= q <= right), pop them from the array queries and insert them in the array answers (with size = right - left +1).\\nSince you\\'re looking at the interval from the smallest to the largest, the first answer found is correct.\\n```\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        ans = [-1] * len(queries)\\n        intervals.sort(key = lambda i: i[1] - i[0])\\n        queries = sorted([q, i] for i, q in enumerate(queries))\\n        for left, right in intervals:\\n            idx = bisect.bisect(queries, [left])\\n            while idx < len(queries) and queries[idx][0] <= right:\\n                ans[queries.pop(idx)[1]] = right - left + 1\\n        return ans\\n```\\nRuntime: 2584 ms\\nMemory Usage: 55 MB\\nThis solution was inspired by the one by zdu011.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        ans = [-1] * len(queries)\\n        intervals.sort(key = lambda i: i[1] - i[0])\\n        queries = sorted([q, i] for i, q in enumerate(queries))\\n        for left, right in intervals:\\n            idx = bisect.bisect(queries, [left])\\n            while idx < len(queries) and queries[idx][0] <= right:\\n                ans[queries.pop(idx)[1]] = right - left + 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186882,
                "title": "maintaining-a-relevant-heap-python3-with-explanation",
                "content": "sort queries in order, and keep its index. \\nmaintain a heap called \"relevant\", which include all the relevant intervals and is ordered by its width.\\nFor each query, start to add new intervals into the \"relevant\" heap if  intervals[start][0] <= q\\nthen pop all the intervals that has relevant[0][1] < q\\n\\nif relevant exists, then the answer to the query is just at the top of the heap.\\n\\n```\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        queries= sorted([[n,qidx] for qidx,n in enumerate(queries)])\\n        intervals = sorted(intervals)\\n        ans = [-1]*len(queries)\\n        relevant = []\\n        start = 0\\n        for q, qidx in queries:\\n            while start < len(intervals) and intervals[start][0] <= q:\\n                heapq.heappush(relevant,[intervals[start][1]-intervals[start][0]+1,intervals[start][1],intervals[start][0]] )\\n                start+=1\\n            \\n            while relevant and relevant[0][1] < q:\\n                heapq.heappop(relevant)\\n            \\n            if relevant:\\n                ans[qidx] = relevant[0][0]\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        queries= sorted([[n,qidx] for qidx,n in enumerate(queries)])\\n        intervals = sorted(intervals)\\n        ans = [-1]*len(queries)\\n        relevant = []\\n        start = 0\\n        for q, qidx in queries:\\n            while start < len(intervals) and intervals[start][0] <= q:\\n                heapq.heappush(relevant,[intervals[start][1]-intervals[start][0]+1,intervals[start][1],intervals[start][0]] )\\n                start+=1\\n            \\n            while relevant and relevant[0][1] < q:\\n                heapq.heappop(relevant)\\n            \\n            if relevant:\\n                ans[qidx] = relevant[0][0]\\n        \\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1186789,
                "title": "difference-array",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        int z=0;\\n        for(auto &x:intervals){\\n            z=max(z,x[1]);\\n        }\\n        vector<vector<int>> diff(z+5);\\n        for(auto &x:intervals){ //O(|INTERVALS|)\\n            diff[x[0]].push_back(x[1]-x[0]+1);\\n            diff[x[1]+1].push_back(-1*(x[1]-x[0]+1));\\n        }\\n        vector<int> ans(z+1);\\n        multiset<int> s;\\n        for(int i=0;i<=z;i++){ //O(1E7+LOGN)\\n            for(auto &x:diff[i]) {\\n                if(x>0)\\n                    s.insert(x);\\n                else\\n                    s.erase(s.find(-1*x));\\n            }\\n            ans[i]=*s.begin();\\n        }\\n        vector<int> a;\\n        for(auto &x:queries){ //O(|QUERIES|)\\n            if(ans[x]==0) ans[x]=-1;\\n            a.push_back(ans[x]);\\n        }\\n        return a;\\n    }\\n};\\n```\\n\\nPlease comment if you want an explanation.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        int z=0;\\n        for(auto &x:intervals){\\n            z=max(z,x[1]);\\n        }\\n        vector<vector<int>> diff(z+5);\\n        for(auto &x:intervals){ //O(|INTERVALS|)\\n            diff[x[0]].push_back(x[1]-x[0]+1);\\n            diff[x[1]+1].push_back(-1*(x[1]-x[0]+1));\\n        }\\n        vector<int> ans(z+1);\\n        multiset<int> s;\\n        for(int i=0;i<=z;i++){ //O(1E7+LOGN)\\n            for(auto &x:diff[i]) {\\n                if(x>0)\\n                    s.insert(x);\\n                else\\n                    s.erase(s.find(-1*x));\\n            }\\n            ans[i]=*s.begin();\\n        }\\n        vector<int> a;\\n        for(auto &x:queries){ //O(|QUERIES|)\\n            if(ans[x]==0) ans[x]=-1;\\n            a.push_back(ans[x]);\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2702952,
                "title": "javascript-commented-using-sorting-heap",
                "content": "95/95 was time/space\\n```\\nvar minInterval = function(intervals, queries) {\\n\\t//sort intervals and queries so we can process them in order\\n    intervals = intervals.sort((a,b) => a[0]-b[0])\\n\\t// careful here when sorting queries we must make a shallow copy so we dont sort the original array\\n    let sortedQueries = [...queries].sort((a,b) => a-b)\\n    let minInterval = {}\\n\\t// use min heap to keep track of the smallest interval\\n    let heap = new MinPriorityQueue({priority: (a) => a[1] - a[0] + 1})\\n\\t// pointer tracks our position in intervals\\n    let pointer = 0\\n\\t\\n    for (const query of sortedQueries) {\\n\\t\\t// if we have already seen the query value before we know the minimum interval\\n\\t\\tif (minInterval[query]) continue\\n\\t\\t// advancing our pointer until we find a new interval that contains our query\\n        while (pointer < intervals.length && intervals[pointer][1] < query) {\\n            pointer++\\n        }\\n\\t\\t// adding new intervals that arent in our heap that our query fits inside\\n        while (pointer < intervals.length && intervals[pointer][0] <= query) {\\n            heap.enqueue(intervals[pointer])\\n            pointer++\\n        }\\n\\t\\t// removing the top interval until we run out of elements or we find an interval that our query fits inside\\n        while (heap.size() && heap.front().element[1] < query) {\\n            heap.dequeue()\\n        }\\n\\t\\t// keep track of each query value \\n        minInterval[query] = (heap.size())? heap.front().priority: -1   \\n    }\\n    let ans = []\\n\\t// since we sorted the queries earlier to get the proper order \\n\\t//we must go back through our queries and look up their value in the stored hash\\n    for (let i = 0; i < queries.length; i++) {\\n        ans[i] = minInterval[queries[i]]\\n    }\\n    return ans\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nvar minInterval = function(intervals, queries) {\\n\\t//sort intervals and queries so we can process them in order\\n    intervals = intervals.sort((a,b) => a[0]-b[0])\\n\\t// careful here when sorting queries we must make a shallow copy so we dont sort the original array\\n    let sortedQueries = [...queries].sort((a,b) => a-b)\\n    let minInterval = {}\\n\\t// use min heap to keep track of the smallest interval\\n    let heap = new MinPriorityQueue({priority: (a) => a[1] - a[0] + 1})\\n\\t// pointer tracks our position in intervals\\n    let pointer = 0\\n\\t\\n    for (const query of sortedQueries) {\\n\\t\\t// if we have already seen the query value before we know the minimum interval\\n\\t\\tif (minInterval[query]) continue\\n\\t\\t// advancing our pointer until we find a new interval that contains our query\\n        while (pointer < intervals.length && intervals[pointer][1] < query) {\\n            pointer++\\n        }\\n\\t\\t// adding new intervals that arent in our heap that our query fits inside\\n        while (pointer < intervals.length && intervals[pointer][0] <= query) {\\n            heap.enqueue(intervals[pointer])\\n            pointer++\\n        }\\n\\t\\t// removing the top interval until we run out of elements or we find an interval that our query fits inside\\n        while (heap.size() && heap.front().element[1] < query) {\\n            heap.dequeue()\\n        }\\n\\t\\t// keep track of each query value \\n        minInterval[query] = (heap.size())? heap.front().priority: -1   \\n    }\\n    let ans = []\\n\\t// since we sorted the queries earlier to get the proper order \\n\\t//we must go back through our queries and look up their value in the stored hash\\n    for (let i = 0; i < queries.length; i++) {\\n        ans[i] = minInterval[queries[i]]\\n    }\\n    return ans\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2652142,
                "title": "clean-python3-sorting-heap",
                "content": "Please upvote if it helps!\\n```\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n\\t\\n        queries_asc = sorted((q, i) for i, q in enumerate(queries))\\n        intervals.sort()\\n        \\n        i, num_intervals = 0, len(intervals)\\n        size_heap = [] # (size, left)\\n        \\n        for pos, qnum in queries_asc:\\n            \\n            while i < num_intervals:\\n                left, right = intervals[i]\\n                if left > pos:\\n                    break\\n                heapq.heappush(size_heap, (right - left + 1, left))\\n                i += 1\\n            \\n            while size_heap:\\n                size, left = size_heap[0]\\n                right = left + size - 1\\n                if right >= pos:\\n                    break\\n                heapq.heappop(size_heap)\\n                   \\n            queries[qnum] = size_heap[0][0] if size_heap else -1\\n        \\n        return queries",
                "solutionTags": [
                    "Python3"
                ],
                "code": "Please upvote if it helps!\\n```\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n\\t\\n        queries_asc = sorted((q, i) for i, q in enumerate(queries))\\n        intervals.sort()\\n        \\n        i, num_intervals = 0, len(intervals)\\n        size_heap = [] # (size, left)\\n        \\n        for pos, qnum in queries_asc:\\n            \\n            while i < num_intervals:\\n                left, right = intervals[i]\\n                if left > pos:\\n                    break\\n                heapq.heappush(size_heap, (right - left + 1, left))\\n                i += 1\\n            \\n            while size_heap:\\n                size, left = size_heap[0]\\n                right = left + size - 1\\n                if right >= pos:\\n                    break\\n                heapq.heappop(size_heap)\\n                   \\n            queries[qnum] = size_heap[0][0] if size_heap else -1\\n        \\n        return queries",
                "codeTag": "Java"
            },
            {
                "id": 2432671,
                "title": "python-solution-minheap-sliding-window-suitable-comments",
                "content": "```\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n\\t\\t\\'\\'\\'O(nlogn + qlogq)\\'\\'\\'\\n        tQ = len(queries)  # total Queries\\n        tI = len(intervals) # total intervals\\n\\n        # 0.1 sort the intervals as per the start point\\n        intervals.sort()\\n\\n        # 0.2 get the queries positions after sorting (ie argsort)\\n        pos = sorted(range(tQ), key=queries.__getitem__)\\n\\n        # result \\n        res = [-1]*tQ # holds the intervals answer corresponding to [queries]\\n        r = 0 # current interval pointer (Sliding Window moving Right Side Pointer)\\n\\n        # Kinda emulates Sliding Window (via eliminating the ineligible candidates)\\n        # -> holds the candidates for intervals\\n        minHeap = [] # (length, endPoint)\\n\\n        for i in pos:\\n            q = queries[i] # query \\n\\n            # 1. Add all eligible candidates (intervals)\\n            while r != tI and intervals[r][0] <= q:\\n                s, e = intervals[r]\\n                heapq.heappush(minHeap, (e-s+1, e))\\n                r += 1 # move ahead\\n\\n            # 2. Swipe Out all ineligible candidates (ie from Left Side)\\n            while minHeap and minHeap[0][1] < q:\\n                heapq.heappop(minHeap)\\n\\n            # 3. Assign most suitable interval length\\n            if minHeap:\\n                res[i] = minHeap[0][0]\\n\\n        return res \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n\\t\\t\\'\\'\\'O(nlogn + qlogq)\\'\\'\\'\\n        tQ = len(queries)  # total Queries\\n        tI = len(intervals) # total intervals\\n\\n        # 0.1 sort the intervals as per the start point\\n        intervals.sort()\\n\\n        # 0.2 get the queries positions after sorting (ie argsort)\\n        pos = sorted(range(tQ), key=queries.__getitem__)\\n\\n        # result \\n        res = [-1]*tQ # holds the intervals answer corresponding to [queries]\\n        r = 0 # current interval pointer (Sliding Window moving Right Side Pointer)\\n\\n        # Kinda emulates Sliding Window (via eliminating the ineligible candidates)\\n        # -> holds the candidates for intervals\\n        minHeap = [] # (length, endPoint)\\n\\n        for i in pos:\\n            q = queries[i] # query \\n\\n            # 1. Add all eligible candidates (intervals)\\n            while r != tI and intervals[r][0] <= q:\\n                s, e = intervals[r]\\n                heapq.heappush(minHeap, (e-s+1, e))\\n                r += 1 # move ahead\\n\\n            # 2. Swipe Out all ineligible candidates (ie from Left Side)\\n            while minHeap and minHeap[0][1] < q:\\n                heapq.heappop(minHeap)\\n\\n            # 3. Assign most suitable interval length\\n            if minHeap:\\n                res[i] = minHeap[0][0]\\n\\n        return res \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2360885,
                "title": "c-shortest-and-simple-solution-sorting-with-smallest-range",
                "content": "\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n\\n\\t\\t\\tsort(intervals.begin(), intervals.end(), [](const vector<int> &a, const vector<int> &b){\\n\\t\\t\\t\\treturn a[1] - a[0] < b[1] - b[0];\\n\\t\\t\\t});\\n\\n\\t\\t\\tint n = queries.size();\\n\\t\\t\\tset<pair<int, int>> st;\\n\\t\\t\\tfor(auto i = 0; i < n; i++){\\n\\t\\t\\t\\tst.insert({queries[i], i});\\n\\t\\t\\t}\\n\\t\\t\\tvector<int> res(n, -1);\\n\\n\\t\\t\\tfor(auto &it : intervals){\\n\\t\\t\\t\\tauto itl = st.lower_bound({it[0], 0});\\n\\t\\t\\t\\tauto itr = st.upper_bound({it[1], n});\\n\\t\\t\\t\\twhile(itl != itr){\\n\\t\\t\\t\\t\\tint ind = itl -> second;\\n\\t\\t\\t\\t\\tres[ind] = it[1] - it[0] + 1;\\n\\t\\t\\t\\t\\tst.erase(itl++);\\n\\t\\t\\t\\t}\\t\\t \\n\\t\\t\\t}\\n\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n\\n\\t\\t\\tsort(intervals.begin(), intervals.end(), [](const vector<int> &a, const vector<int> &b){\\n\\t\\t\\t\\treturn a[1] - a[0] < b[1] - b[0];\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1971345,
                "title": "python-easy-to-understand-solution",
                "content": "```\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        intervals.sort(key=lambda i:i[0])\\n        result = {}\\n        heap = []\\n        i = 0\\n        for q in sorted(queries):\\n            # add the intervals into heap for the given query\\n            while i < len(intervals) and intervals[i][0] <= q:\\n                interval_start,interval_end = intervals[i] \\n                heapq.heappush(heap,(interval_end-interval_start+1,interval_end))\\n                i+=1\\n            # pop out the invalid intervals from the heap against which the given query will not overlap the interval\\n            while heap and heap[0][1] < q:\\n                heapq.heappop(heap)\\n            # after the while loop ends we will at all potential intervals that satisfy the query\\n            # take the min if heap in not null otherwise -1\\n            min_val = heap[0][0] if heap else -1\\n            result[q] = min_val\\n        return [result[q] for q in queries]\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        intervals.sort(key=lambda i:i[0])\\n        result = {}\\n        heap = []\\n        i = 0\\n        for q in sorted(queries):\\n            # add the intervals into heap for the given query\\n            while i < len(intervals) and intervals[i][0] <= q:\\n                interval_start,interval_end = intervals[i] \\n                heapq.heappush(heap,(interval_end-interval_start+1,interval_end))\\n                i+=1\\n            # pop out the invalid intervals from the heap against which the given query will not overlap the interval\\n            while heap and heap[0][1] < q:\\n                heapq.heappop(heap)\\n            # after the while loop ends we will at all potential intervals that satisfy the query\\n            # take the min if heap in not null otherwise -1\\n            min_val = heap[0][0] if heap else -1\\n            result[q] = min_val\\n        return [result[q] for q in queries]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1927342,
                "title": "c-min-heap",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        \\n        int szi = intervals.size(), szq = queries.size();\\n        \\n        sort(intervals.begin(), intervals.end());\\n        \\n        vector<pair<int,int>> idxs;\\n        \\n        for(int i=0; i<szq; i++) idxs.push_back({queries[i],i});\\n        \\n        sort(idxs.begin(), idxs.end());\\n        \\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> minHeap;\\n        \\n        vector<int> sol(szq, -1);\\n        \\n        int j = 0;\\n        \\n        for(auto& it : idxs){\\n            \\n            int q = it.first, idx = it.second;\\n            \\n            while(j < szi and intervals[j][0] <= q){\\n                minHeap.push({ intervals[j][1] - intervals[j][0]+1 , intervals[j][1] });\\n                \\n                j++;\\n            }\\n            \\n            while(!minHeap.empty() and minHeap.top().second < q) minHeap.pop();\\n            \\n            if(!minHeap.empty()) sol[idx] = minHeap.top().first;\\n            \\n        }\\n        \\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        \\n        int szi = intervals.size(), szq = queries.size();\\n        \\n        sort(intervals.begin(), intervals.end());\\n        \\n        vector<pair<int,int>> idxs;\\n        \\n        for(int i=0; i<szq; i++) idxs.push_back({queries[i],i});\\n        \\n        sort(idxs.begin(), idxs.end());\\n        \\n        priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> minHeap;\\n        \\n        vector<int> sol(szq, -1);\\n        \\n        int j = 0;\\n        \\n        for(auto& it : idxs){\\n            \\n            int q = it.first, idx = it.second;\\n            \\n            while(j < szi and intervals[j][0] <= q){\\n                minHeap.push({ intervals[j][1] - intervals[j][0]+1 , intervals[j][1] });\\n                \\n                j++;\\n            }\\n            \\n            while(!minHeap.empty() and minHeap.top().second < q) minHeap.pop();\\n            \\n            if(!minHeap.empty()) sol[idx] = minHeap.top().first;\\n            \\n        }\\n        \\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1218667,
                "title": "c-1851-minimum-interval-to-include-each-query",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        sort(intervals.begin(), intervals.end()); \\n        \\n        vector<pair<int, int>> aug; // augmented array to queries\\n        for (int i = 0; i < queries.size(); ++i) \\n            aug.emplace_back(queries[i], i); \\n        sort(aug.begin(), aug.end()); \\n        \\n        int k = 0; \\n        vector<int> ans(queries.size(), -1); \\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq; // min-heap \\n        for (auto& [query, i] : aug) {\\n            for (; k < intervals.size() && intervals[k][0] <= query; ++k) \\n                pq.emplace(intervals[k][1] - intervals[k][0], intervals[k][1]); \\n            while (pq.size() && pq.top().second < query) \\n                pq.pop();\\n            if (pq.size()) \\n                ans[i] = 1 + pq.top().first; \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        sort(intervals.begin(), intervals.end()); \\n        \\n        vector<pair<int, int>> aug; // augmented array to queries\\n        for (int i = 0; i < queries.size(); ++i) \\n            aug.emplace_back(queries[i], i); \\n        sort(aug.begin(), aug.end()); \\n        \\n        int k = 0; \\n        vector<int> ans(queries.size(), -1); \\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq; // min-heap \\n        for (auto& [query, i] : aug) {\\n            for (; k < intervals.size() && intervals[k][0] <= query; ++k) \\n                pq.emplace(intervals[k][1] - intervals[k][0], intervals[k][1]); \\n            while (pq.size() && pq.top().second < query) \\n                pq.pop();\\n            if (pq.size()) \\n                ans[i] = 1 + pq.top().first; \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1189563,
                "title": "java-clean-code-priorityqueue-100-time-100-space",
                "content": "```\\n\\n\\nclass Solution {\\n    public int[] minInterval(int[][] intervals, int[] queries) {\\n        int qlen=queries.length;\\n        int tempquery[]=new int[qlen];\\n        for (int  i=0;i<qlen;i++)\\n        {\\n            tempquery[i]=queries[i];\\n        }\\n        HashMap<Integer,Integer>hashMap=new HashMap<>();\\n        for(int i=0;i<qlen;i++)\\n        {\\n            hashMap.put(queries[i],i);\\n        }\\n        Arrays.sort(queries);\\n        Arrays.sort(intervals,(a,b)->a[0]-b[0]);\\n        PriorityQueue<int[]>priorityQueue=new PriorityQueue<>(Comparator.comparingInt(a -> (a[1] - a[0])));\\n        int ind=0;\\n        int intind=0;\\n        int find=0;\\n\\n        int answer[]=new int[qlen];\\n        while (ind<qlen)\\n        {\\n            while (intind<intervals.length)\\n            {\\n                if (intervals[intind][0]<=queries[ind]&&intervals[intind][1]>=queries[ind])\\n                {\\n                    priorityQueue.add(intervals[intind]);\\n                    intind++;\\n                }\\n                else if (intervals[intind][0]>queries[ind])\\n                {\\n                    break;\\n                }\\n                else\\n                {\\n                    intind++;\\n                }\\n            }\\n            while (!priorityQueue.isEmpty()&& priorityQueue.peek()[1]<queries[ind])\\n            {\\n                priorityQueue.poll();\\n            }\\n            if (priorityQueue.isEmpty())\\n            {\\n                answer[hashMap.get(queries[ind])]=-1;\\n                ind++;\\n            }\\n            else\\n            {\\n                int ele[]= priorityQueue.peek();\\n                answer[hashMap.get(queries[ind])]=ele[1]-ele[0]+1;\\n                ind++;\\n            }\\n        }\\n        for (int i=0;i<qlen;i++)\\n        {\\n            if (answer[i]==0)\\n            {\\n                answer[i]=answer[hashMap.get(tempquery[i])];\\n            }\\n\\n        }\\n      \\n        return answer;\\n    }\\n\\n  \\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\nclass Solution {\\n    public int[] minInterval(int[][] intervals, int[] queries) {\\n        int qlen=queries.length;\\n        int tempquery[]=new int[qlen];\\n        for (int  i=0;i<qlen;i++)\\n        {\\n            tempquery[i]=queries[i];\\n        }\\n        HashMap<Integer,Integer>hashMap=new HashMap<>();\\n        for(int i=0;i<qlen;i++)\\n        {\\n            hashMap.put(queries[i],i);\\n        }\\n        Arrays.sort(queries);\\n        Arrays.sort(intervals,(a,b)->a[0]-b[0]);\\n        PriorityQueue<int[]>priorityQueue=new PriorityQueue<>(Comparator.comparingInt(a -> (a[1] - a[0])));\\n        int ind=0;\\n        int intind=0;\\n        int find=0;\\n\\n        int answer[]=new int[qlen];\\n        while (ind<qlen)\\n        {\\n            while (intind<intervals.length)\\n            {\\n                if (intervals[intind][0]<=queries[ind]&&intervals[intind][1]>=queries[ind])\\n                {\\n                    priorityQueue.add(intervals[intind]);\\n                    intind++;\\n                }\\n                else if (intervals[intind][0]>queries[ind])\\n                {\\n                    break;\\n                }\\n                else\\n                {\\n                    intind++;\\n                }\\n            }\\n            while (!priorityQueue.isEmpty()&& priorityQueue.peek()[1]<queries[ind])\\n            {\\n                priorityQueue.poll();\\n            }\\n            if (priorityQueue.isEmpty())\\n            {\\n                answer[hashMap.get(queries[ind])]=-1;\\n                ind++;\\n            }\\n            else\\n            {\\n                int ele[]= priorityQueue.peek();\\n                answer[hashMap.get(queries[ind])]=ele[1]-ele[0]+1;\\n                ind++;\\n            }\\n        }\\n        for (int i=0;i<qlen;i++)\\n        {\\n            if (answer[i]==0)\\n            {\\n                answer[i]=answer[hashMap.get(tempquery[i])];\\n            }\\n\\n        }\\n      \\n        return answer;\\n    }\\n\\n  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1187214,
                "title": "python-python3-solution-using-heap-and-sorting-method",
                "content": "Code:\\n```\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n\\t\\t# To store the output result\\n        lis = [0 for i in range(len(queries))]\\n\\t\\t#sort the intervals in the reverse order\\n        intervals.sort(reverse = True)\\n\\t\\t#View the intervals list\\n        print(intervals)\\n\\t\\t#store the index number of the query with query number\\n        queriesWithIndex = sorted([(q,i) for i,q in enumerate(queries)])\\n\\t\\t#Print and view the queriesWithInd\\n        print(queriesWithInd)\\n\\t\\t#decare the lis to store the valuew but with the help of heap so the it will be store in sorted form\\n        heapLis = []\\n\\t\\t#Traverse the queryWithIndex list which consists of tuples\\n        for query,i  in queriesWithIndex:\\n\\t\\t\\t# loop should run till the intervals becomes empty\\n            while len(intervals)  and query >=intervals[-1][0]:\\n\\t\\t\\t\\t#pop the last value from interval and store it in start and end value\\n                start, end = intervals.pop()\\n\\t\\t\\t\\t#push the value in the heap list\\n                heappush(heapLis,[end - start + 1, end])\\n\\t\\t\\t# traverse till the heaplis becomes empty or the element in heapLis[0][1] < query\\n            while len(heapLis) and heapLis[0][1] < query:\\n                #pop the tuple from the heapLis\\n\\t\\t\\t\\theappop(heapLis)\\n\\t\\t\\t#if len(heapLis) is 0 then simply assign lis to -1 else assign the value of heapLis[0][0] to lis[i]\\n            if len(heapLis) == 0:\\n                lis[i] = -1\\n            else:\\n                lis[i] = heapLis[0][0]\\n\\t\\t#return the lis\\n        return lis\\n```\\nHere is the image where I visualized the code\\n![image](https://assets.leetcode.com/users/images/b20be737-8aa4-402a-9850-41951aa1fc9d_1619940373.7095604.png)\\nIf you also would like to visualize how does your code work \\n[Click the link](https://pythontutor.com/visualize.html#mode=edit)\\n\\n***We rise by lifting others***",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n\\t\\t# To store the output result\\n        lis = [0 for i in range(len(queries))]\\n\\t\\t#sort the intervals in the reverse order\\n        intervals.sort(reverse = True)\\n\\t\\t#View the intervals list\\n        print(intervals)\\n\\t\\t#store the index number of the query with query number\\n        queriesWithIndex = sorted([(q,i) for i,q in enumerate(queries)])\\n\\t\\t#Print and view the queriesWithInd\\n        print(queriesWithInd)\\n\\t\\t#decare the lis to store the valuew but with the help of heap so the it will be store in sorted form\\n        heapLis = []\\n\\t\\t#Traverse the queryWithIndex list which consists of tuples\\n        for query,i  in queriesWithIndex:\\n\\t\\t\\t# loop should run till the intervals becomes empty\\n            while len(intervals)  and query >=intervals[-1][0]:\\n\\t\\t\\t\\t#pop the last value from interval and store it in start and end value\\n                start, end = intervals.pop()\\n\\t\\t\\t\\t#push the value in the heap list\\n                heappush(heapLis,[end - start + 1, end])\\n\\t\\t\\t# traverse till the heaplis becomes empty or the element in heapLis[0][1] < query\\n            while len(heapLis) and heapLis[0][1] < query:\\n                #pop the tuple from the heapLis\\n\\t\\t\\t\\theappop(heapLis)\\n\\t\\t\\t#if len(heapLis) is 0 then simply assign lis to -1 else assign the value of heapLis[0][0] to lis[i]\\n            if len(heapLis) == 0:\\n                lis[i] = -1\\n            else:\\n                lis[i] = heapLis[0][0]\\n\\t\\t#return the lis\\n        return lis\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1187121,
                "title": "python-binary-indexed-tree-solution",
                "content": "The Binary indexed tree solution here is tricky to get right: if we process intervals [start, end] by increasing start time, we can have BIT[end] track the minimum size interval whose *endpoint* is >= end. \\n\\nBIT is usually used for **prefix sum. Here, it\\'s being used for suffix mins**; the update and query logic is the same, but we also want a hashmap of indices to events rather than events, since values can be as large as 10^7.\\n\\n```python\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        events = []\\n        # Store all endpoints and query times\\n        event_times = set(queries) | set(y for x, y in intervals)\\n\\n        for x, y in intervals:\\n            events.append((x, -y, y - x + 1))\\n\\n        for i, x in enumerate(queries):\\n            events.append((x, i, 0))\\n\\n        event_times = sorted(event_times, reverse=True)\\n        n = len(event_times)\\n\\n        to_ind = {event_times[i]: i for i in range(n)}\\n\\n        BIT = [math.inf] * n\\n\\n        def update(w, z):\\n            while w < n:\\n                BIT[w] = min(BIT[w], z)\\n                w += ((w + 1) & -(w + 1))\\n\\n        def query(w):\\n            running_min = math.inf\\n            while w != 0:\\n                running_min = min(running_min, BIT[w - 1])\\n                w -= (w & -w)\\n            return running_min\\n\\n        # Events are sorted by start for intervals, with intervals\\n        # before all events of the same time\\n        events.sort()\\n\\n        ans = [-1] * len(queries)\\n\\n        for event in events:\\n            # If this is an interval: update min\\n            if event[1] < 0:\\n                update(to_ind[-event[1]], event[2])\\n            # If this is a query point, find min\\n            else:\\n                temp = query(to_ind[event[0]]+1)\\n                if not math.isinf(temp):\\n                    ans[event[1]] = temp\\n\\n        return ans\\n```\\n\\nComplexity: O(n log n) time for sorting and queries; O(n) space by using a hashmap of BIT indices",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        events = []\\n        # Store all endpoints and query times\\n        event_times = set(queries) | set(y for x, y in intervals)\\n\\n        for x, y in intervals:\\n            events.append((x, -y, y - x + 1))\\n\\n        for i, x in enumerate(queries):\\n            events.append((x, i, 0))\\n\\n        event_times = sorted(event_times, reverse=True)\\n        n = len(event_times)\\n\\n        to_ind = {event_times[i]: i for i in range(n)}\\n\\n        BIT = [math.inf] * n\\n\\n        def update(w, z):\\n            while w < n:\\n                BIT[w] = min(BIT[w], z)\\n                w += ((w + 1) & -(w + 1))\\n\\n        def query(w):\\n            running_min = math.inf\\n            while w != 0:\\n                running_min = min(running_min, BIT[w - 1])\\n                w -= (w & -w)\\n            return running_min\\n\\n        # Events are sorted by start for intervals, with intervals\\n        # before all events of the same time\\n        events.sort()\\n\\n        ans = [-1] * len(queries)\\n\\n        for event in events:\\n            # If this is an interval: update min\\n            if event[1] < 0:\\n                update(to_ind[-event[1]], event[2])\\n            # If this is a query point, find min\\n            else:\\n                temp = query(to_ind[event[0]]+1)\\n                if not math.isinf(temp):\\n                    ans[event[1]] = temp\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186916,
                "title": "python3-priority-queue",
                "content": "\\n```\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        intervals.sort()\\n        pq = []\\n        k = 0 \\n        ans = [-1] * len(queries)\\n        for query, i in sorted(zip(queries, range(len(queries)))): \\n            while k < len(intervals) and intervals[k][0] <= query: \\n                heappush(pq, (intervals[k][1] - intervals[k][0] + 1, *intervals[k]))\\n                k += 1\\n            while pq and pq[0][2] < query: \\n                heappop(pq)\\n            if pq: ans[i] = pq[0][0]\\n        return ans \\n```\\n\\nEdited on 5/19/2021\\nAdding Union-Find solution \\n```\\nclass UnionFind: \\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n        self.rank = [1]*n\\n    \\n    def find(self, p):\\n        if self.parent[p] != p:\\n            self.parent[p] = self.find(self.parent[p]) # path with compression \\n        return self.parent[p]\\n    \\n    def union(self, p, q): \\n        prt, qrt = self.find(p), self.find(q)\\n        if prt == qrt: return False\\n        if self.rank[prt] > self.rank[qrt]: prt, qrt = qrt, prt # union by rank \\n        self.parent[prt] = qrt\\n        self.rank[qrt] += self.rank[prt]\\n        return True \\n    \\n\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        qs = sorted(set(queries))\\n        mp = {x : i for i, x in enumerate(qs)} # compress queries \\n               \\n        ans = [-1] * len(qs)\\n        uf = UnionFind(len(qs) + 1)\\n        for x, y in sorted(intervals, key = lambda x: x[1] - x[0]):\\n            lo = bisect_left(qs, x)\\n            hi = bisect_right(qs, y)\\n            mid = uf.find(lo)\\n            while mid < hi:\\n                ans[mid] = y - x + 1\\n                uf.parent[mid] = mid + 1\\n                mid = uf.find(mid)\\n                \\n        return [ans[mp[query]] for query in queries] \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        intervals.sort()\\n        pq = []\\n        k = 0 \\n        ans = [-1] * len(queries)\\n        for query, i in sorted(zip(queries, range(len(queries)))): \\n            while k < len(intervals) and intervals[k][0] <= query: \\n                heappush(pq, (intervals[k][1] - intervals[k][0] + 1, *intervals[k]))\\n                k += 1\\n            while pq and pq[0][2] < query: \\n                heappop(pq)\\n            if pq: ans[i] = pq[0][0]\\n        return ans \\n```\n```\\nclass UnionFind: \\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n        self.rank = [1]*n\\n    \\n    def find(self, p):\\n        if self.parent[p] != p:\\n            self.parent[p] = self.find(self.parent[p]) # path with compression \\n        return self.parent[p]\\n    \\n    def union(self, p, q): \\n        prt, qrt = self.find(p), self.find(q)\\n        if prt == qrt: return False\\n        if self.rank[prt] > self.rank[qrt]: prt, qrt = qrt, prt # union by rank \\n        self.parent[prt] = qrt\\n        self.rank[qrt] += self.rank[prt]\\n        return True \\n    \\n\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        qs = sorted(set(queries))\\n        mp = {x : i for i, x in enumerate(qs)} # compress queries \\n               \\n        ans = [-1] * len(qs)\\n        uf = UnionFind(len(qs) + 1)\\n        for x, y in sorted(intervals, key = lambda x: x[1] - x[0]):\\n            lo = bisect_left(qs, x)\\n            hi = bisect_right(qs, y)\\n            mid = uf.find(lo)\\n            while mid < hi:\\n                ans[mid] = y - x + 1\\n                uf.parent[mid] = mid + 1\\n                mid = uf.find(mid)\\n                \\n        return [ans[mp[query]] for query in queries] \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3771654,
                "title": "c-priority-queue",
                "content": "\\n# Complexity\\nTime complexity: O(n*logn + m*logm)       \\n                              n=intervals.size(), m=queries.size()\\nSpace complexity: O(n + m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        int n=intervals.size();\\n        vector<int> sorted_queries = queries;\\n        sort(sorted_queries.begin(), sorted_queries.end());\\n        sort(intervals.begin(), intervals.end());\\n\\n        // pq: {size of interval, end of interval}\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        // mp: {query, size of interval}\\n        unordered_map<int, int> mp;\\n\\n        // We are traversing \\'intervals\\' only once\\n        int i=0, left, right;\\n        for(int j=0; j<sorted_queries.size(); j++){\\n            int q=sorted_queries[j];\\n\\n            // Adding all the intervals with \\'start\\' >= \\'q\\' in the \\'pq\\'\\n            //   sorted based on the size of the interval\\n            while(i<n && q>=intervals[i][0]){\\n                left=intervals[i][0];\\n                right=intervals[i][1];\\n                pq.push({right-left+1, right});\\n                i++;\\n            }\\n\\n            // Remove all the intervals from \\'pq\\' that don\\'t contain \\'q\\'\\n            //   This works because the \\'queries\\' are sorted and if the interval doesn\\'t contain \\'q\\'\\n            //   then it won\\'t contain q+1,q+2,....\\n            while(!pq.empty() && pq.top().second<q) pq.pop();\\n\\n            if(!pq.empty()) mp[q]=pq.top().first;\\n            else mp[q]=-1;\\n        }\\n\\n        vector<int> ans;\\n        for(auto x: queries){\\n            ans.push_back(mp[x]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        int n=intervals.size();\\n        vector<int> sorted_queries = queries;\\n        sort(sorted_queries.begin(), sorted_queries.end());\\n        sort(intervals.begin(), intervals.end());\\n\\n        // pq: {size of interval, end of interval}\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        // mp: {query, size of interval}\\n        unordered_map<int, int> mp;\\n\\n        // We are traversing \\'intervals\\' only once\\n        int i=0, left, right;\\n        for(int j=0; j<sorted_queries.size(); j++){\\n            int q=sorted_queries[j];\\n\\n            // Adding all the intervals with \\'start\\' >= \\'q\\' in the \\'pq\\'\\n            //   sorted based on the size of the interval\\n            while(i<n && q>=intervals[i][0]){\\n                left=intervals[i][0];\\n                right=intervals[i][1];\\n                pq.push({right-left+1, right});\\n                i++;\\n            }\\n\\n            // Remove all the intervals from \\'pq\\' that don\\'t contain \\'q\\'\\n            //   This works because the \\'queries\\' are sorted and if the interval doesn\\'t contain \\'q\\'\\n            //   then it won\\'t contain q+1,q+2,....\\n            while(!pq.empty() && pq.top().second<q) pq.pop();\\n\\n            if(!pq.empty()) mp[q]=pq.top().first;\\n            else mp[q]=-1;\\n        }\\n\\n        vector<int> ans;\\n        for(auto x: queries){\\n            ans.push_back(mp[x]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203186,
                "title": "golang-heapsort-based-on-interval-size",
                "content": "# Complexity\\n- Time complexity:\\nO(NlogN) and O(qlogq) for sorting and O(qlogN) for main loop\\nso O(NlogN + qlogq + qlogN)\\nN - number of intervals\\nq - number of queries\\n\\n- Space complexity:\\nO(N+q), heap and index storage\\n\\n# Code\\n```\\nfunc minInterval(intervals [][]int, queries []int) []int {\\n    queryNodes := [][]int{}\\n    \\n    for i := 0; i < len(queries); i++ {\\n        queryNodes = append(queryNodes, []int{queries[i], i})\\n    }\\n    sort.Slice(queryNodes, func (i, j int) bool {\\n        return queryNodes[i][0] < queryNodes[j][0]\\n    })\\n    \\n    sort.Slice(intervals, func (i, j int) bool {\\n        return intervals[i][0] < intervals[j][0]\\n    })\\n    \\n    res := make([]int, len(queries))\\n    minHeap := &MinHeap{}\\n    j := 0\\n    for i := 0; i < len(queries); i++ {\\n        query := queryNodes[i]\\n        \\n        for j < len(intervals) && intervals[j][0] <= query[0] {\\n            heap.Push(minHeap, intervals[j])\\n            j++\\n        }\\n        \\n        for minHeap.Len() > 0 && minHeap.Top()[1] < query[0] {\\n            heap.Pop(minHeap)\\n        }\\n        \\n        if minHeap.Len() > 0 {\\n            res[query[1]] = minHeap.Top()[1]-minHeap.Top()[0]+1\\n        } else {\\n            res[query[1]] = -1\\n        }\\n    }\\n    \\n    return res\\n}\\n\\ntype MinHeap [][]int\\n\\nfunc (h MinHeap) Len() int {\\n    return len(h)\\n}\\n\\nfunc (h MinHeap) Less(i int, j int) bool {\\n    return h[i][1]-h[i][0] < h[j][1]-h[j][0]\\n}\\n                          \\nfunc (h MinHeap) Swap(i int, j int) {\\n    h[i], h[j] = h[j], h[i]\\n} \\n                          \\nfunc (h *MinHeap) Push(a interface{}) {\\n    *h = append(*h, a.([]int))\\n}\\n\\nfunc (h *MinHeap) Pop() interface{} {\\n    l := len(*h)\\n    res := (*h)[l - 1]\\n    *h = (*h)[:l - 1]\\n    return res\\n}\\n\\nfunc (h *MinHeap) Top() []int {\\n    return (*h)[0]\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minInterval(intervals [][]int, queries []int) []int {\\n    queryNodes := [][]int{}\\n    \\n    for i := 0; i < len(queries); i++ {\\n        queryNodes = append(queryNodes, []int{queries[i], i})\\n    }\\n    sort.Slice(queryNodes, func (i, j int) bool {\\n        return queryNodes[i][0] < queryNodes[j][0]\\n    })\\n    \\n    sort.Slice(intervals, func (i, j int) bool {\\n        return intervals[i][0] < intervals[j][0]\\n    })\\n    \\n    res := make([]int, len(queries))\\n    minHeap := &MinHeap{}\\n    j := 0\\n    for i := 0; i < len(queries); i++ {\\n        query := queryNodes[i]\\n        \\n        for j < len(intervals) && intervals[j][0] <= query[0] {\\n            heap.Push(minHeap, intervals[j])\\n            j++\\n        }\\n        \\n        for minHeap.Len() > 0 && minHeap.Top()[1] < query[0] {\\n            heap.Pop(minHeap)\\n        }\\n        \\n        if minHeap.Len() > 0 {\\n            res[query[1]] = minHeap.Top()[1]-minHeap.Top()[0]+1\\n        } else {\\n            res[query[1]] = -1\\n        }\\n    }\\n    \\n    return res\\n}\\n\\ntype MinHeap [][]int\\n\\nfunc (h MinHeap) Len() int {\\n    return len(h)\\n}\\n\\nfunc (h MinHeap) Less(i int, j int) bool {\\n    return h[i][1]-h[i][0] < h[j][1]-h[j][0]\\n}\\n                          \\nfunc (h MinHeap) Swap(i int, j int) {\\n    h[i], h[j] = h[j], h[i]\\n} \\n                          \\nfunc (h *MinHeap) Push(a interface{}) {\\n    *h = append(*h, a.([]int))\\n}\\n\\nfunc (h *MinHeap) Pop() interface{} {\\n    l := len(*h)\\n    res := (*h)[l - 1]\\n    *h = (*h)[:l - 1]\\n    return res\\n}\\n\\nfunc (h *MinHeap) Top() []int {\\n    return (*h)[0]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3170248,
                "title": "c-solution-explained",
                "content": "# Intuition\\nMy first thought is to sort the intervals and queries, then use a priority queue to keep track of the minimum interval for each query. \\n\\n# Approach\\nTo solve this problem, I first sorted the intervals and queries. Then I used a priority queue to store the intervals. For each query, I iterated through the intervals until I found one that is larger than the query. This process ensures that the intervals stored in the priority queue are all valid and smaller than the query. Then I check if the priority queue is empty, if it is not then I output the minimum interval in the queue.\\n\\n# Complexity\\n- Time complexity: $$O(n \\\\log n)$$ \\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\n#pragma GCC optimize(\"Ofast\",\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\",\"f16c\")\\nstatic const auto fast = []() {ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); return 0; } ();\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        int n = queries.size();\\n        vector<int> ans(n, -1);\\n        vector<pair<int, int>> q(n);\\n        for (int i = 0; i < n; ++i) {\\n            q[i] = {queries[i], i};\\n        }\\n        sort(q.begin(), q.end());\\n        sort(intervals.begin(), intervals.end());\\n        int m = intervals.size(), j = 0;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        for (int i = 0; i < n; ++i) {\\n            while (j < m && intervals[j][0] <= q[i].first) {\\n                pq.push({intervals[j][1] - intervals[j][0] + 1, intervals[j][1]});\\n                ++j;\\n            }\\n            while (!pq.empty() && pq.top().second < q[i].first) {\\n                pq.pop();\\n            }\\n            if (!pq.empty()) {\\n                ans[q[i].second] = pq.top().first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Line Sweep",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n#pragma GCC optimize(\"Ofast\",\"inline\",\"fast-math\",\"unroll-loops\",\"no-stack-protector\")\\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\",\"f16c\")\\nstatic const auto fast = []() {ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0); return 0; } ();\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        int n = queries.size();\\n        vector<int> ans(n, -1);\\n        vector<pair<int, int>> q(n);\\n        for (int i = 0; i < n; ++i) {\\n            q[i] = {queries[i], i};\\n        }\\n        sort(q.begin(), q.end());\\n        sort(intervals.begin(), intervals.end());\\n        int m = intervals.size(), j = 0;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        for (int i = 0; i < n; ++i) {\\n            while (j < m && intervals[j][0] <= q[i].first) {\\n                pq.push({intervals[j][1] - intervals[j][0] + 1, intervals[j][1]});\\n                ++j;\\n            }\\n            while (!pq.empty() && pq.top().second < q[i].first) {\\n                pq.pop();\\n            }\\n            if (!pq.empty()) {\\n                ans[q[i].second] = pq.top().first;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2859405,
                "title": "python-priority-queue-ez",
                "content": "```\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        intervals.sort()\\n        queries_s = sorted((val, i) for i, val in enumerate(queries))\\n        \\n        res = [-1] * len(queries)\\n        curr_interval_index = 0\\n        pq = []\\n        \\n        for query, ind in queries_s:\\n            \\n            while curr_interval_index < len(intervals) and query >= intervals[curr_interval_index][0]:\\n                diff = intervals[curr_interval_index][1] - intervals[curr_interval_index][0] + 1\\n                heappush(pq, (diff, intervals[curr_interval_index]))\\n                curr_interval_index += 1\\n            \\n            \\n            while pq and (pq[0][1][1] < query):\\n                heappop(pq)\\n            \\n            \\n            res[ind] = pq[0][0] if pq else -1\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        intervals.sort()\\n        queries_s = sorted((val, i) for i, val in enumerate(queries))\\n        \\n        res = [-1] * len(queries)\\n        curr_interval_index = 0\\n        pq = []\\n        \\n        for query, ind in queries_s:\\n            \\n            while curr_interval_index < len(intervals) and query >= intervals[curr_interval_index][0]:\\n                diff = intervals[curr_interval_index][1] - intervals[curr_interval_index][0] + 1\\n                heappush(pq, (diff, intervals[curr_interval_index]))\\n                curr_interval_index += 1\\n            \\n            \\n            while pq and (pq[0][1][1] < query):\\n                heappop(pq)\\n            \\n            \\n            res[ind] = pq[0][0] if pq else -1\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2794832,
                "title": "python3-sorting-heap-w-comments",
                "content": "```\\n def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        \\n        #Observation: We know that for a query, any intervals starting time that is\\n        #equal to that query value, is a valid interval for that query\\n        \\n        #Sort the queries by value\\n        #Sort the intervals by the starting time\\n        #Loop through the queruies\\n        \\n        #While the starting time of the interval is <= the query value, add the finishing time and size\\n        # of the interval to our heap\\n        \\n        #While the ending time is less than the query value, pop that interval (because it isnt valid)\\n        \\n        #Also make sure the heap sorts by the size of the interval so we after we are done popping, we \\n        #can get the head of the heap in 0(1) time which will be the smallest interval that the query is valid for\\n        \\n        #index into our result with the query that we\\'re on\\'s index, and set it to the size of that interval\\n        \\n        result = [-1] * len(queries)\\n        heap = []\\n        intervals.sort(key=lambda x:x[0])\\n        queries = [(queries, i) for i, queries in enumerate(queries)]\\n        queries.sort()\\n        interval_idx = 0\\n\\n        for query, query_idx in queries:\\n            \\n            while interval_idx < len(intervals) and intervals[interval_idx][0] <= query:\\n                size = intervals[interval_idx][1] - intervals[interval_idx][0] + 1\\n                end_time = intervals[interval_idx][1]\\n                heappush(heap, (size, end_time))\\n                interval_idx += 1\\n            \\n            while len(heap) and heap[0][1] < query:\\n                heappop(heap)\\n            \\n            if len(heap):\\n                size = heap[0][0]\\n                result[query_idx] = size\\n              \\n            \\n        return result\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        \\n        #Observation: We know that for a query, any intervals starting time that is\\n        #equal to that query value, is a valid interval for that query\\n        \\n        #Sort the queries by value\\n        #Sort the intervals by the starting time\\n        #Loop through the queruies\\n        \\n        #While the starting time of the interval is <= the query value, add the finishing time and size\\n        # of the interval to our heap\\n        \\n        #While the ending time is less than the query value, pop that interval (because it isnt valid)\\n        \\n        #Also make sure the heap sorts by the size of the interval so we after we are done popping, we \\n        #can get the head of the heap in 0(1) time which will be the smallest interval that the query is valid for\\n        \\n        #index into our result with the query that we\\'re on\\'s index, and set it to the size of that interval\\n        \\n        result = [-1] * len(queries)\\n        heap = []\\n        intervals.sort(key=lambda x:x[0])\\n        queries = [(queries, i) for i, queries in enumerate(queries)]\\n        queries.sort()\\n        interval_idx = 0\\n\\n        for query, query_idx in queries:\\n            \\n            while interval_idx < len(intervals) and intervals[interval_idx][0] <= query:\\n                size = intervals[interval_idx][1] - intervals[interval_idx][0] + 1\\n                end_time = intervals[interval_idx][1]\\n                heappush(heap, (size, end_time))\\n                interval_idx += 1\\n            \\n            while len(heap) and heap[0][1] < query:\\n                heappop(heap)\\n            \\n            if len(heap):\\n                size = heap[0][0]\\n                result[query_idx] = size\\n              \\n            \\n        return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2526951,
                "title": "python-faster-than-98-using-minheap-easy-to-understand-explained",
                "content": "```\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        intervals.sort(key = lambda x: x[0])\\n        query_results = {}\\n        heap = []\\n        \\n        i = 0\\n        for q in sorted(queries):\\n            query_results[q] = -1\\n            # populate heap with (size, end) so we can get the smallest valid interval for the query \\n            while i < len(intervals) and q >= intervals[i][0]:\\n                start, end = intervals[i]\\n                heapq.heappush(heap, (1 + end - start, end))    \\n                i += 1\\n            # clean up heap by popping invalid results. Any results not valid now will not be valid for\\n            # any future queries, since we are looping through the queries in ascending order. \\n            while heap and q > heap[0][1]:\\n                heapq.heappop(heap)\\n            # After cleanup, the front of the heap is guarnteed to be the smallest sized interval \\n            # that is valid for the given query. \\n            if heap:\\n                query_results[q] = heap[0][0]\\n        \\n        # we must return the query results in the same order we got them\\n        return [query_results[q] for q in queries]\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        intervals.sort(key = lambda x: x[0])\\n        query_results = {}\\n        heap = []\\n        \\n        i = 0\\n        for q in sorted(queries):\\n            query_results[q] = -1\\n            # populate heap with (size, end) so we can get the smallest valid interval for the query \\n            while i < len(intervals) and q >= intervals[i][0]:\\n                start, end = intervals[i]\\n                heapq.heappush(heap, (1 + end - start, end))    \\n                i += 1\\n            # clean up heap by popping invalid results. Any results not valid now will not be valid for\\n            # any future queries, since we are looping through the queries in ascending order. \\n            while heap and q > heap[0][1]:\\n                heapq.heappop(heap)\\n            # After cleanup, the front of the heap is guarnteed to be the smallest sized interval \\n            # that is valid for the given query. \\n            if heap:\\n                query_results[q] = heap[0][0]\\n        \\n        # we must return the query results in the same order we got them\\n        return [query_results[q] for q in queries]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2340833,
                "title": "c-two-solutions-segment-trees-and-priority-queue",
                "content": "# **Priority Queue**\\n\\n```\\nfaster than 40%, 1251 ms\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        vector<vector<int>> q;\\n        vector<int> res(queries.size(), -1);\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>> > pq;\\n        for(int i=0; i<queries.size(); i++)\\n            q.push_back({queries[i], i});\\n        sort(q.begin(), q.end());\\n        sort(intervals.begin(), intervals.end());\\n        int i=0, j=0;\\n        while(j<q.size())\\n        {\\n            while(i<intervals.size() && intervals[i][0]<=q[j][0])\\n            {\\n                pq.push({intervals[i][1]-intervals[i][0]+1, intervals[i][1]});\\n                i++;\\n            }\\n            while(!pq.empty() && pq.top().second<q[j][0])\\n                pq.pop();\\n            if(!pq.empty())\\n                res[q[j][1]]=pq.top().first;\\n            j++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n\\n\\n# **Segment Trees**\\n\\n```\\nFaster than 90%, 655 ms\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    class node {\\n        public:\\n        int start, end, mid, interval;\\n        node *left, *right;\\n        node(int x, int y){\\n            start=x;\\n            end=y;\\n            mid=(x+y)/2;\\n            interval=INT_MAX;\\n            left=NULL;\\n            right=NULL;\\n        }\\n    };\\n    \\n    void add(int start, int end, int range, node *root){\\n        if(end<root->start || start>root->end || root->interval<=range)\\n            return;\\n        if(start<=root->start && end>=root->end)\\n            root->interval = min(range, root->interval);\\n        else\\n        {\\n            if(!root->left)\\n                root->left=new node(root->start, root->mid);\\n            add(start, end, range, root->left);\\n            if(!root->right)\\n                root->right=new node(root->mid+1, root->end);\\n            add(start, end, range, root->right);\\n        }\\n    }\\n    \\n    int MinRange(int num, node *root)\\n    {\\n        if(!root || num<root->start || num>root->end)\\n            return INT_MAX;\\n        return min(root->interval, min(MinRange(num, root->left), MinRange(num, root->right)));\\n    }\\n    \\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        node *root=new node(1, 10000000);\\n        for(auto i: intervals)\\n            add(i[0], i[1], i[1]-i[0]+1, root);\\n        vector<int> res;\\n        for(auto i: queries)\\n        {\\n            int temp=MinRange(i, root);\\n            res.push_back((temp<INT_MAX?temp:-1));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfaster than 40%, 1251 ms\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        vector<vector<int>> q;\\n        vector<int> res(queries.size(), -1);\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>> > pq;\\n        for(int i=0; i<queries.size(); i++)\\n            q.push_back({queries[i], i});\\n        sort(q.begin(), q.end());\\n        sort(intervals.begin(), intervals.end());\\n        int i=0, j=0;\\n        while(j<q.size())\\n        {\\n            while(i<intervals.size() && intervals[i][0]<=q[j][0])\\n            {\\n                pq.push({intervals[i][1]-intervals[i][0]+1, intervals[i][1]});\\n                i++;\\n            }\\n            while(!pq.empty() && pq.top().second<q[j][0])\\n                pq.pop();\\n            if(!pq.empty())\\n                res[q[j][1]]=pq.top().first;\\n            j++;\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nFaster than 90%, 655 ms\\n```\n```\\nclass Solution {\\npublic:\\n    class node {\\n        public:\\n        int start, end, mid, interval;\\n        node *left, *right;\\n        node(int x, int y){\\n            start=x;\\n            end=y;\\n            mid=(x+y)/2;\\n            interval=INT_MAX;\\n            left=NULL;\\n            right=NULL;\\n        }\\n    };\\n    \\n    void add(int start, int end, int range, node *root){\\n        if(end<root->start || start>root->end || root->interval<=range)\\n            return;\\n        if(start<=root->start && end>=root->end)\\n            root->interval = min(range, root->interval);\\n        else\\n        {\\n            if(!root->left)\\n                root->left=new node(root->start, root->mid);\\n            add(start, end, range, root->left);\\n            if(!root->right)\\n                root->right=new node(root->mid+1, root->end);\\n            add(start, end, range, root->right);\\n        }\\n    }\\n    \\n    int MinRange(int num, node *root)\\n    {\\n        if(!root || num<root->start || num>root->end)\\n            return INT_MAX;\\n        return min(root->interval, min(MinRange(num, root->left), MinRange(num, root->right)));\\n    }\\n    \\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        node *root=new node(1, 10000000);\\n        for(auto i: intervals)\\n            add(i[0], i[1], i[1]-i[0]+1, root);\\n        vector<int> res;\\n        for(auto i: queries)\\n        {\\n            int temp=MinRange(i, root);\\n            res.push_back((temp<INT_MAX?temp:-1));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2315278,
                "title": "python-3-hashmap-priority-queue-min-heap",
                "content": "\\tclass Solution:\\n\\t\\tdef minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n\\t\\t\\thashMap = {}\\n\\t\\t\\tintervals.sort()\\n\\n\\t\\t\\tminHeap = []\\n\\n\\t\\t\\ti_l = len(intervals)\\n\\t\\t\\ti = 0\\n\\t\\t\\tfor q in sorted(queries):\\n\\t\\t\\t\\twhile i < i_l and intervals[i][0] <= q:\\n\\t\\t\\t\\t\\tstart, end = intervals[i]\\n\\t\\t\\t\\t\\theapq.heappush(minHeap, [(end-start+1), end])\\n\\t\\t\\t\\t\\ti += 1\\n\\n\\t\\t\\t\\twhile minHeap and minHeap[0][1] < q:\\n\\t\\t\\t\\t\\theapq.heappop(minHeap)\\n\\n\\t\\t\\t\\thashMap[q] = minHeap[0][0] if minHeap else -1\\n\\n\\t\\t\\treturn [hashMap[q] for q in queries]",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution:\\n\\t\\tdef minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n\\t\\t\\thashMap = {}",
                "codeTag": "Java"
            },
            {
                "id": 2304477,
                "title": "c-sorting-multiset",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        vector<vector<int>> events;\\n\\t\\tfor (vector<int> &e: intervals) {\\n\\t\\t\\tevents.push_back({e[0], 1, e[1] - e[0] + 1});\\n\\t\\t\\tevents.push_back({e[1] + 1, -1, e[1] - e[0] + 1});\\n\\t\\t}\\n\\t\\tint n = queries.size();\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tevents.push_back({queries[i], 2, i});\\n\\t\\t}\\n\\t\\tsort(events.begin(), events.end(), [](const vector<int> &a, const vector<int> &b) {\\n\\t\\t\\tif (a[0] != b[0]) return a[0] < b[0];\\n\\t\\t\\treturn a[1] < b[1];\\n\\t\\t});\\n\\t\\tvector<int> res(n);\\n\\t\\tmultiset<int> ms;\\n\\t\\tfor (vector<int> &v: events) {\\n\\t\\t\\tif (v[1] == 1) {\\n\\t\\t\\t\\tms.insert(v[2]);\\n\\t\\t\\t} else if (v[1] == -1) {\\n\\t\\t\\t\\tms.erase(ms.lower_bound(v[2]));\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (ms.empty()) {\\n\\t\\t\\t\\t\\tres[v[2]] = -1;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tres[v[2]] = *ms.begin();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        vector<vector<int>> events;\\n\\t\\tfor (vector<int> &e: intervals) {\\n\\t\\t\\tevents.push_back({e[0], 1, e[1] - e[0] + 1});\\n\\t\\t\\tevents.push_back({e[1] + 1, -1, e[1] - e[0] + 1});\\n\\t\\t}\\n\\t\\tint n = queries.size();\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tevents.push_back({queries[i], 2, i});\\n\\t\\t}\\n\\t\\tsort(events.begin(), events.end(), [](const vector<int> &a, const vector<int> &b) {\\n\\t\\t\\tif (a[0] != b[0]) return a[0] < b[0];\\n\\t\\t\\treturn a[1] < b[1];\\n\\t\\t});\\n\\t\\tvector<int> res(n);\\n\\t\\tmultiset<int> ms;\\n\\t\\tfor (vector<int> &v: events) {\\n\\t\\t\\tif (v[1] == 1) {\\n\\t\\t\\t\\tms.insert(v[2]);\\n\\t\\t\\t} else if (v[1] == -1) {\\n\\t\\t\\t\\tms.erase(ms.lower_bound(v[2]));\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (ms.empty()) {\\n\\t\\t\\t\\t\\tres[v[2]] = -1;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tres[v[2]] = *ms.begin();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2252405,
                "title": "java-sweep-line-algorithm-easy",
                "content": "**Sweep Line Algorithm**:\\nCreate a new class called Event. Each event has\\xA0`[value,type,additionValue]`.\\n\\nWe can combine the intervals and queries arrays into one array of events.\\n\\nThen sort the array of events base on value (if values are the same, sort by type)\\n\\nIterate through events array:\\n1. If the event is the left of the interval, add it to the TreeMap<length of the interval, right of the interval> which is sorted by the length of the interval\\n2. If the event is the right of the interval, means we need to close the interval. Remove one from the TreeMap.\\n3. If the event is the query, look at the top of the TreeMap to get the smalleset interval.\\n\\n```\\nclass Solution { \\n    class Event{\\n        int value;//left, right or query value\\n        int type;//0 - interval left ; 1 - queries ; 2 - interval right\\n        int additionValue;//right or left or index of the query\\n        \\n        public Event(int value, int type, int additionValue){\\n            this.value = value;\\n            this.type = type;\\n            this.additionValue = additionValue;\\n        }\\n    }\\n    \\n    public int[] minInterval(int[][] intervals, int[] queries) {\\n        //base case\\n        if(intervals == null || intervals.length == 0 || queries == null || queries.length == 0) return new int[0];\\n        \\n        int numOfQueries = queries.length;\\n        int numOfIntervals = intervals.length;\\n        \\n        int[] result = new int[numOfQueries];\\n        \\n        List<Event> eventList = new ArrayList<>(numOfIntervals * 2 + numOfQueries);\\n        int i = 0;\\n        while(i < Math.max(numOfQueries, numOfIntervals)){\\n            if(i < numOfQueries) {\\n                eventList.add(new Event(queries[i], 1, i));//1 - query\\n            }\\n            if(i < numOfIntervals){\\n                int left = intervals[i][0];\\n                int right = intervals[i][1];\\n                eventList.add(new Event(left, 0, right));//0 - left\\n                eventList.add(new Event(right, 2, left));//2 - right\\n            }\\n            i++;\\n        }\\n        \\n        //sort the eventList by value (if values are the same, sort by type)\\n        Comparator<Event> cmp = new Comparator<>(){\\n            @Override\\n            public int compare(Event a, Event b){\\n                if(a.value == b.value) return a.type - b.type;\\n                else return a.value - b.value;\\n            }\\n        };\\n        Collections.sort(eventList, cmp);\\n        \\n        TreeMap<Integer, Integer> lengthSortedMap = new TreeMap<>();\\n        int numOfQueryProcessed = 0;\\n        for(Event e : eventList){\\n            if(e.type == 0){\\n                //interval start (open the interval)\\n                lengthSortedMap.put(e.additionValue - e.value + 1, e.additionValue);//length, right value\\n            } else if(e.type == 2){\\n                //interval end -> remove the start (close the interval)\\n                lengthSortedMap.remove(e.value - e.additionValue + 1, e.value);\\n            }\\n            else {\\n                //query\\n                if(!lengthSortedMap.isEmpty()){\\n                    result[e.additionValue] = lengthSortedMap.firstEntry().getKey();\\n                    numOfQueryProcessed++;\\n                } else result[e.additionValue] = -1;\\n            }\\n            if(numOfQueryProcessed == numOfQueries) break;//processed all queries, break the loop\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution { \\n    class Event{\\n        int value;//left, right or query value\\n        int type;//0 - interval left ; 1 - queries ; 2 - interval right\\n        int additionValue;//right or left or index of the query\\n        \\n        public Event(int value, int type, int additionValue){\\n            this.value = value;\\n            this.type = type;\\n            this.additionValue = additionValue;\\n        }\\n    }\\n    \\n    public int[] minInterval(int[][] intervals, int[] queries) {\\n        //base case\\n        if(intervals == null || intervals.length == 0 || queries == null || queries.length == 0) return new int[0];\\n        \\n        int numOfQueries = queries.length;\\n        int numOfIntervals = intervals.length;\\n        \\n        int[] result = new int[numOfQueries];\\n        \\n        List<Event> eventList = new ArrayList<>(numOfIntervals * 2 + numOfQueries);\\n        int i = 0;\\n        while(i < Math.max(numOfQueries, numOfIntervals)){\\n            if(i < numOfQueries) {\\n                eventList.add(new Event(queries[i], 1, i));//1 - query\\n            }\\n            if(i < numOfIntervals){\\n                int left = intervals[i][0];\\n                int right = intervals[i][1];\\n                eventList.add(new Event(left, 0, right));//0 - left\\n                eventList.add(new Event(right, 2, left));//2 - right\\n            }\\n            i++;\\n        }\\n        \\n        //sort the eventList by value (if values are the same, sort by type)\\n        Comparator<Event> cmp = new Comparator<>(){\\n            @Override\\n            public int compare(Event a, Event b){\\n                if(a.value == b.value) return a.type - b.type;\\n                else return a.value - b.value;\\n            }\\n        };\\n        Collections.sort(eventList, cmp);\\n        \\n        TreeMap<Integer, Integer> lengthSortedMap = new TreeMap<>();\\n        int numOfQueryProcessed = 0;\\n        for(Event e : eventList){\\n            if(e.type == 0){\\n                //interval start (open the interval)\\n                lengthSortedMap.put(e.additionValue - e.value + 1, e.additionValue);//length, right value\\n            } else if(e.type == 2){\\n                //interval end -> remove the start (close the interval)\\n                lengthSortedMap.remove(e.value - e.additionValue + 1, e.value);\\n            }\\n            else {\\n                //query\\n                if(!lengthSortedMap.isEmpty()){\\n                    result[e.additionValue] = lengthSortedMap.firstEntry().getKey();\\n                    numOfQueryProcessed++;\\n                } else result[e.additionValue] = -1;\\n            }\\n            if(numOfQueryProcessed == numOfQueries) break;//processed all queries, break the loop\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2234263,
                "title": "c-solution-priority-queue",
                "content": "```\\npublic class Solution {\\n    public int[] MinInterval(int[][] intervals, int[] queries) {\\n        \\n        var q = queries.Length;\\n        var indexDict = new int[q][];\\n        var index = 0;\\n        foreach(var query in queries){\\n            indexDict[index] = new int[2]{query, index};\\n            index++;\\n        }\\n        Array.Sort(indexDict, (a, b) => a[0]-b[0]);\\n        Array.Sort(intervals, (a, b) => a[0]-b[0]);\\n        \\n        var pq = new PriorityQueue<int[], int>();\\n        var result = new int[queries.Length];\\n        \\n        index = 0;\\n        foreach(var query in indexDict){\\n            var resultIndex = query;\\n            var calResult = -1;\\n            \\n            while(index < intervals.Length && intervals[index][0] <= resultIndex[0]){\\n                var curr = intervals[index];\\n                pq.Enqueue(new int[2] {curr[1]-curr[0]+1, curr[1]}, curr[1]-curr[0]+1);\\n                index++;\\n            }\\n            \\n            while(pq.Count > 0 && pq.Peek()[1] < resultIndex[0]){\\n                pq.Dequeue();\\n            }\\n            calResult = pq.Count > 0 ? pq.Peek()[0]: -1;\\n            result[resultIndex[1]] = calResult;\\n        }\\n        \\n        return result;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] MinInterval(int[][] intervals, int[] queries) {\\n        \\n        var q = queries.Length;\\n        var indexDict = new int[q][];\\n        var index = 0;\\n        foreach(var query in queries){\\n            indexDict[index] = new int[2]{query, index};\\n            index++;\\n        }\\n        Array.Sort(indexDict, (a, b) => a[0]-b[0]);\\n        Array.Sort(intervals, (a, b) => a[0]-b[0]);\\n        \\n        var pq = new PriorityQueue<int[], int>();\\n        var result = new int[queries.Length];\\n        \\n        index = 0;\\n        foreach(var query in indexDict){\\n            var resultIndex = query;\\n            var calResult = -1;\\n            \\n            while(index < intervals.Length && intervals[index][0] <= resultIndex[0]){\\n                var curr = intervals[index];\\n                pq.Enqueue(new int[2] {curr[1]-curr[0]+1, curr[1]}, curr[1]-curr[0]+1);\\n                index++;\\n            }\\n            \\n            while(pq.Count > 0 && pq.Peek()[1] < resultIndex[0]){\\n                pq.Dequeue();\\n            }\\n            calResult = pq.Count > 0 ? pq.Peek()[0]: -1;\\n            result[resultIndex[1]] = calResult;\\n        }\\n        \\n        return result;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2026366,
                "title": "easy-to-understand-and-fully-commented-c-solution",
                "content": "```\\n/*\\nexplanation:\\n\\n1. we can first sort the intervals and for each query we can push those intervals in which it lies into the min heap\\n   w.r.t size and right end of the interval and conditons will query[i]>= left side of interval and query[i]<= right side.\\n \\n2. we can use a hashmap to keep the original index of the queries and then sort the queries array to move from min\\n   query to max.\\n   \\n3. if the top value of heap lies in the range of ith query then store the size in the result vector else pop out that        value from minheap as i+1th query will also be out of range.\\n\\n*/\\nclass Solution {\\npublic:\\n    #define p pair<int,int>\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n      int n=intervals.size();\\n        \\n      sort(intervals.begin(),intervals.end());\\n        \\n      unordered_map<int,vector<int>>mp; //to the original index of the queries (there can be duplicates..)\\n        \\n      for(int i=0;i<queries.size();++i)\\n        mp[queries[i]].push_back(i);\\n        \\n      sort(queries.begin(),queries.end());\\n        \\n      priority_queue<p,vector<p>,greater<p>>pq; //min heap [size,right side of the array]  \\n        \\n      int i=0;\\n        \\n      vector<int>res(queries.size(),-1); //resultant vector\\n        \\n      for(int j=0;j<queries.size();++j){\\n        while(i<n){\\n          if(intervals[i][0]<=queries[j] and intervals[i][1]>=queries[j]){  //condition to insert in min heap\\n              pq.push({intervals[i][1]-intervals[i][0]+1,intervals[i][1]});\\n              ++i;}\\n         else if(intervals[i][1]<queries[j]) ++i; //if right value is less than query then move to the next interval\\n         else break;}\\n          \\n        while(pq.size()>0){\\n           auto [size,right]=pq.top();\\n           if(right>=queries[j]){\\n               for(auto it:mp[queries[j]]) res[it]=size;\\n               break;}\\n           else pq.pop();}}\\n        \\n          return res;}};\\n```\\nif liked my solution please upvote.  :)",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/*\\nexplanation:\\n\\n1. we can first sort the intervals and for each query we can push those intervals in which it lies into the min heap\\n   w.r.t size and right end of the interval and conditons will query[i]>= left side of interval and query[i]<= right side.\\n \\n2. we can use a hashmap to keep the original index of the queries and then sort the queries array to move from min\\n   query to max.\\n   \\n3. if the top value of heap lies in the range of ith query then store the size in the result vector else pop out that        value from minheap as i+1th query will also be out of range.\\n\\n*/\\nclass Solution {\\npublic:\\n    #define p pair<int,int>\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n      int n=intervals.size();\\n        \\n      sort(intervals.begin(),intervals.end());\\n        \\n      unordered_map<int,vector<int>>mp; //to the original index of the queries (there can be duplicates..)\\n        \\n      for(int i=0;i<queries.size();++i)\\n        mp[queries[i]].push_back(i);\\n        \\n      sort(queries.begin(),queries.end());\\n        \\n      priority_queue<p,vector<p>,greater<p>>pq; //min heap [size,right side of the array]  \\n        \\n      int i=0;\\n        \\n      vector<int>res(queries.size(),-1); //resultant vector\\n        \\n      for(int j=0;j<queries.size();++j){\\n        while(i<n){\\n          if(intervals[i][0]<=queries[j] and intervals[i][1]>=queries[j]){  //condition to insert in min heap\\n              pq.push({intervals[i][1]-intervals[i][0]+1,intervals[i][1]});\\n              ++i;}\\n         else if(intervals[i][1]<queries[j]) ++i; //if right value is less than query then move to the next interval\\n         else break;}\\n          \\n        while(pq.size()>0){\\n           auto [size,right]=pq.top();\\n           if(right>=queries[j]){\\n               for(auto it:mp[queries[j]]) res[it]=size;\\n               break;}\\n           else pq.pop();}}\\n        \\n          return res;}};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979670,
                "title": "c-segment-tree-iterative-recursive-solution",
                "content": "**Segment Tree Recursive Solution**\\n\\n```\\nStore the min interval values of the given range in Segment tree.\\nGet the min value of the [Q,Q] range of Segment tree for queries[i] => Q\\nwhich gets updated only for the ranges => left <= Q <= right\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // update min value of the intervals with lazy propagation\\n    void update(int * tree, int *lazy, int index, int low, int high, int minRange, int maxRange, int val)\\n    {\\n        int left = 2 * index + 1;\\n        int right = left + 1;\\n            \\n        // update lazy value to child and current node\\n        if(lazy[index]!=INT_MAX)\\n        {\\n            tree[index] = min(tree[index],lazy[index]);\\n            if(low!=high)\\n            {\\n                lazy[left] = min(lazy[left],lazy[index]);\\n                lazy[right] = min(lazy[right],lazy[index]);\\n            }\\n            lazy[index] = INT_MAX;\\n        }\\n\\n        // no overlap\\n        if(low > maxRange || high < minRange) return;\\n        \\n        // complete overlap\\n        if(low>=minRange && high<=maxRange)\\n        {\\n            tree[index] = min(tree[index],val);\\n            lazy[index] = min(lazy[index],val);\\n            \\n            if(low!=high)\\n            {\\n                lazy[left] = min(lazy[left],lazy[index]);\\n                lazy[right] = min(lazy[right],lazy[index]);\\n            }\\n\\n            return;\\n        }\\n\\n        // partial overlap\\n        \\n        int mid = low + (high-low)/2;\\n\\n        update(tree,lazy,left,low,mid,minRange,maxRange,val);\\n        update(tree,lazy,right,mid+1,high,minRange,maxRange,val);\\n    }\\n\\n    // query min value of the intervals with lazy propagation    \\n    int query(int * tree, int *lazy, int index, int low, int high, int range)\\n    {\\n        if(low > range || high < range) return INT_MAX;\\n\\n        int left = 2 * index + 1;\\n        int right = left + 1;\\n            \\n        if(lazy[index]!=INT_MAX)\\n        {\\n            tree[index] = min(tree[index],lazy[index]);\\n            if(low!=high)\\n            {\\n                lazy[left] = min(lazy[left],lazy[index]);\\n                lazy[right] = min(lazy[right],lazy[index]);\\n            }\\n            lazy[index] = INT_MAX;\\n        }\\n\\n        // get the range leaf value\\n        if(low==range && high==range) return tree[index];\\n\\n        int mid = low + (high-low)/2;\\n\\n        // only move to the side which contains range\\n        \\n        if(range <= mid) return query(tree,lazy,left,low,mid,range);\\n        else return query(tree,lazy,right,mid+1,high,range);\\n\\n    }\\n\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n\\n        // get max possible value in the interval and query\\n        int maxVal = INT_MIN;\\n        for(int i=0;i<intervals.size();i++)\\n            maxVal= max(maxVal,intervals[i][1]);\\n        \\n        for(int i=0;i<queries.size();i++)\\n           maxVal = max(maxVal,queries[i]);\\n        \\n        maxVal++;\\n        \\n        // make max range segment tree and lazy tree\\n        int *tree = new int[4*maxVal];\\n        int *lazy = new int[4*maxVal];\\n\\n        for(int i=0;i<4*maxVal;i++){\\n            tree[i] = INT_MAX;\\n            lazy[i] = INT_MAX;\\n        }\\n        \\n        // update the min interval value for all intervals\\n        for(int i=0;i<intervals.size();i++)\\n            update(tree,lazy,0,0,maxVal-1,intervals[i][0],intervals[i][1],intervals[i][1]-intervals[i][0]+1);\\n\\n        vector<int>res;\\n        int result;\\n        \\n        // get query min interval value\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            result = query(tree,lazy,0,0,maxVal-1,queries[i]);\\n            res.push_back(result==INT_MAX ? -1 : result);\\n        }           \\n\\n        return res;\\n    }\\n};\\n```\\n\\n\\n**Segment Tree Iterative Solution**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // update min value of the intervals\\n    void update(int * tree, int minRange, int maxRange, int val)\\n    {\\n        int left = minRange + N;\\n        int right = maxRange + N;\\n        \\n        while(left <= right)\\n        {\\n            if(left&1)\\n            {\\n                tree[left] = min(tree[left],val);\\n                left++;\\n            }\\n            \\n            if(!(right&1))\\n            {\\n                tree[right] = min(tree[right],val);\\n                right--;\\n            }\\n            \\n            left = left >> 1;\\n            right = right >> 1;\\n        }\\n    }\\n\\n    // query min value of the intervals \\n    int query(int * tree, int range)\\n    {\\n        int index = range + N;\\n        int res = tree[index];\\n        \\n        while(index > 1)\\n        {\\n            index = index >> 1;\\n            res = min(res,tree[index]);\\n        }\\n        \\n        return res;\\n    }\\n\\n    int N;\\n    \\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n\\n        // get max possible value in the interval and query\\n        int maxVal = INT_MIN;\\n        for(int i=0;i<intervals.size();i++)\\n            maxVal= max(maxVal,intervals[i][1]);\\n        \\n        for(int i=0;i<queries.size();i++)\\n           maxVal = max(maxVal,queries[i]);\\n        \\n        N = maxVal;\\n        maxVal++;\\n        \\n        // make max range segment tree\\n        int *tree = new int[2*maxVal];\\n\\n        for(int i=0;i<2*maxVal;i++)\\n            tree[i] = INT_MAX;\\n        \\n        // update the min interval value for all intervals\\n        for(int i=0;i<intervals.size();i++)\\n            update(tree,intervals[i][0],intervals[i][1],intervals[i][1]-intervals[i][0]+1);\\n\\n        vector<int>res;\\n        int result;\\n        \\n        // get query min interval value\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            result = query(tree,queries[i]);\\n            res.push_back(result==INT_MAX ? -1 : result);\\n        }           \\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nStore the min interval values of the given range in Segment tree.\\nGet the min value of the [Q,Q] range of Segment tree for queries[i] => Q\\nwhich gets updated only for the ranges => left <= Q <= right\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    // update min value of the intervals with lazy propagation\\n    void update(int * tree, int *lazy, int index, int low, int high, int minRange, int maxRange, int val)\\n    {\\n        int left = 2 * index + 1;\\n        int right = left + 1;\\n            \\n        // update lazy value to child and current node\\n        if(lazy[index]!=INT_MAX)\\n        {\\n            tree[index] = min(tree[index],lazy[index]);\\n            if(low!=high)\\n            {\\n                lazy[left] = min(lazy[left],lazy[index]);\\n                lazy[right] = min(lazy[right],lazy[index]);\\n            }\\n            lazy[index] = INT_MAX;\\n        }\\n\\n        // no overlap\\n        if(low > maxRange || high < minRange) return;\\n        \\n        // complete overlap\\n        if(low>=minRange && high<=maxRange)\\n        {\\n            tree[index] = min(tree[index],val);\\n            lazy[index] = min(lazy[index],val);\\n            \\n            if(low!=high)\\n            {\\n                lazy[left] = min(lazy[left],lazy[index]);\\n                lazy[right] = min(lazy[right],lazy[index]);\\n            }\\n\\n            return;\\n        }\\n\\n        // partial overlap\\n        \\n        int mid = low + (high-low)/2;\\n\\n        update(tree,lazy,left,low,mid,minRange,maxRange,val);\\n        update(tree,lazy,right,mid+1,high,minRange,maxRange,val);\\n    }\\n\\n    // query min value of the intervals with lazy propagation    \\n    int query(int * tree, int *lazy, int index, int low, int high, int range)\\n    {\\n        if(low > range || high < range) return INT_MAX;\\n\\n        int left = 2 * index + 1;\\n        int right = left + 1;\\n            \\n        if(lazy[index]!=INT_MAX)\\n        {\\n            tree[index] = min(tree[index],lazy[index]);\\n            if(low!=high)\\n            {\\n                lazy[left] = min(lazy[left],lazy[index]);\\n                lazy[right] = min(lazy[right],lazy[index]);\\n            }\\n            lazy[index] = INT_MAX;\\n        }\\n\\n        // get the range leaf value\\n        if(low==range && high==range) return tree[index];\\n\\n        int mid = low + (high-low)/2;\\n\\n        // only move to the side which contains range\\n        \\n        if(range <= mid) return query(tree,lazy,left,low,mid,range);\\n        else return query(tree,lazy,right,mid+1,high,range);\\n\\n    }\\n\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n\\n        // get max possible value in the interval and query\\n        int maxVal = INT_MIN;\\n        for(int i=0;i<intervals.size();i++)\\n            maxVal= max(maxVal,intervals[i][1]);\\n        \\n        for(int i=0;i<queries.size();i++)\\n           maxVal = max(maxVal,queries[i]);\\n        \\n        maxVal++;\\n        \\n        // make max range segment tree and lazy tree\\n        int *tree = new int[4*maxVal];\\n        int *lazy = new int[4*maxVal];\\n\\n        for(int i=0;i<4*maxVal;i++){\\n            tree[i] = INT_MAX;\\n            lazy[i] = INT_MAX;\\n        }\\n        \\n        // update the min interval value for all intervals\\n        for(int i=0;i<intervals.size();i++)\\n            update(tree,lazy,0,0,maxVal-1,intervals[i][0],intervals[i][1],intervals[i][1]-intervals[i][0]+1);\\n\\n        vector<int>res;\\n        int result;\\n        \\n        // get query min interval value\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            result = query(tree,lazy,0,0,maxVal-1,queries[i]);\\n            res.push_back(result==INT_MAX ? -1 : result);\\n        }           \\n\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    // update min value of the intervals\\n    void update(int * tree, int minRange, int maxRange, int val)\\n    {\\n        int left = minRange + N;\\n        int right = maxRange + N;\\n        \\n        while(left <= right)\\n        {\\n            if(left&1)\\n            {\\n                tree[left] = min(tree[left],val);\\n                left++;\\n            }\\n            \\n            if(!(right&1))\\n            {\\n                tree[right] = min(tree[right],val);\\n                right--;\\n            }\\n            \\n            left = left >> 1;\\n            right = right >> 1;\\n        }\\n    }\\n\\n    // query min value of the intervals \\n    int query(int * tree, int range)\\n    {\\n        int index = range + N;\\n        int res = tree[index];\\n        \\n        while(index > 1)\\n        {\\n            index = index >> 1;\\n            res = min(res,tree[index]);\\n        }\\n        \\n        return res;\\n    }\\n\\n    int N;\\n    \\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n\\n        // get max possible value in the interval and query\\n        int maxVal = INT_MIN;\\n        for(int i=0;i<intervals.size();i++)\\n            maxVal= max(maxVal,intervals[i][1]);\\n        \\n        for(int i=0;i<queries.size();i++)\\n           maxVal = max(maxVal,queries[i]);\\n        \\n        N = maxVal;\\n        maxVal++;\\n        \\n        // make max range segment tree\\n        int *tree = new int[2*maxVal];\\n\\n        for(int i=0;i<2*maxVal;i++)\\n            tree[i] = INT_MAX;\\n        \\n        // update the min interval value for all intervals\\n        for(int i=0;i<intervals.size();i++)\\n            update(tree,intervals[i][0],intervals[i][1],intervals[i][1]-intervals[i][0]+1);\\n\\n        vector<int>res;\\n        int result;\\n        \\n        // get query min interval value\\n        for(int i=0;i<queries.size();i++)\\n        {\\n            result = query(tree,queries[i]);\\n            res.push_back(result==INT_MAX ? -1 : result);\\n        }           \\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1779557,
                "title": "python-two-pointer-and-min-heap-over-sorted-arrays-o-nlogn",
                "content": "```python\\ndef minInterval(self, intervals, queries):\\n    j, m, n = 0, len(intervals), len(queries)\\n    iv, ix = sorted(intervals), sorted(range(n), key=queries.__getitem__)\\n    res, q = [-1] * n, []\\n    for i in ix:\\n        while j < m and iv[j][0] <= queries[i]:\\n            heapq.heappush(q, (iv[j][1] - iv[j][0] + 1, iv[j][1]))\\n            j += 1\\n        while q and queries[i] > q[0][1]:\\n            heapq.heappop(q)\\n        if q:\\n            res[i] = q[0][0]\\n    return res\\n```",
                "solutionTags": [],
                "code": "```python\\ndef minInterval(self, intervals, queries):\\n    j, m, n = 0, len(intervals), len(queries)\\n    iv, ix = sorted(intervals), sorted(range(n), key=queries.__getitem__)\\n    res, q = [-1] * n, []\\n    for i in ix:\\n        while j < m and iv[j][0] <= queries[i]:\\n            heapq.heappush(q, (iv[j][1] - iv[j][0] + 1, iv[j][1]))\\n            j += 1\\n        while q and queries[i] > q[0][1]:\\n            heapq.heappop(q)\\n        if q:\\n            res[i] = q[0][0]\\n    return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1516823,
                "title": "javascript-solution",
                "content": "```\\nvar minInterval = function (intervals, queries) {\\n  var minInterval = function (intervals, queries) {\\n    intervals.sort((a, b) =>  a[0] - b[0]);\\n    let originalQuery = [...queries];\\n    queries.sort((a, b) => a - b);\\n    let resultMap = {};\\n\\n    let idx = 0;\\n    let currentQuery = queries[0];\\n    let minHeap = new MinHeap((x) => x?.[0]);\\n    let i = 0;\\n    while (i < intervals.length) {\\n        if (currentQuery < intervals[i][0]) {\\n            findMin();\\n            continue;\\n        }\\n\\n        minHeap.add([intervals[i][1] - intervals[i][0] + 1, intervals[i][1]]);\\n        i++;\\n    }\\n\\n    while (idx < queries.length) {\\n       findMin();\\n    }\\n\\n    return originalQuery.map(query => resultMap[query]);\\n    \\n    function findMin() {\\n        while (minHeap.peek()?.[1] < currentQuery) {\\n            minHeap.poll();\\n        }\\n\\n        resultMap[currentQuery] = minHeap.peek()?.[0] ?? -1;\\n        idx++;\\n        currentQuery = queries[idx];\\n    }\\n\\n};\\n\\n\\n\\n\\nclass MinHeap {\\n\\n    constructor(fn) {\\n        this.list = [];\\n        this.fn = fn ?? ((x) => x);\\n    }\\n\\n    add(val) {\\n        this.list.push(val);\\n        let cur = this.list.length - 1;\\n        let parent = Math.floor((cur - 1) / 2);\\n        // bubble up\\n        while (this.fn(this.list[cur]) < this.fn(this.list[parent])) {\\n            this.swap(cur, parent);\\n            cur = parent;\\n            parent = Math.floor((cur - 1) / 2);\\n        }\\n    }\\n\\n    poll() {\\n        let res = this.list[0];\\n        this.swap(0, this.list.length - 1);\\n        this.list.pop();\\n        // bubble down\\n        let cur = 0;\\n        let left = cur * 2 + 1;\\n        let right = cur * 2 + 2;\\n        while (this.fn(this.list[left]) !== undefined || this.fn(this.list[right]) !== undefined) {\\n            if (this.fn(this.list[cur]) < (this.fn(this.list[left]) ?? Infinity) && this.fn(this.list[cur]) < (this.fn(this.list[right]) ?? Infinity)) {\\n                break;\\n            }\\n\\n            const smallerIndex = this.fn(this.list[left]) > this.fn(this.list[right]) ? right : left;\\n            this.swap(cur, smallerIndex);\\n            cur = smallerIndex;\\n            left = cur * 2 + 1;\\n            right = cur * 2 + 2;\\n        }\\n\\n        return res;\\n    }\\n\\n    peek() {\\n        return this.list[0];\\n    }\\n\\n    swap(a, b) {\\n        [this.list[a], this.list[b]] = [this.list[b], this.list[a]];\\n    }\\n}\\n    let originalQuery = [...queries];\\n    queries.sort((a, b) => a - b);\\n    let resultMap = {};\\n\\n    let idx = 0;\\n    let currentQuery = queries[0];\\n    let minHeap = new MinHeap((x) => x?.[0]);\\n    let i = 0;\\n    while (i < intervals.length) {\\n        if (currentQuery < intervals[i][0]) {\\n            findMin();\\n            continue;\\n        }\\n\\n        minHeap.add([intervals[i][1] - intervals[i][0] + 1, intervals[i][1]]);\\n        i++;\\n    }\\n\\n    while (idx < queries.length) {\\n       findMin();\\n    }\\n\\n    return originalQuery.map(query => resultMap[query]);\\n    \\n    function findMin() {\\n        while (minHeap.peek()?.[1] < currentQuery) {\\n            minHeap.poll();\\n        }\\n\\n        resultMap[currentQuery] = minHeap.peek()?.[0] ?? -1;\\n        idx++;\\n        currentQuery = queries[idx];\\n    }\\n\\n};\\n\\n\\n\\n\\nclass MinHeap {\\n\\n    constructor(fn) {\\n        this.list = [];\\n        this.fn = fn ?? ((x) => x);\\n    }\\n\\n    add(val) {\\n        this.list.push(val);\\n        let cur = this.list.length - 1;\\n        let parent = Math.floor((cur - 1) / 2);\\n        // bubble up\\n        while (this.fn(this.list[cur]) < this.fn(this.list[parent])) {\\n            this.swap(cur, parent);\\n            cur = parent;\\n            parent = Math.floor((cur - 1) / 2);\\n        }\\n    }\\n\\n    poll() {\\n        let res = this.list[0];\\n        this.swap(0, this.list.length - 1);\\n        this.list.pop();\\n        // bubble down\\n        let cur = 0;\\n        let left = cur * 2 + 1;\\n        let right = cur * 2 + 2;\\n        while (this.fn(this.list[left]) !== undefined || this.fn(this.list[right]) !== undefined) {\\n            if (this.fn(this.list[cur]) < (this.fn(this.list[left]) ?? Infinity) && this.fn(this.list[cur]) < (this.fn(this.list[right]) ?? Infinity)) {\\n                break;\\n            }\\n\\n            const smallerIndex = this.fn(this.list[left]) > this.fn(this.list[right]) ? right : left;\\n            this.swap(cur, smallerIndex);\\n            cur = smallerIndex;\\n            left = cur * 2 + 1;\\n            right = cur * 2 + 2;\\n        }\\n\\n        return res;\\n    }\\n\\n    peek() {\\n        return this.list[0];\\n    }\\n\\n    swap(a, b) {\\n        [this.list[a], this.list[b]] = [this.list[b], this.list[a]];\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minInterval = function (intervals, queries) {\\n  var minInterval = function (intervals, queries) {\\n    intervals.sort((a, b) =>  a[0] - b[0]);\\n    let originalQuery = [...queries];\\n    queries.sort((a, b) => a - b);\\n    let resultMap = {};\\n\\n    let idx = 0;\\n    let currentQuery = queries[0];\\n    let minHeap = new MinHeap((x) => x?.[0]);\\n    let i = 0;\\n    while (i < intervals.length) {\\n        if (currentQuery < intervals[i][0]) {\\n            findMin();\\n            continue;\\n        }\\n\\n        minHeap.add([intervals[i][1] - intervals[i][0] + 1, intervals[i][1]]);\\n        i++;\\n    }\\n\\n    while (idx < queries.length) {\\n       findMin();\\n    }\\n\\n    return originalQuery.map(query => resultMap[query]);\\n    \\n    function findMin() {\\n        while (minHeap.peek()?.[1] < currentQuery) {\\n            minHeap.poll();\\n        }\\n\\n        resultMap[currentQuery] = minHeap.peek()?.[0] ?? -1;\\n        idx++;\\n        currentQuery = queries[idx];\\n    }\\n\\n};\\n\\n\\n\\n\\nclass MinHeap {\\n\\n    constructor(fn) {\\n        this.list = [];\\n        this.fn = fn ?? ((x) => x);\\n    }\\n\\n    add(val) {\\n        this.list.push(val);\\n        let cur = this.list.length - 1;\\n        let parent = Math.floor((cur - 1) / 2);\\n        // bubble up\\n        while (this.fn(this.list[cur]) < this.fn(this.list[parent])) {\\n            this.swap(cur, parent);\\n            cur = parent;\\n            parent = Math.floor((cur - 1) / 2);\\n        }\\n    }\\n\\n    poll() {\\n        let res = this.list[0];\\n        this.swap(0, this.list.length - 1);\\n        this.list.pop();\\n        // bubble down\\n        let cur = 0;\\n        let left = cur * 2 + 1;\\n        let right = cur * 2 + 2;\\n        while (this.fn(this.list[left]) !== undefined || this.fn(this.list[right]) !== undefined) {\\n            if (this.fn(this.list[cur]) < (this.fn(this.list[left]) ?? Infinity) && this.fn(this.list[cur]) < (this.fn(this.list[right]) ?? Infinity)) {\\n                break;\\n            }\\n\\n            const smallerIndex = this.fn(this.list[left]) > this.fn(this.list[right]) ? right : left;\\n            this.swap(cur, smallerIndex);\\n            cur = smallerIndex;\\n            left = cur * 2 + 1;\\n            right = cur * 2 + 2;\\n        }\\n\\n        return res;\\n    }\\n\\n    peek() {\\n        return this.list[0];\\n    }\\n\\n    swap(a, b) {\\n        [this.list[a], this.list[b]] = [this.list[b], this.list[a]];\\n    }\\n}\\n    let originalQuery = [...queries];\\n    queries.sort((a, b) => a - b);\\n    let resultMap = {};\\n\\n    let idx = 0;\\n    let currentQuery = queries[0];\\n    let minHeap = new MinHeap((x) => x?.[0]);\\n    let i = 0;\\n    while (i < intervals.length) {\\n        if (currentQuery < intervals[i][0]) {\\n            findMin();\\n            continue;\\n        }\\n\\n        minHeap.add([intervals[i][1] - intervals[i][0] + 1, intervals[i][1]]);\\n        i++;\\n    }\\n\\n    while (idx < queries.length) {\\n       findMin();\\n    }\\n\\n    return originalQuery.map(query => resultMap[query]);\\n    \\n    function findMin() {\\n        while (minHeap.peek()?.[1] < currentQuery) {\\n            minHeap.poll();\\n        }\\n\\n        resultMap[currentQuery] = minHeap.peek()?.[0] ?? -1;\\n        idx++;\\n        currentQuery = queries[idx];\\n    }\\n\\n};\\n\\n\\n\\n\\nclass MinHeap {\\n\\n    constructor(fn) {\\n        this.list = [];\\n        this.fn = fn ?? ((x) => x);\\n    }\\n\\n    add(val) {\\n        this.list.push(val);\\n        let cur = this.list.length - 1;\\n        let parent = Math.floor((cur - 1) / 2);\\n        // bubble up\\n        while (this.fn(this.list[cur]) < this.fn(this.list[parent])) {\\n            this.swap(cur, parent);\\n            cur = parent;\\n            parent = Math.floor((cur - 1) / 2);\\n        }\\n    }\\n\\n    poll() {\\n        let res = this.list[0];\\n        this.swap(0, this.list.length - 1);\\n        this.list.pop();\\n        // bubble down\\n        let cur = 0;\\n        let left = cur * 2 + 1;\\n        let right = cur * 2 + 2;\\n        while (this.fn(this.list[left]) !== undefined || this.fn(this.list[right]) !== undefined) {\\n            if (this.fn(this.list[cur]) < (this.fn(this.list[left]) ?? Infinity) && this.fn(this.list[cur]) < (this.fn(this.list[right]) ?? Infinity)) {\\n                break;\\n            }\\n\\n            const smallerIndex = this.fn(this.list[left]) > this.fn(this.list[right]) ? right : left;\\n            this.swap(cur, smallerIndex);\\n            cur = smallerIndex;\\n            left = cur * 2 + 1;\\n            right = cur * 2 + 2;\\n        }\\n\\n        return res;\\n    }\\n\\n    peek() {\\n        return this.list[0];\\n    }\\n\\n    swap(a, b) {\\n        [this.list[a], this.list[b]] = [this.list[b], this.list[a]];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1257027,
                "title": "c-sort-pq",
                "content": "```\\nclass Solution {\\npublic:\\n    #define p pair<int,int>\\n    vector<int> minInterval(vector<vector<int>>&s, vector<int>& que) \\n    {\\n        int i=0;\\n        vector<vector<int>>queries;\\n        for(i=0;i<que.size();i++)\\n            queries.push_back({que[i],i});\\n        vector<int>res(i,-1);\\n        sort(s.begin(),s.end());\\n        sort(queries.begin(),queries.end());\\n        priority_queue<p,vector<p>,greater<p>>pq;\\n        i=0;\\n        for(auto &q:queries)\\n        {\\n            while(i<s.size() && s[i][0]<=q[0])\\n            {\\n                pq.push({s[i][1]-s[i][0]+1,s[i][1]});\\n                i++;\\n            }\\n            while(!pq.empty() && pq.top().second<q[0])\\n                pq.pop();\\n            if(!pq.empty())\\n                res[q[1]]=pq.top().first;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define p pair<int,int>\\n    vector<int> minInterval(vector<vector<int>>&s, vector<int>& que) \\n    {\\n        int i=0;\\n        vector<vector<int>>queries;\\n        for(i=0;i<que.size();i++)\\n            queries.push_back({que[i],i});\\n        vector<int>res(i,-1);\\n        sort(s.begin(),s.end());\\n        sort(queries.begin(),queries.end());\\n        priority_queue<p,vector<p>,greater<p>>pq;\\n        i=0;\\n        for(auto &q:queries)\\n        {\\n            while(i<s.size() && s[i][0]<=q[0])\\n            {\\n                pq.push({s[i][1]-s[i][0]+1,s[i][1]});\\n                i++;\\n            }\\n            while(!pq.empty() && pq.top().second<q[0])\\n                pq.pop();\\n            if(!pq.empty())\\n                res[q[1]]=pq.top().first;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1220060,
                "title": "javascript-segment-tree-dsu-solutions",
                "content": "Let us first start with the naive way. We want to use some sort of a Data Structure that supports segment queries [a,b] , so our Intervals are satisfied. Moreover, we want on each point inside that interval to have the minimum range of all the queries that contain said point. For this reason we can use a Segment Tree.\\nThe segment tree will contain 1e7+1 elements, (the maximum possible value we may get) and then we ll just Query each point seperately to form our final result.\\nThe code would look something like this\\n\\n```\\n\\tS=new SegmentTree(0,1e7+1) //create the segment tree with the appropriate range\\n\\tfor(let [a,b] of Intervals)\\n\\t//set each point in [a,b] to have the minimum b-a+1 of the queries that contain it\\n\\t\\tS.rangeSet(a,b, b-a+1) \\n\\treturn Q.map( value=> S.pointQuery(value) ) //just query each point for the final result\\n```\\n\\nUnfortunately the values inside my Queries can go up to 1e7+1, which is huge, and this will give us a Memory Limit Exceeded error. We can, however, remedy that without storing all of the potential values inside the segment tree. Instead, we can use a segment tree that stores Q.length elements, or rather 1 for each element of Q. The thing is that rangeSetting now becomes tricky, as we ll need to find which elements lie inside [a,b] so we can update them correctly. However, we need to keep in mind that we re dealing with a Sorted version of Q because everything inside the Segment Tree is always sorted. Therefore a simple binary search would yield us with the actual indices that need to be updated inside the Segment Tree. \\nMore specifically we will be looking for the Smallest index of Q that\\'s bigger than or equal to a. In the same manner we will be looking for the BIGGEST index of Q that\\'s smaller than or equal to b. Then we will have to rangeSet these indices instead, as these correspond to the interval we re currently examining. The code would then look something like this:\\n\\n```\\n\\tS=new SegmentTree(0,Q.length+1)\\n\\tfor(let [a,b] of Intervals)\\n\\t\\tS.rangeSet( binarySearchSmall(Q , a), binarySearchBig( Q,b) , b-a+1)\\n\\treturn Q.map( value=> S.pointQuery ( SORTED_INDEX_OF(value) ) )  \\n\\t//remember that after sorting, each  value inside Q has a new index, \\n\\t//which we will be using to access that element inside the Segment Tree.\\n```\\n\\nI will now provide the full code of the segment Tree approach. The implementation is simply a Segment Tree that supports range updates and and PointQueries whose details can be easily found online. \\n\\n```\\n\\nlet bisect_left=(A,element)=>{\\n    let lo=0,hi=A.length-1,res=Infinity\\n    while(lo<=hi){\\n        let mid=lo+hi>>1\\n        if(A[mid][0]<element)\\n            lo=mid+1\\n        else\\n            res=Math.min(res,mid),\\n            hi=mid-1\\n    }\\n    return res\\n}\\nlet bisect_right=(A,element)=>{\\n    let lo=0,hi=A.length-1,res=-Infinity\\n    while(lo<=hi){\\n        let mid=lo+hi>>1\\n        if(A[mid][0]>element)\\n            hi=mid-1\\n        else\\n            res=Math.max(res,mid),\\n            lo=mid+1\\n    }\\n    return res\\n}\\nclass ISTNode{\\n    constructor(l,r){\\n        this.l=l,this.r=r\\n        this.leftChild=this.rightChild=null\\n        this.val=Infinity\\n    }\\n    extend(){\\n        if((!this.leftChild )&& (this.l!==this.r)){\\n            let mid=this.l+this.r>>1\\n            this.leftChild=new ISTNode(this.l,mid)\\n            this.rightChild=new ISTNode(mid+1,this.r)\\n        }\\n    }\\n    rangeUpdate(L,R,val){\\n        if(L<=this.l&& this.r<=R){\\n            this.val=Math.min(this.val,val)\\n            return\\n        }\\n        if(L>this.r||this.l>R)\\n            return\\n        this.extend()\\n        this.leftChild.rangeUpdate(L,R,val)\\n        this.rightChild.rangeUpdate(L,R,val)\\n    }\\n    pointQuery(x,minsofar=Infinity){\\n        if(!this.leftChild)\\n            return Math.min(minsofar,this.val)\\n        if(this.leftChild.r>=x)\\n            return this.leftChild.pointQuery(x,Math.min(minsofar,this.val))\\n        else\\n            return this.rightChild.pointQuery(x,Math.min(minsofar,this.val))\\n    }\\n}\\n\\nvar minInterval = function(I, Q) {\\n    let n=Q.length,S=new ISTNode(0,n+1), Queries=[...Q]\\n    Queries=Queries.map((d,i)=>[d,i]).sort((a,b)=>a[0]-b[0])\\n    for(let [a,b] of I)\\n        S.rangeUpdate(bisect_left(Queries,a),bisect_right(Queries,b),b-a+1)\\n    for(let i in Queries){\\n        let [val,originalIdx]=Queries[i]\\n        Q[originalIdx]=S.pointQuery(i)\\n        if(Q[originalIdx]===Infinity)\\n            Q[originalIdx]=-1\\n    }\\n    return Q\\n};\\n```\\nTime Complexity is O( (n+Q) logQ ) and Space Complexity is O(4\\\\*Q)\\n\\nA more elegant approach is a Union Find Data structure as proposed in the top posts. The whole idea is that, for each element we have 2 properties. The first is its final result, meaning the length of the smallest interval that contains it. We will call this feature the element\\'s color. The second, is a pointer to the first element on its right side that is not yet painted. One needs to notice that an element can only be painted once, so the first time it is painted has to be the minimum range interval that contains it. After an element is painted, its parent is updated as the first element on its right side that is unpainted, and we achieve is through the \"find\" operation of a DSU. So then the battle plan becomes:\\n* Sort the Intervals in ascending Range, so that the first time a range is set, it has to be the smallest one\\n* Update each range accordingly\\n* Build the result\\n\\nSo the code would look something like :\\n```\\n let colors=[...Array(1e7+1)],\\n\\t parent=[...Array(1e7+1)].map((d,i)=>i) //set each parent as the element itself,\\n\\t find=(x)=>x===parent[x]?x: parent[x]=find(parent[x]) //the DSU find operation + path compression\\n Intervals.sort((a,b)=> a[1]-a[0] - ( b[1] -b[0]) ) \\n for(let [a,b] of Intervals){\\n\\t let start=find(a)\\n\\t while(start<=b)\\n\\t\\t colors[start]=b-a+1,\\n\\t\\t parent[start]=start+1,\\n\\t\\t start=find(start)\\n }\\nreturn Q.map((d,i)=>colors[d]) \\n```\\n\\nHowever we seem to be having the exact same problem as before. Due to the huge size of our initial array we get MLE. Now though, we know how to combat this by using a \"proxy\" DSU only for the element of Q that we aready have. The logic is exactly the same with the Segment Tree approach and the 2 binary searches.\\nHere follows the code that gets a clean AC.\\n\\n```\\nlet bisect_left=(A,element)=>{\\n    let lo=0,hi=A.length-1,res=Infinity\\n    while(lo<=hi){\\n        let mid=lo+hi>>1\\n        if(A[mid][0]<element)\\n            lo=mid+1\\n        else\\n            res=Math.min(res,mid),\\n            hi=mid-1\\n    }\\n    return res\\n}\\nlet bisect_right=(A,element)=>{\\n    let lo=0,hi=A.length-1,res=-Infinity\\n    while(lo<=hi){\\n        let mid=lo+hi>>1\\n        if(A[mid][0]>element)\\n            hi=mid-1\\n        else\\n            res=Math.max(res,mid),\\n            lo=mid+1\\n    }\\n    return res\\n}\\nvar minInterval = function(I, Q) {\\n    I.sort((a,b)=>a[1]-a[0]-b[1]+b[0])\\n    let Queries=[...Q]\\n    Queries=Queries.map((d,i)=>[d,i]).sort((a,b)=>a[0]-b[0])\\n    let n=Q.length,ans=[...Array(n)].map(d=>-1),par=[...Array(n)].map((d,i)=>i)\\n    let find=x=>par[x]!==x?par[x]=find(par[x]):par[x]\\n    for(let [a,b] of I){\\n        let [l,r]=[bisect_left(Queries,a),bisect_right(Queries,b)] //indices\\n        let v=find(l)\\n        while(v<=r)\\n            ans[v]=b-a+1,\\n            par[v]=v+1,\\n            v=find(v)\\n    }\\n    for(let i in Queries){\\n        let [val,originalIdx]=Queries[i]\\n        Q[originalIdx]=ans[i]\\n    }\\n    return Q\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Tree",
                    "Union Find"
                ],
                "code": "```\\n\\tS=new SegmentTree(0,1e7+1) //create the segment tree with the appropriate range\\n\\tfor(let [a,b] of Intervals)\\n\\t//set each point in [a,b] to have the minimum b-a+1 of the queries that contain it\\n\\t\\tS.rangeSet(a,b, b-a+1) \\n\\treturn Q.map( value=> S.pointQuery(value) ) //just query each point for the final result\\n```\n```\\n\\tS=new SegmentTree(0,Q.length+1)\\n\\tfor(let [a,b] of Intervals)\\n\\t\\tS.rangeSet( binarySearchSmall(Q , a), binarySearchBig( Q,b) , b-a+1)\\n\\treturn Q.map( value=> S.pointQuery ( SORTED_INDEX_OF(value) ) )  \\n\\t//remember that after sorting, each  value inside Q has a new index, \\n\\t//which we will be using to access that element inside the Segment Tree.\\n```\n```\\n\\nlet bisect_left=(A,element)=>{\\n    let lo=0,hi=A.length-1,res=Infinity\\n    while(lo<=hi){\\n        let mid=lo+hi>>1\\n        if(A[mid][0]<element)\\n            lo=mid+1\\n        else\\n            res=Math.min(res,mid),\\n            hi=mid-1\\n    }\\n    return res\\n}\\nlet bisect_right=(A,element)=>{\\n    let lo=0,hi=A.length-1,res=-Infinity\\n    while(lo<=hi){\\n        let mid=lo+hi>>1\\n        if(A[mid][0]>element)\\n            hi=mid-1\\n        else\\n            res=Math.max(res,mid),\\n            lo=mid+1\\n    }\\n    return res\\n}\\nclass ISTNode{\\n    constructor(l,r){\\n        this.l=l,this.r=r\\n        this.leftChild=this.rightChild=null\\n        this.val=Infinity\\n    }\\n    extend(){\\n        if((!this.leftChild )&& (this.l!==this.r)){\\n            let mid=this.l+this.r>>1\\n            this.leftChild=new ISTNode(this.l,mid)\\n            this.rightChild=new ISTNode(mid+1,this.r)\\n        }\\n    }\\n    rangeUpdate(L,R,val){\\n        if(L<=this.l&& this.r<=R){\\n            this.val=Math.min(this.val,val)\\n            return\\n        }\\n        if(L>this.r||this.l>R)\\n            return\\n        this.extend()\\n        this.leftChild.rangeUpdate(L,R,val)\\n        this.rightChild.rangeUpdate(L,R,val)\\n    }\\n    pointQuery(x,minsofar=Infinity){\\n        if(!this.leftChild)\\n            return Math.min(minsofar,this.val)\\n        if(this.leftChild.r>=x)\\n            return this.leftChild.pointQuery(x,Math.min(minsofar,this.val))\\n        else\\n            return this.rightChild.pointQuery(x,Math.min(minsofar,this.val))\\n    }\\n}\\n\\nvar minInterval = function(I, Q) {\\n    let n=Q.length,S=new ISTNode(0,n+1), Queries=[...Q]\\n    Queries=Queries.map((d,i)=>[d,i]).sort((a,b)=>a[0]-b[0])\\n    for(let [a,b] of I)\\n        S.rangeUpdate(bisect_left(Queries,a),bisect_right(Queries,b),b-a+1)\\n    for(let i in Queries){\\n        let [val,originalIdx]=Queries[i]\\n        Q[originalIdx]=S.pointQuery(i)\\n        if(Q[originalIdx]===Infinity)\\n            Q[originalIdx]=-1\\n    }\\n    return Q\\n};\\n```\n```\\n let colors=[...Array(1e7+1)],\\n\\t parent=[...Array(1e7+1)].map((d,i)=>i) //set each parent as the element itself,\\n\\t find=(x)=>x===parent[x]?x: parent[x]=find(parent[x]) //the DSU find operation + path compression\\n Intervals.sort((a,b)=> a[1]-a[0] - ( b[1] -b[0]) ) \\n for(let [a,b] of Intervals){\\n\\t let start=find(a)\\n\\t while(start<=b)\\n\\t\\t colors[start]=b-a+1,\\n\\t\\t parent[start]=start+1,\\n\\t\\t start=find(start)\\n }\\nreturn Q.map((d,i)=>colors[d]) \\n```\n```\\nlet bisect_left=(A,element)=>{\\n    let lo=0,hi=A.length-1,res=Infinity\\n    while(lo<=hi){\\n        let mid=lo+hi>>1\\n        if(A[mid][0]<element)\\n            lo=mid+1\\n        else\\n            res=Math.min(res,mid),\\n            hi=mid-1\\n    }\\n    return res\\n}\\nlet bisect_right=(A,element)=>{\\n    let lo=0,hi=A.length-1,res=-Infinity\\n    while(lo<=hi){\\n        let mid=lo+hi>>1\\n        if(A[mid][0]>element)\\n            hi=mid-1\\n        else\\n            res=Math.max(res,mid),\\n            lo=mid+1\\n    }\\n    return res\\n}\\nvar minInterval = function(I, Q) {\\n    I.sort((a,b)=>a[1]-a[0]-b[1]+b[0])\\n    let Queries=[...Q]\\n    Queries=Queries.map((d,i)=>[d,i]).sort((a,b)=>a[0]-b[0])\\n    let n=Q.length,ans=[...Array(n)].map(d=>-1),par=[...Array(n)].map((d,i)=>i)\\n    let find=x=>par[x]!==x?par[x]=find(par[x]):par[x]\\n    for(let [a,b] of I){\\n        let [l,r]=[bisect_left(Queries,a),bisect_right(Queries,b)] //indices\\n        let v=find(l)\\n        while(v<=r)\\n            ans[v]=b-a+1,\\n            par[v]=v+1,\\n            v=find(v)\\n    }\\n    for(let i in Queries){\\n        let [val,originalIdx]=Queries[i]\\n        Q[originalIdx]=ans[i]\\n    }\\n    return Q\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1212992,
                "title": "c-iterate-over-intervals-explained",
                "content": "Sort the intervals according to the size of intervals.\\nThen iterate over the sorted intervals. For each interval, find the queries that lies inside the interval.\\nWe need to prune the queries that already matched to a interval.\\n```\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        auto comp = [](vector<int>& a, vector<int>& b) {\\n            return a[1] - a[0] < b[1] - b[0];\\n        };\\n        sort(intervals.begin(), intervals.end(), comp);\\n        \\n        unordered_map<int, vector<int>> mp;\\n        set<int> s;\\n        int n = queries.size();\\n        for(int i=0; i<n; ++i) {\\n            mp[queries[i]].push_back(i);\\n            s.insert(queries[i]);\\n        }\\n        \\n        vector<int> ans(n, -1);\\n        \\n        for(auto v : intervals) {\\n            int l = v[0], r = v[1];\\n            vector<int> rem;\\n\\t\\t\\t\\n\\t\\t\\t// For the interval, find the queries that is covered by it.\\n            auto it1 = s.lower_bound(l);\\n            auto it2 = s.upper_bound(r);\\n            for(auto it = it1; it != it2; ++it) {\\n                int q = *it;\\n                rem.push_back(q); // The queries needs to be removed from the set of queries. \\n                for(auto idx : mp[q]) {\\n                    ans[idx] = r - l + 1;\\n                }\\n            }\\n            for(auto& r : rem) {\\n                s.erase(r);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        auto comp = [](vector<int>& a, vector<int>& b) {\\n            return a[1] - a[0] < b[1] - b[0];\\n        };\\n        sort(intervals.begin(), intervals.end(), comp);\\n        \\n        unordered_map<int, vector<int>> mp;\\n        set<int> s;\\n        int n = queries.size();\\n        for(int i=0; i<n; ++i) {\\n            mp[queries[i]].push_back(i);\\n            s.insert(queries[i]);\\n        }\\n        \\n        vector<int> ans(n, -1);\\n        \\n        for(auto v : intervals) {\\n            int l = v[0], r = v[1];\\n            vector<int> rem;\\n\\t\\t\\t\\n\\t\\t\\t// For the interval, find the queries that is covered by it.\\n            auto it1 = s.lower_bound(l);\\n            auto it2 = s.upper_bound(r);\\n            for(auto it = it1; it != it2; ++it) {\\n                int q = *it;\\n                rem.push_back(q); // The queries needs to be removed from the set of queries. \\n                for(auto idx : mp[q]) {\\n                    ans[idx] = r - l + 1;\\n                }\\n            }\\n            for(auto& r : rem) {\\n                s.erase(r);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1199959,
                "title": "golang-heap",
                "content": "```\\ntype Interval struct {\\n\\tleft  int\\n\\tright int\\n\\tsize  int\\n}\\n\\nfunc (self *Interval) GetSize() int {\\n\\treturn self.right - self.left + 1\\n}\\n\\nfunc NewInterval(a []int) Interval {\\n\\treturn Interval{\\n\\t\\tleft:  a[0],\\n\\t\\tright: a[1],\\n\\t\\tsize:  a[1] - a[0] + 1,\\n\\t}\\n\\n}\\n\\ntype IntervalHeap []Interval\\n\\nfunc (self IntervalHeap) Len() int {\\n\\treturn len(self)\\n}\\n\\nfunc (self IntervalHeap) Less(a, b int) bool {\\n\\treturn self[a].size < self[b].size\\n}\\nfunc (self IntervalHeap) Swap(a, b int) {\\n\\tself[a], self[b] = self[b], self[a]\\n}\\nfunc (h *IntervalHeap) Push(x interface{}) {\\n\\t*h = append(*h, x.(Interval))\\n}\\n\\nfunc (h *IntervalHeap) Pop() interface{} {\\n\\told := *h\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*h = old[0 : n-1]\\n\\treturn x\\n}\\n\\nfunc minInterval(intervals [][]int, queries []int) []int {\\n\\tsort.Slice(intervals, func(i, j int) bool {\\n\\t\\treturn intervals[i][0] < intervals[j][0]\\n\\t})\\n\\tqueries2 := make([]int, len(queries))\\n\\tcopy(queries2, queries)\\n\\tsort.Ints(queries2)\\n\\tans := make(map[int]int)\\n\\n\\th := &IntervalHeap{}\\n\\n\\theap.Init(h)\\n\\tidx := 0 //intervals index\\n\\tfor _, query := range queries2 {\\n\\t\\tfor ; idx < len(intervals) && intervals[idx][0] <= query; idx++ {\\n\\t\\t\\theap.Push(h, NewInterval(intervals[idx]))\\n\\t\\t}\\n\\n\\t\\tfor h.Len() > 0 && (*h)[0].right < query {\\n\\t\\t\\theap.Pop(h)\\n\\t\\t}\\n\\t\\tif h.Len() == 0 {\\n\\t\\t\\tans[query] = -1\\n\\t\\t}\\n\\t\\tif h.Len() > 0 {\\n\\t\\t\\tans[query] = (*h)[0].size\\n\\t\\t}\\n\\n\\t}\\n\\tret := make([]int, len(queries))\\n\\n\\tfor i, n := range queries {\\n\\t\\tret[i] = -1\\n\\t\\tif a, ok := ans[n]; ok {\\n\\t\\t\\tret[i] = a\\n\\t\\t}\\n\\n\\t}\\n\\treturn ret\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype Interval struct {\\n\\tleft  int\\n\\tright int\\n\\tsize  int\\n}\\n\\nfunc (self *Interval) GetSize() int {\\n\\treturn self.right - self.left + 1\\n}\\n\\nfunc NewInterval(a []int) Interval {\\n\\treturn Interval{\\n\\t\\tleft:  a[0],\\n\\t\\tright: a[1],\\n\\t\\tsize:  a[1] - a[0] + 1,\\n\\t}\\n\\n}\\n\\ntype IntervalHeap []Interval\\n\\nfunc (self IntervalHeap) Len() int {\\n\\treturn len(self)\\n}\\n\\nfunc (self IntervalHeap) Less(a, b int) bool {\\n\\treturn self[a].size < self[b].size\\n}\\nfunc (self IntervalHeap) Swap(a, b int) {\\n\\tself[a], self[b] = self[b], self[a]\\n}\\nfunc (h *IntervalHeap) Push(x interface{}) {\\n\\t*h = append(*h, x.(Interval))\\n}\\n\\nfunc (h *IntervalHeap) Pop() interface{} {\\n\\told := *h\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*h = old[0 : n-1]\\n\\treturn x\\n}\\n\\nfunc minInterval(intervals [][]int, queries []int) []int {\\n\\tsort.Slice(intervals, func(i, j int) bool {\\n\\t\\treturn intervals[i][0] < intervals[j][0]\\n\\t})\\n\\tqueries2 := make([]int, len(queries))\\n\\tcopy(queries2, queries)\\n\\tsort.Ints(queries2)\\n\\tans := make(map[int]int)\\n\\n\\th := &IntervalHeap{}\\n\\n\\theap.Init(h)\\n\\tidx := 0 //intervals index\\n\\tfor _, query := range queries2 {\\n\\t\\tfor ; idx < len(intervals) && intervals[idx][0] <= query; idx++ {\\n\\t\\t\\theap.Push(h, NewInterval(intervals[idx]))\\n\\t\\t}\\n\\n\\t\\tfor h.Len() > 0 && (*h)[0].right < query {\\n\\t\\t\\theap.Pop(h)\\n\\t\\t}\\n\\t\\tif h.Len() == 0 {\\n\\t\\t\\tans[query] = -1\\n\\t\\t}\\n\\t\\tif h.Len() > 0 {\\n\\t\\t\\tans[query] = (*h)[0].size\\n\\t\\t}\\n\\n\\t}\\n\\tret := make([]int, len(queries))\\n\\n\\tfor i, n := range queries {\\n\\t\\tret[i] = -1\\n\\t\\tif a, ok := ans[n]; ok {\\n\\t\\t\\tret[i] = a\\n\\t\\t}\\n\\n\\t}\\n\\treturn ret\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1194331,
                "title": "c-solution-faster-than-98-of-solution-using-set-easy-approach-and-simple-code",
                "content": "Just like queue we will insert each interval when the start time is greater than current query time and in set one with shortest duration will be at top.We will remove from set if end time of top of set is less than the current query. After these two operations the one that remains on top of set is the answer for our query.\\n```\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& in, vector<int>& q) {\\n        vector<pair<int,int>> qq,v;\\n        int i,j,k,l,n=in.size(),m=q.size();\\n        for(i=0;i<m;i++)\\n            qq.push_back({q[i],i});\\n        sort(qq.begin(),qq.end());\\n        for(i=0;i<n;i++)\\n            v.push_back({in[i][0],in[i][1]});\\n        sort(v.begin(),v.end());\\n        vector<int> res(m,-1);\\n        j=0;\\n        set<pair<int,int>> st;\\n        for(i=0;i<m;i++)\\n        {\\n            l=qq[i].first;\\n            while(j<n&&v[j].first<=l)\\n            {\\n                st.insert({v[j].second-v[j].first+1,v[j].second});\\n                j++;\\n            }\\n            while(st.size()>0&&(*st.begin()).second<l)\\n                st.erase(st.begin());\\n            if(st.size()>0)\\n                res[qq[i].second]=(*st.begin()).first;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& in, vector<int>& q) {\\n        vector<pair<int,int>> qq,v;\\n        int i,j,k,l,n=in.size(),m=q.size();\\n        for(i=0;i<m;i++)\\n            qq.push_back({q[i],i});\\n        sort(qq.begin(),qq.end());\\n        for(i=0;i<n;i++)\\n            v.push_back({in[i][0],in[i][1]});\\n        sort(v.begin(),v.end());\\n        vector<int> res(m,-1);\\n        j=0;\\n        set<pair<int,int>> st;\\n        for(i=0;i<m;i++)\\n        {\\n            l=qq[i].first;\\n            while(j<n&&v[j].first<=l)\\n            {\\n                st.insert({v[j].second-v[j].first+1,v[j].second});\\n                j++;\\n            }\\n            while(st.size()>0&&(*st.begin()).second<l)\\n                st.erase(st.begin());\\n            if(st.size()>0)\\n                res[qq[i].second]=(*st.begin()).first;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1189502,
                "title": "c-std-set-with-lower-bound-and-upper-bound",
                "content": "1. Use std::set to store the queries.\\n2. Sort the intervals by size\\n3. Loop through the sorted intervals, use std::set::lower_bound to find the first query that is >= interval start, and use std::set::upper_bound to find the first query that is > interval end.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n\\t    // 1.\\n        std::set<int> q(queries.begin(), queries.end());\\n\\t\\t// 2.\\n        std::sort(intervals.begin(), intervals.end(), [](const auto& i1, const auto& i2) {\\n            return i1[1] - i1[0] < i2[1] - i2[0];\\n        });\\n        // 3. \\n        std::unordered_map<int, int> q2size;\\n        for (const auto& interval : intervals) {\\n            auto size = interval[1] - interval[0] + 1;\\n            auto start = q.lower_bound(interval[0]);\\n            auto end = q.upper_bound(interval[1]);\\n\\t\\t\\t// Now we have the queries between start and end of this interval\\n            auto it = start;\\n            while (it != end) {\\n                q2size[*it++] = size;\\n            }\\n            q.erase(start, end);\\n            if (q.empty()) {\\n                break;\\n            }\\n        }\\n\\t\\t\\n\\t\\t// Just make it as std::vector\\n        std::vector<int> sizes(queries.size(), -1);\\n        for (int i = 0; i < queries.size(); ++i) {\\n            if (auto it = q2size.find(queries[i]); it != q2size.end()) {\\n                sizes[i] = it->second;\\n            }\\n        }\\n        return sizes;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n\\t    // 1.\\n        std::set<int> q(queries.begin(), queries.end());\\n\\t\\t// 2.\\n        std::sort(intervals.begin(), intervals.end(), [](const auto& i1, const auto& i2) {\\n            return i1[1] - i1[0] < i2[1] - i2[0];\\n        });\\n        // 3. \\n        std::unordered_map<int, int> q2size;\\n        for (const auto& interval : intervals) {\\n            auto size = interval[1] - interval[0] + 1;\\n            auto start = q.lower_bound(interval[0]);\\n            auto end = q.upper_bound(interval[1]);\\n\\t\\t\\t// Now we have the queries between start and end of this interval\\n            auto it = start;\\n            while (it != end) {\\n                q2size[*it++] = size;\\n            }\\n            q.erase(start, end);\\n            if (q.empty()) {\\n                break;\\n            }\\n        }\\n\\t\\t\\n\\t\\t// Just make it as std::vector\\n        std::vector<int> sizes(queries.size(), -1);\\n        for (int i = 0; i < queries.size(); ++i) {\\n            if (auto it = q2size.find(queries[i]); it != q2size.end()) {\\n                sizes[i] = it->second;\\n            }\\n        }\\n        return sizes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1188679,
                "title": "golang-solution",
                "content": "Painful in writing in golang.\\n```\\nfunc minInterval(intervals [][]int, queries []int) []int {\\n    sort.Slice(intervals, func(x, y int) bool {\\n        if intervals[x][0] == intervals[y][0] {\\n            return intervals[x][1] < intervals[y][1]\\n        }\\n        return intervals[x][0] < intervals[y][0]\\n    })\\n    \\n    m := make([][]int, len(queries))\\n    for i, v := range queries {\\n        m[i] = []int{v, i}\\n    }\\n    \\n    sort.Slice(m, func(x, y int) bool {\\n        return m[x][0] < m[y][0]\\n    })\\n    \\n    idx := 0\\n    res := make([]int, len(m))\\n    pq := make(PriorityQueue, 0, len(intervals))\\n    heap.Init(&pq)\\n    for _, qs := range m {        \\n        // Push new intervals that q is inside the range\\n        q := qs[0]\\n        for idx < len(intervals) && intervals[idx][0] <= q {\\n            item := &Item{\\n                left: intervals[idx][0],\\n                right: intervals[idx][1],\\n            }\\n            heap.Push(&pq, item)\\n            idx ++\\n        }\\n        \\n        \\n        // Pop the top\\n        p := qs[1]\\n        for pq.Len() > 0 {\\n            top := heap.Pop(&pq).(*Item)\\n            if top.right >= q {\\n                res[p] =  top.right-top.left+1\\n                heap.Push(&pq, top)\\n                break\\n            }\\n        }\\n        if pq.Len() == 0{\\n            res[p] = -1\\n        }\\n    }\\n    return res\\n}\\n\\ntype Item struct {\\n\\tleft    int\\n    right   int\\n}\\n\\ntype PriorityQueue []*Item\\n\\nfunc (pq PriorityQueue) Len() int { return len(pq) }\\n\\nfunc (pq PriorityQueue) Less(i, j int) bool {\\n\\treturn pq[i].right- pq[i].left < pq[j].right - pq[j].left\\n}\\n\\nfunc (pq PriorityQueue) Swap(i, j int) {\\n\\tpq[i], pq[j] = pq[j], pq[i]\\n}\\n\\nfunc (pq *PriorityQueue) Push(x interface{}) {\\n\\titem := x.(*Item)\\n\\t*pq = append(*pq, item)\\n}\\n\\nfunc (pq *PriorityQueue) Pop() interface{} {\\n\\told := *pq\\n\\tn := len(old)\\n\\titem := old[n-1]\\n\\told[n-1] = nil  // avoid memory leak\\n\\t*pq = old[0 : n-1]\\n\\treturn item\\n}\\n\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nfunc minInterval(intervals [][]int, queries []int) []int {\\n    sort.Slice(intervals, func(x, y int) bool {\\n        if intervals[x][0] == intervals[y][0] {\\n            return intervals[x][1] < intervals[y][1]\\n        }\\n        return intervals[x][0] < intervals[y][0]\\n    })\\n    \\n    m := make([][]int, len(queries))\\n    for i, v := range queries {\\n        m[i] = []int{v, i}\\n    }\\n    \\n    sort.Slice(m, func(x, y int) bool {\\n        return m[x][0] < m[y][0]\\n    })\\n    \\n    idx := 0\\n    res := make([]int, len(m))\\n    pq := make(PriorityQueue, 0, len(intervals))\\n    heap.Init(&pq)\\n    for _, qs := range m {        \\n        // Push new intervals that q is inside the range\\n        q := qs[0]\\n        for idx < len(intervals) && intervals[idx][0] <= q {\\n            item := &Item{\\n                left: intervals[idx][0],\\n                right: intervals[idx][1],\\n            }\\n            heap.Push(&pq, item)\\n            idx ++\\n        }\\n        \\n        \\n        // Pop the top\\n        p := qs[1]\\n        for pq.Len() > 0 {\\n            top := heap.Pop(&pq).(*Item)\\n            if top.right >= q {\\n                res[p] =  top.right-top.left+1\\n                heap.Push(&pq, top)\\n                break\\n            }\\n        }\\n        if pq.Len() == 0{\\n            res[p] = -1\\n        }\\n    }\\n    return res\\n}\\n\\ntype Item struct {\\n\\tleft    int\\n    right   int\\n}\\n\\ntype PriorityQueue []*Item\\n\\nfunc (pq PriorityQueue) Len() int { return len(pq) }\\n\\nfunc (pq PriorityQueue) Less(i, j int) bool {\\n\\treturn pq[i].right- pq[i].left < pq[j].right - pq[j].left\\n}\\n\\nfunc (pq PriorityQueue) Swap(i, j int) {\\n\\tpq[i], pq[j] = pq[j], pq[i]\\n}\\n\\nfunc (pq *PriorityQueue) Push(x interface{}) {\\n\\titem := x.(*Item)\\n\\t*pq = append(*pq, item)\\n}\\n\\nfunc (pq *PriorityQueue) Pop() interface{} {\\n\\told := *pq\\n\\tn := len(old)\\n\\titem := old[n-1]\\n\\told[n-1] = nil  // avoid memory leak\\n\\t*pq = old[0 : n-1]\\n\\treturn item\\n}\\n\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1188563,
                "title": "o-n-q-logm-segment-tree-online-update-query-no-sorting-no-recursion",
                "content": "`n=len(intervals)`, `q=len(queries)`, `M` is the range of all numbers.\\n\\nWhen we meet an interval, update marks to the `min(mark, size of interval)`\\n\\nWhen we meet a query, return the minimal all the way up to root\\n\\n```python\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        mini = min(inter[0] for inter in intervals)\\n        maxi = max(inter[1] for inter in intervals)\\n        size = maxi - mini + 1\\n        tree = collections.defaultdict(lambda: inf)  # or use list: tree = [inf] * (2*size)\\n\\n        def update(l, r, v):  # update [l,r) to min of v and its orginal value\\n            l += size  # move to leaf\\n            r += size\\n            while l < r:\\n                if l % 2 == 1:  # if l is right node, update and move to parent\\'s sibling\\n                    tree[l] = min(tree[l], v)\\n                    l += 1\\n                l >>= 1  # else move to parent\\n                if r % 2 == 1:  # if r is right node, update sibling and move to parent\\n                    r -= 1\\n                    tree[r] = min(tree[r], v)\\n                r >>= 1  # else move to parent\\n\\n        def query(i):\\n            i += size  # move to leaf\\n            res = tree[i]\\n            while i > 1:  # collect the minimal all the way up\\n                i >>= 1\\n                res = min(tree[i], res)\\n            return res if res != inf else -1\\n\\n        for inter in intervals:\\n            update(inter[0] - mini, inter[1] + 1 - mini, inter[1] - inter[0] + 1)\\n\\n        ans = []\\n        for q in queries:\\n            if q < mini or q > maxi:\\n                ans.append(-1)\\n            else:\\n                ans.append(query(q - mini))\\n\\n        return ans\\n\\n```\\n\\n> if q is much larger, we can preprocess the whole tree after processing all intervals, making complexity to O(nlogM + M + q)",
                "solutionTags": [
                    "Python",
                    "Tree"
                ],
                "code": "```python\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        mini = min(inter[0] for inter in intervals)\\n        maxi = max(inter[1] for inter in intervals)\\n        size = maxi - mini + 1\\n        tree = collections.defaultdict(lambda: inf)  # or use list: tree = [inf] * (2*size)\\n\\n        def update(l, r, v):  # update [l,r) to min of v and its orginal value\\n            l += size  # move to leaf\\n            r += size\\n            while l < r:\\n                if l % 2 == 1:  # if l is right node, update and move to parent\\'s sibling\\n                    tree[l] = min(tree[l], v)\\n                    l += 1\\n                l >>= 1  # else move to parent\\n                if r % 2 == 1:  # if r is right node, update sibling and move to parent\\n                    r -= 1\\n                    tree[r] = min(tree[r], v)\\n                r >>= 1  # else move to parent\\n\\n        def query(i):\\n            i += size  # move to leaf\\n            res = tree[i]\\n            while i > 1:  # collect the minimal all the way up\\n                i >>= 1\\n                res = min(tree[i], res)\\n            return res if res != inf else -1\\n\\n        for inter in intervals:\\n            update(inter[0] - mini, inter[1] + 1 - mini, inter[1] - inter[0] + 1)\\n\\n        ans = []\\n        for q in queries:\\n            if q < mini or q > maxi:\\n                ans.append(-1)\\n            else:\\n                ans.append(query(q - mini))\\n\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1188496,
                "title": "c-sweep-line-solution-o-n-logn",
                "content": "Let\\'s sweep from left to right, and assume we have a data structure to hold the intervals:\\n\\n1. When encounter start of an interval,  insert the interval to our ds\\n2. When encounter a query, find the shortest interval that is in our ds\\n3. When encounter end of an interval, remove the interval from our ds\\n\\n\\nThe data structure need support efficient insert/removal and  quick access of the smallest element. In C++,  it would a std::set. As the insert/removal is Log(N) while access is O(1). \\n\\n```\\nclass Interval {\\npublic: \\n    Interval(int size, int index): size(size), index(index) {\\n    }\\n    \\n    bool operator<(const Interval& it) const\\n    {\\n        if(this->size == it.size) {\\n            return this->index < it.index;   \\n        }\\n        else {\\n            return this->size < it.size;\\n        }\\n    }\\n\\n    int size;\\n    int index;\\n};\\n\\nclass Node {\\npublic:\\n    // kind: 0 - start, 1 - query, 2 - end\\n    Node(int kind, int value, int index): kind(kind), value(value), index(index) {\\n        \\n    }\\n    int kind;\\n    int value;\\n    int index;\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        vector<Node> nodes;\\n        for(int i = 0; i < intervals.size(); i++) {\\n            nodes.emplace_back(0, intervals[i][0], i);\\n            nodes.emplace_back(2, intervals[i][1], i);\\n        }\\n        for(int i = 0; i < queries.size(); i++) {\\n            nodes.emplace_back(1, queries[i], i);\\n        }\\n        \\n        sort(nodes.begin(), nodes.end(), [](const Node& n1, const Node& n2){\\n            if(n1.value == n2.value) {\\n                return n1.kind < n2.kind;\\n            } else {\\n                return n1.value < n2.value;\\n            }\\n        });\\n        \\n        set<Interval> mySet;\\n        vector<set<Interval>::iterator> its(intervals.size());\\n        vector<int> ret(queries.size());\\n\\t\\t// Sweep line\\n        for(int i = 0; i < nodes.size(); i++) {\\n            if(nodes[i].kind == 0) {\\n                //  meet start: insert interval to data structure\\n                int s = nodes[i].value;\\n                int intervalIndex = nodes[i].index;\\n                int e = intervals[intervalIndex][1];\\n                auto it = mySet.insert(Interval(e - s + 1, intervalIndex)).first;\\n                its[intervalIndex] = it;\\n            } else if (nodes[i].kind == 1) {\\n                // meet query: find the shortest interval in data structure\\n                int queryIndex = nodes[i].index;\\n                int q = nodes[i].value;\\n                if(mySet.empty())\\n                    ret[queryIndex] = -1;\\n                else {\\n                    auto it = mySet.begin();\\n                    ret[queryIndex] = it->size;\\n                }\\n            } else {\\n                // meet end of interval: \\n                // remove interval from data structure\\n                int intervalIndex = nodes[i].index;\\n                auto it = its[intervalIndex];\\n                mySet.erase(it);\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Interval {\\npublic: \\n    Interval(int size, int index): size(size), index(index) {\\n    }\\n    \\n    bool operator<(const Interval& it) const\\n    {\\n        if(this->size == it.size) {\\n            return this->index < it.index;   \\n        }\\n        else {\\n            return this->size < it.size;\\n        }\\n    }\\n\\n    int size;\\n    int index;\\n};\\n\\nclass Node {\\npublic:\\n    // kind: 0 - start, 1 - query, 2 - end\\n    Node(int kind, int value, int index): kind(kind), value(value), index(index) {\\n        \\n    }\\n    int kind;\\n    int value;\\n    int index;\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        vector<Node> nodes;\\n        for(int i = 0; i < intervals.size(); i++) {\\n            nodes.emplace_back(0, intervals[i][0], i);\\n            nodes.emplace_back(2, intervals[i][1], i);\\n        }\\n        for(int i = 0; i < queries.size(); i++) {\\n            nodes.emplace_back(1, queries[i], i);\\n        }\\n        \\n        sort(nodes.begin(), nodes.end(), [](const Node& n1, const Node& n2){\\n            if(n1.value == n2.value) {\\n                return n1.kind < n2.kind;\\n            } else {\\n                return n1.value < n2.value;\\n            }\\n        });\\n        \\n        set<Interval> mySet;\\n        vector<set<Interval>::iterator> its(intervals.size());\\n        vector<int> ret(queries.size());\\n\\t\\t// Sweep line\\n        for(int i = 0; i < nodes.size(); i++) {\\n            if(nodes[i].kind == 0) {\\n                //  meet start: insert interval to data structure\\n                int s = nodes[i].value;\\n                int intervalIndex = nodes[i].index;\\n                int e = intervals[intervalIndex][1];\\n                auto it = mySet.insert(Interval(e - s + 1, intervalIndex)).first;\\n                its[intervalIndex] = it;\\n            } else if (nodes[i].kind == 1) {\\n                // meet query: find the shortest interval in data structure\\n                int queryIndex = nodes[i].index;\\n                int q = nodes[i].value;\\n                if(mySet.empty())\\n                    ret[queryIndex] = -1;\\n                else {\\n                    auto it = mySet.begin();\\n                    ret[queryIndex] = it->size;\\n                }\\n            } else {\\n                // meet end of interval: \\n                // remove interval from data structure\\n                int intervalIndex = nodes[i].index;\\n                auto it = its[intervalIndex];\\n                mySet.erase(it);\\n            }\\n        }\\n        \\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1187328,
                "title": "c-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& q) {\\n      int s=0;\\n      vector<vector<int>>queries;\\n      for(auto x : q){\\n        queries.push_back({x,s});\\n        s++;\\n      }\\n      \\n      sort(begin(intervals),end(intervals),[](const vector<int>&v1,const vector<int>&v2){\\n        return v1[0]<v2[0];\\n      });\\n       sort(begin(queries),end(queries),[](const vector<int>&v1,const vector<int>&v2){\\n        return v1[0]<v2[0];\\n      });\\n      \\n      priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>> >pq;\\n      \\n      int i=0;\\n      int n=intervals.size();\\n      int j=0;\\n      int m= queries.size();\\n      vector<int>res(m,-1);\\n      while(j<m){\\n      \\n        while(i<n && intervals[i][0]<= queries[j][0]){\\n          pq.push({intervals[i][1]-intervals[i][0]+1,intervals[i][1]});\\n          i++;\\n        }\\n  \\n        while(!pq.empty() && pq.top().second<queries[j][0]) pq.pop();\\n        \\n        if(!pq.empty()) res[queries[j][1]]= pq.top().first;\\n        \\n        j++;\\n        \\n      }\\n      \\n      return res;\\n      \\n      \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& q) {\\n      int s=0;\\n      vector<vector<int>>queries;\\n      for(auto x : q){\\n        queries.push_back({x,s});\\n        s++;\\n      }\\n      \\n      sort(begin(intervals),end(intervals),[](const vector<int>&v1,const vector<int>&v2){\\n        return v1[0]<v2[0];\\n      });\\n       sort(begin(queries),end(queries),[](const vector<int>&v1,const vector<int>&v2){\\n        return v1[0]<v2[0];\\n      });\\n      \\n      priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>> >pq;\\n      \\n      int i=0;\\n      int n=intervals.size();\\n      int j=0;\\n      int m= queries.size();\\n      vector<int>res(m,-1);\\n      while(j<m){\\n      \\n        while(i<n && intervals[i][0]<= queries[j][0]){\\n          pq.push({intervals[i][1]-intervals[i][0]+1,intervals[i][1]});\\n          i++;\\n        }\\n  \\n        while(!pq.empty() && pq.top().second<queries[j][0]) pq.pop();\\n        \\n        if(!pq.empty()) res[queries[j][1]]= pq.top().first;\\n        \\n        j++;\\n        \\n      }\\n      \\n      return res;\\n      \\n      \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1187319,
                "title": "c-priority-queue-faster-than-100-memory-lesser-than-100",
                "content": "To get the intuition, just read the hints of the problem.\\n```\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        int n=intervals.size();\\n        int qsize=queries.size();\\n        vector<pair<int,int>> dqueries;\\n        for(int i=0;i<qsize;i++)\\n            dqueries.push_back({queries[i],i});\\n        \\n        sort(intervals.begin(),intervals.end());\\n        sort(dqueries.begin(),dqueries.end());\\n        \\n        vector<int> ans(qsize);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        int i=0;\\n        for(auto query:dqueries){\\n            while(i<n&&intervals[i][0]<=query.first){\\n                pq.push({intervals[i][1]-intervals[i][0]+1,intervals[i][1]+1});\\n                i++;\\n            }\\n            while(!pq.empty()&&pq.top().second<=query.first){\\n                pq.pop();\\n            }\\n            if(pq.empty())   ans[query.second]=-1;\\n            else    ans[query.second]=pq.top().first;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/dcb7b12d-306d-4ee7-9c3b-5ad0b4ad7669_1619943875.6045675.png)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        int n=intervals.size();\\n        int qsize=queries.size();\\n        vector<pair<int,int>> dqueries;\\n        for(int i=0;i<qsize;i++)\\n            dqueries.push_back({queries[i],i});\\n        \\n        sort(intervals.begin(),intervals.end());\\n        sort(dqueries.begin(),dqueries.end());\\n        \\n        vector<int> ans(qsize);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n        int i=0;\\n        for(auto query:dqueries){\\n            while(i<n&&intervals[i][0]<=query.first){\\n                pq.push({intervals[i][1]-intervals[i][0]+1,intervals[i][1]+1});\\n                i++;\\n            }\\n            while(!pq.empty()&&pq.top().second<=query.first){\\n                pq.pop();\\n            }\\n            if(pq.empty())   ans[query.second]=-1;\\n            else    ans[query.second]=pq.top().first;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1187056,
                "title": "python-min-heap",
                "content": "```\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        intervals.sort(reverse=True)\\n        \\n        queries_ind = sorted([(q, i) for i, q in enumerate(queries)])\\n        \\n        out = [0 for _ in queries]\\n        heap = []\\n        for q, i in queries_ind:\\n            while len(intervals) != 0 and q >= intervals[-1][0]:\\n                s, e = intervals.pop()\\n                heapq.heappush(heap, [e-s+1, e])\\n            \\n            while len(heap) != 0 and heap[0][1] < q:\\n                heapq.heappop(heap)\\n            \\n            if len(heap) == 0:\\n                out[i] = -1\\n            else:\\n                out[i] = heap[0][0]\\n        \\n        return out\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        intervals.sort(reverse=True)\\n        \\n        queries_ind = sorted([(q, i) for i, q in enumerate(queries)])\\n        \\n        out = [0 for _ in queries]\\n        heap = []\\n        for q, i in queries_ind:\\n            while len(intervals) != 0 and q >= intervals[-1][0]:\\n                s, e = intervals.pop()\\n                heapq.heappush(heap, [e-s+1, e])\\n            \\n            while len(heap) != 0 and heap[0][1] < q:\\n                heapq.heappop(heap)\\n            \\n            if len(heap) == 0:\\n                out[i] = -1\\n            else:\\n                out[i] = heap[0][0]\\n        \\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186924,
                "title": "java-sort-then-update",
                "content": "First sort the intervals based on their sizes.\\nThen record the size of each index in an interval to be the interval size;\\nif the sizes[i] is already recorded,  make i jump to ending[i]+1 and start counting from there.\\n```\\nclass Solution {\\n    public int[] minInterval(int[][] intervals, int[] queries) {\\n        Arrays.sort(intervals, (a,b)->((a[1]-a[0]-(b[1]-b[0]))));\\n        int[] sizes = new int[10000000];\\n        int[] ending = new int[10000000];\\n        for (int[] interval: intervals) {\\n            for (int i = interval[0]; i<=interval[1]; i++) {\\n                if (sizes[i]>0) {\\n                    i = ending[i];\\n                } else {\\n                    sizes[i] = interval[1]-interval[0]+1;\\n                    ending[i] = interval[1];\\n                }\\n            }\\n        }\\n        int[] res = new int[queries.length];\\n        for (int i=0; i<queries.length; i++) {\\n            res[i] = sizes[queries[i]];\\n            if (res[i]==0) res[i]=-1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] minInterval(int[][] intervals, int[] queries) {\\n        Arrays.sort(intervals, (a,b)->((a[1]-a[0]-(b[1]-b[0]))));\\n        int[] sizes = new int[10000000];\\n        int[] ending = new int[10000000];\\n        for (int[] interval: intervals) {\\n            for (int i = interval[0]; i<=interval[1]; i++) {\\n                if (sizes[i]>0) {\\n                    i = ending[i];\\n                } else {\\n                    sizes[i] = interval[1]-interval[0]+1;\\n                    ending[i] = interval[1];\\n                }\\n            }\\n        }\\n        int[] res = new int[queries.length];\\n        for (int i=0; i<queries.length; i++) {\\n            res[i] = sizes[queries[i]];\\n            if (res[i]==0) res[i]=-1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186881,
                "title": "short-java-solution-treemap-sort",
                "content": "Tried to make codes to avoid use the complex array operations. \\n\\nThe basic idea is to sort intervals on the increasement of right - left + 1. Sort queries. For each interval, if any query value hits it, the answer is best. After finish the current interval, removes keys from TreeMap where query values between left and right.\\n\\nReply on java objects make the codes short. But sacrifice the time.\\n\\n```\\nclass Solution {\\n    public int[] minInterval(int[][] intervals, int[] queries) {\\n        Arrays.sort(intervals, (a, b) -> ((b[0] - a[0]) - (b[1] - a[1])));\\n        \\n        TreeMap<Integer, List<Integer>> treeMap = new TreeMap<>();\\n        for (int i = 0; i < queries.length; i++) {\\n            treeMap.computeIfAbsent(queries[i], a -> new ArrayList<>()).add(i);\\n        }\\n        \\n        int ret[] = new int[queries.length];\\n        Arrays.fill(ret, -1);\\n        for (int[] oneInterval : intervals) {\\n            int left = oneInterval[0], right = oneInterval[1];\\n            Map<Integer, List<Integer>> sub = treeMap.subMap(left, true, right, true);\\n            \\n            for (List<Integer> list : sub.values()) {\\n                for (int i : list) {\\n                    ret[i] = right - left + 1;    \\n                }\\n            }\\n            treeMap.keySet().removeAll(new HashSet<Integer>(sub.keySet()));\\n        }\\n        return ret;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] minInterval(int[][] intervals, int[] queries) {\\n        Arrays.sort(intervals, (a, b) -> ((b[0] - a[0]) - (b[1] - a[1])));\\n        \\n        TreeMap<Integer, List<Integer>> treeMap = new TreeMap<>();\\n        for (int i = 0; i < queries.length; i++) {\\n            treeMap.computeIfAbsent(queries[i], a -> new ArrayList<>()).add(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1186845,
                "title": "java-solution",
                "content": "\\n\\n```\\nclass Solution {\\n    Map<Integer,Integer>f=new HashMap<>();\\n    public int[] minInterval(int[][] A, int[] queries) {\\n        int q[][]=new int[queries.length][2];\\n        int res[]=new int[q.length];\\n        Arrays.fill(res,-1);\\n        \\n        for(int i=0;i<q.length;i++){\\n            q[i][0]=queries[i];\\n            q[i][1]=i;\\n        }\\n        \\n        Arrays.sort(q,(a,b)->{\\n            return a[0]-b[0];\\n        });\\n        \\n        Arrays.sort(A,(a,b)->{\\n            return a[0]-b[0];\\n        });\\n        \\n        \\n        int j=0;\\n        PriorityQueue<int[]>pq=new PriorityQueue<>((a,b)->{\\n            return a[1]-b[1];\\n        }); //sort based on the end\\n        PriorityQueue<Integer>min=new PriorityQueue<>();//heap storing the size\\n        \\n        for(int i=0;i<q.length;i++){\\n            int val=q[i][0],index=q[i][1];\\n            while(j<A.length&&A[j][0]<=val){\\n                if(A[j][1]>=val){\\n                    //add \\n                    int size=A[j][1]-A[j][0]+1;\\n                    pq.add(A[j]);\\n                    put(size);\\n                    min.add(size);\\n                }\\n                j++;\\n            }\\n            \\n            while(pq.size()>0&&pq.peek()[1]<val){//pq should contain all those interval that include the current query number\\n                int top[]=pq.poll();\\n                int size=top[1]-top[0]+1;\\n                remove(size);\\n            }\\n\\t\\t\\t\\n            while(min.size()>0&&!f.containsKey(min.peek()))min.poll();\\n            \\n            if(min.size()>0){//choose the minimum size\\n                res[index]=min.peek();\\n            }\\n            \\n        }\\n        \\n        return res;\\n    }\\n    \\n    public void put(int k){\\n        if(!f.containsKey(k))f.put(k,1);\\n        else f.put(k,f.get(k)+1);\\n    }\\n    \\n    public void remove(int k){\\n        f.put(k,f.get(k)-1);\\n        if(f.get(k)==0)f.remove(k);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<Integer,Integer>f=new HashMap<>();\\n    public int[] minInterval(int[][] A, int[] queries) {\\n        int q[][]=new int[queries.length][2];\\n        int res[]=new int[q.length];\\n        Arrays.fill(res,-1);\\n        \\n        for(int i=0;i<q.length;i++){\\n            q[i][0]=queries[i];\\n            q[i][1]=i;\\n        }\\n        \\n        Arrays.sort(q,(a,b)->{\\n            return a[0]-b[0];\\n        });\\n        \\n        Arrays.sort(A,(a,b)->{\\n            return a[0]-b[0];\\n        });\\n        \\n        \\n        int j=0;\\n        PriorityQueue<int[]>pq=new PriorityQueue<>((a,b)->{\\n            return a[1]-b[1];\\n        }); //sort based on the end\\n        PriorityQueue<Integer>min=new PriorityQueue<>();//heap storing the size\\n        \\n        for(int i=0;i<q.length;i++){\\n            int val=q[i][0],index=q[i][1];\\n            while(j<A.length&&A[j][0]<=val){\\n                if(A[j][1]>=val){\\n                    //add \\n                    int size=A[j][1]-A[j][0]+1;\\n                    pq.add(A[j]);\\n                    put(size);\\n                    min.add(size);\\n                }\\n                j++;\\n            }\\n            \\n            while(pq.size()>0&&pq.peek()[1]<val){//pq should contain all those interval that include the current query number\\n                int top[]=pq.poll();\\n                int size=top[1]-top[0]+1;\\n                remove(size);\\n            }\\n\\t\\t\\t\\n            while(min.size()>0&&!f.containsKey(min.peek()))min.poll();\\n            \\n            if(min.size()>0){//choose the minimum size\\n                res[index]=min.peek();\\n            }\\n            \\n        }\\n        \\n        return res;\\n    }\\n    \\n    public void put(int k){\\n        if(!f.containsKey(k))f.put(k,1);\\n        else f.put(k,f.get(k)+1);\\n    }\\n    \\n    public void remove(int k){\\n        f.put(k,f.get(k)-1);\\n        if(f.get(k)==0)f.remove(k);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186801,
                "title": "python-heap-sliding-window-solution",
                "content": "It combines heap and sliding window. For every query, we get a window of the target and we use heap to get the answer for this query.\\n```\\n  def minInterval(self, intervals, queries):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type queries: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        intervals.sort()\\n        queries = [[queries[i]]+[i] for i in range(len(queries))]\\n        queries.sort()\\n        res = [-1 for _ in range(len(queries))]\\n        left = 0\\n        heap = []# heap is (length,right side)\\n        for target,index in queries:#query from small to large\\n            while left<len(intervals) and intervals[left][1]<target:#if the interval is in the left side, skip it\\n                left+=1\\n            while left<len(intervals) and intervals[left][0]<=target:#if the interval is the right side of the target, include it in the heap, a trap here is that we shouldn\\'t require intervals[left][1]>=target, or we will miss to add some intervals.\\n                heapq.heappush(heap,(intervals[left][1]-intervals[left][0]+1,intervals[left][1]))\\n                left+=1\\n            while heap and heap[0][1]<target:# if the smallest interval doesn\\'t include the target, pop (targets after this one also don\\'t need it)\\n                heapq.heappop(heap)\\n            if heap:# get the res\\n                res[index] = heap[0][0]\\n        return res",
                "solutionTags": [],
                "code": "It combines heap and sliding window. For every query, we get a window of the target and we use heap to get the answer for this query.\\n```\\n  def minInterval(self, intervals, queries):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type queries: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        intervals.sort()\\n        queries = [[queries[i]]+[i] for i in range(len(queries))]\\n        queries.sort()\\n        res = [-1 for _ in range(len(queries))]\\n        left = 0\\n        heap = []# heap is (length,right side)\\n        for target,index in queries:#query from small to large\\n            while left<len(intervals) and intervals[left][1]<target:#if the interval is in the left side, skip it\\n                left+=1\\n            while left<len(intervals) and intervals[left][0]<=target:#if the interval is the right side of the target, include it in the heap, a trap here is that we shouldn\\'t require intervals[left][1]>=target, or we will miss to add some intervals.\\n                heapq.heappush(heap,(intervals[left][1]-intervals[left][0]+1,intervals[left][1]))\\n                left+=1\\n            while heap and heap[0][1]<target:# if the smallest interval doesn\\'t include the target, pop (targets after this one also don\\'t need it)\\n                heapq.heappop(heap)\\n            if heap:# get the res\\n                res[index] = heap[0][0]\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 4022264,
                "title": "c-beginner-solution-easy-to-catch-priority-queue-step-by-step-code-iit-roorkee",
                "content": "# Complexity\\n- Time complexity:O(Nlog(n))\\n\\n- Space complexity:O(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& it, vector<int>& pr)\\n    {\\n        int n=it.size();\\n        int m=pr.size();\\n        vector<int>v(m,0);\\n        vector<int>qr=pr;\\n        unordered_map<int,vector<pair<int,int>>>mp;\\n        unordered_map<int,int>ans;\\n        sort(qr.begin(),qr.end());\\n        for(int i=0;i<n;i++)\\n        {\\n            int x=(it[i][1]-it[i][0])+1;\\n            auto start=lower_bound(qr.begin(),qr.end(),it[i][0])-qr.begin();\\n            auto end=upper_bound(qr.begin(),qr.end(),it[i][1])-qr.begin();\\n            if(start<=(end-1))\\n            {\\n                mp[start].push_back({x,(end-1)});\\n            }\\n        }\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<mp[i].size();j++)\\n            {\\n                pq.push(mp[i][j]);\\n            }\\n            while((!pq.empty())&&(i>pq.top().second))\\n            {\\n                pq.pop();\\n            }\\n            if(pq.empty())\\n            {\\n                ans[qr[i]]=-1;\\n            }\\n            else\\n            {\\n                ans[qr[i]]=pq.top().first;\\n            }\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            v[i]=ans[pr[i]];\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Line Sweep",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& it, vector<int>& pr)\\n    {\\n        int n=it.size();\\n        int m=pr.size();\\n        vector<int>v(m,0);\\n        vector<int>qr=pr;\\n        unordered_map<int,vector<pair<int,int>>>mp;\\n        unordered_map<int,int>ans;\\n        sort(qr.begin(),qr.end());\\n        for(int i=0;i<n;i++)\\n        {\\n            int x=(it[i][1]-it[i][0])+1;\\n            auto start=lower_bound(qr.begin(),qr.end(),it[i][0])-qr.begin();\\n            auto end=upper_bound(qr.begin(),qr.end(),it[i][1])-qr.begin();\\n            if(start<=(end-1))\\n            {\\n                mp[start].push_back({x,(end-1)});\\n            }\\n        }\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<mp[i].size();j++)\\n            {\\n                pq.push(mp[i][j]);\\n            }\\n            while((!pq.empty())&&(i>pq.top().second))\\n            {\\n                pq.pop();\\n            }\\n            if(pq.empty())\\n            {\\n                ans[qr[i]]=-1;\\n            }\\n            else\\n            {\\n                ans[qr[i]]=pq.top().first;\\n            }\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            v[i]=ans[pr[i]];\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003200,
                "title": "c-solution-using-priorityqueue-with-detailed-explanation",
                "content": "# Intuition\\nuse the minheap to order the intervals\\n\\n# Complexity\\n- Time complexity:prio\\nO(nlogn + qlogq)\\nn = intervals.Length\\nq = queries.Length\\n\\n- Space complexity:\\nO(Q)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] MinInterval(int[][] intervals, int[] queries) \\n    {\\n      // sort both intervals and queries\\n      Array.Sort(intervals, (a, b) => a[0]-b[0]);\\n      var sortedQueries = queries.OrderBy(e=> e).ToArray(); // do not mutate queries\\n      // since the queries are sorted we need to return answers in actual order\\n      Dictionary<int, int> answers = new();\\n\\n      // so we basically create a c# minheap with a composite key `Size` and `End` interval, `End` is for tie breaker, so in that case we need to consider the size on the left handside of scale. \\n      var comparer = Comparer<(int Size, int End)>.Create((a, b) => \\n      {\\n        if(a.Size == b.Size) return a.End.CompareTo(b.End);\\n        return a.Size.CompareTo(b.Size);\\n      });\\n      var minHeap = new PriorityQueue<(int Size, int End), (int Size, int End)>(intervals.Length, comparer);\\n\\n      int i = 0;\\n      for(int qi = 0; qi < sortedQueries.Length; qi++)\\n      {\\n        // Enqueue all intervals in minheap whose Start is less than current query\\n        while(i < intervals.Length && sortedQueries[qi] >= intervals[i][0])\\n        {\\n          var value = (intervals[i][1] - intervals[i][0] + 1, intervals[i][1]);\\n          minHeap.Enqueue(value, value);\\n          i++;\\n        }\\n\\n        // now we must remove from minheap if the head element of queue doesnt satisfy the current query i.e if End < current query\\n        while(minHeap.Count > 0 && minHeap.Peek().End < sortedQueries[qi]) minHeap.Dequeue();\\n        \\n        // the element at the head is the answer\\n        if(!answers.ContainsKey(sortedQueries[qi]))\\n          answers.TryAdd(sortedQueries[qi], minHeap.Count > 0 ? minHeap.Peek().Size: -1);\\n      }\\n      \\n      // we want to return answer in original order\\n      return queries.Select(e=> answers[e]).ToArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Hash Table",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] MinInterval(int[][] intervals, int[] queries) \\n    {\\n      // sort both intervals and queries\\n      Array.Sort(intervals, (a, b) => a[0]-b[0]);\\n      var sortedQueries = queries.OrderBy(e=> e).ToArray(); // do not mutate queries\\n      // since the queries are sorted we need to return answers in actual order\\n      Dictionary<int, int> answers = new();\\n\\n      // so we basically create a c# minheap with a composite key `Size` and `End` interval, `End` is for tie breaker, so in that case we need to consider the size on the left handside of scale. \\n      var comparer = Comparer<(int Size, int End)>.Create((a, b) => \\n      {\\n        if(a.Size == b.Size) return a.End.CompareTo(b.End);\\n        return a.Size.CompareTo(b.Size);\\n      });\\n      var minHeap = new PriorityQueue<(int Size, int End), (int Size, int End)>(intervals.Length, comparer);\\n\\n      int i = 0;\\n      for(int qi = 0; qi < sortedQueries.Length; qi++)\\n      {\\n        // Enqueue all intervals in minheap whose Start is less than current query\\n        while(i < intervals.Length && sortedQueries[qi] >= intervals[i][0])\\n        {\\n          var value = (intervals[i][1] - intervals[i][0] + 1, intervals[i][1]);\\n          minHeap.Enqueue(value, value);\\n          i++;\\n        }\\n\\n        // now we must remove from minheap if the head element of queue doesnt satisfy the current query i.e if End < current query\\n        while(minHeap.Count > 0 && minHeap.Peek().End < sortedQueries[qi]) minHeap.Dequeue();\\n        \\n        // the element at the head is the answer\\n        if(!answers.ContainsKey(sortedQueries[qi]))\\n          answers.TryAdd(sortedQueries[qi], minHeap.Count > 0 ? minHeap.Peek().Size: -1);\\n      }\\n      \\n      // we want to return answer in original order\\n      return queries.Select(e=> answers[e]).ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3996369,
                "title": "rust-sorting-heap",
                "content": "# Code\\n```\\nuse std::collections::{BinaryHeap, HashMap};\\nuse std::cmp::Ordering;\\n\\n#[derive(Debug, PartialEq, Eq)]\\nstruct Interval {\\n    low: i32,\\n    high: i32,\\n}\\n\\nimpl Ord for Interval {\\n    fn cmp(&self, other: &Self) -> Ordering {\\n        if self.high - self.low == other.high - other.low {\\n            return self.high.cmp(&other.high).reverse();\\n        }\\n\\n        return (self.high - self.low).cmp(&(other.high - other.low)).reverse();\\n    }\\n}\\n\\nimpl PartialOrd for Interval {\\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\\n        Some(self.cmp(other))\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn min_interval(mut intervals: Vec<Vec<i32>>, mut queries: Vec<i32>) -> Vec<i32> {\\n        // 1. Sort intervals by left border\\n        intervals.sort_by(|a, b| if a[0] == b[0] { a[1].cmp(&b[1]) } else { a[0].cmp(&b[0]) });\\n        let mut i = 0;\\n\\n        let mut heap = BinaryHeap::new();\\n        let mut result_map = HashMap::new();\\n\\n        // 2. Sort queries\\n        let mut sorted_queries = queries.clone();\\n        sorted_queries.sort();\\n        for query in sorted_queries {\\n            // 3. Add intervals to the heap only if the current query is not less than the left border\\n            while i < intervals.len() && intervals[i][0] <= query {\\n                heap.push(Interval { low: intervals[i][0], high: intervals[i][1] });\\n                i += 1;\\n            }\\n\\n            loop {\\n                // 4. Get intervals from the heap (sorted by length) and pop in they not usable anymore\\n                if let Some(top_interval) = heap.peek() {\\n                    if top_interval.low <= query && query <= top_interval.high {\\n                        result_map.insert(query, top_interval.high - top_interval.low + 1);\\n                        break;\\n                    } else {\\n                        heap.pop();\\n                    }\\n                } else {\\n                    result_map.insert(query, -1);\\n                    break;\\n                }\\n            }\\n        }\\n\\n        // 5. Recover the original order of the queries\\n        return queries.into_iter().map(|x| result_map[&x]).collect();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::{BinaryHeap, HashMap};\\nuse std::cmp::Ordering;\\n\\n#[derive(Debug, PartialEq, Eq)]\\nstruct Interval {\\n    low: i32,\\n    high: i32,\\n}\\n\\nimpl Ord for Interval {\\n    fn cmp(&self, other: &Self) -> Ordering {\\n        if self.high - self.low == other.high - other.low {\\n            return self.high.cmp(&other.high).reverse();\\n        }\\n\\n        return (self.high - self.low).cmp(&(other.high - other.low)).reverse();\\n    }\\n}\\n\\nimpl PartialOrd for Interval {\\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\\n        Some(self.cmp(other))\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn min_interval(mut intervals: Vec<Vec<i32>>, mut queries: Vec<i32>) -> Vec<i32> {\\n        // 1. Sort intervals by left border\\n        intervals.sort_by(|a, b| if a[0] == b[0] { a[1].cmp(&b[1]) } else { a[0].cmp(&b[0]) });\\n        let mut i = 0;\\n\\n        let mut heap = BinaryHeap::new();\\n        let mut result_map = HashMap::new();\\n\\n        // 2. Sort queries\\n        let mut sorted_queries = queries.clone();\\n        sorted_queries.sort();\\n        for query in sorted_queries {\\n            // 3. Add intervals to the heap only if the current query is not less than the left border\\n            while i < intervals.len() && intervals[i][0] <= query {\\n                heap.push(Interval { low: intervals[i][0], high: intervals[i][1] });\\n                i += 1;\\n            }\\n\\n            loop {\\n                // 4. Get intervals from the heap (sorted by length) and pop in they not usable anymore\\n                if let Some(top_interval) = heap.peek() {\\n                    if top_interval.low <= query && query <= top_interval.high {\\n                        result_map.insert(query, top_interval.high - top_interval.low + 1);\\n                        break;\\n                    } else {\\n                        heap.pop();\\n                    }\\n                } else {\\n                    result_map.insert(query, -1);\\n                    break;\\n                }\\n            }\\n        }\\n\\n        // 5. Recover the original order of the queries\\n        return queries.into_iter().map(|x| result_map[&x]).collect();\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3994758,
                "title": "clean-python3-with-explanation-heap",
                "content": "# Complexity\\n- Time complexity: $$O(n\\\\log n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom heapq import heappush , heappop\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        available = []\\n        output = [0] * len(queries)\\n        queries = sorted((v,i) for i ,v in enumerate(queries))\\n        intervals.sort()\\n        i = 0\\n        for q, query_index in queries:\\n            # add all possible candidates\\n            while i < len(intervals) and intervals[i][0] <= q:\\n                heappush(available,(intervals[i][1]-intervals[i][0]+1,intervals[i][1]))\\n                i += 1\\n            # remove expired intervals\\n            while available and available[0][1] < q:\\n                heappop(available)\\n            # take care when no interval cover this q\\n            output[query_index] = available[0][0] if available else -1\\n        return output\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom heapq import heappush , heappop\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        available = []\\n        output = [0] * len(queries)\\n        queries = sorted((v,i) for i ,v in enumerate(queries))\\n        intervals.sort()\\n        i = 0\\n        for q, query_index in queries:\\n            # add all possible candidates\\n            while i < len(intervals) and intervals[i][0] <= q:\\n                heappush(available,(intervals[i][1]-intervals[i][0]+1,intervals[i][1]))\\n                i += 1\\n            # remove expired intervals\\n            while available and available[0][1] < q:\\n                heappop(available)\\n            # take care when no interval cover this q\\n            output[query_index] = available[0][0] if available else -1\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977707,
                "title": "binary-search-sorting-ez-python",
                "content": "# Approach\\nThe solution is based on a binary search on the queries.\\n\\n1. Sort the queries and save also their initial positions. Sort the intervals in ascending order.\\n2. Iterate through intervals and use a binary search to find the index of the query that is just above the start of our interval.\\n3. If that index is valid (query exists)check if the query is inside the interval and set the old index of that query that was saved into end-start+1 in the output list.\\n\\nThis solution works because the intervals are sorted. So the first time you pop a query it will be for the smallest length interval.\\n\\n# Complexity\\n- Time complexity:O(n x q logq)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n\\n        q = sorted([q,i] for i, q in enumerate(queries))\\n        intervals.sort(key = lambda x: x[1]-x[0])\\n\\n        output = [-1] * len(queries)\\n\\n        for start, end in intervals:\\n            ind = bisect.bisect(q, [start])\\n            while ind < len(q) and q[ind][0]<=end:\\n                output[q.pop(ind)[1]] = end-start+1\\n\\n        return output\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n\\n        q = sorted([q,i] for i, q in enumerate(queries))\\n        intervals.sort(key = lambda x: x[1]-x[0])\\n\\n        output = [-1] * len(queries)\\n\\n        for start, end in intervals:\\n            ind = bisect.bisect(q, [start])\\n            while ind < len(q) and q[ind][0]<=end:\\n                output[q.pop(ind)[1]] = end-start+1\\n\\n        return output\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3925130,
                "title": "c-2d-range-tree-fractional-cascading",
                "content": "Yeet funny data structure at problem and call it a day.\\n\\nIf you interpret the intervals as points `(l, r)` and assign each point a value equal to the length of the interval, each query `q` is looking for the point with the maximum value satisfying `l <= q` and `q <= r`.\\n\\nWhich is solvable with range trees from computational geometry.\\n\\nI liked how this set of slides explained them: https://ima.udg.edu/~sellares/ComGeo/RangeTrees4Ms.pdf.\\nHowever, I didn\\'t fully understand what the slides meant by \"fractional cascading\", so I went to the wikipedia article: https://en.wikipedia.org/wiki/Fractional_cascading.\\nThe wikipedia article talks about a more general technique, and it\\'s a bit different from how it\\'s used in range trees, but understanding the more general technique helped me understand the specialized case.\\n\\nTheoretically this is `O(nlogn)` memory and preprocessing time, `O(logn)` per query. Which is pretty bad: any other solution posted here is probably better in both theory and practice.\\n\\nBut hey, funny data structure go vroom.\\n\\n```cpp\\n// #define DEBUG\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        int n = intervals.size();\\n        int inf = std::numeric_limits<int>::max();\\n        std::vector<std::vector<std::pair<int, int>>> st(2 * n);\\n        std::vector<std::vector<int>> fc(n + 1);\\n        std::sort(intervals.begin(), intervals.end());\\n        std::vector<int> xcoords(n);\\n        for (int i = 0; i < n; ++i) {\\n            const auto& interval = intervals[i];\\n            xcoords[i] = interval[0];\\n            st[n + i] = {{interval[1], interval[1] - interval[0] + 1}};\\n        }\\n        for (int i = n; --i > 0; ) {\\n            std::merge(\\n                st[i << 1].begin(), st[i << 1].end(),\\n                st[i << 1 | 1].begin(), st[i << 1 | 1].end(),\\n                std::back_inserter(st[i]));\\n            auto lit = st[i << 1].begin();\\n            auto lit_end = st[i << 1].end();\\n            fc[i].push_back(0);\\n            for (auto it = st[i].begin(); it != st[i].end(); ++it) {\\n                fc[i].push_back(fc[i].back());\\n                if (lit != lit_end && *it == *lit) {\\n                    ++fc[i].back();\\n                    ++lit;\\n                }\\n            }\\n        }\\n        for (int i = 2 * n; --i > 0; ) {\\n            st[i].emplace_back(inf, inf);\\n            for (int j = st[i].size(); --j > 0; ) {\\n                st[i][j - 1].second = std::min(st[i][j - 1].second, st[i][j].second);\\n            }\\n        }\\n        fc.back() = {0, 0};\\n        std::vector<int> ycoords(n);\\n        for (int i = 0; i < n; ++i) {\\n            ycoords[i] = st[1][i].first;\\n        }\\n        int h = 32 - __builtin_clz(2 * n);\\n        \\n#ifdef DEBUG        \\n        for (int i = 0; i < st.size(); ++i) {\\n            auto& r = st[i];\\n            std::cout << i << \": \";\\n            for (auto& [y, v] : r) {\\n                std::cout << \"(\" << y << \", \" << v << \")\" << \", \";\\n            }\\n            std::cout << std::endl;\\n        }\\n        for (int i = 0; i < fc.size(); ++i) {\\n            auto& v = fc[i];\\n            std::cout << i << \": \";\\n            for (auto& lc : v) {\\n                std::cout << lc << \", \";\\n            }\\n            std::cout << std::endl;\\n        }\\n#endif // DEBUG\\n        \\n        for (auto& q : queries) {\\n            int xidx = std::upper_bound(xcoords.begin(), xcoords.end(), q) - xcoords.begin();\\n            int yidx = std::lower_bound(ycoords.begin(), ycoords.end(), q) - ycoords.begin();\\n#ifdef DEBUG\\n            std::cout << q << \": \" << xidx << \", \" << yidx << std::endl;\\n#endif // DEBUG\\n            int l = n - 1;\\n            int r = n + xidx;\\n            int yl = yidx;\\n            int yr = yidx;\\n            q = inf;\\n            for (int s = h; --s >= 0; ) {\\n                int li = l >> s;\\n                int ri = r >> s;\\n                int lp = li >> 1;\\n                int rp = ri >> 1;\\n                if (li + 1 <= ri - 1) {\\n                    if (!(li & 1)) q = std::min(q, st[li + 1][lp ? yl - fc[lp][yl] : yl].second);\\n                    if (ri & 1) q = std::min(q, st[ri - 1][rp ? fc[rp][yr] : yr].second);\\n                }\\n                yl = lp ? li & 1 ? yl - fc[lp][yl] : fc[lp][yl] : yl;\\n                yr = rp ? ri & 1 ? yr - fc[rp][yr] : fc[rp][yr] : yr;\\n#ifdef DEBUG\\n                std::cout << li << \", \" << ri << \", \" << lp << \", \" << rp << \", \" << yl << \", \" << yr << std::endl;\\n#endif // DEBUG\\n            }\\n            if (q == inf) q = -1;\\n        }\\n        \\n        return queries;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```cpp\\n// #define DEBUG\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        int n = intervals.size();\\n        int inf = std::numeric_limits<int>::max();\\n        std::vector<std::vector<std::pair<int, int>>> st(2 * n);\\n        std::vector<std::vector<int>> fc(n + 1);\\n        std::sort(intervals.begin(), intervals.end());\\n        std::vector<int> xcoords(n);\\n        for (int i = 0; i < n; ++i) {\\n            const auto& interval = intervals[i];\\n            xcoords[i] = interval[0];\\n            st[n + i] = {{interval[1], interval[1] - interval[0] + 1}};\\n        }\\n        for (int i = n; --i > 0; ) {\\n            std::merge(\\n                st[i << 1].begin(), st[i << 1].end(),\\n                st[i << 1 | 1].begin(), st[i << 1 | 1].end(),\\n                std::back_inserter(st[i]));\\n            auto lit = st[i << 1].begin();\\n            auto lit_end = st[i << 1].end();\\n            fc[i].push_back(0);\\n            for (auto it = st[i].begin(); it != st[i].end(); ++it) {\\n                fc[i].push_back(fc[i].back());\\n                if (lit != lit_end && *it == *lit) {\\n                    ++fc[i].back();\\n                    ++lit;\\n                }\\n            }\\n        }\\n        for (int i = 2 * n; --i > 0; ) {\\n            st[i].emplace_back(inf, inf);\\n            for (int j = st[i].size(); --j > 0; ) {\\n                st[i][j - 1].second = std::min(st[i][j - 1].second, st[i][j].second);\\n            }\\n        }\\n        fc.back() = {0, 0};\\n        std::vector<int> ycoords(n);\\n        for (int i = 0; i < n; ++i) {\\n            ycoords[i] = st[1][i].first;\\n        }\\n        int h = 32 - __builtin_clz(2 * n);\\n        \\n#ifdef DEBUG        \\n        for (int i = 0; i < st.size(); ++i) {\\n            auto& r = st[i];\\n            std::cout << i << \": \";\\n            for (auto& [y, v] : r) {\\n                std::cout << \"(\" << y << \", \" << v << \")\" << \", \";\\n            }\\n            std::cout << std::endl;\\n        }\\n        for (int i = 0; i < fc.size(); ++i) {\\n            auto& v = fc[i];\\n            std::cout << i << \": \";\\n            for (auto& lc : v) {\\n                std::cout << lc << \", \";\\n            }\\n            std::cout << std::endl;\\n        }\\n#endif // DEBUG\\n        \\n        for (auto& q : queries) {\\n            int xidx = std::upper_bound(xcoords.begin(), xcoords.end(), q) - xcoords.begin();\\n            int yidx = std::lower_bound(ycoords.begin(), ycoords.end(), q) - ycoords.begin();\\n#ifdef DEBUG\\n            std::cout << q << \": \" << xidx << \", \" << yidx << std::endl;\\n#endif // DEBUG\\n            int l = n - 1;\\n            int r = n + xidx;\\n            int yl = yidx;\\n            int yr = yidx;\\n            q = inf;\\n            for (int s = h; --s >= 0; ) {\\n                int li = l >> s;\\n                int ri = r >> s;\\n                int lp = li >> 1;\\n                int rp = ri >> 1;\\n                if (li + 1 <= ri - 1) {\\n                    if (!(li & 1)) q = std::min(q, st[li + 1][lp ? yl - fc[lp][yl] : yl].second);\\n                    if (ri & 1) q = std::min(q, st[ri - 1][rp ? fc[rp][yr] : yr].second);\\n                }\\n                yl = lp ? li & 1 ? yl - fc[lp][yl] : fc[lp][yl] : yl;\\n                yr = rp ? ri & 1 ? yr - fc[rp][yr] : fc[rp][yr] : yr;\\n#ifdef DEBUG\\n                std::cout << li << \", \" << ri << \", \" << lp << \", \" << rp << \", \" << yl << \", \" << yr << std::endl;\\n#endif // DEBUG\\n            }\\n            if (q == inf) q = -1;\\n        }\\n        \\n        return queries;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3912739,
                "title": "very-intuitive-solution-using-sweep-line-technique",
                "content": "# Intuition\\nlet\\'s say for a given query point Xi, we need to know the value of length of all the segment which inclues the point Xi in it\\'s range i.e Li<=Xi<=Ri\\n# Approach\\nIt turns out that we can do the above thing mentioned using sweep line technique. we create events array and there will be three type of events:\\nevents of type 1: starting point of any segment \\nevents of type 2: Query points\\nevents of type 3: ending point of any segment \\n\\nthe events array will also have store the length of current segment, then we can simply sort the events array on increasing order of starting point and process them with a multiset which will give me length of all the segments which are currently active. (See implementation for clarity)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n O((N+Q)log(N+Q))\\n- Space complexity:\\n O(N+Q)\\n\\n# Code\\n```\\n#define f first\\n#define s second\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        int q=queries.size();\\n        vector<int>ans(q,-1);\\n        vector<pair<int,pair<int,int>>>events;\\n        for(auto arr:intervals){\\n            int cost=arr[1]-arr[0]+1;\\n            events.push_back({arr[0],{1,cost}});\\n            events.push_back({arr[1],{3,cost}});\\n        }\\n        for(int i=0;i<q;i++){\\n            events.push_back({queries[i],{2,i}});\\n        }\\n        sort(events.begin(),events.end());\\n        multiset<int>ms; // maintains length of each active segment\\n        for(int i=0;i<events.size();i++){\\n            if(events[i].s.f==1){\\n                ms.insert(events[i].s.s);\\n            }else if(events[i].s.f==2){\\n                if(!ms.empty()){\\n                    ans[events[i].s.s]=*ms.begin();\\n                }\\n            }else{\\n                ms.erase(ms.find(events[i].s.s));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define f first\\n#define s second\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        int q=queries.size();\\n        vector<int>ans(q,-1);\\n        vector<pair<int,pair<int,int>>>events;\\n        for(auto arr:intervals){\\n            int cost=arr[1]-arr[0]+1;\\n            events.push_back({arr[0],{1,cost}});\\n            events.push_back({arr[1],{3,cost}});\\n        }\\n        for(int i=0;i<q;i++){\\n            events.push_back({queries[i],{2,i}});\\n        }\\n        sort(events.begin(),events.end());\\n        multiset<int>ms; // maintains length of each active segment\\n        for(int i=0;i<events.size();i++){\\n            if(events[i].s.f==1){\\n                ms.insert(events[i].s.s);\\n            }else if(events[i].s.f==2){\\n                if(!ms.empty()){\\n                    ans[events[i].s.s]=*ms.begin();\\n                }\\n            }else{\\n                ms.erase(ms.find(events[i].s.s));\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3895354,
                "title": "kotlin-o-n-logn-q-logq-o-n-q",
                "content": "# Approach\\nSorting intervals and queries, then using min-heap to calculate sizes of the smallest intervals for queries.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*logn + q*logq)$$\\n\\n- Space complexity:\\n$$O(n + q)$$\\n\\n# Code\\n```\\nclass Solution {\\n\\n    fun minInterval(\\n        intervals: Array<IntArray>, queries: IntArray\\n    ): IntArray {\\n        val output = IntArray(queries.size)\\n        val heap = PriorityQueue<Pair<Int,Int>>(compareBy{ it.first })\\n        val sortedIntervals = intervals.sortedBy{ it[0] }\\n        val sortedQueries = queries\\n            .mapIndexed{index, it ->  Pair(index, it) }\\n            .sortedBy{ it.second }\\n        var i = 0\\n        for(query in sortedQueries){\\n            while(i < sortedIntervals.size\\n                && sortedIntervals[i][0] <= query.second\\n            ){\\n                val l = sortedIntervals[i][0]\\n                val r = sortedIntervals[i][1]\\n                heap.offer(Pair(r - l + 1, r))\\n                i += 1\\n            }\\n            while(!heap.isEmpty() \\n                && heap.peek().second < query.second\\n            ) heap.poll()\\n            output[query.first] = \\n                if(!heap.isEmpty()) heap.peek().first\\n                else - 1 \\n        }\\n        return output\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n\\n    fun minInterval(\\n        intervals: Array<IntArray>, queries: IntArray\\n    ): IntArray {\\n        val output = IntArray(queries.size)\\n        val heap = PriorityQueue<Pair<Int,Int>>(compareBy{ it.first })\\n        val sortedIntervals = intervals.sortedBy{ it[0] }\\n        val sortedQueries = queries\\n            .mapIndexed{index, it ->  Pair(index, it) }\\n            .sortedBy{ it.second }\\n        var i = 0\\n        for(query in sortedQueries){\\n            while(i < sortedIntervals.size\\n                && sortedIntervals[i][0] <= query.second\\n            ){\\n                val l = sortedIntervals[i][0]\\n                val r = sortedIntervals[i][1]\\n                heap.offer(Pair(r - l + 1, r))\\n                i += 1\\n            }\\n            while(!heap.isEmpty() \\n                && heap.peek().second < query.second\\n            ) heap.poll()\\n            output[query.first] = \\n                if(!heap.isEmpty()) heap.peek().first\\n                else - 1 \\n        }\\n        return output\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889071,
                "title": "java-priorityqueue-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.Arrays;\\nimport java.util.Comparator;\\nimport java.util.PriorityQueue;\\n\\nclass Solution {\\n\\tpublic int[] minInterval(int[][] intervals, int[] queries) {\\n\\t\\t\\n\\t\\tint m = queries.length;\\n\\t\\tint[][] arr = new int[m][2];\\n\\t\\tfor (int i=0;i<m;i++){\\n\\t\\t\\tarr[i][0]=queries[i];\\n\\t\\t\\tarr[i][1]=i;\\n\\t\\t}\\n\\t\\tArrays.sort(arr, new Comparator<int[]>() {\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic int compare(int[] o1, int[] o2) {\\n\\t\\t\\t\\treturn o1[0]-o2[0];\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\t\\n\\t\\tArrays.sort(intervals, new Comparator<int[]>() {\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic int compare(int[] o1, int[] o2) {\\n\\t\\t\\t\\treturn o1[0]-o2[0];\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tPriorityQueue<int[]> q = new PriorityQueue<>(new Comparator<int[]>() {\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic int compare(int[] o1, int[] o2) {\\n\\t\\t\\t\\treturn (o1[1]-o1[0])-(o2[1]-o2[0]);\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\t\\n\\t\\tint n = intervals.length;\\n\\t\\tint[]ans = new int[m];\\n\\t\\tint j=0;\\n\\t\\tfor (int i=0;i<m;i++){\\n\\t\\t\\t\\n\\t\\t\\twhile (!q.isEmpty()&&q.peek()[1]<arr[i][0]){\\n\\t\\t\\t\\tq.poll();\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\twhile (j<n){\\n\\t\\t\\t\\tif (intervals[j][0]<=arr[i][0]){\\n\\t\\t\\t\\t\\tq.add(intervals[j]);\\n\\t\\t\\t\\t\\tj++;\\t\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\twhile (!q.isEmpty()&&q.peek()[1]<arr[i][0]){\\n\\t\\t\\t\\tq.poll();\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (!q.isEmpty()) {\\n\\t\\t\\t\\tans[arr[i][1]] = q.peek()[1] - q.peek()[0] + 1;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tans[arr[i][1]]=-1;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.Arrays;\\nimport java.util.Comparator;\\nimport java.util.PriorityQueue;\\n\\nclass Solution {\\n\\tpublic int[] minInterval(int[][] intervals, int[] queries) {\\n\\t\\t\\n\\t\\tint m = queries.length;\\n\\t\\tint[][] arr = new int[m][2];\\n\\t\\tfor (int i=0;i<m;i++){\\n\\t\\t\\tarr[i][0]=queries[i];\\n\\t\\t\\tarr[i][1]=i;\\n\\t\\t}\\n\\t\\tArrays.sort(arr, new Comparator<int[]>() {\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic int compare(int[] o1, int[] o2) {\\n\\t\\t\\t\\treturn o1[0]-o2[0];\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\t\\n\\t\\tArrays.sort(intervals, new Comparator<int[]>() {\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic int compare(int[] o1, int[] o2) {\\n\\t\\t\\t\\treturn o1[0]-o2[0];\\n\\t\\t\\t}\\n\\t\\t});\\n\\n\\t\\tPriorityQueue<int[]> q = new PriorityQueue<>(new Comparator<int[]>() {\\n\\t\\t\\t@Override\\n\\t\\t\\tpublic int compare(int[] o1, int[] o2) {\\n\\t\\t\\t\\treturn (o1[1]-o1[0])-(o2[1]-o2[0]);\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\t\\n\\t\\tint n = intervals.length;\\n\\t\\tint[]ans = new int[m];\\n\\t\\tint j=0;\\n\\t\\tfor (int i=0;i<m;i++){\\n\\t\\t\\t\\n\\t\\t\\twhile (!q.isEmpty()&&q.peek()[1]<arr[i][0]){\\n\\t\\t\\t\\tq.poll();\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\twhile (j<n){\\n\\t\\t\\t\\tif (intervals[j][0]<=arr[i][0]){\\n\\t\\t\\t\\t\\tq.add(intervals[j]);\\n\\t\\t\\t\\t\\tj++;\\t\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\twhile (!q.isEmpty()&&q.peek()[1]<arr[i][0]){\\n\\t\\t\\t\\tq.poll();\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (!q.isEmpty()) {\\n\\t\\t\\t\\tans[arr[i][1]] = q.peek()[1] - q.peek()[0] + 1;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tans[arr[i][1]]=-1;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886561,
                "title": "typescript-beats-90-minheap-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass MinHeap {\\n    public heap;\\n    constructor() {\\n        this.heap = [];\\n    }\\n\\n    _heapifyUp(index: number) {\\n        while (index > 0) {\\n            const parentIndex: number = Math.floor((index - 1) / 2);\\n            if (this.heap[index][0] < this.heap[parentIndex][0]) {\\n                [this.heap[index], this.heap[parentIndex]] = [this.heap[parentIndex], this.heap[index]];\\n                index = parentIndex;\\n            } else {\\n                break;\\n            }\\n        }\\n    }\\n\\n    _heapifyDown(index: number) {\\n        while (index < this.heap.length) {\\n            const left: number = (index * 2) + 1;\\n            const right: number = (index * 2) + 2;\\n            let smallest = index;\\n            if (this.heap[left] && this.heap[left][0] < this.heap[smallest][0]) {\\n                smallest = left;\\n            }\\n            if (this.heap[right] && this.heap[right][0] < this.heap[smallest][0]) {\\n                smallest = right;\\n            }\\n            if (smallest !== index) {\\n                [this.heap[index], this.heap[smallest]] = [this.heap[smallest], this.heap[index]];\\n                index = smallest;\\n            } else {\\n                break;\\n            }\\n        }\\n    }\\n\\n    add(interval: number[]) {\\n        this.heap.push(interval);\\n        this._heapifyUp(this.heap.length - 1);\\n    }\\n\\n    remove() {\\n        [this.heap[0], this.heap[this.heap.length - 1]] = [this.heap[this.heap.length - 1], this.heap[0]];\\n        this.heap.pop();\\n        this._heapifyDown(0);\\n    }\\n\\n}\\n\\nfunction minInterval(intervals: number[][], queries: number[]): number[] {\\n    const result: number[] = [];\\n    intervals = intervals.sort((a, b) => a[0] - b[0]);\\n    const sortedQueries: number[] = [...queries].sort((a, b) => a - b);\\n    const minInterval = {};\\n    const minHeap = new MinHeap();\\n    let pointer: number = 0;\\n\\n    for (let i = 0; i < sortedQueries.length; i++) {\\n        const query: number = sortedQueries[i];\\n        if (minInterval[query]) {\\n            continue;\\n        }\\n\\n        while(pointer < intervals.length && intervals[pointer][1] < query) {\\n            pointer++;\\n        }\\n\\n        while (pointer < intervals.length && intervals[pointer][0] <= query) {\\n            minHeap.add([(intervals[pointer][1] - intervals[pointer][0]) + 1, intervals[pointer][1]])\\n            pointer++\\n        }\\n\\n        while (minHeap.heap.length > 0 && minHeap.heap[0][1] < query) {\\n            minHeap.remove();\\n        }\\n\\n        minInterval[query] = minHeap.heap.length !== 0 ? minHeap.heap[0][0] : -1;\\n    }\\n\\n    for (let i = 0; i < queries.length; i++) {\\n        result.push(minInterval[queries[i]]);\\n    }\\n\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass MinHeap {\\n    public heap;\\n    constructor() {\\n        this.heap = [];\\n    }\\n\\n    _heapifyUp(index: number) {\\n        while (index > 0) {\\n            const parentIndex: number = Math.floor((index - 1) / 2);\\n            if (this.heap[index][0] < this.heap[parentIndex][0]) {\\n                [this.heap[index], this.heap[parentIndex]] = [this.heap[parentIndex], this.heap[index]];\\n                index = parentIndex;\\n            } else {\\n                break;\\n            }\\n        }\\n    }\\n\\n    _heapifyDown(index: number) {\\n        while (index < this.heap.length) {\\n            const left: number = (index * 2) + 1;\\n            const right: number = (index * 2) + 2;\\n            let smallest = index;\\n            if (this.heap[left] && this.heap[left][0] < this.heap[smallest][0]) {\\n                smallest = left;\\n            }\\n            if (this.heap[right] && this.heap[right][0] < this.heap[smallest][0]) {\\n                smallest = right;\\n            }\\n            if (smallest !== index) {\\n                [this.heap[index], this.heap[smallest]] = [this.heap[smallest], this.heap[index]];\\n                index = smallest;\\n            } else {\\n                break;\\n            }\\n        }\\n    }\\n\\n    add(interval: number[]) {\\n        this.heap.push(interval);\\n        this._heapifyUp(this.heap.length - 1);\\n    }\\n\\n    remove() {\\n        [this.heap[0], this.heap[this.heap.length - 1]] = [this.heap[this.heap.length - 1], this.heap[0]];\\n        this.heap.pop();\\n        this._heapifyDown(0);\\n    }\\n\\n}\\n\\nfunction minInterval(intervals: number[][], queries: number[]): number[] {\\n    const result: number[] = [];\\n    intervals = intervals.sort((a, b) => a[0] - b[0]);\\n    const sortedQueries: number[] = [...queries].sort((a, b) => a - b);\\n    const minInterval = {};\\n    const minHeap = new MinHeap();\\n    let pointer: number = 0;\\n\\n    for (let i = 0; i < sortedQueries.length; i++) {\\n        const query: number = sortedQueries[i];\\n        if (minInterval[query]) {\\n            continue;\\n        }\\n\\n        while(pointer < intervals.length && intervals[pointer][1] < query) {\\n            pointer++;\\n        }\\n\\n        while (pointer < intervals.length && intervals[pointer][0] <= query) {\\n            minHeap.add([(intervals[pointer][1] - intervals[pointer][0]) + 1, intervals[pointer][1]])\\n            pointer++\\n        }\\n\\n        while (minHeap.heap.length > 0 && minHeap.heap[0][1] < query) {\\n            minHeap.remove();\\n        }\\n\\n        minInterval[query] = minHeap.heap.length !== 0 ? minHeap.heap[0][0] : -1;\\n    }\\n\\n    for (let i = 0; i < queries.length; i++) {\\n        result.push(minInterval[queries[i]]);\\n    }\\n\\n    return result;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3881088,
                "title": "beats-97-intuitive-yet-efficient-solution-explained",
                "content": "# Intuition\\nSince brute force approach results in O(mn) time complexity( where m is size of queries and n is size of intervals). Instead of looping through each interval for each query and taking minimum size, sort both intervals and queries and implement minheap.\\n# Approach\\nSort the intervals. For each query in sorted copy-queries add pair of values: size and end point of such interval which\\'s start value is less than current query. Because queries are now in ascending order, proccess only unvisited intervals for each next query. \\n\\nIn order to prevent assigning false minimum of interval which has less end point than query, i.e interval whcih doesn\\'t contain this query, pop from minheap each such interval\\'s pairs. Again, because queries are in sorted order, for each next query we don\\'t need any popped intervals before from minheap. \\n\\nFinally, to return minimum size for each query in original given order assign minsize for each query to query in hashmap (that\\'s why we didn\\'t change queries and loop through copy-sorted queries)\\n# Complexity\\n- Time complexity:\\nO(nlogn + mlogm) since we sorted both of them\\n- Space complexity:\\nO(n)\\n# Code\\n```\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        intervals.sort()\\n        minheap = []\\n        res={}\\n        i=0\\n\\n        for q in sorted(queries):\\n            while i<len(intervals) and intervals[i][0] <= q:\\n                l,r = intervals[i]\\n                heappush(minheap,(r-l+1,r))\\n                i+=1\\n\\n            while minheap and minheap[0][1]<q:\\n                heappop(minheap)\\n            \\n            res[q] = minheap[0][0] if minheap else -1\\n\\n        return [res[q] for q in queries]\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        intervals.sort()\\n        minheap = []\\n        res={}\\n        i=0\\n\\n        for q in sorted(queries):\\n            while i<len(intervals) and intervals[i][0] <= q:\\n                l,r = intervals[i]\\n                heappush(minheap,(r-l+1,r))\\n                i+=1\\n\\n            while minheap and minheap[0][1]<q:\\n                heappop(minheap)\\n            \\n            res[q] = minheap[0][0] if minheap else -1\\n\\n        return [res[q] for q in queries]\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838961,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        vector<int> sortedQueries = queries; \\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        unordered_map<int,int> m;\\n        sort(intervals.begin(),intervals.end());\\n        sort(sortedQueries.begin(),sortedQueries.end());\\n        vector<int> result;\\n        int i = 0;\\n        for(int j=0; j<sortedQueries.size(); j++){\\n            int query = sortedQueries[j];\\n            while(i<intervals.size() && intervals[i][0]<=query){\\n                int left = intervals[i][0];\\n                int right = intervals[i][1];\\n                pq.push({right-left+1,right});\\n                i++;\\n            }\\n            while(!pq.empty() && pq.top().second<query){\\n                pq.pop();\\n            }\\n            if(!pq.empty()){\\n                m[query] = pq.top().first;\\n            }\\n            else{\\n                m[query] = -1;\\n            }\\n        }\\n        for(int j=0; j<queries.size(); j++){\\n            result.push_back(m[queries[j]]);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        vector<int> sortedQueries = queries; \\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        unordered_map<int,int> m;\\n        sort(intervals.begin(),intervals.end());\\n        sort(sortedQueries.begin(),sortedQueries.end());\\n        vector<int> result;\\n        int i = 0;\\n        for(int j=0; j<sortedQueries.size(); j++){\\n            int query = sortedQueries[j];\\n            while(i<intervals.size() && intervals[i][0]<=query){\\n                int left = intervals[i][0];\\n                int right = intervals[i][1];\\n                pq.push({right-left+1,right});\\n                i++;\\n            }\\n            while(!pq.empty() && pq.top().second<query){\\n                pq.pop();\\n            }\\n            if(!pq.empty()){\\n                m[query] = pq.top().first;\\n            }\\n            else{\\n                m[query] = -1;\\n            }\\n        }\\n        for(int j=0; j<queries.size(); j++){\\n            result.push_back(m[queries[j]]);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835443,
                "title": "beats-100-solutions-in-js",
                "content": "# Intuition\\nUse a PriorityQueue and sort both intervals and queries. If the query is included in the interval we add the interval to the PriorityQueue and move on to the next interval until the query is not included anymore in the interval. \\n\\n\\n# Approach\\nSort both intervals and queries. Then traverse them and using two pointers (one for the intervals and one for the queries). Check if the query is included in the interval and keep adding intervals to a PriorityQueue. If the interval is not enclosing the query then it\\'s time to move query\\'s pointer forward and repeat the previous step.\\nThe hashmap is used so that we can then respect the order of the original queries in the final output.\\n\\n# Complexity\\n- Time complexity:\\nO(n log n + q log q)\\n\\n- Space complexity:\\nO(n+q)\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} intervals\\n * @param {number[]} queries\\n * @return {number[]}\\n */\\nvar minInterval = function(intervals, queries) {\\n\\n    intervals.sort( (a,b) => {\\n        if(a[0] != b[0]){\\n            return a[0]-b[0];\\n        }else{\\n            return a[1]-b[1];\\n        }\\n    });\\n\\n    let heap = new PriorityQueue({compare: (a,b) => {\\n\\n        if( (a[0])!=(b[0])){\\n            return (a[0] - b[0]);\\n        }else{\\n            return (a[1] - b[1]);\\n        }\\n\\n    }});\\n\\n\\n    let sortedQ = [...queries];\\n\\n    sortedQ.sort( (a,b) => a-b);\\n\\n\\n    let m = new Map();\\n\\n    let res = [];\\n\\n    let q = 0;\\n    let i = 0;\\n\\n    // console.log(`Sorted Q: ${sortedQ}`);\\n    // console.log(`Sorted INTER:`);\\n    // console.log(intervals);\\n\\n    while(q<sortedQ.length){\\n\\n        while(i<intervals.length && sortedQ[q]>=intervals[i][0]){\\n\\n            let len = intervals[i][1] - intervals[i][0] +1;\\n            let r = intervals[i][1];\\n            heap.enqueue([len,r]);\\n            i+=1;\\n            // console.log(\"HEAP: \");\\n            // console.log(heap.toArray())\\n        }\\n        // console.log(heap.front());\\n        while(heap.size() > 0 && heap.front()[1]<sortedQ[q]){\\n            heap.dequeue();\\n        }\\n        if(heap.size()>0){\\n            m.set(sortedQ[q],heap.front()[0]);\\n        }\\n        q+=1;\\n    }\\n\\n    for(let q of queries){\\n        if(m.has(q)){\\n            res.push(m.get(q));\\n        }else{\\n            res.push(-1);\\n        }\\n        \\n    }\\n\\n    return res;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} intervals\\n * @param {number[]} queries\\n * @return {number[]}\\n */\\nvar minInterval = function(intervals, queries) {\\n\\n    intervals.sort( (a,b) => {\\n        if(a[0] != b[0]){\\n            return a[0]-b[0];\\n        }else{\\n            return a[1]-b[1];\\n        }\\n    });\\n\\n    let heap = new PriorityQueue({compare: (a,b) => {\\n\\n        if( (a[0])!=(b[0])){\\n            return (a[0] - b[0]);\\n        }else{\\n            return (a[1] - b[1]);\\n        }\\n\\n    }});\\n\\n\\n    let sortedQ = [...queries];\\n\\n    sortedQ.sort( (a,b) => a-b);\\n\\n\\n    let m = new Map();\\n\\n    let res = [];\\n\\n    let q = 0;\\n    let i = 0;\\n\\n    // console.log(`Sorted Q: ${sortedQ}`);\\n    // console.log(`Sorted INTER:`);\\n    // console.log(intervals);\\n\\n    while(q<sortedQ.length){\\n\\n        while(i<intervals.length && sortedQ[q]>=intervals[i][0]){\\n\\n            let len = intervals[i][1] - intervals[i][0] +1;\\n            let r = intervals[i][1];\\n            heap.enqueue([len,r]);\\n            i+=1;\\n            // console.log(\"HEAP: \");\\n            // console.log(heap.toArray())\\n        }\\n        // console.log(heap.front());\\n        while(heap.size() > 0 && heap.front()[1]<sortedQ[q]){\\n            heap.dequeue();\\n        }\\n        if(heap.size()>0){\\n            m.set(sortedQ[q],heap.front()[0]);\\n        }\\n        q+=1;\\n    }\\n\\n    for(let q of queries){\\n        if(m.has(q)){\\n            res.push(m.get(q));\\n        }else{\\n            res.push(-1);\\n        }\\n        \\n    }\\n\\n    return res;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3829969,
                "title": "beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(m*logm+ n*logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        q=[]\\n        heapq.heapify(q)\\n        intervals.sort()\\n        out={}\\n        i=0\\n        for each in sorted(queries):\\n            while q and q[0][1]<each:\\n                    heapq.heappop(q)\\n            while i<len(intervals) and intervals[i][0]<=each:\\n                start,end = intervals[i]\\n                if end>=each:\\n                    heapq.heappush(q,(end-start+1,end))\\n                i+=1\\n\\n            out[each]=q[0][0] if q else -1\\n        return [out[each] for each in queries]\\n\\n            \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        q=[]\\n        heapq.heapify(q)\\n        intervals.sort()\\n        out={}\\n        i=0\\n        for each in sorted(queries):\\n            while q and q[0][1]<each:\\n                    heapq.heappop(q)\\n            while i<len(intervals) and intervals[i][0]<=each:\\n                start,end = intervals[i]\\n                if end>=each:\\n                    heapq.heappush(q,(end-start+1,end))\\n                i+=1\\n\\n            out[each]=q[0][0] if q else -1\\n        return [out[each] for each in queries]\\n\\n            \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824642,
                "title": "using-sort-heap-with-comments",
                "content": "# Intuition\\n\\n\\n# Approach\\n\\n# Complexity\\n- Time complexity:\\n\\n- Space complexity:\\n\\n# Code\\n```\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        intervals.sort()\\n        result = [-1] * len(queries)\\n        # for processing we want the queries to be sorted, but then we need to keep track of the respected index of the\\n        # original queries list to put the result in the proper position\\n        queries_sorted = sorted([(query, index) for index, query in enumerate(queries)])\\n        heap = []  # We use heapq ... which has at the TOP of the heap always the SMALLEST value\\n        interval_index = 0\\n        for each_query, query_index in queries_sorted:\\n\\n            # push all intervals with START time <= query onto the heap\\n            while interval_index < len(intervals) and intervals[interval_index][0] <= each_query:\\n                start = intervals[interval_index][0]\\n                end = intervals[interval_index][1]\\n                duration = end - start + 1\\n                heapq.heappush(heap, (duration, end))\\n                interval_index += 1\\n\\n            # The heap has now a list of all the potential candidates based on START time\\n            # The heap has at the TOP the smallest duration interval\\n            # Now we just need to make sure that the query is less than the END time of the interval\\n            # otherwise we remove (POP) the candidate\\n            while len(heap) and heap[0][1] < each_query:  # Is the END of the interval < each_query ?\\n                heapq.heappop(heap)\\n\\n            # the TOP entry on the heap is now the interval with start <= query <= end and the shortest duration\\n            if len(heap):\\n                duration = heap[0][0]  \\n                result[query_index] = duration\\n\\n            # we initially initialized the result array with -1 ... no need to update in case we do NOT have a match\\n            \\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        intervals.sort()\\n        result = [-1] * len(queries)\\n        # for processing we want the queries to be sorted, but then we need to keep track of the respected index of the\\n        # original queries list to put the result in the proper position\\n        queries_sorted = sorted([(query, index) for index, query in enumerate(queries)])\\n        heap = []  # We use heapq ... which has at the TOP of the heap always the SMALLEST value\\n        interval_index = 0\\n        for each_query, query_index in queries_sorted:\\n\\n            # push all intervals with START time <= query onto the heap\\n            while interval_index < len(intervals) and intervals[interval_index][0] <= each_query:\\n                start = intervals[interval_index][0]\\n                end = intervals[interval_index][1]\\n                duration = end - start + 1\\n                heapq.heappush(heap, (duration, end))\\n                interval_index += 1\\n\\n            # The heap has now a list of all the potential candidates based on START time\\n            # The heap has at the TOP the smallest duration interval\\n            # Now we just need to make sure that the query is less than the END time of the interval\\n            # otherwise we remove (POP) the candidate\\n            while len(heap) and heap[0][1] < each_query:  # Is the END of the interval < each_query ?\\n                heapq.heappop(heap)\\n\\n            # the TOP entry on the heap is now the interval with start <= query <= end and the shortest duration\\n            if len(heap):\\n                duration = heap[0][0]  \\n                result[query_index] = duration\\n\\n            # we initially initialized the result array with -1 ... no need to update in case we do NOT have a match\\n            \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3800995,
                "title": "o-nlogn-time-o-n-space-solution-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse min heap (priority queue).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- sort intervals according to the start time\\n- create a list for min heap\\n- set result res = empty hashmap\\n- set i = 0 to track the interval index\\n- for each query q in sorted queries\\n    - while there are intervals to process and the interval is valid i,e current interval start time <= q\\n        - get the start time l and end time r of the current interval\\n        - add (size, end time) of the interval to the heap\\n        - increment i\\n    - while the heap is not empty and the interval is not valid i.e heap top interval end time < q, pop interval\\n    - add the minimum interval (heap top interval size) for the query in the hashmap res\\n- add the min interval for each query at its index and return the result.\\n\\n# Complexity\\n- Time complexity: O(sort(intervals) + sort(queries) + qlogn) \\u2192 O(nlogn + qlogq + qlogn) \\u2192 O(nlogn)\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(sort + heap) \\u2192 O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        intervals.sort()\\n        min_heap = []\\n        res = {}\\n        i = 0\\n        for q in sorted(queries):\\n            while i < len(intervals) and intervals[i][0] <= q:\\n                l, r = intervals[i]\\n                heapq.heappush(min_heap, (r - l + 1, r))\\n                i += 1\\n            while min_heap and min_heap[0][1] < q:\\n                heapq.heappop(min_heap)\\n            res[q] = min_heap[0][0] if min_heap else -1\\n        return [res[q] for q in queries]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        intervals.sort()\\n        min_heap = []\\n        res = {}\\n        i = 0\\n        for q in sorted(queries):\\n            while i < len(intervals) and intervals[i][0] <= q:\\n                l, r = intervals[i]\\n                heapq.heappush(min_heap, (r - l + 1, r))\\n                i += 1\\n            while min_heap and min_heap[0][1] < q:\\n                heapq.heappop(min_heap)\\n            res[q] = min_heap[0][0] if min_heap else -1\\n        return [res[q] for q in queries]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3728471,
                "title": "fully-explained-priority-queue",
                "content": "# Intuition\\nBasically in this problem we will check all intervals in which queries is occuring and we will output the minimum one.\\n\\n# Approach\\nWe will use priority queue for checking each interval.If it is in range we will push till then,after then we will check if it got out of range then we will pop the element.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& v, vector<int>& queries) {\\n        int n=queries.size();\\n        vector<int> ans(n,-1);\\n        sort(v.begin(),v.end());\\n\\n        vector<pair<int,int>> q(n);\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            q[i]={queries[i],i};\\n        }\\n        \\n        sort(q.begin(),q.end());\\n\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n\\n         for(int i=0,j=0;i<q.size();i++)\\n          {\\n            while(j<v.size() && v[j][0]<=q[i].first)\\n            {\\n                pq.push({v[j][1]-v[j][0]+1,v[j][1]});\\n                j++;\\n            }\\n            while(pq.size() && pq.top().second<q[i].first)\\n            {\\n                pq.pop();\\n            }\\n\\n            if(pq.size()!=0)\\n            {\\n                ans[q[i].second]=pq.top().first;\\n            }\\n            else\\n            {\\n                ans[q[i].second]=-1;\\n            }\\n        }\\n     return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& v, vector<int>& queries) {\\n        int n=queries.size();\\n        vector<int> ans(n,-1);\\n        sort(v.begin(),v.end());\\n\\n        vector<pair<int,int>> q(n);\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            q[i]={queries[i],i};\\n        }\\n        \\n        sort(q.begin(),q.end());\\n\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n\\n         for(int i=0,j=0;i<q.size();i++)\\n          {\\n            while(j<v.size() && v[j][0]<=q[i].first)\\n            {\\n                pq.push({v[j][1]-v[j][0]+1,v[j][1]});\\n                j++;\\n            }\\n            while(pq.size() && pq.top().second<q[i].first)\\n            {\\n                pq.pop();\\n            }\\n\\n            if(pq.size()!=0)\\n            {\\n                ans[q[i].second]=pq.top().first;\\n            }\\n            else\\n            {\\n                ans[q[i].second]=-1;\\n            }\\n        }\\n     return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3698375,
                "title": "min-heap-solution",
                "content": "# Intuition\\nUse a min heap that keeps the possible intervals that the query can use. For every new query update the min-heap so that it just contains a window of the possible intervals. The min heap should be ordered on the size of the intervals. That way, when you take the top of the heap, it will contain the smallest interval.\\n\\n# Approach\\n1. Order the intervals by increasing starting order (you can also put it into a queue for efficient element removal). This will allow you to know what intervals should be added to heap (starting value is less than the query, and can therefore contain the value).\\n2. Sort the queries in increasing order. This is because you want to make sure that the next query that you use does not need a interval that you may have already popped from the min-heap. By sorting in increasing order, you ensure that the interval that contains the query is already inside the min-heap, or is in the rest of the intervals queue. You can also attach the original index to the query in order to allow you to return the results in order. \\n3. Iterate through each of the queries. While the intervals have a start that is less than the interval, push the interval into the heap. While the top of the heap has a end that is less than the interval pop from the heap. By doing this, you are first validating that the interval has a start that is less than the query (and a start that will be less than all future queries). Then you are validating that the interval you are choosing has an end that contains your query. You can pop any ends that do not contain your query, because it is also sure not to contain any of the future queries.\\n\\n# Complexity\\n$$n$$ -> `intervals.len()`\\n$$m$$ -> `queries.len()`\\n\\n- Time complexity:\\n  Overall -> $$O(nlog(n) + mlog(m))$$\\n  1. Sort intervals -> $$O(nlog(n))$$\\n  2. Sort queries -> $$O(mlog(m))$$\\n  3. Iterate through queries and push/pop interval from the min-heap $$O(nlog(n))$$. In the worst case, all intervals will be pushed/popped once. This is not dependent on the amount of queries, because there can be multiple pushes and pops per query.\\n\\n- Space complexity:\\n$$O(n)$$ for the min-heap, and $$O(m)$$ for the sorted queries -> $$O(n + m)$$\\n\\n# Code\\n```\\nuse std::collections::BinaryHeap;\\nuse std::collections::HashMap;\\nuse std::collections::VecDeque;\\n\\n#[derive(Debug, Eq, PartialEq)]\\nstruct Interval(i32, i32);\\n\\nimpl Ord for Interval {\\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\\n        ((other.0 - other.1).abs()).cmp(&(self.0 - self.1).abs())\\n    }\\n}\\n\\nimpl PartialOrd for Interval {\\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\\n        Some(self.cmp(other))\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn min_interval(intervals: Vec<Vec<i32>>, queries: Vec<i32>) -> Vec<i32> {\\n        let mut intervals = intervals;\\n        intervals.sort_by_key(|v| (v[0], v[1]));\\n        let mut intervals: VecDeque<Interval> =\\n            intervals.iter().map(|v| Interval(v[0], v[1])).collect();\\n        let mut queries: Vec<(i32, usize)> =\\n            queries.iter().enumerate().map(|(i, e)| (*e, i)).collect();\\n        queries.sort_by_key(|&(item, _)| item);\\n\\n        let mut res = vec![-1; queries.len()];\\n        let mut interval_heap: BinaryHeap<Interval> = BinaryHeap::new();\\n        for (q, i) in queries.iter() {\\n            while intervals.len() > 0 && intervals.front().unwrap().0 <= *q {\\n                interval_heap.push(intervals.pop_front().unwrap());\\n            }\\n            while interval_heap.len() > 0 && interval_heap.peek().unwrap().1 < *q {\\n                interval_heap.pop();\\n            }\\n\\n            match interval_heap.peek() {\\n                Some(v) => {\\n                    res[*i] = v.1 - v.0 + 1;\\n                }\\n                None => res[*i] = -1,\\n            }\\n        }\\n        res\\n    }\\n}\\n\\n```\\n",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::BinaryHeap;\\nuse std::collections::HashMap;\\nuse std::collections::VecDeque;\\n\\n#[derive(Debug, Eq, PartialEq)]\\nstruct Interval(i32, i32);\\n\\nimpl Ord for Interval {\\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\\n        ((other.0 - other.1).abs()).cmp(&(self.0 - self.1).abs())\\n    }\\n}\\n\\nimpl PartialOrd for Interval {\\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\\n        Some(self.cmp(other))\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn min_interval(intervals: Vec<Vec<i32>>, queries: Vec<i32>) -> Vec<i32> {\\n        let mut intervals = intervals;\\n        intervals.sort_by_key(|v| (v[0], v[1]));\\n        let mut intervals: VecDeque<Interval> =\\n            intervals.iter().map(|v| Interval(v[0], v[1])).collect();\\n        let mut queries: Vec<(i32, usize)> =\\n            queries.iter().enumerate().map(|(i, e)| (*e, i)).collect();\\n        queries.sort_by_key(|&(item, _)| item);\\n\\n        let mut res = vec![-1; queries.len()];\\n        let mut interval_heap: BinaryHeap<Interval> = BinaryHeap::new();\\n        for (q, i) in queries.iter() {\\n            while intervals.len() > 0 && intervals.front().unwrap().0 <= *q {\\n                interval_heap.push(intervals.pop_front().unwrap());\\n            }\\n            while interval_heap.len() > 0 && interval_heap.peek().unwrap().1 < *q {\\n                interval_heap.pop();\\n            }\\n\\n            match interval_heap.peek() {\\n                Some(v) => {\\n                    res[*i] = v.1 - v.0 + 1;\\n                }\\n                None => res[*i] = -1,\\n            }\\n        }\\n        res\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3671880,
                "title": "scala-iterative-solution",
                "content": "# Intuition\\nTBA\\n\\n# Approach\\nTBA\\n\\n# Complexity\\n- Time complexity:\\nO(n log n) + O(m log m)\\n\\n- Space complexity:\\nO(n) + O(m)\\n\\n# Code\\n```\\nimport scala.collection.mutable\\n\\nobject Solution {\\n    object ByLengthAndEndAsc extends Ordering[(Int, Int)] {\\n        def compare(a: (Int,Int), b: (Int, Int)) = {\\n            // if length is equal we pick interval that ends earlier\\n            if(a._1 == b._1) {\\n                b._2 compare a._2\\n            } else {\\n                b._1 compare a._1\\n            }\\n        }\\n    }\\n\\n    def minInterval(intervals: Array[Array[Int]], queries: Array[Int]): Array[Int] = {\\n        intervals.sortInPlaceWith {\\n            case (Array(s1,e1),Array(s2,e2)) => s1 < s2\\n        }\\n        val sortedQueries = queries.sortWith {\\n            case (a, b) => a < b\\n        }\\n        val bestIntervalsSoFar = mutable.PriorityQueue.empty[(Int, Int)](ByLengthAndEndAsc)\\n        var queryId = 0\\n        var intervalId = 0\\n        val results = mutable.Map.empty[Int, Int]\\n        while(queryId < sortedQueries.length && intervalId < intervals.length) {\\n            // remove intervals that got passed\\n            while(bestIntervalsSoFar.headOption.exists(_._2 < sortedQueries(queryId))) {\\n                bestIntervalsSoFar.dequeue()\\n            }\\n            intervals(intervalId) match {\\n                // interval intersects with query\\n                case Array(start, end) if sortedQueries(queryId) >= start && sortedQueries(queryId) <= end =>\\n                    bestIntervalsSoFar.enqueue((end - start + 1, end))\\n                    intervalId += 1\\n                // interval is ahead, try next query\\n                case Array(start, end) if start > sortedQueries(queryId) =>\\n                    results(sortedQueries(queryId)) = bestIntervalsSoFar.headOption.map(_._1).getOrElse(-1)\\n                    queryId += 1\\n                // interval is behind, skip it\\n                case Array(start, end) =>\\n                    intervalId += 1\\n            }\\n        }\\n        // if all intervals are over but we still have queries process them\\n        while(queryId < sortedQueries.length) {\\n            // remove intervals that got passed\\n            while(bestIntervalsSoFar.headOption.exists(_._2 < sortedQueries(queryId))) {\\n                bestIntervalsSoFar.dequeue()\\n            }\\n            results(sortedQueries(queryId)) = bestIntervalsSoFar.headOption.map(_._1).getOrElse(-1)\\n            queryId += 1\\n        }\\n        queries.map {\\n            v => results(v)\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nimport scala.collection.mutable\\n\\nobject Solution {\\n    object ByLengthAndEndAsc extends Ordering[(Int, Int)] {\\n        def compare(a: (Int,Int), b: (Int, Int)) = {\\n            // if length is equal we pick interval that ends earlier\\n            if(a._1 == b._1) {\\n                b._2 compare a._2\\n            } else {\\n                b._1 compare a._1\\n            }\\n        }\\n    }\\n\\n    def minInterval(intervals: Array[Array[Int]], queries: Array[Int]): Array[Int] = {\\n        intervals.sortInPlaceWith {\\n            case (Array(s1,e1),Array(s2,e2)) => s1 < s2\\n        }\\n        val sortedQueries = queries.sortWith {\\n            case (a, b) => a < b\\n        }\\n        val bestIntervalsSoFar = mutable.PriorityQueue.empty[(Int, Int)](ByLengthAndEndAsc)\\n        var queryId = 0\\n        var intervalId = 0\\n        val results = mutable.Map.empty[Int, Int]\\n        while(queryId < sortedQueries.length && intervalId < intervals.length) {\\n            // remove intervals that got passed\\n            while(bestIntervalsSoFar.headOption.exists(_._2 < sortedQueries(queryId))) {\\n                bestIntervalsSoFar.dequeue()\\n            }\\n            intervals(intervalId) match {\\n                // interval intersects with query\\n                case Array(start, end) if sortedQueries(queryId) >= start && sortedQueries(queryId) <= end =>\\n                    bestIntervalsSoFar.enqueue((end - start + 1, end))\\n                    intervalId += 1\\n                // interval is ahead, try next query\\n                case Array(start, end) if start > sortedQueries(queryId) =>\\n                    results(sortedQueries(queryId)) = bestIntervalsSoFar.headOption.map(_._1).getOrElse(-1)\\n                    queryId += 1\\n                // interval is behind, skip it\\n                case Array(start, end) =>\\n                    intervalId += 1\\n            }\\n        }\\n        // if all intervals are over but we still have queries process them\\n        while(queryId < sortedQueries.length) {\\n            // remove intervals that got passed\\n            while(bestIntervalsSoFar.headOption.exists(_._2 < sortedQueries(queryId))) {\\n                bestIntervalsSoFar.dequeue()\\n            }\\n            results(sortedQueries(queryId)) = bestIntervalsSoFar.headOption.map(_._1).getOrElse(-1)\\n            queryId += 1\\n        }\\n        queries.map {\\n            v => results(v)\\n        }\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3668855,
                "title": "simple-solution-heap-sorting",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        vector<int>cquery=queries;\\n        sort(intervals.begin(),intervals.end());\\n        sort(queries.begin(),queries.end());\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        unordered_map<int,int>m;\\n        int i=0;\\n        int n=intervals.size();\\n        vector<int>ans;\\n        for(auto q:queries){\\n            while(i<n && intervals[i][0]<=q){\\n                int l=intervals[i][0];\\n                int r=intervals[i][1];\\n                pq.push({r-l+1,r});\\n                i++;\\n            }\\n            while(!pq.empty() && pq.top().second<q){\\n                pq.pop();\\n            }\\n            if(pq.size()){\\n                m[q]=pq.top().first;\\n            }\\n            else{\\n                m[q]=-1;\\n            }\\n        }\\n        for(auto q:cquery){\\n            ans.push_back(m[q]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Line Sweep",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        vector<int>cquery=queries;\\n        sort(intervals.begin(),intervals.end());\\n        sort(queries.begin(),queries.end());\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>pq;\\n        unordered_map<int,int>m;\\n        int i=0;\\n        int n=intervals.size();\\n        vector<int>ans;\\n        for(auto q:queries){\\n            while(i<n && intervals[i][0]<=q){\\n                int l=intervals[i][0];\\n                int r=intervals[i][1];\\n                pq.push({r-l+1,r});\\n                i++;\\n            }\\n            while(!pq.empty() && pq.top().second<q){\\n                pq.pop();\\n            }\\n            if(pq.size()){\\n                m[q]=pq.top().first;\\n            }\\n            else{\\n                m[q]=-1;\\n            }\\n        }\\n        for(auto q:cquery){\\n            ans.push_back(m[q]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651942,
                "title": "scala-treemap-linesweep",
                "content": "# Code\\n```\\nobject Solution {\\n  import scala.collection.immutable.TreeMap\\n\\n  sealed trait Event\\n  case class Begin(at: Int, size: Int) extends Event\\n  case class End(at: Int, size: Int) extends Event\\n  case class Query(at: Int, index: Int) extends Event\\n\\n  implicit val ord: Ordering[Event] =\\n    Ordering.by {\\n      case Begin(at, _) => (at, 0)\\n      case Query(at, _) => (at, 1)\\n      case End(at, _) => (at, 2)\\n    }\\n\\n  def minInterval(intervals: Array[Array[Int]], queries: Array[Int]): Array[Int] = {\\n    val iEvents = intervals.collect { case Array(begin, end) =>\\n      val size = end - begin + 1\\n      Array(Begin(begin, size), End(end, size))\\n    }\\n    val qEvents = queries.zipWithIndex.map { case (at, ind) => Query(at, ind) }\\n    val events: List[Event] = (iEvents.flatten ++ qEvents).toList\\n    go(events.sorted, TreeMap.empty, List.empty).toArray\\n  }\\n\\n  def go(events: List[Event], qs: TreeMap[Int, Int], acc: List[(Int, Int)]): List[Int] =\\n    events match {\\n      case Nil => acc.sorted.map(_._2)\\n      case Begin(_, size) :: tail => go(tail, qs.updated(size, qs.getOrElse(size, 0) + 1), acc)\\n      case Query(_, index) :: tail => go(tail, qs, (index, qs.headOption.fold(-1)(_._1)) :: acc)\\n      case End(_, size) :: tail =>\\n        val sizes = qs(size)\\n        go(tail, if (sizes <= 1) qs.removed(size) else qs.updated(size, sizes - 1), acc)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  import scala.collection.immutable.TreeMap\\n\\n  sealed trait Event\\n  case class Begin(at: Int, size: Int) extends Event\\n  case class End(at: Int, size: Int) extends Event\\n  case class Query(at: Int, index: Int) extends Event\\n\\n  implicit val ord: Ordering[Event] =\\n    Ordering.by {\\n      case Begin(at, _) => (at, 0)\\n      case Query(at, _) => (at, 1)\\n      case End(at, _) => (at, 2)\\n    }\\n\\n  def minInterval(intervals: Array[Array[Int]], queries: Array[Int]): Array[Int] = {\\n    val iEvents = intervals.collect { case Array(begin, end) =>\\n      val size = end - begin + 1\\n      Array(Begin(begin, size), End(end, size))\\n    }\\n    val qEvents = queries.zipWithIndex.map { case (at, ind) => Query(at, ind) }\\n    val events: List[Event] = (iEvents.flatten ++ qEvents).toList\\n    go(events.sorted, TreeMap.empty, List.empty).toArray\\n  }\\n\\n  def go(events: List[Event], qs: TreeMap[Int, Int], acc: List[(Int, Int)]): List[Int] =\\n    events match {\\n      case Nil => acc.sorted.map(_._2)\\n      case Begin(_, size) :: tail => go(tail, qs.updated(size, qs.getOrElse(size, 0) + 1), acc)\\n      case Query(_, index) :: tail => go(tail, qs, (index, qs.headOption.fold(-1)(_._1)) :: acc)\\n      case End(_, size) :: tail =>\\n        val sizes = qs(size)\\n        go(tail, if (sizes <= 1) qs.removed(size) else qs.updated(size, sizes - 1), acc)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615249,
                "title": "line-sweep-using-small-to-large-merging-on-heap",
                "content": "```\\nimport bisect\\n\\nclass Heap:\\n    def __init__(self):\\n        self.heap = []\\n        self.deleted = defaultdict(int)\\n\\n    def push(self, val):\\n        heapq.heappush(self.heap, val)\\n\\n    def clean(self):\\n        while len(self.heap) > 0 and self.heap[0] in self.deleted:\\n            self.deleted[self.heap[0]] -= 1\\n            if self.deleted[self.heap[0]] == 0:\\n                del self.deleted[self.heap[0]]\\n            heapq.heappop(self.heap)\\n\\n    def __len__(self):\\n        self.clean()\\n        return len(self.heap)\\n    \\n    def min(self):\\n        self.clean()\\n        return self.heap[0]\\n    \\n    def __repr__(self):\\n        return str(self.deleted)\\n    \\n    def delete(self, val):\\n        self.deleted[val] += 1\\n\\n    def pop(self):\\n        self.clean()\\n        return heapq.heappop(self.heap)\\n\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        n = len(intervals)\\n        q = len(queries)\\n        intervals.sort(key = lambda x: x[0] - x[1])\\n        for i in range(q):\\n            queries[i] = (queries[i], i)\\n        queries.sort()\\n        res = [-1] * q\\n        adds = [Heap() for _ in range(q + 1)]\\n        dels = [Heap() for _ in range(q + 1)]\\n        for a, b in intervals:\\n            i = bisect.bisect_left(queries, (a, float(\\'-inf\\')))\\n            j = bisect.bisect_right(queries, (b, float(\\'inf\\')))\\n            adds[i].push(b - a + 1)\\n            dels[j].push(b - a + 1)\\n        curr = Heap()\\n        for i in range(q):\\n            if len(adds[i]) > len(curr):\\n                curr, adds[i] = adds[i], curr\\n            while len(adds[i]) > 0:\\n                curr.push(adds[i].pop())\\n            if len(dels[i]) > len(curr):\\n                curr, dels[i] = dels[i], curr\\n            while len(dels[i]) > 0:\\n                curr.delete(dels[i].pop())\\n            res[queries[i][1]] = curr.min() if len(curr) > 0 else -1\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport bisect\\n\\nclass Heap:\\n    def __init__(self):\\n        self.heap = []\\n        self.deleted = defaultdict(int)\\n\\n    def push(self, val):\\n        heapq.heappush(self.heap, val)\\n\\n    def clean(self):\\n        while len(self.heap) > 0 and self.heap[0] in self.deleted:\\n            self.deleted[self.heap[0]] -= 1\\n            if self.deleted[self.heap[0]] == 0:\\n                del self.deleted[self.heap[0]]\\n            heapq.heappop(self.heap)\\n\\n    def __len__(self):\\n        self.clean()\\n        return len(self.heap)\\n    \\n    def min(self):\\n        self.clean()\\n        return self.heap[0]\\n    \\n    def __repr__(self):\\n        return str(self.deleted)\\n    \\n    def delete(self, val):\\n        self.deleted[val] += 1\\n\\n    def pop(self):\\n        self.clean()\\n        return heapq.heappop(self.heap)\\n\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        n = len(intervals)\\n        q = len(queries)\\n        intervals.sort(key = lambda x: x[0] - x[1])\\n        for i in range(q):\\n            queries[i] = (queries[i], i)\\n        queries.sort()\\n        res = [-1] * q\\n        adds = [Heap() for _ in range(q + 1)]\\n        dels = [Heap() for _ in range(q + 1)]\\n        for a, b in intervals:\\n            i = bisect.bisect_left(queries, (a, float(\\'-inf\\')))\\n            j = bisect.bisect_right(queries, (b, float(\\'inf\\')))\\n            adds[i].push(b - a + 1)\\n            dels[j].push(b - a + 1)\\n        curr = Heap()\\n        for i in range(q):\\n            if len(adds[i]) > len(curr):\\n                curr, adds[i] = adds[i], curr\\n            while len(adds[i]) > 0:\\n                curr.push(adds[i].pop())\\n            if len(dels[i]) > len(curr):\\n                curr, dels[i] = dels[i], curr\\n            while len(dels[i]) > 0:\\n                curr.delete(dels[i].pop())\\n            res[queries[i][1]] = curr.min() if len(curr) > 0 else -1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579395,
                "title": "concise-98-7-runtime-solution-with-key-optimisations",
                "content": "# Approach\\n- For the most part there isnt much algorithm variety in the solutions for this problem. But you can make it faster with some key optimisation\\n    1. Take advantage of the fact that duplicate queries will have the same result by skipping duplicates and using the cached lengths to reconstruct the solution. This reduces the search space.\\n    2. This one may be language specific, if anyone has a technical definition for why this is do explain. Theres no need to keep track of an intervals pointer, python can construct a deque from a list fairly quickly so simply popping intervals from the start results in a concise and more efficient solution (you would think simply incrementing a pointer and doing one check would be faster than a pop operation?)\\n    3. Another language specific one but not at all important for anything othere than this website. Leetcode excepts generator expression as an answer in place of a list. I suspect this is because a type cast is done during evaluation so simply returning a generator with () instead of constructiong a list offloads some of the overhead and makes any list returning solution slightly faster\\n\\n# Complexity\\n- Time complexity: nlogn\\n- Space complexity: n (for both intervals and queries)\\n\\n# Code\\n```\\nfrom collections import deque\\nimport heapq\\n\\n\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        intervals = deque(sorted(intervals, key=lambda x: x[0]))\\n        cache = {} # query -> min interval length\\n        pq = []\\n\\n        for query in sorted(set(queries)):\\n            while intervals and intervals[0][0] <= query:\\n                l, r = intervals.popleft() # pop smallest start\\n                heapq.heappush(pq, (r - l + 1, r)) # interval length, interval end\\n\\n            while pq and query > pq[0][1]: # intervals that are too small\\n                heapq.heappop(pq)\\n            cache[query] = pq[0][0] if pq else -1\\n\\n        return (cache[q] for q in queries)\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom collections import deque\\nimport heapq\\n\\n\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        intervals = deque(sorted(intervals, key=lambda x: x[0]))\\n        cache = {} # query -> min interval length\\n        pq = []\\n\\n        for query in sorted(set(queries)):\\n            while intervals and intervals[0][0] <= query:\\n                l, r = intervals.popleft() # pop smallest start\\n                heapq.heappush(pq, (r - l + 1, r)) # interval length, interval end\\n\\n            while pq and query > pq[0][1]: # intervals that are too small\\n                heapq.heappop(pq)\\n            cache[query] = pq[0][0] if pq else -1\\n\\n        return (cache[q] for q in queries)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574536,
                "title": "bruteforce-and-optimised-using-priority-queue",
                "content": "# Optimised\\n# Approach\\nwe sort the queries and interval(starting index) so that we get the intervals for certain query without looking much. We maintain a priority queue that sorts intervals based on its size and rightmost value. for each query we add all interval to queue whose starting index value of interval is less than query value. then we remove all intervals from queue which cannot contain query we set least size interval that contains the query to index of the query in the answer array \\n# Complexity\\n- Time complexity:\\nO(NlogN + qlogq)\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Query {\\n\\n    int index;\\n    int queryTimeStamp;\\n    int result;\\n\\n    public Query(int index, int queryTimeStamp) {\\n        this.index = index;\\n        this.queryTimeStamp = queryTimeStamp;\\n        this.result = -1; // initially store as -1\\n    }\\n\\n    @Override\\n    public String toString() {\\n        return \"[\" + index + \",\" + queryTimeStamp + \",\" + result + \"]\";\\n    }\\n\\n    public void setResult(int result) {\\n        this.result = result;\\n    }\\n}\\n\\nclass IntervalComparator implements Comparator<int[]> {\\n\\n    public static int getSize(int[] interval) {\\n        return (interval[1] - interval[0] + 1);\\n    }\\n\\n    @Override\\n    public int compare(int[] o1, int[] o2) {\\n        int o1Size = getSize(o1), o2Size = getSize(o2);\\n        if (o1Size != o2Size) {\\n            return (o1Size - o2Size);\\n        }\\n        return (o1[1] - o2[1]);\\n    }\\n}\\n\\nclass Solution {\\n\\n    public int[] minInterval(int[][] intervals, int[] queries) {\\n        // book-keeping & sorting\\n        int numIntervals = intervals.length;\\n        int numQueries = queries.length;\\n\\n        // Sort by start times\\n        Arrays.sort(intervals, (o1, o2) -> (o1[0] - o2[0]));\\n\\n        Query[] sortedQueries = new Query[numQueries];\\n        for (int i = 0; i < numQueries; i++) sortedQueries[i] =\\n            new Query(i, queries[i]);\\n\\n        Arrays.sort(\\n            sortedQueries,\\n            (q1, q2) -> (q1.queryTimeStamp - q2.queryTimeStamp)\\n        );\\n\\n        // algorithm\\n\\n        Comparator<int[]> comparator = new IntervalComparator();\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(comparator);\\n        int idx = 0;\\n\\n        for (Query query : sortedQueries) {\\n            // 1. Keep taking all those queries which have lower starting time than the query time and add them to priority queue\\n            while (\\n                (idx < numIntervals) &&\\n                (query.queryTimeStamp >= intervals[idx][0])\\n            ) {\\n                pq.add(intervals[idx]);\\n                idx++;\\n            }\\n\\n            // 2. Keep removing the inconsistent intervals and get the min size interval from priority queue\\n            while (!pq.isEmpty() && (pq.peek()[1] < query.queryTimeStamp)) {\\n                pq.remove();\\n            }\\n\\n            // Now, priority queue must have the consistent & smallest interval\\n            int ans = pq.isEmpty() ? -1 : IntervalComparator.getSize(pq.peek());\\n            query.setResult(ans);\\n        }\\n\\n        // reconversion\\n        int[] results = new int[numQueries];\\n        for (Query query : sortedQueries) {\\n            results[query.index] = query.result;\\n        }\\n\\n        return results;\\n    }\\n}\\n```\\n\\n\\n# Bruteforce\\nTLE at 34 \\nTC O(nq)\\n```\\n\\n class Solution {\\n     public int[] minInterval(int[][] intervals, int[] queries) {\\n        \\n         int[]ans=new int[queries.length];\\n         int index=0;\\n         for(int query:queries){\\n             int count=Integer.MAX_VALUE;\\n         for(int i=0;i<intervals.length;i++){\\n             if(intervals[i][0]<=query&& query<=intervals[i][1]){\\n                 count=Math.min(count,intervals[i][1]-intervals[i][0]+1);\\n             }\\n         }\\n         if(count==Integer.MAX_VALUE) ans[index++]=-1;\\n         else{\\n         ans[index++]=count;\\n         }\\n         }\\n         return ans;\\n     }\\n }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Query {\\n\\n    int index;\\n    int queryTimeStamp;\\n    int result;\\n\\n    public Query(int index, int queryTimeStamp) {\\n        this.index = index;\\n        this.queryTimeStamp = queryTimeStamp;\\n        this.result = -1; // initially store as -1\\n    }\\n\\n    @Override\\n    public String toString() {\\n        return \"[\" + index + \",\" + queryTimeStamp + \",\" + result + \"]\";\\n    }\\n\\n    public void setResult(int result) {\\n        this.result = result;\\n    }\\n}\\n\\nclass IntervalComparator implements Comparator<int[]> {\\n\\n    public static int getSize(int[] interval) {\\n        return (interval[1] - interval[0] + 1);\\n    }\\n\\n    @Override\\n    public int compare(int[] o1, int[] o2) {\\n        int o1Size = getSize(o1), o2Size = getSize(o2);\\n        if (o1Size != o2Size) {\\n            return (o1Size - o2Size);\\n        }\\n        return (o1[1] - o2[1]);\\n    }\\n}\\n\\nclass Solution {\\n\\n    public int[] minInterval(int[][] intervals, int[] queries) {\\n        // book-keeping & sorting\\n        int numIntervals = intervals.length;\\n        int numQueries = queries.length;\\n\\n        // Sort by start times\\n        Arrays.sort(intervals, (o1, o2) -> (o1[0] - o2[0]));\\n\\n        Query[] sortedQueries = new Query[numQueries];\\n        for (int i = 0; i < numQueries; i++) sortedQueries[i] =\\n            new Query(i, queries[i]);\\n\\n        Arrays.sort(\\n            sortedQueries,\\n            (q1, q2) -> (q1.queryTimeStamp - q2.queryTimeStamp)\\n        );\\n\\n        // algorithm\\n\\n        Comparator<int[]> comparator = new IntervalComparator();\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(comparator);\\n        int idx = 0;\\n\\n        for (Query query : sortedQueries) {\\n            // 1. Keep taking all those queries which have lower starting time than the query time and add them to priority queue\\n            while (\\n                (idx < numIntervals) &&\\n                (query.queryTimeStamp >= intervals[idx][0])\\n            ) {\\n                pq.add(intervals[idx]);\\n                idx++;\\n            }\\n\\n            // 2. Keep removing the inconsistent intervals and get the min size interval from priority queue\\n            while (!pq.isEmpty() && (pq.peek()[1] < query.queryTimeStamp)) {\\n                pq.remove();\\n            }\\n\\n            // Now, priority queue must have the consistent & smallest interval\\n            int ans = pq.isEmpty() ? -1 : IntervalComparator.getSize(pq.peek());\\n            query.setResult(ans);\\n        }\\n\\n        // reconversion\\n        int[] results = new int[numQueries];\\n        for (Query query : sortedQueries) {\\n            results[query.index] = query.result;\\n        }\\n\\n        return results;\\n    }\\n}\\n```\n```\\n\\n class Solution {\\n     public int[] minInterval(int[][] intervals, int[] queries) {\\n        \\n         int[]ans=new int[queries.length];\\n         int index=0;\\n         for(int query:queries){\\n             int count=Integer.MAX_VALUE;\\n         for(int i=0;i<intervals.length;i++){\\n             if(intervals[i][0]<=query&& query<=intervals[i][1]){\\n                 count=Math.min(count,intervals[i][1]-intervals[i][0]+1);\\n             }\\n         }\\n         if(count==Integer.MAX_VALUE) ans[index++]=-1;\\n         else{\\n         ans[index++]=count;\\n         }\\n         }\\n         return ans;\\n     }\\n }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535153,
                "title": "my-solutions",
                "content": "**1. Sort and iterate, using the `std::multiset`**\\n```\\n/**\\n * Time Complexity: O((n_intervals + n_queries) * log(n_intervals + n_queries))\\n * Space Complexity: O(n_intervals + n_queries)\\n * where `n_intervals` is the length of the vector `intervals`\\n *       `n_queries` is the length of the vector `queries`\\n */\\nclass Solution {\\n private:\\n  enum class EventType : uint8_t {\\n    start,\\n    query,\\n    end\\n  };\\n  \\n  /**\\n   * {\\n   *   the timestamp,\\n   *   the type,\\n   *   the value\\n   * }\\n   *\\n   * the `type` will have 3 options,\\n   * 1. EventType::start\\n   *    which means the `timestamp` stands for the starting timestamp of an interval\\n   *                the `value` is the size of the corresponding interval\\n   * 2. EventType::query\\n   *    which means the `timestamp` stands for an element of the vecotr `queries`\\n   *                the `value` is the index of the element in the vector `queries`\\n   * 3. EventType::end\\n   *    which means the `timestamp` stands for the ending timestamp of an interval\\n   *                the `value` is the size of the corresponding interval\\n   */\\n  using event_t = tuple<int, EventType, int>;\\n  \\n public:\\n  vector<int> minInterval(const vector<vector<int>> &intervals, const vector<int> &queries) {\\n    constexpr int invalid_interval_size = -1;\\n    vector<event_t> events;\\n    for (const vector<int> &interval : intervals) {\\n      events.emplace_back(interval.front(), EventType::start, interval.back() - interval.front() + 1);\\n      events.emplace_back(interval.back(), EventType::end, interval.back() - interval.front() + 1);\\n    }\\n    const int n_queries = static_cast<int>(queries.size());\\n    for (int i_query = 0; i_query < n_queries; ++i_query) {\\n      events.emplace_back(queries[i_query], EventType::query, i_query);\\n    }\\n    sort(events.begin(), events.end());\\n    \\n    vector<int> ret(n_queries, invalid_interval_size);\\n    multiset<int> interval_sizes;\\n    for (const auto [_, type, value] : events) {\\n      if (type == EventType::start) {\\n        interval_sizes.emplace(value);\\n      } else if (type == EventType::end) {\\n        interval_sizes.erase(interval_sizes.find(value));\\n      } else {\\n        // type == EventType::query\\n        ret[value] = interval_sizes.empty() ? invalid_interval_size : *interval_sizes.begin();\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```\\n**2. Use the `std::priority_queue`**\\n```\\n/**\\n * Time Complexity: O(n_intervals * log(n_intervals) + n_queries * log(n_queries))\\n * Space Complexity: O(n_intervals + n_queries)\\n * where `n_intervals` is the length of the vector `intervals`\\n *       `n_queries` is the length of the vector `queries`\\n */\\nclass Solution {\\n public:\\n  vector<int> minInterval(vector<vector<int>> &intervals, const vector<int> &queries) {\\n    using pq_node_t = pair<int, int>;   // {the size of the interval, the ending timestamp of the interval}\\n    constexpr int invalid_interval_size = -1;\\n    const int n_intervals = static_cast<int>(intervals.size());\\n    const int n_queries = static_cast<int>(queries.size());\\n    sort(intervals.begin(), intervals.end());\\n    int query_indices[n_queries];\\n    iota(query_indices, query_indices + n_queries, 0);\\n    sort(query_indices, query_indices + n_queries, [&queries](const int lhs, const int rhs) -> bool {\\n      return queries[lhs] < queries[rhs];\\n    });\\n    priority_queue<pq_node_t, vector<pq_node_t>, greater<>> pq;\\n    vector<int> ret(n_queries, invalid_interval_size);\\n    for (int i_interval = 0, i = 0; i < n_queries; ++i) {\\n      const int i_query = query_indices[i];\\n      const int query = queries[i_query];\\n      for (; i_interval < n_intervals && intervals[i_interval].front() <= query; ++i_interval) {\\n        if (intervals[i_interval].back() >= query) {\\n          pq.emplace(intervals[i_interval].back() - intervals[i_interval].front() + 1,\\n                     intervals[i_interval].back());\\n        }\\n      }\\n      while (!pq.empty() && pq.top().second < query) {\\n        pq.pop();\\n      }\\n      ret[i_query] = pq.empty() ? invalid_interval_size : pq.top().first;\\n    }\\n    return ret;\\n  }\\n};\\n```\\n**3. Use the `std::multimap`**\\n```\\n/**\\n * Time Complexity: O(n_intervals * log(n_intervals) + n_queries * log(n_queries))\\n * Space Complexity: O(n_queries)\\n * where `n_intervals` is the length of the vector `intervals`\\n *       `n_queries` is the length of the vector `queries`\\n */\\nclass Solution {\\n public:\\n  vector<int> minInterval(vector<vector<int>> &intervals, const vector<int> &queries) {\\n    constexpr int invalid_interval_size = -1;\\n    const int n_queries = static_cast<int>(queries.size());\\n    sort(intervals.begin(), intervals.end(), [](const vector<int> &lhs, const vector<int> &rhs) -> bool {\\n      return lhs.back() - lhs.front() < rhs.back() - rhs.front();\\n    });\\n    \\n    multimap<int, int> query_to_index;\\n    for (int i_query = 0; i_query < n_queries; ++i_query) {\\n      query_to_index.emplace(queries[i_query], i_query);\\n    }\\n    \\n    vector<int> ret(n_queries, invalid_interval_size);\\n    for (const vector<int> &interval : intervals) {\\n      const int size = interval.back() - interval.front() + 1;\\n      for (auto itr = query_to_index.lower_bound(interval.front());\\n           itr != query_to_index.end() && itr->first <= interval.back();\\n           itr = query_to_index.erase(itr)) {\\n        ret[itr->second] = size;\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O((n_intervals + n_queries) * log(n_intervals + n_queries))\\n * Space Complexity: O(n_intervals + n_queries)\\n * where `n_intervals` is the length of the vector `intervals`\\n *       `n_queries` is the length of the vector `queries`\\n */\\nclass Solution {\\n private:\\n  enum class EventType : uint8_t {\\n    start,\\n    query,\\n    end\\n  };\\n  \\n  /**\\n   * {\\n   *   the timestamp,\\n   *   the type,\\n   *   the value\\n   * }\\n   *\\n   * the `type` will have 3 options,\\n   * 1. EventType::start\\n   *    which means the `timestamp` stands for the starting timestamp of an interval\\n   *                the `value` is the size of the corresponding interval\\n   * 2. EventType::query\\n   *    which means the `timestamp` stands for an element of the vecotr `queries`\\n   *                the `value` is the index of the element in the vector `queries`\\n   * 3. EventType::end\\n   *    which means the `timestamp` stands for the ending timestamp of an interval\\n   *                the `value` is the size of the corresponding interval\\n   */\\n  using event_t = tuple<int, EventType, int>;\\n  \\n public:\\n  vector<int> minInterval(const vector<vector<int>> &intervals, const vector<int> &queries) {\\n    constexpr int invalid_interval_size = -1;\\n    vector<event_t> events;\\n    for (const vector<int> &interval : intervals) {\\n      events.emplace_back(interval.front(), EventType::start, interval.back() - interval.front() + 1);\\n      events.emplace_back(interval.back(), EventType::end, interval.back() - interval.front() + 1);\\n    }\\n    const int n_queries = static_cast<int>(queries.size());\\n    for (int i_query = 0; i_query < n_queries; ++i_query) {\\n      events.emplace_back(queries[i_query], EventType::query, i_query);\\n    }\\n    sort(events.begin(), events.end());\\n    \\n    vector<int> ret(n_queries, invalid_interval_size);\\n    multiset<int> interval_sizes;\\n    for (const auto [_, type, value] : events) {\\n      if (type == EventType::start) {\\n        interval_sizes.emplace(value);\\n      } else if (type == EventType::end) {\\n        interval_sizes.erase(interval_sizes.find(value));\\n      } else {\\n        // type == EventType::query\\n        ret[value] = interval_sizes.empty() ? invalid_interval_size : *interval_sizes.begin();\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```\n```\\n/**\\n * Time Complexity: O(n_intervals * log(n_intervals) + n_queries * log(n_queries))\\n * Space Complexity: O(n_intervals + n_queries)\\n * where `n_intervals` is the length of the vector `intervals`\\n *       `n_queries` is the length of the vector `queries`\\n */\\nclass Solution {\\n public:\\n  vector<int> minInterval(vector<vector<int>> &intervals, const vector<int> &queries) {\\n    using pq_node_t = pair<int, int>;   // {the size of the interval, the ending timestamp of the interval}\\n    constexpr int invalid_interval_size = -1;\\n    const int n_intervals = static_cast<int>(intervals.size());\\n    const int n_queries = static_cast<int>(queries.size());\\n    sort(intervals.begin(), intervals.end());\\n    int query_indices[n_queries];\\n    iota(query_indices, query_indices + n_queries, 0);\\n    sort(query_indices, query_indices + n_queries, [&queries](const int lhs, const int rhs) -> bool {\\n      return queries[lhs] < queries[rhs];\\n    });\\n    priority_queue<pq_node_t, vector<pq_node_t>, greater<>> pq;\\n    vector<int> ret(n_queries, invalid_interval_size);\\n    for (int i_interval = 0, i = 0; i < n_queries; ++i) {\\n      const int i_query = query_indices[i];\\n      const int query = queries[i_query];\\n      for (; i_interval < n_intervals && intervals[i_interval].front() <= query; ++i_interval) {\\n        if (intervals[i_interval].back() >= query) {\\n          pq.emplace(intervals[i_interval].back() - intervals[i_interval].front() + 1,\\n                     intervals[i_interval].back());\\n        }\\n      }\\n      while (!pq.empty() && pq.top().second < query) {\\n        pq.pop();\\n      }\\n      ret[i_query] = pq.empty() ? invalid_interval_size : pq.top().first;\\n    }\\n    return ret;\\n  }\\n};\\n```\n```\\n/**\\n * Time Complexity: O(n_intervals * log(n_intervals) + n_queries * log(n_queries))\\n * Space Complexity: O(n_queries)\\n * where `n_intervals` is the length of the vector `intervals`\\n *       `n_queries` is the length of the vector `queries`\\n */\\nclass Solution {\\n public:\\n  vector<int> minInterval(vector<vector<int>> &intervals, const vector<int> &queries) {\\n    constexpr int invalid_interval_size = -1;\\n    const int n_queries = static_cast<int>(queries.size());\\n    sort(intervals.begin(), intervals.end(), [](const vector<int> &lhs, const vector<int> &rhs) -> bool {\\n      return lhs.back() - lhs.front() < rhs.back() - rhs.front();\\n    });\\n    \\n    multimap<int, int> query_to_index;\\n    for (int i_query = 0; i_query < n_queries; ++i_query) {\\n      query_to_index.emplace(queries[i_query], i_query);\\n    }\\n    \\n    vector<int> ret(n_queries, invalid_interval_size);\\n    for (const vector<int> &interval : intervals) {\\n      const int size = interval.back() - interval.front() + 1;\\n      for (auto itr = query_to_index.lower_bound(interval.front());\\n           itr != query_to_index.end() && itr->first <= interval.back();\\n           itr = query_to_index.erase(itr)) {\\n        ret[itr->second] = size;\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3530135,
                "title": "java-solution-with-comment",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] minInterval(int[][] intervals, int[] queries) {\\n        int numQuery = queries.length;\\n        \\n        //append index in query\\n        int[][] queriesWithIndex = new int[numQuery][2];\\n        for(int i = 0; i < numQuery; i++){\\n            queriesWithIndex[i] = new int[]{queries[i], i};\\n        }\\n        \\n        Arrays.sort(intervals, (a, b) -> (a[0] - b[0]));\\n        Arrays.sort(queriesWithIndex, (a, b) -> (a[0] - b[0]));\\n        \\n        //sort interval in increasing order of size\\n        PriorityQueue<int[]> minHeap = new PriorityQueue<int[]>((a, b) -> ((a[1] - a[0]) - (b[1] - b[0])));\\n        \\n        int[] result = new int[numQuery];\\n        \\n        int j = 0;\\n        for(int i = 0; i < queries.length; i++){\\n            int queryVal = queriesWithIndex[i][0];\\n            int queryIndex = queriesWithIndex[i][1];\\n            \\n            //add all the interval which start is less or equal than current query value \\n            while(j < intervals.length && intervals[j][0] <= queryVal){\\n                minHeap.add(intervals[j]);\\n                j++;\\n            }\\n            \\n            //remove all the smallest size interval which end val is less than current query value\\n            while(!minHeap.isEmpty() && minHeap.peek()[1] < queryVal){\\n                minHeap.remove();\\n            }\\n            //now if heap is empty it means there is no interval which satisfy query val\\n            result[queryIndex] = minHeap.isEmpty() ? -1 : (minHeap.peek()[1] - minHeap.peek()[0] + 1); \\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search",
                    "Line Sweep",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] minInterval(int[][] intervals, int[] queries) {\\n        int numQuery = queries.length;\\n        \\n        //append index in query\\n        int[][] queriesWithIndex = new int[numQuery][2];\\n        for(int i = 0; i < numQuery; i++){\\n            queriesWithIndex[i] = new int[]{queries[i], i};\\n        }\\n        \\n        Arrays.sort(intervals, (a, b) -> (a[0] - b[0]));\\n        Arrays.sort(queriesWithIndex, (a, b) -> (a[0] - b[0]));\\n        \\n        //sort interval in increasing order of size\\n        PriorityQueue<int[]> minHeap = new PriorityQueue<int[]>((a, b) -> ((a[1] - a[0]) - (b[1] - b[0])));\\n        \\n        int[] result = new int[numQuery];\\n        \\n        int j = 0;\\n        for(int i = 0; i < queries.length; i++){\\n            int queryVal = queriesWithIndex[i][0];\\n            int queryIndex = queriesWithIndex[i][1];\\n            \\n            //add all the interval which start is less or equal than current query value \\n            while(j < intervals.length && intervals[j][0] <= queryVal){\\n                minHeap.add(intervals[j]);\\n                j++;\\n            }\\n            \\n            //remove all the smallest size interval which end val is less than current query value\\n            while(!minHeap.isEmpty() && minHeap.peek()[1] < queryVal){\\n                minHeap.remove();\\n            }\\n            //now if heap is empty it means there is no interval which satisfy query val\\n            result[queryIndex] = minHeap.isEmpty() ? -1 : (minHeap.peek()[1] - minHeap.peek()[0] + 1); \\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3517628,
                "title": "java-2-solutions-segment-tree-binarysearch-with-comments",
                "content": "1st\\n```\\nclass Solution {\\n    // Nested class representing a node in the interval tree\\n    private class Node {\\n        public int left, right, min;\\n        public Node lnode, rnode;\\n        \\n        public Node(int l, int r) {\\n            this.left = l;\\n            this.right = r;\\n            this.min = Integer.MAX_VALUE;\\n        }\\n    }\\n    \\n    // Function to find the minimum interval containing the query point\\n    public int find(Node curr, int q) {\\n        // If the current node is null or the query point is outside the range of the current node,\\n        // return the maximum value to indicate that no interval contains the query point\\n        if (curr == null || q < curr.left || q > curr.right)\\n            return Integer.MAX_VALUE;\\n        \\n        int m = (curr.left + curr.right) / 2;\\n        \\n        // If the query point is in the left subtree, recursively search in the left subtree\\n        // and return the minimum value found\\n        if (q <= m)\\n            return Integer.min(find(curr.lnode, q), curr.min);\\n        // If the query point is in the right subtree, recursively search in the right subtree\\n        // and return the minimum value found\\n        else\\n            return Integer.min(find(curr.rnode, q), curr.min);\\n    }\\n    \\n    // Function to add an interval to the interval tree\\n    public void add(Node curr, int l, int r, int b) {\\n        // If the interval is outside the range of the current node, return\\n        if (l < curr.left || r > curr.right)\\n            return;\\n        \\n        // If the interval exactly matches the range of the current node,\\n        // update the minimum value of the node and return\\n        if (curr.left == l && curr.right == r) {\\n            curr.min = Integer.min(curr.min, b);\\n            return;\\n        }\\n        \\n        int m = (curr.left + curr.right) / 2;\\n        \\n        // If the left child of the current node is null, create the left and right children\\n        if (curr.lnode == null) {\\n            curr.lnode = new Node(curr.left, m);\\n            curr.rnode = new Node(m + 1, curr.right);\\n        }\\n        \\n        // Recursively add the interval to the appropriate child node\\n        if (r <= m)\\n            add(curr.lnode, l, r, b);\\n        else if (l >= m + 1)\\n            add(curr.rnode, l, r, b);\\n        else {\\n            add(curr.lnode, l, m, b);\\n            add(curr.rnode, m + 1, r, b);\\n        }\\n    }\\n    \\n    // Main function to find the minimum intervals for given queries\\n    public int[] minInterval(int[][] intervals, int[] queries) {\\n        // Create the root node of the interval tree with a large range\\n        Node root = new Node(0, 10000000);\\n        \\n        // Add each interval to the interval tree\\n        for (int[] inter : intervals)\\n            add(root, inter[0], inter[1], inter[1] - inter[0] + 1);\\n        \\n        // Perform queries and store the results in an array\\n        int[] ans = new int[queries.length];\\n        \\n        for (int i = 0; i < queries.length; i++) {\\n            ans[i] = find(root, queries[i]);\\n            // If no interval contains the query point, set the result to -1\\n            ans[i] = ans[i] == Integer.MAX_VALUE ? -1 : ans[i];\\n        }\\n        \\n       \\n\\n```\\n\\n\\n2nd\\n\\n```\\nclass Solution {\\n    class Pair{\\n        public int st,end;\\n        public Pair(int s,int e){\\n            this.st=s;\\n            this.end=e;\\n        }\\n    }\\n    public int[] minInterval(int[][] intervals, int[] queries) {\\n        Arrays.sort(intervals,(i1,i2)->Integer.compare(i1[1]-i1[0],i2[1]-i2[0]));\\n        int [] ans=new int[queries.length];\\n        Arrays.fill(ans,-1);\\n        TreeSet<Pair> ts=new TreeSet<>((p1,p2)->{\\n            if(p1.st==p2.st)\\n                return  Integer.compare(p1.end,p2.end);\\n            else \\n                 return  Integer.compare(p1.st,p2.st);\\n        }\\n        );\\n        for(int i=0;i<queries.length;i++)ts.add(new Pair(queries[i],i));\\n        for(int inter[]:intervals){\\n            Iterator<Pair> it= ts.tailSet(new Pair(inter[0],-1)).iterator();\\n            while(it.hasNext()){\\n                Pair res=it.next();\\n                if(res.st<=inter[1]){\\n                    ans[res.end]=inter[1]-inter[0]+1;\\n                    it.remove();\\n                }else break;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // Nested class representing a node in the interval tree\\n    private class Node {\\n        public int left, right, min;\\n        public Node lnode, rnode;\\n        \\n        public Node(int l, int r) {\\n            this.left = l;\\n            this.right = r;\\n            this.min = Integer.MAX_VALUE;\\n        }\\n    }\\n    \\n    // Function to find the minimum interval containing the query point\\n    public int find(Node curr, int q) {\\n        // If the current node is null or the query point is outside the range of the current node,\\n        // return the maximum value to indicate that no interval contains the query point\\n        if (curr == null || q < curr.left || q > curr.right)\\n            return Integer.MAX_VALUE;\\n        \\n        int m = (curr.left + curr.right) / 2;\\n        \\n        // If the query point is in the left subtree, recursively search in the left subtree\\n        // and return the minimum value found\\n        if (q <= m)\\n            return Integer.min(find(curr.lnode, q), curr.min);\\n        // If the query point is in the right subtree, recursively search in the right subtree\\n        // and return the minimum value found\\n        else\\n            return Integer.min(find(curr.rnode, q), curr.min);\\n    }\\n    \\n    // Function to add an interval to the interval tree\\n    public void add(Node curr, int l, int r, int b) {\\n        // If the interval is outside the range of the current node, return\\n        if (l < curr.left || r > curr.right)\\n            return;\\n        \\n        // If the interval exactly matches the range of the current node,\\n        // update the minimum value of the node and return\\n        if (curr.left == l && curr.right == r) {\\n            curr.min = Integer.min(curr.min, b);\\n            return;\\n        }\\n        \\n        int m = (curr.left + curr.right) / 2;\\n        \\n        // If the left child of the current node is null, create the left and right children\\n        if (curr.lnode == null) {\\n            curr.lnode = new Node(curr.left, m);\\n            curr.rnode = new Node(m + 1, curr.right);\\n        }\\n        \\n        // Recursively add the interval to the appropriate child node\\n        if (r <= m)\\n            add(curr.lnode, l, r, b);\\n        else if (l >= m + 1)\\n            add(curr.rnode, l, r, b);\\n        else {\\n            add(curr.lnode, l, m, b);\\n            add(curr.rnode, m + 1, r, b);\\n        }\\n    }\\n    \\n    // Main function to find the minimum intervals for given queries\\n    public int[] minInterval(int[][] intervals, int[] queries) {\\n        // Create the root node of the interval tree with a large range\\n        Node root = new Node(0, 10000000);\\n        \\n        // Add each interval to the interval tree\\n        for (int[] inter : intervals)\\n            add(root, inter[0], inter[1], inter[1] - inter[0] + 1);\\n        \\n        // Perform queries and store the results in an array\\n        int[] ans = new int[queries.length];\\n        \\n        for (int i = 0; i < queries.length; i++) {\\n            ans[i] = find(root, queries[i]);\\n            // If no interval contains the query point, set the result to -1\\n            ans[i] = ans[i] == Integer.MAX_VALUE ? -1 : ans[i];\\n        }\\n        \\n       \\n\\n```\n```\\nclass Solution {\\n    class Pair{\\n        public int st,end;\\n        public Pair(int s,int e){\\n            this.st=s;\\n            this.end=e;\\n        }\\n    }\\n    public int[] minInterval(int[][] intervals, int[] queries) {\\n        Arrays.sort(intervals,(i1,i2)->Integer.compare(i1[1]-i1[0],i2[1]-i2[0]));\\n        int [] ans=new int[queries.length];\\n        Arrays.fill(ans,-1);\\n        TreeSet<Pair> ts=new TreeSet<>((p1,p2)->{\\n            if(p1.st==p2.st)\\n                return  Integer.compare(p1.end,p2.end);\\n            else \\n                 return  Integer.compare(p1.st,p2.st);\\n        }\\n        );\\n        for(int i=0;i<queries.length;i++)ts.add(new Pair(queries[i],i));\\n        for(int inter[]:intervals){\\n            Iterator<Pair> it= ts.tailSet(new Pair(inter[0],-1)).iterator();\\n            while(it.hasNext()){\\n                Pair res=it.next();\\n                if(res.st<=inter[1]){\\n                    ans[res.end]=inter[1]-inter[0]+1;\\n                    it.remove();\\n                }else break;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3500801,
                "title": "c-solution-with-priority-query",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int[] MinInterval(int[][] intervals, int[] queries) {\\n        int queriesLength = queries.Length;\\n        // we have to store queries with their original indexes\\n        int[][] queriesWithIndexes = new int[queriesLength][];\\n\\n        int index = 0;\\n        foreach(var query in queries){\\n            queriesWithIndexes[index] = new int[2] { query, index++ };\\n        }\\n\\n        Array.Sort(queriesWithIndexes, (first, second) => first[0] - second[0]);\\n        Array.Sort(intervals, (first, second) => first[0] - second[0]);\\n        \\n        // first element will be with the largest length (priority)\\n        var queue = new PriorityQueue<int[], int>();\\n        var result = new int[queriesLength];\\n        \\n        index = 0;\\n        foreach(var queryWithIndex in queriesWithIndexes){\\n            // query is great or equal than start of intervals[index]\\n            while(index < intervals.Length && intervals[index][0] <= queryWithIndex[0]){\\n                int itemsCount = intervals[index][1] - intervals[index][0] + 1;\\n                queue.Enqueue(new int[2] { itemsCount, intervals[index][1]}, itemsCount);\\n                index++;\\n            }\\n            \\n            // remove intervals which end point is less than current query\\n            while(queue.Count > 0 && queue.Peek()[1] < queryWithIndex[0]){\\n                queue.Dequeue();\\n            }\\n\\n            result[queryWithIndex[1]] = queue.Count > 0 ? queue.Peek()[0] : -1;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] MinInterval(int[][] intervals, int[] queries) {\\n        int queriesLength = queries.Length;\\n        // we have to store queries with their original indexes\\n        int[][] queriesWithIndexes = new int[queriesLength][];\\n\\n        int index = 0;\\n        foreach(var query in queries){\\n            queriesWithIndexes[index] = new int[2] { query, index++ };\\n        }\\n\\n        Array.Sort(queriesWithIndexes, (first, second) => first[0] - second[0]);\\n        Array.Sort(intervals, (first, second) => first[0] - second[0]);\\n        \\n        // first element will be with the largest length (priority)\\n        var queue = new PriorityQueue<int[], int>();\\n        var result = new int[queriesLength];\\n        \\n        index = 0;\\n        foreach(var queryWithIndex in queriesWithIndexes){\\n            // query is great or equal than start of intervals[index]\\n            while(index < intervals.Length && intervals[index][0] <= queryWithIndex[0]){\\n                int itemsCount = intervals[index][1] - intervals[index][0] + 1;\\n                queue.Enqueue(new int[2] { itemsCount, intervals[index][1]}, itemsCount);\\n                index++;\\n            }\\n            \\n            // remove intervals which end point is less than current query\\n            while(queue.Count > 0 && queue.Peek()[1] < queryWithIndex[0]){\\n                queue.Dequeue();\\n            }\\n\\n            result[queryWithIndex[1]] = queue.Count > 0 ? queue.Peek()[0] : -1;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454501,
                "title": "c-priority-queue-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\ntypedef pair<int,int> PI;\\n    vector<int> minInterval(vector<vector<int>>& itl, vector<int>& q) {\\n        int n=itl.size();\\n        int m=q.size();\\n        vector<int> sizes(n);   // storing sizes of each interval\\n        sort(itl.begin(),itl.end());\\n        vector<int> ans(m);\\n        int* arr=new int[10000001];\\n        int mini=itl[0][0];\\n        int maxi=itl[n-1][1];\\n        set<pair<int,int>> st;\\n        priority_queue<PI,vector<PI>,greater<PI>> pq;\\n        for(auto& ele:  itl){\\n            maxi=max(maxi,ele[1]);\\n        }\\n        int j=0;\\n        for(int i=mini;i<=maxi;i++){\\n            while(j<n){\\n                if(i<itl[j][0]) break;\\n                sizes[j]=itl[j][1]-itl[j][0]+1;\\n                st.insert(make_pair(sizes[j],j));\\n                pq.push(make_pair(itl[j][1],j));\\n                j++;\\n            }\\n            arr[i]=(st.size())?(st.begin()->first):(-1);\\n            while(pq.size() && pq.top().first==i){\\n                auto [a,b]=pq.top();\\n                st.erase({sizes[b],b});\\n                pq.pop();\\n            }\\n        }\\n\\n        for(int j=0;j<m;j++){\\n            if(q[j]<mini  || q[j]>maxi) ans[j]=-1;\\n            else ans[j]=arr[q[j]];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\ntypedef pair<int,int> PI;\\n    vector<int> minInterval(vector<vector<int>>& itl, vector<int>& q) {\\n        int n=itl.size();\\n        int m=q.size();\\n        vector<int> sizes(n);   // storing sizes of each interval\\n        sort(itl.begin(),itl.end());\\n        vector<int> ans(m);\\n        int* arr=new int[10000001];\\n        int mini=itl[0][0];\\n        int maxi=itl[n-1][1];\\n        set<pair<int,int>> st;\\n        priority_queue<PI,vector<PI>,greater<PI>> pq;\\n        for(auto& ele:  itl){\\n            maxi=max(maxi,ele[1]);\\n        }\\n        int j=0;\\n        for(int i=mini;i<=maxi;i++){\\n            while(j<n){\\n                if(i<itl[j][0]) break;\\n                sizes[j]=itl[j][1]-itl[j][0]+1;\\n                st.insert(make_pair(sizes[j],j));\\n                pq.push(make_pair(itl[j][1],j));\\n                j++;\\n            }\\n            arr[i]=(st.size())?(st.begin()->first):(-1);\\n            while(pq.size() && pq.top().first==i){\\n                auto [a,b]=pq.top();\\n                st.erase({sizes[b],b});\\n                pq.pop();\\n            }\\n        }\\n\\n        for(int j=0;j<m;j++){\\n            if(q[j]<mini  || q[j]>maxi) ans[j]=-1;\\n            else ans[j]=arr[q[j]];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421467,
                "title": "java-solution-with-detailed-explanation-passes-all-cases",
                "content": "# Approach\\n1. Sort the 2D \\'intervals\\' array in ascending order by index 0 of every element of the \\'intervals\\' array. \\n2. Create a 2D array named \\'queriesWithOriIndex\\' to get a copy of the \\'queries\\' with the index of each element in the array.  \\n3. Sort the \\'queriesWithOriIndex\\' array in ascending order by value(index 0) of every element of the \\'queriesWithOriIndex\\' array.\\n4. Create a PriorityQueue<int[]> named minHeap to from {righti - lefti + 1, right index of current interval}\\n5. Run for loop and 2 while loops. \\n6. Sort the \\'queriesWithOriIndex\\' array in ascending order by index(index 1) of every element of the \\'queriesWithOriIndex\\' array.\\n7. Created an array name \\'result\\' to store index 0 of every element of the \\'queriesWithOriIndex\\' array\\n8. return \\'result\\'. \\n\\n# Complexity\\n- Time complexity: O(nlog(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] minInterval(int[][] intervals, int[] queries) {\\n        // Time complexity is O(nlog(n) + qlog(q)), simplified that is O(nlog(n)), \\n        // because we need to sort both in order to get the best interval and \\n        // for the meat part to get the best interval, runtime just O(n). \\n\\n\\n\\n        // Assign the length of queries to the variable queryLength \\n        // because there are several usages in the upcoming code\\n        int queriesLength = queries.length;\\n\\n        // Sorted the intervals\\n        Arrays.sort(intervals, (a, b) -> (a[0] - b[0]));\\n\\n        // Create a 2D array to have a record for queries with its original index\\n        // We must have that record in hand because the final result has to be consistent\\n        // with the order of elements of the original queries. \\n        int[][] queriesWithOriIndex = new int[queriesLength][2];\\n\\n        // After the for loop, The queriesWithOriIndex will look like:\\n        // [[2,0], [3,1], [4,2], [5,3]] if based on the example 1.\\n        // [[2,0], [19,1], [5,2], [22,3]] if based on the example 2.\\n        //   \\u2191 \\u2191\\n        //   v,i (value, index)\\n        for(int i=0; i<queries.length; i++) {\\n            queriesWithOriIndex[i] = new int[]{queries[i], i};\\n        }\\n\\n        // BEFORE the for loop, The queriesWithOriIndex will look like:\\n        // [[2,0], [19,1], [5,2], [22,3]] if based on the example 2.\\n        // AFTER the for loop, The queriesWithOriIndex will look like:\\n        // [[2,0], [5,2], [19,1], [22,3]] if based on the example 2.\\n        // Notice that [19,1] and [5,2] is swapped because we sort it based on the index 0.\\n        Arrays.sort(queriesWithOriIndex, (a, b) -> (a[0] - b[0]));\\n        \\n\\n        // minHeap in Java is PriorityQueue.\\n        // We need to specify the sort constraint because the generic type is array.\\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>((a, b) -> (a[0]-b[0]));\\n\\n        \\n        // below is the meat part I mentioned earlier, \\n        // the runtime is O(n) because every interval add and poll once. \\n        int j = 0; // This is for while loop use\\n\\n        // The for loop is for every element insdie queriesWithOriIndex,\\n        // especially for index[0] of each element.\\n        for(int i=0; i<queriesLength; i++) {       \\n\\n            // If the current query is within the left side of the interval, \\n            // we add the {righti - lefti + 1, right index of the interval} into the minHeap.\\n            while(j<intervals.length && queriesWithOriIndex[i][0] >= intervals[j][0]) {\\n                int amountOfInterval = intervals[j][1] - intervals[j][0] + 1;\\n                int[] tempArr = new int[]{amountOfInterval, intervals[j][1]};\\n                minHeap.add(tempArr);\\n                j++;\\n            }\\n\\n            // At this point, means we finish adding all possible intervals into minHeap, \\n            // and we start to get rid of those intervals that do not fit the current query. \\n            // If the current query is larger than the right side of the interval, means the \\n            // current query doesn\\'t fall into that interval, we can just poll it from\\n            // minHeap.\\n            // Notice that the next element from queriesWithOriIndex will also not \\n            // falling into all the intervals we poll from minHeap because \\n            // queriesWithOriIndex is sorted in ascending order.  \\n            // For example, if current element from queriesWithOriIndex[i][0] is 2, \\n            // the upcoming element from queriesWithOriIndex[i][0] only possible that >= 2, \\n            // since the current element is not fit for all those intervals, the \\n            // upcoming will not fit for all those intervals as well.    \\n            while(!minHeap.isEmpty() && queriesWithOriIndex[i][0] > minHeap.peek()[1]) {\\n                minHeap.poll();\\n            }\\n\\n            // We found the smallest interval for the query if minHeap is not empty.\\n            // Otherwise means we fail to find that, return -1 in this case.\\n            queriesWithOriIndex[i][0] = minHeap.isEmpty()?-1: minHeap.peek()[0];\\n        }\\n\\n        // We sort the queriesWithOriIndex based on the the orginal query index. \\n        Arrays.sort(queriesWithOriIndex, (a, b) -> (a[1] - b[1]));\\n\\n        // And we create the result variable and run a for loop to obtain the result \\n        // in the order of the original order of query. \\n        int[] result = new int[queriesLength];\\n        for(int i=0; i<queriesLength; i++) {\\n            result[i] = queriesWithOriIndex[i][0];\\n        }\\n\\n        // return result. \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] minInterval(int[][] intervals, int[] queries) {\\n        // Time complexity is O(nlog(n) + qlog(q)), simplified that is O(nlog(n)), \\n        // because we need to sort both in order to get the best interval and \\n        // for the meat part to get the best interval, runtime just O(n). \\n\\n\\n\\n        // Assign the length of queries to the variable queryLength \\n        // because there are several usages in the upcoming code\\n        int queriesLength = queries.length;\\n\\n        // Sorted the intervals\\n        Arrays.sort(intervals, (a, b) -> (a[0] - b[0]));\\n\\n        // Create a 2D array to have a record for queries with its original index\\n        // We must have that record in hand because the final result has to be consistent\\n        // with the order of elements of the original queries. \\n        int[][] queriesWithOriIndex = new int[queriesLength][2];\\n\\n        // After the for loop, The queriesWithOriIndex will look like:\\n        // [[2,0], [3,1], [4,2], [5,3]] if based on the example 1.\\n        // [[2,0], [19,1], [5,2], [22,3]] if based on the example 2.\\n        //   \\u2191 \\u2191\\n        //   v,i (value, index)\\n        for(int i=0; i<queries.length; i++) {\\n            queriesWithOriIndex[i] = new int[]{queries[i], i};\\n        }\\n\\n        // BEFORE the for loop, The queriesWithOriIndex will look like:\\n        // [[2,0], [19,1], [5,2], [22,3]] if based on the example 2.\\n        // AFTER the for loop, The queriesWithOriIndex will look like:\\n        // [[2,0], [5,2], [19,1], [22,3]] if based on the example 2.\\n        // Notice that [19,1] and [5,2] is swapped because we sort it based on the index 0.\\n        Arrays.sort(queriesWithOriIndex, (a, b) -> (a[0] - b[0]));\\n        \\n\\n        // minHeap in Java is PriorityQueue.\\n        // We need to specify the sort constraint because the generic type is array.\\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>((a, b) -> (a[0]-b[0]));\\n\\n        \\n        // below is the meat part I mentioned earlier, \\n        // the runtime is O(n) because every interval add and poll once. \\n        int j = 0; // This is for while loop use\\n\\n        // The for loop is for every element insdie queriesWithOriIndex,\\n        // especially for index[0] of each element.\\n        for(int i=0; i<queriesLength; i++) {       \\n\\n            // If the current query is within the left side of the interval, \\n            // we add the {righti - lefti + 1, right index of the interval} into the minHeap.\\n            while(j<intervals.length && queriesWithOriIndex[i][0] >= intervals[j][0]) {\\n                int amountOfInterval = intervals[j][1] - intervals[j][0] + 1;\\n                int[] tempArr = new int[]{amountOfInterval, intervals[j][1]};\\n                minHeap.add(tempArr);\\n                j++;\\n            }\\n\\n            // At this point, means we finish adding all possible intervals into minHeap, \\n            // and we start to get rid of those intervals that do not fit the current query. \\n            // If the current query is larger than the right side of the interval, means the \\n            // current query doesn\\'t fall into that interval, we can just poll it from\\n            // minHeap.\\n            // Notice that the next element from queriesWithOriIndex will also not \\n            // falling into all the intervals we poll from minHeap because \\n            // queriesWithOriIndex is sorted in ascending order.  \\n            // For example, if current element from queriesWithOriIndex[i][0] is 2, \\n            // the upcoming element from queriesWithOriIndex[i][0] only possible that >= 2, \\n            // since the current element is not fit for all those intervals, the \\n            // upcoming will not fit for all those intervals as well.    \\n            while(!minHeap.isEmpty() && queriesWithOriIndex[i][0] > minHeap.peek()[1]) {\\n                minHeap.poll();\\n            }\\n\\n            // We found the smallest interval for the query if minHeap is not empty.\\n            // Otherwise means we fail to find that, return -1 in this case.\\n            queriesWithOriIndex[i][0] = minHeap.isEmpty()?-1: minHeap.peek()[0];\\n        }\\n\\n        // We sort the queriesWithOriIndex based on the the orginal query index. \\n        Arrays.sort(queriesWithOriIndex, (a, b) -> (a[1] - b[1]));\\n\\n        // And we create the result variable and run a for loop to obtain the result \\n        // in the order of the original order of query. \\n        int[] result = new int[queriesLength];\\n        for(int i=0; i<queriesLength; i++) {\\n            result[i] = queriesWithOriIndex[i][0];\\n        }\\n\\n        // return result. \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418050,
                "title": "c",
                "content": "```\\nusing PII = pair<int, int> ; \\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        priority_queue<PII, vector<PII>, greater<PII>>pq ; // { duration, right} ;\\n                \\n        vector<PII>queryPII ;  //pos, index\\n        for(int i = 0; i < queries.size(); i++){\\n            queryPII.push_back({queries[i], i}) ;\\n        }\\n        \\n        sort(queryPII.begin(), queryPII.end()) ;\\n        sort(intervals.begin(), intervals.end()) ;\\n        \\n        vector<int>rets(queryPII.size()) ;\\n        int i = 0 ;\\n        for(auto [pos, idx] : queryPII){\\n            while(i < intervals.size() && intervals[i][0] <= pos){\\n                pq.push({intervals[i][1] - intervals[i][0]+1 , intervals[i][1] }) ;\\n                i++ ;\\n            }\\n            while(!pq.empty() && pq.top().second < pos)\\n                pq.pop() ;\\n            \\n            if(!pq.empty())\\n                rets[idx] = pq.top().first ;\\n            else\\n                rets[idx] = -1 ;\\n        }\\n        return rets ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nusing PII = pair<int, int> ; \\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        priority_queue<PII, vector<PII>, greater<PII>>pq ; // { duration, right} ;\\n                \\n        vector<PII>queryPII ;  //pos, index\\n        for(int i = 0; i < queries.size(); i++){\\n            queryPII.push_back({queries[i], i}) ;\\n        }\\n        \\n        sort(queryPII.begin(), queryPII.end()) ;\\n        sort(intervals.begin(), intervals.end()) ;\\n        \\n        vector<int>rets(queryPII.size()) ;\\n        int i = 0 ;\\n        for(auto [pos, idx] : queryPII){\\n            while(i < intervals.size() && intervals[i][0] <= pos){\\n                pq.push({intervals[i][1] - intervals[i][0]+1 , intervals[i][1] }) ;\\n                i++ ;\\n            }\\n            while(!pq.empty() && pq.top().second < pos)\\n                pq.pop() ;\\n            \\n            if(!pq.empty())\\n                rets[idx] = pq.top().first ;\\n            else\\n                rets[idx] = -1 ;\\n        }\\n        return rets ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3413150,
                "title": "ts-solution-using-min-heap-and-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n log n + q log q)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// Self Solution, Time Limit Exceeded, Time Complexity: O(m * n * k), Space Complexity: O(m * n)(k = queries length)\\n// type ElementGroup = {\\n//     start: number;\\n//     end: number;\\n//     size: number;\\n// }\\n// function minInterval(intervals: number[][], queries: number[]): number[] {\\n//     let arr: ElementGroup[] = [];\\n//     let processed: number[] = [];\\n//     for ( const interval of intervals ) {\\n//         arr.push({\\n//             start: interval[0],\\n//             end: interval[1],\\n//             size: interval[1] - interval[0] + 1\\n//         });\\n//     }\\n//     arr.sort((el1, el2) => (el1.start !== el2.start) ? el1.start - el2.start: el1.end - el2.end);\\n//     for ( let i = 0; i < queries.length; i++ ) {\\n//         let isNotFound: boolean = true;\\n//         let left: number = 0;\\n//         let right: number = arr.length - 1;\\n//         let minSize: number = Infinity;\\n//         // for ( const elementgroup of arr ) {\\n//         //     // if ( queries[i] > elementgroup.end ) continue;\\n//         //     if ( elementgroup.start <= queries[i] && elementgroup.end >= queries[i] )  {\\n//         //         processed.push(elementgroup.size);\\n//         //         isNotFound = false;\\n//         //         break;\\n//         //     }\\n//         // }\\n//         while ( left < right ) {\\n//             let mid = Math.floor((left + right) / 2);\\n//             if ( arr[mid].start > queries[i] ) right = mid - 1;\\n//             else if ( arr[mid].end < queries[i] ) left = mid + 1;\\n//             else {\\n//                 while ( arr[mid].start >= queries[i] && arr[mid].end <= queries[i] ) {\\n//                 // processed.push(arr[mid].size);\\n//                 minSize = Math.min(minSize, arr[mid].size);\\n//                 isNotFound = false;\\n//                 mid--;\\n//             }\\n//             }\\n//         }\\n//         if ( isNotFound ) processed.push(-1);\\n//         else processed.push(minSize);\\n//     }\\n//     return processed;\\n// };\\n\\n// Book Solution, Using MinHeap, Time Complexity: O(n log n + q log q), Space Complexity: O(n)(q = queries length)\\nfunction minInterval(intervals: number[][], queries: number[]): number[] {\\n    let nQueries: number[][] = queries.map((query, index) => [query, index]).sort((a, b) => a[0] - b[0]);\\n    intervals.sort((a, b) => a[0] !== b[0] ? a[0] - b[0]: a[1] - b[1]);\\n    let minHeap = new MinPriorityQueue();\\n    let i = 0;\\n    let map = [];\\n    for ( const [query, index] of nQueries) {\\n        while ( i < intervals.length && intervals[i][0] <= query ) {\\n            let [left, right] = intervals[i];\\n            minHeap.enqueue([right - left + 1, right], right - left + 1);\\n            i++;\\n        }\\n        while ( minHeap.size() > 0 && minHeap.front().element[1] < query ) {\\n            minHeap.dequeue();\\n        }\\n        map[index] = minHeap.size() > 0 ? minHeap.front().element[0]: -1;\\n    }\\n    return map;\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\n// Self Solution, Time Limit Exceeded, Time Complexity: O(m * n * k), Space Complexity: O(m * n)(k = queries length)\\n// type ElementGroup = {\\n//     start: number;\\n//     end: number;\\n//     size: number;\\n// }\\n// function minInterval(intervals: number[][], queries: number[]): number[] {\\n//     let arr: ElementGroup[] = [];\\n//     let processed: number[] = [];\\n//     for ( const interval of intervals ) {\\n//         arr.push({\\n//             start: interval[0],\\n//             end: interval[1],\\n//             size: interval[1] - interval[0] + 1\\n//         });\\n//     }\\n//     arr.sort((el1, el2) => (el1.start !== el2.start) ? el1.start - el2.start: el1.end - el2.end);\\n//     for ( let i = 0; i < queries.length; i++ ) {\\n//         let isNotFound: boolean = true;\\n//         let left: number = 0;\\n//         let right: number = arr.length - 1;\\n//         let minSize: number = Infinity;\\n//         // for ( const elementgroup of arr ) {\\n//         //     // if ( queries[i] > elementgroup.end ) continue;\\n//         //     if ( elementgroup.start <= queries[i] && elementgroup.end >= queries[i] )  {\\n//         //         processed.push(elementgroup.size);\\n//         //         isNotFound = false;\\n//         //         break;\\n//         //     }\\n//         // }\\n//         while ( left < right ) {\\n//             let mid = Math.floor((left + right) / 2);\\n//             if ( arr[mid].start > queries[i] ) right = mid - 1;\\n//             else if ( arr[mid].end < queries[i] ) left = mid + 1;\\n//             else {\\n//                 while ( arr[mid].start >= queries[i] && arr[mid].end <= queries[i] ) {\\n//                 // processed.push(arr[mid].size);\\n//                 minSize = Math.min(minSize, arr[mid].size);\\n//                 isNotFound = false;\\n//                 mid--;\\n//             }\\n//             }\\n//         }\\n//         if ( isNotFound ) processed.push(-1);\\n//         else processed.push(minSize);\\n//     }\\n//     return processed;\\n// };\\n\\n// Book Solution, Using MinHeap, Time Complexity: O(n log n + q log q), Space Complexity: O(n)(q = queries length)\\nfunction minInterval(intervals: number[][], queries: number[]): number[] {\\n    let nQueries: number[][] = queries.map((query, index) => [query, index]).sort((a, b) => a[0] - b[0]);\\n    intervals.sort((a, b) => a[0] !== b[0] ? a[0] - b[0]: a[1] - b[1]);\\n    let minHeap = new MinPriorityQueue();\\n    let i = 0;\\n    let map = [];\\n    for ( const [query, index] of nQueries) {\\n        while ( i < intervals.length && intervals[i][0] <= query ) {\\n            let [left, right] = intervals[i];\\n            minHeap.enqueue([right - left + 1, right], right - left + 1);\\n            i++;\\n        }\\n        while ( minHeap.size() > 0 && minHeap.front().element[1] < query ) {\\n            minHeap.dequeue();\\n        }\\n        map[index] = minHeap.size() > 0 ? minHeap.front().element[0]: -1;\\n    }\\n    return map;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3363870,
                "title": "c-sort-priorityqueue",
                "content": "```\\npublic class Solution {\\n    public int[] MinInterval(int[][] intervals, int[] queries) {\\n        int n=queries.Length;\\n        int[] q=Enumerable.Range(0,n).ToArray();\\n        Array.Sort(q,(x,y)=>queries[x].CompareTo(queries[y]));\\n        \\n        int[] res=new int[n];\\n        \\n        Array.Sort(intervals,(x,y)=> x[0].CompareTo(y[0]) );\\n        int j=0;\\n        PriorityQueue<int,int> pq=new PriorityQueue<int,int>();\\n        for(int i=0;i<n;i++)\\n        {\\n            while(j<intervals.Length && intervals[j][0]<=queries[q[i]]){\\n                pq.Enqueue(j, intervals[j][1] -intervals[j][0]+1);\\n                j++;\\n            }\\n\\n            while(pq.Count>0 && intervals[pq.Peek()][1] <queries[q[i]])\\n                pq.Dequeue();\\n            \\n            res[q[i]]=pq.Count >0 ? intervals[pq.Peek()][1]-intervals[pq.Peek()][0]+1 : -1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] MinInterval(int[][] intervals, int[] queries) {\\n        int n=queries.Length;\\n        int[] q=Enumerable.Range(0,n).ToArray();\\n        Array.Sort(q,(x,y)=>queries[x].CompareTo(queries[y]));\\n        \\n        int[] res=new int[n];\\n        \\n        Array.Sort(intervals,(x,y)=> x[0].CompareTo(y[0]) );\\n        int j=0;\\n        PriorityQueue<int,int> pq=new PriorityQueue<int,int>();\\n        for(int i=0;i<n;i++)\\n        {\\n            while(j<intervals.Length && intervals[j][0]<=queries[q[i]]){\\n                pq.Enqueue(j, intervals[j][1] -intervals[j][0]+1);\\n                j++;\\n            }\\n\\n            while(pq.Count>0 && intervals[pq.Peek()][1] <queries[q[i]])\\n                pq.Dequeue();\\n            \\n            res[q[i]]=pq.Count >0 ? intervals[pq.Peek()][1]-intervals[pq.Peek()][0]+1 : -1;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3348911,
                "title": "c-simple-sorting-solution-n-logn",
                "content": "```\\nclass Solution {\\npublic:\\n    std::vector<int> minInterval(std::vector<std::vector<int>> & intervals, std::vector<int> & queries) {\\n        std::vector<std::tuple<int, int, int>> points;\\n        points.reserve(std::size(intervals) + std::size(queries));\\n        for (auto & i : intervals)\\n            points.emplace_back(i[0], 0, i[1] - i[0] + 1), points.emplace_back(i[1], 2, i[1] - i[0] + 1);\\n        for (int i = 0; i < std::size(queries); ++i)\\n            points.emplace_back(queries[i], 1, i);\\n        std::sort(std::begin(points), std::end(points), [] (auto & a, auto & b) noexcept { return std::get<0>(a) < std::get<0>(b) || std::get<0>(a) == std::get<0>(b) && std::get<1>(a) < std::get<1>(b); });\\n\\n        std::vector<int> result(std::size(queries));\\n        std::map<int, int> sizes;\\n\\n        for (auto & [x, type, val] : points) {\\n            switch (type) {\\n                case 0: // starting interval (val is interval length)\\n                    ++sizes[val];\\n                    break;\\n                case 1: // query point (val is result index)\\n                    result[val] = std::empty(sizes) ? -1 : std::begin(sizes)->first;\\n                    break;\\n                case 2: // ending interval (val is interval length)\\n                    if (!--sizes[val])\\n                        sizes.erase(val);\\n                    break;\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    std::vector<int> minInterval(std::vector<std::vector<int>> & intervals, std::vector<int> & queries) {\\n        std::vector<std::tuple<int, int, int>> points;\\n        points.reserve(std::size(intervals) + std::size(queries));\\n        for (auto & i : intervals)\\n            points.emplace_back(i[0], 0, i[1] - i[0] + 1), points.emplace_back(i[1], 2, i[1] - i[0] + 1);\\n        for (int i = 0; i < std::size(queries); ++i)\\n            points.emplace_back(queries[i], 1, i);\\n        std::sort(std::begin(points), std::end(points), [] (auto & a, auto & b) noexcept { return std::get<0>(a) < std::get<0>(b) || std::get<0>(a) == std::get<0>(b) && std::get<1>(a) < std::get<1>(b); });\\n\\n        std::vector<int> result(std::size(queries));\\n        std::map<int, int> sizes;\\n\\n        for (auto & [x, type, val] : points) {\\n            switch (type) {\\n                case 0: // starting interval (val is interval length)\\n                    ++sizes[val];\\n                    break;\\n                case 1: // query point (val is result index)\\n                    result[val] = std::empty(sizes) ? -1 : std::begin(sizes)->first;\\n                    break;\\n                case 2: // ending interval (val is interval length)\\n                    if (!--sizes[val])\\n                        sizes.erase(val);\\n                    break;\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3318059,
                "title": "python-simple-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minInterval(self, intervals, queries):\\n        intervals.sort(key = lambda x:x[0])\\n        dict1, idx, ans = {}, 0, []\\n\\n        for q in sorted(queries):\\n            while idx < len(intervals) and intervals[idx][0] <= q:\\n                left,right = intervals[idx][0],intervals[idx][1]\\n                heapq.heappush(ans,(right-left+1,right))\\n                idx += 1\\n\\n            while ans and ans[0][1] < q:\\n                heappop(ans)\\n\\n            dict1[q] = ans[0][0] if ans else -1\\n\\n        return [dict1[i] for i in queries]\\n\\n\\n            \\n\\n\\n\\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minInterval(self, intervals, queries):\\n        intervals.sort(key = lambda x:x[0])\\n        dict1, idx, ans = {}, 0, []\\n\\n        for q in sorted(queries):\\n            while idx < len(intervals) and intervals[idx][0] <= q:\\n                left,right = intervals[idx][0],intervals[idx][1]\\n                heapq.heappush(ans,(right-left+1,right))\\n                idx += 1\\n\\n            while ans and ans[0][1] < q:\\n                heappop(ans)\\n\\n            dict1[q] = ans[0][0] if ans else -1\\n\\n        return [dict1[i] for i in queries]\\n\\n\\n            \\n\\n\\n\\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261850,
                "title": "minimum-interval-to-include-each-query",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn) or O(klogk) \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(k) where k is the length of the queries\\n\\n# Code\\n```\\nimport heapq as h\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        res=[]\\n        intervals.sort()\\n        s=sorted(queries)\\n        i=0\\n        hm={}\\n        heap=[]\\n        h.heapify(heap)\\n        for q in s:\\n            while(i<len(intervals) and intervals[i][0]<=q):  #You are pushing the intervals in which the query is present in heap\\n                h.heappush(heap,[intervals[i][1]-intervals[i][0]+1,intervals[i][1]])\\n                i+=1\\n            #print(heap)\\n            while(heap and heap[0][1]<q): # of all the intervals in which the query is present, you remove the intervals in which q or any query greater than q is not present\\n                h.heappop(heap)\\n            if len(heap)==0:\\n                hm[q]=-1\\n            else:\\n                hm[q]=heap[0][0]\\n        for q in queries:\\n            res.append(hm[q])\\n        return res\\n                \\n            \\n           \\n                    \\n\\n                \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport heapq as h\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        res=[]\\n        intervals.sort()\\n        s=sorted(queries)\\n        i=0\\n        hm={}\\n        heap=[]\\n        h.heapify(heap)\\n        for q in s:\\n            while(i<len(intervals) and intervals[i][0]<=q):  #You are pushing the intervals in which the query is present in heap\\n                h.heappush(heap,[intervals[i][1]-intervals[i][0]+1,intervals[i][1]])\\n                i+=1\\n            #print(heap)\\n            while(heap and heap[0][1]<q): # of all the intervals in which the query is present, you remove the intervals in which q or any query greater than q is not present\\n                h.heappop(heap)\\n            if len(heap)==0:\\n                hm[q]=-1\\n            else:\\n                hm[q]=heap[0][0]\\n        for q in queries:\\n            res.append(hm[q])\\n        return res\\n                \\n            \\n           \\n                    \\n\\n                \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3252545,
                "title": "heap-swift-short",
                "content": "\\n- Time complexity: O(nlogn + qlogq)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(q+n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Main\\n```\\nclass Solution {\\n    func minInterval(_ intervals: [[Int]], _ queries: [Int]) -> [Int] {\\n        let intervals = intervals.sorted{$0[0] < $1[0]}\\n        let queries = queries.enumerated().sorted{$0.1 < $1.1}\\n        var minHeap = Heap<Interval>(<)\\n        \\n        var ans = Array(repeating: 0, count: queries.count)\\n        var j = 0\\n        for (i, q) in queries {\\n            while j < intervals.count && intervals[j][0] <= q {\\n                minHeap.push(Interval(left: intervals[j][0], right: intervals[j][1] ))\\n                j += 1\\n            }\\n            while !minHeap.isEmpty && minHeap[0].right < q {\\n                minHeap.pop()\\n            }\\n            ans[i] = !minHeap.isEmpty ? (minHeap[0].right - minHeap[0].left + 1) : -1 \\n        }\\n        return ans\\n    }\\n}\\n```\\n# Interval & Heap\\n```\\nstruct Interval: Comparable {\\n    let left, right: Int\\n    static func < (lhs: Interval, rhs: Interval) -> Bool {\\n        return lhs.right - lhs.left < rhs.right - rhs.left\\n    }\\n}\\n\\nstruct Heap<T: Comparable> {\\n    private var heap = [T]()\\n    private let comparator: (T, T)->Bool \\n    \\n    init(_ comparator: @escaping (T, T)->Bool) {\\n        self.comparator = comparator\\n    }\\n    \\n    subscript(i: Int) -> T {heap[i]}\\n    var isEmpty: Bool {heap.isEmpty}\\n    var count: Int {heap.count}\\n    \\n    mutating func push(_ val: T) {\\n        heap.append(val)\\n        var pos = heap.count-1\\n        while pos > 0 && comparator(heap[pos], heap[(pos-1)/2]) {\\n            heap.swapAt(pos, (pos-1)/2)\\n            pos = (pos-1)/2\\n        }\\n    }\\n    \\n    mutating func pop() -> T? {\\n        guard let ans = heap.first else {return nil }\\n        heap[0] = heap.last!\\n        var pos = 0\\n        while pos*2 + 2 < heap.count {\\n            let swapSonInd = \\n                comparator(heap[pos*2 + 1], heap[pos*2 + 2]) ?\\n                (pos*2 + 1) : (pos*2 + 2)\\n            if comparator(heap[swapSonInd], heap[pos]) {\\n                heap.swapAt(pos, swapSonInd)\\n                pos = swapSonInd\\n            } else {\\n                break\\n            }\\n        }\\n        heap.popLast()\\n        return ans\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Swift",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    func minInterval(_ intervals: [[Int]], _ queries: [Int]) -> [Int] {\\n        let intervals = intervals.sorted{$0[0] < $1[0]}\\n        let queries = queries.enumerated().sorted{$0.1 < $1.1}\\n        var minHeap = Heap<Interval>(<)\\n        \\n        var ans = Array(repeating: 0, count: queries.count)\\n        var j = 0\\n        for (i, q) in queries {\\n            while j < intervals.count && intervals[j][0] <= q {\\n                minHeap.push(Interval(left: intervals[j][0], right: intervals[j][1] ))\\n                j += 1\\n            }\\n            while !minHeap.isEmpty && minHeap[0].right < q {\\n                minHeap.pop()\\n            }\\n            ans[i] = !minHeap.isEmpty ? (minHeap[0].right - minHeap[0].left + 1) : -1 \\n        }\\n        return ans\\n    }\\n}\\n```\n```\\nstruct Interval: Comparable {\\n    let left, right: Int\\n    static func < (lhs: Interval, rhs: Interval) -> Bool {\\n        return lhs.right - lhs.left < rhs.right - rhs.left\\n    }\\n}\\n\\nstruct Heap<T: Comparable> {\\n    private var heap = [T]()\\n    private let comparator: (T, T)->Bool \\n    \\n    init(_ comparator: @escaping (T, T)->Bool) {\\n        self.comparator = comparator\\n    }\\n    \\n    subscript(i: Int) -> T {heap[i]}\\n    var isEmpty: Bool {heap.isEmpty}\\n    var count: Int {heap.count}\\n    \\n    mutating func push(_ val: T) {\\n        heap.append(val)\\n        var pos = heap.count-1\\n        while pos > 0 && comparator(heap[pos], heap[(pos-1)/2]) {\\n            heap.swapAt(pos, (pos-1)/2)\\n            pos = (pos-1)/2\\n        }\\n    }\\n    \\n    mutating func pop() -> T? {\\n        guard let ans = heap.first else {return nil }\\n        heap[0] = heap.last!\\n        var pos = 0\\n        while pos*2 + 2 < heap.count {\\n            let swapSonInd = \\n                comparator(heap[pos*2 + 1], heap[pos*2 + 2]) ?\\n                (pos*2 + 1) : (pos*2 + 2)\\n            if comparator(heap[swapSonInd], heap[pos]) {\\n                heap.swapAt(pos, swapSonInd)\\n                pos = swapSonInd\\n            } else {\\n                break\\n            }\\n        }\\n        heap.popLast()\\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3241429,
                "title": "java-solution-using-concurrentskiplistmap",
                "content": "```\\n\\timport java.util.*;\\n\\timport java.util.concurrent.ConcurrentSkipListMap;\\n\\tclass Solution {\\n\\t\\t  public int[] minInterval(int[][] intervals, int[] queries) {\\n\\n\\t\\t\\t{\\n\\n\\t\\t\\tint result[] = new int[queries.length];\\n\\t\\t\\tArrays.fill(result,-1);\\n\\n\\t\\t\\tConcurrentSkipListMap<Integer,LinkedList<Integer>>treeMap = new ConcurrentSkipListMap<Integer, LinkedList<Integer>>();\\n\\t\\t\\tfor(int i=0;i< queries.length;i++){\\n\\t\\t\\t\\tLinkedList<Integer>indices = (treeMap.containsKey(queries[i]))?treeMap.get(queries[i]):new LinkedList<>();\\n\\t\\t\\t\\tindices.add(i);\\n\\t\\t\\t\\ttreeMap.put(queries[i],indices);\\n\\t\\t\\t}\\n\\n\\t\\t\\tArrays.sort(intervals,(a,b)->(a[1]-a[0]+1)-(b[1]-b[0]+1));\\n\\n\\t\\t\\tfor(int i=0;i< intervals.length;i++){\\n\\t\\t\\t\\tint interval[] = intervals[i];\\n\\t\\t\\t\\tMap.Entry<Integer,LinkedList<Integer>>startEntry = treeMap.ceilingEntry(interval[0]);\\n\\t\\t\\t\\tMap.Entry<Integer,LinkedList<Integer>>endEntry = treeMap.floorEntry(interval[1]);\\n\\t\\t\\t\\tif(startEntry==null||endEntry==null)continue;\\n\\t\\t\\t\\tif(interval[1]<startEntry.getKey() || endEntry.getKey()<interval[0])continue;\\n\\n\\t\\t\\t\\tSortedMap<Integer,LinkedList<Integer>> subMap = treeMap.subMap(startEntry.getKey(),endEntry.getKey()+1);\\n\\t\\t\\t\\tIterator<Map.Entry<Integer,LinkedList<Integer>>>iterator = subMap.entrySet().iterator();\\n\\t\\t\\t\\twhile(iterator.hasNext()){\\n\\t\\t\\t\\t\\tMap.Entry<Integer,LinkedList<Integer>>entry = iterator.next();\\n\\t\\t\\t\\t\\tint k = entry.getKey();\\n\\t\\t\\t\\t\\tListIterator<Integer>listIterator = entry.getValue().listIterator();\\n\\t\\t\\t\\t\\twhile (listIterator.hasNext()){\\n\\t\\t\\t\\t\\t\\tresult[listIterator.next()] = interval[1]-interval[0]+1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\ttreeMap.remove(k);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\t  public int[] minInterval(int[][] intervals, int[] queries) {\\n\\n\\t\\t\\t{\\n\\n\\t\\t\\tint result[] = new int[queries.length];\\n\\t\\t\\tArrays.fill(result,-1);\\n\\n\\t\\t\\tConcurrentSkipListMap<Integer,LinkedList<Integer>>treeMap = new ConcurrentSkipListMap<Integer, LinkedList<Integer>>();\\n\\t\\t\\tfor(int i=0;i< queries.length;i++){\\n\\t\\t\\t\\tLinkedList<Integer>indices = (treeMap.containsKey(queries[i]))?treeMap.get(queries[i]):new LinkedList<>();\\n\\t\\t\\t\\tindices.add(i);\\n\\t\\t\\t\\ttreeMap.put(queries[i],indices);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3224936,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn min_interval(intervals: Vec<Vec<i32>>, queries: Vec<i32>) -> Vec<i32> {\\n        let mut intervals = intervals;\\n        intervals.sort();\\n        let mut ids = (0..queries.len()).collect::<Vec<usize>>();\\n        ids.sort_by_key(|&i| queries[i]);\\n        let mut s = std::collections::BTreeSet::new();\\n        let mut res = vec![-1; queries.len()];\\n        let mut j = 0;\\n        for i in ids {\\n            while j < intervals.len() && intervals[j][0] <= queries[i] {\\n                s.insert((intervals[j][1] - intervals[j][0] + 1, intervals[j][1]));\\n                j += 1;\\n            }\\n            while !s.is_empty() && s.iter().next().unwrap().1 < queries[i] {\\n                let v = *s.iter().next().unwrap();\\n                s.remove(&v);\\n            }\\n            if !s.is_empty() {\\n                res[i] = s.iter().next().unwrap().0;\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_interval(intervals: Vec<Vec<i32>>, queries: Vec<i32>) -> Vec<i32> {\\n        let mut intervals = intervals;\\n        intervals.sort();\\n        let mut ids = (0..queries.len()).collect::<Vec<usize>>();\\n        ids.sort_by_key(|&i| queries[i]);\\n        let mut s = std::collections::BTreeSet::new();\\n        let mut res = vec![-1; queries.len()];\\n        let mut j = 0;\\n        for i in ids {\\n            while j < intervals.len() && intervals[j][0] <= queries[i] {\\n                s.insert((intervals[j][1] - intervals[j][0] + 1, intervals[j][1]));\\n                j += 1;\\n            }\\n            while !s.is_empty() && s.iter().next().unwrap().1 < queries[i] {\\n                let v = *s.iter().next().unwrap();\\n                s.remove(&v);\\n            }\\n            if !s.is_empty() {\\n                res[i] = s.iter().next().unwrap().0;\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3169695,
                "title": "c-o-nlog-n-qlog-q-sorting-greedy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor each query, we will have several candidate intervals which contain it and we want to find the one with smallest interval span. So using a priority queue as minheap is reasonable.\\n\\nHowever, we cannot tolerate the time complexity $O(nq)$ to finding all the possible candidate intervals for each query every time, so we have to sort both of them to make each interval be inserted into and removed from the minheap at most once.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort the query from small to large and sort the intervals from smallest start point to greatest.\\n\\nSince the query `q_i` is now ever-increasing, so for each time we only have to \\n1. add all the residual intervals with starting point `<= q_i` into the priority queue,\\n2. remove intervals in priority queue with end point `< q_i`, and \\n3. finally query the minimal value in the priority queue. \\n\\nSince the starting point of the interval is ever increasing, when doing step 1, we can keep a pointer `ptr` pointing to the first interval that is not added in the previous query. As a result, each interval may be put into the minheap at most once and removed at most once.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(n\\\\log n + q\\\\log q + n\\\\log n)$: Sort interval + sort query + push each intervals into the minheap at most once \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(q + n)$: n for minheap and q for storing the queries and their indexes.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        int q = queries.size();\\n        vector<pair<int, int>> v;\\n        vector<int> res (q);\\n        for (int i = 0;i < q; ++i) {\\n            v.push_back({queries[i], i});\\n        }\\n\\n        ::sort(begin(v), end(v));\\n        ::sort(begin(intervals), end(intervals));\\n\\n        int ptr = 0, n = intervals.size();\\n        priority_queue<pair<int, int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;\\n        for (int i = 0; i < q; ++i) {\\n            auto [x, idx] = v[i];\\n            // insert all intervals with a start point  <= x\\n            while (ptr < n && intervals[ptr][0] <= x) {\\n                pq.push({intervals[ptr][1] -intervals[ptr][0] + 1, intervals[ptr][1]});\\n                ++ptr;\\n            }\\n            // remove all interval with an end point < x\\n            while (!pq.empty() && pq.top().second < x) {\\n                pq.pop();\\n            }\\n            res[idx] = pq.empty()?-1:pq.top().first;\\n        }\\n        return res;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        int q = queries.size();\\n        vector<pair<int, int>> v;\\n        vector<int> res (q);\\n        for (int i = 0;i < q; ++i) {\\n            v.push_back({queries[i], i});\\n        }\\n\\n        ::sort(begin(v), end(v));\\n        ::sort(begin(intervals), end(intervals));\\n\\n        int ptr = 0, n = intervals.size();\\n        priority_queue<pair<int, int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;\\n        for (int i = 0; i < q; ++i) {\\n            auto [x, idx] = v[i];\\n            // insert all intervals with a start point  <= x\\n            while (ptr < n && intervals[ptr][0] <= x) {\\n                pq.push({intervals[ptr][1] -intervals[ptr][0] + 1, intervals[ptr][1]});\\n                ++ptr;\\n            }\\n            // remove all interval with an end point < x\\n            while (!pq.empty() && pq.top().second < x) {\\n                pq.pop();\\n            }\\n            res[idx] = pq.empty()?-1:pq.top().first;\\n        }\\n        return res;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3149945,
                "title": "python-solution-using-minheap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def minInterval(self, intervals, queries):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type queries: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        intervals.sort()\\n        ans = {}\\n        minheap = []\\n        i = 0\\n        for query in sorted(queries):\\n            while(i < len(intervals) and  intervals[i][0] <= query):\\n                left,right = intervals[i]\\n                heapq.heappush(minheap, (right - left +1, right))\\n                i +=1\\n            interval = -1\\n            while(minheap and minheap[0][1] < query):\\n                heapq.heappop(minheap)\\n            ans[query] = minheap[0][0] if minheap else -1\\n        return [ans[query] for query in queries]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minInterval(self, intervals, queries):\\n        \"\"\"\\n        :type intervals: List[List[int]]\\n        :type queries: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        intervals.sort()\\n        ans = {}\\n        minheap = []\\n        i = 0\\n        for query in sorted(queries):\\n            while(i < len(intervals) and  intervals[i][0] <= query):\\n                left,right = intervals[i]\\n                heapq.heappush(minheap, (right - left +1, right))\\n                i +=1\\n            interval = -1\\n            while(minheap and minheap[0][1] < query):\\n                heapq.heappop(minheap)\\n            ans[query] = minheap[0][0] if minheap else -1\\n        return [ans[query] for query in queries]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3122003,
                "title": "c-ordered-set-lower-bound-upper-bound-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int> &I1, vector<int> &I2){\\n        int size1=I1[1]-I1[0]+1;\\n        int size2=I2[1]-I2[0]+1;\\n        return size1<size2;\\n    }\\n    \\n    vector<int> minInterval(vector<vector<int>> &intervals, vector<int> &queries) {\\n        int n=queries.size();        \\n        \\n        sort(intervals.begin(),intervals.end(),cmp);\\n        \\n        vector<pair<int,int>> Q;\\n        for(int i=0;i<n;i++){\\n            Q.push_back({queries[i],i});\\n        }\\n        \\n        set<pair<int,int>> QS(Q.begin(),Q.end());\\n        \\n        vector<int> res(n,-1);  \\n\\n        for(int i=0;i<intervals.size() && !QS.empty();i++){\\n            \\n            int start=intervals[i][0];\\n            int end=intervals[i][1];\\n            int range=end-start+1;\\n            \\n            auto itr1=QS.lower_bound({start,-1});\\n            auto itr2=QS.upper_bound({end,INT_MAX});\\n            \\n            if(itr2==QS.begin()){\\n                continue;\\n            }\\n            \\n            for(auto itr=itr1;itr!=itr2;itr++){\\n                res[itr->second]=range;\\n            }\\n            \\n            QS.erase(itr1,itr2);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int> &I1, vector<int> &I2){\\n        int size1=I1[1]-I1[0]+1;\\n        int size2=I2[1]-I2[0]+1;\\n        return size1<size2;\\n    }\\n    \\n    vector<int> minInterval(vector<vector<int>> &intervals, vector<int> &queries) {\\n        int n=queries.size();        \\n        \\n        sort(intervals.begin(),intervals.end(),cmp);\\n        \\n        vector<pair<int,int>> Q;\\n        for(int i=0;i<n;i++){\\n            Q.push_back({queries[i],i});\\n        }\\n        \\n        set<pair<int,int>> QS(Q.begin(),Q.end());\\n        \\n        vector<int> res(n,-1);  \\n\\n        for(int i=0;i<intervals.size() && !QS.empty();i++){\\n            \\n            int start=intervals[i][0];\\n            int end=intervals[i][1];\\n            int range=end-start+1;\\n            \\n            auto itr1=QS.lower_bound({start,-1});\\n            auto itr2=QS.upper_bound({end,INT_MAX});\\n            \\n            if(itr2==QS.begin()){\\n                continue;\\n            }\\n            \\n            for(auto itr=itr1;itr!=itr2;itr++){\\n                res[itr->second]=range;\\n            }\\n            \\n            QS.erase(itr1,itr2);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3119097,
                "title": "c-priority-queue-sorting-sorting-queries-to-get-results-faster-great-question",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        vector<int> Q = queries;\\n        sort(Q.begin(), Q.end());\\n        sort(intervals.begin(), intervals.end());\\n        unordered_map<int, int> mp;\\n        priority_queue<pair<int, int>> pq; // {-intervalSize, intervalEnd}\\n        int i = 0;\\n        for(int q : Q) {\\n            while(i < intervals.size() && intervals[i][0] <= q) {\\n                pq.push({-(intervals[i][1] - intervals[i][0] + 1), intervals[i][1]});\\n                i++;\\n            }\\n            while(!pq.empty() && pq.top().second < q) {\\n                pq.pop();\\n            }\\n            mp[q] = !pq.empty() ? -(pq.top().first) : -1;\\n        }\\n        vector<int> ans;\\n        for(int q : queries) {\\n            ans.push_back(mp[q]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        vector<int> Q = queries;\\n        sort(Q.begin(), Q.end());\\n        sort(intervals.begin(), intervals.end());\\n        unordered_map<int, int> mp;\\n        priority_queue<pair<int, int>> pq; // {-intervalSize, intervalEnd}\\n        int i = 0;\\n        for(int q : Q) {\\n            while(i < intervals.size() && intervals[i][0] <= q) {\\n                pq.push({-(intervals[i][1] - intervals[i][0] + 1), intervals[i][1]});\\n                i++;\\n            }\\n            while(!pq.empty() && pq.top().second < q) {\\n                pq.pop();\\n            }\\n            mp[q] = !pq.empty() ? -(pq.top().first) : -1;\\n        }\\n        vector<int> ans;\\n        for(int q : queries) {\\n            ans.push_back(mp[q]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115715,
                "title": "c-easy-solution-using-lower-bound",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem can be solved efficiently with the help of lower_bound(). Lower bound returns the first element in the given data structure that is >= the passed in value.\\n\\nBy sorting the intervals by their size and using a set to store the queries in order, we can solve this problem in O(NLOGM) where N is the number of intervals, and M is the number of queries.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, sort the intervals from smallest to largest size. Then, insert all queries into a set. Also, initialize a hash table to store the size of the interval found for each query as we go.\\n\\nThen, we iterate through all of our intervals and perform a binary search (using lower_bound) to find an iterator to the smallest query in our query set such that it is >= than the interval\\'s start. Then, we use the iterator given to check if the query is within the interval\\'s range and update our hash table to store that query\\'s answer. We keep iterating the iterator until the query is not within the current interval\\'s range.\\n\\nLastely, we generate our answer using the hash table that stores each query\\'s interval size. Be sure to check if a query didn\\'t find an interval.\\n\\n# Complexity\\n- Time complexity: O(N*LOGM) - N = number of intervals, M = number of queries.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    class myComp {\\n    public:\\n        bool operator()(vector<int>& i1, vector<int>& i2) {\\n            return i1[1] - i1[0] + 1 < i2[1] - i2[0] + 1;\\n        }\\n    };\\n\\n\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        sort(intervals.begin(), intervals.end(), myComp()); // sort by size\\n\\n        // Make set of queries\\n        set<int> query_set;\\n        for (const auto& query : queries) {\\n            query_set.insert(query);\\n        }\\n\\n        unordered_map<int, int> ans = {}; // For each query, what index did we find its smallest interval at\\n\\n        for (int i = 0; i < intervals.size(); ++i) {\\n            if (query_set.size() == 0) {\\n                break;\\n            }\\n\\n            // Start at first query such that it is in this interval\\'s range.\\n            // Lower bound returns the lowest value in query set such that it is >= start of interval.\\n            auto it = query_set.lower_bound(intervals[i][0]);\\n            while (it != query_set.end() && *it <= intervals[i][1]) {\\n                // Fits inside interval\\n                ans[*it] = intervals[i][1] - intervals[i][0] + 1;\\n                auto new_it = it;\\n                new_it++;\\n                query_set.erase(it);\\n                it = new_it;\\n            }\\n        }\\n\\n        // Generate answer\\n        vector<int> ans_final;\\n        for (const auto& query : queries) {\\n            if (ans.find(query) != ans.end()) {\\n                ans_final.push_back(ans[query]);\\n            } else {\\n                ans_final.push_back(-1);\\n            }\\n        }\\n\\n        return ans_final;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    class myComp {\\n    public:\\n        bool operator()(vector<int>& i1, vector<int>& i2) {\\n            return i1[1] - i1[0] + 1 < i2[1] - i2[0] + 1;\\n        }\\n    };\\n\\n\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        sort(intervals.begin(), intervals.end(), myComp()); // sort by size\\n\\n        // Make set of queries\\n        set<int> query_set;\\n        for (const auto& query : queries) {\\n            query_set.insert(query);\\n        }\\n\\n        unordered_map<int, int> ans = {}; // For each query, what index did we find its smallest interval at\\n\\n        for (int i = 0; i < intervals.size(); ++i) {\\n            if (query_set.size() == 0) {\\n                break;\\n            }\\n\\n            // Start at first query such that it is in this interval\\'s range.\\n            // Lower bound returns the lowest value in query set such that it is >= start of interval.\\n            auto it = query_set.lower_bound(intervals[i][0]);\\n            while (it != query_set.end() && *it <= intervals[i][1]) {\\n                // Fits inside interval\\n                ans[*it] = intervals[i][1] - intervals[i][0] + 1;\\n                auto new_it = it;\\n                new_it++;\\n                query_set.erase(it);\\n                it = new_it;\\n            }\\n        }\\n\\n        // Generate answer\\n        vector<int> ans_final;\\n        for (const auto& query : queries) {\\n            if (ans.find(query) != ans.end()) {\\n                ans_final.push_back(ans[query]);\\n            } else {\\n                ans_final.push_back(-1);\\n            }\\n        }\\n\\n        return ans_final;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047969,
                "title": "python-heap-49-time-5-space",
                "content": "```\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        intervals.sort(key=lambda x: (x[0], x[1]))\\n        q = [[idx, query] for idx, query in enumerate(queries)]\\n        q.sort(key=lambda x: (x[1], x[0]))\\n\\n        output = [-1] * len(queries)\\n        heap = []\\n        intervals_idx = 0\\n        for query_idx, query in q:\\n            while intervals_idx < len(intervals):\\n                l, r = intervals[intervals_idx]\\n                if l <= query <= r or r < query:\\n                    heapq.heappush(heap, [r - l + 1, l, r])\\n                    intervals_idx += 1\\n                else: break\\n\\n            while heap:\\n                interval, ll, rr = heap[0]\\n                if not ll <= query <= rr: heapq.heappop(heap)\\n                else:\\n                    output[query_idx] = interval\\n                    break\\n\\n        return output\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        intervals.sort(key=lambda x: (x[0], x[1]))\\n        q = [[idx, query] for idx, query in enumerate(queries)]\\n        q.sort(key=lambda x: (x[1], x[0]))\\n\\n        output = [-1] * len(queries)\\n        heap = []\\n        intervals_idx = 0\\n        for query_idx, query in q:\\n            while intervals_idx < len(intervals):\\n                l, r = intervals[intervals_idx]\\n                if l <= query <= r or r < query:\\n                    heapq.heappush(heap, [r - l + 1, l, r])\\n                    intervals_idx += 1\\n                else: break\\n\\n            while heap:\\n                interval, ll, rr = heap[0]\\n                if not ll <= query <= rr: heapq.heappop(heap)\\n                else:\\n                    output[query_idx] = interval\\n                    break\\n\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043933,
                "title": "java-priorityqueue-hashmap-easy-to-understand",
                "content": "# Approach\\nHashMap\\nKey - query number\\nValue - smallest len for that query number\\n\\nFirst we order the intervals and queries in ascending order.\\nThen we see which intervals can potentially encompass the query number by comparing ONLY the left marker on ther interval.\\n\\nWe do this because we may have multimple interval that satisfy this criteria and we later need to get the smallest one.\\n\\nAfter we have our \"candidate\" list we then look for the smaller.\\nWhile we are still in the same query number we will use the power of the heap to keep removing the top interval if the right number does not encompass the query.  We do this unti lwe meet an interval can can encompass.  At this point we have found our small interval if it exists.  \\n\\nWe then just add it, or if the PQ is empty cuz we polled everything then add a -1 in the map for that query.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public class Interval {\\n\\n        int left;\\n        int right;\\n        int len;\\n\\n        public Interval(int[] interval) {\\n            this.left = interval[0];\\n            this.right = interval[1];\\n            this.len = right - left + 1;\\n        }\\n    }\\n    \\n    public int[] minInterval(int[][] intervals, int[] queries) {\\n        Arrays.sort(intervals, (a,b) -> a[0] - b[0]);\\n        int[] queriesClone = queries.clone();\\n        Arrays.sort(queriesClone);\\n\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        PriorityQueue<Interval> pq = new PriorityQueue<>( (a,b) -> a.len - b.len );\\n\\n        int index = 0;\\n\\n        for(int query : queriesClone) {\\n\\n            while(index < intervals.length && intervals[index][0] <= query) {\\n                pq.offer(new Interval(intervals[index]));  // these are our potential intervaLs that can encomapss our query\\n                index++;\\n            }\\n            \\n            while(!pq.isEmpty() && pq.peek().right < query) {\\n                pq.poll();\\n            }\\n\\n            if(!pq.isEmpty()) {\\n                hm.put(query, pq.peek().len);\\n            }\\n        }\\n        \\n        int[] res = new int[queries.length];\\n\\n        int i=0;\\n        for(int query : queries) {\\n            res[i++] = hm.getOrDefault(query, -1);\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n\\n    public class Interval {\\n\\n        int left;\\n        int right;\\n        int len;\\n\\n        public Interval(int[] interval) {\\n            this.left = interval[0];\\n            this.right = interval[1];\\n            this.len = right - left + 1;\\n        }\\n    }\\n    \\n    public int[] minInterval(int[][] intervals, int[] queries) {\\n        Arrays.sort(intervals, (a,b) -> a[0] - b[0]);\\n        int[] queriesClone = queries.clone();\\n        Arrays.sort(queriesClone);\\n\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        PriorityQueue<Interval> pq = new PriorityQueue<>( (a,b) -> a.len - b.len );\\n\\n        int index = 0;\\n\\n        for(int query : queriesClone) {\\n\\n            while(index < intervals.length && intervals[index][0] <= query) {\\n                pq.offer(new Interval(intervals[index]));  // these are our potential intervaLs that can encomapss our query\\n                index++;\\n            }\\n            \\n            while(!pq.isEmpty() && pq.peek().right < query) {\\n                pq.poll();\\n            }\\n\\n            if(!pq.isEmpty()) {\\n                hm.put(query, pq.peek().len);\\n            }\\n        }\\n        \\n        int[] res = new int[queries.length];\\n\\n        int i=0;\\n        for(int query : queries) {\\n            res[i++] = hm.getOrDefault(query, -1);\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3036216,
                "title": "cpp-sort-intervals-and-queries",
                "content": "### Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        int n = queries.size(), handled = 0;\\n        \\n        vector<int> res(n, -1);\\n        set<pair<int,int>> queriesWithPos;\\n        \\n        // sort intervals based on size\\n        sort(intervals.begin(), intervals.end(), [](const vector<int>& a, const vector<int>& b){\\n            return a[1]-a[0] < b[1]-b[0];\\n        });\\n\\n        // use set to store the queries in increasing order, also store thier index\\n        for(int i=0;i<n;i++) queriesWithPos.insert({queries[i], i});\\n\\n        for(auto interval: intervals) {\\n            int st = interval[0], end = interval[1];\\n\\n            // for the smallest interval, update the answer for all the queries which fall inside it\\n            auto it = queriesWithPos.lower_bound({st, 0});\\n            while(it!=queriesWithPos.end() and it->first <= end) {\\n                res[it->second] = (end - st + 1);\\n                // remove the query from set once found its answer\\n                queriesWithPos.erase(it++);\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        int n = queries.size(), handled = 0;\\n        \\n        vector<int> res(n, -1);\\n        set<pair<int,int>> queriesWithPos;\\n        \\n        // sort intervals based on size\\n        sort(intervals.begin(), intervals.end(), [](const vector<int>& a, const vector<int>& b){\\n            return a[1]-a[0] < b[1]-b[0];\\n        });\\n\\n        // use set to store the queries in increasing order, also store thier index\\n        for(int i=0;i<n;i++) queriesWithPos.insert({queries[i], i});\\n\\n        for(auto interval: intervals) {\\n            int st = interval[0], end = interval[1];\\n\\n            // for the smallest interval, update the answer for all the queries which fall inside it\\n            auto it = queriesWithPos.lower_bound({st, 0});\\n            while(it!=queriesWithPos.end() and it->first <= end) {\\n                res[it->second] = (end - st + 1);\\n                // remove the query from set once found its answer\\n                queriesWithPos.erase(it++);\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2913199,
                "title": "java-solution-using-heap",
                "content": "# Intuition\\nadd all the possible intervals for the given query and pick the one which has minimum interval size.\\n\\n# Approach\\nsort the queries.(we maintain a datastructure to keep track of indices of each query)\\nsort the intervals in ascending order\\nremove element from heap if current query is greater than the \"end\" interval of the peek.\\nadd all valid intervals to heap.\\nif heap is empty, then store -1 in result else size of the peek interval\\n\\n# Complexity\\n- Time complexity:\\n  O(nlogn)\\n\\n- Space complexity:\\n  O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] minInterval(int[][] intervals, int[] queries) {\\n        int[][] queriesIdx =new int[queries.length][2];\\n        for(int i=0;i<queries.length;i++){\\n            queriesIdx[i]=new int[]{queries[i],i};\\n        }\\n        Arrays.sort(queriesIdx,(q1,q2)->(q1[0]-q2[0]));\\n        Arrays.sort(intervals, (i1,i2)->{\\n            if(i1[0]==i2[0]) return i1[1]-i2[1];\\n            return i1[0]-i2[0];\\n        });\\n        int[] result = new int[queries.length];\\n        PriorityQueue<int[]> heap = new PriorityQueue<>((a,b)->{\\n            return (a[1]-a[0]+1)-(b[1]-b[0]+1);\\n        });\\n        int pos=0;\\n        for(int i=0;i<queries.length;i++){\\n            while(!heap.isEmpty() && queriesIdx[i][0]>heap.peek()[1]){\\n                heap.poll();\\n            }\\n            while(pos<intervals.length && intervals[pos][0]<=queriesIdx[i][0]){\\n                  if(queriesIdx[i][0]>=intervals[pos][0] && queriesIdx[i][0]<=intervals[pos][1]){\\n                      heap.add(new int[]{intervals[pos][0],intervals[pos][1]});\\n                  }\\n                  pos++;\\n            }\\n            if(heap.isEmpty()) result[queriesIdx[i][1]]=-1;\\n            else result[queriesIdx[i][1]]=heap.peek()[1]-heap.peek()[0]+1;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int[] minInterval(int[][] intervals, int[] queries) {\\n        int[][] queriesIdx =new int[queries.length][2];\\n        for(int i=0;i<queries.length;i++){\\n            queriesIdx[i]=new int[]{queries[i],i};\\n        }\\n        Arrays.sort(queriesIdx,(q1,q2)->(q1[0]-q2[0]));\\n        Arrays.sort(intervals, (i1,i2)->{\\n            if(i1[0]==i2[0]) return i1[1]-i2[1];\\n            return i1[0]-i2[0];\\n        });\\n        int[] result = new int[queries.length];\\n        PriorityQueue<int[]> heap = new PriorityQueue<>((a,b)->{\\n            return (a[1]-a[0]+1)-(b[1]-b[0]+1);\\n        });\\n        int pos=0;\\n        for(int i=0;i<queries.length;i++){\\n            while(!heap.isEmpty() && queriesIdx[i][0]>heap.peek()[1]){\\n                heap.poll();\\n            }\\n            while(pos<intervals.length && intervals[pos][0]<=queriesIdx[i][0]){\\n                  if(queriesIdx[i][0]>=intervals[pos][0] && queriesIdx[i][0]<=intervals[pos][1]){\\n                      heap.add(new int[]{intervals[pos][0],intervals[pos][1]});\\n                  }\\n                  pos++;\\n            }\\n            if(heap.isEmpty()) result[queriesIdx[i][1]]=-1;\\n            else result[queriesIdx[i][1]]=heap.peek()[1]-heap.peek()[0]+1;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2893074,
                "title": "python-heap-solution",
                "content": "```\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], q: List[int]) -> List[int]:\\n        h=[]\\n        intervals=sorted(intervals)\\n        qs=sorted([(q[i],i) for i in range(len(q))])\\n        pi=0\\n        r=[-1 for i in range(len(q))]\\n        for q,i in qs:\\n            while pi<len(intervals) and intervals[pi][0] <= q:\\n                heappush(h, (intervals[pi][1]-intervals[pi][0]+1,pi))\\n                pi+=1\\n            while len(h)>0 and intervals[h[0][1]][1] < q:heappop(h)\\n            if len(h)>0:r[i]=h[0][0]\\n        return r\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], q: List[int]) -> List[int]:\\n        h=[]\\n        intervals=sorted(intervals)\\n        qs=sorted([(q[i],i) for i in range(len(q))])\\n        pi=0\\n        r=[-1 for i in range(len(q))]\\n        for q,i in qs:\\n            while pi<len(intervals) and intervals[pi][0] <= q:\\n                heappush(h, (intervals[pi][1]-intervals[pi][0]+1,pi))\\n                pi+=1\\n            while len(h)>0 and intervals[h[0][1]][1] < q:heappop(h)\\n            if len(h)>0:r[i]=h[0][0]\\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2862706,
                "title": "python-from-brute-force-to-min-heap-solution",
                "content": "## **1. BRUTE FORCE APPROACH - TLE**\\n\\nIn the Brute Force Approach, for each query, we have to traverse the whole list to find the minimum interval size. This is not efficient and hence, we will get TLE.\\n\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        output = [0] * len(queries)\\n        \\n        minVal = float(\\'inf\\')\\n        \\n        # For each query\\n        # Go through the intervals list and find the minimum size\\n        for i,query in enumerate(queries):\\n            minSize = minVal\\n            \\n            for left, right in intervals:\\n                if left <= query and right >= query: \\n                    minSize = min(minSize, right - left + 1)\\n                    \\n            output[i] = minSize if minSize != minVal else -1 \\n        \\n        return output\\n\\t\\t\\n## **2. USING A MINHEAP**\\n\\nWhat if the intervals were sorted based on their start time? Then, all those intervals for which the start value is already > query are of no use and we should not waste our time checking them. So that means, as soon as we reach an interval for which \"start\" > \"query\", we know that not just that interval, but all the intervals after it are also not valid so no need to waste time checking them. \\n\\nThis also means, all the intervals for which \"left\" <= \"query\", may contain the \"query\". Why did I say \"may contain\"? Because  it is also possible that while left <= query, the right is not >= query. \\n\\n\\tSuppose we have interval = [1,5] and query = 6\\n\\n\\tThen, we know that since 1 <= 6, it is possible that \"6\" may be in this interval\\n\\t\\n\\tBut after we see that \"5\" < \"6\", we know this interval is not at all valid and \"6\" is not in it. \\n\\t\\nAnd that\\'s the idea of the Min Heap approach. We will use a MinHeap because we are looking for the minimum size of an interval that contains the \"query\". So, first, we will simply push all those intervals in the MinHeap which we think could contain the point \"query\". \\n\\nAnd once we are done, we will then remove all those intervals from the top for which \"right\" > \"query\". \\n\\nAnd now, on the top of heap, we will be left with the smallest interval size since this is a Minheap and so, smallest size will be on top.\\n\\nAlso, as the elements in heap are to be placed based on the size, that means, we have to push a pair in the heap -> (size, right).\\n\\nAnd since we want ouput array to have value for the original query index, we also need to keep track of the original index of each query. Hence, before soring the query array, we have to convert each value to a pair (query, queryIndex). \\n\\n```\\ndef minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        output = [0] * len(queries)\\n        \\n        # The reason why above solution gives TLE for some test cases is because,\\n        # For each query, we have to traverse the whole list of intervals again\\n        # And that is not efficient\\n        \\n        # Can sorting help in this case?\\n        # Let\\'s see\\n        # First, we sort the intervals by their start time\\n        intervals.sort()\\n        \\n        # Since in output, each index corresponds to the index of query, we don\\'t want to lose track of original indices\\n        # So, before sorting, we will make sure to convert each query into a pair (query, index)\\n        queries = [(query, index) for index,query in enumerate(queries)]\\n        \\n        # Now we sort\\n        queries.sort()\\n        \\n        # Min Heap\\n        minH = []\\n        \\n        # To track the interval indices\\n        idx = 0\\n        \\n        # Now, for each query\\n        for query , queryIndex in queries:\\n            \\n            # We will put all the intervals that this query could belong to in the minHeap\\n            # Since the intervals are sorted by their \"start\" value, we will put all intervals in heap\\n            # for which, the start value is <= query as the \"query\" may belong in that interval\\n            \\n            # In the heap, we will put a pair (size, right)\\n            # Such that after we are done pushing, we can then pop the intervals that are not valid\\n            # That is, the intervals for which \"right\" is < query (Since we want right >= query in a valid interval)\\n            \\n            while idx < len(intervals) and intervals[idx][0] <= query:\\n                left = intervals[idx][0]\\n                right = intervals[idx][1]\\n                \\n                size = right - left + 1\\n                \\n                heappush(minH, (size, right))\\n                \\n                idx += 1\\n            \\n            \\n            # Now, we remove the intervals that are not valid. That is, for which right < query\\n            while minH and minH[0][1] < query: heappop(minH)\\n        \\n            # And since this is a minHeap and the values are ordered based on the \"size\"\\n            # The smallest interval containing \"query\" is the topmost value of heap\\n            # It is also possible that heap is empty, meaning, we need to push -1 in output array this case\\n            \\n            if not minH: output[queryIndex] = -1\\n            else: output[queryIndex] = minH[0][0]        \\n        \\n        return output\\n```\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ndef minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        output = [0] * len(queries)\\n        \\n        # The reason why above solution gives TLE for some test cases is because,\\n        # For each query, we have to traverse the whole list of intervals again\\n        # And that is not efficient\\n        \\n        # Can sorting help in this case?\\n        # Let\\'s see\\n        # First, we sort the intervals by their start time\\n        intervals.sort()\\n        \\n        # Since in output, each index corresponds to the index of query, we don\\'t want to lose track of original indices\\n        # So, before sorting, we will make sure to convert each query into a pair (query, index)\\n        queries = [(query, index) for index,query in enumerate(queries)]\\n        \\n        # Now we sort\\n        queries.sort()\\n        \\n        # Min Heap\\n        minH = []\\n        \\n        # To track the interval indices\\n        idx = 0\\n        \\n        # Now, for each query\\n        for query , queryIndex in queries:\\n            \\n            # We will put all the intervals that this query could belong to in the minHeap\\n            # Since the intervals are sorted by their \"start\" value, we will put all intervals in heap\\n            # for which, the start value is <= query as the \"query\" may belong in that interval\\n            \\n            # In the heap, we will put a pair (size, right)\\n            # Such that after we are done pushing, we can then pop the intervals that are not valid\\n            # That is, the intervals for which \"right\" is < query (Since we want right >= query in a valid interval)\\n            \\n            while idx < len(intervals) and intervals[idx][0] <= query:\\n                left = intervals[idx][0]\\n                right = intervals[idx][1]\\n                \\n                size = right - left + 1\\n                \\n                heappush(minH, (size, right))\\n                \\n                idx += 1\\n            \\n            \\n            # Now, we remove the intervals that are not valid. That is, for which right < query\\n            while minH and minH[0][1] < query: heappop(minH)\\n        \\n            # And since this is a minHeap and the values are ordered based on the \"size\"\\n            # The smallest interval containing \"query\" is the topmost value of heap\\n            # It is also possible that heap is empty, meaning, we need to push -1 in output array this case\\n            \\n            if not minH: output[queryIndex] = -1\\n            else: output[queryIndex] = minH[0][0]        \\n        \\n        return output\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2862063,
                "title": "c-priority-queue-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& A, vector<int>& Q) {\\n        int N = Q.size(), M = A.size();\\n        sort(begin(A), end(A));\\n        \\n        vector<vector<int>> qq;\\n        for(int i = 0; i < N; i++) qq.push_back({Q[i], i});\\n        sort(begin(qq), end(qq));\\n\\n        auto comp = [](auto & a, auto & b){\\n            return a[1]- a[0] >= b[1]-b[0];\\n        };\\n        priority_queue<vector<int>, vector<vector<int>>, decltype(comp)> pq(comp);\\n\\n        vector<int> res(N, -1);\\n        int idx = 0;\\n        for(auto & q : qq) {\\n            while(idx < M && q[0] >= A[idx][0]) {\\n                if(q[0] <= A[idx][1]) pq.push(A[idx]);\\n                idx++;\\n            }\\n            while(!pq.empty() && q[0] > pq.top()[1]) pq.pop();\\n            if(pq.empty()) continue;\\n            res[q[1]] = pq.top()[1]-pq.top()[0]+1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& A, vector<int>& Q) {\\n        int N = Q.size(), M = A.size();\\n        sort(begin(A), end(A));\\n        \\n        vector<vector<int>> qq;\\n        for(int i = 0; i < N; i++) qq.push_back({Q[i], i});\\n        sort(begin(qq), end(qq));\\n\\n        auto comp = [](auto & a, auto & b){\\n            return a[1]- a[0] >= b[1]-b[0];\\n        };\\n        priority_queue<vector<int>, vector<vector<int>>, decltype(comp)> pq(comp);\\n\\n        vector<int> res(N, -1);\\n        int idx = 0;\\n        for(auto & q : qq) {\\n            while(idx < M && q[0] >= A[idx][0]) {\\n                if(q[0] <= A[idx][1]) pq.push(A[idx]);\\n                idx++;\\n            }\\n            while(!pq.empty() && q[0] > pq.top()[1]) pq.pop();\\n            if(pq.empty()) continue;\\n            res[q[1]] = pq.top()[1]-pq.top()[0]+1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2857381,
                "title": "excellent-question-to-think-about-dynamic-heaps",
                "content": "# Intuition\\nThis problem is easy if you think that you have a dynamic pool of elegible intervals. The secret is to mantain and update that pool in a heap so to efectively select the smallest interval.\\n\\n# Approach\\nMin heap\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*logn)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] minInterval(int[][] in, int[] queries) {\\n        Map<Integer,Integer> resp = new HashMap();\\n        int[] q = queries.clone();\\n        Arrays.sort(q);\\n        Queue<int[]> pq = new PriorityQueue<int[]>((a,b)->a[1]-a[0]-(b[1]-b[0]));\\n        Arrays.sort(in,(a,b)->a[0]-b[0]);\\n        int elegible=0;\\n        for(int next : q) {\\n            if(resp.containsKey(next)) continue;\\n            // Add the new elegible intervals\\n            while(elegible<in.length&&in[elegible][0]<=next) pq.add(in[elegible++]);\\n            // Remove intervals that are not in range\\n            while(!pq.isEmpty()&&pq.peek()[1]<next) pq.remove();\\n            resp.put(next,pq.isEmpty()?-1:pq.peek()[1]-pq.peek()[0]+1);\\n        }\\n        int[] r = new int[q.length];\\n        for(int i=0;i<r.length;i++) r[i]=resp.get(queries[i]);\\n        return r;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int[] minInterval(int[][] in, int[] queries) {\\n        Map<Integer,Integer> resp = new HashMap();\\n        int[] q = queries.clone();\\n        Arrays.sort(q);\\n        Queue<int[]> pq = new PriorityQueue<int[]>((a,b)->a[1]-a[0]-(b[1]-b[0]));\\n        Arrays.sort(in,(a,b)->a[0]-b[0]);\\n        int elegible=0;\\n        for(int next : q) {\\n            if(resp.containsKey(next)) continue;\\n            // Add the new elegible intervals\\n            while(elegible<in.length&&in[elegible][0]<=next) pq.add(in[elegible++]);\\n            // Remove intervals that are not in range\\n            while(!pq.isEmpty()&&pq.peek()[1]<next) pq.remove();\\n            resp.put(next,pq.isEmpty()?-1:pq.peek()[1]-pq.peek()[0]+1);\\n        }\\n        int[] r = new int[q.length];\\n        for(int i=0;i<r.length;i++) r[i]=resp.get(queries[i]);\\n        return r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2833147,
                "title": "min-heap-python-solution-with-detailed-steps",
                "content": "```\\n\\'\\'\\'\\nStep 1) Sort queries and intervals.\\nStep 2) In the Min Heap, we use [interval size, interval end] = [r-l+1, r] as the key. The answer for each query is the head of the min heap.\\nStep 3) Iterate queries from smallest to largest.\\nStep 4) keep adding intervals while the left value <= q or until we ran out of intervals.\\nStep 5) keep popping all intervals that q can\\'t belong to. In other words, intervals that ended before the current query.\\nStep 6) Map each query to it\\'s answer from the top of the Min Heap.\\n\\nComplexity\\nTime O(nlogn + qlogq)\\nSpace O(n+q)\\nwhere q = len(queries)\\n\\'\\'\\'\\n\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        # Step 1)\\n        intervals.sort()\\n        i, ans = 0, {}\\n        \\n        # Step 2)\\n        minheap = []\\n        \\n        # Step 3)\\n        for q in sorted(queries): \\n            # Step 4)\\n            while i < len(intervals) and intervals[i][0] <= q:\\n                l = intervals[i][0]\\n                r = intervals[i][1]\\n                # keep the right value in the heap to use in case of ties\\n                heappush(minheap, ((r - l + 1), intervals[i][1]))\\n                i += 1\\n                \\n            # Step 5)\\n            while minheap and minheap[0][1] < q:\\n                heappop(minheap)\\n     \\n            # Step 6)\\n            ans[q] = minheap[0][0] if minheap else -1\\n            \\n        return [ans[q] for q in queries]\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\'\\'\\'\\nStep 1) Sort queries and intervals.\\nStep 2) In the Min Heap, we use [interval size, interval end] = [r-l+1, r] as the key. The answer for each query is the head of the min heap.\\nStep 3) Iterate queries from smallest to largest.\\nStep 4) keep adding intervals while the left value <= q or until we ran out of intervals.\\nStep 5) keep popping all intervals that q can\\'t belong to. In other words, intervals that ended before the current query.\\nStep 6) Map each query to it\\'s answer from the top of the Min Heap.\\n\\nComplexity\\nTime O(nlogn + qlogq)\\nSpace O(n+q)\\nwhere q = len(queries)\\n\\'\\'\\'\\n\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        # Step 1)\\n        intervals.sort()\\n        i, ans = 0, {}\\n        \\n        # Step 2)\\n        minheap = []\\n        \\n        # Step 3)\\n        for q in sorted(queries): \\n            # Step 4)\\n            while i < len(intervals) and intervals[i][0] <= q:\\n                l = intervals[i][0]\\n                r = intervals[i][1]\\n                # keep the right value in the heap to use in case of ties\\n                heappush(minheap, ((r - l + 1), intervals[i][1]))\\n                i += 1\\n                \\n            # Step 5)\\n            while minheap and minheap[0][1] < q:\\n                heappop(minheap)\\n     \\n            # Step 6)\\n            ans[q] = minheap[0][0] if minheap else -1\\n            \\n        return [ans[q] for q in queries]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2787459,
                "title": "python-simple-solution-keep-active-intervals-in-a-heap",
                "content": "```\\nfrom heapq import heappush, heappop\\n\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        intervals = sorted(intervals, reverse=True)\\n        queries = sorted((q, i) for i, q in enumerate(queries))\\n        \\n        heap = []\\n        res = [-1]*len(queries)\\n        for q, i in queries:\\n            while intervals and intervals[-1][0] <= q:\\n                begin, end = intervals.pop()\\n                heappush(heap, (end-begin+1, end))\\n                \\n            while heap and heap[0][1] < q:\\n                heappop(heap)\\n            \\n            if heap:\\n                res[i] = heap[0][0]\\n        \\n        return res\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nfrom heapq import heappush, heappop\\n\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        intervals = sorted(intervals, reverse=True)\\n        queries = sorted((q, i) for i, q in enumerate(queries))\\n        \\n        heap = []\\n        res = [-1]*len(queries)\\n        for q, i in queries:\\n            while intervals and intervals[-1][0] <= q:\\n                begin, end = intervals.pop()\\n                heappush(heap, (end-begin+1, end))\\n                \\n            while heap and heap[0][1] < q:\\n                heappop(heap)\\n            \\n            if heap:\\n                res[i] = heap[0][0]\\n        \\n        return res\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2733456,
                "title": "line-sweep-algo-with-offline-queries-and-hashmap-82-94-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n\\n    static bool cmp(pair<ll,ll>&p1,pair<ll,ll>&p2){\\n        if(p1.first==p2.first){\\n            return p1.second>p2.second;\\n        }\\n        return p1.first<p2.first;\\n    }\\n\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        ll n=intervals.size(),m=queries.size(),diff,i=0,j=0;\\n        vector<pair<ll,ll>>new_queries,points;\\n        vector<int>answer(m);\\n        for(ll i=0;i<m;i++){\\n            new_queries.push_back({queries[i],i});\\n        }\\n        for(ll i=0;i<n;i++){\\n            diff=intervals[i][1]-intervals[i][0]+1;\\n            points.push_back({intervals[i][0],diff});\\n            points.push_back({intervals[i][1],-diff});\\n        }\\n        sort(points.begin(),points.end(),cmp);\\n        sort(new_queries.begin(),new_queries.end());\\n        map<ll,ll>mp;\\n        while(j<m){\\n            while(points[i].first<=new_queries[j].first && i<points.size()){\\n                if(points[i].second<0 && points[i].first==new_queries[j].first){\\n                    break;\\n                }\\n                if(points[i].second>0){\\n                    mp[points[i].second]++;\\n                }\\n                else{\\n                    mp[-points[i].second]--;\\n                    if(mp[-points[i].second]==0){\\n                        mp.erase(-points[i].second);\\n                    }\\n                }\\n                i++;\\n            }\\n            if(mp.size()==0){\\n                answer[new_queries[j].second]=-1;\\n            }\\n            else{\\n                auto temp=mp.lower_bound(0);\\n                answer[new_queries[j].second]=temp->first;\\n            }\\n            j++;\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n\\n    static bool cmp(pair<ll,ll>&p1,pair<ll,ll>&p2){\\n        if(p1.first==p2.first){\\n            return p1.second>p2.second;\\n        }\\n        return p1.first<p2.first;\\n    }\\n\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        ll n=intervals.size(),m=queries.size(),diff,i=0,j=0;\\n        vector<pair<ll,ll>>new_queries,points;\\n        vector<int>answer(m);\\n        for(ll i=0;i<m;i++){\\n            new_queries.push_back({queries[i],i});\\n        }\\n        for(ll i=0;i<n;i++){\\n            diff=intervals[i][1]-intervals[i][0]+1;\\n            points.push_back({intervals[i][0],diff});\\n            points.push_back({intervals[i][1],-diff});\\n        }\\n        sort(points.begin(),points.end(),cmp);\\n        sort(new_queries.begin(),new_queries.end());\\n        map<ll,ll>mp;\\n        while(j<m){\\n            while(points[i].first<=new_queries[j].first && i<points.size()){\\n                if(points[i].second<0 && points[i].first==new_queries[j].first){\\n                    break;\\n                }\\n                if(points[i].second>0){\\n                    mp[points[i].second]++;\\n                }\\n                else{\\n                    mp[-points[i].second]--;\\n                    if(mp[-points[i].second]==0){\\n                        mp.erase(-points[i].second);\\n                    }\\n                }\\n                i++;\\n            }\\n            if(mp.size()==0){\\n                answer[new_queries[j].second]=-1;\\n            }\\n            else{\\n                auto temp=mp.lower_bound(0);\\n                answer[new_queries[j].second]=temp->first;\\n            }\\n            j++;\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2730215,
                "title": "beautiful-java-soln-neetcode",
                "content": "```\\nclass Solution {\\n    \\n    public int[] minInterval(int[][] intervals, int[] queries) {\\n        int ql = queries.length;\\n        int len = intervals.length;\\n        int[] tmp = new int[ql];\\n        for(int i=0;i<ql;i++){\\n            tmp[i]=queries[i];\\n        }\\n        Map<Integer,Integer> qmap = new HashMap<>();\\n       \\n        Arrays.sort(queries);\\n        Arrays.sort(intervals, (int[] a, int[] b)->{\\n            if(a[0]==b[0]){\\n                return a[1]-b[1];\\n            }\\n            return a[0]-b[0]; \\n        });\\n        \\n        Queue<int[]> pq = new PriorityQueue<>((int[] a,int[] b)->{\\n            if(a[0]==b[0]){\\n                return a[1]-b[1];\\n            }\\n            return a[0]-b[0];\\n        });\\n        int i=0,j=0;\\n        while(j<ql){    \\n            while(i<len && intervals[i][0]<=queries[j]){\\n                int l=intervals[i][0];\\n                int r=intervals[i][1];\\n                int diff = r-l+1;\\n                int[] arr={diff,r};\\n                pq.add(arr);\\n                i++;\\n            }\\n            while(!pq.isEmpty() && pq.peek()[1]<queries[j]){\\n                pq.poll();\\n            }\\n            if(!pq.isEmpty()){\\n                qmap.put(queries[j],pq.peek()[0]);\\n                //res[j]=;\\n            }\\n            else{\\n                qmap.put(queries[j],-1);\\n            }\\n            j++;\\n        }\\n        int[] ans = new int[ql];\\n        for(int k=0;k<ql;k++){\\n            ans[k]=qmap.get(tmp[k]);\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int[] minInterval(int[][] intervals, int[] queries) {\\n        int ql = queries.length;\\n        int len = intervals.length;\\n        int[] tmp = new int[ql];\\n        for(int i=0;i<ql;i++){\\n            tmp[i]=queries[i];\\n        }\\n        Map<Integer,Integer> qmap = new HashMap<>();\\n       \\n        Arrays.sort(queries);\\n        Arrays.sort(intervals, (int[] a, int[] b)->{\\n            if(a[0]==b[0]){\\n                return a[1]-b[1];\\n            }\\n            return a[0]-b[0]; \\n        });\\n        \\n        Queue<int[]> pq = new PriorityQueue<>((int[] a,int[] b)->{\\n            if(a[0]==b[0]){\\n                return a[1]-b[1];\\n            }\\n            return a[0]-b[0];\\n        });\\n        int i=0,j=0;\\n        while(j<ql){    \\n            while(i<len && intervals[i][0]<=queries[j]){\\n                int l=intervals[i][0];\\n                int r=intervals[i][1];\\n                int diff = r-l+1;\\n                int[] arr={diff,r};\\n                pq.add(arr);\\n                i++;\\n            }\\n            while(!pq.isEmpty() && pq.peek()[1]<queries[j]){\\n                pq.poll();\\n            }\\n            if(!pq.isEmpty()){\\n                qmap.put(queries[j],pq.peek()[0]);\\n                //res[j]=;\\n            }\\n            else{\\n                qmap.put(queries[j],-1);\\n            }\\n            j++;\\n        }\\n        int[] ans = new int[ql];\\n        for(int k=0;k<ql;k++){\\n            ans[k]=qmap.get(tmp[k]);\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2722769,
                "title": "c-min-heap",
                "content": "typedef pair<int,int> pii;\\nclass Solution {\\npublic:\\n\\n    vector<int> minInterval(vector<vector<int>>& in, vector<int>& q) {\\n        sort(in.begin(),in.end());\\n        vector<pii>v;\\n        for(int i=0;i<q.size();i++){\\n            v.push_back({ q[i],i });\\n        }\\n        \\n        sort(v.begin(),v.end());\\n        priority_queue< pii,vector<pii>,greater<pii> >pq;\\n        vector<int>ans((int)q.size());\\n        \\n        int k=0;\\n        for(int i=0;i<v.size();i++){\\n            while(k<in.size() && in[k][0]<=v[i].first){\\n                pq.push( {in[k][1]-in[k][0]+1 ,in[k][1]  }  );\\n                k++;\\n            }\\n            while( pq.size()>0 && pq.top().second<v[i].first ){\\n                pq.pop();\\n            }\\n            if(pq.empty()){\\n                ans[v[i].second] = -1;\\n            }\\n            else{\\n                ans[v[i].second] = pq.top().first;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<int> minInterval(vector<vector<int>>& in, vector<int>& q) {\\n        sort(in.begin(),in.end());\\n        vector<pii>v;\\n        for(int i=0;i<q.size();i++){\\n            v.push_back({ q[i],i }",
                "codeTag": "Java"
            },
            {
                "id": 2677803,
                "title": "c-explained-approach-priority-queue-interval-length-sorting",
                "content": "# Commented Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        // sorting queries in ascending order allows us to discard intervals smaller than pervious queries\\n        vector<int> Q = queries; sort(Q.begin(), Q.end()); \\n        // sorting intervals in ascending order helps reduce number of elements to traverse for increasing query values\\n        vector<vector<int>> I = intervals; sort(I.begin(), I.end());\\n\\n        // store interval size(-ve, as a pq by default is a max heap : helps keep smallest interval on top)\\n        priority_queue<pair<int, int>> pq; \\n        // As a sorted order of queries might cause a change in order, we temporarily store a <query, result> map\\n        unordered_map<int, int> store; \\n\\n        // i is an interator on the sorted intervals array\\n        int i = 0, n = I.size();\\n        for(auto q : Q){\\n            // Add all intervals which might possible include the query (starting element less than or equal to query)\\n            while(i < n && I[i][0] <= q)\\n                pq.push({-(I[i][1]-I[i][0]+1), I[i++][1]});\\n            // discard added/previously added intervals which are smaller than current query\\n            while(pq.size() && pq.top().second < q)\\n                pq.pop();\\n            // In case the pq is not empty, the top element represents interval with the smallest length \\n            // containing current query\\n            store[q] = (pq.size()) ? -pq.top().first : -1;\\n        }\\n\\n        // return result by storing query results in original order:\\n        vector<int> res;\\n        for(auto q : queries) res.push_back(store[q]);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        // sorting queries in ascending order allows us to discard intervals smaller than pervious queries\\n        vector<int> Q = queries; sort(Q.begin(), Q.end()); \\n        // sorting intervals in ascending order helps reduce number of elements to traverse for increasing query values\\n        vector<vector<int>> I = intervals; sort(I.begin(), I.end());\\n\\n        // store interval size(-ve, as a pq by default is a max heap : helps keep smallest interval on top)\\n        priority_queue<pair<int, int>> pq; \\n        // As a sorted order of queries might cause a change in order, we temporarily store a <query, result> map\\n        unordered_map<int, int> store; \\n\\n        // i is an interator on the sorted intervals array\\n        int i = 0, n = I.size();\\n        for(auto q : Q){\\n            // Add all intervals which might possible include the query (starting element less than or equal to query)\\n            while(i < n && I[i][0] <= q)\\n                pq.push({-(I[i][1]-I[i][0]+1), I[i++][1]});\\n            // discard added/previously added intervals which are smaller than current query\\n            while(pq.size() && pq.top().second < q)\\n                pq.pop();\\n            // In case the pq is not empty, the top element represents interval with the smallest length \\n            // containing current query\\n            store[q] = (pq.size()) ? -pq.top().first : -1;\\n        }\\n\\n        // return result by storing query results in original order:\\n        vector<int> res;\\n        for(auto q : queries) res.push_back(store[q]);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658382,
                "title": "javascript-min-priority-queue-pointer",
                "content": "```\\n/**\\n * @param {number[][]} intervals\\n * @param {number[]} queries\\n * @return {number[]}\\n */\\nvar minInterval = function(intervals, queries) {\\n    // new queries has sortedqueries with its orginal location[ [int, original index]...]\\n    var newQueries = queries.map((q, index) => [q, index]);\\n    newQueries.sort((a, b) => a[0] - b[0]);\\n    intervals.sort((a, b) => a[0] === b[0] ? a[1] - b[1] : a[0] - b[0]);\\n    var res = [];\\n    var i = 0; // pointer\\n    var minPQ = new MinPriorityQueue();\\n    \\n    for (var [q, index] of newQueries) {\\n        // add possible intervals (start <= q) to min priority queue\\n        while (i < intervals.length && intervals[i][0] <= q) {\\n            var [s, e] = intervals[i];\\n            var size = e - s + 1;\\n            minPQ.enqueue([size, e], size);\\n            i++;\\n        }\\n        \\n        // remove elements before q\\n\\t\\t// since the queries are sorted, the dequeued items are no longer needed\\n\\t\\t// because their ending is smaller than all upcoming queries\\n        while (minPQ.size() && minPQ.front().element[1] < q) {\\n            minPQ.dequeue();\\n        }\\n\\t\\t// if min priority queue is not empty, peak[0] will be the size\\n        var minSize = !minPQ.isEmpty() ? minPQ.front().element[0] : -1;\\n        // new queries is sorted, so need to push size to the original index of the query\\n        res[index] = minSize;\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/**\\n * @param {number[][]} intervals\\n * @param {number[]} queries\\n * @return {number[]}\\n */\\nvar minInterval = function(intervals, queries) {\\n    // new queries has sortedqueries with its orginal location[ [int, original index]...]\\n    var newQueries = queries.map((q, index) => [q, index]);\\n    newQueries.sort((a, b) => a[0] - b[0]);\\n    intervals.sort((a, b) => a[0] === b[0] ? a[1] - b[1] : a[0] - b[0]);\\n    var res = [];\\n    var i = 0; // pointer\\n    var minPQ = new MinPriorityQueue();\\n    \\n    for (var [q, index] of newQueries) {\\n        // add possible intervals (start <= q) to min priority queue\\n        while (i < intervals.length && intervals[i][0] <= q) {\\n            var [s, e] = intervals[i];\\n            var size = e - s + 1;\\n            minPQ.enqueue([size, e], size);\\n            i++;\\n        }\\n        \\n        // remove elements before q\\n\\t\\t// since the queries are sorted, the dequeued items are no longer needed\\n\\t\\t// because their ending is smaller than all upcoming queries\\n        while (minPQ.size() && minPQ.front().element[1] < q) {\\n            minPQ.dequeue();\\n        }\\n\\t\\t// if min priority queue is not empty, peak[0] will be the size\\n        var minSize = !minPQ.isEmpty() ? minPQ.front().element[0] : -1;\\n        // new queries is sorted, so need to push size to the original index of the query\\n        res[index] = minSize;\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2651633,
                "title": "priorityque-binarysearch-solutions-explained-c",
                "content": "First Approach goes through queries first\\n```\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        sort(intervals.begin(), intervals.end());//sort by start time\\n        \\n        //think of query values as time values and imagine how you would sovle this problem if queries were sorted\\n        unordered_map<int, vector<int>> pos;//there might be repeated time values\\n        for(int j = 0; j < queries.size(); j++){\\n            pos[queries[j]].push_back(j);\\n        }\\n        sort(queries.begin(), queries.end());\\n        \\n        priority_queue<pair<int, int>> pq; //by default its a max-heap\\n        \\n        //for each time value, we would iterate through the remaining intervals\\n        //and if startTime of c_interval <= c_time, push that value on the heap\\n        //I would also check and make sure that the top value of heap is not ending before c_time\\n        //if it is, just remove it from the heap\\n        //heap is minHeap, the top value in the heap is the smallest size interal that overlaps c_time\\n        \\n        vector<vector<int>>::iterator c_interval = intervals.begin();\\n        vector<int> ans(queries.size(), -1);\\n        for (int i = 0; i < queries.size(); i++){\\n            int time = queries[i];\\n            while (c_interval!=intervals.end() && (*c_interval)[0] <= time){\\n                int start = (*c_interval)[0]; int end = (*c_interval)[1];\\n                pq.push(pair<int, int>(-(end - start + 1), end));\\n                c_interval++;\\n            }\\n            while (pq.size() && pq.top().second < time){\\n                pq.pop();\\n            }\\n            \\n            if (pq.size()){//same time values would have the same solution\\n                for(int idx: pos[time]){\\n                    ans[idx] = -(pq.top().first);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```\\n\\nSecond Approach goes through intervals first\\n```\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        //Approach2 sort intervals by size\\n        //think of queries as time values and sort them by time\\n        //go through each interval and do binarySearch on queries and look for first value, such that startTime <= value <= endTime\\n        \\n        sort(intervals.begin(), intervals.end(), [](auto& a, auto& b){return a[1]-a[0] < b[1]-b[0];});\\n        set<pair<int, int>> times;\\n        for (int i=0; i<queries.size(); i++){\\n            times.insert(pair<int, int>(queries[i], i));\\n        }\\n        \\n        vector<int> ans(queries.size(), -1);\\n        \\n        //iterating through smallest interval at a time\\n        for(auto interval: intervals){\\n            int start = interval[0]; int end = interval[1];\\n            \\n            //find first query >= start using binary search\\n            auto c_query = times.lower_bound({start, -1});\\n            \\n            //go through all the queries that fit in current interval\\n            //c_interval is the smallest size interval these queries can fit in\\n            //remember to remove the query from the set!!\\n            while (c_query != times.end() && c_query->first <= end){\\n                ans[c_query->second] = end - start + 1;\\n                times.erase(c_query++);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        sort(intervals.begin(), intervals.end());//sort by start time\\n        \\n        //think of query values as time values and imagine how you would sovle this problem if queries were sorted\\n        unordered_map<int, vector<int>> pos;//there might be repeated time values\\n        for(int j = 0; j < queries.size(); j++){\\n            pos[queries[j]].push_back(j);\\n        }\\n        sort(queries.begin(), queries.end());\\n        \\n        priority_queue<pair<int, int>> pq; //by default its a max-heap\\n        \\n        //for each time value, we would iterate through the remaining intervals\\n        //and if startTime of c_interval <= c_time, push that value on the heap\\n        //I would also check and make sure that the top value of heap is not ending before c_time\\n        //if it is, just remove it from the heap\\n        //heap is minHeap, the top value in the heap is the smallest size interal that overlaps c_time\\n        \\n        vector<vector<int>>::iterator c_interval = intervals.begin();\\n        vector<int> ans(queries.size(), -1);\\n        for (int i = 0; i < queries.size(); i++){\\n            int time = queries[i];\\n            while (c_interval!=intervals.end() && (*c_interval)[0] <= time){\\n                int start = (*c_interval)[0]; int end = (*c_interval)[1];\\n                pq.push(pair<int, int>(-(end - start + 1), end));\\n                c_interval++;\\n            }\\n            while (pq.size() && pq.top().second < time){\\n                pq.pop();\\n            }\\n            \\n            if (pq.size()){//same time values would have the same solution\\n                for(int idx: pos[time]){\\n                    ans[idx] = -(pq.top().first);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```\n```\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        //Approach2 sort intervals by size\\n        //think of queries as time values and sort them by time\\n        //go through each interval and do binarySearch on queries and look for first value, such that startTime <= value <= endTime\\n        \\n        sort(intervals.begin(), intervals.end(), [](auto& a, auto& b){return a[1]-a[0] < b[1]-b[0];});\\n        set<pair<int, int>> times;\\n        for (int i=0; i<queries.size(); i++){\\n            times.insert(pair<int, int>(queries[i], i));\\n        }\\n        \\n        vector<int> ans(queries.size(), -1);\\n        \\n        //iterating through smallest interval at a time\\n        for(auto interval: intervals){\\n            int start = interval[0]; int end = interval[1];\\n            \\n            //find first query >= start using binary search\\n            auto c_query = times.lower_bound({start, -1});\\n            \\n            //go through all the queries that fit in current interval\\n            //c_interval is the smallest size interval these queries can fit in\\n            //remember to remove the query from the set!!\\n            while (c_query != times.end() && c_query->first <= end){\\n                ans[c_query->second] = end - start + 1;\\n                times.erase(c_query++);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2641770,
                "title": "sorting-set",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& in, vector<int>& q) {\\n        set<pair<int,int>> st;\\n        for(int i=0;i<q.size();i++)st.insert({q[i],i});\\n        sort(in.begin(),in.end(),[](vector<int> &a,vector<int> &b){\\n            return a[1]-a[0]<b[1]-b[0];\\n        });\\n        int n=in.size();\\n        int m=q.size();\\n        vector<int> ans(m,-1);\\n        for(int i=0;i<n;i++){\\n            vector<pair<int,int>> v;\\n            auto it=st.lower_bound({in[i][0],0});\\n            while(it!=st.end() and (*it).first>=in[i][0] and (*it).first<=in[i][1]){\\n                ans[(*it).second]=in[i][1]-in[i][0]+1;\\n                v.push_back(*it);\\n                it++;\\n            }\\n            for(int i=0;i<v.size();i++){\\n                st.erase(v[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& in, vector<int>& q) {\\n        set<pair<int,int>> st;\\n        for(int i=0;i<q.size();i++)st.insert({q[i],i});\\n        sort(in.begin(),in.end(),[](vector<int> &a,vector<int> &b){\\n            return a[1]-a[0]<b[1]-b[0];\\n        });\\n        int n=in.size();\\n        int m=q.size();\\n        vector<int> ans(m,-1);\\n        for(int i=0;i<n;i++){\\n            vector<pair<int,int>> v;\\n            auto it=st.lower_bound({in[i][0],0});\\n            while(it!=st.end() and (*it).first>=in[i][0] and (*it).first<=in[i][1]){\\n                ans[(*it).second]=in[i][1]-in[i][0]+1;\\n                v.push_back(*it);\\n                it++;\\n            }\\n            for(int i=0;i<v.size();i++){\\n                st.erase(v[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2633855,
                "title": "python-enumerate-in-ascending-order-and-keep-a-heap-with-smallest-interval-sizes",
                "content": "```\\n# Idea: Enumerate starts, ends and queries in ascending order and keep a heap with the smallest interval along the way.\\nfrom heapq import heappush, heappop, heapify\\n\\nclass Solution:\\n  def minInterval(self, ints: List[List[int]], queries: List[int]) -> List[int]:\\n    starts = [(e[0], i) for i, e in enumerate(ints) ]\\n    ends = [(e[1], i) for i, e in enumerate(ints) ]\\n    squeries = [(e, i) for i, e in enumerate(queries)]\\n    starts.sort()\\n    ends.sort()\\n    squeries.sort()\\n    starts_i = 0\\n    ends_i = 0\\n    squeries_i = 0 \\n    removed = set()\\n    smallest = [] \\n    ans = [None] * len(queries)\\n    def getn(arr, i):\\n      if i < len(arr):\\n        return arr[i]\\n      return float(\\'inf\\'), -1\\n    # Main loop\\n    while squeries_i < len(squeries):\\n      q, qinx = getn(squeries, squeries_i) \\n      s, s_int_i = getn(starts, starts_i)  \\n      e, e_int_i = getn(ends, ends_i) \\n      if q < s and q <= e:\\n        while smallest and smallest[0][1] in removed:\\n          heappop(smallest)\\n        ans[qinx] = smallest[0][0] if smallest else -1\\n        squeries_i += 1\\n      elif s <= e:\\n        int_start, int_end = ints[s_int_i] \\n        heappush(smallest, (int_end - int_start + 1, s_int_i))  \\n        starts_i += 1\\n      else:\\n        removed.add(e_int_i)\\n        while smallest and smallest[0][1] in removed:\\n          heappop(smallest)\\n        ends_i += 1\\n    return ans\\n        \\n\\n```",
                "solutionTags": [],
                "code": "```\\n# Idea: Enumerate starts, ends and queries in ascending order and keep a heap with the smallest interval along the way.\\nfrom heapq import heappush, heappop, heapify\\n\\nclass Solution:\\n  def minInterval(self, ints: List[List[int]], queries: List[int]) -> List[int]:\\n    starts = [(e[0], i) for i, e in enumerate(ints) ]\\n    ends = [(e[1], i) for i, e in enumerate(ints) ]\\n    squeries = [(e, i) for i, e in enumerate(queries)]\\n    starts.sort()\\n    ends.sort()\\n    squeries.sort()\\n    starts_i = 0\\n    ends_i = 0\\n    squeries_i = 0 \\n    removed = set()\\n    smallest = [] \\n    ans = [None] * len(queries)\\n    def getn(arr, i):\\n      if i < len(arr):\\n        return arr[i]\\n      return float(\\'inf\\'), -1\\n    # Main loop\\n    while squeries_i < len(squeries):\\n      q, qinx = getn(squeries, squeries_i) \\n      s, s_int_i = getn(starts, starts_i)  \\n      e, e_int_i = getn(ends, ends_i) \\n      if q < s and q <= e:\\n        while smallest and smallest[0][1] in removed:\\n          heappop(smallest)\\n        ans[qinx] = smallest[0][0] if smallest else -1\\n        squeries_i += 1\\n      elif s <= e:\\n        int_start, int_end = ints[s_int_i] \\n        heappush(smallest, (int_end - int_start + 1, s_int_i))  \\n        starts_i += 1\\n      else:\\n        removed.add(e_int_i)\\n        while smallest and smallest[0][1] in removed:\\n          heappop(smallest)\\n        ends_i += 1\\n    return ans\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630675,
                "title": "python-sorting-and-priority-queue-min-heap-solution-o-nlogn-qlogq-time-o-n-space",
                "content": "```\\n# * Sorting and Priority Queue (Min Heap) Solution | O(nlogn+qlogq) Time | O(n) Space\\n# * n -> The length of intervals array | q -> The length of queries array\\n\\n\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        # * Sort the intervals in ascending order based on the left value.\\n        intervals.sort(key=lambda interval: interval[0])\\n        res = {}\\n        # * Stores a pair of the size and right value of the interval.\\n        # * Pair -> (size, right_val)\\n        min_heap = []\\n        i = 0\\n\\n        # * Sort the queries in ascending order.\\n        for query in sorted(queries):\\n            # * Push the intervals into the min heap that the current query belongs to.\\n            while i < len(intervals) and intervals[i][0] <= query:\\n                left, right = intervals[i]\\n                heapq.heappush(min_heap, (right - left + 1, right))\\n                i += 1\\n\\n            # * Pop the intervals from the min heap that are OOB of the current query.\\n            while min_heap and min_heap[0][1] < query:\\n                heapq.heappop(min_heap)\\n\\n            # * Add the smallest interval from the min heap to the current query.\\n            res[query] = min_heap[0][0] if min_heap else -1\\n\\n        return [res[query] for query in queries]\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\n# * Sorting and Priority Queue (Min Heap) Solution | O(nlogn+qlogq) Time | O(n) Space\\n# * n -> The length of intervals array | q -> The length of queries array\\n\\n\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        # * Sort the intervals in ascending order based on the left value.\\n        intervals.sort(key=lambda interval: interval[0])\\n        res = {}\\n        # * Stores a pair of the size and right value of the interval.\\n        # * Pair -> (size, right_val)\\n        min_heap = []\\n        i = 0\\n\\n        # * Sort the queries in ascending order.\\n        for query in sorted(queries):\\n            # * Push the intervals into the min heap that the current query belongs to.\\n            while i < len(intervals) and intervals[i][0] <= query:\\n                left, right = intervals[i]\\n                heapq.heappush(min_heap, (right - left + 1, right))\\n                i += 1\\n\\n            # * Pop the intervals from the min heap that are OOB of the current query.\\n            while min_heap and min_heap[0][1] < query:\\n                heapq.heappop(min_heap)\\n\\n            # * Add the smallest interval from the min heap to the current query.\\n            res[query] = min_heap[0][0] if min_heap else -1\\n\\n        return [res[query] for query in queries]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2611401,
                "title": "typescript-priorityqueue-sorting",
                "content": "```\\nfunction minInterval(intervals: number[][], queries: number[]): number[] {\\n\\t// sort intervals according to start\\n    intervals.sort((a, b) => a[0] - b[0]);\\n\\t// create sorted queries\\n    let queriesSorted = [...queries].sort((a,b) => a - b);\\n\\t// cache to map query to result  \\n    const cache:Map<number, number> = new Map();\\n\\t\\n\\t// min priority queue to map distance to interval end where interval distance is use to evaluate priority;\\n    const priorityQueue = new MinPriorityQueue();\\n    let i = 0;\\n    for(const q of queriesSorted){\\n        if(cache.has(q)){\\n            continue;\\n        }\\n        while(i < intervals.length && intervals[i][0] <= q){\\n            const [start, end] = intervals[i];\\n  \\n            priorityQueue.enqueue(end, (end+1) -  start);\\n            i++\\n        }\\n        // remove invalid intervals min, i.e. intervals with end less than the query;\\n        while(priorityQueue.size() > 0 && priorityQueue.front().element < q){\\n            priorityQueue.dequeue()\\n        }\\n\\t\\t// set query value to  minimum distance in  queue\\n        cache.set(q, priorityQueue.front()?.priority ?? -1);\\n    }\\n    \\n    \\n    return queries.map(v => cache.get(v));\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfunction minInterval(intervals: number[][], queries: number[]): number[] {\\n\\t// sort intervals according to start\\n    intervals.sort((a, b) => a[0] - b[0]);\\n\\t// create sorted queries\\n    let queriesSorted = [...queries].sort((a,b) => a - b);\\n\\t// cache to map query to result  \\n    const cache:Map<number, number> = new Map();\\n\\t\\n\\t// min priority queue to map distance to interval end where interval distance is use to evaluate priority;\\n    const priorityQueue = new MinPriorityQueue();\\n    let i = 0;\\n    for(const q of queriesSorted){\\n        if(cache.has(q)){\\n            continue;\\n        }\\n        while(i < intervals.length && intervals[i][0] <= q){\\n            const [start, end] = intervals[i];\\n  \\n            priorityQueue.enqueue(end, (end+1) -  start);\\n            i++\\n        }\\n        // remove invalid intervals min, i.e. intervals with end less than the query;\\n        while(priorityQueue.size() > 0 && priorityQueue.front().element < q){\\n            priorityQueue.dequeue()\\n        }\\n\\t\\t// set query value to  minimum distance in  queue\\n        cache.set(q, priorityQueue.front()?.priority ?? -1);\\n    }\\n    \\n    \\n    return queries.map(v => cache.get(v));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2571495,
                "title": "very-short-code-in-python3-with-sortedlist-beating-77",
                "content": "The idea is to find each interval can cover which queries (points). By the order of the interval lengths, every query will be covered by the smallest intervals. For efficiency, all queris are stored in a BST (with SortedList in Python). A query will be removed from the BST once it is covered by an interval. \\n\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        points = SortedList((v, i) for i, v in enumerate(queries))\\n        intervals.sort(key=lambda x: x[1] - x[0])\\n        results = [-1] * len(queries)\\n        for l, r in intervals:\\n            for (v, i) in list(points.irange((l, -inf), (r, inf))):\\n                results[i] = r - l + 1\\n                points.remove((v, i))\\n        return results",
                "solutionTags": [
                    "Python3"
                ],
                "code": "The idea is to find each interval can cover which queries (points). By the order of the interval lengths, every query will be covered by the smallest intervals. For efficiency, all queris are stored in a BST (with SortedList in Python). A query will be removed from the BST once it is covered by an interval. \\n\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        points = SortedList((v, i) for i, v in enumerate(queries))\\n        intervals.sort(key=lambda x: x[1] - x[0])\\n        results = [-1] * len(queries)\\n        for l, r in intervals:\\n            for (v, i) in list(points.irange((l, -inf), (r, inf))):\\n                results[i] = r - l + 1\\n                points.remove((v, i))\\n        return results",
                "codeTag": "Java"
            },
            {
                "id": 2518241,
                "title": "clean-python-solution-self-explained-easy-to-understand",
                "content": "```python\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        ans = [-1]*len(queries)\\n        queries = sorted([(query, i) for i, query in enumerate(queries)])\\n        intervals.sort()\\n        h = []\\n        \\n        itervalIndex = 0\\n        for query, queryIndex in queries:\\n            #push all intervals that include \\'query\\' to the min heap\\n            while itervalIndex<len(intervals) and intervals[itervalIndex][0]<=query:\\n                left = intervals[itervalIndex][0]\\n                right = intervals[itervalIndex][1]\\n                size = right-left+1\\n                heapq.heappush(h, (size, right))\\n                itervalIndex += 1\\n            \\n            #pop all intervals that not includes \\'query\\' out of the min heap\\n            while h and h[0][1]<query:\\n                heapq.heappop(h)\\n                \\n            if h: ans[queryIndex] = h[0][0]\\n        return ans\\n\\t\\t\\n\"\"\"\\nFor interview preparation, similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n        ans = [-1]*len(queries)\\n        queries = sorted([(query, i) for i, query in enumerate(queries)])\\n        intervals.sort()\\n        h = []\\n        \\n        itervalIndex = 0\\n        for query, queryIndex in queries:\\n            #push all intervals that include \\'query\\' to the min heap\\n            while itervalIndex<len(intervals) and intervals[itervalIndex][0]<=query:\\n                left = intervals[itervalIndex][0]\\n                right = intervals[itervalIndex][1]\\n                size = right-left+1\\n                heapq.heappush(h, (size, right))\\n                itervalIndex += 1\\n            \\n            #pop all intervals that not includes \\'query\\' out of the min heap\\n            while h and h[0][1]<query:\\n                heapq.heappop(h)\\n                \\n            if h: ans[queryIndex] = h[0][0]\\n        return ans\\n\\t\\t\\n\"\"\"\\nFor interview preparation, similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2517656,
                "title": "js-simple",
                "content": "```\\n\\nclass MinHeap {\\n    constructor() {\\n        this.values = [];\\n    }\\n\\n    extractMinimum() {\\n        const minimum = this.values[0]\\n        const lastElem = this.values.pop();\\n\\n        if (this.values.length) {\\n            this.values[0] = lastElem;\\n            this.sinkDown();\\n        }\\n\\n        return minimum;\\n    }\\n\\n    swap(index1, index2) {\\n        [this.values[index1], this.values[index2]] = [this.values[index2], this.values[index1]];\\n    }\\n\\n    insert(value) {\\n        this.values.push(value);\\n        this.bubbleUp();\\n    }\\n\\n    bubbleUp() {\\n        let index = this.values.length - 1;\\n\\n        while (index > 0) {\\n            let parentIndex = Math.floor((index - 1) / 2);\\n\\n            if ((this.values[parentIndex][0] < this.values[index][0])\\n            || (this.values[parentIndex][0] === this.values[index][0] && \\n                this.values[parentIndex][1][1] <= this.values[index][1][1]))\\n             {\\n                break;\\n            }\\n\\n            this.swap(index, parentIndex);\\n            index = parentIndex;\\n        }\\n    }\\n\\n    sinkDown() {\\n        let index = 0;\\n\\n        while (true) {  \\n            let swapIndex = index;\\n            let leftCI = 2 * index + 1;\\n            let rightCI =  2 * index + 2;\\n\\n            if (leftCI < this.values.length && ((this.values[leftCI][0] < this.values[swapIndex][0])\\n             || (this.values[leftCI][0] === this.values[swapIndex][0] && this.values[leftCI][1][1] < this.values[swapIndex][1][1]))) {\\n                swapIndex = leftCI;\\n            }\\n\\n             if (rightCI < this.values.length && ((this.values[rightCI][0] < this.values[swapIndex][0])\\n             || (this.values[rightCI][0] === this.values[swapIndex][0] && this.values[rightCI][1][1] < this.values[swapIndex][1][1]))) {\\n                swapIndex = rightCI;\\n            }   \\n\\n            if (swapIndex === index) {\\n                break;\\n            }\\n\\n            this.swap(index, swapIndex);\\n            index = swapIndex;\\n        }\\n    }\\n}\\n\\nvar minInterval = function(intervals, queries) {\\n    const ans = [];\\n    intervals.sort((int1, int2) => int1[0] - int2[0]);\\n\\n    const minHeap = new MinHeap();\\n    const indexedQuery = [];\\n\\n    for (let i = 0 ; i < queries.length; i++) {\\n        indexedQuery.push([i, queries[i]]);\\n    }\\n\\n    indexedQuery.sort((q1, q2) => q1[1] - q2[1]);\\n\\n    let j = 0;\\n\\n    for (let i = 0; i < indexedQuery.length; i++) {\\n        const [index, query] = indexedQuery[i];\\n\\n        while (j < intervals.length && intervals[j][0] <= query) {\\n            minHeap.insert([intervals[j][1] - intervals[j][0] + 1, intervals[j]]);\\n            j++;\\n        }\\n\\n        // remove all invalid intervals from heap \\n        while (minHeap.values.length && minHeap.values[0][1][1] < query) {\\n            minHeap.extractMinimum();\\n        }\\n\\n        let result = -1;\\n\\n        if (minHeap.values.length) {\\n            result = minHeap.values[0][0];\\n        }\\n\\n        ans[index] = result;\\n    }\\n\\n    return ans;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass MinHeap {\\n    constructor() {\\n        this.values = [];\\n    }\\n\\n    extractMinimum() {\\n        const minimum = this.values[0]\\n        const lastElem = this.values.pop();\\n\\n        if (this.values.length) {\\n            this.values[0] = lastElem;\\n            this.sinkDown();\\n        }\\n\\n        return minimum;\\n    }\\n\\n    swap(index1, index2) {\\n        [this.values[index1], this.values[index2]] = [this.values[index2], this.values[index1]];\\n    }\\n\\n    insert(value) {\\n        this.values.push(value);\\n        this.bubbleUp();\\n    }\\n\\n    bubbleUp() {\\n        let index = this.values.length - 1;\\n\\n        while (index > 0) {\\n            let parentIndex = Math.floor((index - 1) / 2);\\n\\n            if ((this.values[parentIndex][0] < this.values[index][0])\\n            || (this.values[parentIndex][0] === this.values[index][0] && \\n                this.values[parentIndex][1][1] <= this.values[index][1][1]))\\n             {\\n                break;\\n            }\\n\\n            this.swap(index, parentIndex);\\n            index = parentIndex;\\n        }\\n    }\\n\\n    sinkDown() {\\n        let index = 0;\\n\\n        while (true) {  \\n            let swapIndex = index;\\n            let leftCI = 2 * index + 1;\\n            let rightCI =  2 * index + 2;\\n\\n            if (leftCI < this.values.length && ((this.values[leftCI][0] < this.values[swapIndex][0])\\n             || (this.values[leftCI][0] === this.values[swapIndex][0] && this.values[leftCI][1][1] < this.values[swapIndex][1][1]))) {\\n                swapIndex = leftCI;\\n            }\\n\\n             if (rightCI < this.values.length && ((this.values[rightCI][0] < this.values[swapIndex][0])\\n             || (this.values[rightCI][0] === this.values[swapIndex][0] && this.values[rightCI][1][1] < this.values[swapIndex][1][1]))) {\\n                swapIndex = rightCI;\\n            }   \\n\\n            if (swapIndex === index) {\\n                break;\\n            }\\n\\n            this.swap(index, swapIndex);\\n            index = swapIndex;\\n        }\\n    }\\n}\\n\\nvar minInterval = function(intervals, queries) {\\n    const ans = [];\\n    intervals.sort((int1, int2) => int1[0] - int2[0]);\\n\\n    const minHeap = new MinHeap();\\n    const indexedQuery = [];\\n\\n    for (let i = 0 ; i < queries.length; i++) {\\n        indexedQuery.push([i, queries[i]]);\\n    }\\n\\n    indexedQuery.sort((q1, q2) => q1[1] - q2[1]);\\n\\n    let j = 0;\\n\\n    for (let i = 0; i < indexedQuery.length; i++) {\\n        const [index, query] = indexedQuery[i];\\n\\n        while (j < intervals.length && intervals[j][0] <= query) {\\n            minHeap.insert([intervals[j][1] - intervals[j][0] + 1, intervals[j]]);\\n            j++;\\n        }\\n\\n        // remove all invalid intervals from heap \\n        while (minHeap.values.length && minHeap.values[0][1][1] < query) {\\n            minHeap.extractMinimum();\\n        }\\n\\n        let result = -1;\\n\\n        if (minHeap.values.length) {\\n            result = minHeap.values[0][0];\\n        }\\n\\n        ans[index] = result;\\n    }\\n\\n    return ans;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2510473,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& in, vector<int>& q) {\\n        \\n        map<int,vector<int>> sad;\\n       \\n        for(int i=0;i<q.size();i++)\\n        {\\n            sad[q[i]].push_back(i);\\n          \\n        }\\n        vector<int> ans(q.size(),-1);\\n        sort(in.begin(),in.end());\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>mad;\\n        int j=0;\\n        for(auto it:sad)\\n        {\\n            while(j<in.size() && in[j][0]<=it.first)\\n            {\\n                mad.push({in[j][1]-in[j][0]+1,in[j][1]});\\n                j++;\\n            }\\n            \\n            while(!mad.empty() && mad.top().second<it.first)\\n            {\\n                mad.pop();\\n            }\\n            int res=-1;\\n            if(!mad.empty())\\n                res=mad.top().first;\\n            for(auto it2:it.second)\\n            {\\n                ans[it2]=res;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& in, vector<int>& q) {\\n        \\n        map<int,vector<int>> sad;\\n       \\n        for(int i=0;i<q.size();i++)\\n        {\\n            sad[q[i]].push_back(i);\\n          \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2505290,
                "title": "heap-kotlin-readable",
                "content": "```kotlin\\nclass Solution {\\n\\n    data class Interval(val from: Int, val to: Int)\\n\\n    fun minInterval(intervals: Array<IntArray>, queries: IntArray): IntArray {\\n\\n        val queriesWithIndex = Array<Pair<Int, Int>>(queries.size) { queries[it] to it }\\n        queriesWithIndex.sortBy { it.first }\\n\\n        val intervalsByFrom = Array<Interval>(intervals.size) { Interval(intervals[it][0], intervals[it][1]) }\\n        intervalsByFrom.sortBy { it.from }\\n\\n        // by size\\n        val intervalMinHeap = PriorityQueue<Interval> { f, s -> (f.to - f.from) - (s.to - s.from) }\\n\\n        val result = IntArray(queries.size)\\n\\n        var j = 0\\n        for ((queryVal, queryIndex) in queriesWithIndex) {\\n\\n            while (j < intervalsByFrom.size && intervalsByFrom[j].from <= queryVal) {\\n                intervalMinHeap.add(intervalsByFrom[j])\\n                j++\\n            }\\n\\n            while (!intervalMinHeap.isEmpty() && intervalMinHeap.first().to < queryVal) {\\n                intervalMinHeap.remove();\\n            }\\n            result[queryIndex] =\\n                if (intervalMinHeap.isEmpty())\\n                    -1\\n                else\\n                    (intervalMinHeap.first().to - intervalMinHeap.first().from + 1)\\n\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Heap (Priority Queue)"
                ],
                "code": "```kotlin\\nclass Solution {\\n\\n    data class Interval(val from: Int, val to: Int)\\n\\n    fun minInterval(intervals: Array<IntArray>, queries: IntArray): IntArray {\\n\\n        val queriesWithIndex = Array<Pair<Int, Int>>(queries.size) { queries[it] to it }\\n        queriesWithIndex.sortBy { it.first }\\n\\n        val intervalsByFrom = Array<Interval>(intervals.size) { Interval(intervals[it][0], intervals[it][1]) }\\n        intervalsByFrom.sortBy { it.from }\\n\\n        // by size\\n        val intervalMinHeap = PriorityQueue<Interval> { f, s -> (f.to - f.from) - (s.to - s.from) }\\n\\n        val result = IntArray(queries.size)\\n\\n        var j = 0\\n        for ((queryVal, queryIndex) in queriesWithIndex) {\\n\\n            while (j < intervalsByFrom.size && intervalsByFrom[j].from <= queryVal) {\\n                intervalMinHeap.add(intervalsByFrom[j])\\n                j++\\n            }\\n\\n            while (!intervalMinHeap.isEmpty() && intervalMinHeap.first().to < queryVal) {\\n                intervalMinHeap.remove();\\n            }\\n            result[queryIndex] =\\n                if (intervalMinHeap.isEmpty())\\n                    -1\\n                else\\n                    (intervalMinHeap.first().to - intervalMinHeap.first().from + 1)\\n\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2491197,
                "title": "c-intuitions-explained-min-heap-clean-code",
                "content": "```\\n#define pp pair< int , int>\\n\\nclass Solution {\\npublic:\\n    \\n    // Intuition -> we will sort the intervals & queries \\n    \\n    // then we will check that for how many interval exist for , a given query \\n    \\n    // we push the size of the interval , ending index of the interval into \\n    \\n    // the min heap \\n    \\n    // when a query value is greater than ending index of the interval , pop those \\n    \\n    // from min heap\\n    \\n    // Same do for all the query \\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& q) {\\n        \\n        map< int , set<int>> mp;\\n        \\n        for(int i=0;i<q.size();i++)\\n        {\\n            mp[q[i]].insert(i);\\n        }\\n        \\n        vector<int> res(q.size());\\n        \\n        priority_queue< pp , vector<pp> , greater<pp>> pq;\\n        \\n        sort(intervals.begin() , intervals.end());\\n        \\n        sort(q.begin() , q.end());\\n        \\n        int j=0;\\n        \\n        for(int i=0;i<q.size();i++)\\n        {\\n            \\n            while(j<intervals.size() && intervals[j][0]<=q[i] )\\n            {\\n                pq.push({intervals[j][1]-intervals[j][0]+1 , intervals[j][1]});\\n                j++;\\n            }\\n            \\n            while(!pq.empty() && pq.top().second<q[i])\\n            {\\n                pq.pop();\\n                // Pop those are do not contains q[i] now \\n            }\\n            \\n            int ans=-1;\\n            \\n            if(!pq.empty())\\n             ans=pq.top().first;\\n            \\n            int index=-1;\\n            \\n            if(mp[q[i]].size()!=0)\\n            {\\n                index=*mp[q[i]].begin();\\n                \\n                res[index]=ans;\\n                mp[q[i]].erase(mp[q[i]].begin());\\n            }\\n            \\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n#define pp pair< int , int>\\n\\nclass Solution {\\npublic:\\n    \\n    // Intuition -> we will sort the intervals & queries \\n    \\n    // then we will check that for how many interval exist for , a given query \\n    \\n    // we push the size of the interval , ending index of the interval into \\n    \\n    // the min heap \\n    \\n    // when a query value is greater than ending index of the interval , pop those \\n    \\n    // from min heap\\n    \\n    // Same do for all the query \\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& q) {\\n        \\n        map< int , set<int>> mp;\\n        \\n        for(int i=0;i<q.size();i++)\\n        {\\n            mp[q[i]].insert(i);\\n        }\\n        \\n        vector<int> res(q.size());\\n        \\n        priority_queue< pp , vector<pp> , greater<pp>> pq;\\n        \\n        sort(intervals.begin() , intervals.end());\\n        \\n        sort(q.begin() , q.end());\\n        \\n        int j=0;\\n        \\n        for(int i=0;i<q.size();i++)\\n        {\\n            \\n            while(j<intervals.size() && intervals[j][0]<=q[i] )\\n            {\\n                pq.push({intervals[j][1]-intervals[j][0]+1 , intervals[j][1]});\\n                j++;\\n            }\\n            \\n            while(!pq.empty() && pq.top().second<q[i])\\n            {\\n                pq.pop();\\n                // Pop those are do not contains q[i] now \\n            }\\n            \\n            int ans=-1;\\n            \\n            if(!pq.empty())\\n             ans=pq.top().first;\\n            \\n            int index=-1;\\n            \\n            if(mp[q[i]].size()!=0)\\n            {\\n                index=*mp[q[i]].begin();\\n                \\n                res[index]=ans;\\n                mp[q[i]].erase(mp[q[i]].begin());\\n            }\\n            \\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2465833,
                "title": "priority-queue-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        auto cmp=[](pair<int,int> a,pair<int,int> b){ \\n            return a.second-a.first > b.second-b.first;\\n        };\\n        priority_queue< pair<int,int>, vector<pair<int,int>>, decltype(cmp)> pq(cmp);\\n        for(auto i: intervals){\\n            pq.push({i[0],i[1]});\\n        }\\n        multiset<pair<int,int>> m;\\n        vector<int> ans(queries.size(),-1);\\n        for(int i=0;i<queries.size();i++) m.insert({queries[i],i});\\n        while(pq.size() > 0){\\n            int curr = pq.top().second-pq.top().first +1;\\n            int a=pq.top().first;\\n            int b=pq.top().second;\\n            while(1){\\n                auto it = m.lower_bound({pq.top().first,0});\\n                if(it==m.end() || (*it).first > b) break;\\n                ans[(*it).second]=curr;\\n                m.erase(it);\\n            }\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        auto cmp=[](pair<int,int> a,pair<int,int> b){ \\n            return a.second-a.first > b.second-b.first;\\n        };\\n        priority_queue< pair<int,int>, vector<pair<int,int>>, decltype(cmp)> pq(cmp);\\n        for(auto i: intervals){\\n            pq.push({i[0],i[1]});\\n        }\\n        multiset<pair<int,int>> m;\\n        vector<int> ans(queries.size(),-1);\\n        for(int i=0;i<queries.size();i++) m.insert({queries[i],i});\\n        while(pq.size() > 0){\\n            int curr = pq.top().second-pq.top().first +1;\\n            int a=pq.top().first;\\n            int b=pq.top().second;\\n            while(1){\\n                auto it = m.lower_bound({pq.top().first,0});\\n                if(it==m.end() || (*it).first > b) break;\\n                ans[(*it).second]=curr;\\n                m.erase(it);\\n            }\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2444299,
                "title": "c-priorityqueue-dictionary-sorting",
                "content": "Time: O (nlogn + qlogq)\\nnlogn - intervals sorting\\nqlogq - queries sorting\\n```csharp\\npublic class Solution {\\n    public int[] MinInterval(int[][] intervals, int[] queries) {\\n        intervals = intervals.OrderBy(x => x[0]).ToArray();\\n        Dictionary<int, int> resultDict = new(); // key = \\'query\\', value = \\'interval size\\'\\n        PriorityQueue<(int size, int right), int> pq = new();\\n\\n        int i = 0;\\n        foreach (int q in queries.OrderBy(x => x)) { // order queries, but don\\'t change original array, it will be used at the end to return sized in correct order\\n\\n            while (i < intervals.Length && intervals[i][0] <= q) { // if there still invtervals and interval starts before current query\\n                int l = intervals[i][0], r = intervals[i][1];\\n                int size = r - l + 1;\\n                pq.Enqueue((size, r), size);\\n                i++;\\n            }\\n\\n            // pop those which are no longer valid\\n            while (pq.Count > 0 && pq.Peek().right < q) {\\n                pq.Dequeue();\\n            }\\n            resultDict[q] = pq.Count > 0 ? pq.Peek().size : -1; // even if there are duplicates, they will be overriden with the same value\\n        }\\n        return queries.Select(q => resultDict[q]).ToArray();\\n        // int[] result = new int[queries.Length];\\n        // for (int idx = 0; idx < queries.Length; idx++) {\\n        //     result[idx] = resultDict[queries[idx]];\\n        // }\\n        // return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```csharp\\npublic class Solution {\\n    public int[] MinInterval(int[][] intervals, int[] queries) {\\n        intervals = intervals.OrderBy(x => x[0]).ToArray();\\n        Dictionary<int, int> resultDict = new(); // key = \\'query\\', value = \\'interval size\\'\\n        PriorityQueue<(int size, int right), int> pq = new();\\n\\n        int i = 0;\\n        foreach (int q in queries.OrderBy(x => x)) { // order queries, but don\\'t change original array, it will be used at the end to return sized in correct order\\n\\n            while (i < intervals.Length && intervals[i][0] <= q) { // if there still invtervals and interval starts before current query\\n                int l = intervals[i][0], r = intervals[i][1];\\n                int size = r - l + 1;\\n                pq.Enqueue((size, r), size);\\n                i++;\\n            }\\n\\n            // pop those which are no longer valid\\n            while (pq.Count > 0 && pq.Peek().right < q) {\\n                pq.Dequeue();\\n            }\\n            resultDict[q] = pq.Count > 0 ? pq.Peek().size : -1; // even if there are duplicates, they will be overriden with the same value\\n        }\\n        return queries.Select(q => resultDict[q]).ToArray();\\n        // int[] result = new int[queries.Length];\\n        // for (int idx = 0; idx < queries.Length; idx++) {\\n        //     result[idx] = resultDict[queries[idx]];\\n        // }\\n        // return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2443174,
                "title": "c-python-min-heap",
                "content": "# C++ Code\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\t#define pi pair<int,int>    \\n\\t\\t#define f first\\n\\t\\t#define s second\\n\\n\\t\\tvector<int> minInterval(vector<vector<int>>& it, vector<int>& q) {\\n\\t\\t\\tpriority_queue<pi, vector<pi>, greater<pi>> pq;\\n\\t\\t\\tvector<pi> nq;\\n\\t\\t\\tfor(int i{0}; i<q.size(); ++i) nq.push_back({q[i], i});\\n\\t\\t\\tsort(nq.begin(), nq.end());\\n\\t\\t\\tsort(it.begin(), it.end());\\n\\t\\t\\tint j=0;\\n\\t\\t\\tvector<int> ans(q.size(), -1);\\n\\t\\t\\tfor(auto& x : nq){\\n\\t\\t\\t\\twhile(j<it.size() && it[j][0] <= x.f)\\n\\t\\t\\t\\t\\tpq.push({it[j][1]-it[j][0]+1,it[j][1]}),j++;\\n\\t\\t\\t\\twhile(pq.size() && pq.top().s < x.f)pq.pop();\\n\\t\\t\\t\\tif(pq.size()) ans[x.s] = pq.top().f;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\n# Python Code\\n\\tclass Solution:\\n\\t\\tdef minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\\n\\t\\t\\tintervals.sort()\\n\\n\\t\\t\\tj, pq = 0, []\\n\\t\\t\\tans = [-1]*(len(queries))\\n\\t\\t\\tfor i, x in sorted(enumerate(queries), key = lambda a: a[1]):\\n\\t\\t\\t\\twhile j<len(intervals) and x>=intervals[j][0]:\\n\\t\\t\\t\\t\\theapq.heappush(pq, (intervals[j][1]-intervals[j][0]+1, intervals[j][1]))\\n\\t\\t\\t\\t\\tj+=1\\n\\t\\t\\t\\twhile pq and pq[0][1] < x: heapq.heappop(pq)\\n\\t\\t\\t\\tif pq: ans[i] = pq[0][0]\\n\\t\\t\\treturn ans",
                "solutionTags": [
                    "Python",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\t#define pi pair<int,int>    \\n\\t\\t#define f first\\n\\t\\t#define s second\\n\\n\\t\\tvector<int> minInterval(vector<vector<int>>& it, vector<int>& q) {\\n\\t\\t\\tpriority_queue<pi, vector<pi>, greater<pi>> pq;\\n\\t\\t\\tvector<pi> nq;\\n\\t\\t\\tfor(int i{0}",
                "codeTag": "Java"
            },
            {
                "id": 2415980,
                "title": "lazy-propagation",
                "content": "vector<int> seg,lazy;\\n    \\n   \\n    \\n    void propogate(int l,int r,int sv){\\n        if(l==r){\\n            seg[sv]=min(seg[sv],lazy[sv]);\\n            lazy[sv]=INT_MAX;\\n            return ;\\n        }\\n        seg[sv]=min(seg[sv],lazy[sv]);\\n        lazy[sv*2]=min(lazy[sv*2],lazy[sv]);\\n        lazy[sv*2+1]=min(lazy[sv*2+1],lazy[sv]);\\n        lazy[sv]=INT_MAX;\\n    }\\n    \\n    void update(int l,int r,int i,int j,int sv,int val){\\n        propogate(l,r,sv);\\n        if(r<i or l>j) return ;\\n        if(l>=i and r<=j){\\n            lazy[sv]=min(lazy[sv],val);\\n            propogate(l,r,sv);\\n            return ;\\n        }\\n        int m=(l+r)/2;\\n       update(l,m,i,j,sv*2,val);\\n        update(m+1,r,i,j,sv*2+1,val);\\n        seg[sv]=min(seg[sv],min(seg[sv*2],seg[sv*2+1]));\\n    }\\n    \\n    int find(int l,int r,int v,int sv){\\n        propogate(l,r,sv);\\n       \\n        if(l==r){\\n          \\n            return seg[sv] ;\\n        }\\n        int m=(l+r)/2;\\n        if(m>=v) return find(l,m,v,sv*2);\\n        return find(m+1,r,v,sv*2+1);\\n        \\n    }\\n    \\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n       int n=0;\\n        for(int i=0;i<intervals.size();i++){\\n            n=max(n,intervals[i][0]);\\n            n=max(n,intervals[i][1]);\\n        }\\n        for(int i=0;i<queries.size();i++){\\n            n=max(n,queries[i]);\\n        }\\n        n++;\\n        \\n        seg.resize(4*n,INT_MAX);\\n        lazy.resize(4*n,INT_MAX);\\n        \\n        for(auto k:intervals){\\n            update(0,n-1,k[0],k[1],1,k[1]-k[0]+1);\\n        }\\n      vector<int> ans;\\n        for(auto q:queries){\\n            int x=find(0,n-1,q,1);\\n            if(x==INT_MAX) x=-1;\\n            ans.push_back(x);\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "vector<int> seg,lazy;\\n    \\n   \\n    \\n    void propogate(int l,int r,int sv){\\n        if(l==r){\\n            seg[sv]=min(seg[sv],lazy[sv]);\\n            lazy[sv]=INT_MAX;\\n            return ;\\n        }\\n        seg[sv]=min(seg[sv],lazy[sv]);\\n        lazy[sv*2]=min(lazy[sv*2],lazy[sv]);\\n        lazy[sv*2+1]=min(lazy[sv*2+1],lazy[sv]);\\n        lazy[sv]=INT_MAX;\\n    }\\n    \\n    void update(int l,int r,int i,int j,int sv,int val){\\n        propogate(l,r,sv);\\n        if(r<i or l>j) return ;\\n        if(l>=i and r<=j){\\n            lazy[sv]=min(lazy[sv],val);\\n            propogate(l,r,sv);\\n            return ;\\n        }\\n        int m=(l+r)/2;\\n       update(l,m,i,j,sv*2,val);\\n        update(m+1,r,i,j,sv*2+1,val);\\n        seg[sv]=min(seg[sv],min(seg[sv*2],seg[sv*2+1]));\\n    }\\n    \\n    int find(int l,int r,int v,int sv){\\n        propogate(l,r,sv);\\n       \\n        if(l==r){\\n          \\n            return seg[sv] ;\\n        }\\n        int m=(l+r)/2;\\n        if(m>=v) return find(l,m,v,sv*2);\\n        return find(m+1,r,v,sv*2+1);\\n        \\n    }\\n    \\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n       int n=0;\\n        for(int i=0;i<intervals.size();i++){\\n            n=max(n,intervals[i][0]);\\n            n=max(n,intervals[i][1]);\\n        }\\n        for(int i=0;i<queries.size();i++){\\n            n=max(n,queries[i]);\\n        }\\n        n++;\\n        \\n        seg.resize(4*n,INT_MAX);\\n        lazy.resize(4*n,INT_MAX);\\n        \\n        for(auto k:intervals){\\n            update(0,n-1,k[0],k[1],1,k[1]-k[0]+1);\\n        }\\n      vector<int> ans;\\n        for(auto q:queries){\\n            int x=find(0,n-1,q,1);\\n            if(x==INT_MAX) x=-1;\\n            ans.push_back(x);\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2362147,
                "title": "c-easy-to-understand-as-a-variant-of-skyline",
                "content": "# [C++] Easy to understand as a Variant of Skyline\\nWe can treat this problem as a variant of the [Skyline problem](https://leetcode.com/problems/the-skyline-problem/).  If you\\'re familiar with the skyline, then its solutions can easily adapted for this problem.\\nThe main difference is that here in this problem,\\nwe are looking for the minimum width, whereas in the skyline problem we\\'re looking for maximum\\nheight.\\n\\n* aux data structures: \\n\\t* enum class Kind { Start = 0, Query, End, };\\n\\t* Note that the Query is between Start and End.\\n\\n\\nSteps:\\n1. we convert each interval into two events (as 3-tuple/triplet):\\n   <start_pos, Start, height==width>,\\n   <end_pos,   End, height==width>,\\n2. each query will be converted as an event: <query_pos, Query, query_id>\\n3. sort the events\\n4. in a loop, iterate each event, and use a multiset<int> to maintain the active heights/width.\\n   We can get the current min height from the active heights set in O(1) time.\\n\\n```\\n// Idea / Solution: very similar to the Skyline problem.\\n// The difference is that here in this problem,\\n// we are looking for the minimum width, whereas in the skyline problem we\\'re looking for maximum\\n// height.\\n// aux data structures: enum class Kind { Start = 0, Query, End, }\\n// Steps:\\n// 1. we convert each interval into two events (as 3-tuple/triplet):\\n//    <start_pos, Start, height==width>,\\n//    <end_pos,   End, height==width>,\\n// 2. each query will be converted as an event: <query_pos, Query, query_id>\\n// 3. sort the events\\n// 4. in a loop, iterate each event, and use a multiset<int> to maintain the active heights/width.\\n//    We can get the current min height from the active heights set in O(1) time.\\nclass Solution {\\n    /// kind of event.\\n    /// Objects of a Enum Class are always comparable with themselves.\\n    enum class Kind : int8_t {\\n        START = 0,\\n        QUERY,\\n        END,\\n    };\\n    using Event = tuple<int, Kind, int>;\\n\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        // convert the intervals and queries into events\\n        vector<Event> events;\\n        events.reserve(intervals.size() * 2 + queries.size());\\n        // 1. we convert each interval into two events (as 3-tuple/triplet):\\n        //    <start_pos, Start, height==width>,\\n        //    <end_pos,   End, height==width>,\\n        for (auto& e : intervals) {\\n            auto start = e[0], end = e[1], width = end - start + 1;\\n            events.emplace_back(start, Kind::START, width);\\n            events.emplace_back(end, Kind::END, width);\\n        }\\n        // 2. each query will be converted as an event: <query_pos, Query, query_id>\\n        for (int q = 0; q < queries.size(); ++q) {\\n            events.emplace_back(queries[q], Kind::QUERY, q);\\n        }\\n        // 3. sort the events\\n        sort(events.begin(), events.end());\\n        // 4. in a loop, iterate each event, and use a multiset<int> to maintain the active\\n        // heights/width.\\n        // We can get the current min height from the active heights set in O(1) time.\\n        vector<int> res(queries.size(), -1);\\n        multiset<int> widths; // active widths\\n        for (auto [pos, kind, width_or_qid] : events) {\\n            switch (kind) {\\n            case Kind::START:\\n                widths.insert(width_or_qid);\\n                break;\\n            case Kind::QUERY:\\n                if (!widths.empty()) {\\n                    // get the current min width by querying the multiset widths.\\n                    res[width_or_qid] = *widths.begin();\\n                }\\n                break;\\n            case Kind::END:\\n                auto iter = widths.find(width_or_qid);\\n                widths.erase(iter);\\n                break;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\n// Idea / Solution: very similar to the Skyline problem.\\n// The difference is that here in this problem,\\n// we are looking for the minimum width, whereas in the skyline problem we\\'re looking for maximum\\n// height.\\n// aux data structures: enum class Kind { Start = 0, Query, End, }\\n// Steps:\\n// 1. we convert each interval into two events (as 3-tuple/triplet):\\n//    <start_pos, Start, height==width>,\\n//    <end_pos,   End, height==width>,\\n// 2. each query will be converted as an event: <query_pos, Query, query_id>\\n// 3. sort the events\\n// 4. in a loop, iterate each event, and use a multiset<int> to maintain the active heights/width.\\n//    We can get the current min height from the active heights set in O(1) time.\\nclass Solution {\\n    /// kind of event.\\n    /// Objects of a Enum Class are always comparable with themselves.\\n    enum class Kind : int8_t {\\n        START = 0,\\n        QUERY,\\n        END,\\n    };\\n    using Event = tuple<int, Kind, int>;\\n\\npublic:\\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\\n        // convert the intervals and queries into events\\n        vector<Event> events;\\n        events.reserve(intervals.size() * 2 + queries.size());\\n        // 1. we convert each interval into two events (as 3-tuple/triplet):\\n        //    <start_pos, Start, height==width>,\\n        //    <end_pos,   End, height==width>,\\n        for (auto& e : intervals) {\\n            auto start = e[0], end = e[1], width = end - start + 1;\\n            events.emplace_back(start, Kind::START, width);\\n            events.emplace_back(end, Kind::END, width);\\n        }\\n        // 2. each query will be converted as an event: <query_pos, Query, query_id>\\n        for (int q = 0; q < queries.size(); ++q) {\\n            events.emplace_back(queries[q], Kind::QUERY, q);\\n        }\\n        // 3. sort the events\\n        sort(events.begin(), events.end());\\n        // 4. in a loop, iterate each event, and use a multiset<int> to maintain the active\\n        // heights/width.\\n        // We can get the current min height from the active heights set in O(1) time.\\n        vector<int> res(queries.size(), -1);\\n        multiset<int> widths; // active widths\\n        for (auto [pos, kind, width_or_qid] : events) {\\n            switch (kind) {\\n            case Kind::START:\\n                widths.insert(width_or_qid);\\n                break;\\n            case Kind::QUERY:\\n                if (!widths.empty()) {\\n                    // get the current min width by querying the multiset widths.\\n                    res[width_or_qid] = *widths.begin();\\n                }\\n                break;\\n            case Kind::END:\\n                auto iter = widths.find(width_or_qid);\\n                widths.erase(iter);\\n                break;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2344879,
                "title": "c-beginner-s-friendly-easy-solution",
                "content": "\\tvector<int> minInterval(vector<vector<int>>& inter, vector<int>& q) {\\n        int n = inter.size();\\n        unordered_map<int,int> help;\\n        vector<int> cq = q;\\n        priority_queue<pair<int,int> ,vector<pair<int,int>> ,greater<pair<int,int>> > pq;\\n        sort(q.begin(),q.end());\\n        sort(inter.begin(),inter.end());\\n        \\n        int i = 0;\\n        for(auto it:q)\\n        {\\n            while(i<n && it>=inter[i][0])\\n            {\\n                if(it<=inter[i][1])\\n                {\\n                    int size = inter[i][1] - inter[i][0] + 1;\\n                    pq.push({size,inter[i][1]});\\n                }\\n                i++;\\n            }\\n            \\n            while(pq.size()&&pq.top().second<it)\\n            {\\n                pq.pop();\\n            }\\n            if(pq.size()==0)\\n                help[it] = -1;\\n            else \\n                help[it] = pq.top().first;\\n            \\n        }\\n        \\n        vector<int> ans;\\n        for(auto it:cq)\\n        {\\n            ans.push_back(help[it]);\\n        }\\n        \\n        return ans;\\n\\t}",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "\\tvector<int> minInterval(vector<vector<int>>& inter, vector<int>& q) {\\n        int n = inter.size();\\n        unordered_map<int,int> help;\\n        vector<int> cq = q;\\n        priority_queue<pair<int,int> ,vector<pair<int,int>> ,greater<pair<int,int>> > pq;\\n        sort(q.begin(),q.end());\\n        sort(inter.begin(),inter.end());\\n        \\n        int i = 0;\\n        for(auto it:q)\\n        {\\n            while(i<n && it>=inter[i][0])\\n            {\\n                if(it<=inter[i][1])\\n                {\\n                    int size = inter[i][1] - inter[i][0] + 1;\\n                    pq.push({size,inter[i][1]});\\n                }\\n                i++;\\n            }\\n            \\n            while(pq.size()&&pq.top().second<it)\\n            {\\n                pq.pop();\\n            }\\n            if(pq.size()==0)\\n                help[it] = -1;\\n            else \\n                help[it] = pq.top().first;\\n            \\n        }\\n        \\n        vector<int> ans;\\n        for(auto it:cq)\\n        {\\n            ans.push_back(help[it]);\\n        }\\n        \\n        return ans;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2317588,
                "title": "accepted-c-solution-heap-sortedset",
                "content": "```\\npublic class Solution {\\n    \\nprivate class Heap<T>\\n{\\n    private readonly IList<T> _data;\\n    private readonly IComparer<T> _comparer;\\n\\n    public int Count => _data.Count;\\n    public T Peek => _data[0];\\n\\n    public Heap(IList<T> inputs, IComparer<T> comparer = null)\\n    {\\n        _comparer = comparer ?? Comparer<T>.Default;\\n        _data = inputs;\\n        for (int i = Count / 2; i >= 0; i--)\\n        {\\n            SiftDown(i);\\n        }\\n    }\\n\\n    public Heap(IEnumerable<T> inputs, IComparer<T> comparer = null) : this(inputs.ToList(), comparer)\\n    {\\n    }\\n\\n    private void Swap(int i, int j)\\n    {\\n        var tmp = _data[i];\\n        _data[i] = _data[j];\\n        _data[j] = tmp;\\n    }\\n\\n    public void Clear()\\n    {\\n\\t    _data.Clear();\\n    }\\n\\n\\tprivate void SiftDown(int i)\\n    {\\n        while (2 * i + 1 < _data.Count)\\n        {\\n            int left = 2 * i + 1;\\n            int right = 2 * i + 2;\\n            int j = left;\\n\\n            if (right < _data.Count && _comparer.Compare(_data[right], _data[left]) < 0)\\n            {\\n                j = right;\\n            }\\n\\n            if (_comparer.Compare(_data[i], _data[j]) <= 0)\\n            {\\n                break;\\n            }\\n\\n            Swap(i, j);\\n            i = j;\\n        }\\n    }\\n\\n    private void SiftUp(int i)\\n    {\\n        while(_comparer.Compare(_data[i], _data[(i - 1) / 2]) < 0)\\n        {\\n            Swap(i, (i - 1) / 2);\\n            i = (i - 1) / 2;\\n        }\\n    }\\n\\n    public T Pop()\\n    {\\n        T top = Peek;\\n        _data[0] = _data.Last();\\n        _data.RemoveAt(Count - 1);\\n        SiftDown(0);\\n        return top;\\n    }\\n\\n    public void Push(T value)\\n    {\\n        _data.Add(value);\\n        SiftUp(Count - 1);\\n    }\\n}\\n    \\n    \\n\\t\\t\\tprivate class ExitComparer : IComparer<int>\\n\\t\\t\\t{\\n\\t\\t\\t\\tprivate readonly int[][] _intervals;\\n\\n\\t\\t\\t\\tpublic ExitComparer(int[][] intervals)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t_intervals = intervals;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tpublic int Compare(int x, int y)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tvar cmp = _intervals[x][1].CompareTo(_intervals[y][1]);\\n\\t\\t\\t\\t\\tif (cmp == 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\treturn x.CompareTo(y);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\treturn cmp;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tprivate class LengthComparer : IComparer<int>\\n\\t\\t\\t{\\n\\t\\t\\t\\tprivate readonly int[][] _intervals;\\n\\n\\t\\t\\t\\tpublic LengthComparer(int[][] intervals)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t_intervals = intervals;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tpublic int Compare(int x, int y)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tvar l1 = _intervals[x][1] - _intervals[x][0] + 1;\\n\\t\\t\\t\\t\\tvar l2 = _intervals[y][1] - _intervals[y][0] + 1;\\n\\t\\t\\t\\t\\tvar cmp = l1.CompareTo(l2);\\n\\t\\t\\t\\t\\tif (cmp == 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tcmp = x.CompareTo(y);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\treturn cmp;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n    \\n    \\n    public int[] MinInterval(int[][] intervals, int[] queries) {\\n        Array.Sort(intervals, (i1, i2) => i1[0].CompareTo(i2[0]));\\n\\t\\t\\t\\t(int q, int idx)[] qdata = new (int q, int idx)[queries.Length];\\n\\t\\t\\t\\tfor (var i = 0; i < queries.Length; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tqdata[i] = (queries[i], i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tArray.Sort(qdata, (q1, q2) =>\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tvar cmp = q1.q.CompareTo(q2.q);\\n\\t\\t\\t\\t\\tif (cmp == 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tcmp = q1.idx.CompareTo(q2.idx);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\treturn cmp;\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\tint[] res = new int[queries.Length];\\n\\t\\t\\t\\tHeap<int> opened = new Heap<int>(new List<int>(), new ExitComparer(intervals));\\n\\t\\t\\t\\tSortedSet<int> minLengthSet = new SortedSet<int>(new LengthComparer(intervals));\\n\\t\\t\\t\\tint intervalOpenIdx = 0;\\n\\n\\t\\t\\t\\tfor (var i = 0; i < qdata.Length; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tvar curr = qdata[i];\\n\\t\\t\\t\\t\\twhile (intervalOpenIdx != intervals.Length && intervals[intervalOpenIdx][0] <= curr.q)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\topened.Push(intervalOpenIdx);\\n\\t\\t\\t\\t\\t\\tminLengthSet.Add(intervalOpenIdx);\\n                        intervalOpenIdx++;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\twhile (opened.Count > 0 && intervals[opened.Peek][1] < curr.q)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tminLengthSet.Remove(opened.Peek);\\n\\t\\t\\t\\t\\t\\topened.Pop();\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif (minLengthSet.Count != 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tvar min = minLengthSet.Min;\\n\\t\\t\\t\\t\\t\\tres[curr.idx] = intervals[min][1] - intervals[min][0] + 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tres[curr.idx] = -1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic class Solution {\\n    \\nprivate class Heap<T>\\n{\\n    private readonly IList<T> _data;\\n    private readonly IComparer<T> _comparer;\\n\\n    public int Count => _data.Count;\\n    public T Peek => _data[0];\\n\\n    public Heap(IList<T> inputs, IComparer<T> comparer = null)\\n    {\\n        _comparer = comparer ?? Comparer<T>.Default;\\n        _data = inputs;\\n        for (int i = Count / 2; i >= 0; i--)\\n        {\\n            SiftDown(i);\\n        }\\n    }\\n\\n    public Heap(IEnumerable<T> inputs, IComparer<T> comparer = null) : this(inputs.ToList(), comparer)\\n    {\\n    }\\n\\n    private void Swap(int i, int j)\\n    {\\n        var tmp = _data[i];\\n        _data[i] = _data[j];\\n        _data[j] = tmp;\\n    }\\n\\n    public void Clear()\\n    {\\n\\t    _data.Clear();\\n    }\\n\\n\\tprivate void SiftDown(int i)\\n    {\\n        while (2 * i + 1 < _data.Count)\\n        {\\n            int left = 2 * i + 1;\\n            int right = 2 * i + 2;\\n            int j = left;\\n\\n            if (right < _data.Count && _comparer.Compare(_data[right], _data[left]) < 0)\\n            {\\n                j = right;\\n            }\\n\\n            if (_comparer.Compare(_data[i], _data[j]) <= 0)\\n            {\\n                break;\\n            }\\n\\n            Swap(i, j);\\n            i = j;\\n        }\\n    }\\n\\n    private void SiftUp(int i)\\n    {\\n        while(_comparer.Compare(_data[i], _data[(i - 1) / 2]) < 0)\\n        {\\n            Swap(i, (i - 1) / 2);\\n            i = (i - 1) / 2;\\n        }\\n    }\\n\\n    public T Pop()\\n    {\\n        T top = Peek;\\n        _data[0] = _data.Last();\\n        _data.RemoveAt(Count - 1);\\n        SiftDown(0);\\n        return top;\\n    }\\n\\n    public void Push(T value)\\n    {\\n        _data.Add(value);\\n        SiftUp(Count - 1);\\n    }\\n}\\n    \\n    \\n\\t\\t\\tprivate class ExitComparer : IComparer<int>\\n\\t\\t\\t{\\n\\t\\t\\t\\tprivate readonly int[][] _intervals;\\n\\n\\t\\t\\t\\tpublic ExitComparer(int[][] intervals)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t_intervals = intervals;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tpublic int Compare(int x, int y)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tvar cmp = _intervals[x][1].CompareTo(_intervals[y][1]);\\n\\t\\t\\t\\t\\tif (cmp == 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\treturn x.CompareTo(y);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\treturn cmp;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tprivate class LengthComparer : IComparer<int>\\n\\t\\t\\t{\\n\\t\\t\\t\\tprivate readonly int[][] _intervals;\\n\\n\\t\\t\\t\\tpublic LengthComparer(int[][] intervals)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t_intervals = intervals;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tpublic int Compare(int x, int y)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tvar l1 = _intervals[x][1] - _intervals[x][0] + 1;\\n\\t\\t\\t\\t\\tvar l2 = _intervals[y][1] - _intervals[y][0] + 1;\\n\\t\\t\\t\\t\\tvar cmp = l1.CompareTo(l2);\\n\\t\\t\\t\\t\\tif (cmp == 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tcmp = x.CompareTo(y);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\treturn cmp;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n    \\n    \\n    public int[] MinInterval(int[][] intervals, int[] queries) {\\n        Array.Sort(intervals, (i1, i2) => i1[0].CompareTo(i2[0]));\\n\\t\\t\\t\\t(int q, int idx)[] qdata = new (int q, int idx)[queries.Length];\\n\\t\\t\\t\\tfor (var i = 0; i < queries.Length; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tqdata[i] = (queries[i], i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tArray.Sort(qdata, (q1, q2) =>\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tvar cmp = q1.q.CompareTo(q2.q);\\n\\t\\t\\t\\t\\tif (cmp == 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tcmp = q1.idx.CompareTo(q2.idx);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\treturn cmp;\\n\\t\\t\\t\\t});\\n\\n\\t\\t\\t\\tint[] res = new int[queries.Length];\\n\\t\\t\\t\\tHeap<int> opened = new Heap<int>(new List<int>(), new ExitComparer(intervals));\\n\\t\\t\\t\\tSortedSet<int> minLengthSet = new SortedSet<int>(new LengthComparer(intervals));\\n\\t\\t\\t\\tint intervalOpenIdx = 0;\\n\\n\\t\\t\\t\\tfor (var i = 0; i < qdata.Length; i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tvar curr = qdata[i];\\n\\t\\t\\t\\t\\twhile (intervalOpenIdx != intervals.Length && intervals[intervalOpenIdx][0] <= curr.q)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\topened.Push(intervalOpenIdx);\\n\\t\\t\\t\\t\\t\\tminLengthSet.Add(intervalOpenIdx);\\n                        intervalOpenIdx++;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\twhile (opened.Count > 0 && intervals[opened.Peek][1] < curr.q)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tminLengthSet.Remove(opened.Peek);\\n\\t\\t\\t\\t\\t\\topened.Pop();\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif (minLengthSet.Count != 0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tvar min = minLengthSet.Min;\\n\\t\\t\\t\\t\\t\\tres[curr.idx] = intervals[min][1] - intervals[min][0] + 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tres[curr.idx] = -1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2301587,
                "title": "c",
                "content": "```\\npublic int[] MinInterval(int[][] intervals, int[] queries) {\\n        int[][] q = new int[queries.Length][];\\n        for (int i=0;i<queries.Length;i++){\\n            q[i]=new int[]{i,queries[i]};\\n        }\\n        Array.Sort(intervals,(a,b)=>a[0]-b[0]);\\n        Array.Sort(q,(a,b)=>a[1]-b[1]);\\n        var minHeap=new PriorityQueue<int,int>();\\n        \\n        int j=0;\\n        int[] result=new int[queries.Length];                                           \\n        for(int i=0;i<q.Length;i++){\\n           while(j<intervals.Length && q[i][1]>=intervals[j][0]){\\n               minHeap.Enqueue(intervals[j][1],intervals[j][1]-intervals[j][0]+1);\\n               j++;\\n           }\\n            \\n            while(minHeap.Count>0 && minHeap.Peek()<q[i][1]){\\n                minHeap.Dequeue();\\n            }\\n           bool flag= minHeap.TryPeek(out int lastVal,out int val);\\n            if(!flag){\\n                val=-1;\\n            }\\n            \\n            result[q[i][0]]=val;\\n          \\n        }\\n                                                   return result;\\n                                                   \\n                                                   \\n        \\n                                                   \\n    \\n}",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic int[] MinInterval(int[][] intervals, int[] queries) {\\n        int[][] q = new int[queries.Length][];\\n        for (int i=0;i<queries.Length;i++){\\n            q[i]=new int[]{i,queries[i]};\\n        }\\n        Array.Sort(intervals,(a,b)=>a[0]-b[0]);\\n        Array.Sort(q,(a,b)=>a[1]-b[1]);\\n        var minHeap=new PriorityQueue<int,int>();\\n        \\n        int j=0;\\n        int[] result=new int[queries.Length];                                           \\n        for(int i=0;i<q.Length;i++){\\n           while(j<intervals.Length && q[i][1]>=intervals[j][0]){\\n               minHeap.Enqueue(intervals[j][1],intervals[j][1]-intervals[j][0]+1);\\n               j++;\\n           }\\n            \\n            while(minHeap.Count>0 && minHeap.Peek()<q[i][1]){\\n                minHeap.Dequeue();\\n            }\\n           bool flag= minHeap.TryPeek(out int lastVal,out int val);\\n            if(!flag){\\n                val=-1;\\n            }\\n            \\n            result[q[i][0]]=val;\\n          \\n        }\\n                                                   return result;\\n                                                   \\n                                                   \\n        \\n                                                   \\n    \\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2289535,
                "title": "java-solution",
                "content": "\\tclass Solution {\\n\\t\\tpublic int[] minInterval(int[][] intervals, int[] queries) {\\n\\t\\t\\tArrays.sort(intervals,(x,y)->{\\n\\t\\t\\t\\tif(x[1]!=y[1]) \\n\\t\\t\\t\\t\\treturn y[1]-x[1];\\n\\t\\t\\t\\treturn y[0]-x[0];\\n\\t\\t\\t});\\n\\t\\t\\tint[][] queryWithIndex = new int[queries.length][2];\\n\\t\\t\\tfor(int i=0;i<queryWithIndex.length;i++){\\n\\t\\t\\t\\tqueryWithIndex[i][0] = queries[i];\\n\\t\\t\\t\\tqueryWithIndex[i][1] = i;\\n\\t\\t\\t}\\n\\t\\t\\tArrays.sort(queryWithIndex,(x,y)->y[0]-x[0]);\\n\\t\\t\\t//minHeap int[0] : distance,int[1] : left\\n\\t\\t\\tPriorityQueue<int[]> minHeap = new PriorityQueue<>((x,y)->x[0]-y[0]);\\n\\n\\t\\t\\tint[] result = new int[queries.length];\\n\\t\\t\\tfor(int i=0,j=0;i<queryWithIndex.length;i++){\\n\\t\\t\\t\\tint query  = queryWithIndex[i][0];\\n\\t\\t\\t\\tint queryIndex = queryWithIndex[i][1];\\n\\t\\t\\t\\twhile(j<intervals.length && intervals[j][1]>=query){\\n\\t\\t\\t\\t\\tminHeap.offer(new int[]{intervals[j][1]-intervals[j][0]+1,intervals[j][0]});\\n\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\twhile(minHeap.size()>0 && minHeap.peek()[1]>query){\\n\\t\\t\\t\\t\\tminHeap.poll();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(minHeap.size()==0)\\n\\t\\t\\t\\t\\tresult[queryIndex] = -1;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tresult[queryIndex] = minHeap.peek()[0];\\n\\t\\t\\t}\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n\\t\\tpublic int[] minInterval(int[][] intervals, int[] queries) {\\n\\t\\t\\tArrays.sort(intervals,(x,y)->{\\n\\t\\t\\t\\tif(x[1]!=y[1]) \\n\\t\\t\\t\\t\\treturn y[1]-x[1];\\n\\t\\t\\t\\treturn y[0]-x[0];\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2288338,
                "title": "java-hashmap-priorityqueue",
                "content": "```\\nclass Solution {\\n    public int[] minInterval(int[][] intervals, int[] q) {\\n        \\n        Arrays.sort(intervals,(a,b) ->(a[0] != b[0] ? a[0]-b[0]:(a[1]-a[0])-(b[1]-b[0])));\\n        int tmp[] = new int[q.length];\\n        for(int pos = 0; pos<q.length; pos++) {\\n            tmp[pos] = q[pos];\\n        }\\n        Arrays.sort(tmp);\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        PriorityQueue<int[]> heap = new PriorityQueue<>((a,b) ->(a[0] != b[0] ? a[0]-b[0]:(a[1]-a[0])-(b[1]-b[0])));\\n        int i = 0, j = 0;\\n        for(i = 0,j = 0;j<q.length;) {\\n            \\n            while(i<intervals.length && tmp[j] >= intervals[i][0]){\\n                heap.add(new int[]{intervals[i][1]-intervals[i][0]+1,intervals[i][1]});\\n                i++;\\n            }\\n            while(heap.size()>0 && heap.peek()[1] < tmp[j] ){\\n                heap.poll();\\n            }\\n            if(heap.size() > 0){\\n                hm.put(tmp[j], heap.peek()[0]);\\n            } else{\\n                 hm.put(tmp[j], -1);\\n            }\\n\\n            j++;\\n        }\\n        \\n        for(i = 0; i< q.length; i++) {\\n            if(hm.containsKey(q[i])){\\n                q[i] = hm.get(q[i]);\\n            } else {\\n                q[i] = -1;\\n            }\\n        }\\n        \\n        return q;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] minInterval(int[][] intervals, int[] q) {\\n        \\n        Arrays.sort(intervals,(a,b) ->(a[0] != b[0] ? a[0]-b[0]:(a[1]-a[0])-(b[1]-b[0])));\\n        int tmp[] = new int[q.length];\\n        for(int pos = 0; pos<q.length; pos++) {\\n            tmp[pos] = q[pos];\\n        }\\n        Arrays.sort(tmp);\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        PriorityQueue<int[]> heap = new PriorityQueue<>((a,b) ->(a[0] != b[0] ? a[0]-b[0]:(a[1]-a[0])-(b[1]-b[0])));\\n        int i = 0, j = 0;\\n        for(i = 0,j = 0;j<q.length;) {\\n            \\n            while(i<intervals.length && tmp[j] >= intervals[i][0]){\\n                heap.add(new int[]{intervals[i][1]-intervals[i][0]+1,intervals[i][1]});\\n                i++;\\n            }\\n            while(heap.size()>0 && heap.peek()[1] < tmp[j] ){\\n                heap.poll();\\n            }\\n            if(heap.size() > 0){\\n                hm.put(tmp[j], heap.peek()[0]);\\n            } else{\\n                 hm.put(tmp[j], -1);\\n            }\\n\\n            j++;\\n        }\\n        \\n        for(i = 0; i< q.length; i++) {\\n            if(hm.containsKey(q[i])){\\n                q[i] = hm.get(q[i]);\\n            } else {\\n                q[i] = -1;\\n            }\\n        }\\n        \\n        return q;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2265740,
                "title": "1851-java-code",
                "content": "```\\nclass Solution {\\n    public int[] minInterval(int[][] intervals, int[] queries) {\\n        //the basic idea here is that queries can be considered as the x-axis (visualization) and let\\'s say we sort the queries in ascending order. The intervals are also sorted in ascending order. While iterating through the queries, we also iterate through each interval. How to make sure that a query belongs to an interval. The start time of the interval must be less than or equal to the query. We put the interval into a minHeap based on a pair (length, intervalEnd). Why intervalEnd has to be marked? In case of a tie of length, the deciding factor would be the intervalEnd. The lesser the value the higher the chances of being polled. This is because we need to poll the interval on the left side because the right intervals might belong to other queries as well.\\n        //copy queries \\n        int[]temp = new int[queries.length];\\n        for(int i = 0; i < temp.length; i++){\\n            temp[i] = queries[i];\\n        }\\n        Arrays.sort(queries);\\n        //Sort the intervals based on the start time.\\n        Arrays.sort(intervals, new Comparator<int[]>(){\\n            public int compare(int[]a, int[]b){\\n                return a[0] - b[0];\\n            }\\n        });\\n        \\n        PriorityQueue<Pair> minHeap = new PriorityQueue<>(new Comparator<Pair>(){\\n            public int compare(Pair a, Pair b){\\n                if(a.length == b.length){\\n                    return a.IntervalEnd - b.IntervalEnd;\\n                }    \\n                return a.length - b.length;\\n            }\\n        });\\n        \\n        int[]res = new int[queries.length];\\n        \\n        HashMap<Integer, Integer> map = new HashMap<>(); //key : query, value : size\\n        int i = 0;\\n        for(int query : queries){\\n            while(i < intervals.length && intervals[i][0] <= query){\\n                //push it onto the minHeap\\n                int start = intervals[i][0];\\n                int end = intervals[i][1];\\n                minHeap.offer(new Pair(end - start + 1, end));\\n                i++;\\n            }\\n            while(!minHeap.isEmpty() && minHeap.peek().IntervalEnd < query){\\n                //these intervals are not needed so poll them\\n                minHeap.poll();\\n            }\\n            if(!minHeap.isEmpty()){\\n                map.put(query, minHeap.peek().length);\\n            }\\n            else{\\n                map.put(query, -1);\\n            }\\n        }\\n        \\n        for(i = 0; i < temp.length; i++){\\n            res[i] = map.get(temp[i]);\\n        }\\n        return res;\\n    }\\n}\\n\\nclass Pair{\\n    int length;\\n    int IntervalEnd;\\n    Pair(int l, int i){\\n        length = l;\\n        IntervalEnd = i;\\n    }\\n}\\n\\n//O(nlogn) + O(qlogq) time```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] minInterval(int[][] intervals, int[] queries) {\\n        //the basic idea here is that queries can be considered as the x-axis (visualization) and let\\'s say we sort the queries in ascending order. The intervals are also sorted in ascending order. While iterating through the queries, we also iterate through each interval. How to make sure that a query belongs to an interval. The start time of the interval must be less than or equal to the query. We put the interval into a minHeap based on a pair (length, intervalEnd). Why intervalEnd has to be marked? In case of a tie of length, the deciding factor would be the intervalEnd. The lesser the value the higher the chances of being polled. This is because we need to poll the interval on the left side because the right intervals might belong to other queries as well.\\n        //copy queries \\n        int[]temp = new int[queries.length];\\n        for(int i = 0; i < temp.length; i++){\\n            temp[i] = queries[i];\\n        }\\n        Arrays.sort(queries);\\n        //Sort the intervals based on the start time.\\n        Arrays.sort(intervals, new Comparator<int[]>(){\\n            public int compare(int[]a, int[]b){\\n                return a[0] - b[0];\\n            }\\n        });\\n        \\n        PriorityQueue<Pair> minHeap = new PriorityQueue<>(new Comparator<Pair>(){\\n            public int compare(Pair a, Pair b){\\n                if(a.length == b.length){\\n                    return a.IntervalEnd - b.IntervalEnd;\\n                }    \\n                return a.length - b.length;\\n            }\\n        });\\n        \\n        int[]res = new int[queries.length];\\n        \\n        HashMap<Integer, Integer> map = new HashMap<>(); //key : query, value : size\\n        int i = 0;\\n        for(int query : queries){\\n            while(i < intervals.length && intervals[i][0] <= query){\\n                //push it onto the minHeap\\n                int start = intervals[i][0];\\n                int end = intervals[i][1];\\n                minHeap.offer(new Pair(end - start + 1, end));\\n                i++;\\n            }\\n            while(!minHeap.isEmpty() && minHeap.peek().IntervalEnd < query){\\n                //these intervals are not needed so poll them\\n                minHeap.poll();\\n            }\\n            if(!minHeap.isEmpty()){\\n                map.put(query, minHeap.peek().length);\\n            }\\n            else{\\n                map.put(query, -1);\\n            }\\n        }\\n        \\n        for(i = 0; i < temp.length; i++){\\n            res[i] = map.get(temp[i]);\\n        }\\n        return res;\\n    }\\n}\\n\\nclass Pair{\\n    int length;\\n    int IntervalEnd;\\n    Pair(int l, int i){\\n        length = l;\\n        IntervalEnd = i;\\n    }\\n}\\n\\n//O(nlogn) + O(qlogq) time```",
                "codeTag": "Java"
            },
            {
                "id": 2265347,
                "title": "java-solution-priority-queue-nyc",
                "content": "```\\nclass Solution {\\n    public int[] minInterval(int[][] intervals, int[] queries) {\\n        \\n        int[][] index_query = new int[queries.length][2];\\n        for(int i = 0;i<index_query.length;i++){\\n            index_query[i][0] = queries[i];\\n            index_query[i][1] = i;\\n        }\\n        \\n        // sort queries as per the \\n        Arrays.sort(index_query, new Comparator<int[]>(){\\n            public int compare(int[] a, int[] b){\\n                if(a[0] == b[0])\\n                    return a[1] - b[1];\\n                return a[0] - b[0];\\n            }\\n        });\\n        \\n        // sort the intervals as per starting time\\n        Arrays.sort(intervals, new Comparator<int[]>(){\\n            public int compare(int[] a, int[] b){\\n                if(a[0] == b[0])\\n                    return a[1] - b[1];\\n                return a[0] - b[0];\\n            }\\n        });\\n            \\n        // make the priority queue\\n        PriorityQueue<int[]> ret = new PriorityQueue<>(new Comparator<int[]>(){\\n            public int compare(int[] a, int[] b){\\n                if(a[0] == b[0])\\n                    return a[1] - b[1];\\n                return a[0] - b[0];\\n            }\\n        });\\n        \\n        // iterate over the queries for the results\\n        int[] fret = new int[queries.length];\\n        int j = 0;\\n        for(int i = 0;i<index_query.length;i++){\\n            while(j < intervals.length){\\n                if(intervals[j][0] <= index_query[i][0]){\\n                    // add to the priority queue\\n                    ret.add(new int[]{intervals[j][1] - intervals[j][0]+1, intervals[j][1]});\\n                    j += 1;\\n                }\\n                else\\n                    break;\\n            }\\n            \\n            // now, weed out those intervals whose end time is less than query\\n            while(!ret.isEmpty()){\\n                int[] temp = ret.peek();\\n                if(temp[1] < index_query[i][0])\\n                    ret.poll();\\n                else\\n                    break;\\n            }\\n            if(ret.isEmpty())\\n                fret[index_query[i][1]] = -1;\\n            else{\\n                int[] temp = ret.peek();\\n                fret[index_query[i][1]] = temp[0];\\n            }\\n        }\\n        return fret;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] minInterval(int[][] intervals, int[] queries) {\\n        \\n        int[][] index_query = new int[queries.length][2];\\n        for(int i = 0;i<index_query.length;i++){\\n            index_query[i][0] = queries[i];\\n            index_query[i][1] = i;\\n        }\\n        \\n        // sort queries as per the \\n        Arrays.sort(index_query, new Comparator<int[]>(){\\n            public int compare(int[] a, int[] b){\\n                if(a[0] == b[0])\\n                    return a[1] - b[1];\\n                return a[0] - b[0];\\n            }\\n        });\\n        \\n        // sort the intervals as per starting time\\n        Arrays.sort(intervals, new Comparator<int[]>(){\\n            public int compare(int[] a, int[] b){\\n                if(a[0] == b[0])\\n                    return a[1] - b[1];\\n                return a[0] - b[0];\\n            }\\n        });\\n            \\n        // make the priority queue\\n        PriorityQueue<int[]> ret = new PriorityQueue<>(new Comparator<int[]>(){\\n            public int compare(int[] a, int[] b){\\n                if(a[0] == b[0])\\n                    return a[1] - b[1];\\n                return a[0] - b[0];\\n            }\\n        });\\n        \\n        // iterate over the queries for the results\\n        int[] fret = new int[queries.length];\\n        int j = 0;\\n        for(int i = 0;i<index_query.length;i++){\\n            while(j < intervals.length){\\n                if(intervals[j][0] <= index_query[i][0]){\\n                    // add to the priority queue\\n                    ret.add(new int[]{intervals[j][1] - intervals[j][0]+1, intervals[j][1]});\\n                    j += 1;\\n                }\\n                else\\n                    break;\\n            }\\n            \\n            // now, weed out those intervals whose end time is less than query\\n            while(!ret.isEmpty()){\\n                int[] temp = ret.peek();\\n                if(temp[1] < index_query[i][0])\\n                    ret.poll();\\n                else\\n                    break;\\n            }\\n            if(ret.isEmpty())\\n                fret[index_query[i][1]] = -1;\\n            else{\\n                int[] temp = ret.peek();\\n                fret[index_query[i][1]] = temp[0];\\n            }\\n        }\\n        return fret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2252424,
                "title": "java-sort-minheap-easy",
                "content": "### Sort + MinHeap\\n\\n1. Sort intervals by start point\\n2. Sort queries (either copy queries then sort them or create a sorted query index array)\\n3. create a min-heap (this data strucutre is used to find the smallest size interval). In this min-heap, we use [interval size, interval end] = [r-l+1, r] as the key.\\n4. Iterate through queries\\n\\ta. find all intervals that contain this query and add them to the minHeap\\n\\tb. remove all invalid intervals (its right point is less than the query) from the minHeap\\n\\tc. update the result\\n\\n```\\npublic int[] minInterval(int[][] intervals, int[] queries) {\\n        //base case\\n        if(intervals == null || intervals.length == 0 || queries == null || queries.length == 0) return new int[0];\\n        \\n        int numOfQueries = queries.length;\\n        int[] result = new int[numOfQueries];\\n        \\n        List<Integer> sortedQueryIndex = new ArrayList<>();\\n        for (int i = 0; i < numOfQueries; i++) sortedQueryIndex.add(i);\\n        \\n        \\n        //sort intervals base on left value (if left values are the same, sort by right value)\\n        Arrays.sort(intervals, (a, b) -> (a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]));\\n        //sort queries index base on queries value [instead of sort queries, we sort the queries index]\\n        Collections.sort(sortedQueryIndex, (a, b)->(queries[a] - queries[b]));\\n        \\n        //min-heap (this data strucutre is used to find the smallest size interval)\\n        Queue<int[]> minHeap = new PriorityQueue<int[]>((a, b) -> (a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]));\\n       \\n        int intervalIdx = 0;//this variable tells us the position at the intervals array\\n        //interate through queries\\n        for(int i = 0; i < numOfQueries; i++){\\n            int queryIdx = sortedQueryIndex.get(i);\\n            int queryVal = queries[queryIdx];\\n            \\n            //find all intervals that contain this query and add them to the minHeap\\n            while(intervalIdx < intervals.length && intervals[intervalIdx][0] <= queryVal){\\n                int l = intervals[intervalIdx][0], r = intervals[intervalIdx][1];\\n                minHeap.add(new int[]{r - l + 1, r});//length of the interval and the right value\\n                intervalIdx++;\\n            }\\n            \\n            //remove all invalid intervals (its right value is less than the query) from the minHeap\\n            while(!minHeap.isEmpty() && minHeap.peek()[1] < queryVal){\\n                minHeap.poll();\\n            }\\n            \\n            //update the result array\\n            if(!minHeap.isEmpty())\\n                result[queryIdx] = minHeap.peek()[0];\\n            else result[queryIdx] = -1;\\n        }\\n        \\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] minInterval(int[][] intervals, int[] queries) {\\n        //base case\\n        if(intervals == null || intervals.length == 0 || queries == null || queries.length == 0) return new int[0];\\n        \\n        int numOfQueries = queries.length;\\n        int[] result = new int[numOfQueries];\\n        \\n        List<Integer> sortedQueryIndex = new ArrayList<>();\\n        for (int i = 0; i < numOfQueries; i++) sortedQueryIndex.add(i);\\n        \\n        \\n        //sort intervals base on left value (if left values are the same, sort by right value)\\n        Arrays.sort(intervals, (a, b) -> (a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]));\\n        //sort queries index base on queries value [instead of sort queries, we sort the queries index]\\n        Collections.sort(sortedQueryIndex, (a, b)->(queries[a] - queries[b]));\\n        \\n        //min-heap (this data strucutre is used to find the smallest size interval)\\n        Queue<int[]> minHeap = new PriorityQueue<int[]>((a, b) -> (a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]));\\n       \\n        int intervalIdx = 0;//this variable tells us the position at the intervals array\\n        //interate through queries\\n        for(int i = 0; i < numOfQueries; i++){\\n            int queryIdx = sortedQueryIndex.get(i);\\n            int queryVal = queries[queryIdx];\\n            \\n            //find all intervals that contain this query and add them to the minHeap\\n            while(intervalIdx < intervals.length && intervals[intervalIdx][0] <= queryVal){\\n                int l = intervals[intervalIdx][0], r = intervals[intervalIdx][1];\\n                minHeap.add(new int[]{r - l + 1, r});//length of the interval and the right value\\n                intervalIdx++;\\n            }\\n            \\n            //remove all invalid intervals (its right value is less than the query) from the minHeap\\n            while(!minHeap.isEmpty() && minHeap.peek()[1] < queryVal){\\n                minHeap.poll();\\n            }\\n            \\n            //update the result array\\n            if(!minHeap.isEmpty())\\n                result[queryIdx] = minHeap.peek()[0];\\n            else result[queryIdx] = -1;\\n        }\\n        \\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2225282,
                "title": "priority-queue-window",
                "content": "```\\nfrom heapq import *\\nfrom collections import defaultdict\\n\\n\\nclass Solution:\\n    def minInterval(self, intervals, queries):\\n        intervals=list(set(list(map(tuple,intervals))))\\n        L=defaultdict(list)\\n        for i,(l,r) in enumerate(intervals):\\n            L[l].append((r-l+1,r,i))\\n        ma=max(max(e) for e in intervals)\\n        answers=[-1 for _ in range(ma+1)]\\n        patch=set([e[0] for e in intervals if e[0]==e[1]])\\n        cur=[]\\n        for i in sorted(queries+L.keys()):\\n            for l in L[i]:\\n                heappush(cur,l)\\n            if i in patch:\\n                answers[i]=1\\n                continue\\n            got=False\\n            if len(cur):\\n                d,r,j=cur[0] #peek top\\n                got=True\\n            while len(cur) and r<i:\\n                d,r,j=heappop(cur)\\n                got=True\\n                if len(cur) and cur[0][1]>=i:\\n                    d,r,j=cur[0] #peek top\\n                    break\\n            if got and r>=i:\\n                answers[i]=d\\n        result=[]\\n        for q in queries:\\n            if q>ma:\\n                result.append(-1)\\n            else:\\n                result.append(answers[q])\\n        return result\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom heapq import *\\nfrom collections import defaultdict\\n\\n\\nclass Solution:\\n    def minInterval(self, intervals, queries):\\n        intervals=list(set(list(map(tuple,intervals))))\\n        L=defaultdict(list)\\n        for i,(l,r) in enumerate(intervals):\\n            L[l].append((r-l+1,r,i))\\n        ma=max(max(e) for e in intervals)\\n        answers=[-1 for _ in range(ma+1)]\\n        patch=set([e[0] for e in intervals if e[0]==e[1]])\\n        cur=[]\\n        for i in sorted(queries+L.keys()):\\n            for l in L[i]:\\n                heappush(cur,l)\\n            if i in patch:\\n                answers[i]=1\\n                continue\\n            got=False\\n            if len(cur):\\n                d,r,j=cur[0] #peek top\\n                got=True\\n            while len(cur) and r<i:\\n                d,r,j=heappop(cur)\\n                got=True\\n                if len(cur) and cur[0][1]>=i:\\n                    d,r,j=cur[0] #peek top\\n                    break\\n            if got and r>=i:\\n                answers[i]=d\\n        result=[]\\n        for q in queries:\\n            if q>ma:\\n                result.append(-1)\\n            else:\\n                result.append(answers[q])\\n        return result\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1575217,
                "content": [
                    {
                        "username": "bibaboy00",
                        "content": "[213. The Skyline Problem](https://leetcode.com/problems/the-skyline-problem/)\\n\\nThe only difference here is that:\\n1. height = width for each building (compared to random height)\\n2. min of all overlapped building (compared to max / skyline of overlapped building)\\n\\nSo remember this type of problem using heap:)"
                    },
                    {
                        "username": "askvij",
                        "content": "During the contest Segement Tree and BIT came in my mind while doing the testcases but i wasn\\'t able to implement it(found implementation hard). Can this question be solved using anyone of them ?"
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "Yes, you can use a segment tree with lazy propagation to solve this problem even though it is overkill. \\n\\n1. First, we have to do coordinate compression and compress the points in intervals and queries. \\n2. Next, we can sort the given intervals in decreasing order of the span (right-left+1), so that intervals with a longer span come first.\\n3. Now initialize a segment tree with lazy propagation and do range updates for each interval, let the current interval be (left_i, right_i), then do range update for all points left_i, left_i + 1, left_i + 2, ...... right_i and set the value for them to (right_i - left_i + 1), i.e the span of the interval.\\n4. Now go through the queries one by one and do point queries on the segment tree to retrieve the length of the smallest interval that contains that query."
                    },
                    {
                        "username": "ahan98",
                        "content": "I think the Python time constraints for TLE should be updated. It\\'s pretty dumb that segment tree works for C++ and Java, but not Python. Certainly in an interview, implementing a Segment Tree solution is more than sufficient and asymptotically optimal, especially after additional speedup tricks like coordinate compression."
                    }
                ]
            },
            {
                "id": 1567037,
                "content": [
                    {
                        "username": "bibaboy00",
                        "content": "[213. The Skyline Problem](https://leetcode.com/problems/the-skyline-problem/)\\n\\nThe only difference here is that:\\n1. height = width for each building (compared to random height)\\n2. min of all overlapped building (compared to max / skyline of overlapped building)\\n\\nSo remember this type of problem using heap:)"
                    },
                    {
                        "username": "askvij",
                        "content": "During the contest Segement Tree and BIT came in my mind while doing the testcases but i wasn\\'t able to implement it(found implementation hard). Can this question be solved using anyone of them ?"
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "Yes, you can use a segment tree with lazy propagation to solve this problem even though it is overkill. \\n\\n1. First, we have to do coordinate compression and compress the points in intervals and queries. \\n2. Next, we can sort the given intervals in decreasing order of the span (right-left+1), so that intervals with a longer span come first.\\n3. Now initialize a segment tree with lazy propagation and do range updates for each interval, let the current interval be (left_i, right_i), then do range update for all points left_i, left_i + 1, left_i + 2, ...... right_i and set the value for them to (right_i - left_i + 1), i.e the span of the interval.\\n4. Now go through the queries one by one and do point queries on the segment tree to retrieve the length of the smallest interval that contains that query."
                    },
                    {
                        "username": "ahan98",
                        "content": "I think the Python time constraints for TLE should be updated. It\\'s pretty dumb that segment tree works for C++ and Java, but not Python. Certainly in an interview, implementing a Segment Tree solution is more than sufficient and asymptotically optimal, especially after additional speedup tricks like coordinate compression."
                    }
                ]
            },
            {
                "id": 2003919,
                "content": [
                    {
                        "username": "bibaboy00",
                        "content": "[213. The Skyline Problem](https://leetcode.com/problems/the-skyline-problem/)\\n\\nThe only difference here is that:\\n1. height = width for each building (compared to random height)\\n2. min of all overlapped building (compared to max / skyline of overlapped building)\\n\\nSo remember this type of problem using heap:)"
                    },
                    {
                        "username": "askvij",
                        "content": "During the contest Segement Tree and BIT came in my mind while doing the testcases but i wasn\\'t able to implement it(found implementation hard). Can this question be solved using anyone of them ?"
                    },
                    {
                        "username": "roboto7o32oo3",
                        "content": "Yes, you can use a segment tree with lazy propagation to solve this problem even though it is overkill. \\n\\n1. First, we have to do coordinate compression and compress the points in intervals and queries. \\n2. Next, we can sort the given intervals in decreasing order of the span (right-left+1), so that intervals with a longer span come first.\\n3. Now initialize a segment tree with lazy propagation and do range updates for each interval, let the current interval be (left_i, right_i), then do range update for all points left_i, left_i + 1, left_i + 2, ...... right_i and set the value for them to (right_i - left_i + 1), i.e the span of the interval.\\n4. Now go through the queries one by one and do point queries on the segment tree to retrieve the length of the smallest interval that contains that query."
                    },
                    {
                        "username": "ahan98",
                        "content": "I think the Python time constraints for TLE should be updated. It\\'s pretty dumb that segment tree works for C++ and Java, but not Python. Certainly in an interview, implementing a Segment Tree solution is more than sufficient and asymptotically optimal, especially after additional speedup tricks like coordinate compression."
                    }
                ]
            }
        ]
    }
]