[
    {
        "title": "Making A Large Island",
        "question_content": "You are given an n x n binary matrix grid. You are allowed to change at most one 0 to be 1.\r\n\r\nReturn the size of the largest island in grid after applying this operation.\r\n\r\nAn island is a 4-directionally connected group of 1s.\r\n\r\n&nbsp;\r\nExample 1:\r\n\r\n\r\nInput: grid = [[1,0],[0,1]]\r\nOutput: 3\r\nExplanation: Change one 0 to 1 and connect two 1s, then we get an island with area = 3.\r\n\r\n\r\nExample 2:\r\n\r\n\r\nInput: grid = [[1,1],[1,0]]\r\nOutput: 4\r\nExplanation: Change the 0 to 1 and make the island bigger, only one island with area = 4.\r\n\r\nExample 3:\r\n\r\n\r\nInput: grid = [[1,1],[1,1]]\r\nOutput: 4\r\nExplanation: Can't change any 0 to 1, only one island with area = 4.\r\n\r\n\r\n&nbsp;\r\nConstraints:\r\n\r\n\r\n\tn == grid.length\r\n\tn == grid[i].length\r\n\t1 <= n <= 500\r\n\tgrid[i][j] is either 0 or 1.",
        "solutions": [
            {
                "id": 127015,
                "title": "c-with-picture-o-n-m",
                "content": "For each ```1``` in the grid, we paint all connected ```1``` with the next available color (2, 3, and so on). We also remember the size of the island we just painted with that color.\\n\\nThen, we analyze all ```0``` in the grid, and sum sizes of connected islands (based on the island color). Note that the same island can connect to  ```0``` more than once. The example below demonstrates this idea (the answer is highlighted):\\n<p align=\"center\">\\n  <img src=\"https://s3-lc-upload.s3.amazonaws.com/users/votrubac/image_1525310120.png\">\\n</p>\\n\\n**C++**\\n```cpp\\nint get(int i, int j, vector<vector<int>>& g) {\\n  return (i < 0 || j < 0 || i >= g.size() || j >= g[0].size()) ? 0 : g[i][j];\\n}\\nint paint(int i, int j, int clr, vector<vector<int>>& g)\\n{\\n  if (get(i, j, g) != 1) return 0;\\n  g[i][j] = clr;\\n  return 1 + paint(i + 1, j, clr, g) + paint(i - 1, j, clr, g) + paint(i, j + 1, clr, g) + paint(i, j - 1, clr, g);\\n}\\nint largestIsland(vector<vector<int>>& g, int res = 0) {\\n  vector<int> sizes = { 0, 0 }; // sentinel values; colors start from 2.\\n  for (auto i = 0; i < g.size(); ++i)\\n    for (auto j = 0; j < g[i].size(); ++j)\\n      if (g[i][j] == 1) sizes.push_back(paint(i, j, sizes.size(), g));\\n  for (auto i = 0; i < g.size(); ++i)\\n    for (auto j = 0; j < g[i].size(); ++j)\\n      if (g[i][j] == 0) {\\n        unordered_set<int> s = { get(i + 1, j, g), get(i - 1, j, g), get(i, j + 1, g), get(i, j - 1, g) };\\n        res = max(res, 1 + accumulate(begin(s), end(s), 0, [&](int a, int b) {return a + sizes[b]; }));\\n      }\\n  return res == 0 ? g.size() * g[0].size() : res;\\n}\\n```\\nJust to compare, below is a brute-force solution (accepted) that calculates the size of an island after flipping ```0```. It\\'s  shorter, but runtime is above 400 ms. It would probably be a good idea so stick to a simpler solution to save time during contests.\\n\\n> Update: this solution gives TLE now. \\n\\n**C++**\\n```cpp\\nint paint(int i, int j, int c, vector<vector<int>>& g, bool flip = false)\\n{\\n  if (!flip && (i < 0 || j < 0 || i >= g.size() || j >= g[0].size() || g[i][j] == 0 || g[i][j] == c)) return 0;\\n  g[i][j] = g[i][j] == 0 ? 0 : c;\\n  return 1 + paint(i + 1, j, c, g) + paint(i - 1, j, c, g) + paint(i, j + 1, c, g) + paint(i, j - 1, c, g);\\n}\\nint largestIsland(vector<vector<int>>& g, int res = 0) {\\n  for (auto i = 0; i < g.size(); ++i)\\n    for (auto j = 0; j < g[i].size(); ++j)\\n      if (g[i][j] == 0) {\\n        res = max(res, paint(i, j, 2, g, true));\\n        paint(i, j, 1, g, true);\\n      }\\n  return res == 0 ? g.size() * g[0].size() : res;\\n}\\n```",
                "solutionTags": [],
                "code": "```1```\n```1```\n```0```\n```0```\n```cpp\\nint get(int i, int j, vector<vector<int>>& g) {\\n  return (i < 0 || j < 0 || i >= g.size() || j >= g[0].size()) ? 0 : g[i][j];\\n}\\nint paint(int i, int j, int clr, vector<vector<int>>& g)\\n{\\n  if (get(i, j, g) != 1) return 0;\\n  g[i][j] = clr;\\n  return 1 + paint(i + 1, j, clr, g) + paint(i - 1, j, clr, g) + paint(i, j + 1, clr, g) + paint(i, j - 1, clr, g);\\n}\\nint largestIsland(vector<vector<int>>& g, int res = 0) {\\n  vector<int> sizes = { 0, 0 }; // sentinel values; colors start from 2.\\n  for (auto i = 0; i < g.size(); ++i)\\n    for (auto j = 0; j < g[i].size(); ++j)\\n      if (g[i][j] == 1) sizes.push_back(paint(i, j, sizes.size(), g));\\n  for (auto i = 0; i < g.size(); ++i)\\n    for (auto j = 0; j < g[i].size(); ++j)\\n      if (g[i][j] == 0) {\\n        unordered_set<int> s = { get(i + 1, j, g), get(i - 1, j, g), get(i, j + 1, g), get(i, j - 1, g) };\\n        res = max(res, 1 + accumulate(begin(s), end(s), 0, [&](int a, int b) {return a + sizes[b]; }));\\n      }\\n  return res == 0 ? g.size() * g[0].size() : res;\\n}\\n```\n```0```\n```cpp\\nint paint(int i, int j, int c, vector<vector<int>>& g, bool flip = false)\\n{\\n  if (!flip && (i < 0 || j < 0 || i >= g.size() || j >= g[0].size() || g[i][j] == 0 || g[i][j] == c)) return 0;\\n  g[i][j] = g[i][j] == 0 ? 0 : c;\\n  return 1 + paint(i + 1, j, c, g) + paint(i - 1, j, c, g) + paint(i, j + 1, c, g) + paint(i, j - 1, c, g);\\n}\\nint largestIsland(vector<vector<int>>& g, int res = 0) {\\n  for (auto i = 0; i < g.size(); ++i)\\n    for (auto j = 0; j < g[i].size(); ++j)\\n      if (g[i][j] == 0) {\\n        res = max(res, paint(i, j, 2, g, true));\\n        paint(i, j, 1, g, true);\\n      }\\n  return res == 0 ? g.size() * g[0].size() : res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 127032,
                "title": "c-java-python-straight-forward-o-n-2-with-explanations",
                "content": "# PreWord\\nThe solution is long, but in fact it is really straight forward.\\nI suggest **not** going into my codes but reading my explanations, which should be enough.\\n\\n# Prepare\\nI have several simple sub function to help me on this kind of problem.\\n1. valid(int x, int y), check if (x, y) is valid in the grid.\\n1. move(int x, int y), return all possible next position in 4 directions.\\n<br>\\n\\n# Explanation\\nOnly 2 steps:\\n1. Explore every island using DFS, count its area, give it an island index and save the result to a {index: area} map.\\n2. Loop every cell == 0, check its connected islands and calculate total islands area.\\n<br>\\n\\n# Complexity\\nTime `O(N^2)`\\nSpace `O(N^2)`\\n<br>\\n\\n**C++:**\\n```cpp\\n    int N;\\n    int largestIsland(vector<vector<int>>& grid) {\\n        N = grid.size();\\n        //DFS every island and give it an index of island\\n        int index = 2, res = 0;\\n        unordered_map <int, int>area;\\n        for (int x = 0; x < N; ++x) {\\n            for (int y = 0; y < N; ++y) {\\n                if (grid[x][y] == 1) {\\n                    area[index] = dfs(grid, x, y, index);\\n                    res = max(res, area[index++]);\\n                }\\n            }\\n        }\\n        //traverse every 0 cell and count biggest island it can conntect\\n        for (int x = 0; x < N; ++x)\\n            for (int y = 0; y < N; ++y)\\n                if (grid[x][y] == 0) {\\n                    unordered_set<int> seen = {};\\n                    int cur = 1;\\n                    for (auto p : move(x, y)) {\\n                        index = grid[p.first][p.second];\\n                        if (index > 1 && seen.count(index) == 0) {\\n                            seen.insert(index);\\n                            cur += area[index];\\n                        }\\n                    }\\n                    res = max(res, cur);\\n                }\\n        return res;\\n    }\\n\\n    vector<pair<int, int>> move(int x, int y) {\\n        vector<pair<int, int>> res;\\n        for (auto p : vector<vector<int>> {{1, 0}, { -1, 0}, {0, 1}, {0, -1}}) {\\n            if (valid(x + p[0], y + p[1]))\\n                res.push_back(make_pair(x + p[0], y + p[1]));\\n        }\\n        return res;\\n    }\\n\\n    int valid(int x, int y) {\\n        return 0 <= x && x < N && 0 <= y && y < N;\\n    }\\n\\n    int dfs(vector<vector<int>>& grid, int x, int y, int index) {\\n        int area = 0;\\n        grid[x][y] = index;\\n        for (auto p : move(x, y))\\n            if (grid[p.first][p.second] == 1)\\n                area += dfs(grid, p.first, p.second, index);\\n        return area + 1;\\n    }\\n```\\n\\n**Java:**\\n```java\\nimport javafx.util.Pair;\\nclass Solution {\\n    public int N = 0;\\n    public int largestIsland(int[][] grid) {\\n        N = grid.length;\\n        //DFS every island and give it an index of island\\n        int index = 3, res = 0;\\n        HashMap<Integer, Integer> area = new HashMap<>();\\n        for (int x = 0; x < N; ++x) for (int y = 0; y < N; ++y)\\n            if (grid[x][y] == 1) {\\n                area.put(index, dfs(grid, x, y, index));\\n                res = Math.max(res, area.get(index++));\\n            }\\n\\n        //traverse every 0 cell and count biggest island it can conntect\\n        for (int x = 0; x < N; ++x) for (int y = 0; y < N; ++y)\\n            if (grid[x][y] == 0) {\\n                HashSet<Integer> seen = new HashSet<>();\\n                int cur = 1;\\n                for (Pair<Integer, Integer> p : move(x, y)) {\\n                    index = grid[p.getKey()][p.getValue()];\\n                    if (index > 1 && !seen.contains(index)) {\\n                        seen.add(index);\\n                        cur += area.get(index);\\n                    }\\n                }\\n                res = Math.max(res, cur);\\n            }\\n        return res;\\n    }\\n\\n    public List <Pair<Integer, Integer>> move(int x, int y) {\\n        ArrayList <Pair<Integer, Integer>> res = new ArrayList<>();\\n        if (valid(x, y + 1)) res.add(new Pair<Integer, Integer>(x, y + 1));\\n        if (valid(x, y - 1)) res.add(new Pair<Integer, Integer>(x, y - 1));\\n        if (valid(x + 1, y)) res.add(new Pair<Integer, Integer>(x + 1, y));\\n        if (valid(x - 1, y)) res.add(new Pair<Integer, Integer>(x - 1, y));\\n        return res;\\n    }\\n\\n    public boolean valid(int x, int y) {\\n        return 0 <= x && x < N && 0 <= y && y < N;\\n    }\\n\\n    public int dfs(int[][] grid, int x, int y, int index) {\\n        int area = 0;\\n        grid[x][y] = index;\\n        for (Pair<Integer, Integer> p : move(x, y))\\n            if (grid[p.getKey()][p.getValue()] == 1)\\n                area += dfs(grid, p.getKey(), p.getValue(), index);\\n        return area + 1;\\n    }\\n}\\n\\n\\n```\\n**Python:**\\n```py\\n    def largestIsland(self, grid):\\n        N = len(grid)\\n\\n        def move(x, y):\\n            for i, j in ((1, 0), (-1, 0), (0, 1), (0, -1)):\\n                if 0 <= x + i < N and 0 <= y + j < N:\\n                    yield x + i, y + j\\n\\n        def dfs(x, y, index):\\n            res = 0\\n            grid[x][y] = index\\n            for i, j in move(x, y):\\n                if grid[i][j] == 1:\\n                    res += dfs(i, j, index)\\n            return res + 1\\n\\n        # DFS every island and give it an index of island\\n        index = 2\\n        areas = {0: 0}\\n        for x in xrange(N):\\n            for y in xrange(N):\\n                if grid[x][y] == 1:\\n                    areas[index] = dfs(x, y, index)\\n                    index += 1\\n\\n        # traverse every 0 cell and count biggest island it can conntect\\n        res = max(areas.values())\\n        for x in xrange(N):\\n            for y in xrange(N):\\n                if grid[x][y] == 0:\\n                    possible = set(grid[i][j] for i, j in move(x, y))\\n                    res = max(res, sum(areas[index] for index in possible) + 1)\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```cpp\\n    int N;\\n    int largestIsland(vector<vector<int>>& grid) {\\n        N = grid.size();\\n        //DFS every island and give it an index of island\\n        int index = 2, res = 0;\\n        unordered_map <int, int>area;\\n        for (int x = 0; x < N; ++x) {\\n            for (int y = 0; y < N; ++y) {\\n                if (grid[x][y] == 1) {\\n                    area[index] = dfs(grid, x, y, index);\\n                    res = max(res, area[index++]);\\n                }\\n            }\\n        }\\n        //traverse every 0 cell and count biggest island it can conntect\\n        for (int x = 0; x < N; ++x)\\n            for (int y = 0; y < N; ++y)\\n                if (grid[x][y] == 0) {\\n                    unordered_set<int> seen = {};\\n                    int cur = 1;\\n                    for (auto p : move(x, y)) {\\n                        index = grid[p.first][p.second];\\n                        if (index > 1 && seen.count(index) == 0) {\\n                            seen.insert(index);\\n                            cur += area[index];\\n                        }\\n                    }\\n                    res = max(res, cur);\\n                }\\n        return res;\\n    }\\n\\n    vector<pair<int, int>> move(int x, int y) {\\n        vector<pair<int, int>> res;\\n        for (auto p : vector<vector<int>> {{1, 0}, { -1, 0}, {0, 1}, {0, -1}}) {\\n            if (valid(x + p[0], y + p[1]))\\n                res.push_back(make_pair(x + p[0], y + p[1]));\\n        }\\n        return res;\\n    }\\n\\n    int valid(int x, int y) {\\n        return 0 <= x && x < N && 0 <= y && y < N;\\n    }\\n\\n    int dfs(vector<vector<int>>& grid, int x, int y, int index) {\\n        int area = 0;\\n        grid[x][y] = index;\\n        for (auto p : move(x, y))\\n            if (grid[p.first][p.second] == 1)\\n                area += dfs(grid, p.first, p.second, index);\\n        return area + 1;\\n    }\\n```\n```java\\nimport javafx.util.Pair;\\nclass Solution {\\n    public int N = 0;\\n    public int largestIsland(int[][] grid) {\\n        N = grid.length;\\n        //DFS every island and give it an index of island\\n        int index = 3, res = 0;\\n        HashMap<Integer, Integer> area = new HashMap<>();\\n        for (int x = 0; x < N; ++x) for (int y = 0; y < N; ++y)\\n            if (grid[x][y] == 1) {\\n                area.put(index, dfs(grid, x, y, index));\\n                res = Math.max(res, area.get(index++));\\n            }\\n\\n        //traverse every 0 cell and count biggest island it can conntect\\n        for (int x = 0; x < N; ++x) for (int y = 0; y < N; ++y)\\n            if (grid[x][y] == 0) {\\n                HashSet<Integer> seen = new HashSet<>();\\n                int cur = 1;\\n                for (Pair<Integer, Integer> p : move(x, y)) {\\n                    index = grid[p.getKey()][p.getValue()];\\n                    if (index > 1 && !seen.contains(index)) {\\n                        seen.add(index);\\n                        cur += area.get(index);\\n                    }\\n                }\\n                res = Math.max(res, cur);\\n            }\\n        return res;\\n    }\\n\\n    public List <Pair<Integer, Integer>> move(int x, int y) {\\n        ArrayList <Pair<Integer, Integer>> res = new ArrayList<>();\\n        if (valid(x, y + 1)) res.add(new Pair<Integer, Integer>(x, y + 1));\\n        if (valid(x, y - 1)) res.add(new Pair<Integer, Integer>(x, y - 1));\\n        if (valid(x + 1, y)) res.add(new Pair<Integer, Integer>(x + 1, y));\\n        if (valid(x - 1, y)) res.add(new Pair<Integer, Integer>(x - 1, y));\\n        return res;\\n    }\\n\\n    public boolean valid(int x, int y) {\\n        return 0 <= x && x < N && 0 <= y && y < N;\\n    }\\n\\n    public int dfs(int[][] grid, int x, int y, int index) {\\n        int area = 0;\\n        grid[x][y] = index;\\n        for (Pair<Integer, Integer> p : move(x, y))\\n            if (grid[p.getKey()][p.getValue()] == 1)\\n                area += dfs(grid, p.getKey(), p.getValue(), index);\\n        return area + 1;\\n    }\\n}\\n\\n\\n```\n```py\\n    def largestIsland(self, grid):\\n        N = len(grid)\\n\\n        def move(x, y):\\n            for i, j in ((1, 0), (-1, 0), (0, 1), (0, -1)):\\n                if 0 <= x + i < N and 0 <= y + j < N:\\n                    yield x + i, y + j\\n\\n        def dfs(x, y, index):\\n            res = 0\\n            grid[x][y] = index\\n            for i, j in move(x, y):\\n                if grid[i][j] == 1:\\n                    res += dfs(i, j, index)\\n            return res + 1\\n\\n        # DFS every island and give it an index of island\\n        index = 2\\n        areas = {0: 0}\\n        for x in xrange(N):\\n            for y in xrange(N):\\n                if grid[x][y] == 1:\\n                    areas[index] = dfs(x, y, index)\\n                    index += 1\\n\\n        # traverse every 0 cell and count biggest island it can conntect\\n        res = max(areas.values())\\n        for x in xrange(N):\\n            for y in xrange(N):\\n                if grid[x][y] == 0:\\n                    possible = set(grid[i][j] for i, j in move(x, y))\\n                    res = max(res, sum(areas[index] for index in possible) + 1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1375992,
                "title": "c-python-dfs-paint-different-colors-union-find-solutions-with-picture-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: DFS - Paint different connected components by different colors**\\n- The idea is that we `dfs` to paint different connected components by different colors, we gonna paint in-place on the `grid` matrix, so we start color from `2`, because `0` and `1` is already existed in the `grid`.\\n- We need a counter, let `componentSize[color]` be the size of connected component corresponding to `color`.\\n- Iterate over rows and columns in the matrix again, this time we calculate the new size that can be formed if we turn `matrix[r][c] from 0 into 1`, that is:\\n\\t- If `matrix[r][c] == 0` then:\\n\\t\\t- Get color ids of landing neighboring cells to calculate component size. (We get unique color ids to avoid calculating the size of 2 connected component two times)\\n\\t\\t- Calculate total size can be formed.\\n\\t\\t- Update the largest size can be formed so far to our answer.\\n\\n![image](https://assets.leetcode.com/users/images/2292c663-4a43-47c5-a9bb-b88b148b152f_1627963871.547048.png)\\n\\n\\n<iframe src=\"https://leetcode.com/playground/ehtZaxpn/shared\" frameBorder=\"0\" width=\"100%\" height=\"710\"></iframe>\\n\\n**Complexity**\\n- Time: `O(M * N)`, where `M <= 500` is number of rows, `N <= 500` is number of columns in the matrix.\\n- Space: `O(M * N)`\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 2: Uninon-Find**\\n- A **Union-Find** is a really good data structure to store the connected components with their respective sizes.\\n- Iterate over rows and columns in the matrix, if a cell `matrix[r][c] == 1` then we connect that cell with its landing neighboring cells by using **Union-Find**.\\n- Iterate over rows and columns in the matrix again, this time we calculate the new size that can be formed if we turn `matrix[r][c] from 0 into 1`, that is:\\n\\t- If `matrix[r][c] == 0` then:\\n\\t\\t- Get unique parent ids of landing neighboring cells to calculate component size. (We get unique parent ids to avoid calculating the size of 2 connected component two times)\\n\\t\\t- Calculate total size can be formed.\\n\\t\\t- Update the largest size can be formed so far to our answer.\\n- There is a simillar problem with this problem: [305. Number of Islands II](https://leetcode.com/problems/number-of-islands-ii/)\\n```\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parent = [-1] * n\\n        self.size = [0] * n\\n    def isExist(self, u):\\n        return self.parent[u] >= 0\\n    def add(self, u):\\n        if self.isExist(u): return  # Only add if not existed yet!\\n        self.parent[u] = u\\n        self.size[u] = 1\\n    def find(self, u):\\n        if self.parent[u] == u: return u\\n        self.parent[u] = self.find(self.parent[u])  # Path compression\\n        return self.parent[u]\\n    def union(self, u, v):\\n        pu, pv = self.find(u), self.find(v)\\n        if pu == pv: return False\\n        if self.size[pu] <= self.size[pv]:  # Merge the smaller component to the bigger component\\n            self.parent[pu] = pv  # Merge u into v\\n            self.size[pv] += self.size[pu]\\n        else:\\n            self.parent[pv] = pu  # Merge v into u\\n            self.size[pu] += self.size[pv]\\n        return True\\n\\nclass Solution:\\n    def largestIsland(self, grid: List[List[int]]) -> int:\\n        DIR = [0, 1, 0, -1, 0]\\n        m, n, ans = len(grid), len(grid[0]), 0\\n        uf = UnionFind(m * n)\\n\\n        def landNeighbors(r, c):\\n            for i in range(4):\\n                nr, nc = r + DIR[i], c + DIR[i + 1]\\n                neiId = nr * n + nc\\n                if nr < 0 or nr == m or nc < 0 or nc == n or not uf.isExist(neiId): continue\\n                yield neiId\\n\\n        for r in range(m):\\n            for c in range(n):\\n                if grid[r][c] == 0: continue\\n                curId = r * n + c\\n                uf.add(curId)\\n                for neiId in landNeighbors(r, c):\\n                    uf.union(curId, neiId)\\n                p = uf.find(curId)\\n                ans = max(ans, uf.size[p])\\n\\n        for r in range(m):\\n            for c in range(n):\\n                if grid[r][c] == 1: continue\\n                neiParents = set()\\n                for neiId in landNeighbors(r, c):\\n                    neiParents.add(uf.find(neiId))\\n                sizeFormed = 1  # Start with 1, which is matrix[r][c] when turning from 0 into 1\\n                for p in neiParents:\\n                    sizeFormed += uf.size[p]\\n                ans = max(ans, sizeFormed)\\n        return ans\\n```\\n**Complexity**\\n- Time: `O(M * N * \\u03B1(M*N)` ~ `O(M * N)`, where `M <= 500` is number of rows, `N <= 500` is number of columns in the matrix.\\n\\tExplanation: Using both **path compression** and **union by size** ensures that the **amortized time** per operation is only `\\u03B1(n)`, which is optimal, where `\\u03B1(n)` is the inverse Ackermann function. This function has a value `\\u03B1(n) < 5` for any value of n that can be written in this physical universe, so the disjoint-set operations take place in essentially constant time.\\nReference: https://en.wikipedia.org/wiki/Disjoint-set_data_structure or https://www.slideshare.net/WeiLi73/time-complexity-of-union-find-55858534 for more information.\\n- Space: `O(M * N)`\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "solutionTags": [],
                "code": "```\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parent = [-1] * n\\n        self.size = [0] * n\\n    def isExist(self, u):\\n        return self.parent[u] >= 0\\n    def add(self, u):\\n        if self.isExist(u): return  # Only add if not existed yet!\\n        self.parent[u] = u\\n        self.size[u] = 1\\n    def find(self, u):\\n        if self.parent[u] == u: return u\\n        self.parent[u] = self.find(self.parent[u])  # Path compression\\n        return self.parent[u]\\n    def union(self, u, v):\\n        pu, pv = self.find(u), self.find(v)\\n        if pu == pv: return False\\n        if self.size[pu] <= self.size[pv]:  # Merge the smaller component to the bigger component\\n            self.parent[pu] = pv  # Merge u into v\\n            self.size[pv] += self.size[pu]\\n        else:\\n            self.parent[pv] = pu  # Merge v into u\\n            self.size[pu] += self.size[pv]\\n        return True\\n\\nclass Solution:\\n    def largestIsland(self, grid: List[List[int]]) -> int:\\n        DIR = [0, 1, 0, -1, 0]\\n        m, n, ans = len(grid), len(grid[0]), 0\\n        uf = UnionFind(m * n)\\n\\n        def landNeighbors(r, c):\\n            for i in range(4):\\n                nr, nc = r + DIR[i], c + DIR[i + 1]\\n                neiId = nr * n + nc\\n                if nr < 0 or nr == m or nc < 0 or nc == n or not uf.isExist(neiId): continue\\n                yield neiId\\n\\n        for r in range(m):\\n            for c in range(n):\\n                if grid[r][c] == 0: continue\\n                curId = r * n + c\\n                uf.add(curId)\\n                for neiId in landNeighbors(r, c):\\n                    uf.union(curId, neiId)\\n                p = uf.find(curId)\\n                ans = max(ans, uf.size[p])\\n\\n        for r in range(m):\\n            for c in range(n):\\n                if grid[r][c] == 1: continue\\n                neiParents = set()\\n                for neiId in landNeighbors(r, c):\\n                    neiParents.add(uf.find(neiId))\\n                sizeFormed = 1  # Start with 1, which is matrix[r][c] when turning from 0 into 1\\n                for p in neiParents:\\n                    sizeFormed += uf.size[p]\\n                ans = max(ans, sizeFormed)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1376070,
                "title": "making-a-large-island-explanation-w-comments-in-code-dfs-bfs",
                "content": "***Solution 1(DFS + BFS):***\\n```\\n# Algorithm:\\nStep 1: Find out all the connected components and assign each component an index.\\nStep 2: While calculating the connected components , also calculate the area for that connected component.\\nStep 3: Use HashMap to store the mapping between component index and its corresponding area.\\nStep 4: Use BFS to find out the max Area by flipping each zero one by one.\\n\\nNOTE:\\n1) Zero can be a part of more than one connected component,\\n2) While calculating the area , dont forget to add 1 to the area because the zero is now flipped to 1,\\nand we have to consider this value also. \\n\\nBelow is the step by step code for the above explanation with comments,\\n```\\n***\\n**C++:**\\n```\\nclass Solution {\\n\\n// As 0,1 already occupied in matrix so we need to start with index = 2;\\nint idx=2;\\n\\n// HashMap to have mapping between the connected component index and its area\\nunordered_map<int,int> mp;\\n\\n// 4 directions to find out connected 1s\\nvector<pair<int,int>> direction{{1,0},{-1,0},{0,1},{0,-1}};\\n\\n// Globally declaring the area variable which will store the max area\\nint area = 0;\\n\\n// Simple DFS method for assigning connected components an index.\\nvoid dfs(int i,int j,vector<vector<int>> &grid)\\n{\\n    if(i<0 or i>=size(grid) or j<0 or j>=size(grid) or grid[i][j]!=1)\\n        return;\\n    mp[idx]++;\\n    grid[i][j]=idx;\\n    for(auto dir:direction)\\n    {\\n        dfs(i+dir.first,j+dir.second,grid);\\n    }\\n}\\n\\n// Method to mark all the connected components.\\nvoid markAllTheConnectedComponents(vector<vector<int>>& grid)\\n{\\n    int n=size(grid);\\n    mp.clear();\\n    idx=2;\\n    for(int i=0;i<n;i++)\\n    {\\n        for(int j=0;j<n;j++)\\n        {\\n            if(grid[i][j])\\n            {\\n                dfs(i,j,grid);\\n            // Here we are handling the situation when there is no 0 in the matrix.\\n                area=max(area,mp[idx]);\\n                idx++;\\n            }\\n        }\\n    }\\n}\\n\\n// Method to find out the max area in case of any 0 to be flipped.\\nvoid findMaxArea(vector<vector<int>>& grid)\\n{\\n    int n=size(grid);\\n    queue<pair<int,int>> q;\\n    \\n//     Push all the {i,j} where grid[i][j]==0 in queue.\\n    for(int i=0;i<n;i++)\\n    {\\n        for(int j=0;j<n;j++)\\n        {\\n            if(grid[i][j]==0)\\n            {\\n                q.push({i,j});\\n            }\\n        }\\n    }\\n\\n    auto isValid = [&](int i,int j){\\n        return (i>=0 and i<n and j>=0 and j<n and grid[i][j]!=0);\\n    };\\n\\n    while(!q.empty())\\n    {\\n        auto front = q.front();\\n        q.pop();\\n        int i = front.first;\\n        int j = front.second;\\n        \\n        unordered_set<int> vis;\\n        int curr = 0;\\n        for(auto dir:direction)\\n        {\\n            int newi = i+dir.first;\\n            int newj = j+dir.second;\\n            \\n            if(isValid(newi,newj) and !vis.count(grid[newi][newj]))\\n            {\\n                vis.insert(grid[newi][newj]);\\n                curr += mp[grid[newi][newj]];\\n            }\\n        }\\n//         its curr+1, why? because we need to consider the flipped 0 also.\\n        area = max(curr+1,area);\\n    }\\n}\\n\\n\\npublic:\\n    int largestIsland(vector<vector<int>>& grid) \\n    {\\n//         Step 1: Mark all the connected componentes with index.\\n        markAllTheConnectedComponents(grid);\\n//         Step 2: Do BFS to find which 0 flip will result in the larger area.\\n        findMaxArea(grid);\\n        return area;\\n    }\\n};\\n```\\n***\\n**If you found the post useful, do consider it for upvotes.\\uD83D\\uDE0A**\\n***",
                "solutionTags": [],
                "code": "```\\n# Algorithm:\\nStep 1: Find out all the connected components and assign each component an index.\\nStep 2: While calculating the connected components , also calculate the area for that connected component.\\nStep 3: Use HashMap to store the mapping between component index and its corresponding area.\\nStep 4: Use BFS to find out the max Area by flipping each zero one by one.\\n\\nNOTE:\\n1) Zero can be a part of more than one connected component,\\n2) While calculating the area , dont forget to add 1 to the area because the zero is now flipped to 1,\\nand we have to consider this value also. \\n\\nBelow is the step by step code for the above explanation with comments,\\n```\n```\\nclass Solution {\\n\\n// As 0,1 already occupied in matrix so we need to start with index = 2;\\nint idx=2;\\n\\n// HashMap to have mapping between the connected component index and its area\\nunordered_map<int,int> mp;\\n\\n// 4 directions to find out connected 1s\\nvector<pair<int,int>> direction{{1,0},{-1,0},{0,1},{0,-1}};\\n\\n// Globally declaring the area variable which will store the max area\\nint area = 0;\\n\\n// Simple DFS method for assigning connected components an index.\\nvoid dfs(int i,int j,vector<vector<int>> &grid)\\n{\\n    if(i<0 or i>=size(grid) or j<0 or j>=size(grid) or grid[i][j]!=1)\\n        return;\\n    mp[idx]++;\\n    grid[i][j]=idx;\\n    for(auto dir:direction)\\n    {\\n        dfs(i+dir.first,j+dir.second,grid);\\n    }\\n}\\n\\n// Method to mark all the connected components.\\nvoid markAllTheConnectedComponents(vector<vector<int>>& grid)\\n{\\n    int n=size(grid);\\n    mp.clear();\\n    idx=2;\\n    for(int i=0;i<n;i++)\\n    {\\n        for(int j=0;j<n;j++)\\n        {\\n            if(grid[i][j])\\n            {\\n                dfs(i,j,grid);\\n            // Here we are handling the situation when there is no 0 in the matrix.\\n                area=max(area,mp[idx]);\\n                idx++;\\n            }\\n        }\\n    }\\n}\\n\\n// Method to find out the max area in case of any 0 to be flipped.\\nvoid findMaxArea(vector<vector<int>>& grid)\\n{\\n    int n=size(grid);\\n    queue<pair<int,int>> q;\\n    \\n//     Push all the {i,j} where grid[i][j]==0 in queue.\\n    for(int i=0;i<n;i++)\\n    {\\n        for(int j=0;j<n;j++)\\n        {\\n            if(grid[i][j]==0)\\n            {\\n                q.push({i,j});\\n            }\\n        }\\n    }\\n\\n    auto isValid = [&](int i,int j){\\n        return (i>=0 and i<n and j>=0 and j<n and grid[i][j]!=0);\\n    };\\n\\n    while(!q.empty())\\n    {\\n        auto front = q.front();\\n        q.pop();\\n        int i = front.first;\\n        int j = front.second;\\n        \\n        unordered_set<int> vis;\\n        int curr = 0;\\n        for(auto dir:direction)\\n        {\\n            int newi = i+dir.first;\\n            int newj = j+dir.second;\\n            \\n            if(isValid(newi,newj) and !vis.count(grid[newi][newj]))\\n            {\\n                vis.insert(grid[newi][newj]);\\n                curr += mp[grid[newi][newj]];\\n            }\\n        }\\n//         its curr+1, why? because we need to consider the flipped 0 also.\\n        area = max(curr+1,area);\\n    }\\n}\\n\\n\\npublic:\\n    int largestIsland(vector<vector<int>>& grid) \\n    {\\n//         Step 1: Mark all the connected componentes with index.\\n        markAllTheConnectedComponents(grid);\\n//         Step 2: Do BFS to find which 0 flip will result in the larger area.\\n        findMaxArea(grid);\\n        return area;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 127256,
                "title": "dfs-java-ac-concise-solution",
                "content": "My idea is similar to the problem: number of islands\\n\\n```\\nclass Solution {\\n    public int largestIsland(int[][] grid) {\\n        int max = 0, m = grid.length, n = grid[0].length;\\n        boolean hasZero = false; //To check if there is any zero in the grid\\n        for(int i = 0; i < grid.length; i++){\\n            for(int j = 0;j<grid[0].length;j++){\\n                if(grid[i][j] == 0){\\n                    grid[i][j] = 1;\\n                    max = Math.max(max,dfs(i,j,grid,new boolean[m][n]));   \\n                    if(max == m*n) return max;\\n                    grid[i][j] = 0;\\n                    hasZero = true;\\n                }\\n            }\\n        }\\n        return hasZero?max:m*n;\\n    }\\n    private int dfs(int i, int j, int[][] grid,boolean[][] visited){\\n        if(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] == 0||visited[i][j]) return 0;\\n        visited[i][j] = true;\\n        int result = 1+dfs(i-1,j,grid,visited)+dfs(i+1,j,grid,visited)+dfs(i,j+1,grid,visited)+dfs(i,j-1,grid,visited);\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int largestIsland(int[][] grid) {\\n        int max = 0, m = grid.length, n = grid[0].length;\\n        boolean hasZero = false; //To check if there is any zero in the grid\\n        for(int i = 0; i < grid.length; i++){\\n            for(int j = 0;j<grid[0].length;j++){\\n                if(grid[i][j] == 0){\\n                    grid[i][j] = 1;\\n                    max = Math.max(max,dfs(i,j,grid,new boolean[m][n]));   \\n                    if(max == m*n) return max;\\n                    grid[i][j] = 0;\\n                    hasZero = true;\\n                }\\n            }\\n        }\\n        return hasZero?max:m*n;\\n    }\\n    private int dfs(int i, int j, int[][] grid,boolean[][] visited){\\n        if(i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] == 0||visited[i][j]) return 0;\\n        visited[i][j] = true;\\n        int result = 1+dfs(i-1,j,grid,visited)+dfs(i+1,j,grid,visited)+dfs(i,j+1,grid,visited)+dfs(i,j-1,grid,visited);\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1375940,
                "title": "python-dfs-with-connected-components-explained",
                "content": "What we need to do is to find all islands first (very similar to **0694** Number of Distinct Islands), we can do it in place: for each island we rewrite it with its number (we start enumerate from `2`, because `0` and `1` already reserved), also we evaluate size of each island in `island` Counter. Then we need to traverse our grid once again and for each empty cell check four neighbors: and create set off all unique islands (it can happen that for example left neighbor and upper neighbor are the same island). Then we evaluate sum of sizes of all neighbours and choose the biggest one.\\n\\n#### Complexity\\nTime complexity is `O(n*m)`, because we traverse our graph twice: one with `dfs` and another when we were looking for empty cells. Space complxity is potentially `O(n*m)` as well.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def largestIsland(self, grid):\\n        m, n = len(grid), len(grid[0])\\n        neib_list = [[1,0],[-1,0],[0,-1],[0,1]]\\n        islands, count, ans = Counter(), 2, 0\\n        \\n        def dfs(t, i, j):\\n            if not 0 <= i < m or not 0 <= j < n or grid[i][j] != 1: return\\n            islands[t] += 1\\n            grid[i][j] = t\\n            for x, y in neib_list: dfs(t, x+i, y+j)\\n                \\n        for x, y in product(range(m), range(n)):\\n            if grid[x][y] == 1:\\n                dfs(count, x, y)\\n                count += 1\\n                \\n        for x, y in product(range(m), range(n)):\\n            if grid[x][y] != 0: continue\\n            neibs = set()\\n            for dx, dy in neib_list:\\n                if 0 <= x + dx < m and 0 <= y + dy < n and grid[x+dx][y+dy] != 0:\\n                    neibs.add(grid[x+dx][y+dy])\\n            ans = max(ans, sum(islands[i] for i in neibs) + 1)\\n            \\n        return ans if ans != 0 else m*n\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def largestIsland(self, grid):\\n        m, n = len(grid), len(grid[0])\\n        neib_list = [[1,0],[-1,0],[0,-1],[0,1]]\\n        islands, count, ans = Counter(), 2, 0\\n        \\n        def dfs(t, i, j):\\n            if not 0 <= i < m or not 0 <= j < n or grid[i][j] != 1: return\\n            islands[t] += 1\\n            grid[i][j] = t\\n            for x, y in neib_list: dfs(t, x+i, y+j)\\n                \\n        for x, y in product(range(m), range(n)):\\n            if grid[x][y] == 1:\\n                dfs(count, x, y)\\n                count += 1\\n                \\n        for x, y in product(range(m), range(n)):\\n            if grid[x][y] != 0: continue\\n            neibs = set()\\n            for dx, dy in neib_list:\\n                if 0 <= x + dx < m and 0 <= y + dy < n and grid[x+dx][y+dy] != 0:\\n                    neibs.add(grid[x+dx][y+dy])\\n            ans = max(ans, sum(islands[i] for i in neibs) + 1)\\n            \\n        return ans if ans != 0 else m*n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 127980,
                "title": "java-solution-using-union-find",
                "content": "```\\nclass Solution {\\n    public int largestIsland(int[][] grid) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        \\n        // create father array and size array, and initialize them\\n        int[] father = new int[rows * cols];\\n        for (int i = 0; i < rows * cols; i++) {\\n            father[i] = i;\\n        }\\n        int[] size = new int[rows * cols];\\n        Arrays.fill(size, 1);\\n        \\n        int[] dx = {0, 1, -1, 0};\\n        int[] dy = {1, 0, 0, -1};\\n        \\n        // scan grid, update father array and size array\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                if (grid[i][j] == 1) {\\n                    int id = i * cols + j;\\n                    for (int k = 0; k < 4; k++) {\\n                        int newi = i + dx[k];\\n                        int newj = j + dy[k];\\n                        int newid = newi * cols + newj;\\n                        if (isValid(rows, cols, newi, newj) && grid[newi][newj] == 1) {\\n                            union(father, size, id, newid);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // find current max component size\\n        int max = 0;\\n        for (int i = 0; i < size.length; i++) {\\n            max = Math.max(max, size[i]);\\n        }\\n        \\n        // find max component size if we set any 0 to 1\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                if (grid[i][j] == 0) {\\n                    int id = i * cols + j;\\n                    int combinedSize = 1;\\n                    Set<Integer> prevFather = new HashSet<>();\\n                    for (int k = 0; k < 4; k++) {\\n                        int newi = i + dx[k];\\n                        int newj = j + dy[k];\\n                        int newid = newi * cols + newj;\\n                        if (isValid(rows, cols, newi, newj) && grid[newi][newj] == 1) { \\n                            int currFather = find(father, newid);\\n                            if (prevFather.isEmpty() || !prevFather.contains(currFather)) {\\n                                combinedSize += size[currFather];\\n                                prevFather.add(currFather);\\n                            }\\n                        }\\n                    }\\n                    max = Math.max(max, combinedSize);\\n                }\\n            }\\n        }\\n        \\n        // return whole size if the grid is an all 1 matrix, otherwise return the value of max\\n        return max == 0 ? rows * cols : max;\\n    }\\n    \\n    public int find(int[] father, int id) {\\n        if (father[id] == id) {\\n            return id;\\n        }\\n        return father[id] = find(father, father[id]);\\n    }\\n    \\n    public void union(int[] father, int[] size, int id1, int id2) {\\n        int fa1 = find(father, id1);\\n        int fa2 = find(father, id2);\\n        if (fa1 != fa2) {\\n            father[fa1] = fa2;\\n            size[fa2] += size[fa1];\\n        }\\n    }\\n    \\n    public boolean isValid(int rows, int cols, int i, int j) {\\n        if (i >= 0 && i < rows && j >= 0 && j < cols) {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int largestIsland(int[][] grid) {\\n        int rows = grid.length;\\n        int cols = grid[0].length;\\n        \\n        // create father array and size array, and initialize them\\n        int[] father = new int[rows * cols];\\n        for (int i = 0; i < rows * cols; i++) {\\n            father[i] = i;\\n        }\\n        int[] size = new int[rows * cols];\\n        Arrays.fill(size, 1);\\n        \\n        int[] dx = {0, 1, -1, 0};\\n        int[] dy = {1, 0, 0, -1};\\n        \\n        // scan grid, update father array and size array\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                if (grid[i][j] == 1) {\\n                    int id = i * cols + j;\\n                    for (int k = 0; k < 4; k++) {\\n                        int newi = i + dx[k];\\n                        int newj = j + dy[k];\\n                        int newid = newi * cols + newj;\\n                        if (isValid(rows, cols, newi, newj) && grid[newi][newj] == 1) {\\n                            union(father, size, id, newid);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // find current max component size\\n        int max = 0;\\n        for (int i = 0; i < size.length; i++) {\\n            max = Math.max(max, size[i]);\\n        }\\n        \\n        // find max component size if we set any 0 to 1\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                if (grid[i][j] == 0) {\\n                    int id = i * cols + j;\\n                    int combinedSize = 1;\\n                    Set<Integer> prevFather = new HashSet<>();\\n                    for (int k = 0; k < 4; k++) {\\n                        int newi = i + dx[k];\\n                        int newj = j + dy[k];\\n                        int newid = newi * cols + newj;\\n                        if (isValid(rows, cols, newi, newj) && grid[newi][newj] == 1) { \\n                            int currFather = find(father, newid);\\n                            if (prevFather.isEmpty() || !prevFather.contains(currFather)) {\\n                                combinedSize += size[currFather];\\n                                prevFather.add(currFather);\\n                            }\\n                        }\\n                    }\\n                    max = Math.max(max, combinedSize);\\n                }\\n            }\\n        }\\n        \\n        // return whole size if the grid is an all 1 matrix, otherwise return the value of max\\n        return max == 0 ? rows * cols : max;\\n    }\\n    \\n    public int find(int[] father, int id) {\\n        if (father[id] == id) {\\n            return id;\\n        }\\n        return father[id] = find(father, father[id]);\\n    }\\n    \\n    public void union(int[] father, int[] size, int id1, int id2) {\\n        int fa1 = find(father, id1);\\n        int fa2 = find(father, id2);\\n        if (fa1 != fa2) {\\n            father[fa1] = fa2;\\n            size[fa2] += size[fa1];\\n        }\\n    }\\n    \\n    public boolean isValid(int rows, int cols, int i, int j) {\\n        if (i >= 0 && i < rows && j >= 0 && j < cols) {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1376435,
                "title": "making-a-large-island-detailed-explanation-java",
                "content": "**Intuition**\\n* The idea is to find all the distinct regions(islands) in the grid. We name these regions with a number starting from `2` (Since `0`,`1` are reserved for the grid). Then we apply the flood fill algorithm with the regions.\\n* While applying flood fill algorithm we need to also get the area of the region and store it. So we can use a map to get area of any region.\\n* Once we have marked all the regions what should we do. The problem we have to solve now is merge multiple islands if there is just one `0` separating these.\\n* So we have to iterate over all the `0`s and check the distinct neighbors. Now all these neighbors will become one island if we flip this `0` to `1`. So we add the area for all the neighbors.\\n* If this area is greater than the max area, we update the max.\\n\\n```\\nclass Solution {\\n    public int largestIsland(int[][] grid) {\\n        Map<Integer, Integer> regionsArea = new HashMap<>();\\n        regionsArea.put(0,0);\\n        \\n        int n = grid.length;\\n        int region = 2;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1){\\n                    int area = floodFill(grid, i, j, region);\\n                    regionsArea.put(region, area);\\n                    region++;\\n                }\\n            }\\n        }\\n        \\n        int max = regionsArea.getOrDefault(2,0);\\n        for(int r=0;r<n;r++){\\n            for(int c=0;c<n;c++){\\n                if(grid[r][c]==0){\\n                    Set<Integer> neighbors = new HashSet<>();\\n                    neighbors.add(r>0?grid[r-1][c]:0);\\n                    neighbors.add(c>0?grid[r][c-1]:0);\\n                    neighbors.add(r<n-1?grid[r+1][c]:0);\\n                    neighbors.add(c<n-1?grid[r][c+1]:0);\\n                    int area = 1;\\n                    for(int neighbor: neighbors){\\n                        area+=regionsArea.get(neighbor);\\n                    }\\n                    if(area>max){\\n                        max = area;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return max;\\n    }\\n    \\n    public int floodFill(int[][] grid, int r, int c, int region) {\\n        int n = grid.length;\\n        if(r<0||r>=n||c<0||c>=n||grid[r][c]!=1){\\n            return 0;\\n        }\\n        \\n        grid[r][c] = region;\\n        \\n        int sum = 1;\\n        sum+=floodFill(grid, r, c+1, region);\\n        sum+=floodFill(grid, r+1, c, region);\\n        sum+=floodFill(grid, r, c-1, region);\\n        sum+=floodFill(grid, r-1, c, region);\\n        \\n        return sum;\\n    }\\n}\\n```\\n\\n**Please upvote if this solution helps you so that it can reach others. Cheers :)**",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int largestIsland(int[][] grid) {\\n        Map<Integer, Integer> regionsArea = new HashMap<>();\\n        regionsArea.put(0,0);\\n        \\n        int n = grid.length;\\n        int region = 2;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1){\\n                    int area = floodFill(grid, i, j, region);\\n                    regionsArea.put(region, area);\\n                    region++;\\n                }\\n            }\\n        }\\n        \\n        int max = regionsArea.getOrDefault(2,0);\\n        for(int r=0;r<n;r++){\\n            for(int c=0;c<n;c++){\\n                if(grid[r][c]==0){\\n                    Set<Integer> neighbors = new HashSet<>();\\n                    neighbors.add(r>0?grid[r-1][c]:0);\\n                    neighbors.add(c>0?grid[r][c-1]:0);\\n                    neighbors.add(r<n-1?grid[r+1][c]:0);\\n                    neighbors.add(c<n-1?grid[r][c+1]:0);\\n                    int area = 1;\\n                    for(int neighbor: neighbors){\\n                        area+=regionsArea.get(neighbor);\\n                    }\\n                    if(area>max){\\n                        max = area;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return max;\\n    }\\n    \\n    public int floodFill(int[][] grid, int r, int c, int region) {\\n        int n = grid.length;\\n        if(r<0||r>=n||c<0||c>=n||grid[r][c]!=1){\\n            return 0;\\n        }\\n        \\n        grid[r][c] = region;\\n        \\n        int sum = 1;\\n        sum+=floodFill(grid, r, c+1, region);\\n        sum+=floodFill(grid, r+1, c, region);\\n        sum+=floodFill(grid, r, c-1, region);\\n        sum+=floodFill(grid, r-1, c, region);\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 126960,
                "title": "extremely-simple-concept-using-marker",
                "content": "Mark all the Connected Components in the grid using a distinct Integer marker. \\n\\nKeep the count of the marker in the grid using a HashMap. \\n\\nFor each zero check the distinct islands that get connected. \\n\\nex: \\n\\n101\\n000\\n011\\n\\nusing Marker\\nGrid : \\n203\\n000\\n044\\n\\nMap : \\n2 : 1\\n3 : 1\\n4 : 2\\n\\nNow for each zero, check the distinct marker it connects. \\nThe zero in the 2nd row last column connects marker 3 and 4. \\n\\nHence the counts becomes maximum = 2 (count of 4) + 1 (count of 3) + 1(The zero that is converted to 1). \\n\\nHope this helps. \\n\\n```\\nclass Solution {\\n    public int dfs(int[][]grid, int i, int j , int marker){\\n        int count = 0 ;\\n        if(i<0 || j <0 || i >= grid.length || j >= grid[0].length || grid[i][j] != 1)return count; \\n        grid[i][j] = marker; \\n        count++; \\n        count += dfs(grid, i-1, j, marker) + dfs(grid, i+1, j, marker) +dfs(grid, i, j-1, marker) +dfs(grid, i, j+1, marker); \\n        return count; \\n    }\\n    \\n    public int calc(int[][] grid, int i, int j, Map<Integer, Integer> map){\\n        int count = 0; \\n        Set<Integer> set = new HashSet<>(); \\n        for(int x = Math.max(0, i-1); x <= Math.min(grid.length-1, i+1); ++x){\\n            for(int y = Math.max(0, j-1); y<=Math.min(grid[0].length-1, j+1); ++y){\\n                if(x == i && y == j)continue; \\n\\t\\t\\t\\t\\t\\t\\t\\t// Continue if its the diagonal elements\\n                if((x==i-1 && y==j-1) || (x==i+1 && y==j+1) || (x==i+1 && y==j-1) || (x==i-1 && y==j+1))continue; \\n                if(grid[x][y]!=0 && !set.contains(grid[x][y]))count+=map.get(grid[x][y]);\\n                set.add(grid[x][y]); \\n            }\\n        }\\n        return count+1; \\n    }\\n    \\n    public int largestIsland(int[][] grid) {\\n        int marker = 2;\\n        if(grid == null || grid.length < 1)return 0; \\n        int max = 0; \\n        Map<Integer, Integer> map = new HashMap<>(); \\n        for(int i = 0 ; i < grid.length ; ++i){\\n            for(int j = 0 ; j < grid[0].length ; ++j){\\n                if(grid[i][j] == 1){\\n                    int count = dfs(grid, i, j, marker++); \\n                    map.put(marker-1, count);\\n                    max = Math.max(max, count); \\n                }\\n            }\\n        }\\n        for(int i = 0 ; i < grid.length; ++i){\\n            for(int j = 0 ; j < grid[0].length ; ++j){\\n                if(grid[i][j] == 0){\\n                    max = Math.max(max, calc(grid, i, j, map ));\\n                }\\n            }\\n        }\\n        return max; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int dfs(int[][]grid, int i, int j , int marker){\\n        int count = 0 ;\\n        if(i<0 || j <0 || i >= grid.length || j >= grid[0].length || grid[i][j] != 1)return count; \\n        grid[i][j] = marker; \\n        count++; \\n        count += dfs(grid, i-1, j, marker) + dfs(grid, i+1, j, marker) +dfs(grid, i, j-1, marker) +dfs(grid, i, j+1, marker); \\n        return count; \\n    }\\n    \\n    public int calc(int[][] grid, int i, int j, Map<Integer, Integer> map){\\n        int count = 0; \\n        Set<Integer> set = new HashSet<>(); \\n        for(int x = Math.max(0, i-1); x <= Math.min(grid.length-1, i+1); ++x){\\n            for(int y = Math.max(0, j-1); y<=Math.min(grid[0].length-1, j+1); ++y){\\n                if(x == i && y == j)continue; \\n\\t\\t\\t\\t\\t\\t\\t\\t// Continue if its the diagonal elements\\n                if((x==i-1 && y==j-1) || (x==i+1 && y==j+1) || (x==i+1 && y==j-1) || (x==i-1 && y==j+1))continue; \\n                if(grid[x][y]!=0 && !set.contains(grid[x][y]))count+=map.get(grid[x][y]);\\n                set.add(grid[x][y]); \\n            }\\n        }\\n        return count+1; \\n    }\\n    \\n    public int largestIsland(int[][] grid) {\\n        int marker = 2;\\n        if(grid == null || grid.length < 1)return 0; \\n        int max = 0; \\n        Map<Integer, Integer> map = new HashMap<>(); \\n        for(int i = 0 ; i < grid.length ; ++i){\\n            for(int j = 0 ; j < grid[0].length ; ++j){\\n                if(grid[i][j] == 1){\\n                    int count = dfs(grid, i, j, marker++); \\n                    map.put(marker-1, count);\\n                    max = Math.max(max, count); \\n                }\\n            }\\n        }\\n        for(int i = 0 ; i < grid.length; ++i){\\n            for(int j = 0 ; j < grid[0].length ; ++j){\\n                if(grid[i][j] == 0){\\n                    max = Math.max(max, calc(grid, i, j, map ));\\n                }\\n            }\\n        }\\n        return max; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 593202,
                "title": "c-dfs-bfs-easy-understand",
                "content": "My idea is to perform a DFS on the grid and find the area of each island. To differentiate each island we will assign a unique value which is variable  ```k``` in our case. After finding all the islands and their areas, we will push the ```0\\'s``` in the queue. From each 0, we will start a bfs of size 1 and check the number of islands present in the vicinity of this 0. With each check, we will update our ```area``` variable which denotes the max area connected.\\n\\n```\\nclass Solution {\\npublic:\\n    int k=2;\\n    unordered_map<int,int> mp;\\n    int dx[4]={1,-1,0,0};\\n    int dy[4]={0,0,1,-1};\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        k=2;\\n        mp.clear();\\n        int area=0;        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]){\\n                    dfs(grid,i,j);\\n\\t\\t\\t\\t\\t// We have to find the largest island in case there are no 0\\'s in the grid\\n                    area=max(area,mp[k]);\\n                    k++;\\n                }\\n           }\\n        }\\n        queue<pair<int,int>> q;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==0)\\n                    q.push({i,j});\\n            }\\n        }\\n        while(!q.empty()){\\n            auto p=q.front();\\n            q.pop();\\n            int x=p.first;\\n            int y=p.second;\\n\\t\\t\\t// Unordered Set to make sure the islands are unique\\n            unordered_set<int> s;\\n            int tmp=0;\\n            for(int i=0;i<4;i++){\\n                int xx=dx[i]+x;\\n                int yy=dy[i]+y;\\n                if(xx<0||yy<0||xx>=m||yy>=n)    continue;\\n                if(grid[xx][yy]==0)     continue;\\n                int val=grid[xx][yy];\\n                if(s.find(val)==s.end()){\\n                    s.insert(val);\\n                    tmp+=mp[val];\\n                }\\n            }\\n            area=max(area,tmp+1);\\n        }\\n        return area;\\n    }\\n    \\n    void dfs(vector<vector<int>> &grid, int i, int j){\\n        if(i<0||j<0||i>=grid.size()||j>=grid[0].size())\\n            return;\\n        if(grid[i][j]!=1)\\n            return;\\n        mp[k]++;\\n        grid[i][j]=k;\\n        dfs(grid,i+1,j);\\n        dfs(grid,i-1,j);\\n        dfs(grid,i,j+1);\\n        dfs(grid,i,j-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```k```\n```0\\'s```\n```area```\n```\\nclass Solution {\\npublic:\\n    int k=2;\\n    unordered_map<int,int> mp;\\n    int dx[4]={1,-1,0,0};\\n    int dy[4]={0,0,1,-1};\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        k=2;\\n        mp.clear();\\n        int area=0;        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]){\\n                    dfs(grid,i,j);\\n\\t\\t\\t\\t\\t// We have to find the largest island in case there are no 0\\'s in the grid\\n                    area=max(area,mp[k]);\\n                    k++;\\n                }\\n           }\\n        }\\n        queue<pair<int,int>> q;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==0)\\n                    q.push({i,j});\\n            }\\n        }\\n        while(!q.empty()){\\n            auto p=q.front();\\n            q.pop();\\n            int x=p.first;\\n            int y=p.second;\\n\\t\\t\\t// Unordered Set to make sure the islands are unique\\n            unordered_set<int> s;\\n            int tmp=0;\\n            for(int i=0;i<4;i++){\\n                int xx=dx[i]+x;\\n                int yy=dy[i]+y;\\n                if(xx<0||yy<0||xx>=m||yy>=n)    continue;\\n                if(grid[xx][yy]==0)     continue;\\n                int val=grid[xx][yy];\\n                if(s.find(val)==s.end()){\\n                    s.insert(val);\\n                    tmp+=mp[val];\\n                }\\n            }\\n            area=max(area,tmp+1);\\n        }\\n        return area;\\n    }\\n    \\n    void dfs(vector<vector<int>> &grid, int i, int j){\\n        if(i<0||j<0||i>=grid.size()||j>=grid[0].size())\\n            return;\\n        if(grid[i][j]!=1)\\n            return;\\n        mp[k]++;\\n        grid[i][j]=k;\\n        dfs(grid,i+1,j);\\n        dfs(grid,i-1,j);\\n        dfs(grid,i,j+1);\\n        dfs(grid,i,j-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1376269,
                "title": "c-dfs-solution-assign-id-s-to-island-commented-exlained",
                "content": "```\\nclass Solution {\\npublic:\\n    //we use the concept of leetcode 695- maximum area of island\\n    //we assign all connected islands with different id\\'s \\n    //we do it inplace\\n    //we then store the area of the island id in a hashmap\\n    \\n    //we again iterate through the isalnd and when we have zero\\n    //we push all the 4 adjacent cell\\'s island id to hashset to get the unique id\\'s\\n    //the we calculate the sum of the area of each id in hashset and update the result\\n    vector<int> offsets={0,1,0,-1,0};\\n    int largestIsland(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size();\\n        unordered_map<int,int> area;\\n        \\n        int maxArea=0;\\n        int currArea=0;\\n        int island_id=2;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    \\n                    calc(grid,i,j,currArea,n,island_id);\\n                    maxArea=max(maxArea,currArea);\\n                    //store the area of the island using its id\\n                    area[island_id]=currArea;\\n                    currArea=0;\\n                    island_id++;\\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==0)\\n                {\\n                    unordered_set<int> st;\\n                    for(int k=0;k<4;k++)\\n                    {\\n                        int x=i+offsets[k];\\n                        int y=j+offsets[k+1];\\n                        if(x<0 || y<0 || x>=n || y>=n || grid[x][y]==0)\\n                            continue;\\n                        st.insert({grid[x][y]});\\n                    }\\n                    \\n                    int total=1;\\n                    for(auto i:st){\\n                        total+=area[i];\\n                    \\n                    }\\n                    maxArea=max(maxArea,total);\\n                }\\n            }\\n        }\\n        \\n        return maxArea;\\n        \\n        \\n        \\n    }\\n\\t\\n\\t//calculates the area of island\\n    void calc(vector<vector<int>>& grid,int i,int j,int& currArea,int& n,int& island_id)\\n    {\\n        currArea++;\\n        //store the island id to which the current cell belongs to\\n        grid[i][j]=island_id;\\n        for(int k=0;k<4;k++)\\n        {\\n            int x=i+offsets[k];\\n            int y=j+offsets[k+1];\\n            if(x<0 || y<0 || x>=n || y>=n || grid[x][y]!=1)\\n                continue;\\n            calc(grid,x,y,currArea,n,island_id);\\n        }\\n        \\n        \\n    }\\n};\\n```\\n**Upvote if this helps you :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //we use the concept of leetcode 695- maximum area of island\\n    //we assign all connected islands with different id\\'s \\n    //we do it inplace\\n    //we then store the area of the island id in a hashmap\\n    \\n    //we again iterate through the isalnd and when we have zero\\n    //we push all the 4 adjacent cell\\'s island id to hashset to get the unique id\\'s\\n    //the we calculate the sum of the area of each id in hashset and update the result\\n    vector<int> offsets={0,1,0,-1,0};\\n    int largestIsland(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size();\\n        unordered_map<int,int> area;\\n        \\n        int maxArea=0;\\n        int currArea=0;\\n        int island_id=2;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    \\n                    calc(grid,i,j,currArea,n,island_id);\\n                    maxArea=max(maxArea,currArea);\\n                    //store the area of the island using its id\\n                    area[island_id]=currArea;\\n                    currArea=0;\\n                    island_id++;\\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==0)\\n                {\\n                    unordered_set<int> st;\\n                    for(int k=0;k<4;k++)\\n                    {\\n                        int x=i+offsets[k];\\n                        int y=j+offsets[k+1];\\n                        if(x<0 || y<0 || x>=n || y>=n || grid[x][y]==0)\\n                            continue;\\n                        st.insert({grid[x][y]});\\n                    }\\n                    \\n                    int total=1;\\n                    for(auto i:st){\\n                        total+=area[i];\\n                    \\n                    }\\n                    maxArea=max(maxArea,total);\\n                }\\n            }\\n        }\\n        \\n        return maxArea;\\n        \\n        \\n        \\n    }\\n\\t\\n\\t//calculates the area of island\\n    void calc(vector<vector<int>>& grid,int i,int j,int& currArea,int& n,int& island_id)\\n    {\\n        currArea++;\\n        //store the island id to which the current cell belongs to\\n        grid[i][j]=island_id;\\n        for(int k=0;k<4;k++)\\n        {\\n            int x=i+offsets[k];\\n            int y=j+offsets[k+1];\\n            if(x<0 || y<0 || x>=n || y>=n || grid[x][y]!=1)\\n                continue;\\n            calc(grid,x,y,currArea,n,island_id);\\n        }\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1707404,
                "title": "c-using-dfs",
                "content": "**If you like the Solution, then please Upvote!**\\n![image](https://assets.leetcode.com/users/images/5e590ed2-e526-4c5e-83c9-312677e006f7_1647181101.9379933.png)\\n\\n    class Solution {\\n    public:\\n    int dfs(int i, int j, vector<vector<int>> &grid, int & color,int rows,int cols)\\n    {      \\n        if(i < 0 || j < 0 || i >= rows || j >= cols)//invalid case\\n             return 0;\\n        \\n        if(grid[i][j] == 0 || grid[i][j] ==  color)//invalid case\\n             return 0;\\n        \\n        grid[i][j] = color;//just assign the value of color to all adjacent 1\\'s of grid and increment the count everytime\\n        \\n        int count = 1;\\n        count += dfs(i + 1, j, grid,color,rows,cols);\\n        count += dfs(i - 1, j , grid,color,rows,cols);\\n        count += dfs(i, j + 1, grid,color,rows,cols);\\n        count += dfs(i, j - 1, grid,color,rows,cols);\\n        \\n        return count;\\n    }\\n    \\n \\n    int largestIsland(vector<vector<int>>& grid) \\n    {\\n        int rows=grid.size();\\n        int cols=grid[0].size();\\n        \\n        int color = 2;//after visiting any 1, we change that one by color val and then move to its adjacent element, when their is no adjacent increment the color val\\n        \\n        unordered_map<int,int>mp;\\n        \\n         for(int i = 0; i < rows; i++)\\n         {\\n            for(int j = 0; j < cols; j++)\\n            {\\n                if(grid[i][j] == 1)\\n                {\\n                    int count = dfs(i, j, grid,color,rows,cols);//insert the value of particular area in map with its 1\\'s count\\n                        mp[color] = count;\\n                        color++;\\n                     \\n                }\\n            }\\n        }\\n        //Now we are changing one 0 to 1 and checking for every case and find max island with 1\\'s\\n        int result=0;\\n        for(int i=0;i<rows;i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n                if(grid[i][j]==0)\\n                {\\n                    set<int> st;//here i use set because we want to store connected values of different color counts,checking all the adjacent values\\n                    \\n                    if(i-1>=0 && grid[i-1][j]!=0)\\n                    {\\n                        st.insert(grid[i-1][j]);\\n                    }\\n                    if(i+1<rows && grid[i+1][j]!=0) \\n                    {\\n                        st.insert(grid[i+1][j]);\\n                    }\\n                    if(j-1>=0 && grid[i][j-1]!=0) \\n                    {\\n                        st.insert(grid[i][j-1]);\\n                    }\\n                    if(j+1<cols && grid[i][j+1]!=0) \\n                    {\\n                        st.insert(grid[i][j+1]);\\n                    }\\n                    \\n                    int sum = 1;\\n                    for(auto i:st)\\n                        sum += mp[i];\\n                    \\n                    result = max(result, sum);\\n                    \\n                }\\n            }\\n        }\\n        return result==0?(rows*cols):result; \\n    }\\n   };",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "class Solution {\\n    public:\\n    int dfs(int i, int j, vector<vector<int>> &grid, int & color,int rows,int cols)\\n    {      \\n        if(i < 0 || j < 0 || i >= rows || j >= cols)//invalid case\\n             return 0;\\n        \\n        if(grid[i][j] == 0 || grid[i][j] ==  color)//invalid case\\n             return 0;\\n        \\n        grid[i][j] = color;//just assign the value of color to all adjacent 1\\'s of grid and increment the count everytime\\n        \\n        int count = 1;\\n        count += dfs(i + 1, j, grid,color,rows,cols);\\n        count += dfs(i - 1, j , grid,color,rows,cols);\\n        count += dfs(i, j + 1, grid,color,rows,cols);\\n        count += dfs(i, j - 1, grid,color,rows,cols);\\n        \\n        return count;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1057453,
                "title": "dfs-c-intuitive-solution-with-explanation-o-n-n",
                "content": "Let us group the islands by changing the 1s to their index and increment the index.\\nAll islands in a particular group have the same index. We store the index and the corresponding area in a map and keep track of the maximum area until now.\\nExamples:\\n1 0 1 -> 2 0 3    \\n0 1 1 -> 0 3 3 \\n1 0 1 ->  4 0 3\\n\\nNow, we traverse each 0 in the grid and find its adjacent group and add up their areas. \\nFor the 0 at (0,1), we get area=m[2]+m[3]+1=1+4+1=6\\nFor the 0 at (1,0), we get area=m[2]+m[3]+m[4]+1=1+4+1+1=7\\nWe add 1 to account for the converted island.\\n\\nAt the end, we are left with the required answer.\\n\\n```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>>& grid, int i, int j, int index) {\\n        int n=grid.size();\\n        if(i<0 || i>=n || j<0 || j>=n || grid[i][j]!=1) return 0;\\n        grid[i][j]=index;\\n        int count = dfs(grid, i+1, j, index) + \\n                    dfs(grid, i-1, j, index) + \\n                    dfs(grid, i, j+1, index) + \\n                    dfs(grid, i, j-1, index);\\n        return count+1;\\n    }\\n    \\n    void findNeighbours(vector<vector<int>>& grid, int i, int j, set<int>& s) {\\n\\t\\t//finding adjacent island groups\\n        int n=grid.size();\\n        if(i>0) s.insert(grid[i-1][j]);\\n        if(j>0) s.insert(grid[i][j-1]);\\n        if(i<n-1) s.insert(grid[i+1][j]);\\n        if(j<n-1) s.insert(grid[i][j+1]);\\n    }\\n    \\n    int largestIsland(vector<vector<int>>& grid) {\\n        int n=grid.size(), res=0, index=2, count;\\n        map<int, int> area;\\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(grid[i][j]==1) {\\n                    area[index]=dfs(grid, i, j, index);\\n                    res=max(res, area[index++]);\\n\\t\\t\\t\\t\\t//if the grid is one large island, we would find the maximum size island here\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(grid[i][j]==0) {\\n                    set<int> s;\\n                    findNeighbours(grid, i, j, s);\\n                    count=1;    //to account for the converted island\\n                    for(int i:s)\\n                        count+=area[i];       // count the number of islands in the adjacent groups\\n                    res=max(res, count);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(vector<vector<int>>& grid, int i, int j, int index) {\\n        int n=grid.size();\\n        if(i<0 || i>=n || j<0 || j>=n || grid[i][j]!=1) return 0;\\n        grid[i][j]=index;\\n        int count = dfs(grid, i+1, j, index) + \\n                    dfs(grid, i-1, j, index) + \\n                    dfs(grid, i, j+1, index) + \\n                    dfs(grid, i, j-1, index);\\n        return count+1;\\n    }\\n    \\n    void findNeighbours(vector<vector<int>>& grid, int i, int j, set<int>& s) {\\n\\t\\t//finding adjacent island groups\\n        int n=grid.size();\\n        if(i>0) s.insert(grid[i-1][j]);\\n        if(j>0) s.insert(grid[i][j-1]);\\n        if(i<n-1) s.insert(grid[i+1][j]);\\n        if(j<n-1) s.insert(grid[i][j+1]);\\n    }\\n    \\n    int largestIsland(vector<vector<int>>& grid) {\\n        int n=grid.size(), res=0, index=2, count;\\n        map<int, int> area;\\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(grid[i][j]==1) {\\n                    area[index]=dfs(grid, i, j, index);\\n                    res=max(res, area[index++]);\\n\\t\\t\\t\\t\\t//if the grid is one large island, we would find the maximum size island here\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(grid[i][j]==0) {\\n                    set<int> s;\\n                    findNeighbours(grid, i, j, s);\\n                    count=1;    //to account for the converted island\\n                    for(int i:s)\\n                        count+=area[i];       // count the number of islands in the adjacent groups\\n                    res=max(res, count);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 126938,
                "title": "python-solution-with-explanation-and-comments",
                "content": "Tag islands and record the area of islands for initial grid.\\nThen for each \\'water\\' position, combine its adjacent islands and return the largest.\\n\\n```\\nclass Solution:\\n    def largestIsland(self, grid):\\n        if not grid or not grid[0]: return 0\\n        m, n = len(grid), len(grid[0])\\n        \\n        island_tag = 100\\n        visited = set()\\n        # area for each island_tag\\n        areas = collections.Counter()\\n        \\n        ret = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j]==0 or (i, j) in visited: continue\\n                # increment to get new island_tag\\n                island_tag += 1\\n                visited.add((i, j))\\n                q = [(i, j)]\\n                while q:\\n                    (x, y) = q.pop(0)\\n                    # increment island area\\n                    areas[island_tag] += 1\\n                    ret = max(ret, areas[island_tag])\\n                    # set grid[x][y] to the island_tag it belongs to\\n                    grid[x][y] = island_tag\\n                    for xx, yy in [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]:\\n                        if not (0<=xx<m and 0<=yy<n) or (xx, yy) in visited or grid[xx][yy]==0:\\n                            continue\\n                        visited.add((xx, yy))\\n                        q.append((xx, yy))\\n                        \\n        for x in range(m):\\n            for y in range(n):\\n                if grid[x][y]!=0: continue\\n                area = 1\\n                islands = set()\\n                # Combine its adjacent islands and sum up their area\\n                for xx, yy in [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]:\\n                    if not (0<=xx<m and 0<=yy<n):\\n                        continue\\n                    islands.add(grid[xx][yy])\\n                for island in islands:\\n                    area += areas[island]\\n                ret = max(ret, area)\\n                \\n        return ret\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestIsland(self, grid):\\n        if not grid or not grid[0]: return 0\\n        m, n = len(grid), len(grid[0])\\n        \\n        island_tag = 100\\n        visited = set()\\n        # area for each island_tag\\n        areas = collections.Counter()\\n        \\n        ret = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j]==0 or (i, j) in visited: continue\\n                # increment to get new island_tag\\n                island_tag += 1\\n                visited.add((i, j))\\n                q = [(i, j)]\\n                while q:\\n                    (x, y) = q.pop(0)\\n                    # increment island area\\n                    areas[island_tag] += 1\\n                    ret = max(ret, areas[island_tag])\\n                    # set grid[x][y] to the island_tag it belongs to\\n                    grid[x][y] = island_tag\\n                    for xx, yy in [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]:\\n                        if not (0<=xx<m and 0<=yy<n) or (xx, yy) in visited or grid[xx][yy]==0:\\n                            continue\\n                        visited.add((xx, yy))\\n                        q.append((xx, yy))\\n                        \\n        for x in range(m):\\n            for y in range(n):\\n                if grid[x][y]!=0: continue\\n                area = 1\\n                islands = set()\\n                # Combine its adjacent islands and sum up their area\\n                for xx, yy in [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]:\\n                    if not (0<=xx<m and 0<=yy<n):\\n                        continue\\n                    islands.add(grid[xx][yy])\\n                for island in islands:\\n                    area += areas[island]\\n                ret = max(ret, area)\\n                \\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 127869,
                "title": "c-disjoint-set-or-union-find",
                "content": "This is a typical union find algorithm. merge all connected 1s into a group with the smallest index as the parent. Also add a size vector for the disjoint sets and keep track of the max size.\\n\\nIterate all over the zeros and if we flip it and add all different set\\'s length and update the max length.\\n\\nThe code is straightforward and easy to implement if we have the disjoint set toolbox.\\nComplexity: O(N^2), 15ms\\n\\n```\\nclass union_find\\n{\\n    int m,n;\\n    int count;\\n    vector<int> parent;\\n    vector<int> size;\\n    int max_size;\\npublic:\\n    union_find(vector<vector<int>>& grid)\\n    {\\n        count=0;\\n        max_size=0;\\n        m=grid.size(),n=grid[0].size();\\n        parent.resize(m*n+1);\\n        size.resize(m*n+1);\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]) {parent[i*n+j]=i*n+j;size[i*n+j]=1;count++;}\\n            }\\n        }\\n        if(count) max_size=1;\\n        parent[n*m]=n*m;//dummy node\\n    }\\n    int find(int node)\\n    {\\n        while(parent[node]!=node) node=parent[node];\\n        return node;\\n    }\\n    void merge(int ni,int nj)\\n    {\\n        int i_id=find(ni);\\n        int j_id=find(nj);\\n        if(i_id==j_id) return;\\n        if(i_id<j_id) {parent[j_id]=i_id;size[i_id]+=size[j_id];size[j_id]=0;max_size=max(max_size,size[i_id]);}\\n        else {parent[i_id]=j_id;size[j_id]+=size[i_id];size[i_id]=0;max_size=max(max_size,size[j_id]);}\\n        count--;\\n    }\\n    bool connected(int ni,int nj) {return find(ni)==find(nj);}\\n    int get_numset() {return count;}\\n    int get_size(int p) {return size[p];}\\n    int get_maxsize() {return max_size;}\\n};\\nclass Solution {\\npublic:\\n    int largestIsland(vector<vector<int>>& grid) {\\n        //disjoint set and see which one flip will add the largest\\n        //using the i*n+j as the root\\n        //bfs search to merge \\n        union_find uf(grid);\\n        int m=grid.size(),n=grid[0].size();\\n        int dir[][2]={{-1,0},{1,0},{0,-1},{0,1}};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j])\\n                {\\n                    for(int k=0;k<4;k++)\\n                    {\\n                        int x=i+dir[k][0],y=j+dir[k][1];\\n                        if(x>=0 && x<m && y>=0 && y<n && grid[x][y])\\n                        {\\n                            uf.merge(i*n+j,x*n+y);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        //now we get all the adjoint set, we will check the 0 to see which connect two or three or 4\\n        int maxlen=INT_MIN;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(!grid[i][j])\\n                {\\n                    unordered_set<int> us;\\n                    for(int k=0;k<4;k++)\\n                    {\\n                        int x=i+dir[k][0],y=j+dir[k][1];\\n\\n                        if(x>=0 && x<m && y>=0 && y<n && grid[x][y])\\n                        {\\n                            int p=uf.find(x*n+y);//same region cannot be added multiple times\\n                            us.insert(p);\\n                        }\\n                    }\\n                    int cnt=0;\\n                    for(auto it=us.begin();it!=us.end();it++) cnt+=uf.get_size(*it);\\n                    maxlen=max(maxlen,cnt);\\n                }\\n            }\\n        }\\n        return maxlen==INT_MIN?uf.get_maxsize():maxlen+1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass union_find\\n{\\n    int m,n;\\n    int count;\\n    vector<int> parent;\\n    vector<int> size;\\n    int max_size;\\npublic:\\n    union_find(vector<vector<int>>& grid)\\n    {\\n        count=0;\\n        max_size=0;\\n        m=grid.size(),n=grid[0].size();\\n        parent.resize(m*n+1);\\n        size.resize(m*n+1);\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]) {parent[i*n+j]=i*n+j;size[i*n+j]=1;count++;}\\n            }\\n        }\\n        if(count) max_size=1;\\n        parent[n*m]=n*m;//dummy node\\n    }\\n    int find(int node)\\n    {\\n        while(parent[node]!=node) node=parent[node];\\n        return node;\\n    }\\n    void merge(int ni,int nj)\\n    {\\n        int i_id=find(ni);\\n        int j_id=find(nj);\\n        if(i_id==j_id) return;\\n        if(i_id<j_id) {parent[j_id]=i_id;size[i_id]+=size[j_id];size[j_id]=0;max_size=max(max_size,size[i_id]);}\\n        else {parent[i_id]=j_id;size[j_id]+=size[i_id];size[i_id]=0;max_size=max(max_size,size[j_id]);}\\n        count--;\\n    }\\n    bool connected(int ni,int nj) {return find(ni)==find(nj);}\\n    int get_numset() {return count;}\\n    int get_size(int p) {return size[p];}\\n    int get_maxsize() {return max_size;}\\n};\\nclass Solution {\\npublic:\\n    int largestIsland(vector<vector<int>>& grid) {\\n        //disjoint set and see which one flip will add the largest\\n        //using the i*n+j as the root\\n        //bfs search to merge \\n        union_find uf(grid);\\n        int m=grid.size(),n=grid[0].size();\\n        int dir[][2]={{-1,0},{1,0},{0,-1},{0,1}};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j])\\n                {\\n                    for(int k=0;k<4;k++)\\n                    {\\n                        int x=i+dir[k][0],y=j+dir[k][1];\\n                        if(x>=0 && x<m && y>=0 && y<n && grid[x][y])\\n                        {\\n                            uf.merge(i*n+j,x*n+y);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        //now we get all the adjoint set, we will check the 0 to see which connect two or three or 4\\n        int maxlen=INT_MIN;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(!grid[i][j])\\n                {\\n                    unordered_set<int> us;\\n                    for(int k=0;k<4;k++)\\n                    {\\n                        int x=i+dir[k][0],y=j+dir[k][1];\\n\\n                        if(x>=0 && x<m && y>=0 && y<n && grid[x][y])\\n                        {\\n                            int p=uf.find(x*n+y);//same region cannot be added multiple times\\n                            us.insert(p);\\n                        }\\n                    }\\n                    int cnt=0;\\n                    for(auto it=us.begin();it!=us.end();it++) cnt+=uf.get_size(*it);\\n                    maxlen=max(maxlen,cnt);\\n                }\\n            }\\n        }\\n        return maxlen==INT_MIN?uf.get_maxsize():maxlen+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1533620,
                "title": "union-find-with-explanation",
                "content": "(Please read the explanation along with the code below)\\n\\n`1` in an island is like an element in a disjoint set; an island is like a disjoint set. \\n\\nSo we may use Disjoint Set (a.k.a. Union Find) to model the problem first. For each `1` in the grid, we `union_around` its adjacent `1`s. After that, the model is built.\\n\\nIf there are only `1`s in the grid, current `uf.max_size()` is the final answer.\\n\\nIf there are `0`s in the grid, for each `0`, we should try unioning it with its adjacent island.\\n\\nNote that all its adjacent `1`s may come from the same island.\\nSo we build `total_size_map`, which maps adjacent island root to its size, in order to deduplicate. \\n\\nFinally, we add sizes of all adjacent islands and plus 1 -- that\\'s the total island size after changing the current `0` to `1`.\\n\\nWe keep track of the maximum total island size by chaning each `0` and return it at last.\\n\\n```\\nclass Solution:\\n    def largestIsland(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        uf = UnionFind(n, grid)\\n        for x in range(n):\\n            for y in range(n):\\n                 if grid[x][y] == 1:\\n                    uf.union_around(x, y)\\n        max_total_size = uf.max_size()\\n\\n        for x in range(n):\\n            for y in range(n):\\n                if grid[x][y] == 0:\\n                    total_size_map = {}\\n                    for direction in uf.dirs:\\n                        nx = x + direction[0]\\n                        ny = y + direction[1]\\n                        if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] == 1:\\n                            parent = uf.find(nx * n + ny)\\n                            total_size_map[parent] = uf.size[parent]\\n                    max_total_size = max(max_total_size, sum(total_size_map.values()) + 1)\\n                        \\n        return max_total_size\\n                            \\n    \\nclass UnionFind:\\n    def __init__(self, n, grid):\\n        self.parent, self.size, self.rank = {}, {}, {}\\n        for x in range(n * n):\\n            self.parent[x] = x\\n            self.size[x] = 1\\n            self.rank[x] = 1\\n        \\n        self.dirs = [[0, -1], [0, 1], [-1, 0], [1, 0]]\\n        self.n = n\\n        self.grid = grid\\n        \\n    def union(self, u, v):\\n        root_u = self.find(u)\\n        root_v = self.find(v)\\n        if root_u != root_v:\\n            if self.rank[root_u] < self.rank[root_v]:\\n                self.parent[root_u] = root_v\\n                self.size[root_v] += self.size[root_u]\\n                self.rank[root_v] += 1\\n            else:\\n                self.parent[root_v] = root_u\\n                self.size[root_u] += self.size[root_v]\\n                self.rank[root_u] += 1                \\n\\n    def find(self, u):\\n        if self.parent[u] != u:\\n            self.parent[u] = self.find(self.parent[u])\\n        return self.parent[u]\\n\\n    def union_around(self, x, y):\\n        for direction in self.dirs:\\n            nx = x + direction[0]\\n            ny = y + direction[1]\\n            if 0 <= nx < self.n and 0 <= ny < self.n and self.grid[nx][ny] == 1:\\n                self.union(x * self.n + y, nx * self.n + ny)\\n\\n    def max_size(self):\\n        size = 0\\n        for v in range(self.n * self.n):\\n            if self.parent[v] == v and self.grid[v // self.n][v % self.n] == 1:\\n                size = max(size, self.size[v])\\n        return size\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def largestIsland(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        uf = UnionFind(n, grid)\\n        for x in range(n):\\n            for y in range(n):\\n                 if grid[x][y] == 1:\\n                    uf.union_around(x, y)\\n        max_total_size = uf.max_size()\\n\\n        for x in range(n):\\n            for y in range(n):\\n                if grid[x][y] == 0:\\n                    total_size_map = {}\\n                    for direction in uf.dirs:\\n                        nx = x + direction[0]\\n                        ny = y + direction[1]\\n                        if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] == 1:\\n                            parent = uf.find(nx * n + ny)\\n                            total_size_map[parent] = uf.size[parent]\\n                    max_total_size = max(max_total_size, sum(total_size_map.values()) + 1)\\n                        \\n        return max_total_size\\n                            \\n    \\nclass UnionFind:\\n    def __init__(self, n, grid):\\n        self.parent, self.size, self.rank = {}, {}, {}\\n        for x in range(n * n):\\n            self.parent[x] = x\\n            self.size[x] = 1\\n            self.rank[x] = 1\\n        \\n        self.dirs = [[0, -1], [0, 1], [-1, 0], [1, 0]]\\n        self.n = n\\n        self.grid = grid\\n        \\n    def union(self, u, v):\\n        root_u = self.find(u)\\n        root_v = self.find(v)\\n        if root_u != root_v:\\n            if self.rank[root_u] < self.rank[root_v]:\\n                self.parent[root_u] = root_v\\n                self.size[root_v] += self.size[root_u]\\n                self.rank[root_v] += 1\\n            else:\\n                self.parent[root_v] = root_u\\n                self.size[root_u] += self.size[root_v]\\n                self.rank[root_u] += 1                \\n\\n    def find(self, u):\\n        if self.parent[u] != u:\\n            self.parent[u] = self.find(self.parent[u])\\n        return self.parent[u]\\n\\n    def union_around(self, x, y):\\n        for direction in self.dirs:\\n            nx = x + direction[0]\\n            ny = y + direction[1]\\n            if 0 <= nx < self.n and 0 <= ny < self.n and self.grid[nx][ny] == 1:\\n                self.union(x * self.n + y, nx * self.n + ny)\\n\\n    def max_size(self):\\n        size = 0\\n        for v in range(self.n * self.n):\\n            if self.parent[v] == v and self.grid[v // self.n][v % self.n] == 1:\\n                size = max(size, self.size[v])\\n        return size\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1150779,
                "title": "python-union-find-solution",
                "content": "**Idea**\\n- Find connected components (island) and their size using Union Find\\n- Iterate all 0s and check the adjacant 1s, if any, and which island it is adjacant to. \\n- Sum the size of all adjacant islands and plus 1. It is the new connected area if the 0 is converted to 1.\\n- update max area for each 0 in the grid. If no 0 in grid (all cells are 1s), return the size of grid.\\n\\n**Complexity**\\n* Time: O(N^2)\\n* Space: O(N^2)\\n\\t\\t\\n**Python**\\n```\\n    def largestIsland(self, grid: List[List[int]]) -> int:\\n        \\n        # Union Find Solution\\n        # Time: O(N^2)\\n        # Space: O(N^2)\\n        \\n        N = len(grid)\\n        \\n        # union find and size of components\\n        uf = {\\n            (r, c): (r, c)\\n            for r in range(N)\\n            for c in range(N)\\n            if grid[r][c]\\n        }\\n        \\n        size = {\\n            (r, c): 1\\n            for r in range(N)\\n            for c in range(N)\\n            if grid[r][c]\\n        }\\n        \\n        def find(x):\\n            if x != uf[x]:\\n                uf[x] = find(uf[x])\\n            return uf[x]\\n        \\n        def union(x, y):\\n            rootx = find(x)\\n            rooty = find(y)\\n            if rootx != rooty:\\n                uf[rootx] = rooty\\n                size[rooty] += size[rootx]\\n            \\n        # union adjacant 1s\\n        for r in range(N):\\n            for c in range(N):\\n                if grid[r][c]:\\n                    for nr, nc in [[r+1, c], [r, c+1]]:\\n                        if 0 <= nr < N and 0 <= nc < N and grid[nr][nc]:\\n                            union((r,c), (nr,nc))\\n        \\n        # iterate all 0s to find the max area\\n        max_area = 0\\n        has_zero = False\\n        for r in range(N):\\n            for c in range(N):\\n                if grid[r][c] == 0:\\n                    has_zero = True\\n                    adj_islands = set()\\n                    for nr, nc in [[r+1, c], [r, c+1], [r-1, c], [r, c-1]]:\\n                        if 0 <= nr < N and 0 <= nc < N and grid[nr][nc]:\\n                            adj_islands.add(find((nr, nc)))\\n                    area = 1 + sum(size[adj_island] for adj_island in adj_islands)\\n                    max_area = max(max_area, area)\\n                    \\n        return max_area if has_zero else N * N\\n```",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\n    def largestIsland(self, grid: List[List[int]]) -> int:\\n        \\n        # Union Find Solution\\n        # Time: O(N^2)\\n        # Space: O(N^2)\\n        \\n        N = len(grid)\\n        \\n        # union find and size of components\\n        uf = {\\n            (r, c): (r, c)\\n            for r in range(N)\\n            for c in range(N)\\n            if grid[r][c]\\n        }\\n        \\n        size = {\\n            (r, c): 1\\n            for r in range(N)\\n            for c in range(N)\\n            if grid[r][c]\\n        }\\n        \\n        def find(x):\\n            if x != uf[x]:\\n                uf[x] = find(uf[x])\\n            return uf[x]\\n        \\n        def union(x, y):\\n            rootx = find(x)\\n            rooty = find(y)\\n            if rootx != rooty:\\n                uf[rootx] = rooty\\n                size[rooty] += size[rootx]\\n            \\n        # union adjacant 1s\\n        for r in range(N):\\n            for c in range(N):\\n                if grid[r][c]:\\n                    for nr, nc in [[r+1, c], [r, c+1]]:\\n                        if 0 <= nr < N and 0 <= nc < N and grid[nr][nc]:\\n                            union((r,c), (nr,nc))\\n        \\n        # iterate all 0s to find the max area\\n        max_area = 0\\n        has_zero = False\\n        for r in range(N):\\n            for c in range(N):\\n                if grid[r][c] == 0:\\n                    has_zero = True\\n                    adj_islands = set()\\n                    for nr, nc in [[r+1, c], [r, c+1], [r-1, c], [r, c-1]]:\\n                        if 0 <= nr < N and 0 <= nc < N and grid[nr][nc]:\\n                            adj_islands.add(find((nr, nc)))\\n                    area = 1 + sum(size[adj_island] for adj_island in adj_islands)\\n                    max_area = max(max_area, area)\\n                    \\n        return max_area if has_zero else N * N\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2881443,
                "title": "solution-dsu-o-n-n",
                "content": "```\\n\\n```class DSU\\n{\\n    vector<int>rank , parent , size;\\n    public:\\n    DSU(int n)\\n    {\\n        size.resize(n+1 , 1);\\n        rank.resize(n+1 , 0);\\n        parent.resize(n+1);\\n        for(int i = 0;i<=n;i++)\\n        parent[i] = i;\\n    }\\n    int findpar(int node)\\n    {\\n        if(node == parent[node])return node;\\n\\n        return parent[node] = findpar(parent[node]);\\n    }\\n    void unionbyrank(int u , int v)\\n    {\\n        int p_u = findpar(u);\\n        int p_v = findpar(v);\\n        if(p_u == p_v) return ;\\n        if(rank[p_u] > rank[p_v])\\n        {\\n            parent[p_v] = p_u;\\n        }\\n        else if(rank[p_v] > rank[p_u])\\n        {\\n            parent[p_u] = p_v;\\n        }\\n        else \\n        {\\n            parent[p_v] = p_u;\\n            rank[p_u]++;\\n        }\\n    }\\n    void unionbysize(int u , int v)\\n    {\\n        int p_u = findpar(u);\\n        int p_v = findpar(v);\\n        if(p_u == p_v) return ;\\n        if(size[p_u] > size[p_v])\\n        {\\n            size[p_u] += size[p_v];\\n            parent[p_v] = p_u;\\n        }\\n        else \\n        {\\n            size[p_v] += size[p_u];\\n            parent[p_u] = p_v;\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        DSU dsu(n*n);\\n        int dc[] = {1 , 0 , 0 , -1};\\n        int dr[] = {0 , -1 , 1 , 0};\\n        for(int i = 0;i<n;i++)\\n        {\\n            for(int j = 0;j<n;j++)\\n            {\\n                int node = i*n + j;\\n                if(grid[i][j] == 1)\\n                {\\n                    for(int k = 0;k<4;k++)\\n                    {\\n                        int next_i = i + dr[k];\\n                        int next_j = j + dc[k];\\n                        if(next_i < 0 || next_j < 0 || next_i >= n || next_j >= n) continue;\\n                        if(grid[next_i][next_j] == 0) continue;\\n                        int next_node = next_i*n + next_j;\\n                        if(dsu.findpar(node) == dsu.findpar(next_node))\\n                            continue;\\n                        dsu.unionbyrank(node , next_node);\\n                    }\\n                }\\n            }\\n        }\\n        int ans = 0 , maxi = 0;\\n        unordered_map<int , int>mp;\\n        for(int i = 0;i<n*n;i++)\\n        {\\n            mp[dsu.findpar(i)]++;\\n        }\\n        for(int i = 0;i<n;i++)\\n        {\\n            for(int j = 0;j<n;j++)\\n            {\\n                int count = 1;\\n                unordered_set<int>s;\\n                if(grid[i][j] == 0)\\n                {\\n                    for(int k = 0;k<4;k++)\\n                    {\\n                        int next_i = i + dr[k];\\n                        int next_j = j + dc[k];\\n                        if(next_i < 0|| next_j < 0|| next_i >= n|| next_j >= n) continue;\\n                        if(grid[next_i][next_j] == 0) continue;\\n                        int next_node = next_i*n + next_j;\\n                        if(s.find(dsu.findpar(next_node)) != s.end()) continue;\\n                        s.insert(dsu.findpar(next_node));\\n                        count += mp[dsu.findpar(next_node)];\\n                        \\n                    }\\n                }\\n                ans = max(ans , count);\\n            }\\n        }\\n        for(auto it:mp)\\n            ans = max(ans , it.second);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Union Find",
                    "Matrix"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1380164,
                "title": "java-simple-and-easy-to-understand-solution-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n```\\nclass Solution {\\n    static int[][] DIRECTIONS = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n    private int rows;\\n    private int cols;\\n    \\n    public int largestIsland(int[][] grid) {\\n        rows = grid.length;\\n        cols = grid[0].length;\\n        \\n        \\n        int[] areas = new int[rows * cols + 2];\\n        int areaIndex = 2;\\n        \\n        for(int r = 0; r < rows; r++){\\n            for(int c = 0; c < cols; c++){\\n                if(grid[r][c] != 1) continue;\\n                \\n                //save the area of this ones island in unique index\\n                areas[areaIndex] = getArea(grid, r, c, areaIndex);\\n                areaIndex++;\\n            }\\n        }\\n        \\n        int maxArea = 0;\\n        //max area without toggling zero\\n        for(int area : areas) maxArea = Math.max(area, maxArea);\\n        \\n        \\n        //max area after toggling zero to one\\n        for(int r = 0; r < rows; r++){\\n            for(int c = 0; c < cols; c++){\\n                if(grid[r][c] != 0) continue;\\n                \\n                Set<Integer> seenIsland = new HashSet();\\n                \\n                int area = 1;\\n                for(int[] dir : DIRECTIONS){\\n                    int x = r + dir[0];\\n                    int y = c + dir[1];\\n                    \\n                    if(isOutsideGrid(x, y)) continue;\\n                    \\n                    if(seenIsland.contains(grid[x][y])) continue;\\n                    \\n                    //mark as seen this island\\n                    seenIsland.add(grid[x][y]);\\n                    \\n                    //add the island area of current direction\\n                    area += areas[grid[x][y]];\\n                }\\n                \\n                maxArea = Math.max(area, maxArea);\\n            }\\n        }\\n        \\n        return maxArea;\\n    }\\n    \\n    \\n    private int getArea(int[][] grid, int r, int c, int areaIndex){\\n        if(isOutsideGrid(r, c)) return 0;\\n        \\n        if(grid[r][c] != 1) return 0;\\n\\n        //marked Visited and assign a unique index,\\n        grid[r][c] = areaIndex;\\n\\n        int area = 1;\\n\\n        for(int[] dir : DIRECTIONS){\\n            int x = r + dir[0];\\n            int y = c + dir[1];\\n\\n            area += getArea(grid, x, y, areaIndex);\\n        }\\n\\n        return area;\\n    }\\n        \\n    private boolean isOutsideGrid(int r, int c){\\n        return r < 0 || r >= rows || c < 0 || c >= cols;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static int[][] DIRECTIONS = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n    private int rows;\\n    private int cols;\\n    \\n    public int largestIsland(int[][] grid) {\\n        rows = grid.length;\\n        cols = grid[0].length;\\n        \\n        \\n        int[] areas = new int[rows * cols + 2];\\n        int areaIndex = 2;\\n        \\n        for(int r = 0; r < rows; r++){\\n            for(int c = 0; c < cols; c++){\\n                if(grid[r][c] != 1) continue;\\n                \\n                //save the area of this ones island in unique index\\n                areas[areaIndex] = getArea(grid, r, c, areaIndex);\\n                areaIndex++;\\n            }\\n        }\\n        \\n        int maxArea = 0;\\n        //max area without toggling zero\\n        for(int area : areas) maxArea = Math.max(area, maxArea);\\n        \\n        \\n        //max area after toggling zero to one\\n        for(int r = 0; r < rows; r++){\\n            for(int c = 0; c < cols; c++){\\n                if(grid[r][c] != 0) continue;\\n                \\n                Set<Integer> seenIsland = new HashSet();\\n                \\n                int area = 1;\\n                for(int[] dir : DIRECTIONS){\\n                    int x = r + dir[0];\\n                    int y = c + dir[1];\\n                    \\n                    if(isOutsideGrid(x, y)) continue;\\n                    \\n                    if(seenIsland.contains(grid[x][y])) continue;\\n                    \\n                    //mark as seen this island\\n                    seenIsland.add(grid[x][y]);\\n                    \\n                    //add the island area of current direction\\n                    area += areas[grid[x][y]];\\n                }\\n                \\n                maxArea = Math.max(area, maxArea);\\n            }\\n        }\\n        \\n        return maxArea;\\n    }\\n    \\n    \\n    private int getArea(int[][] grid, int r, int c, int areaIndex){\\n        if(isOutsideGrid(r, c)) return 0;\\n        \\n        if(grid[r][c] != 1) return 0;\\n\\n        //marked Visited and assign a unique index,\\n        grid[r][c] = areaIndex;\\n\\n        int area = 1;\\n\\n        for(int[] dir : DIRECTIONS){\\n            int x = r + dir[0];\\n            int y = c + dir[1];\\n\\n            area += getArea(grid, x, y, areaIndex);\\n        }\\n\\n        return area;\\n    }\\n        \\n    private boolean isOutsideGrid(int r, int c){\\n        return r < 0 || r >= rows || c < 0 || c >= cols;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1424229,
                "title": "python-3-dfs-96",
                "content": "```\\nclass Solution:\\n    def largestIsland(self, grid: list[list[int]]) -> int:\\n        border=defaultdict(set)   # coor of border 0 mapping to area id. (r,c) -> id\\n        n=len(grid)\\n        seen=[[False]*n for _ in range(n)]\\n\\n        def dfs(r,c,id):\\n            seen[r][c]=True\\n            area=1\\n            for x,y in ((r+1,c),(r-1,c),(r,c+1),(r,c-1)):\\n                if 0<=x<n and 0<=y<n:\\n                    if grid[x][y]==0:\\n                        border[(x,y)].add(id)\\n                    elif grid[x][y]==1 and not seen[x][y]:\\n                        area+=dfs(x,y,id)\\n            return area\\n\\n        areas=[]\\n        id=0\\n        for i in range(n):\\n            for j in range(n):\\n                if grid[i][j]==1 and not seen[i][j]:\\n                    areas.append(dfs(i,j,id))\\n                    id+=1\\n        \\n        if border:\\n            return max(1+sum(areas[x] for x in y) for y in border.values())\\n        else:\\n            return n*n if grid[0][0]==1 else 1\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def largestIsland(self, grid: list[list[int]]) -> int:\\n        border=defaultdict(set)   # coor of border 0 mapping to area id. (r,c) -> id\\n        n=len(grid)\\n        seen=[[False]*n for _ in range(n)]\\n\\n        def dfs(r,c,id):\\n            seen[r][c]=True\\n            area=1\\n            for x,y in ((r+1,c),(r-1,c),(r,c+1),(r,c-1)):\\n                if 0<=x<n and 0<=y<n:\\n                    if grid[x][y]==0:\\n                        border[(x,y)].add(id)\\n                    elif grid[x][y]==1 and not seen[x][y]:\\n                        area+=dfs(x,y,id)\\n            return area\\n\\n        areas=[]\\n        id=0\\n        for i in range(n):\\n            for j in range(n):\\n                if grid[i][j]==1 and not seen[i][j]:\\n                    areas.append(dfs(i,j,id))\\n                    id+=1\\n        \\n        if border:\\n            return max(1+sum(areas[x] for x in y) for y in border.values())\\n        else:\\n            return n*n if grid[0][0]==1 else 1\\n",
                "codeTag": "Java"
            },
            {
                "id": 1377835,
                "title": "java-dfs-connected-components-solution-union-find-solution",
                "content": "Solution 1:  DFS connected components\\n\\nIterate the matrix and paint different components with different colors and store the size of each component.\\nIterate the matrix again whenever you find zero try to connect them under single component and store the maximum size.\\n\\nNote:\\n 1. The colors shoud start from 2 since 0 and 1 are already in the matrix.\\n 2. Set is used in second iteration because colors are unique for every component. If 2 neighbors have same color they are part of the same component. Hence to prevent repetition set is used. \\n\\nTime Complexity: 0(n^2) effectively\\n\\n```\\nclass Solution {\\n    \\n    int [][]dirs={{0,1},{1,0},{0,-1},{-1,0}};\\n    Map<Integer,Integer> component=new HashMap<>();\\n    \\n    void paint(int [][]grid,int i,int j,int color) {\\n        if(i<0 || j<0 || i>=grid.length || j>=grid.length || grid[i][j]!=1) return;\\n        grid[i][j]=color;\\n        component.put(color,component.getOrDefault(color,0)+1);\\n        for(int []dir:dirs)\\n            paint(grid,i+dir[0],j+dir[1],color);\\n    }\\n    \\n    public int largestIsland(int [][]grid) {\\n        int n=grid.length,ans=0,color=2;\\n        \\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(grid[i][j]==0) continue;\\n                paint(grid,i,j,color);\\n                if(component.containsKey(color))\\n                    ans=Math.max(ans,component.get(color));\\n                color++;\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(grid[i][j]!=0) continue;\\n                Set<Integer> neigh=new HashSet<>();\\n                for(int []dir:dirs) {\\n                    int x=i+dir[0],y=j+dir[1];\\n                    if(x<0 || y<0 || x>=n || y>=n || grid[x][y]==0) continue;\\n                    neigh.add(grid[x][y]);\\n                }\\n                \\n                int size=1;\\n                for(int s:neigh)\\n                    size+=component.get(s);\\n                \\n                ans=Math.max(ans,size);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\t\\nSolution 2: Union Find Solution\\n\\t\\nThis solution is same as DFS solution. Only difference is instead of colors we use Union Find here.\\nIterate the matrix and wherever you find 1 add it to the Union find and update ans with maximum size.\\nIterate the matrix. This time check for 0s. Whenver you find a zero get the component sizes from the neighbors and update the ans with maximum size.\\n\\nTime Complexity: 0(n^2) effectively\\n\\n```\\nclass Solution {\\n\\t UnionFind uf;\\n    public int largestIsland(int[][] grid) {\\n        int n=grid.length;\\n        uf=new UnionFind(n*n);\\n        int ans=0;\\n        \\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(grid[i][j]==0) continue;\\n                int curr=i*n+j;\\n                \\n                uf.add(curr);\\n                for(int neigh:neighbors(grid,i,j))\\n                    uf.union(curr,neigh);\\n                \\n                int p=uf.find(curr);\\n                ans=Math.max(ans,uf.size[p]);\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(grid[i][j]==1) continue;\\n                Set<Integer> neighParents=new HashSet<>();\\n                for(int neigh: neighbors(grid,i,j))\\n                    neighParents.add(uf.find(neigh));\\n                \\n                int size=1;\\n                for(int s:neighParents)\\n                    size+=uf.size[s];\\n                ans=Math.max(ans,size);\\n            }\\n        }\\n        return ans;\\n\\t\\t}\\n    \\n    int [][]dirs={{0,1},{1,0},{0,-1},{-1,0}};\\n    \\n    List<Integer> neighbors(int [][]grid,int i,int j) {\\n        int n=grid.length;\\n        List<Integer> list=new ArrayList<>();\\n        for(int []dir:dirs) {\\n            int x=i+dir[0],y=j+dir[1];\\n            if(x<0 || y<0 || x>=n || y>=n || !uf.contains(x*n+y))\\n                continue;\\n            list.add(x*n+y);\\n        }\\n        return list;\\n    }\\n    \\n    class UnionFind {\\n        int []parent,size;\\n        \\n        UnionFind(int n) {\\n            parent=new int[n];\\n            Arrays.fill(parent,-1);\\n            size=new int[n];\\n        }\\n        \\n        boolean contains(int u) {\\n            return parent[u]>=0;\\n        }\\n        \\n        void add(int u) {\\n            if(contains(u)) return;\\n            parent[u]=u;\\n            size[u]=1;\\n        }\\n        \\n        int find(int u) {\\n            if(parent[u]==u) return u;\\n            parent[u]=find(parent[u]); //path compression\\n            return parent[u];\\n        }\\n        \\n        boolean union(int u,int v) {\\n            int pu=find(u),pv=find(v);\\n            if(pu==pv) return false;\\n            if(size[pu]<=size[pv]) { //merge smaller component\\n                parent[pu]=pv;\\n                size[pv]+=size[pu];\\n            }\\n            else {\\n                parent[pv]=pu;\\n                size[pu]+=size[pv];\\n            }\\n            return true;\\n        }\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int [][]dirs={{0,1},{1,0},{0,-1},{-1,0}};\\n    Map<Integer,Integer> component=new HashMap<>();\\n    \\n    void paint(int [][]grid,int i,int j,int color) {\\n        if(i<0 || j<0 || i>=grid.length || j>=grid.length || grid[i][j]!=1) return;\\n        grid[i][j]=color;\\n        component.put(color,component.getOrDefault(color,0)+1);\\n        for(int []dir:dirs)\\n            paint(grid,i+dir[0],j+dir[1],color);\\n    }\\n    \\n    public int largestIsland(int [][]grid) {\\n        int n=grid.length,ans=0,color=2;\\n        \\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(grid[i][j]==0) continue;\\n                paint(grid,i,j,color);\\n                if(component.containsKey(color))\\n                    ans=Math.max(ans,component.get(color));\\n                color++;\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(grid[i][j]!=0) continue;\\n                Set<Integer> neigh=new HashSet<>();\\n                for(int []dir:dirs) {\\n                    int x=i+dir[0],y=j+dir[1];\\n                    if(x<0 || y<0 || x>=n || y>=n || grid[x][y]==0) continue;\\n                    neigh.add(grid[x][y]);\\n                }\\n                \\n                int size=1;\\n                for(int s:neigh)\\n                    size+=component.get(s);\\n                \\n                ans=Math.max(ans,size);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 623612,
                "title": "javascript-clear-solution-beats-100-easy-to-understand",
                "content": "```\\nvar largestIsland = function(grid) {\\n    return searchLargest(paintIsland(grid));\\n};\\nconst dir = [[1, 0], [-1, 0], [0, 1], [0, -1]];\\n\\nconst validate = (row, col, grid) => row >= 0 && col >= 0 && row < grid.length && col < grid[0].length;\\n\\nconst paintIsland = grid => {\\n    const islandMap = new Map();\\n    let label = 2, area = 0;\\n    const dfs = (x, y) => {\\n        area++;\\n        grid[x][y] = label; // paint the island to a new number\\n        for(const [dx, dy] of dir) {\\n            const row = x + dx;\\n            const col = y + dy;\\n            if(validate(row, col, grid) && grid[row][col] === 1) {\\n                dfs(row, col);\\n            }\\n        }\\n    }\\n    for(let i = 0; i < grid.length; i++) {\\n        for(let j = 0; j < grid[0].length; j++) {\\n            if(grid[i][j] === 1) { \\n                dfs(i, j);\\n                islandMap.set(label, area);\\n                area = 0;\\n                label++;\\n            }\\n        }\\n    }\\n    return [grid, islandMap];\\n}\\n\\nconst searchLargest = ([grid, map]) => {\\n    let res = 0;\\n    for(let i = 0; i < grid.length; i++) {\\n        for(let j = 0; j < grid[0].length; j++) {\\n            if(grid[i][j] === 0) {\\n                let area = 1;\\n                const seen = new Set();\\n                for(const [di, dj] of dir) {\\n                    if(!validate(i + di, j + dj, grid)) continue;\\n                    const curr = grid[i + di][j + dj];\\n                    if(map.has(curr) && !seen.has(curr)) {\\n                        area += map.get(curr);\\n                        seen.add(curr);\\n                    }\\n                }\\n                res = Math.max(area, res);\\n            }\\n        }\\n    }\\n    return res ? res : grid.length * grid[0].length;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar largestIsland = function(grid) {\\n    return searchLargest(paintIsland(grid));\\n};\\nconst dir = [[1, 0], [-1, 0], [0, 1], [0, -1]];\\n\\nconst validate = (row, col, grid) => row >= 0 && col >= 0 && row < grid.length && col < grid[0].length;\\n\\nconst paintIsland = grid => {\\n    const islandMap = new Map();\\n    let label = 2, area = 0;\\n    const dfs = (x, y) => {\\n        area++;\\n        grid[x][y] = label; // paint the island to a new number\\n        for(const [dx, dy] of dir) {\\n            const row = x + dx;\\n            const col = y + dy;\\n            if(validate(row, col, grid) && grid[row][col] === 1) {\\n                dfs(row, col);\\n            }\\n        }\\n    }\\n    for(let i = 0; i < grid.length; i++) {\\n        for(let j = 0; j < grid[0].length; j++) {\\n            if(grid[i][j] === 1) { \\n                dfs(i, j);\\n                islandMap.set(label, area);\\n                area = 0;\\n                label++;\\n            }\\n        }\\n    }\\n    return [grid, islandMap];\\n}\\n\\nconst searchLargest = ([grid, map]) => {\\n    let res = 0;\\n    for(let i = 0; i < grid.length; i++) {\\n        for(let j = 0; j < grid[0].length; j++) {\\n            if(grid[i][j] === 0) {\\n                let area = 1;\\n                const seen = new Set();\\n                for(const [di, dj] of dir) {\\n                    if(!validate(i + di, j + dj, grid)) continue;\\n                    const curr = grid[i + di][j + dj];\\n                    if(map.has(curr) && !seen.has(curr)) {\\n                        area += map.get(curr);\\n                        seen.add(curr);\\n                    }\\n                }\\n                res = Math.max(area, res);\\n            }\\n        }\\n    }\\n    return res ? res : grid.length * grid[0].length;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 127178,
                "title": "c-union-find-with-path-compression-union-by-rank",
                "content": "15ms runtime\\n1) Scan through grid\\n2) Union to previous neighbors(r-1 or c-1) if they are 1\\n3) Keep track of all zeros.\\n4) Loop through set of zeros & find the area possible if that zero is converted to one.\\n5) PROFIT\\n```\\nclass UF\\n{\\n    vector<int> p;\\n    vector<int> rank; // size of island\\n        \\n    public:\\n    UF(int n)\\n    {\\n        p=vector<int>(n*n,0);\\n        rank=vector<int>(n*n,0);\\n    }\\n    \\n    void makeSet(int i)\\n    {\\n        p[i]=i;\\n        rank[i]=1;\\n    }\\n    \\n    int findSet(int i)\\n    {\\n        while(i!=p[i])\\n        {\\n            p[i]=p[p[i]];\\n            i=p[i];\\n        }\\n        \\n        return i;\\n    }\\n    \\n    void Union(int a, int b)\\n    {\\n        int roota=findSet(a);\\n        int rootb=findSet(b);\\n        \\n        if(roota==rootb) return;\\n        \\n        if(rank[roota]>=rank[rootb])\\n        {\\n            p[rootb]=roota;\\n            rank[roota]+=rank[rootb];\\n        }\\n        else if(rank[roota]<rank[rootb])\\n        {\\n            p[roota]=rootb;\\n            rank[rootb]+=rank[roota];\\n        }\\n    }\\n    \\n    int getSize(int i)\\n    {\\n        int rooti=findSet(i);\\n        \\n        return rank[rooti];\\n    }\\n};\\n```\\n\\n```\\nclass Solution {\\n    \\n    int getPos(int r, int c, int C)\\n    {\\n        return (r*C)+c;\\n    }\\n    \\n    void getRC(int pos, int N, int& r, int& c)\\n    {\\n        r=pos/N;\\n        c=pos%N;\\n    }\\npublic:\\n    int largestIsland(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size();\\n        \\n        UF uf(n); // n*n\\n        \\n        vector<int> zeros;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                int curr_pos=getPos(i,j,n);\\n                \\n                if(grid[i][j]==1)\\n                {\\n                    uf.makeSet(curr_pos);\\n                    if(i>0 && grid[i-1][j]==1)\\n                    {\\n                        int prev_pos=getPos(i-1,j,n);\\n                        uf.Union(curr_pos,prev_pos);\\n                    }\\n                    \\n                    if(j>0 && grid[i][j-1]==1)\\n                    {\\n                        int prev_pos=getPos(i,j-1,n);\\n                        uf.Union(curr_pos,prev_pos);\\n                    }\\n                }\\n                else\\n                {\\n                    zeros.push_back(curr_pos);\\n                }\\n            }\\n        }\\n        \\n        int res=0;\\n        for(int i=0;i<zeros.size();i++)\\n        {\\n            unordered_set<int> nei;\\n            \\n            int r,c;\\n            getRC(zeros[i],n,r,c);\\n            \\n            if(r>0 && grid[r-1][c]==1)\\n            {\\n                int rootb=uf.findSet(getPos(r-1,c,n));\\n                nei.insert(rootb);\\n            }\\n            \\n            if(r<n-1 && grid[r+1][c]==1)\\n            {\\n                int rootb=uf.findSet(getPos(r+1,c,n));\\n                nei.insert(rootb);\\n            }\\n            \\n            if(c>0 && grid[r][c-1]==1)\\n            {\\n                int rootb=uf.findSet(getPos(r,c-1,n));\\n                nei.insert(rootb);\\n            }\\n            \\n            if(c<n-1 && grid[r][c+1]==1)\\n            {\\n                int rootb=uf.findSet(getPos(r,c+1,n));\\n                nei.insert(rootb);\\n            }\\n            \\n            int curr_area=0;\\n            for(auto& root: nei)\\n            {\\n                curr_area+=uf.getSize(root);\\n            }\\n            \\n            res=max(res,curr_area+1);\\n        }\\n        \\n        return (res==0)?n*n:res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass UF\\n{\\n    vector<int> p;\\n    vector<int> rank; // size of island\\n        \\n    public:\\n    UF(int n)\\n    {\\n        p=vector<int>(n*n,0);\\n        rank=vector<int>(n*n,0);\\n    }\\n    \\n    void makeSet(int i)\\n    {\\n        p[i]=i;\\n        rank[i]=1;\\n    }\\n    \\n    int findSet(int i)\\n    {\\n        while(i!=p[i])\\n        {\\n            p[i]=p[p[i]];\\n            i=p[i];\\n        }\\n        \\n        return i;\\n    }\\n    \\n    void Union(int a, int b)\\n    {\\n        int roota=findSet(a);\\n        int rootb=findSet(b);\\n        \\n        if(roota==rootb) return;\\n        \\n        if(rank[roota]>=rank[rootb])\\n        {\\n            p[rootb]=roota;\\n            rank[roota]+=rank[rootb];\\n        }\\n        else if(rank[roota]<rank[rootb])\\n        {\\n            p[roota]=rootb;\\n            rank[rootb]+=rank[roota];\\n        }\\n    }\\n    \\n    int getSize(int i)\\n    {\\n        int rooti=findSet(i);\\n        \\n        return rank[rooti];\\n    }\\n};\\n```\n```\\nclass Solution {\\n    \\n    int getPos(int r, int c, int C)\\n    {\\n        return (r*C)+c;\\n    }\\n    \\n    void getRC(int pos, int N, int& r, int& c)\\n    {\\n        r=pos/N;\\n        c=pos%N;\\n    }\\npublic:\\n    int largestIsland(vector<vector<int>>& grid) {\\n        \\n        int n=grid.size();\\n        \\n        UF uf(n); // n*n\\n        \\n        vector<int> zeros;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                int curr_pos=getPos(i,j,n);\\n                \\n                if(grid[i][j]==1)\\n                {\\n                    uf.makeSet(curr_pos);\\n                    if(i>0 && grid[i-1][j]==1)\\n                    {\\n                        int prev_pos=getPos(i-1,j,n);\\n                        uf.Union(curr_pos,prev_pos);\\n                    }\\n                    \\n                    if(j>0 && grid[i][j-1]==1)\\n                    {\\n                        int prev_pos=getPos(i,j-1,n);\\n                        uf.Union(curr_pos,prev_pos);\\n                    }\\n                }\\n                else\\n                {\\n                    zeros.push_back(curr_pos);\\n                }\\n            }\\n        }\\n        \\n        int res=0;\\n        for(int i=0;i<zeros.size();i++)\\n        {\\n            unordered_set<int> nei;\\n            \\n            int r,c;\\n            getRC(zeros[i],n,r,c);\\n            \\n            if(r>0 && grid[r-1][c]==1)\\n            {\\n                int rootb=uf.findSet(getPos(r-1,c,n));\\n                nei.insert(rootb);\\n            }\\n            \\n            if(r<n-1 && grid[r+1][c]==1)\\n            {\\n                int rootb=uf.findSet(getPos(r+1,c,n));\\n                nei.insert(rootb);\\n            }\\n            \\n            if(c>0 && grid[r][c-1]==1)\\n            {\\n                int rootb=uf.findSet(getPos(r,c-1,n));\\n                nei.insert(rootb);\\n            }\\n            \\n            if(c<n-1 && grid[r][c+1]==1)\\n            {\\n                int rootb=uf.findSet(getPos(r,c+1,n));\\n                nei.insert(rootb);\\n            }\\n            \\n            int curr_area=0;\\n            for(auto& root: nei)\\n            {\\n                curr_area+=uf.getSize(root);\\n            }\\n            \\n            res=max(res,curr_area+1);\\n        }\\n        \\n        return (res==0)?n*n:res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1458518,
                "title": "c-beat-90-runtime-space-usage-easy-to-understand-solution",
                "content": "First Round - find all islands, get sizes and marked with different colors (labeling and also avoid duplicated searches).\\nSecond Round - traverse all \\'0\\'s, find all adjacented islands to make a bigger one. Search the sizes in cache to get the size of the new island.\\n\\n```\\nclass Solution {\\npublic:\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int color = 2;\\n        unordered_map<int, int> sizes;\\n        for (int i = 0; i < grid.size(); i++)\\n            for (int j = 0; j < grid[0].size(); j++)\\n                if (grid[i][j] == 1)\\n                {\\n                    int count = 0;\\n                    colorize(grid, i, j, color, count);\\n                    sizes[color] = count;\\n                    color++;\\n                }\\n        \\n        int res = 1; \\n        for (auto kv:sizes)\\n            res = max(res, kv.second);\\n        \\n        for (int i = 0; i < grid.size(); i++)\\n            for (int j = 0; j < grid[0].size(); j++)\\n                if (grid[i][j] == 0)\\n                    res = max(res, change(grid, sizes, i, j));\\n        \\n        return res;\\n    }\\n    \\n    void colorize(vector<vector<int>>& grid, int i, int j, int color, int& count) {\\n        count++;\\n        grid[i][j] = color;\\n        if (i-1 >=0 && grid[i-1][j] == 1) colorize(grid, i-1, j, color, count);\\n        if (i+1 < grid.size() && grid[i+1][j] == 1) colorize(grid, i+1, j, color, count);\\n        if (j-1 >=0 && grid[i][j-1] == 1) colorize(grid, i, j-1, color, count);\\n        if (j+1 < grid[0].size() && grid[i][j+1] == 1) colorize(grid, i, j+1, color, count);\\n    }\\n    \\n    int change(vector<vector<int>>& grid, unordered_map<int, int>& sizes, int i, int j)\\n    {\\n        set<int> neighbors;\\n        if (i-1 >=0 && grid[i-1][j] > 1) neighbors.insert(grid[i-1][j]);\\n        if (i+1 < grid.size() && grid[i+1][j] > 1) neighbors.insert(grid[i+1][j]);\\n        if (j-1 >=0 && grid[i][j-1] > 1) neighbors.insert(grid[i][j-1]);\\n        if (j+1 < grid[0].size() && grid[i][j+1] > 1) neighbors.insert(grid[i][j+1]);\\n                                                                \\n        int res = 1;\\n        for (int c:neighbors)\\n            res += sizes[c];\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int color = 2;\\n        unordered_map<int, int> sizes;\\n        for (int i = 0; i < grid.size(); i++)\\n            for (int j = 0; j < grid[0].size(); j++)\\n                if (grid[i][j] == 1)\\n                {\\n                    int count = 0;\\n                    colorize(grid, i, j, color, count);\\n                    sizes[color] = count;\\n                    color++;\\n                }\\n        \\n        int res = 1; \\n        for (auto kv:sizes)\\n            res = max(res, kv.second);\\n        \\n        for (int i = 0; i < grid.size(); i++)\\n            for (int j = 0; j < grid[0].size(); j++)\\n                if (grid[i][j] == 0)\\n                    res = max(res, change(grid, sizes, i, j));\\n        \\n        return res;\\n    }\\n    \\n    void colorize(vector<vector<int>>& grid, int i, int j, int color, int& count) {\\n        count++;\\n        grid[i][j] = color;\\n        if (i-1 >=0 && grid[i-1][j] == 1) colorize(grid, i-1, j, color, count);\\n        if (i+1 < grid.size() && grid[i+1][j] == 1) colorize(grid, i+1, j, color, count);\\n        if (j-1 >=0 && grid[i][j-1] == 1) colorize(grid, i, j-1, color, count);\\n        if (j+1 < grid[0].size() && grid[i][j+1] == 1) colorize(grid, i, j+1, color, count);\\n    }\\n    \\n    int change(vector<vector<int>>& grid, unordered_map<int, int>& sizes, int i, int j)\\n    {\\n        set<int> neighbors;\\n        if (i-1 >=0 && grid[i-1][j] > 1) neighbors.insert(grid[i-1][j]);\\n        if (i+1 < grid.size() && grid[i+1][j] > 1) neighbors.insert(grid[i+1][j]);\\n        if (j-1 >=0 && grid[i][j-1] > 1) neighbors.insert(grid[i][j-1]);\\n        if (j+1 < grid[0].size() && grid[i][j+1] > 1) neighbors.insert(grid[i][j+1]);\\n                                                                \\n        int res = 1;\\n        for (int c:neighbors)\\n            res += sizes[c];\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1377233,
                "title": "c-dfs-faster-than-95",
                "content": "Try to understand the use of id and how we are using it to map the count\\'s val.\\n```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>>dir={{1,0},{0,1},{-1,0},{0,-1}};\\n    bool check(int i,int j,vector<vector<int>>& grid){\\n        if(i<grid.size()&&j<grid[0].size()&&i>=0&&j>=0&&grid[i][j]==1)return true;\\n        return false;\\n    }\\n    int dfs(vector<vector<int>>&grid,int i,int j,int&val,vector<vector<int>>&vis){\\n        int count=1;\\n        vis[i][j]=val;\\n        for(auto x:dir){\\n            if(check(i+x.first,j+x.second,grid)&&vis[i+x.first][j+x.second]!=val){\\n               count += dfs(grid,i+x.first,j+x.second,val,vis); \\n            }\\n        }\\n        return count;\\n    }\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int val=1;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>vis(n+1,vector<int>(m+1));\\n        vector<int>dp(n*m+2);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1&&vis[i][j]==0){\\n                    dp[val]=dfs(grid,i,j,val,vis);\\n                    val++;\\n                }\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j]==1){\\n                    ans=max(ans,dp[vis[i][j]]);\\n                }else{\\n                    int u=0,d=0,l=0,r=0,ui=0,di=0,li=0,ri=0;\\n                    if(i>0){\\n                        ui=vis[i-1][j];\\n                        u=dp[vis[i-1][j]];\\n                    }\\n                    if(i<n-1){\\n                        di=vis[i+1][j];\\n                        if(ui!=di)d=dp[vis[i+1][j]];\\n                    }\\n                    if(j>0){\\n                        li=vis[i][j-1];\\n                        if(li!=ui&&li!=di)l=dp[vis[i][j-1]];\\n                    }\\n                    if(j<m){\\n                        ri=vis[i][j+1];\\n                        if(ri!=li&&ri!=ui&&ri!=di)r=dp[vis[i][j+1]];\\n                    }\\n                    ans=max(ans,r+l+u+d+1);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>>dir={{1,0},{0,1},{-1,0},{0,-1}};\\n    bool check(int i,int j,vector<vector<int>>& grid){\\n        if(i<grid.size()&&j<grid[0].size()&&i>=0&&j>=0&&grid[i][j]==1)return true;\\n        return false;\\n    }\\n    int dfs(vector<vector<int>>&grid,int i,int j,int&val,vector<vector<int>>&vis){\\n        int count=1;\\n        vis[i][j]=val;\\n        for(auto x:dir){\\n            if(check(i+x.first,j+x.second,grid)&&vis[i+x.first][j+x.second]!=val){\\n               count += dfs(grid,i+x.first,j+x.second,val,vis); \\n            }\\n        }\\n        return count;\\n    }\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int val=1;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        vector<vector<int>>vis(n+1,vector<int>(m+1));\\n        vector<int>dp(n*m+2);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1&&vis[i][j]==0){\\n                    dp[val]=dfs(grid,i,j,val,vis);\\n                    val++;\\n                }\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j]==1){\\n                    ans=max(ans,dp[vis[i][j]]);\\n                }else{\\n                    int u=0,d=0,l=0,r=0,ui=0,di=0,li=0,ri=0;\\n                    if(i>0){\\n                        ui=vis[i-1][j];\\n                        u=dp[vis[i-1][j]];\\n                    }\\n                    if(i<n-1){\\n                        di=vis[i+1][j];\\n                        if(ui!=di)d=dp[vis[i+1][j]];\\n                    }\\n                    if(j>0){\\n                        li=vis[i][j-1];\\n                        if(li!=ui&&li!=di)l=dp[vis[i][j-1]];\\n                    }\\n                    if(j<m){\\n                        ri=vis[i][j+1];\\n                        if(ri!=li&&ri!=ui&&ri!=di)r=dp[vis[i][j+1]];\\n                    }\\n                    ans=max(ans,r+l+u+d+1);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 205334,
                "title": "readable-javascript-solution-beats-100",
                "content": "Strategy is to\\n1. Paint islands with an unique integer > 1 (i.e. 2 then 3... so on)\\n2. Loop through 0s and visit its neighboring islands.\\n3. Return the max of neighboring islands + 1\\n\\nThis seems like a lot of code but actually it\\'s really straight forward.\\n\\n```\\nconst DIRECTIONS = [[1,0], [-1,0], [0,1], [0,-1]];\\n\\nfunction largestIsland(grid) {\\n    if (!grid || !grid.length) return 0;\\n\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    let max = Number.MIN_VALUE;\\n    let count = 2;\\n    let map = {};\\n\\n    for (let i = 0; i < m; i++) {\\n        for (let j = 0; j < n; j++) {\\n            if (grid[i][j] === 1) {\\n                // mark the island\\n                const area = dfs(grid, i, j, count);\\n                max = Math.max(max, area);\\n                map[count] = area;\\n                count++;\\n            }\\n        }\\n    }\\n\\n    for (let i = 0; i < m; i++) {\\n        for (let j = 0; j < n; j++) {\\n            if (grid[i][j] === 0) {\\n                let set = new Set();\\n                let cur = 1;\\n\\n                // visit it\\'s neighbors\\n                for (let [row, col] of DIRECTIONS) {\\n                    const x = row + i;\\n                    const y = col + j;\\n\\n                    // bound check\\n                    if (x < 0 || x >= m || y < 0 || y >= n) continue;\\n\\n                    const islandId = grid[x][y];\\n                    if (islandId > 1 && !set.has(islandId)) {\\n                        set.add(islandId);\\n                        cur += map[islandId];\\n                    }\\n                }\\n                max = Math.max(max, cur);\\n            }\\n        }\\n    }\\n    return max;\\n}\\n\\nfunction dfs(grid, row, col, num) {\\n    // bound check\\n    if (row < 0 || row >= grid.length || col < 0 || col >= grid[0].length) return 0;\\n    if (grid[row][col] === 0 || grid[row][col] === num) return 0;\\n\\n    grid[row][col] = num;\\n    return 1 + dfs(grid, row + 1, col, num) + dfs(grid, row - 1, col, num) + \\n        dfs(grid, row, col + 1, num) + dfs(grid, row, col - 1, num);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nconst DIRECTIONS = [[1,0], [-1,0], [0,1], [0,-1]];\\n\\nfunction largestIsland(grid) {\\n    if (!grid || !grid.length) return 0;\\n\\n    const m = grid.length;\\n    const n = grid[0].length;\\n    let max = Number.MIN_VALUE;\\n    let count = 2;\\n    let map = {};\\n\\n    for (let i = 0; i < m; i++) {\\n        for (let j = 0; j < n; j++) {\\n            if (grid[i][j] === 1) {\\n                // mark the island\\n                const area = dfs(grid, i, j, count);\\n                max = Math.max(max, area);\\n                map[count] = area;\\n                count++;\\n            }\\n        }\\n    }\\n\\n    for (let i = 0; i < m; i++) {\\n        for (let j = 0; j < n; j++) {\\n            if (grid[i][j] === 0) {\\n                let set = new Set();\\n                let cur = 1;\\n\\n                // visit it\\'s neighbors\\n                for (let [row, col] of DIRECTIONS) {\\n                    const x = row + i;\\n                    const y = col + j;\\n\\n                    // bound check\\n                    if (x < 0 || x >= m || y < 0 || y >= n) continue;\\n\\n                    const islandId = grid[x][y];\\n                    if (islandId > 1 && !set.has(islandId)) {\\n                        set.add(islandId);\\n                        cur += map[islandId];\\n                    }\\n                }\\n                max = Math.max(max, cur);\\n            }\\n        }\\n    }\\n    return max;\\n}\\n\\nfunction dfs(grid, row, col, num) {\\n    // bound check\\n    if (row < 0 || row >= grid.length || col < 0 || col >= grid[0].length) return 0;\\n    if (grid[row][col] === 0 || grid[row][col] === num) return 0;\\n\\n    grid[row][col] = num;\\n    return 1 + dfs(grid, row + 1, col, num) + dfs(grid, row - 1, col, num) + \\n        dfs(grid, row, col + 1, num) + dfs(grid, row, col - 1, num);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 130132,
                "title": "java-unionfind-o-mn-time-complexity-22ms",
                "content": "You can simply use this as a template for most \"large islands\" problems.\\nFirst go over all grid and connect all single \"islands\", while counting their area. This is typical move for all island problem using UnionFind.\\nThen try inserting a \"1\" at every existing \"0\" postion on the grid. This time instead of \"connecting\" islands together, we only add all four neighbor \"islands\" area.\\n\\nSince we use compressed find here, the average runtime is O(mn).\\n\\n```\\nclass Solution {\\n    public int largestIsland(int[][] grid) {\\n        if (grid.length == 0 || grid[0].length == 0) return 0;\\n        int row = grid.length, col = grid[0].length;\\n        int[] father = new int[row * col];\\n        int[] area = new int[row * col];\\n        int[][] d = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        \\n        for (int i = 0; i < father.length; ++i) father[i] = i;\\n        \\n        int max = 0;\\n        for (int i = 0; i < row; ++i) {\\n            for (int j = 0; j < col; ++j) {\\n                if (grid[i][j] == 0) continue;\\n                int fy = i * col + j;\\n                area[fy] = 1;\\n                if (i > 0 && grid[i - 1][j] == 1) {\\n                    //int fx = find(father, i * col + j);\\n                    fy = find(father, i * col + j - col);\\n                    father[i * col + j] = fy;\\n                    area[fy]++;\\n                }\\n                if (j > 0 && grid[i][j - 1] == 1) {\\n                    int fx = find(father, i * col + j);\\n                    fy = find(father, i * col + j - 1);\\n                    if (fx != fy) {\\n                        father[fx] = fy;\\n                        area[fy] += area[fx];\\n                    }\\n                }\\n                max = Math.max(max, area[fy]);\\n            }\\n        }\\n        \\n        for (int i = 0; i < row; ++i) {\\n            for (int j = 0; j < col; ++j) {\\n                if (grid[i][j] == 1) continue;\\n                int f0 = i * col + j;\\n                area[f0] = 1;\\n                Set<Integer> nb = new HashSet();\\n                for (int k = 0; k < 4; ++k) {\\n                    int x = i + d[k][0], y = j + d[k][1];\\n                    if (x < 0 || y < 0 || x >= row || y >= col || grid[x][y] == 0)\\n                        continue;\\n                    int f1 = find(father, x * col + y);\\n                    if (!nb.contains(f1)) {\\n                        nb.add(f1);\\n                        area[f0] += area[f1];\\n                    }\\n                }\\n                max = Math.max(area[f0], max);\\n            }\\n        }\\n        return max;\\n    }\\n    \\n    private int find(int[] father, int x) {\\n        int parent = father[x];\\n        while (parent != father[parent]) {\\n            parent = father[parent];\\n        }\\n        int temp = -1;\\n        int fx = x;\\n        while (fx != parent) {\\n            temp = father[fx];\\n            father[fx] = parent;\\n            fx = temp;\\n        }\\n        return parent;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int largestIsland(int[][] grid) {\\n        if (grid.length == 0 || grid[0].length == 0) return 0;\\n        int row = grid.length, col = grid[0].length;\\n        int[] father = new int[row * col];\\n        int[] area = new int[row * col];\\n        int[][] d = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        \\n        for (int i = 0; i < father.length; ++i) father[i] = i;\\n        \\n        int max = 0;\\n        for (int i = 0; i < row; ++i) {\\n            for (int j = 0; j < col; ++j) {\\n                if (grid[i][j] == 0) continue;\\n                int fy = i * col + j;\\n                area[fy] = 1;\\n                if (i > 0 && grid[i - 1][j] == 1) {\\n                    //int fx = find(father, i * col + j);\\n                    fy = find(father, i * col + j - col);\\n                    father[i * col + j] = fy;\\n                    area[fy]++;\\n                }\\n                if (j > 0 && grid[i][j - 1] == 1) {\\n                    int fx = find(father, i * col + j);\\n                    fy = find(father, i * col + j - 1);\\n                    if (fx != fy) {\\n                        father[fx] = fy;\\n                        area[fy] += area[fx];\\n                    }\\n                }\\n                max = Math.max(max, area[fy]);\\n            }\\n        }\\n        \\n        for (int i = 0; i < row; ++i) {\\n            for (int j = 0; j < col; ++j) {\\n                if (grid[i][j] == 1) continue;\\n                int f0 = i * col + j;\\n                area[f0] = 1;\\n                Set<Integer> nb = new HashSet();\\n                for (int k = 0; k < 4; ++k) {\\n                    int x = i + d[k][0], y = j + d[k][1];\\n                    if (x < 0 || y < 0 || x >= row || y >= col || grid[x][y] == 0)\\n                        continue;\\n                    int f1 = find(father, x * col + y);\\n                    if (!nb.contains(f1)) {\\n                        nb.add(f1);\\n                        area[f0] += area[f1];\\n                    }\\n                }\\n                max = Math.max(area[f0], max);\\n            }\\n        }\\n        return max;\\n    }\\n    \\n    private int find(int[] father, int x) {\\n        int parent = father[x];\\n        while (parent != father[parent]) {\\n            parent = father[parent];\\n        }\\n        int temp = -1;\\n        int fx = x;\\n        while (fx != parent) {\\n            temp = father[fx];\\n            father[fx] = parent;\\n            fx = temp;\\n        }\\n        return parent;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 126962,
                "title": "java-union-find-solution",
                "content": "Save the union size in `size[]`\\n\\n```\\nclass Solution {\\n    class DSU {\\n        int[] parent;\\n        int[] rank;\\n        int[] size;\\n        DSU (int n) {\\n            parent = new int[n];\\n            rank = new int[n];\\n            size = new int[n];\\n            for (int i = 0; i < n; i++) {\\n                parent[i] = i;\\n                size[i] = 1;\\n            }\\n        }\\n        int find(int x) {\\n            if (parent[x] != x) {\\n                parent[x] = find(parent[x]);\\n            }\\n            return parent[x];\\n        }\\n        void union(int x, int y) {\\n            int rx = find(x);\\n            int ry = find(y);\\n            if (rx == ry) {\\n                return;\\n            }\\n            if (rank[rx] == rank[ry]) {\\n                rank[rx]++;\\n                parent[ry] = rx;\\n                size[rx] += size[ry];\\n            } else if (rank[rx] < rank[ry]) {\\n                parent[rx] = ry;\\n                size[ry] += size[rx];\\n            } else {\\n                parent[ry] = rx;\\n                size[rx] += size[ry];\\n            }\\n        }\\n    }\\n    public int largestIsland(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        DSU dsu = new DSU(m * n);\\n        int[][] dirs = new int[][]{{-1, 0}, {0, -1}, {0, 1}, {1, 0}};\\n        int result = 1;\\n        // Build up the DSU, record the largest union.\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    for (int d = 0; d < 2; d++) {\\n                        int row = i + dirs[d][0];\\n                        int col = j + dirs[d][1];\\n                        if (row >= 0 && col >= 0 && grid[row][col] == 1) {\\n                            dsu.union(i * n + j, row * n + col);\\n                            result = Math.max(result, dsu.size[dsu.find(i * n + j)]);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        // For each \\'0\\', calculate the area after changing.\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 0) {\\n                    Map<Integer, Integer> map = new HashMap<>();\\n                    for (int d = 0; d < 4; d++) {\\n                        int row = i + dirs[d][0];\\n                        int col = j + dirs[d][1];\\n                        if (row >= 0 && col >= 0 && row < m && col < n && grid[row][col] == 1) {\\n                            int parent = dsu.find(row * n + col);\\n                            map.put(parent, dsu.size[parent]);\\n                        }\\n                    }\\n                    int temp = 1;\\n                    for (int v : map.values()) {\\n                        temp += v;\\n                    }\\n                    result = Math.max(result, temp);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class DSU {\\n        int[] parent;\\n        int[] rank;\\n        int[] size;\\n        DSU (int n) {\\n            parent = new int[n];\\n            rank = new int[n];\\n            size = new int[n];\\n            for (int i = 0; i < n; i++) {\\n                parent[i] = i;\\n                size[i] = 1;\\n            }\\n        }\\n        int find(int x) {\\n            if (parent[x] != x) {\\n                parent[x] = find(parent[x]);\\n            }\\n            return parent[x];\\n        }\\n        void union(int x, int y) {\\n            int rx = find(x);\\n            int ry = find(y);\\n            if (rx == ry) {\\n                return;\\n            }\\n            if (rank[rx] == rank[ry]) {\\n                rank[rx]++;\\n                parent[ry] = rx;\\n                size[rx] += size[ry];\\n            } else if (rank[rx] < rank[ry]) {\\n                parent[rx] = ry;\\n                size[ry] += size[rx];\\n            } else {\\n                parent[ry] = rx;\\n                size[rx] += size[ry];\\n            }\\n        }\\n    }\\n    public int largestIsland(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        DSU dsu = new DSU(m * n);\\n        int[][] dirs = new int[][]{{-1, 0}, {0, -1}, {0, 1}, {1, 0}};\\n        int result = 1;\\n        // Build up the DSU, record the largest union.\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    for (int d = 0; d < 2; d++) {\\n                        int row = i + dirs[d][0];\\n                        int col = j + dirs[d][1];\\n                        if (row >= 0 && col >= 0 && grid[row][col] == 1) {\\n                            dsu.union(i * n + j, row * n + col);\\n                            result = Math.max(result, dsu.size[dsu.find(i * n + j)]);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        // For each \\'0\\', calculate the area after changing.\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 0) {\\n                    Map<Integer, Integer> map = new HashMap<>();\\n                    for (int d = 0; d < 4; d++) {\\n                        int row = i + dirs[d][0];\\n                        int col = j + dirs[d][1];\\n                        if (row >= 0 && col >= 0 && row < m && col < n && grid[row][col] == 1) {\\n                            int parent = dsu.find(row * n + col);\\n                            map.put(parent, dsu.size[parent]);\\n                        }\\n                    }\\n                    int temp = 1;\\n                    for (int v : map.values()) {\\n                        temp += v;\\n                    }\\n                    result = Math.max(result, temp);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2175010,
                "title": "c-find-components-around-0s-dsu-o-n-2-time-and-space",
                "content": "```\\n/* \\n    Time: O(n^2)\\n    Space: O(n^2)\\n    Tag: DSU, Matrix, Graph\\n    Difficulty: M\\n*/\\n\\nclass Solution {\\n\\n    vector<int> parent;\\n    vector<int> rank;\\n\\n    int find_(int node) {\\n        return parent[node] == -1 ? node : parent[node] = find_(parent[node]);\\n    }\\n\\n    void union_(int node1, int node2) {\\n        node1 = find_(node1);\\n        node2 = find_(node2);\\n\\n        if (node1 != node2) {\\n            if (rank[node1] < rank[node2]) {\\n                parent[node1] = node2;\\n                rank[node2] += rank[node1];\\n            } else {\\n                parent[node2] = node1;\\n                rank[node1] += rank[node2];\\n            }\\n        }\\n    }\\n\\npublic:\\n    int largestIsland(vector<vector<int>> &grid) {\\n        int n = grid.size();\\n        parent.resize(n * n, -1);\\n        rank.resize(n * n, 1);\\n\\n        vector<pair<int, int>> moves = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j]) {\\n                    for (auto move : moves) {\\n                        if (i + move.first >= 0 && j + move.second >= 0 && i + move.first < n && j + move.second < n && grid[i + move.first][j + move.second]) {\\n                            union_(i * n + j, (i + move.first) * n + (j + move.second));\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        int res = *max_element(rank.begin(), rank.end());\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 0) {\\n                    int curRes = 0;\\n                    unordered_set<int> st;\\n                    for (auto move : moves) {\\n                        if (i + move.first >= 0 && j + move.second >= 0 && i + move.first < n && j + move.second < n && grid[i + move.first][j + move.second]) {\\n                            int comp = find_((i + move.first) * n + (j + move.second));\\n                            if (st.find(comp) == st.end()) {\\n                                curRes += rank[comp];\\n                                st.insert(comp);\\n                            }\\n                        }\\n                        res = max(res, 1 + curRes);\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find",
                    "Matrix"
                ],
                "code": "```\\n/* \\n    Time: O(n^2)\\n    Space: O(n^2)\\n    Tag: DSU, Matrix, Graph\\n    Difficulty: M\\n*/\\n\\nclass Solution {\\n\\n    vector<int> parent;\\n    vector<int> rank;\\n\\n    int find_(int node) {\\n        return parent[node] == -1 ? node : parent[node] = find_(parent[node]);\\n    }\\n\\n    void union_(int node1, int node2) {\\n        node1 = find_(node1);\\n        node2 = find_(node2);\\n\\n        if (node1 != node2) {\\n            if (rank[node1] < rank[node2]) {\\n                parent[node1] = node2;\\n                rank[node2] += rank[node1];\\n            } else {\\n                parent[node2] = node1;\\n                rank[node1] += rank[node2];\\n            }\\n        }\\n    }\\n\\npublic:\\n    int largestIsland(vector<vector<int>> &grid) {\\n        int n = grid.size();\\n        parent.resize(n * n, -1);\\n        rank.resize(n * n, 1);\\n\\n        vector<pair<int, int>> moves = {{0, 1}, {0, -1}, {-1, 0}, {1, 0}};\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j]) {\\n                    for (auto move : moves) {\\n                        if (i + move.first >= 0 && j + move.second >= 0 && i + move.first < n && j + move.second < n && grid[i + move.first][j + move.second]) {\\n                            union_(i * n + j, (i + move.first) * n + (j + move.second));\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        int res = *max_element(rank.begin(), rank.end());\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 0) {\\n                    int curRes = 0;\\n                    unordered_set<int> st;\\n                    for (auto move : moves) {\\n                        if (i + move.first >= 0 && j + move.second >= 0 && i + move.first < n && j + move.second < n && grid[i + move.first][j + move.second]) {\\n                            int comp = find_((i + move.first) * n + (j + move.second));\\n                            if (st.find(comp) == st.end()) {\\n                                curRes += rank[comp];\\n                                st.insert(comp);\\n                            }\\n                        }\\n                        res = max(res, 1 + curRes);\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1864499,
                "title": "c-dfs-solution",
                "content": "```\\nclass Solution {\\n    int dx[4]={-1, 1, 0, 0}, dy[4]={0, 0, 1, -1};\\npublic:\\n    void dfs(int x, int y, vector<vector<int>>&grid, int &num, int &count, int &n, int &m){\\n        if(x<0 || x>=n || y<0 || y>=m || grid[x][y]!=1){\\n            return;\\n        }\\n        grid[x][y]=num;\\n        count++;\\n        for(int i=0;i<4;i++){\\n            dfs(x+dx[i], y+dy[i], grid, num, count, n, m);\\n        }\\n    }\\n    \\n    int largestIsland(vector<vector<int>>& grid) {\\n        unordered_map<int,int>mp;\\n        int n=grid.size(), m=grid[0].size();\\n        int count, num=2;\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1)\\n                {\\n                    //assign a number to each island and then assign number to each node of island\\n                    //store the count for each island number\\n                    count=0;\\n                    dfs(i, j, grid, num, count, n, m);\\n                    mp[num]=count;\\n                    num++;\\n                    ans=max(ans, count);\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==0){\\n                    int island1=(i>0 && grid[i-1][j]? grid[i-1][j]: -1);\\n                    int island2=(i<n-1 && grid[i+1][j]? grid[i+1][j]: -1);\\n                    int island3=(j>0 && grid[i][j-1]? grid[i][j-1]: -1);\\n                    int island4=(j<m-1 && grid[i][j+1]? grid[i][j+1]: -1);\\n                    int sum=0;\\n                    if(island1!=-1)\\n                        sum+=mp[island1];\\n                    if(island2!=-1 && island2!=island1){\\n                        sum+=mp[island2];\\n                    }\\n                    if(island3!=-1 && island3!=island1 && island3!=island2){\\n                        sum+=mp[island3];\\n                    }\\n                    if(island4!=-1 && island4!=island1 && island4!=island2 && island4!=island3){\\n                        sum+=mp[island4];\\n                    }\\n                    sum++;\\n                    ans=max(ans, sum);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    int dx[4]={-1, 1, 0, 0}",
                "codeTag": "Java"
            },
            {
                "id": 1377892,
                "title": "how-to-approch-this-question-with-visualization-o-n-2",
                "content": "I am writting this solution by considering You have idea about how to solve **695. Max Area of Island**\\n\\n* **Step 1 :** we will do dfs and give index to each island to distinguish .(simply by one more parameter index).\\n* **Step  2 :** then we map index  to area of each island , means area of island corressponding to that index island (Using HashMap)\\n* **Step3 :**  then explore all zero\\'s and simply find all its neighbour and sum the area of neighbour of zero and find global maximum.\\n\\nLet Visualize how our matrix look after doing dfs \\n\\ngrid[] =\\n{0,0,**1**,0,0,0,0,**1**,0,0,0,0,0},\\n{0,0,0,0,0,0,0,**1,1,1**,0,0,0},\\n{0,**1,1**,0,**1**,0,0,0,0,0,0,0,0},\\n{0,**1**,0,0,**1,1**,0,0,**1**,0,**1**,0,0},\\n{0,**1**,0,0,**1,1**,0,0,**1,1,1**,0,0},\\n{0,0,0,0,0,0,0,0,0,0,**1**,0,0},\\n{0,0,0,0,0,0,0,**1,1,1**,0,0,0},\\n{0,0,0,0,0,0,0,**1,1**,0,0,0,0} \\n\\n\\n\\n\\n```\\nvisited array\\n\\n0  0  1  0  0  0  0  2  0  0  0  0  0  \\n0  0  0  0  0  0  0  2  2  2  0  0  0  \\n0  3  3  0  4  0  0  0  0  0  0  0  0  \\n0  3  0  0  4  4  0  0  5  0  5  0  0  \\n0  3  0  0  4  4  0  0  5  5  5  0  0  \\n0  0  0  0  0  0  0  0  0  0  5  0  0  \\n0  0  0  0  0  0  0  6  6  6  0  0  0  \\n0  0  0  0  0  0  0  6  6  0  0  0  0 \\n``` \\n```\\n\\nhashMap =>   {1=1, 2=4, 3=4, 4=5, 5=6, 6=5}\\nIndex 1 island size 1 ,index 2 island size 4, index 3 island size 4 ans so on\\n\\n```\\n\\n**now we can explore all zeros and  its neighbour , and find overall maximum size island after traversing whole grid**\\n\\n\\n\\n```\\nSimple 2 more function `\\n\\n1  dfs(grid,i,j,isVisited,index)\\n1.  valid(grid ,,X ,Y)\\n```\\n\\n\\n**putting comment for better understanding****\\n\\n```\\n  public static int largestIsland(int[][] grid) {\\n        int row  =  grid.length;\\n        int col  =  grid[0].length;\\n        \\n        int isVisited[][]  =  new int[row][col];\\n        HashMap<Integer,Integer>map=  new HashMap<>();\\n        int maxArea = 0;\\n        int index  = 1; // island index to distinguish\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++ ){\\n                if(grid[i][j]==1  && isVisited[i][j]<=0 ){\\n                \\t// maping area to index of that island \\n                    map.put(index,dfs(grid,i,j,isVisited,index));\\n                    maxArea  =  Math.max(map.get(index),maxArea);\\n                    index++;\\n                }                \\n            }\\n            \\n        }\\n        \\n//        Till this we have isVisited matrix containing all insland identified by index , see above visited array\\n        \\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++ ){\\n                \\n                if(grid[i][j]==0){\\n                \\tint area  = 0;\\n                  // find all valid neighbour of 0  \\n                int dir[][] =  {{0,1},{1,0},{0,-1},{-1,0}};\\n                HashSet<Integer> set  =  new HashSet<Integer>();\\n                // using hashset to avoid duplicate neighbour\\n                 for(int d[]:dir){\\n                    int newX =  i+d[0];\\n                    int newY =  j+d[1];\\n                    if(isValid(grid,newX,newY) ){\\n                    set.add(isVisited[newX][newY]);\\n                        }                \\n                    }\\n               \\n                 \\n                    // then sum area of all neighbour\\n                    for(Integer idx :set){\\n                   \\t\\n                        area+= map.getOrDefault(idx,0);\\n                    }                    \\n                    maxArea  = Math.max(maxArea,area+1);\\n                }\\n              \\n            }\\n            \\n        }\\n        return maxArea;\\n    }\\n      private static int dfs(int grid[][] , int x,int y, int isVisited[][],int index){\\n        // for x,y cell explore all its neighbour                 \\n        if(grid[x][y]==0) return 0 ;\\n        isVisited[x][y] = index;\\n        int dir[][] =  {{0,1},{1,0},{0,-1},{-1,0}};\\n        int count  = 1;\\n        for(int d[]:dir){\\n            int newX =  x+d[0];\\n            int newY =  y+d[1];\\n            if(isValid(grid,newX,newY) && isVisited[newX][newY] <=0){\\n                \\n                  count+=dfs(grid,newX,newY,isVisited,index);\\n                \\n            }\\n        }\\n     return count;\\n    }\\n    private static boolean isValid(int grid[][],int x,int y){\\n        return  !(x<0 || x>=grid.length || y<0 || y>= grid[0].length);        \\n    }\\n    \\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nvisited array\\n\\n0  0  1  0  0  0  0  2  0  0  0  0  0  \\n0  0  0  0  0  0  0  2  2  2  0  0  0  \\n0  3  3  0  4  0  0  0  0  0  0  0  0  \\n0  3  0  0  4  4  0  0  5  0  5  0  0  \\n0  3  0  0  4  4  0  0  5  5  5  0  0  \\n0  0  0  0  0  0  0  0  0  0  5  0  0  \\n0  0  0  0  0  0  0  6  6  6  0  0  0  \\n0  0  0  0  0  0  0  6  6  0  0  0  0 \\n```\n```\\n\\nhashMap =>   {1=1, 2=4, 3=4, 4=5, 5=6, 6=5}\\nIndex 1 island size 1 ,index 2 island size 4, index 3 island size 4 ans so on\\n\\n```\n```\\nSimple 2 more function `\\n\\n1  dfs(grid,i,j,isVisited,index)\\n1.  valid(grid ,,X ,Y)\\n```\n```\\n  public static int largestIsland(int[][] grid) {\\n        int row  =  grid.length;\\n        int col  =  grid[0].length;\\n        \\n        int isVisited[][]  =  new int[row][col];\\n        HashMap<Integer,Integer>map=  new HashMap<>();\\n        int maxArea = 0;\\n        int index  = 1; // island index to distinguish\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++ ){\\n                if(grid[i][j]==1  && isVisited[i][j]<=0 ){\\n                \\t// maping area to index of that island \\n                    map.put(index,dfs(grid,i,j,isVisited,index));\\n                    maxArea  =  Math.max(map.get(index),maxArea);\\n                    index++;\\n                }                \\n            }\\n            \\n        }\\n        \\n//        Till this we have isVisited matrix containing all insland identified by index , see above visited array\\n        \\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++ ){\\n                \\n                if(grid[i][j]==0){\\n                \\tint area  = 0;\\n                  // find all valid neighbour of 0  \\n                int dir[][] =  {{0,1},{1,0},{0,-1},{-1,0}};\\n                HashSet<Integer> set  =  new HashSet<Integer>();\\n                // using hashset to avoid duplicate neighbour\\n                 for(int d[]:dir){\\n                    int newX =  i+d[0];\\n                    int newY =  j+d[1];\\n                    if(isValid(grid,newX,newY) ){\\n                    set.add(isVisited[newX][newY]);\\n                        }                \\n                    }\\n               \\n                 \\n                    // then sum area of all neighbour\\n                    for(Integer idx :set){\\n                   \\t\\n                        area+= map.getOrDefault(idx,0);\\n                    }                    \\n                    maxArea  = Math.max(maxArea,area+1);\\n                }\\n              \\n            }\\n            \\n        }\\n        return maxArea;\\n    }\\n      private static int dfs(int grid[][] , int x,int y, int isVisited[][],int index){\\n        // for x,y cell explore all its neighbour                 \\n        if(grid[x][y]==0) return 0 ;\\n        isVisited[x][y] = index;\\n        int dir[][] =  {{0,1},{1,0},{0,-1},{-1,0}};\\n        int count  = 1;\\n        for(int d[]:dir){\\n            int newX =  x+d[0];\\n            int newY =  y+d[1];\\n            if(isValid(grid,newX,newY) && isVisited[newX][newY] <=0){\\n                \\n                  count+=dfs(grid,newX,newY,isVisited,index);\\n                \\n            }\\n        }\\n     return count;\\n    }\\n    private static boolean isValid(int grid[][],int x,int y){\\n        return  !(x<0 || x>=grid.length || y<0 || y>= grid[0].length);        \\n    }\\n    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1376885,
                "title": "c-beats-96-49-cpp-user",
                "content": "### We run simple DFS on a cell , so that we traverse the whole Island and mark that Island in the visited array as a unique value. We also remember the area realted to the corresponding value which represents each Island.\\n\\nConsider the follwing matrix -> \\n\\n|0|0|1|0|0|\\n|-|-|-|-|-|\\n|0|0|1|0|0|\\n|1|0|1|0|1|\\n|0|0|1|0|0|\\n|1|1|0|1|1|\\n\\nNow if we run a dfs and mark all the island with unique values in visited array :\\n|0|0|1|0|0|\\n|-|-|-|-|-|\\n|0|0|1|0|0|\\n|2|0|1|0|3|\\n|0|0|1|0|0|\\n|4|4|0|5|5|\\n\\nAnd also store the area of the corresponding value in a separate array :\\n|area|0|4|1|1|2|2|\\n|-|-|-|-|-|-|-|\\n|index|0|1|2|3|4|5|\\n\\nSo for every cell in the grid with value 0 we calculate the area by adding all the Island areas on the 4 sides , marked by underlines ->\\n\\n|0|<U>5</U>|1|<U>5</U>|0|\\n|-|-|-|-|-|\\n|<U>2</U>|<U>5</U>|1|<U>5</U>|<U>2</U>|\\n|1|<U>6</U>|1|<U>6</U>|1|\\n|<U>4</U>|<U>7</U>|1|<U>7</U>|<U>4</U>|\\n|1|1|<U>9</U>|1|1|\\n\\nSo among the underlined values we return the max value.\\n\\nIf there are no zeroes return the size of the grid.\\n\\n```c++\\nclass Solution {\\npublic:\\n    vector <pair<int,int>> dir = {{1,0},{0,1},{-1,0},{0,-1}};\\n    int vis[501][501];\\n    bool check(int i,int j,vector<vector<int>>& grid){\\n        if(i>=0 && i<grid.size() && j>=0 && j<grid[0].size() && grid[i][j] == 1)\\n            return true;\\n        return false;\\n    }\\n    int dfs(vector<vector<int>>& grid,int i,int j,int &val){\\n        int count = 1;\\n        vis[i][j] = val;\\n        for(auto x:dir){\\n            if(check(i+x.first,j+x.second,grid) && vis[i+x.first][j+x.second] != val)\\n                count += dfs(grid,i+x.first,j+x.second,val);\\n        }\\n        return count;\\n    }\\n    int largestIsland(vector<vector<int>>& grid) {\\n        memset(vis,0,sizeof(vis));\\n        int val = 1;\\n        int dp[grid.size()*grid[0].size()+2];\\n        memset(dp,0,sizeof(dp));\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j] == 1 && vis[i][j] == 0){\\n                    dp[val] = dfs(grid,i,j,val);\\n                    val++;\\n                }\\n            }  \\n        }\\n        int ans = 0;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j] == 0){\\n                    int temp = 1;\\n                    map<int,int> mp;\\n                    if(i-1>=0 && vis[i-1][j]){\\n                        temp += dp[vis[i-1][j]];\\n                        mp[vis[i-1][j]]++;\\n                    }\\n                    if(j-1>=0 && vis[i][j-1] && !mp[vis[i][j-1]]){\\n                        temp += dp[vis[i][j-1]];\\n                        mp[vis[i][j-1]]++;\\n                    }\\n                    if(i+1<grid.size() && vis[i+1][j] && !mp[vis[i+1][j]]){\\n                        temp += dp[vis[i+1][j]];\\n                        mp[vis[i+1][j]]++;\\n                    }\\n                    if(j+1<grid[0].size() && vis[i][j+1] && !mp[vis[i][j+1]]){\\n                        temp += dp[vis[i][j+1]];\\n                        mp[vis[i][j+1]]++;\\n                    }\\n                    ans = max(ans,temp);\\n                }\\n            }  \\n        }\\n        return ans == 0 ? grid.size()*grid[0].size() : ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    vector <pair<int,int>> dir = {{1,0},{0,1},{-1,0},{0,-1}};\\n    int vis[501][501];\\n    bool check(int i,int j,vector<vector<int>>& grid){\\n        if(i>=0 && i<grid.size() && j>=0 && j<grid[0].size() && grid[i][j] == 1)\\n            return true;\\n        return false;\\n    }\\n    int dfs(vector<vector<int>>& grid,int i,int j,int &val){\\n        int count = 1;\\n        vis[i][j] = val;\\n        for(auto x:dir){\\n            if(check(i+x.first,j+x.second,grid) && vis[i+x.first][j+x.second] != val)\\n                count += dfs(grid,i+x.first,j+x.second,val);\\n        }\\n        return count;\\n    }\\n    int largestIsland(vector<vector<int>>& grid) {\\n        memset(vis,0,sizeof(vis));\\n        int val = 1;\\n        int dp[grid.size()*grid[0].size()+2];\\n        memset(dp,0,sizeof(dp));\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j] == 1 && vis[i][j] == 0){\\n                    dp[val] = dfs(grid,i,j,val);\\n                    val++;\\n                }\\n            }  \\n        }\\n        int ans = 0;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[0].size();j++){\\n                if(grid[i][j] == 0){\\n                    int temp = 1;\\n                    map<int,int> mp;\\n                    if(i-1>=0 && vis[i-1][j]){\\n                        temp += dp[vis[i-1][j]];\\n                        mp[vis[i-1][j]]++;\\n                    }\\n                    if(j-1>=0 && vis[i][j-1] && !mp[vis[i][j-1]]){\\n                        temp += dp[vis[i][j-1]];\\n                        mp[vis[i][j-1]]++;\\n                    }\\n                    if(i+1<grid.size() && vis[i+1][j] && !mp[vis[i+1][j]]){\\n                        temp += dp[vis[i+1][j]];\\n                        mp[vis[i+1][j]]++;\\n                    }\\n                    if(j+1<grid[0].size() && vis[i][j+1] && !mp[vis[i][j+1]]){\\n                        temp += dp[vis[i][j+1]];\\n                        mp[vis[i][j+1]]++;\\n                    }\\n                    ans = max(ans,temp);\\n                }\\n            }  \\n        }\\n        return ans == 0 ? grid.size()*grid[0].size() : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1340782,
                "title": "python-clean-dfs",
                "content": "**\\'area\\' maps the id of an island to its area, and \\'address\\' maps each land piece to the id of the island that it belongs to.**\\n```\\nclass Solution:\\n    def largestIsland(self, grid: List[List[int]]) -> int:\\n        N = len(grid)\\n        DIRECTIONS = [(-1, 0), (0, -1), (0, 1), (1, 0)]\\n        \\n\\t\\taddress = {}\\n        def dfs(row, column, island_id):\\n            queue = deque([(row, column, island_id)])\\n            visited.add((row, column))\\n            area = 1\\n            while queue: \\n                row, column, island_id = queue.pop()\\n                address[(row, column)] = island_id\\n                for direction in DIRECTIONS:\\n                    r, c = row + direction[0], column + direction[1]\\n                    if r in range(N) and c in range(N) and grid[r][c] == 1 and (r, c) not in visited:\\n                        queue.append((r, c, island_id))\\n                        visited.add((r, c))\\n                        area += 1\\n            return area\\n        \\n        visited = set()\\n        area = {}\\n        island_id = 0\\n        for row in range(N):\\n            for column in range(N):\\n                if grid[row][column] == 1 and (row, column) not in visited:\\n                    area[island_id] = dfs(row, column, island_id)\\n                    island_id += 1\\n                    \\n        if len(address.keys()) == N**2: return N**2   \\n        \\n        largest_area = 1\\n        for row in range(N):\\n            for column in range(N):\\n                if grid[row][column] == 1: continue\\n                neighbours = set()\\n                large_area = 1\\n                for direction in DIRECTIONS:\\n                    r, c = row + direction[0], column + direction[1]\\n                    if r in range(N) and c in range(N) and grid[r][c] == 1 and address[(r, c)] not in neighbours:\\n                        neighbours.add(address[(r, c)])\\n                        large_area += area[address[(r, c)]]\\n                largest_area = max(largest_area, large_area)\\n                \\n        return largest_area\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def largestIsland(self, grid: List[List[int]]) -> int:\\n        N = len(grid)\\n        DIRECTIONS = [(-1, 0), (0, -1), (0, 1), (1, 0)]\\n        \\n\\t\\taddress = {}\\n        def dfs(row, column, island_id):\\n            queue = deque([(row, column, island_id)])\\n            visited.add((row, column))\\n            area = 1\\n            while queue: \\n                row, column, island_id = queue.pop()\\n                address[(row, column)] = island_id\\n                for direction in DIRECTIONS:\\n                    r, c = row + direction[0], column + direction[1]\\n                    if r in range(N) and c in range(N) and grid[r][c] == 1 and (r, c) not in visited:\\n                        queue.append((r, c, island_id))\\n                        visited.add((r, c))\\n                        area += 1\\n            return area\\n        \\n        visited = set()\\n        area = {}\\n        island_id = 0\\n        for row in range(N):\\n            for column in range(N):\\n                if grid[row][column] == 1 and (row, column) not in visited:\\n                    area[island_id] = dfs(row, column, island_id)\\n                    island_id += 1\\n                    \\n        if len(address.keys()) == N**2: return N**2   \\n        \\n        largest_area = 1\\n        for row in range(N):\\n            for column in range(N):\\n                if grid[row][column] == 1: continue\\n                neighbours = set()\\n                large_area = 1\\n                for direction in DIRECTIONS:\\n                    r, c = row + direction[0], column + direction[1]\\n                    if r in range(N) and c in range(N) and grid[r][c] == 1 and address[(r, c)] not in neighbours:\\n                        neighbours.add(address[(r, c)])\\n                        large_area += area[address[(r, c)]]\\n                largest_area = max(largest_area, large_area)\\n                \\n        return largest_area\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1310016,
                "title": "python3-union-find",
                "content": "\\n```\\nclass UnionFind:\\n    def __init__(self, n): \\n        self.parent = list(range(n))\\n        self.rank = [1] * n \\n        \\n    def find(self, p): \\n        if self.parent[p] != p: \\n            self.parent[p] = self.find(self.parent[p])\\n        return self.parent[p]\\n    \\n    def union(self, p, q): \\n        prt, qrt = self.find(p), self.find(q)\\n        if prt == qrt: return False \\n        if self.rank[prt] > self.rank[qrt]: prt, qrt = qrt, prt\\n        self.parent[prt] = qrt\\n        self.rank[qrt] += self.rank[prt] \\n        return True \\n    \\n\\nclass Solution:\\n    def largestIsland(self, grid: List[List[int]]) -> int:\\n        n = len(grid) # dimension \\n        uf = UnionFind(n*n)\\n        for i in range(n):\\n            for j in range(n): \\n                if grid[i][j]: \\n                    for (ii, jj) in (i-1, j), (i, j-1): \\n                        if 0 <= ii < n and 0 <= jj < n and grid[ii][jj]: uf.union(i*n+j, ii*n+jj)\\n        \\n        freq = defaultdict(int)\\n        for i in range(n*n): freq[uf.find(i)] += 1\\n        \\n        ans = 0 \\n        for i in range(n): \\n            for j in range(n): \\n                if grid[i][j]: ans = max(ans, freq[uf.find(i*n+j)])\\n                else: \\n                    cand = 1\\n                    seen = set()\\n                    for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): \\n                        if 0 <= ii < n and 0 <= jj < n: \\n                            if grid[ii][jj]: \\n                                key = uf.find(ii*n + jj)\\n                                if key not in seen: \\n                                    seen.add(key)\\n                                    cand += freq[key]\\n                    ans = max(ans, cand)\\n        return ans \\n```\\n\\n\\n```\\nclass Solution:\\n    def largestIsland(self, grid: List[List[int]]) -> int:\\n        n = len(grid) \\n        v = 2 \\n        freq = defaultdict(int)\\n        for r in range(n): \\n            for c in range(n): \\n                if grid[r][c] == 1: \\n                    stack = [(r, c)]\\n                    grid[r][c] = v\\n                    while stack: \\n                        i, j = stack.pop()\\n                        freq[v] += 1\\n                        for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): \\n                            if 0 <= ii < n and 0 <= jj < n and grid[ii][jj] == 1: \\n                                stack.append((ii, jj))\\n                                grid[ii][jj] = v\\n                    v += 1\\n                    \\n        ans = max(freq.values(), default=0)\\n        for i in range(n): \\n            for j in range(n): \\n                if grid[i][j] == 0: \\n                    cand = 1\\n                    seen = set()\\n                    for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): \\n                        if 0 <= ii < n and 0 <= jj < n and grid[ii][jj] and grid[ii][jj] not in seen: \\n                            seen.add(grid[ii][jj])\\n                            cand += freq[grid[ii][jj]]\\n                    ans = max(ans, cand)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass UnionFind:\\n    def __init__(self, n): \\n        self.parent = list(range(n))\\n        self.rank = [1] * n \\n        \\n    def find(self, p): \\n        if self.parent[p] != p: \\n            self.parent[p] = self.find(self.parent[p])\\n        return self.parent[p]\\n    \\n    def union(self, p, q): \\n        prt, qrt = self.find(p), self.find(q)\\n        if prt == qrt: return False \\n        if self.rank[prt] > self.rank[qrt]: prt, qrt = qrt, prt\\n        self.parent[prt] = qrt\\n        self.rank[qrt] += self.rank[prt] \\n        return True \\n    \\n\\nclass Solution:\\n    def largestIsland(self, grid: List[List[int]]) -> int:\\n        n = len(grid) # dimension \\n        uf = UnionFind(n*n)\\n        for i in range(n):\\n            for j in range(n): \\n                if grid[i][j]: \\n                    for (ii, jj) in (i-1, j), (i, j-1): \\n                        if 0 <= ii < n and 0 <= jj < n and grid[ii][jj]: uf.union(i*n+j, ii*n+jj)\\n        \\n        freq = defaultdict(int)\\n        for i in range(n*n): freq[uf.find(i)] += 1\\n        \\n        ans = 0 \\n        for i in range(n): \\n            for j in range(n): \\n                if grid[i][j]: ans = max(ans, freq[uf.find(i*n+j)])\\n                else: \\n                    cand = 1\\n                    seen = set()\\n                    for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): \\n                        if 0 <= ii < n and 0 <= jj < n: \\n                            if grid[ii][jj]: \\n                                key = uf.find(ii*n + jj)\\n                                if key not in seen: \\n                                    seen.add(key)\\n                                    cand += freq[key]\\n                    ans = max(ans, cand)\\n        return ans \\n```\n```\\nclass Solution:\\n    def largestIsland(self, grid: List[List[int]]) -> int:\\n        n = len(grid) \\n        v = 2 \\n        freq = defaultdict(int)\\n        for r in range(n): \\n            for c in range(n): \\n                if grid[r][c] == 1: \\n                    stack = [(r, c)]\\n                    grid[r][c] = v\\n                    while stack: \\n                        i, j = stack.pop()\\n                        freq[v] += 1\\n                        for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): \\n                            if 0 <= ii < n and 0 <= jj < n and grid[ii][jj] == 1: \\n                                stack.append((ii, jj))\\n                                grid[ii][jj] = v\\n                    v += 1\\n                    \\n        ans = max(freq.values(), default=0)\\n        for i in range(n): \\n            for j in range(n): \\n                if grid[i][j] == 0: \\n                    cand = 1\\n                    seen = set()\\n                    for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): \\n                        if 0 <= ii < n and 0 <= jj < n and grid[ii][jj] and grid[ii][jj] not in seen: \\n                            seen.add(grid[ii][jj])\\n                            cand += freq[grid[ii][jj]]\\n                    ans = max(ans, cand)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 478199,
                "title": "javascript-two-simple-solutions-but-not-the-fastest",
                "content": "First: the idea is to check every zero in a grid, and its area size: \\n```\\nvar largestIsland = function(grid) {    \\n    let findArea = function(grid, area, i, j, first){   \\n        if (typeof grid[i] == \\'undefined\\' || typeof grid[i][j] == \\'undefined\\' || area[i+\".\"+j]) return 0;\\n\\n        if (grid[i][j] == 1 || first) {\\n            area[i+\".\"+j] = true;\\n            return 1 + \\n                findArea(grid, area, i-1, j) + \\n                findArea(grid, area, i+1, j) + \\n                findArea(grid, area, i, j-1) +\\n                findArea(grid, area, i, j+1) ;\\n        }\\n        \\n        return 0;\\n    }\\n    \\n    let max = 0;\\n    for (let i =0; i < grid.length; i++) {\\n        for (let j = 0; j < grid[0].length; j++) {\\n            if (grid[i][j] == 0) {           \\n                let size = findArea(grid, {}, i, j, true);\\n                if (size > max) {\\n                    max = size;\\n                }\\n            }\\n        } \\n    }\\n    \\n    return max ? max :  grid.length*grid[0].length\\n};\\n```\\n\\nSecond: the idea is to find all islands, then for each zero, we have to check is it connected to the island (much faster then first solution, but still not the best i think):\\n\\n```\\nfunction Area(){\\n    this.points = {};\\n    \\n    this.Size = 0;\\n    this.Add = function(i,j){\\n        if (!this.points[i]) this.points[i] = {};\\n        this.points[i][j] = true;\\n    }\\n    \\n    this.Get = function(i,j){\\n        return (this.points[i] && this.points[i][j]) ? this.points[i][j] : 0;\\n    }\\n}\\n\\nvar largestIsland = function(grid) { \\n    \\n    let findArea = function(grid, area, i, j){   \\n         if (typeof grid[i] == \\'undefined\\' || typeof grid[i][j] == \\'undefined\\' || area.Get(i,j)) return 0;\\n            \\n         if (grid[i][j] == 1) {\\n            area.Add(i,j);\\n            return 1 + \\n                findArea(grid, area, i-1, j) + \\n                findArea(grid, area, i+1, j) + \\n                findArea(grid, area, i, j-1) +\\n                findArea(grid, area, i, j+1) ;\\n        }\\n        \\n        return 0;\\n    }\\n    \\n    let areas = [];\\n    let zeros = [];\\n    \\n    for (let i = 0; i < grid.length; i++) {\\n       for(let j= 0; j < grid[0].length; j++){\\n            if (grid[i][j] == 0) {\\n                zeros.push([i,j]);\\n                continue;\\n            }\\n           \\n            let skip = false;\\n            for (let a in areas) {\\n                if (areas[a].Get(i,j)) {\\n                    skip = true; break;\\n                }\\n            }\\n\\n            if (skip) continue;\\n            \\n            let area = new Area();\\n            area.Size = findArea(grid, area, i, j);\\n            areas.push(area);\\n       }\\n   }\\n    \\n    if (zeros.length == 0) return grid.length*grid[0].length\\n    if (areas.length == 0) return 1;\\n    \\n    \\n    let maxSize = 0;\\n    for (let z = 0; z < zeros.length; z++) {\\n        let i = zeros[z][0];\\n        let j = zeros[z][1];\\n        \\n        let size = 1;\\n        for (let n = 0; n < areas.length; n++) {\\n            if (areas[n].Get(i+1, j) || areas[n].Get(i-1, j) || areas[n].Get(i, j+1) || areas[n].Get(i, j-1)) {\\n                size+= areas[n].Size;\\n            }\\n        }\\n        \\n        if (size > maxSize) {\\n            maxSize = size;\\n        }\\n    }\\n    \\n    return maxSize;\\n}\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar largestIsland = function(grid) {    \\n    let findArea = function(grid, area, i, j, first){   \\n        if (typeof grid[i] == \\'undefined\\' || typeof grid[i][j] == \\'undefined\\' || area[i+\".\"+j]) return 0;\\n\\n        if (grid[i][j] == 1 || first) {\\n            area[i+\".\"+j] = true;\\n            return 1 + \\n                findArea(grid, area, i-1, j) + \\n                findArea(grid, area, i+1, j) + \\n                findArea(grid, area, i, j-1) +\\n                findArea(grid, area, i, j+1) ;\\n        }\\n        \\n        return 0;\\n    }\\n    \\n    let max = 0;\\n    for (let i =0; i < grid.length; i++) {\\n        for (let j = 0; j < grid[0].length; j++) {\\n            if (grid[i][j] == 0) {           \\n                let size = findArea(grid, {}, i, j, true);\\n                if (size > max) {\\n                    max = size;\\n                }\\n            }\\n        } \\n    }\\n    \\n    return max ? max :  grid.length*grid[0].length\\n};\\n```\n```\\nfunction Area(){\\n    this.points = {};\\n    \\n    this.Size = 0;\\n    this.Add = function(i,j){\\n        if (!this.points[i]) this.points[i] = {};\\n        this.points[i][j] = true;\\n    }\\n    \\n    this.Get = function(i,j){\\n        return (this.points[i] && this.points[i][j]) ? this.points[i][j] : 0;\\n    }\\n}\\n\\nvar largestIsland = function(grid) { \\n    \\n    let findArea = function(grid, area, i, j){   \\n         if (typeof grid[i] == \\'undefined\\' || typeof grid[i][j] == \\'undefined\\' || area.Get(i,j)) return 0;\\n            \\n         if (grid[i][j] == 1) {\\n            area.Add(i,j);\\n            return 1 + \\n                findArea(grid, area, i-1, j) + \\n                findArea(grid, area, i+1, j) + \\n                findArea(grid, area, i, j-1) +\\n                findArea(grid, area, i, j+1) ;\\n        }\\n        \\n        return 0;\\n    }\\n    \\n    let areas = [];\\n    let zeros = [];\\n    \\n    for (let i = 0; i < grid.length; i++) {\\n       for(let j= 0; j < grid[0].length; j++){\\n            if (grid[i][j] == 0) {\\n                zeros.push([i,j]);\\n                continue;\\n            }\\n           \\n            let skip = false;\\n            for (let a in areas) {\\n                if (areas[a].Get(i,j)) {\\n                    skip = true; break;\\n                }\\n            }\\n\\n            if (skip) continue;\\n            \\n            let area = new Area();\\n            area.Size = findArea(grid, area, i, j);\\n            areas.push(area);\\n       }\\n   }\\n    \\n    if (zeros.length == 0) return grid.length*grid[0].length\\n    if (areas.length == 0) return 1;\\n    \\n    \\n    let maxSize = 0;\\n    for (let z = 0; z < zeros.length; z++) {\\n        let i = zeros[z][0];\\n        let j = zeros[z][1];\\n        \\n        let size = 1;\\n        for (let n = 0; n < areas.length; n++) {\\n            if (areas[n].Get(i+1, j) || areas[n].Get(i-1, j) || areas[n].Get(i, j+1) || areas[n].Get(i, j-1)) {\\n                size+= areas[n].Size;\\n            }\\n        }\\n        \\n        if (size > maxSize) {\\n            maxSize = size;\\n        }\\n    }\\n    \\n    return maxSize;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 126952,
                "title": "python-union-find-ac-with-explanation-in-code-comments",
                "content": "```\\nclass Solution(object):\\n    def largestIsland(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if not grid or not grid[0]: return 0\\n        # First do a regular union find to find all the islands and their sizes, remember the biggest island\\'s size in \\'biggest\\'.\\n        # Also remember all zero positions\\n        uf={}\\n        size={}\\n        rank={}\\n        zeros=[]\\n        biggest=0\\n        def findparent(x):\\n            if x not in uf: return x\\n            if uf[x]!=x: return findparent(uf[x])\\n            return x\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]==0:\\n                    zeros.append((i,j))\\n                    continue\\n                if (i,j) not in uf:\\n                    uf[(i,j)]=(i,j)\\n                    rank[(i,j)]=0\\n                    size[(i,j)]=1\\n                    biggest=max(biggest,1)\\n                for ni,nj in [(i-1,j),(i,j-1)]:\\n                    if 0<=ni<len(grid) and 0<=nj<len(grid[0]) and (ni,nj) in uf:\\n                        parA=findparent((i,j))\\n                        parB=findparent((ni,nj))\\n                        if parA!=parB:\\n                            if rank[parA]>rank[parB]:\\n                                uf[parB]=parA\\n                                rank[parA]+=1\\n                                size[parA]+=size[parB]\\n                                biggest=max(biggest,size[parA])\\n                            else:\\n                                uf[parA]=parB\\n                                rank[parB]+=1\\n                                size[parB]+=size[parA]\\n                                biggest=max(biggest,size[parB])\\n        # Now loop over the zeros, and check all of its \\'1\\' neighbors, and tally their sizes in \\'neisizes\\'\\n        # If this new \\'1\\' connects multiple previously separated islands, the new island\\'s size would be sum(neisizes)+1\\n        for i,j in zeros:\\n            neisizes=[]\\n            visited=set()\\n            for ni,nj in [(i-1,j),(i+1,j),(i,j-1),(i,j+1)]:\\n                if 0<=ni<len(grid) and 0<=nj<len(grid[0]) and (ni,nj) in uf:\\n                    par=findparent((ni,nj))\\n                    if par not in visited:\\n                        neisizes.append(size[par])\\n                        visited.add(par)\\n            biggest=max(biggest,sum(neisizes)+1)\\n        return biggest\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def largestIsland(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if not grid or not grid[0]: return 0\\n        # First do a regular union find to find all the islands and their sizes, remember the biggest island\\'s size in \\'biggest\\'.\\n        # Also remember all zero positions\\n        uf={}\\n        size={}\\n        rank={}\\n        zeros=[]\\n        biggest=0\\n        def findparent(x):\\n            if x not in uf: return x\\n            if uf[x]!=x: return findparent(uf[x])\\n            return x\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j]==0:\\n                    zeros.append((i,j))\\n                    continue\\n                if (i,j) not in uf:\\n                    uf[(i,j)]=(i,j)\\n                    rank[(i,j)]=0\\n                    size[(i,j)]=1\\n                    biggest=max(biggest,1)\\n                for ni,nj in [(i-1,j),(i,j-1)]:\\n                    if 0<=ni<len(grid) and 0<=nj<len(grid[0]) and (ni,nj) in uf:\\n                        parA=findparent((i,j))\\n                        parB=findparent((ni,nj))\\n                        if parA!=parB:\\n                            if rank[parA]>rank[parB]:\\n                                uf[parB]=parA\\n                                rank[parA]+=1\\n                                size[parA]+=size[parB]\\n                                biggest=max(biggest,size[parA])\\n                            else:\\n                                uf[parA]=parB\\n                                rank[parB]+=1\\n                                size[parB]+=size[parA]\\n                                biggest=max(biggest,size[parB])\\n        # Now loop over the zeros, and check all of its \\'1\\' neighbors, and tally their sizes in \\'neisizes\\'\\n        # If this new \\'1\\' connects multiple previously separated islands, the new island\\'s size would be sum(neisizes)+1\\n        for i,j in zeros:\\n            neisizes=[]\\n            visited=set()\\n            for ni,nj in [(i-1,j),(i+1,j),(i,j-1),(i,j+1)]:\\n                if 0<=ni<len(grid) and 0<=nj<len(grid[0]) and (ni,nj) in uf:\\n                    par=findparent((ni,nj))\\n                    if par not in visited:\\n                        neisizes.append(size[par])\\n                        visited.add(par)\\n            biggest=max(biggest,sum(neisizes)+1)\\n        return biggest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 126931,
                "title": "python-short-dfs-w-explanation",
                "content": "The idea is to do a dfs and name the Islands based on component number and also store each Island\\'s size.\\n\\nThe next step is to simply iterate through the grid, and for each 0, find the maximum number of components it can unite and add up their sizes + 1\\n```\\n    def largestIsland(self, grid):\\n        def dfs(i, j, comps):\\n            if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == 1): return 0\\n            grid[i][j] = comps\\n            return 1 + sum([dfs(i+dir[0], j+dir[1], comps)for dir in dirs])\\n        comps = 2\\n        dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]\\n        comp_sizes = {}\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1:\\n                    size = dfs(i, j, comps)\\n                    comp_sizes[comps] = size\\n                    comps += 1\\n\\n        res = 0\\n        zeroes_present = False\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                resij = 0\\n                if grid[i][j] == 0:\\n                    zeroes_present = True\\n                    for comp in set([grid[i+dir[0]][j+dir[1]] for dir in dirs if (0 <= i+dir[0] < len(grid) and 0 <= j+dir[1] < len(grid[0]) and grid[i+dir[0]][j+dir[1]] != 0)]):\\n                        resij += comp_sizes[comp]\\n                res = max(res, resij)\\n\\n        return len(grid) * len(grid[0]) if not zeroes_present else res+1\\n```",
                "solutionTags": [],
                "code": "```\\n    def largestIsland(self, grid):\\n        def dfs(i, j, comps):\\n            if not (0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] == 1): return 0\\n            grid[i][j] = comps\\n            return 1 + sum([dfs(i+dir[0], j+dir[1], comps)for dir in dirs])\\n        comps = 2\\n        dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]\\n        comp_sizes = {}\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1:\\n                    size = dfs(i, j, comps)\\n                    comp_sizes[comps] = size\\n                    comps += 1\\n\\n        res = 0\\n        zeroes_present = False\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                resij = 0\\n                if grid[i][j] == 0:\\n                    zeroes_present = True\\n                    for comp in set([grid[i+dir[0]][j+dir[1]] for dir in dirs if (0 <= i+dir[0] < len(grid) and 0 <= j+dir[1] < len(grid[0]) and grid[i+dir[0]][j+dir[1]] != 0)]):\\n                        resij += comp_sizes[comp]\\n                res = max(res, resij)\\n\\n        return len(grid) * len(grid[0]) if not zeroes_present else res+1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3637620,
                "title": "easy-java-solution",
                "content": "# Java Code\\n```\\nclass Solution {\\n    int[] xDir = {0,0,-1,1};\\n    int[] yDir = {-1,1,0,0};\\n    public int DFS(int[][] grid,int i,int j,int var)\\n    {\\n        grid[i][j] = var;\\n        int count = 1;\\n        for(int k = 0;k<4;k++)\\n        {\\n            int newRow = i+xDir[k];\\n            int newCol = j+yDir[k];\\n            if(newRow>=0 && newRow<grid.length && newCol>=0 && newCol<grid[0].length && grid[newRow][newCol] == 1)\\n            {\\n                count+=DFS(grid,newRow,newCol,var);\\n            }\\n        }\\n        return count;\\n    }\\n    public int largestIsland(int[][] grid) {\\n        int islands = 0;\\n        int var = -1;\\n        HashMap<Integer,Integer> hmap = new HashMap<>();\\n        for(int i = 0;i<grid.length;i++)\\n        {\\n            for(int j = 0;j<grid[0].length;j++)\\n            {\\n                if(grid[i][j] == 1)\\n                {\\n                    int area = DFS(grid,i,j,var);\\n                    hmap.put(var,area);\\n                    var--;\\n                }\\n            }\\n        }\\n        boolean zero = false;\\n        int maxArea = Integer.MIN_VALUE;\\n        for(int i = 0;i<grid.length;i++)\\n        {\\n            for(int j = 0;j<grid[0].length;j++)\\n            {\\n                if(grid[i][j] == 0)\\n                {\\n                    zero = true;\\n                    HashSet<Integer> hset = new HashSet<>();\\n                    int area = 1;\\n                    for(int k = 0;k<4;k++)\\n                    {\\n                        int newRow = i+xDir[k];\\n                        int newCol = j+yDir[k];\\n                        if(newRow >= 0 && newRow<grid.length && newCol >= 0 && newCol<grid[0].length)\\n                        {\\n                            hset.add(grid[newRow][newCol]);\\n                        }\\n                    }\\n                    for(int item : hset)\\n                    {\\n                        if(item != 0)\\n                            area += hmap.get(item);\\n                    }\\n                    maxArea = Math.max(maxArea,area);\\n                }\\n            }   \\n        }\\n        return (zero == true)?maxArea:hmap.get(-1);\\n    }\\n}\\n\\n\\n```\\n---\\n#### *Please don\\'t forget to upvote if you\\'ve liked my solution. \\uD83D\\uDC4D*",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int[] xDir = {0,0,-1,1};\\n    int[] yDir = {-1,1,0,0};\\n    public int DFS(int[][] grid,int i,int j,int var)\\n    {\\n        grid[i][j] = var;\\n        int count = 1;\\n        for(int k = 0;k<4;k++)\\n        {\\n            int newRow = i+xDir[k];\\n            int newCol = j+yDir[k];\\n            if(newRow>=0 && newRow<grid.length && newCol>=0 && newCol<grid[0].length && grid[newRow][newCol] == 1)\\n            {\\n                count+=DFS(grid,newRow,newCol,var);\\n            }\\n        }\\n        return count;\\n    }\\n    public int largestIsland(int[][] grid) {\\n        int islands = 0;\\n        int var = -1;\\n        HashMap<Integer,Integer> hmap = new HashMap<>();\\n        for(int i = 0;i<grid.length;i++)\\n        {\\n            for(int j = 0;j<grid[0].length;j++)\\n            {\\n                if(grid[i][j] == 1)\\n                {\\n                    int area = DFS(grid,i,j,var);\\n                    hmap.put(var,area);\\n                    var--;\\n                }\\n            }\\n        }\\n        boolean zero = false;\\n        int maxArea = Integer.MIN_VALUE;\\n        for(int i = 0;i<grid.length;i++)\\n        {\\n            for(int j = 0;j<grid[0].length;j++)\\n            {\\n                if(grid[i][j] == 0)\\n                {\\n                    zero = true;\\n                    HashSet<Integer> hset = new HashSet<>();\\n                    int area = 1;\\n                    for(int k = 0;k<4;k++)\\n                    {\\n                        int newRow = i+xDir[k];\\n                        int newCol = j+yDir[k];\\n                        if(newRow >= 0 && newRow<grid.length && newCol >= 0 && newCol<grid[0].length)\\n                        {\\n                            hset.add(grid[newRow][newCol]);\\n                        }\\n                    }\\n                    for(int item : hset)\\n                    {\\n                        if(item != 0)\\n                            area += hmap.get(item);\\n                    }\\n                    maxArea = Math.max(maxArea,area);\\n                }\\n            }   \\n        }\\n        return (zero == true)?maxArea:hmap.get(-1);\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380011,
                "title": "striver-method-godofgraph",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DisjointSet {\\n\\npublic:\\n    vector<int> rank, parent, size;\\n    DisjointSet(int n) {\\n        rank.resize(n + 1, 0);\\n        parent.resize(n + 1);\\n        size.resize(n + 1);\\n        for (int i = 0; i <= n; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n\\n    int findUPar(int node) {\\n        if (node == parent[node])\\n            return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n\\n    void unionByRank(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (rank[ulp_u] < rank[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n        }\\n        else if (rank[ulp_v] < rank[ulp_u]) {\\n            parent[ulp_v] = ulp_u;\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            rank[ulp_u]++;\\n        }\\n    }\\n\\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n    }\\n};\\nclass Solution {\\n    private:\\n    bool isValid(int newr, int newc, int n) {\\n        return newr >= 0 && newr < n && newc >= 0 && newc < n;\\n    }\\npublic:\\n    int largestIsland(vector<vector<int>>& grid) {\\n         int n = grid.size();\\n        DisjointSet ds(n * n);\\n        // step - 1\\n        for (int row = 0; row < n ; row++) {\\n            for (int col = 0; col < n ; col++) {\\n                if (grid[row][col] == 0) continue;\\n                int dr[] = { -1, 0, 1, 0};\\n                int dc[] = {0, -1, 0, 1};\\n                for (int ind = 0; ind < 4; ind++) {\\n                    int newr = row + dr[ind];\\n                    int newc = col + dc[ind];\\n                    if (isValid(newr, newc, n) && grid[newr][newc] == 1) {\\n                        int nodeNo = row * n + col;\\n                        int adjNodeNo = newr * n + newc;\\n                        ds.unionBySize(nodeNo, adjNodeNo);\\n                    }\\n                }\\n            }\\n        }\\n        // step 2\\n        int mx = 0;\\n        for (int row = 0; row < n; row++) {\\n            for (int col = 0; col < n; col++) {\\n                if (grid[row][col] == 1) continue;\\n                int dr[] = { -1, 0, 1, 0};\\n                int dc[] = {0, -1, 0, 1};\\n                set<int> components;\\n                for (int ind = 0; ind < 4; ind++) {\\n                    int newr = row + dr[ind];\\n                    int newc = col + dc[ind];\\n                    if (isValid(newr, newc, n)) {\\n                        if (grid[newr][newc] == 1) {\\n                            components.insert(ds.findUPar(newr * n + newc));\\n                        }\\n                    }\\n                }\\n                int sizeTotal = 0;\\n                for (auto it : components) {\\n                    sizeTotal += ds.size[it];\\n                }\\n                mx = max(mx, sizeTotal + 1);\\n            }\\n        }\\n        for (int cellNo = 0; cellNo < n * n; cellNo++) {\\n            mx = max(mx, ds.size[ds.findUPar(cellNo)]);\\n        }\\n        return mx;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DisjointSet {\\n\\npublic:\\n    vector<int> rank, parent, size;\\n    DisjointSet(int n) {\\n        rank.resize(n + 1, 0);\\n        parent.resize(n + 1);\\n        size.resize(n + 1);\\n        for (int i = 0; i <= n; i++) {\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n\\n    int findUPar(int node) {\\n        if (node == parent[node])\\n            return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n\\n    void unionByRank(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (rank[ulp_u] < rank[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n        }\\n        else if (rank[ulp_v] < rank[ulp_u]) {\\n            parent[ulp_v] = ulp_u;\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            rank[ulp_u]++;\\n        }\\n    }\\n\\n    void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return;\\n        if (size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v;\\n            size[ulp_v] += size[ulp_u];\\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v];\\n        }\\n    }\\n};\\nclass Solution {\\n    private:\\n    bool isValid(int newr, int newc, int n) {\\n        return newr >= 0 && newr < n && newc >= 0 && newc < n;\\n    }\\npublic:\\n    int largestIsland(vector<vector<int>>& grid) {\\n         int n = grid.size();\\n        DisjointSet ds(n * n);\\n        // step - 1\\n        for (int row = 0; row < n ; row++) {\\n            for (int col = 0; col < n ; col++) {\\n                if (grid[row][col] == 0) continue;\\n                int dr[] = { -1, 0, 1, 0};\\n                int dc[] = {0, -1, 0, 1};\\n                for (int ind = 0; ind < 4; ind++) {\\n                    int newr = row + dr[ind];\\n                    int newc = col + dc[ind];\\n                    if (isValid(newr, newc, n) && grid[newr][newc] == 1) {\\n                        int nodeNo = row * n + col;\\n                        int adjNodeNo = newr * n + newc;\\n                        ds.unionBySize(nodeNo, adjNodeNo);\\n                    }\\n                }\\n            }\\n        }\\n        // step 2\\n        int mx = 0;\\n        for (int row = 0; row < n; row++) {\\n            for (int col = 0; col < n; col++) {\\n                if (grid[row][col] == 1) continue;\\n                int dr[] = { -1, 0, 1, 0};\\n                int dc[] = {0, -1, 0, 1};\\n                set<int> components;\\n                for (int ind = 0; ind < 4; ind++) {\\n                    int newr = row + dr[ind];\\n                    int newc = col + dc[ind];\\n                    if (isValid(newr, newc, n)) {\\n                        if (grid[newr][newc] == 1) {\\n                            components.insert(ds.findUPar(newr * n + newc));\\n                        }\\n                    }\\n                }\\n                int sizeTotal = 0;\\n                for (auto it : components) {\\n                    sizeTotal += ds.size[it];\\n                }\\n                mx = max(mx, sizeTotal + 1);\\n            }\\n        }\\n        for (int cellNo = 0; cellNo < n * n; cellNo++) {\\n            mx = max(mx, ds.size[ds.findUPar(cellNo)]);\\n        }\\n        return mx;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2286265,
                "title": "faster-then-96-easy-to-understand",
                "content": "The main problem is find every island and island size.\\nAfter that we can get private identifer to every island in a map and size;\\nAfter that we must check only 4 cells near every \"0\"  and find bugets sum of islands near that point.\\nO(n^2) for find every island;\\nO(n^2) for marking every island;\\nO(n^2) for find bigest island in total.\\n\\nTotal time complexity is O(n^2).\\n\\n```\\nclass Solution {\\n    int count = 0;\\n    int num = 10;\\n    public int largestIsland(int[][] grid) {\\n        Map<Integer, Integer> map = new HashMap();\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid.length; j++) {\\n                if (grid[i][j] == 1) {\\n                    count = 0;\\n                    find(grid, i, j);\\n                    map.put(num, count);\\n                    change(grid, i, j);\\n                    num++;\\n                }\\n            }\\n        }\\n        int max = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid.length; j++) {\\n                if (grid[i][j] == 0) {\\n                    count = 1;\\n                    int[] tmp = new int[4];\\n                    if(i > 0) tmp[0]=grid[i-1][j];\\n                    if(i+1 < grid.length) tmp[1]=grid[i+1][j];\\n                    if(j > 0) tmp[2]=grid[i][j-1];\\n                    if(j+1 < grid[0].length) tmp[3]=grid[i][j+1];\\n                    for (int f = 0; f < 3; f++) {\\n                        for (int g = f+1; g < 4; g++) {\\n                            if (tmp[f] == tmp[g]) tmp[f] = 0;\\n                        }\\n                    }\\n                    for (int x: tmp) {\\n                        if (x > 9) count += map.get(x);\\n                    }\\n                    \\n                    max = Math.max(max, count);\\n                }\\n            }\\n        }\\n        if (max == 0) return map.get(10);\\n        return max;\\n    }\\n    \\n    public void find(int[][] grid, int i, int j) {\\n        count++;\\n        grid[i][j] = 2;\\n        if(i > 0 && grid[i-1][j] == 1) find(grid, i-1, j);\\n        if(i+1 < grid.length && grid[i+1][j] == 1) find(grid, i+1, j);\\n        if(j > 0 && grid[i][j-1] == 1) find(grid, i, j-1);\\n        if(j+1 < grid[0].length && grid[i][j+1] == 1) find(grid, i, j+1);\\n    }\\n    \\n    public void change(int[][] grid, int i, int j) {\\n        grid[i][j] = num;\\n        if(i > 0 && grid[i-1][j] == 2) change(grid, i-1, j);\\n        if(i+1 < grid.length && grid[i+1][j] == 2) change(grid, i+1, j);\\n        if(j > 0 && grid[i][j-1] == 2) change(grid, i, j-1);\\n        if(j+1 < grid[0].length && grid[i][j+1] == 2) change(grid, i, j+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int count = 0;\\n    int num = 10;\\n    public int largestIsland(int[][] grid) {\\n        Map<Integer, Integer> map = new HashMap();\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid.length; j++) {\\n                if (grid[i][j] == 1) {\\n                    count = 0;\\n                    find(grid, i, j);\\n                    map.put(num, count);\\n                    change(grid, i, j);\\n                    num++;\\n                }\\n            }\\n        }\\n        int max = 0;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid.length; j++) {\\n                if (grid[i][j] == 0) {\\n                    count = 1;\\n                    int[] tmp = new int[4];\\n                    if(i > 0) tmp[0]=grid[i-1][j];\\n                    if(i+1 < grid.length) tmp[1]=grid[i+1][j];\\n                    if(j > 0) tmp[2]=grid[i][j-1];\\n                    if(j+1 < grid[0].length) tmp[3]=grid[i][j+1];\\n                    for (int f = 0; f < 3; f++) {\\n                        for (int g = f+1; g < 4; g++) {\\n                            if (tmp[f] == tmp[g]) tmp[f] = 0;\\n                        }\\n                    }\\n                    for (int x: tmp) {\\n                        if (x > 9) count += map.get(x);\\n                    }\\n                    \\n                    max = Math.max(max, count);\\n                }\\n            }\\n        }\\n        if (max == 0) return map.get(10);\\n        return max;\\n    }\\n    \\n    public void find(int[][] grid, int i, int j) {\\n        count++;\\n        grid[i][j] = 2;\\n        if(i > 0 && grid[i-1][j] == 1) find(grid, i-1, j);\\n        if(i+1 < grid.length && grid[i+1][j] == 1) find(grid, i+1, j);\\n        if(j > 0 && grid[i][j-1] == 1) find(grid, i, j-1);\\n        if(j+1 < grid[0].length && grid[i][j+1] == 1) find(grid, i, j+1);\\n    }\\n    \\n    public void change(int[][] grid, int i, int j) {\\n        grid[i][j] = num;\\n        if(i > 0 && grid[i-1][j] == 2) change(grid, i-1, j);\\n        if(i+1 < grid.length && grid[i+1][j] == 2) change(grid, i+1, j);\\n        if(j > 0 && grid[i][j-1] == 2) change(grid, i, j-1);\\n        if(j+1 < grid[0].length && grid[i][j+1] == 2) change(grid, i, j+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1816403,
                "title": "c-dfs-graph-coloring-breif-algorithm",
                "content": "```\\nAlgorithm ->\\n1) pick a color, color the group of 1\\'s and simultaneously calculate the are of \\n   those 1\\'s and store the pair (color, area)\\n2) traverse the grid again and find the zero, if it is a zero than add the area of\\n   colors on its 4 directions (NOTE: directions should be valid and we should not \\n   add the redundant color).\\n   \\n   \\nclass Solution {\\npublic:\\n    bool isValid(int i, int j, int n){\\n        if(i < 0 || j < 0 || i >= n || j >=n) return false;\\n        return true;\\n    }\\n    int dfs(vector<vector<int>> &grid, int i, int j, int color){\\n        if(i < 0 || j < 0 || i >= grid.size() || j >= grid.size() || grid[i][j] != 1)\\n            return 0;\\n        \\n        grid[i][j] = color;\\n        return 1 + dfs(grid, i + 1, j, color) + dfs(grid, i, j + 1, color) + dfs(grid, i - 1, j, color) + dfs(grid, i, j - 1, color);\\n        \\n    }\\n    int largestIsland(vector<vector<int>>& grid) {\\n          int n = grid.size();\\n          vector<int> colors (n * n + 2, 0);\\n          int color = 2;\\n          for(int i=0; i<n; i++){\\n              for(int j=0; j<n; j++){\\n                  if(grid[i][j] == 1){\\n                      int area = dfs(grid, i, j, color);\\n                      colors[color] = area;\\n                      color++;\\n                  }\\n              }\\n          }\\n        \\n         int area = 0;\\n         \\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j] == 0)\\n                { set<int> col;\\n                if(isValid(i+1, j, n)) col.insert(grid[i+1][j]);\\n                if(isValid(i, j+1, n)) col.insert(grid[i][j+1]);\\n                if(isValid(i, j-1, n)) col.insert(grid[i][j-1]);\\n                if(isValid(i-1, j, n)) col.insert(grid[i-1][j]);\\n                int cur_area = 1;\\n                for(auto it : col) cur_area += (colors[(it)]);\\n                area = max(area, cur_area);\\n                }\\n            }\\n        }\\n          return area == 0 ? n * n : area;\\n    }\\n};\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    bool isValid(int i, int j, int n){\\n        if(i < 0 || j < 0 || i >= n || j >=n) return false;\\n        return true;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1563050,
                "title": "python-union-find-solution",
                "content": "```\\nclass Solution:\\n    def makeSet(self, a):\\n        # Initially, a new element is in its own set\\n        # its parent is itself, its rank is 0\\n        self.parent[a] = a\\n        self.rank[a] = 0\\n        self.size[a] = 1\\n\\n    def find(self, a):\\n        # find the root representative of the set that a belongs to\\n        if (self.parent[a] != a):\\n            self.parent[a] = self.find(self.parent[a])\\n        return self.parent[a]\\n\\n    def union(self, a, b):\\n        # union the set that includes a and  the set that includes b\\n        a_root = self.find(a)\\n        b_root = self.find(b)\\n        if a_root != b_root:\\n            if self.rank[a_root] < self.rank[b_root]:\\n                a_root, b_root = b_root, a_root\\n            self.parent[b_root] = a_root\\n            self.size[a_root] += self.size[b_root]\\n            if self.rank[a_root] == self.rank[b_root]:\\n                self.rank[b_root] += 1\\n            self.answer = max(self.answer, self.size[a_root])\\n            \\n    def largestIsland(self, grid: List[List[int]]) -> int:\\n        self.answer = 0\\n        self.parent, self.rank, self.size = dict(), dict(), dict()\\n        n, m = len(grid), len(grid[0])\\n        # make set for each cell of island, and find the largest size of island\\n        for x in range(n):\\n            for y in range(m):\\n                if grid[x][y] == 1:\\n                    self.makeSet((x, y)) # make set for a new island (x, y)\\n                    self.answer = max(self.answer, 1)\\n                    for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\\n                        x1, y1 = x + dx, y + dy\\n                        if 0 <= x1 < n and 0 <= y1 < m and (x1, y1) in self.parent:\\n                            # union (x, y) and its neighbor (x1, y1)\\n                            self.union((x1, y1), (x, y))\\n        # change each 0 to 1, and find the largest size of island\\n        for x in range(n):\\n            for y in range(m):\\n                if grid[x][y] == 0:\\n                    root_set = set()\\n                    for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\\n                        x1, y1 = x + dx, y + dy\\n                        if 0 <= x1 < n and 0 <= y1 < m and grid[x1][y1] == 1:\\n                            root = self.find((x1, y1))\\n                            root_set.add(root)\\n                    self.answer = max(self.answer, 1 + sum([self.size[root] for root in root_set]))\\n        return self.answer\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def makeSet(self, a):\\n        # Initially, a new element is in its own set\\n        # its parent is itself, its rank is 0\\n        self.parent[a] = a\\n        self.rank[a] = 0\\n        self.size[a] = 1\\n\\n    def find(self, a):\\n        # find the root representative of the set that a belongs to\\n        if (self.parent[a] != a):\\n            self.parent[a] = self.find(self.parent[a])\\n        return self.parent[a]\\n\\n    def union(self, a, b):\\n        # union the set that includes a and  the set that includes b\\n        a_root = self.find(a)\\n        b_root = self.find(b)\\n        if a_root != b_root:\\n            if self.rank[a_root] < self.rank[b_root]:\\n                a_root, b_root = b_root, a_root\\n            self.parent[b_root] = a_root\\n            self.size[a_root] += self.size[b_root]\\n            if self.rank[a_root] == self.rank[b_root]:\\n                self.rank[b_root] += 1\\n            self.answer = max(self.answer, self.size[a_root])\\n            \\n    def largestIsland(self, grid: List[List[int]]) -> int:\\n        self.answer = 0\\n        self.parent, self.rank, self.size = dict(), dict(), dict()\\n        n, m = len(grid), len(grid[0])\\n        # make set for each cell of island, and find the largest size of island\\n        for x in range(n):\\n            for y in range(m):\\n                if grid[x][y] == 1:\\n                    self.makeSet((x, y)) # make set for a new island (x, y)\\n                    self.answer = max(self.answer, 1)\\n                    for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\\n                        x1, y1 = x + dx, y + dy\\n                        if 0 <= x1 < n and 0 <= y1 < m and (x1, y1) in self.parent:\\n                            # union (x, y) and its neighbor (x1, y1)\\n                            self.union((x1, y1), (x, y))\\n        # change each 0 to 1, and find the largest size of island\\n        for x in range(n):\\n            for y in range(m):\\n                if grid[x][y] == 0:\\n                    root_set = set()\\n                    for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\\n                        x1, y1 = x + dx, y + dy\\n                        if 0 <= x1 < n and 0 <= y1 < m and grid[x1][y1] == 1:\\n                            root = self.find((x1, y1))\\n                            root_set.add(root)\\n                    self.answer = max(self.answer, 1 + sum([self.size[root] for root in root_set]))\\n        return self.answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1377321,
                "title": "java-solution-84-fast-63-memory-dfs-easy-to-understand",
                "content": "Below is my commented solution. Please share any comments below.\\n\\n```\\nclass Solution {\\n    /*\\n        Approach:\\n            \\n        Two iterations through the grid:\\n            In first iteration through the grid, use DFS to count and group separate islands together.\\n                * Using a map to map groupNumber -> sizeOfIsland\\n            In second iteration, look for any \\'0\\' and add the values of all the unique groups from 4 directions.\\n            \\n        Complexities:\\n            * Time: O(n^2) - We are iterating through the grid twice. Even in DFS, we are not DFS-ing on visited indices.\\n            * Space: O(n^2) - We are creating group array to account for visited and for groupings\\n    */\\n    \\n    private int[][] dirs = { {1, 0}, {-1, 0}, {0, 1}, {0, -1} };\\n    \\n    public int largestIsland(int[][] grid) {\\n        int len = grid.length;\\n        int largest = 0;\\n    \\n        int[][] group = new int[len][len];\\n        Map<Integer, Integer> groupMap = new HashMap<>();\\n        int groupNum = 1;\\n        \\n        \\n        for (int i = 0; i < len; i++) {\\n            for (int n = 0; n < len; n++) {\\n                // If group[i][n] > 0, it means it was already calculated and assigned a group, we can skip\\n                if (grid[i][n] == 1 && group[i][n] == 0) {\\n                    group[i][n] = groupNum;\\n                    int sizeOfIsland = dfs(grid, i, n, group, groupNum); // the size of this group\\n                    groupMap.put(groupNum, sizeOfIsland);\\n                    groupNum++;\\n                    \\n                    largest = Integer.max(largest, sizeOfIsland);\\n                }\\n            }\\n        }\\n        \\n        for (int i = 0; i < len; i++) {\\n            for (int n = 0; n < len; n++) {\\n                if (grid[i][n] == 0) {\\n                    int count = 0;\\n                    \\n                    Set<Integer> dup = new HashSet<>();\\n                    for (int[] dir : dirs) {\\n                        int x = i + dir[0];\\n                        int y = n + dir[1];\\n                        if (x >= 0 && y >= 0 && x < len && y < len && group[x][y] > 0 && !dup.contains(group[x][y])) {\\n                            count+= groupMap.get(group[x][y]);\\n                            dup.add(group[x][y]);\\n                        }\\n                    }\\n                    \\n                    largest = Integer.max(largest, count+1); // we add 1 to include the current changed \\'0\\'\\n                }\\n            }\\n        }\\n        \\n        return largest;\\n    }\\n    \\n    private int dfs(int[][] grid, int i, int n, int[][] group, int groupNum) {\\n        int count = 0;\\n        \\n        for (int[] dir : dirs) {\\n            int x = i + dir[0];\\n            int y = n + dir[1];\\n            if (x >= 0 && y >= 0 && x < grid.length && y < grid.length && grid[x][y] == 1 && group[x][y] == 0) {\\n                group[x][y] = groupNum;\\n                count += dfs(grid, x, y, group, groupNum);\\n            }\\n        }\\n        \\n        return count + 1;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    /*\\n        Approach:\\n            \\n        Two iterations through the grid:\\n            In first iteration through the grid, use DFS to count and group separate islands together.\\n                * Using a map to map groupNumber -> sizeOfIsland\\n            In second iteration, look for any \\'0\\' and add the values of all the unique groups from 4 directions.\\n            \\n        Complexities:\\n            * Time: O(n^2) - We are iterating through the grid twice. Even in DFS, we are not DFS-ing on visited indices.\\n            * Space: O(n^2) - We are creating group array to account for visited and for groupings\\n    */\\n    \\n    private int[][] dirs = { {1, 0}, {-1, 0}, {0, 1}, {0, -1} };\\n    \\n    public int largestIsland(int[][] grid) {\\n        int len = grid.length;\\n        int largest = 0;\\n    \\n        int[][] group = new int[len][len];\\n        Map<Integer, Integer> groupMap = new HashMap<>();\\n        int groupNum = 1;\\n        \\n        \\n        for (int i = 0; i < len; i++) {\\n            for (int n = 0; n < len; n++) {\\n                // If group[i][n] > 0, it means it was already calculated and assigned a group, we can skip\\n                if (grid[i][n] == 1 && group[i][n] == 0) {\\n                    group[i][n] = groupNum;\\n                    int sizeOfIsland = dfs(grid, i, n, group, groupNum); // the size of this group\\n                    groupMap.put(groupNum, sizeOfIsland);\\n                    groupNum++;\\n                    \\n                    largest = Integer.max(largest, sizeOfIsland);\\n                }\\n            }\\n        }\\n        \\n        for (int i = 0; i < len; i++) {\\n            for (int n = 0; n < len; n++) {\\n                if (grid[i][n] == 0) {\\n                    int count = 0;\\n                    \\n                    Set<Integer> dup = new HashSet<>();\\n                    for (int[] dir : dirs) {\\n                        int x = i + dir[0];\\n                        int y = n + dir[1];\\n                        if (x >= 0 && y >= 0 && x < len && y < len && group[x][y] > 0 && !dup.contains(group[x][y])) {\\n                            count+= groupMap.get(group[x][y]);\\n                            dup.add(group[x][y]);\\n                        }\\n                    }\\n                    \\n                    largest = Integer.max(largest, count+1); // we add 1 to include the current changed \\'0\\'\\n                }\\n            }\\n        }\\n        \\n        return largest;\\n    }\\n    \\n    private int dfs(int[][] grid, int i, int n, int[][] group, int groupNum) {\\n        int count = 0;\\n        \\n        for (int[] dir : dirs) {\\n            int x = i + dir[0];\\n            int y = n + dir[1];\\n            if (x >= 0 && y >= 0 && x < grid.length && y < grid.length && grid[x][y] == 1 && group[x][y] == 0) {\\n                group[x][y] = groupNum;\\n                count += dfs(grid, x, y, group, groupNum);\\n            }\\n        }\\n        \\n        return count + 1;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1377199,
                "title": "union-find-union-by-rank-faster-than-87-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>>parent;\\n    vector<int>csize;\\n    int find_set(int a){\\n        if(parent[a].first==a)\\n            return a;\\n        return parent[a].first = find_set(parent[a].first);\\n    }\\n    void union_set(int a,int b){\\n        a = find_set(a);\\n        b = find_set(b);\\n        if(a!=b){\\n            if(parent[a].second == parent[b].second)\\n                parent[a].second++;\\n            if(parent[a].second < parent[b].second)\\n                swap(a,b);\\n            parent[b].first = a;\\n            csize[a]+=csize[b];\\n        }\\n    }\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        \\n//         make set : provide unique identity to each cell i*n + j \\n//         initialize cells having val 1 to size 1\\n        for(int i=0;i<n*n;i++){\\n//             first -> parent second->rank\\n            parent.push_back({i,0});\\n            csize.push_back(0);\\n            if(grid[i/n][i%n])\\n                csize[i]++;\\n        }\\n        \\n//         union set all the cells with adjacent 1 if any (4 direction)\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(i+1<n and grid[i][j] and grid[i+1][j])\\n                    union_set(i*n+j,(i+1)*n+j);\\n                if(i-1>=0 and grid[i][j] and grid[i-1][j])\\n                    union_set(i*n+j,(i-1)*n+j);\\n                if(j+1<n and grid[i][j] and grid[i][j+1])\\n                    union_set(i*n+j,i*n+j+1);\\n                if(j-1>=0 and grid[i][j] and grid[i][j-1])\\n                    union_set(i*n+j,i*n+j-1);\\n            }\\n        }\\n        \\n//        for each 0 valued cell, find adjacent cell\\'s unique representative to add their size \\n//         if 1 valued cell continue\\n//         take into consideration no 0 cell case\\n        unordered_set<int>dparent;\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]){\\n                    ans = max(ans,csize[i*n+j]);\\n                    continue;\\n                }\\n                int cans = 1;\\n                dparent.clear();\\n                if(i+1<n and grid[i+1][j])\\n                    dparent.insert(find_set((i+1)*n+j));\\n                if(i-1>=0 and grid[i-1][j])\\n                     dparent.insert(find_set((i-1)*n+j));\\n                if(j+1<n and grid[i][j+1])\\n                      dparent.insert(find_set(i*n+j+1));\\n                if(j-1>=0 and grid[i][j-1])\\n                     dparent.insert(find_set(i*n+j-1));\\n                \\n                for(int par:dparent){\\n                    cans += csize[par];\\n                }\\n                ans = max(ans,cans);\\n            }\\n          }\\n        \\n            return ans;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>>parent;\\n    vector<int>csize;\\n    int find_set(int a){\\n        if(parent[a].first==a)\\n            return a;\\n        return parent[a].first = find_set(parent[a].first);\\n    }\\n    void union_set(int a,int b){\\n        a = find_set(a);\\n        b = find_set(b);\\n        if(a!=b){\\n            if(parent[a].second == parent[b].second)\\n                parent[a].second++;\\n            if(parent[a].second < parent[b].second)\\n                swap(a,b);\\n            parent[b].first = a;\\n            csize[a]+=csize[b];\\n        }\\n    }\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        \\n//         make set : provide unique identity to each cell i*n + j \\n//         initialize cells having val 1 to size 1\\n        for(int i=0;i<n*n;i++){\\n//             first -> parent second->rank\\n            parent.push_back({i,0});\\n            csize.push_back(0);\\n            if(grid[i/n][i%n])\\n                csize[i]++;\\n        }\\n        \\n//         union set all the cells with adjacent 1 if any (4 direction)\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(i+1<n and grid[i][j] and grid[i+1][j])\\n                    union_set(i*n+j,(i+1)*n+j);\\n                if(i-1>=0 and grid[i][j] and grid[i-1][j])\\n                    union_set(i*n+j,(i-1)*n+j);\\n                if(j+1<n and grid[i][j] and grid[i][j+1])\\n                    union_set(i*n+j,i*n+j+1);\\n                if(j-1>=0 and grid[i][j] and grid[i][j-1])\\n                    union_set(i*n+j,i*n+j-1);\\n            }\\n        }\\n        \\n//        for each 0 valued cell, find adjacent cell\\'s unique representative to add their size \\n//         if 1 valued cell continue\\n//         take into consideration no 0 cell case\\n        unordered_set<int>dparent;\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]){\\n                    ans = max(ans,csize[i*n+j]);\\n                    continue;\\n                }\\n                int cans = 1;\\n                dparent.clear();\\n                if(i+1<n and grid[i+1][j])\\n                    dparent.insert(find_set((i+1)*n+j));\\n                if(i-1>=0 and grid[i-1][j])\\n                     dparent.insert(find_set((i-1)*n+j));\\n                if(j+1<n and grid[i][j+1])\\n                      dparent.insert(find_set(i*n+j+1));\\n                if(j-1>=0 and grid[i][j-1])\\n                     dparent.insert(find_set(i*n+j-1));\\n                \\n                for(int par:dparent){\\n                    cans += csize[par];\\n                }\\n                ans = max(ans,cans);\\n            }\\n          }\\n        \\n            return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1376868,
                "title": "making-a-large-island-dfs-and-bfs-comments-python",
                "content": "Steps:\\n1. Group all sets of 1\\'s into \"islands\" and give them unique names and store their area in a dictionary.\\n2. Go back through the grid and find the 0\\'s that are attached to these islands\\n3. Iterate through until the largest new \"island\" is found.\\n\\n```\\nclass Solution:\\n    def largestIsland(self, grid: List[List[int]]) -> int:\\n        \\n        #What I will be doing is grouping the islands by giving them all unique numbers and storing these numbers with their areas in a dictionary.\\n        #This function will do the grouping of the islands and find their total areas.\\n\\t\\t\\n\\t\\t\\t#x and y are the location in the grid and num will be the \"name\" of the island, which I will just use as an incrementally increasing set of integers\\n\\t\\t\\tdef redefineGrid(x, y, num): \\n            if grid[x][y] != 1: #if we hit water we can just return zero as there is no need to access this part of the array.\\n                return 0\\n            grid[x][y] = num  #Here we will keep track of each mass of 1\\'s by naming each island.\\n            area = 1\\n            if x + 1 < len(grid):\\n                area += redefineGrid(x + 1, y, num)\\n            if y + 1 < len(grid[0]):\\n                area += redefineGrid(x, y + 1, num)\\n            if x - 1 >= 0:\\n                area += redefineGrid(x - 1, y, num)\\n            if y - 1 >= 0:\\n                area += redefineGrid(x, y - 1, num)\\n            return area\\n\\n      \\n        mem = {}  #mem will be the dictionary.\\n        current = 2  #Each group of islands gets its own name. We will ignore 1 to make the entire thing easier to begin with and iterate up as we go.\\n        subTotal = 0\\n        totalSize = len(grid) * len(grid[0])\\n        \\n        #Now we iterate through the array looking for islands and adding their names and area values to the dictionary.\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1:\\n                    subTotal = redefineGrid(i, j, current)\\n                    if subTotal >= totalSize - 1: #This is a trivial case where either the entire array is 1\\'s or if there is only one 0, in which case, the area is the total\\n                        return totalSize\\n                    mem[current] = subTotal\\n                    current += 1\\n\\n        #now we will look through the grid once again, this time trying to identify the \"water\" or 0\\'s and try to use them to connect to different islands.\\n        #curArray will be used to keep track of which islands are already part of the new landmass so we don\\'t double count islands along the way.\\n        largest = 0\\n        curArray = []\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 0:\\n                  #Setting the stage for the current location by clearing old values.\\n                    current = 0\\n                    curArray.clear()\\n                    if i + 1 < len(grid) and grid[i + 1][j] != 0:\\n                        current += mem[grid[i + 1][j]]\\n                        curArray.append(grid[i + 1][j])\\n                    if i - 1 >= 0 and grid[i - 1][j] != 0 and curArray.count(grid[i - 1][j]) == 0:  #using the array curArray, we keep track of the islands we already counted\\n                        current += mem[grid[i - 1][j]]\\n                        curArray.append(grid[i - 1][j])\\n                    if j + 1 < len(grid[0]) and grid[i][j + 1] != 0 and curArray.count(grid[i][j + 1]) == 0:\\n                        current += mem[grid[i][j + 1]]\\n                        curArray.append(grid[i][j + 1])\\n                    if j - 1 >= 0 and grid[i][j - 1] != 0 and curArray.count(grid[i][j - 1]) == 0:\\n                        current += mem[grid[i][j - 1]]\\n                        curArray.append(grid[i][j - 1])\\n                    #We want to add the current 0 we are looking at, so each current will end up being current + 1\\n                    if current + 1 > largest:\\n                        largest = current + 1\\n        if largest == 0 and totalSize > 0:\\n        #in another trivial case where the entire array is 0\\'s, we can make a single 1, so we will return 1. Note: the trivial case of a 0-value array is solved below.\\n            return 1\\n        return largest\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def largestIsland(self, grid: List[List[int]]) -> int:\\n        \\n        #What I will be doing is grouping the islands by giving them all unique numbers and storing these numbers with their areas in a dictionary.\\n        #This function will do the grouping of the islands and find their total areas.\\n\\t\\t\\n\\t\\t\\t#x and y are the location in the grid and num will be the \"name\" of the island, which I will just use as an incrementally increasing set of integers\\n\\t\\t\\tdef redefineGrid(x, y, num): \\n            if grid[x][y] != 1: #if we hit water we can just return zero as there is no need to access this part of the array.\\n                return 0\\n            grid[x][y] = num  #Here we will keep track of each mass of 1\\'s by naming each island.\\n            area = 1\\n            if x + 1 < len(grid):\\n                area += redefineGrid(x + 1, y, num)\\n            if y + 1 < len(grid[0]):\\n                area += redefineGrid(x, y + 1, num)\\n            if x - 1 >= 0:\\n                area += redefineGrid(x - 1, y, num)\\n            if y - 1 >= 0:\\n                area += redefineGrid(x, y - 1, num)\\n            return area\\n\\n      \\n        mem = {}  #mem will be the dictionary.\\n        current = 2  #Each group of islands gets its own name. We will ignore 1 to make the entire thing easier to begin with and iterate up as we go.\\n        subTotal = 0\\n        totalSize = len(grid) * len(grid[0])\\n        \\n        #Now we iterate through the array looking for islands and adding their names and area values to the dictionary.\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 1:\\n                    subTotal = redefineGrid(i, j, current)\\n                    if subTotal >= totalSize - 1: #This is a trivial case where either the entire array is 1\\'s or if there is only one 0, in which case, the area is the total\\n                        return totalSize\\n                    mem[current] = subTotal\\n                    current += 1\\n\\n        #now we will look through the grid once again, this time trying to identify the \"water\" or 0\\'s and try to use them to connect to different islands.\\n        #curArray will be used to keep track of which islands are already part of the new landmass so we don\\'t double count islands along the way.\\n        largest = 0\\n        curArray = []\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if grid[i][j] == 0:\\n                  #Setting the stage for the current location by clearing old values.\\n                    current = 0\\n                    curArray.clear()\\n                    if i + 1 < len(grid) and grid[i + 1][j] != 0:\\n                        current += mem[grid[i + 1][j]]\\n                        curArray.append(grid[i + 1][j])\\n                    if i - 1 >= 0 and grid[i - 1][j] != 0 and curArray.count(grid[i - 1][j]) == 0:  #using the array curArray, we keep track of the islands we already counted\\n                        current += mem[grid[i - 1][j]]\\n                        curArray.append(grid[i - 1][j])\\n                    if j + 1 < len(grid[0]) and grid[i][j + 1] != 0 and curArray.count(grid[i][j + 1]) == 0:\\n                        current += mem[grid[i][j + 1]]\\n                        curArray.append(grid[i][j + 1])\\n                    if j - 1 >= 0 and grid[i][j - 1] != 0 and curArray.count(grid[i][j - 1]) == 0:\\n                        current += mem[grid[i][j - 1]]\\n                        curArray.append(grid[i][j - 1])\\n                    #We want to add the current 0 we are looking at, so each current will end up being current + 1\\n                    if current + 1 > largest:\\n                        largest = current + 1\\n        if largest == 0 and totalSize > 0:\\n        #in another trivial case where the entire array is 0\\'s, we can make a single 1, so we will return 1. Note: the trivial case of a 0-value array is solved below.\\n            return 1\\n        return largest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1376420,
                "title": "java-solution-with-detailed-explanation",
                "content": "The idea of this solution is similar with other explanataions, but uses different data structures. The logic contains 2 steps:\\n1. find all the islands\\n2. check every cells with zero if they are \"bridges\" between islands.\\n\\nIn order to use a cell\\'s address as a map key, the solution uses a hash function from the procedure getAddressHash();\\n\\nThe solution uses the next data structures:\\n* **islands**. It is a list of sets, where a set contains all the cells of the island. So, a size of an island is a size of a set.\\n* **addressIslandIndex**. It is a map, where a key is the hash of a cell\\'s address and a value is an index of an island that contains this cell. It\\'s used for getting an island index by a cell\\'s address.\\n\\nSo, the algorith of the solution is the next:\\n1. Go through the matrix and recursively find all the islands.\\n2. Go through the matrix one more time and if a cell contains 0, check if it is a **bridge** between two islands and can connect them. It\\'s possible to do this by just checking if the neighbouring cells are keys of the structure **addressIslandIndex**. If so, get a size of an island by its index and increase a local max size.\\n\\n```\\n\\nclass Solution {\\n    List<Set<Integer>> islands; //Contains all the islands, where an island is a set of all included cells\\n    Map<Integer,Integer> addressIslandIndex; //Key - a cell, value - index of an island that contains this cell.\\n    int[][] grid;\\n    int maxSquare; // result\\n    public int largestIsland(int[][] grid) {\\n        //initialise all the variables\\n        islands = new ArrayList();        \\n        addressIslandIndex = new HashMap();\\n        maxSquare=0;\\n        this.grid = grid;\\n        \\n        //fill list of islands\\n        for (int i=0;i<grid.length;i++){\\n            for (int j=0;j<grid.length;j++){\\n                if (addressIslandIndex.containsKey(getAddressHash(i,j))) continue;\\n                if (grid[i][j]==1){\\n                    Set<Integer> island = new HashSet();\\n                    fillIsland(island, i,j, islands.size());\\n                    islands.add(island);\\n                    maxSquare = Math.max(maxSquare,island.size());\\n                }\\n            }\\n        }\\n        \\n        //arrays are used for getting addresses of neighbouring cells\\n        int[] horizontalOffset = {0,0,1,-1};\\n        int[] verticalOffset = {1,-1,0,0};\\n        \\n        //System.out.println(islands.size());\\n        \\n        //check all the possible bridges\\n        for (int i=0;i<grid.length;i++){\\n            for (int j=0;j<grid.length;j++){                \\n                if (grid[i][j]==0){\\n                    int localMax=1;\\n                    \\n                    //A set of visited islands is used in order not to use a size of an island several times\\n                    Set<Integer> visitedIslands = new HashSet();\\n                    for (int k=0;k<horizontalOffset.length;k++){\\n                        \\n                        int addressHash = getAddressHash(i+horizontalOffset[k],j+verticalOffset[k]);\\n                        if (addressIslandIndex.containsKey(addressHash)){                            \\n                            int islandIndex = addressIslandIndex.get(addressHash);\\n                            if (!visitedIslands.contains(islandIndex)){\\n                                localMax+=islands.get(islandIndex).size();\\n                                visitedIslands.add(islandIndex);\\n                            }\\n                        }\\n                    }\\n                    maxSquare = Math.max(maxSquare,localMax);\\n                }\\n            }\\n        }\\n        \\n        return maxSquare;\\n    }\\n    \\n    private void fillIsland(Set<Integer> island, int i, int j, int islandIndex){\\n        if (addressIslandIndex.containsKey(getAddressHash(i,j))) return; //cell was already checked\\n        if (i<0 || j<0 || i>=grid.length || j>=grid.length) return; //cell is out of a grid\\n        if (grid[i][j]==1){\\n            island.add(getAddressHash(i,j));            \\n            addressIslandIndex.put(getAddressHash(i,j),islandIndex);\\n            //up\\n            fillIsland(island, i, j-1, islandIndex);\\n            //down\\n            fillIsland(island, i, j+1, islandIndex);\\n            //right\\n            fillIsland(island, i+1, j, islandIndex);\\n            //left\\n            fillIsland(island, i-1, j, islandIndex);\\n        }\\n    }\\n    \\n    private int getAddressHash(int i, int j){\\n        return i*1000 + j;\\n    }\\n}\\n\\n```\\n\\n*Thank you for reading this solution!*",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    List<Set<Integer>> islands; //Contains all the islands, where an island is a set of all included cells\\n    Map<Integer,Integer> addressIslandIndex; //Key - a cell, value - index of an island that contains this cell.\\n    int[][] grid;\\n    int maxSquare; // result\\n    public int largestIsland(int[][] grid) {\\n        //initialise all the variables\\n        islands = new ArrayList();        \\n        addressIslandIndex = new HashMap();\\n        maxSquare=0;\\n        this.grid = grid;\\n        \\n        //fill list of islands\\n        for (int i=0;i<grid.length;i++){\\n            for (int j=0;j<grid.length;j++){\\n                if (addressIslandIndex.containsKey(getAddressHash(i,j))) continue;\\n                if (grid[i][j]==1){\\n                    Set<Integer> island = new HashSet();\\n                    fillIsland(island, i,j, islands.size());\\n                    islands.add(island);\\n                    maxSquare = Math.max(maxSquare,island.size());\\n                }\\n            }\\n        }\\n        \\n        //arrays are used for getting addresses of neighbouring cells\\n        int[] horizontalOffset = {0,0,1,-1};\\n        int[] verticalOffset = {1,-1,0,0};\\n        \\n        //System.out.println(islands.size());\\n        \\n        //check all the possible bridges\\n        for (int i=0;i<grid.length;i++){\\n            for (int j=0;j<grid.length;j++){                \\n                if (grid[i][j]==0){\\n                    int localMax=1;\\n                    \\n                    //A set of visited islands is used in order not to use a size of an island several times\\n                    Set<Integer> visitedIslands = new HashSet();\\n                    for (int k=0;k<horizontalOffset.length;k++){\\n                        \\n                        int addressHash = getAddressHash(i+horizontalOffset[k],j+verticalOffset[k]);\\n                        if (addressIslandIndex.containsKey(addressHash)){                            \\n                            int islandIndex = addressIslandIndex.get(addressHash);\\n                            if (!visitedIslands.contains(islandIndex)){\\n                                localMax+=islands.get(islandIndex).size();\\n                                visitedIslands.add(islandIndex);\\n                            }\\n                        }\\n                    }\\n                    maxSquare = Math.max(maxSquare,localMax);\\n                }\\n            }\\n        }\\n        \\n        return maxSquare;\\n    }\\n    \\n    private void fillIsland(Set<Integer> island, int i, int j, int islandIndex){\\n        if (addressIslandIndex.containsKey(getAddressHash(i,j))) return; //cell was already checked\\n        if (i<0 || j<0 || i>=grid.length || j>=grid.length) return; //cell is out of a grid\\n        if (grid[i][j]==1){\\n            island.add(getAddressHash(i,j));            \\n            addressIslandIndex.put(getAddressHash(i,j),islandIndex);\\n            //up\\n            fillIsland(island, i, j-1, islandIndex);\\n            //down\\n            fillIsland(island, i, j+1, islandIndex);\\n            //right\\n            fillIsland(island, i+1, j, islandIndex);\\n            //left\\n            fillIsland(island, i-1, j, islandIndex);\\n        }\\n    }\\n    \\n    private int getAddressHash(int i, int j){\\n        return i*1000 + j;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207248,
                "title": "swift-dfs-solution-similar-to-number-of-islands",
                "content": "```\\nclass Solution {\\n    /*\\n    \\n    Task:\\n        1. Perform DFS on each 1 cell and paint it with a unique color >= 2.\\n            I. Increase color variable for each new 1 cell we visit\\n        2. We need a data structure to hold the color and it\\'s area, dictionary does it!\\n            I. The initial key and value pair is 0 as a cell of 0 has 0 area\\n        3. As we finish searching for 1\\'s in the grid, there are 2 cases\\n            I. Either the grid is filled with only 1\\'s, therefore return rows*cols\\n            II. Or the grid is all zero\\'s, return 1 as we can only flip one 0 cell\\n    \\n    Complexity:\\n        TC: O(R*C) where R = # of rows and C # of columns\\n        SC: O(R*C)\\n    \\n    */\\n    \\n    var rows = 0\\n    var cols = 0\\n    var grid: [[Int]] = []\\n    let directions: [[Int]] = [[1,0], [-1,0], [0,1], [0,-1]]\\n    \\n    func largestIsland(_ grid: [[Int]]) -> Int {\\n        \\n        self.rows = grid.count\\n        self.cols = grid[0].count\\n        self.grid = grid\\n        \\n        // Key = color and value is the area. A cell = 0 will have no area, 0.\\n        var map: [Int: Int] = [:]\\n        map[0] = 0\\n        \\n        var color = 2\\n        \\n        // Color All 1\\'s\\n        for r in 0..<rows {\\n            for c in 0..<cols where self.grid[r][c] == 1 {\\n                let area = dfs(r,c,color)\\n                map[color] = area \\n                color += 1\\n            }\\n        }\\n        \\n        // The grid could be all 0\\'s and no cell was painted\\n        var result = map[2, default:0]\\n        \\n        // Optimization. No need to do extra work as we can flip only 1 cell\\n        if result == 0 { return 1 } \\n        \\n        for r in 0..<rows {\\n            for c in 0..<cols where self.grid[r][c] == 0 {\\n                \\n                // Find colors that are around this cell \\n                var uniqueColors: Set<Int> = []\\n                \\n                for direction in directions {\\n                    let nextRow = r + direction[0]\\n                    let nextCol = c + direction[1]\\n                    \\n                    if isValid(nextRow, nextCol) {\\n                        let validColor = self.grid[nextRow][nextCol]\\n                        uniqueColors.insert(validColor)\\n                    }\\n                }\\n                \\n                var totalArea = 1 \\n                for color in uniqueColors {\\n                    totalArea += map[color]!\\n                }\\n                result = max(totalArea, result)\\n            }\\n        }\\n        return result\\n    }\\n    \\n    func dfs(_ r: Int, _ c: Int, _ color: Int) -> Int {\\n        grid[r][c] = color\\n        var totalArea = 1\\n        \\n        for direction in directions {\\n            let nextRow = r + direction[0]\\n            let nextCol = c + direction[1]\\n            \\n            // Only color 1\\'s\\n            if isValid(nextRow,nextCol) && grid[nextRow][nextCol] == 1 {\\n                totalArea += dfs(nextRow,nextCol,color)\\n            }\\n        }\\n        return totalArea\\n    }\\n    \\n    func isValid(_ r: Int, _ c: Int) -> Bool {\\n        return r >= 0 && r < rows && c >= 0 && c < cols\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    /*\\n    \\n    Task:\\n        1. Perform DFS on each 1 cell and paint it with a unique color >= 2.\\n            I. Increase color variable for each new 1 cell we visit\\n        2. We need a data structure to hold the color and it\\'s area, dictionary does it!\\n            I. The initial key and value pair is 0 as a cell of 0 has 0 area\\n        3. As we finish searching for 1\\'s in the grid, there are 2 cases\\n            I. Either the grid is filled with only 1\\'s, therefore return rows*cols\\n            II. Or the grid is all zero\\'s, return 1 as we can only flip one 0 cell\\n    \\n    Complexity:\\n        TC: O(R*C) where R = # of rows and C # of columns\\n        SC: O(R*C)\\n    \\n    */\\n    \\n    var rows = 0\\n    var cols = 0\\n    var grid: [[Int]] = []\\n    let directions: [[Int]] = [[1,0], [-1,0], [0,1], [0,-1]]\\n    \\n    func largestIsland(_ grid: [[Int]]) -> Int {\\n        \\n        self.rows = grid.count\\n        self.cols = grid[0].count\\n        self.grid = grid\\n        \\n        // Key = color and value is the area. A cell = 0 will have no area, 0.\\n        var map: [Int: Int] = [:]\\n        map[0] = 0\\n        \\n        var color = 2\\n        \\n        // Color All 1\\'s\\n        for r in 0..<rows {\\n            for c in 0..<cols where self.grid[r][c] == 1 {\\n                let area = dfs(r,c,color)\\n                map[color] = area \\n                color += 1\\n            }\\n        }\\n        \\n        // The grid could be all 0\\'s and no cell was painted\\n        var result = map[2, default:0]\\n        \\n        // Optimization. No need to do extra work as we can flip only 1 cell\\n        if result == 0 { return 1 } \\n        \\n        for r in 0..<rows {\\n            for c in 0..<cols where self.grid[r][c] == 0 {\\n                \\n                // Find colors that are around this cell \\n                var uniqueColors: Set<Int> = []\\n                \\n                for direction in directions {\\n                    let nextRow = r + direction[0]\\n                    let nextCol = c + direction[1]\\n                    \\n                    if isValid(nextRow, nextCol) {\\n                        let validColor = self.grid[nextRow][nextCol]\\n                        uniqueColors.insert(validColor)\\n                    }\\n                }\\n                \\n                var totalArea = 1 \\n                for color in uniqueColors {\\n                    totalArea += map[color]!\\n                }\\n                result = max(totalArea, result)\\n            }\\n        }\\n        return result\\n    }\\n    \\n    func dfs(_ r: Int, _ c: Int, _ color: Int) -> Int {\\n        grid[r][c] = color\\n        var totalArea = 1\\n        \\n        for direction in directions {\\n            let nextRow = r + direction[0]\\n            let nextCol = c + direction[1]\\n            \\n            // Only color 1\\'s\\n            if isValid(nextRow,nextCol) && grid[nextRow][nextCol] == 1 {\\n                totalArea += dfs(nextRow,nextCol,color)\\n            }\\n        }\\n        return totalArea\\n    }\\n    \\n    func isValid(_ r: Int, _ c: Int) -> Bool {\\n        return r >= 0 && r < rows && c >= 0 && c < cols\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1036263,
                "title": "java-dfs-solution-o-m-n-beats-93",
                "content": "\\n\\tpublic int largestIsland(int[][] grid) {\\n\\n\\t\\tint max_area = 1;\\n\\t\\tint row = grid.length;\\n\\t\\tint col = grid[0].length;\\n\\t\\tint[] colors = new int[row * col + 2];\\n\\t\\tboolean[][] visited = new boolean[row][col];\\n\\t\\tint[][] dirs = { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\\n\\t\\tint index = 2;\\n\\n\\t\\tfor (int i = 0; i < row; i++) {\\n\\t\\t\\tfor (int j = 0; j < col; j++) {\\n\\t\\t\\t\\tif (grid[i][j] == 1) {\\n\\t\\t\\t\\t\\tint area = dfsHelper(grid, visited, i, j, row, col, index, dirs);\\n\\t\\t\\t\\t\\tcolors[index++] = area;\\n\\t\\t\\t\\t\\tmax_area = Math.max(area, max_area);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < row; i++) {\\n\\t\\t\\tfor (int j = 0; j < col; j++) {\\n\\t\\t\\t\\tif (grid[i][j] == 0) {\\n\\t\\t\\t\\t\\tint ans = 0;\\n\\t\\t\\t\\t\\tHashSet<Integer> set = new HashSet<Integer>();\\n\\t\\t\\t\\t\\tfor (int[] dir : dirs) {\\n\\t\\t\\t\\t\\t\\tint r = i + dir[0];\\n\\t\\t\\t\\t\\t\\tint c = j + dir[1];\\n\\t\\t\\t\\t\\t\\tif (r < 0 || c < 0 || r >= row || c >= col || grid[r][c] == 0)\\n\\t\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t\\tset.add(grid[r][c]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tfor (int node : set)\\n\\t\\t\\t\\t\\t\\tans += colors[node];\\n\\t\\t\\t\\t\\tans += 1;\\n\\t\\t\\t\\t\\tmax_area = Math.max(ans, max_area);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn max_area;\\n\\t}\\n\\n\\tpublic int dfsHelper(int[][] grid, boolean[][] visited, int i, int j, int row, int col, int color, int[][] dirs) {\\n\\n\\t\\tvisited[i][j] = true;\\n\\t\\tgrid[i][j] = color;\\n\\t\\tint area = 1;\\n\\t\\tfor (int[] dir : dirs) {\\n\\t\\t\\tint r = i + dir[0];\\n\\t\\t\\tint c = j + dir[1];\\n\\t\\t\\tif (r < 0 || c < 0 || r >= row || c >= col || grid[r][c] == 0 || visited[r][c])\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tarea += dfsHelper(grid, visited, r, c, row, col, color, dirs);\\n\\t\\t}\\n\\t\\treturn area;\\n\\t}\\n",
                "solutionTags": [],
                "code": "\\n\\tpublic int largestIsland(int[][] grid) {\\n\\n\\t\\tint max_area = 1;\\n\\t\\tint row = grid.length;\\n\\t\\tint col = grid[0].length;\\n\\t\\tint[] colors = new int[row * col + 2];\\n\\t\\tboolean[][] visited = new boolean[row][col];\\n\\t\\tint[][] dirs = { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\\n\\t\\tint index = 2;\\n\\n\\t\\tfor (int i = 0; i < row; i++) {\\n\\t\\t\\tfor (int j = 0; j < col; j++) {\\n\\t\\t\\t\\tif (grid[i][j] == 1) {\\n\\t\\t\\t\\t\\tint area = dfsHelper(grid, visited, i, j, row, col, index, dirs);\\n\\t\\t\\t\\t\\tcolors[index++] = area;\\n\\t\\t\\t\\t\\tmax_area = Math.max(area, max_area);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < row; i++) {\\n\\t\\t\\tfor (int j = 0; j < col; j++) {\\n\\t\\t\\t\\tif (grid[i][j] == 0) {\\n\\t\\t\\t\\t\\tint ans = 0;\\n\\t\\t\\t\\t\\tHashSet<Integer> set = new HashSet<Integer>();\\n\\t\\t\\t\\t\\tfor (int[] dir : dirs) {\\n\\t\\t\\t\\t\\t\\tint r = i + dir[0];\\n\\t\\t\\t\\t\\t\\tint c = j + dir[1];\\n\\t\\t\\t\\t\\t\\tif (r < 0 || c < 0 || r >= row || c >= col || grid[r][c] == 0)\\n\\t\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t\\tset.add(grid[r][c]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tfor (int node : set)\\n\\t\\t\\t\\t\\t\\tans += colors[node];\\n\\t\\t\\t\\t\\tans += 1;\\n\\t\\t\\t\\t\\tmax_area = Math.max(ans, max_area);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn max_area;\\n\\t}\\n\\n\\tpublic int dfsHelper(int[][] grid, boolean[][] visited, int i, int j, int row, int col, int color, int[][] dirs) {\\n\\n\\t\\tvisited[i][j] = true;\\n\\t\\tgrid[i][j] = color;\\n\\t\\tint area = 1;\\n\\t\\tfor (int[] dir : dirs) {\\n\\t\\t\\tint r = i + dir[0];\\n\\t\\t\\tint c = j + dir[1];\\n\\t\\t\\tif (r < 0 || c < 0 || r >= row || c >= col || grid[r][c] == 0 || visited[r][c])\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tarea += dfsHelper(grid, visited, r, c, row, col, color, dirs);\\n\\t\\t}\\n\\t\\treturn area;\\n\\t}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 128413,
                "title": "python-undirected-graph-count-connected-components-16-23-lines-easy-and-clear-solutions-100-ms",
                "content": "* 23 lines 100 ms\\n```\\nclass Solution:\\n    def largestIsland(self, grid):\\n        def explore(i, j):\\n            dic[(i, j)], count[curr] = curr, count[curr] + 1\\n            if i > 0 and grid[i - 1][j] == 1 and (i - 1, j) not in dic: explore(i - 1, j)\\n            if j > 0 and grid[i][j - 1] == 1 and (i, j - 1) not in dic: explore(i, j - 1)\\n            if i + 1 < len(grid) and grid[i + 1][j] ==1 and (i + 1, j) not in dic: explore(i + 1, j)\\n            if j + 1 < len(grid) and grid[i][j + 1] == 1 and (i, j + 1) not in dic: explore(i, j + 1)\\n        def neighbours(i, j, adj):\\n            if i > 0 and grid[i - 1][j] == 1 and dic[(i - 1, j)] not in adj: adj.add(dic[(i - 1, j)])\\n            if j > 0 and grid[i][j - 1] == 1 and dic[(i, j - 1)] not in adj: adj.add(dic[(i, j - 1)])\\n            if i + 1 < len(grid) and grid[i + 1][j] ==1 and dic[(i + 1, j)] not in adj: adj.add(dic[(i + 1, j)])\\n            if j + 1 < len(grid) and grid[i][j + 1] == 1 and dic[(i, j + 1)] not in adj: adj.add(dic[(i, j + 1)])\\n            return adj\\n        curr, dic, count, res = 0, {}, collections.defaultdict(int), 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid)):\\n                if grid[i][j] == 1 and (i, j) not in dic: curr += 1; explore(i, j)\\n        for i in range(len(grid)):\\n            for j in range(len(grid)):\\n                if grid[i][j] == 1: res = max(res, count[dic[(i, j)]])\\n                else: res = max(res, sum(count[r] for r in neighbours(i, j, set())) + 1)\\n        return res\\n```\\n*  16 lines 150 ms\\n```\\nclass Solution:\\n    def largestIsland(self, grid):\\n        def proper(i, j): \\n            return (c for c in ((i-1,j),(i+1,j),(i,j-1),(i,j+1)) if 0<=c[0]<len(grid) and 0<=c[1]<len(grid) and grid[c[0]][c[1]]==1)\\n        def explore(i, j):\\n            dic[(i, j)], count[curr] = curr, count[curr] + 1   \\n            for cp in proper(i, j):\\n                if cp not in dic: explore(cp[0], cp[1])\\n        curr, dic, count, res = 0, {}, collections.defaultdict(int), 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid)):\\n                if grid[i][j] == 1 and (i, j) not in dic: curr += 1; explore(i, j)\\n        for i in range(len(grid)):\\n            for j in range(len(grid)):\\n                if grid[i][j] == 1: res = max(res, count[dic[(i, j)]])\\n                else: res = max(res, sum(count[r] for r in {dic[c] for c in proper(i, j)}) + 1)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestIsland(self, grid):\\n        def explore(i, j):\\n            dic[(i, j)], count[curr] = curr, count[curr] + 1\\n            if i > 0 and grid[i - 1][j] == 1 and (i - 1, j) not in dic: explore(i - 1, j)\\n            if j > 0 and grid[i][j - 1] == 1 and (i, j - 1) not in dic: explore(i, j - 1)\\n            if i + 1 < len(grid) and grid[i + 1][j] ==1 and (i + 1, j) not in dic: explore(i + 1, j)\\n            if j + 1 < len(grid) and grid[i][j + 1] == 1 and (i, j + 1) not in dic: explore(i, j + 1)\\n        def neighbours(i, j, adj):\\n            if i > 0 and grid[i - 1][j] == 1 and dic[(i - 1, j)] not in adj: adj.add(dic[(i - 1, j)])\\n            if j > 0 and grid[i][j - 1] == 1 and dic[(i, j - 1)] not in adj: adj.add(dic[(i, j - 1)])\\n            if i + 1 < len(grid) and grid[i + 1][j] ==1 and dic[(i + 1, j)] not in adj: adj.add(dic[(i + 1, j)])\\n            if j + 1 < len(grid) and grid[i][j + 1] == 1 and dic[(i, j + 1)] not in adj: adj.add(dic[(i, j + 1)])\\n            return adj\\n        curr, dic, count, res = 0, {}, collections.defaultdict(int), 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid)):\\n                if grid[i][j] == 1 and (i, j) not in dic: curr += 1; explore(i, j)\\n        for i in range(len(grid)):\\n            for j in range(len(grid)):\\n                if grid[i][j] == 1: res = max(res, count[dic[(i, j)]])\\n                else: res = max(res, sum(count[r] for r in neighbours(i, j, set())) + 1)\\n        return res\\n```\n```\\nclass Solution:\\n    def largestIsland(self, grid):\\n        def proper(i, j): \\n            return (c for c in ((i-1,j),(i+1,j),(i,j-1),(i,j+1)) if 0<=c[0]<len(grid) and 0<=c[1]<len(grid) and grid[c[0]][c[1]]==1)\\n        def explore(i, j):\\n            dic[(i, j)], count[curr] = curr, count[curr] + 1   \\n            for cp in proper(i, j):\\n                if cp not in dic: explore(cp[0], cp[1])\\n        curr, dic, count, res = 0, {}, collections.defaultdict(int), 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid)):\\n                if grid[i][j] == 1 and (i, j) not in dic: curr += 1; explore(i, j)\\n        for i in range(len(grid)):\\n            for j in range(len(grid)):\\n                if grid[i][j] == 1: res = max(res, count[dic[(i, j)]])\\n                else: res = max(res, sum(count[r] for r in {dic[c] for c in proper(i, j)}) + 1)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 127057,
                "title": "python-solution-with-explanation-build-the-beach-of-the-island",
                "content": "The main idea is to build a beach for each island.... First counter the area of each Island and save it in the \"count\". Then find all boundary cells (with the boundary I mean the ocean not the land) of a certain island which are called beach. If two islands can be connected to each other with changing only one cell from \"0\" to \"1\", the beaches of these two islands must overlap at this cell. So for each island, find all the beach cell and add the value with the area of the island. For example, given the grid [[0,1,0,1,1,0]]. There are two island with area [1,2], the beach of the first island is the first and the third cell, the beach of the second island is the third and sixth cell. After calculating the beach, we get [[1,0,3,0,0,2]], and the result is 3+1.\\n\\n\\n        import copy\\n        res = []\\n        for i in grid:\\n            res += i\\n        if 0 not in res:\\n            return len(res)\\n        m , n = len(grid) , len(grid[0])\\n\\n        g = [[0]*(n+2)] + [[0] + i + [0] for i in grid] + [[0]*(n+2)]\\n\\n        res = copy.deepcopy(g)\\n        check = copy.deepcopy(g) # to check\\n        def countArea(i,j):\\n            if g[i][j] == 0 or i<0 or i == m+2 or j < 0 or j == n+2:\\n                return 0\\n            g[i][j] = 0\\n            return 1+sum(list(map(countArea,[i,i,i+1,i-1],[j+1,j-1,j,j])))\\n\\n        count = []\\n        for x in range(1,m+1):\\n            for y in range(1,n+1):\\n                if g[x][y] == 1:\\n                    count += countArea(x,y),\\n\\n        g = copy.deepcopy(res)\\n        def beach(i,j,num):\\n            if g[i][j] == 0 or i<0 or i == m+2 or j < 0 or j == n+2:\\n                res[i][j] += num\\n                g[i][j] = \"X\"\\n                return\\n            if g[i][j] == \"X\":\\n                return\\n            g[i][j] = \"X\"\\n            list(map(beach,[i,i,i-1,i+1],[j-1,j+1,j,j],[num]*4))\\n            return\\n        for x in range(1,m+1):\\n            for y in range(1,n+1):\\n                if g[x][y] == 1:\\n                    beach(x,y,count.pop(0))\\n                    for a in range(1,m+1):\\n                        for b in range(1,n+1):\\n                            g[a][b] = [g[a][b],0][g[a][b] == \"X\"]\\n\\n        Res = []\\n        for i in res:\\n            Res += i\\n\\n        return max(Res)+1\\n\\n",
                "solutionTags": [],
                "code": "The main idea is to build a beach for each island.... First counter the area of each Island and save it in the \"count\". Then find all boundary cells (with the boundary I mean the ocean not the land) of a certain island which are called beach. If two islands can be connected to each other with changing only one cell from \"0\" to \"1\", the beaches of these two islands must overlap at this cell. So for each island, find all the beach cell and add the value with the area of the island. For example, given the grid [[0,1,0,1,1,0]]. There are two island with area [1,2], the beach of the first island is the first and the third cell, the beach of the second island is the third and sixth cell. After calculating the beach, we get [[1,0,3,0,0,2]], and the result is 3+1.\\n\\n\\n        import copy\\n        res = []\\n        for i in grid:\\n            res += i\\n        if 0 not in res:\\n            return len(res)\\n        m , n = len(grid) , len(grid[0])\\n\\n        g = [[0]*(n+2)] + [[0] + i + [0] for i in grid] + [[0]*(n+2)]\\n\\n        res = copy.deepcopy(g)\\n        check = copy.deepcopy(g) # to check\\n        def countArea(i,j):\\n            if g[i][j] == 0 or i<0 or i == m+2 or j < 0 or j == n+2:\\n                return 0\\n            g[i][j] = 0\\n            return 1+sum(list(map(countArea,[i,i,i+1,i-1],[j+1,j-1,j,j])))\\n\\n        count = []\\n        for x in range(1,m+1):\\n            for y in range(1,n+1):\\n                if g[x][y] == 1:\\n                    count += countArea(x,y),\\n\\n        g = copy.deepcopy(res)\\n        def beach(i,j,num):\\n            if g[i][j] == 0 or i<0 or i == m+2 or j < 0 or j == n+2:\\n                res[i][j] += num\\n                g[i][j] = \"X\"\\n                return\\n            if g[i][j] == \"X\":\\n                return\\n            g[i][j] = \"X\"\\n            list(map(beach,[i,i,i-1,i+1],[j-1,j+1,j,j],[num]*4))\\n            return\\n        for x in range(1,m+1):\\n            for y in range(1,n+1):\\n                if g[x][y] == 1:\\n                    beach(x,y,count.pop(0))\\n                    for a in range(1,m+1):\\n                        for b in range(1,n+1):\\n                            g[a][b] = [g[a][b],0][g[a][b] == \"X\"]\\n\\n        Res = []\\n        for i in res:\\n            Res += i\\n\\n        return max(Res)+1\\n\\n",
                "codeTag": "Python3"
            },
            {
                "id": 3748014,
                "title": "c-using-disjoint-set-detailed-explanation-simple-implementation-using-size-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe will make use of disjoint set data structure, as we know it is used in dynamic graphs, so initially we will make one disjoint set and find the size of island with maximum number of 1\\'s , which can be found from size array of disjoint set(NOTE: we will have a public size array for this problem), after getting inital maximum size of island we will move to zeroes, we will check each and every zero.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwhile checking zeroes we will look for its 4D neighbours, consider two neighbours if they have same ultimate parents then we will add their size to the count only once and to make sure we will make one ultimate array, by pushing parents as thier size has been included. finally we will compare it with our initial \\'ans\\' variable, which we found with original grid, we will do this for each zero in the grid, and finally return the maximum answer.\\n\\n**Please Upvote, it keeps me motivated**\\n\\n# Code\\n```\\nclass disjointSet{\\n    public:\\n\\n    vector<int>parent,size;\\n\\n    disjointSet(int v){\\n        size.resize(v,1);\\n        parent.resize(v);\\n        for(int i=0;i<v;i++){\\n            parent[i]=i;\\n        }\\n    }\\n\\n\\n    int findUPar(int node){\\n        if(node==parent[node])return node;\\n\\n        return parent[node]=findUPar(parent[node]);\\n    }    \\n\\n\\n    void unionBySize(int u, int v){\\n        int ulp_u=findUPar(u);\\n        int ulp_v=findUPar(v);\\n        if(ulp_u==ulp_v)return;\\n\\n        if(size[ulp_v]>size[ulp_u]){\\n            parent[ulp_u]=ulp_v;\\n            size[ulp_v]+=size[ulp_u];\\n        }\\n        else{\\n            parent[ulp_v]=ulp_u;\\n            size[ulp_u]+=size[ulp_v];\\n        }\\n    }\\n};\\n\\n\\n\\nclass Solution {\\npublic:\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n       \\n        disjointSet s(n*n);\\n        vector<vector<int>>visited(n,vector<int>(n,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j] && !visited[i][j]){\\n                    visited[i][j]=1;\\n                    int dx[]={-1,0,1,0};\\n                    int dy[]={0,-1,0,1};\\n                    for(int k=0;k<4;k++){\\n                        int x=i+dx[k];\\n                        int y=j+dy[k];\\n                        if(x<0 || x>=n || y<0 || y>=n)continue;\\n                        if(grid[x][y]==1){\\n                            if(s.findUPar(n*x + y)!=s.findUPar(n*i + j)){\\n                                s.unionBySize(n*x + y, n*i + j);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<n*n;i++){\\n            ans=max(ans,s.size[i]);\\n        }\\n\\n\\n\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==0){\\n                    int count=1;\\n                    vector<int>ultimate;\\n                    int dx[]={-1,0,1,0};\\n                    int dy[]={0,-1,0,1};\\n                    for(int k=0;k<4;k++){\\n                        int x=i+dx[k];\\n                        int y=j+dy[k];\\n                        if(x<0 || x>=n || y<0 || y>=n)continue;\\n                        if(visited[x][y]){\\n                            int ultP=s.findUPar(x*n + y);\\n                            if(std::find(ultimate.begin(),ultimate.end(),ultP)==ultimate.end()){\\n                                ultimate.push_back(ultP);\\n                                count+=s.size[ultP];\\n                            }\\n                        }\\n                    }\\n                    ans=max(ans,count);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass disjointSet{\\n    public:\\n\\n    vector<int>parent,size;\\n\\n    disjointSet(int v){\\n        size.resize(v,1);\\n        parent.resize(v);\\n        for(int i=0;i<v;i++){\\n            parent[i]=i;\\n        }\\n    }\\n\\n\\n    int findUPar(int node){\\n        if(node==parent[node])return node;\\n\\n        return parent[node]=findUPar(parent[node]);\\n    }    \\n\\n\\n    void unionBySize(int u, int v){\\n        int ulp_u=findUPar(u);\\n        int ulp_v=findUPar(v);\\n        if(ulp_u==ulp_v)return;\\n\\n        if(size[ulp_v]>size[ulp_u]){\\n            parent[ulp_u]=ulp_v;\\n            size[ulp_v]+=size[ulp_u];\\n        }\\n        else{\\n            parent[ulp_v]=ulp_u;\\n            size[ulp_u]+=size[ulp_v];\\n        }\\n    }\\n};\\n\\n\\n\\nclass Solution {\\npublic:\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n       \\n        disjointSet s(n*n);\\n        vector<vector<int>>visited(n,vector<int>(n,0));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j] && !visited[i][j]){\\n                    visited[i][j]=1;\\n                    int dx[]={-1,0,1,0};\\n                    int dy[]={0,-1,0,1};\\n                    for(int k=0;k<4;k++){\\n                        int x=i+dx[k];\\n                        int y=j+dy[k];\\n                        if(x<0 || x>=n || y<0 || y>=n)continue;\\n                        if(grid[x][y]==1){\\n                            if(s.findUPar(n*x + y)!=s.findUPar(n*i + j)){\\n                                s.unionBySize(n*x + y, n*i + j);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        int ans=0;\\n        for(int i=0;i<n*n;i++){\\n            ans=max(ans,s.size[i]);\\n        }\\n\\n\\n\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==0){\\n                    int count=1;\\n                    vector<int>ultimate;\\n                    int dx[]={-1,0,1,0};\\n                    int dy[]={0,-1,0,1};\\n                    for(int k=0;k<4;k++){\\n                        int x=i+dx[k];\\n                        int y=j+dy[k];\\n                        if(x<0 || x>=n || y<0 || y>=n)continue;\\n                        if(visited[x][y]){\\n                            int ultP=s.findUPar(x*n + y);\\n                            if(std::find(ultimate.begin(),ultimate.end(),ultP)==ultimate.end()){\\n                                ultimate.push_back(ultP);\\n                                count+=s.size[ultP];\\n                            }\\n                        }\\n                    }\\n                    ans=max(ans,count);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3610262,
                "title": "easy-dsu-c",
                "content": "# Intuition\\nGraph nature is dynamic and we need to find maximum number of 1\\'s which are connected so for this Brute forcre approach is to run a dfs over every node and find the count of connected components. Time complexity for this will be O(N^4).\\n\\nTo optimse this we can use DSU. first we will find union of all the connected one\\'s. Then on every zero we will take sum of size[parents] of all components which can be connected through {i,j}. (As union will add all other componets and DSU will store Ultimate parent of all nodes and size will total number of children connected with that parent)\\n\\n# Approach\\nWe will use DSU by size to implement it.\\n\\n1. we will find union of all the one\\'s \\n2. ans will be maximum of size array\\n3. traverse in grid if grid[i][j]==0 we will store ultimate(root) parents of all the {x,y} which can be traverse through {i,j} and answer will size[i][j]\\n4. to store in parent and size array we have used fromula i*n+j \\n\\n# Complexity\\n- Time complexity:\\nO(N2 * log(n))\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    /* Dynamic graph -> so DSU  */\\n    int Dparent[999999];\\n    int Dsize[999999];\\n\\n    void DSU(int n){\\n        for(int i=0;i<=n;i+=1){\\n            Dparent[i]=i;\\n            Dsize[i]=1;\\n        }\\n    }\\n\\n    int Dfind(int val){\\n        if(val == Dparent[val]){\\n            return val;\\n        }\\n\\n        return Dparent[val]= Dfind(Dparent[val]);\\n    }\\n\\n    void Dunion(int a,int b){\\n        int pa= Dfind(a), pb=Dfind(b);\\n\\n        if(pa==pb){\\n            return;\\n        }\\n\\n        if(Dsize[pb]>Dsize[pa]) swap(a,b);\\n\\n        Dparent[pb]=pa;\\n        Dsize[pa]+= Dsize[pb];\\n    }\\n\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int ele= n*n;\\n        DSU(ele);\\n\\n        int dx[4]={1,-1,0,0};\\n        int dy[4]={0,0,1,-1};\\n\\n        set<pair<int,int>> st;\\n        int ans=0;\\n        // Initialisation \\n        for(int i=0;i<n;i+=1){\\n            for(int j=0;j<n;j+=1){\\n                if(grid[i][j]==1){\\n                    int ele= i*n+j;\\n                    for(int k=0;k<4;k+=1){\\n                        int x= dx[k]+i;\\n                        int y= dy[k]+j;\\n\\n                        if(x>=0 && y>=0 && x<n && y<n && grid[x][y]==1){\\n                            int newele= x*n+y;\\n                            Dunion(ele,newele);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n*n;i+=1){\\n            ans=max(ans,Dsize[i]);\\n        }\\n\\n\\n\\n        // Now we can change maximum one zero to one in order to get answer\\n        for(int i=0;i<n;i+=1){\\n            for(int j=0;j<n;j+=1){\\n                if(grid[i][j]==0){\\n                    set<int> par;\\n                    int ele= i*n+j;\\n\\n                    for(int k=0;k<4;k+=1){\\n                        int x=dx[k]+i;\\n                        int y=dy[k]+j;\\n\\n                        if(x>=0 && y>=0 && x<n && y<n && grid[x][y]==1){\\n                            par.insert(Dfind(x*n+y));\\n                        }\\n                    }\\n\\n                    int an=1;\\n                    for(auto it:par){\\n                        an+= Dsize[it];\\n                    }\\n                    ans=max(ans,an);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n\\n```\\nPLEASEE UPVOTEE IF IT HELPED YOU",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /* Dynamic graph -> so DSU  */\\n    int Dparent[999999];\\n    int Dsize[999999];\\n\\n    void DSU(int n){\\n        for(int i=0;i<=n;i+=1){\\n            Dparent[i]=i;\\n            Dsize[i]=1;\\n        }\\n    }\\n\\n    int Dfind(int val){\\n        if(val == Dparent[val]){\\n            return val;\\n        }\\n\\n        return Dparent[val]= Dfind(Dparent[val]);\\n    }\\n\\n    void Dunion(int a,int b){\\n        int pa= Dfind(a), pb=Dfind(b);\\n\\n        if(pa==pb){\\n            return;\\n        }\\n\\n        if(Dsize[pb]>Dsize[pa]) swap(a,b);\\n\\n        Dparent[pb]=pa;\\n        Dsize[pa]+= Dsize[pb];\\n    }\\n\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int ele= n*n;\\n        DSU(ele);\\n\\n        int dx[4]={1,-1,0,0};\\n        int dy[4]={0,0,1,-1};\\n\\n        set<pair<int,int>> st;\\n        int ans=0;\\n        // Initialisation \\n        for(int i=0;i<n;i+=1){\\n            for(int j=0;j<n;j+=1){\\n                if(grid[i][j]==1){\\n                    int ele= i*n+j;\\n                    for(int k=0;k<4;k+=1){\\n                        int x= dx[k]+i;\\n                        int y= dy[k]+j;\\n\\n                        if(x>=0 && y>=0 && x<n && y<n && grid[x][y]==1){\\n                            int newele= x*n+y;\\n                            Dunion(ele,newele);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n*n;i+=1){\\n            ans=max(ans,Dsize[i]);\\n        }\\n\\n\\n\\n        // Now we can change maximum one zero to one in order to get answer\\n        for(int i=0;i<n;i+=1){\\n            for(int j=0;j<n;j+=1){\\n                if(grid[i][j]==0){\\n                    set<int> par;\\n                    int ele= i*n+j;\\n\\n                    for(int k=0;k<4;k+=1){\\n                        int x=dx[k]+i;\\n                        int y=dy[k]+j;\\n\\n                        if(x>=0 && y>=0 && x<n && y<n && grid[x][y]==1){\\n                            par.insert(Dfind(x*n+y));\\n                        }\\n                    }\\n\\n                    int an=1;\\n                    for(auto it:par){\\n                        an+= Dsize[it];\\n                    }\\n                    ans=max(ans,an);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3604741,
                "title": "simple-solution-using-dsu",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple intuition using DSU\\nfor more understanding - https://youtu.be/lgiz0Oup6gM\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Connecting all the components using DSU\\n2. Finding out maximum island\\n\\n# Complexity\\n- Time complexity: O(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n# Code\\n```\\nclass DisjoinSet{   \\npublic:\\n    vector<int> rank, parent, size;\\n    DisjoinSet(int n){\\n        rank.resize(n+1, 0);\\n        parent.resize(n+1);\\n        size.resize(n+1);\\n        for(int i=0;i<=n;i++){\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n    int findUPar(int node){\\n        if(node == parent[node]) return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n    void unionByRank(int u, int v){\\n        int ultimateParent_u = findUPar(u);\\n        int ultimateParent_v = findUPar(v);\\n        if(ultimateParent_u == ultimateParent_v) return;\\n        if(rank[ultimateParent_u] < rank[ultimateParent_v]){\\n            parent[ultimateParent_u] = ultimateParent_v;\\n        }\\n        else if(rank[ultimateParent_v] < rank[ultimateParent_u]){\\n            parent[ultimateParent_v] = ultimateParent_u;\\n        }\\n        else{\\n            parent[ultimateParent_v] = ultimateParent_u;\\n            rank[ultimateParent_u]++;\\n        }\\n    }\\n    void unionBySize(int u, int v){\\n        int ultimateParent_u = findUPar(u);\\n        int ultimateParent_v = findUPar(v);\\n        if(ultimateParent_u == ultimateParent_v) return;\\n        if(size[ultimateParent_u] < size[ultimateParent_v]){\\n            parent[ultimateParent_u] = ultimateParent_v;\\n            size[ultimateParent_v] += size[ultimateParent_u];\\n        }\\n        else{\\n            parent[ultimateParent_v] = ultimateParent_u;\\n            size[ultimateParent_u] += size[ultimateParent_v];\\n        }\\n    }\\n\\n};\\nclass Solution {\\nprivate:\\n    bool isValid(int i, int j, int n){\\n        return (i >= 0 && i < n && j >= 0 && j < n);\\n    }\\npublic:\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        DisjoinSet ds(n*n);\\n        //connecting components\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j] == 0) continue;\\n                for(int delrow=-1;delrow<=1;delrow++){\\n                    for(int delcol=-1;delcol<=1;delcol++){\\n                        if(abs(delrow) == abs(delcol)) continue;\\n                        int nrow = delrow + i;\\n                        int ncol = delcol + j;\\n                        if(isValid(nrow, ncol, n) && grid[nrow][ncol] == 1){\\n                            int nodeNo = i * n + j;\\n                            int adjNodeNo = nrow * n + ncol;\\n                            ds.unionBySize(nodeNo, adjNodeNo);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        //finding maximum island\\n        int maxi = 0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j] == 1) continue;\\n                set<int> st;\\n                for(int delrow=-1;delrow<=1;delrow++){\\n                    for(int delcol=-1;delcol<=1;delcol++){\\n                        if(abs(delrow) == abs(delcol)) continue;\\n                        int nrow = delrow + i;\\n                        int ncol = delcol + j;\\n                        if(isValid(nrow, ncol, n)){\\n                            if(grid[nrow][ncol] == 1){\\n                                st.insert(ds.findUPar(nrow * n + ncol));\\n                            }\\n                        }\\n                    }\\n                }\\n                int sizeTotal = 0;\\n                for(auto it: st) sizeTotal += ds.size[it];\\n                maxi = max(maxi, sizeTotal+1);\\n            }\\n        }\\n        for(int i=0;i<n*n;i++){\\n            maxi = max(maxi, ds.size[ds.findUPar(i)]);\\n        }\\n        return maxi;\\n    }\\n};\\n```\\n# \\uD83D\\uDC47 Please Upvote :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DisjoinSet{   \\npublic:\\n    vector<int> rank, parent, size;\\n    DisjoinSet(int n){\\n        rank.resize(n+1, 0);\\n        parent.resize(n+1);\\n        size.resize(n+1);\\n        for(int i=0;i<=n;i++){\\n            parent[i] = i;\\n            size[i] = 1;\\n        }\\n    }\\n    int findUPar(int node){\\n        if(node == parent[node]) return node;\\n        return parent[node] = findUPar(parent[node]);\\n    }\\n    void unionByRank(int u, int v){\\n        int ultimateParent_u = findUPar(u);\\n        int ultimateParent_v = findUPar(v);\\n        if(ultimateParent_u == ultimateParent_v) return;\\n        if(rank[ultimateParent_u] < rank[ultimateParent_v]){\\n            parent[ultimateParent_u] = ultimateParent_v;\\n        }\\n        else if(rank[ultimateParent_v] < rank[ultimateParent_u]){\\n            parent[ultimateParent_v] = ultimateParent_u;\\n        }\\n        else{\\n            parent[ultimateParent_v] = ultimateParent_u;\\n            rank[ultimateParent_u]++;\\n        }\\n    }\\n    void unionBySize(int u, int v){\\n        int ultimateParent_u = findUPar(u);\\n        int ultimateParent_v = findUPar(v);\\n        if(ultimateParent_u == ultimateParent_v) return;\\n        if(size[ultimateParent_u] < size[ultimateParent_v]){\\n            parent[ultimateParent_u] = ultimateParent_v;\\n            size[ultimateParent_v] += size[ultimateParent_u];\\n        }\\n        else{\\n            parent[ultimateParent_v] = ultimateParent_u;\\n            size[ultimateParent_u] += size[ultimateParent_v];\\n        }\\n    }\\n\\n};\\nclass Solution {\\nprivate:\\n    bool isValid(int i, int j, int n){\\n        return (i >= 0 && i < n && j >= 0 && j < n);\\n    }\\npublic:\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        DisjoinSet ds(n*n);\\n        //connecting components\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j] == 0) continue;\\n                for(int delrow=-1;delrow<=1;delrow++){\\n                    for(int delcol=-1;delcol<=1;delcol++){\\n                        if(abs(delrow) == abs(delcol)) continue;\\n                        int nrow = delrow + i;\\n                        int ncol = delcol + j;\\n                        if(isValid(nrow, ncol, n) && grid[nrow][ncol] == 1){\\n                            int nodeNo = i * n + j;\\n                            int adjNodeNo = nrow * n + ncol;\\n                            ds.unionBySize(nodeNo, adjNodeNo);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        //finding maximum island\\n        int maxi = 0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j] == 1) continue;\\n                set<int> st;\\n                for(int delrow=-1;delrow<=1;delrow++){\\n                    for(int delcol=-1;delcol<=1;delcol++){\\n                        if(abs(delrow) == abs(delcol)) continue;\\n                        int nrow = delrow + i;\\n                        int ncol = delcol + j;\\n                        if(isValid(nrow, ncol, n)){\\n                            if(grid[nrow][ncol] == 1){\\n                                st.insert(ds.findUPar(nrow * n + ncol));\\n                            }\\n                        }\\n                    }\\n                }\\n                int sizeTotal = 0;\\n                for(auto it: st) sizeTotal += ds.size[it];\\n                maxi = max(maxi, sizeTotal+1);\\n            }\\n        }\\n        for(int i=0;i<n*n;i++){\\n            maxi = max(maxi, ds.size[ds.findUPar(i)]);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3488255,
                "title": "python-easy-dsu",
                "content": "```\\nclass Solution:\\n    def largestIsland(self, grid: List[List[int]]) -> int:\\n        def find(u):\\n            if u==parent[u]:\\n                return u\\n            else:\\n                parent[u]=find(parent[u])\\n                return parent[u]\\n        def union(u,v):\\n            pu,pv=find(u),find(v)\\n            if pu==pv:\\n                return \\n            if size[pv]>size[pu]:\\n                parent[pu]=pv\\n                size[pv]+=size[pu]\\n            else:\\n                parent[pv]=pu\\n                size[pu]+=size[pv]\\n        \\n        n=len(grid)\\n        parent=[i for i in range(n*n)]\\n        size=[1 for i in range(n*n)]\\n        for i in range(n):\\n            for j in range(n):\\n                if grid[i][j]:\\n                    a=i*n+j\\n                    for u,v in [(i-1,j),(i+1,j),(i,j-1),(i,j+1)]:\\n                        if 0<=u<n and 0<=v<n and grid[u][v]:\\n                            b=u*n+v\\n                            union(a,b)\\n        m=0 \\n        for i in range(n):\\n            for j in range(n):\\n                if grid[i][j]==0:\\n#adjacent elemnts can have the same parent that\\'s why we are using set\\n                    t=set()\\n                    c=1\\n                    for u,v in [(i-1,j),(i+1,j),(i,j-1),(i,j+1)]:\\n                        if 0<=u<n and 0<=v<n and grid[u][v]:\\n                            a=u*n+v\\n                            t.add(find(a))\\n                    for x in t:\\n                        c+=size[x]\\n                    if c>m:\\n                        m=c\\n        for i in range(n*n):\\n            m=max(m,size[find(i)])\\n        return m\\n```\\n\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def largestIsland(self, grid: List[List[int]]) -> int:\\n        def find(u):\\n            if u==parent[u]:\\n                return u\\n            else:\\n                parent[u]=find(parent[u])\\n                return parent[u]\\n        def union(u,v):\\n            pu,pv=find(u),find(v)\\n            if pu==pv:\\n                return \\n            if size[pv]>size[pu]:\\n                parent[pu]=pv\\n                size[pv]+=size[pu]\\n            else:\\n                parent[pv]=pu\\n                size[pu]+=size[pv]\\n        \\n        n=len(grid)\\n        parent=[i for i in range(n*n)]\\n        size=[1 for i in range(n*n)]\\n        for i in range(n):\\n            for j in range(n):\\n                if grid[i][j]:\\n                    a=i*n+j\\n                    for u,v in [(i-1,j),(i+1,j),(i,j-1),(i,j+1)]:\\n                        if 0<=u<n and 0<=v<n and grid[u][v]:\\n                            b=u*n+v\\n                            union(a,b)\\n        m=0 \\n        for i in range(n):\\n            for j in range(n):\\n                if grid[i][j]==0:\\n#adjacent elemnts can have the same parent that\\'s why we are using set\\n                    t=set()\\n                    c=1\\n                    for u,v in [(i-1,j),(i+1,j),(i,j-1),(i,j+1)]:\\n                        if 0<=u<n and 0<=v<n and grid[u][v]:\\n                            a=u*n+v\\n                            t.add(find(a))\\n                    for x in t:\\n                        c+=size[x]\\n                    if c>m:\\n                        m=c\\n        for i in range(n*n):\\n            m=max(m,size[find(i)])\\n        return m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3210395,
                "title": "python-bfs-solution",
                "content": "# Intuition\\nBy replacing water cell to earth cell (0 -> 1) we can either increase area of nearby island by +1 or either connect nearby island by that cell. If there is no nearby island, we got island of size 1.\\nSo, at every water cell we calculate size of possible island `curr_size` and update max size `ans`. \\n\\n# Approach\\nFirstly, we apply Breadth-First Search to find all islands and save size of islands in array `islands_sizes`. Moreover, we mark every visited island as `number` 2, 3, 4.. and `islands_sizes[number - 2]` is a size of island `number`. \\n\\nNext, we iterate over water cells. At every `0` cell, initialy `curr_size = 1`, then we check its neighbours and if it is island `number`, we increase current cell size by size of this neighbour island `islands_sizes[number - 2]`. For this step `neighbours` of current water cell is `set()`, because we have to add size of every neighbour only once.\\n\\n# Complexity\\n- Time complexity: O(N^2)\\nBFS and iterating over all water cells is N^2 + N^2.\\n\\n- Space complexity: O(N^2)\\n`islands_sizes` in the worst case has N*N / 2 elements. So memory is O(N^2).\\n\\n# Code\\n```\\nfrom collections import deque\\nclass Solution:\\n    def largestIsland(self, grid: List[List[int]]) -> int:\\n        i = 0 \\n        j = 0\\n        n = len(grid)\\n        islands_sizes = []\\n        \\n\\n        def vertex_neighb(coord_i, coord_j):\\n            neighbours = []\\n            if coord_j + 1 < n and grid[coord_i][coord_j + 1] == 1:\\n                neighbours.append((coord_i, coord_j + 1))\\n\\n            if coord_j > 0 and grid[coord_i][coord_j - 1] == 1:\\n                neighbours.append((coord_i, coord_j - 1))\\n\\n            if coord_i + 1 < n and grid[coord_i + 1][coord_j] == 1:\\n                neighbours.append((coord_i + 1, coord_j))\\n\\n            if coord_i > 0 and grid[coord_i - 1][coord_j] == 1:\\n                neighbours.append((coord_i - 1, coord_j))\\n\\n            return neighbours\\n\\n        for i in range(n):\\n            for j in range(n):\\n                que = deque([(i, j)])\\n                \\n                if grid[i][j] == 1:\\n                    islands_sizes.append(1)\\n                    while que:\\n                        vertex = que.popleft()\\n                        grid[vertex[0]][vertex[1]] = len(islands_sizes) + 1\\n                        \\n                        for neighb in vertex_neighb(vertex[0], vertex[1]):\\n                            grid[neighb[0]][neighb[1]] = len(islands_sizes) + 1\\n                            islands_sizes[-1] += 1\\n                            que.append((neighb[0], neighb[1]))\\n\\n        if islands_sizes:    \\n            ans = max(islands_sizes)\\n        else:\\n            ans = 0\\n         \\n        for i in range(n):\\n            for j in range(n):\\n                if grid[i][j] == 0:\\n                    neighbours = set()\\n                    if j + 1 < n and grid[i][j + 1] != 0:\\n                        neighbours.add(grid[i][j + 1])\\n\\n                    if j > 0 and grid[i][j - 1] != 0:\\n                        neighbours.add(grid[i][j - 1])\\n\\n                    if i + 1 < n and grid[i + 1][j] != 0:\\n                        neighbours.add(grid[i + 1][j])\\n\\n                    if i > 0 and grid[i - 1][j] != 0:\\n                        neighbours.add(grid[i - 1][j])\\n                    curr_size = 1\\n                    for neighb in neighbours:\\n                        curr_size += islands_sizes[neighb - 2]\\n                    \\n                    ans = max(ans, curr_size)\\n\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def largestIsland(self, grid: List[List[int]]) -> int:\\n        i = 0 \\n        j = 0\\n        n = len(grid)\\n        islands_sizes = []\\n        \\n\\n        def vertex_neighb(coord_i, coord_j):\\n            neighbours = []\\n            if coord_j + 1 < n and grid[coord_i][coord_j + 1] == 1:\\n                neighbours.append((coord_i, coord_j + 1))\\n\\n            if coord_j > 0 and grid[coord_i][coord_j - 1] == 1:\\n                neighbours.append((coord_i, coord_j - 1))\\n\\n            if coord_i + 1 < n and grid[coord_i + 1][coord_j] == 1:\\n                neighbours.append((coord_i + 1, coord_j))\\n\\n            if coord_i > 0 and grid[coord_i - 1][coord_j] == 1:\\n                neighbours.append((coord_i - 1, coord_j))\\n\\n            return neighbours\\n\\n        for i in range(n):\\n            for j in range(n):\\n                que = deque([(i, j)])\\n                \\n                if grid[i][j] == 1:\\n                    islands_sizes.append(1)\\n                    while que:\\n                        vertex = que.popleft()\\n                        grid[vertex[0]][vertex[1]] = len(islands_sizes) + 1\\n                        \\n                        for neighb in vertex_neighb(vertex[0], vertex[1]):\\n                            grid[neighb[0]][neighb[1]] = len(islands_sizes) + 1\\n                            islands_sizes[-1] += 1\\n                            que.append((neighb[0], neighb[1]))\\n\\n        if islands_sizes:    \\n            ans = max(islands_sizes)\\n        else:\\n            ans = 0\\n         \\n        for i in range(n):\\n            for j in range(n):\\n                if grid[i][j] == 0:\\n                    neighbours = set()\\n                    if j + 1 < n and grid[i][j + 1] != 0:\\n                        neighbours.add(grid[i][j + 1])\\n\\n                    if j > 0 and grid[i][j - 1] != 0:\\n                        neighbours.add(grid[i][j - 1])\\n\\n                    if i + 1 < n and grid[i + 1][j] != 0:\\n                        neighbours.add(grid[i + 1][j])\\n\\n                    if i > 0 and grid[i - 1][j] != 0:\\n                        neighbours.add(grid[i - 1][j])\\n                    curr_size = 1\\n                    for neighb in neighbours:\\n                        curr_size += islands_sizes[neighb - 2]\\n                    \\n                    ans = max(ans, curr_size)\\n\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207861,
                "title": "python-dfs-connect-components",
                "content": "# Intuition\\nDFS and components.\\n\\n# Approach\\nCreate seperate components consisting of all islands and mark all elements of every component with a unique id which is >1 to avoid confusion.Now map that id to the area of that component(no of ones in it).\\nNow again traverse the grid and whenever you see a 0, try to check unique components in its 4 directions and add areas of all of them and update max value.\\nIf there is no 0 in grid simply return m*n.\\n\\n# Complexity\\n- Time complexity:\\nO(m*n) [2 pass]\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def largestIsland(self, grid: List[List[int]]) -> int:\\n        m,n=len(grid),len(grid[0])\\n        mp={}\\n        mmax=0\\n        directions=((0,1),(1,0),(0,-1),(-1,0))\\n        def solve(i,j):\\n            ans=1\\n            seen=set()\\n            for di,dj in directions:\\n                ni,nj=i+di,j+dj\\n                if 0<=ni<m and 0<=nj<n and grid[ni][nj]>1:\\n                    id=grid[ni][nj]\\n                    if id not in seen:\\n                        ans+=mp[id]\\n                        seen.add(id)\\n            return ans\\n        def dfs(i,j,id):\\n            nonlocal cnt\\n            cnt+=1\\n            grid[i][j]=id\\n            for di,dj in directions:\\n                ni,nj=i+di,j+dj\\n                if 0<=ni<m and 0<=nj<n and grid[ni][nj]==1:\\n                    dfs(ni,nj,id)\\n        id=2\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j]==1:\\n                    cnt=0\\n                    dfs(i,j,id)\\n                    mp[id]=cnt\\n                    id+=1\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j]==0:\\n                    mmax=max(mmax,solve(i,j))\\n        return mmax if mmax>0 else m*n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def largestIsland(self, grid: List[List[int]]) -> int:\\n        m,n=len(grid),len(grid[0])\\n        mp={}\\n        mmax=0\\n        directions=((0,1),(1,0),(0,-1),(-1,0))\\n        def solve(i,j):\\n            ans=1\\n            seen=set()\\n            for di,dj in directions:\\n                ni,nj=i+di,j+dj\\n                if 0<=ni<m and 0<=nj<n and grid[ni][nj]>1:\\n                    id=grid[ni][nj]\\n                    if id not in seen:\\n                        ans+=mp[id]\\n                        seen.add(id)\\n            return ans\\n        def dfs(i,j,id):\\n            nonlocal cnt\\n            cnt+=1\\n            grid[i][j]=id\\n            for di,dj in directions:\\n                ni,nj=i+di,j+dj\\n                if 0<=ni<m and 0<=nj<n and grid[ni][nj]==1:\\n                    dfs(ni,nj,id)\\n        id=2\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j]==1:\\n                    cnt=0\\n                    dfs(i,j,id)\\n                    mp[id]=cnt\\n                    id+=1\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j]==0:\\n                    mmax=max(mmax,solve(i,j))\\n        return mmax if mmax>0 else m*n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3197071,
                "title": "c-solution-using-dfs-hashmap-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDo graph traversal to find all possible islands and also calculate their area. Then for each possible change (0 to 1) of a cell, we are merging the island of the cell\\'s neighbor if they are form different island.\\n# Approach\\n1. Create a hashmap to store the label of island and its area.\\n2. Iterate over the grid, when we find a land cell, we assign a label to it. Then perform a DFS travesal on that cell to find neighbor land cells. \\n3. The DFS process will calculate the area of the island formed, also mark the land to the label value (considerred it as being visited so we don\\'t check again)\\n4. After iteration and all DFS, our hashmap will now store all the islands in grid together with their area.\\n5. Perform another iteration over the grid again, this time we find any water cell (0) and calculate the merge area of that cell with its neighbor.\\n6. For each merge operation, we use some data structure to keep track of island labels we have merged (the size is at most 4 since we only have 4 neighbors). If a neighbor\\'s label has not been calculated, we add its area from the hashmap to the possible area value. \\n7. Finally compare it with current maximum are value to update if possible after each possible merge.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n*n)$$ where n is the size if grid dimension.\\n 1. Since we for each process (DFS, iterate grid), we only evaluate a cell for once.\\n 2. When grouping islands to find the area, we only process its 4 neighbors and check if island label has been checked, worst case is 6 times if each neighbor belongs to a separate island.\\n- \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n*n)$$. The number of island on average is proportional to number of cells. Since we us a map to store the island and its area, the memory is $$O(n*n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int largestIsland(vector<vector<int>>& grid) {\\n        unordered_map<int, int> island;\\n        int area = 0;\\n        int maxArea = 0;\\n        int islandLabel = 2;\\n        for(int i = 0; i < grid.size(); i++)\\n        {\\n            for(int j = 0; j < grid[0].size(); j++)\\n            {\\n                if(grid[i][j] == 1)\\n                {\\n                    area = 0;\\n                    calculateArea(i, j, islandLabel, area, grid);\\n                    island[islandLabel] = area;\\n                    islandLabel++;\\n                }              \\n            }\\n        }\\n        \\n        if(island.size() == 0) return 1;\\n        maxArea = island.begin()->second;\\n        for(int i = 0; i < grid.size(); i++)\\n        {\\n            for(int j = 0; j < grid[0].size(); j++)\\n            {\\n                if(grid[i][j] == 0)\\n                {\\n                    vector<int> proccessed;\\n                    area = 1;\\n                    if(i > 0 && grid[i-1][j] > 1)\\n                    {\\n                        proccessed.push_back(grid[i-1][j]);\\n                        area += island[grid[i-1][j]];\\n                    }\\n                    if(j > 0 && grid[i][j-1] > 1 && find(proccessed.begin(), proccessed.end(), grid[i][j-1]) == proccessed.end())\\n                    {\\n                        proccessed.push_back(grid[i][j-1]);\\n                        area += island[grid[i][j-1]];\\n                    }\\n                    if(i < grid.size()-1 && grid[i+1][j] > 1 && find(proccessed.begin(), proccessed.end(), grid[i+1][j]) == proccessed.end())\\n                    {\\n                        proccessed.push_back(grid[i+1][j]);\\n                        area += island[grid[i+1][j]];\\n                    }\\n                    if(j < grid[0].size()-1 && grid[i][j+1] > 1 && find(proccessed.begin(), proccessed.end(), grid[i][j+1]) == proccessed.end())\\n                    {\\n                        area += island[grid[i][j+1]];\\n                    }\\n                    maxArea = max(maxArea, area);\\n                }              \\n            }\\n        }\\n        return maxArea;\\n    }\\n\\n    void calculateArea(int i, int j, int label, int& area, vector<vector<int>>& grid)\\n    {\\n        if(i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size())\\n        {\\n            return;\\n        }\\n        if(grid[i][j] != 1) return;\\n        grid[i][j] = label;\\n        area++;\\n        calculateArea(i-1, j, label, area, grid);\\n        calculateArea(i, j-1, label, area, grid);\\n        calculateArea(i+1, j, label, area, grid);\\n        calculateArea(i, j+1, label, area, grid);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestIsland(vector<vector<int>>& grid) {\\n        unordered_map<int, int> island;\\n        int area = 0;\\n        int maxArea = 0;\\n        int islandLabel = 2;\\n        for(int i = 0; i < grid.size(); i++)\\n        {\\n            for(int j = 0; j < grid[0].size(); j++)\\n            {\\n                if(grid[i][j] == 1)\\n                {\\n                    area = 0;\\n                    calculateArea(i, j, islandLabel, area, grid);\\n                    island[islandLabel] = area;\\n                    islandLabel++;\\n                }              \\n            }\\n        }\\n        \\n        if(island.size() == 0) return 1;\\n        maxArea = island.begin()->second;\\n        for(int i = 0; i < grid.size(); i++)\\n        {\\n            for(int j = 0; j < grid[0].size(); j++)\\n            {\\n                if(grid[i][j] == 0)\\n                {\\n                    vector<int> proccessed;\\n                    area = 1;\\n                    if(i > 0 && grid[i-1][j] > 1)\\n                    {\\n                        proccessed.push_back(grid[i-1][j]);\\n                        area += island[grid[i-1][j]];\\n                    }\\n                    if(j > 0 && grid[i][j-1] > 1 && find(proccessed.begin(), proccessed.end(), grid[i][j-1]) == proccessed.end())\\n                    {\\n                        proccessed.push_back(grid[i][j-1]);\\n                        area += island[grid[i][j-1]];\\n                    }\\n                    if(i < grid.size()-1 && grid[i+1][j] > 1 && find(proccessed.begin(), proccessed.end(), grid[i+1][j]) == proccessed.end())\\n                    {\\n                        proccessed.push_back(grid[i+1][j]);\\n                        area += island[grid[i+1][j]];\\n                    }\\n                    if(j < grid[0].size()-1 && grid[i][j+1] > 1 && find(proccessed.begin(), proccessed.end(), grid[i][j+1]) == proccessed.end())\\n                    {\\n                        area += island[grid[i][j+1]];\\n                    }\\n                    maxArea = max(maxArea, area);\\n                }              \\n            }\\n        }\\n        return maxArea;\\n    }\\n\\n    void calculateArea(int i, int j, int label, int& area, vector<vector<int>>& grid)\\n    {\\n        if(i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size())\\n        {\\n            return;\\n        }\\n        if(grid[i][j] != 1) return;\\n        grid[i][j] = label;\\n        area++;\\n        calculateArea(i-1, j, label, area, grid);\\n        calculateArea(i, j-1, label, area, grid);\\n        calculateArea(i+1, j, label, area, grid);\\n        calculateArea(i, j+1, label, area, grid);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3027193,
                "title": "dfs-marking-every-islands-full-explanation-hints-99-87-faster",
                "content": "# Intuition\\nWe can mark all the islands in one full loop. Then we can count all the unique changed indices around an unchanged (zeroes) index one by one and compare to return the maximum of all.\\n\\n# Approach\\nTreat all these points as separate hints and try the problem again after reading a single point (for best results ;)).\\n- We change the index of an island from one to negative of the `currIslands` i.e. if no islands are found then the value of `currIslands` will be `0` and as soon as we come across our first `1`, we will decrement the `currIslands` and change the value of the index to that of `currIslands`. \\n- We can mark these through a dfs function and it will return the number of changed indices, which we will store in a list.\\n- After that we will traverse the indices having the value `0`, and check their neighbouring four indices for unique islands.\\n- We can now calculate the total landmass around the current index (if it were also land) by using the unique neighbouring islands stored landmass value.\\n- Compare it with a variable for maximum result and return the final answer.\\n\\nYou can now try doing the problem, if still in problem, continue reading the code.\\n\\nPS: Please upvote if you liked my explanation, it encourages me to write more.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n\\n- Space complexity: $$O(n^2)$$\\n\\n# Code\\n```\\ndef largestIsland(grid: List[List[int]]) -> int:\\n    n = len(grid)\\n\\n    # A dfs function to mark all the connected indices to \\n    # the passed index to the value of currIslands and\\n    # return the number of connected indices having 1 as its value\\n    def dfs(i: int, j: int) -> int:\\n        if i < 0 or j < 0 or i >= n or j >= n or grid[i][j] != 1:\\n            return 0\\n        grid[i][j] = currIsland\\n        return 1 + dfs(i + 1, j) + dfs(i - 1, j) + dfs(i, j + 1) + dfs(i, j - 1)\\n\\n    # counting the number of islands found\\n    currIsland = 0\\n    # this array stores the landmass of each island\\n    islands = [0]\\n    # marking and finding the landmasses of all the islands\\n    for i in range(n):\\n        for j in range(n):\\n            if grid[i][j] == 1:\\n                currIsland -= 1\\n                islands.append(dfs(i, j))\\n\\n    maxIsland = max(islands)\\n    for i in range(n):\\n        for j in range(n):\\n            if grid[i][j] == 0:\\n                # This set checks for all the unique islands \\n                # on the neighbouring four square\\n                islandsAround = set()\\n                if i > 0 and grid[i - 1][j] < 0:\\n                    islandsAround.add(grid[i - 1][j])\\n                if i < n - 1 and grid[i + 1][j] < 0:\\n                    islandsAround.add(grid[i + 1][j])\\n                if j > 0 and grid[i][j - 1] < 0:\\n                    islandsAround.add(grid[i][j - 1])\\n                if j < n - 1 and grid[i][j + 1] < 0:\\n                    islandsAround.add(grid[i][j + 1])\\n\\n                # calculating the total landmass if this\\n                # index was to be a landmass by using \\n                # previously stored landmasses of all islands\\n                totalLandAround = 1\\n                for k in islandsAround:\\n                    totalLandAround += islands[-k]\\n                maxIsland = max(maxIsland, totalLandAround)\\n    return maxIsland\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\ndef largestIsland(grid: List[List[int]]) -> int:\\n    n = len(grid)\\n\\n    # A dfs function to mark all the connected indices to \\n    # the passed index to the value of currIslands and\\n    # return the number of connected indices having 1 as its value\\n    def dfs(i: int, j: int) -> int:\\n        if i < 0 or j < 0 or i >= n or j >= n or grid[i][j] != 1:\\n            return 0\\n        grid[i][j] = currIsland\\n        return 1 + dfs(i + 1, j) + dfs(i - 1, j) + dfs(i, j + 1) + dfs(i, j - 1)\\n\\n    # counting the number of islands found\\n    currIsland = 0\\n    # this array stores the landmass of each island\\n    islands = [0]\\n    # marking and finding the landmasses of all the islands\\n    for i in range(n):\\n        for j in range(n):\\n            if grid[i][j] == 1:\\n                currIsland -= 1\\n                islands.append(dfs(i, j))\\n\\n    maxIsland = max(islands)\\n    for i in range(n):\\n        for j in range(n):\\n            if grid[i][j] == 0:\\n                # This set checks for all the unique islands \\n                # on the neighbouring four square\\n                islandsAround = set()\\n                if i > 0 and grid[i - 1][j] < 0:\\n                    islandsAround.add(grid[i - 1][j])\\n                if i < n - 1 and grid[i + 1][j] < 0:\\n                    islandsAround.add(grid[i + 1][j])\\n                if j > 0 and grid[i][j - 1] < 0:\\n                    islandsAround.add(grid[i][j - 1])\\n                if j < n - 1 and grid[i][j + 1] < 0:\\n                    islandsAround.add(grid[i][j + 1])\\n\\n                # calculating the total landmass if this\\n                # index was to be a landmass by using \\n                # previously stored landmasses of all islands\\n                totalLandAround = 1\\n                for k in islandsAround:\\n                    totalLandAround += islands[-k]\\n                maxIsland = max(maxIsland, totalLandAround)\\n    return maxIsland\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2915340,
                "title": "c-dsu-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:O(N*N)\\n\\n- Space complexity:O(N*N)\\n\\n# Code\\n```\\nclass disjointset{\\n    public:\\n    vector<int>par, sz;\\n    disjointset(int n){\\n        par.resize(n+1);\\n        sz.resize(n+1);\\n        for(int i=0; i<n; i++){\\n            par[i]=i;\\n            sz[i]=1;\\n        }\\n    }\\n    int findp(int u){\\n        if(u==par[u]){\\n            return u;\\n        }\\n        return par[u]=findp(par[u]);\\n    }\\n    void un(int u, int v){\\n        int pu=findp(u), pv=findp(v);\\n        if(pu==pv){return;}\\n        if(sz[pu]<sz[pv]){\\n            par[pu]=pv;\\n            sz[pv]+=sz[pu];\\n        }\\n        else{\\n            par[pv]=pu;\\n            sz[pu]+=sz[pv];\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    bool chk(int i, int j, int n){return i>=0 && i<n && j>=0 && j<n;}\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int n=grid.size(), cnt=0;\\n        disjointset d(n*n);\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j]==1){\\n                    int r[4]={-1, 0, 1, 0};\\n                    int c[4]={0, -1, 0, 1};\\n                    for(int k=0; k<4; k++){\\n                        int row=r[k]+i, col=c[k]+j;\\n                        if(chk(row, col, n) && grid[row][col]==1){\\n                            d.un(i*n+j, row*n+col);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j]==0){\\n                    set<int>s;\\n                    int r[4]={-1, 0, 1, 0};\\n                    int c[4]={0, -1, 0, 1};\\n                    for(int k=0; k<4; k++){\\n                        int row=r[k]+i, col=c[k]+j;\\n                        if(chk(row, col, n) && grid[row][col]==1){\\n                            s.insert(d.findp(row*n+col));\\n                        }\\n                    }\\n                    int ans=0;\\n                    for(auto it: s){\\n                        ans+=d.sz[d.findp(it)];\\n                    }\\n                    cnt=max(cnt, ans+1);\\n                }\\n            }\\n        }\\n        for(int i=0; i<n*n; i++){\\n            cnt=max(cnt, d.sz[d.findp(i)]);\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find",
                    "Graph",
                    "Matrix"
                ],
                "code": "```\\nclass disjointset{\\n    public:\\n    vector<int>par, sz;\\n    disjointset(int n){\\n        par.resize(n+1);\\n        sz.resize(n+1);\\n        for(int i=0; i<n; i++){\\n            par[i]=i;\\n            sz[i]=1;\\n        }\\n    }\\n    int findp(int u){\\n        if(u==par[u]){\\n            return u;\\n        }\\n        return par[u]=findp(par[u]);\\n    }\\n    void un(int u, int v){\\n        int pu=findp(u), pv=findp(v);\\n        if(pu==pv){return;}\\n        if(sz[pu]<sz[pv]){\\n            par[pu]=pv;\\n            sz[pv]+=sz[pu];\\n        }\\n        else{\\n            par[pv]=pu;\\n            sz[pu]+=sz[pv];\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    bool chk(int i, int j, int n){return i>=0 && i<n && j>=0 && j<n;}\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int n=grid.size(), cnt=0;\\n        disjointset d(n*n);\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j]==1){\\n                    int r[4]={-1, 0, 1, 0};\\n                    int c[4]={0, -1, 0, 1};\\n                    for(int k=0; k<4; k++){\\n                        int row=r[k]+i, col=c[k]+j;\\n                        if(chk(row, col, n) && grid[row][col]==1){\\n                            d.un(i*n+j, row*n+col);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j]==0){\\n                    set<int>s;\\n                    int r[4]={-1, 0, 1, 0};\\n                    int c[4]={0, -1, 0, 1};\\n                    for(int k=0; k<4; k++){\\n                        int row=r[k]+i, col=c[k]+j;\\n                        if(chk(row, col, n) && grid[row][col]==1){\\n                            s.insert(d.findp(row*n+col));\\n                        }\\n                    }\\n                    int ans=0;\\n                    for(auto it: s){\\n                        ans+=d.sz[d.findp(it)];\\n                    }\\n                    cnt=max(cnt, ans+1);\\n                }\\n            }\\n        }\\n        for(int i=0; i<n*n; i++){\\n            cnt=max(cnt, d.sz[d.findp(i)]);\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2891674,
                "title": "c-disjoint-set-approach-by-striver",
                "content": "\\n\\n\\n# Code\\n```\\nclass DisjointSet{\\n    public: \\n    \\n    vector<int>par;\\n    vector<int>size;\\n\\n    DisjointSet(int n){\\n        par.resize(n+1);\\n        size.resize(n+1,1);\\n\\n        for(int i=0;i<=n;i++){\\n            par[i] = i;\\n        }\\n    }\\n\\n    int findpar(int u){\\n        if(u == par[u]){\\n            return u;\\n        }\\n\\n        return par[u] = findpar(par[u]);\\n    }\\n\\n    void unionbysz(int u,int v){\\n        u = findpar(u);\\n        v = findpar(v);\\n\\n        if(u == v) return;\\n\\n        if(size[u] < size[v]){\\n            par[u] = v;\\n            size[v] += size[u];\\n        }\\n        else{\\n            par[v] = u;\\n            size[u] += size[v]; \\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n\\nbool isValid(int i,int j,int n){\\n    if(i<0 || i>=n || j<0 || j>=n){\\n        return false;\\n    }\\n\\n    return true;\\n}\\n    vector<int>dx = {-1,0,1,0};\\n    vector<int>dy = {0,-1,0,1};\\n\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n\\n        DisjointSet ds(n*n);\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n\\n                if(grid[i][j] == 0) continue;\\n\\n                for(int idx=0;idx<4;idx++){\\n                    int newr = i + dx[idx];\\n                    int newc = j + dy[idx];\\n\\n                    if(isValid(newr,newc,n) && grid[newr][newc] == 1){\\n                        int node = i*n + j;\\n                        int adjnode = newr*n + newc;\\n\\n                        ds.unionbysz(node,adjnode);\\n                    }\\n                }\\n            }\\n        }\\n\\n        int mx = 0;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n\\n                if(grid[i][j] == 1) continue;\\n\\n                set<int>set;\\n\\n                for(int idx=0;idx<4;idx++){\\n                    int newr = i + dx[idx];\\n                    int newc = j + dy[idx];\\n\\n                    if(isValid(newr,newc,n) && grid[newr][newc] == 1){\\n                        set.insert(ds.findpar(newr*n + newc));\\n                    }\\n                }\\n\\n                int totalsize = 0;\\n\\n                for(auto it: set){\\n                    totalsize += ds.size[it];\\n                }\\n                mx = max(mx,totalsize + 1);\\n            }\\n        }\\n\\n        mx=max(mx,ds.size[ds.findpar(n*n-1)]);\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass DisjointSet{\\n    public: \\n    \\n    vector<int>par;\\n    vector<int>size;\\n\\n    DisjointSet(int n){\\n        par.resize(n+1);\\n        size.resize(n+1,1);\\n\\n        for(int i=0;i<=n;i++){\\n            par[i] = i;\\n        }\\n    }\\n\\n    int findpar(int u){\\n        if(u == par[u]){\\n            return u;\\n        }\\n\\n        return par[u] = findpar(par[u]);\\n    }\\n\\n    void unionbysz(int u,int v){\\n        u = findpar(u);\\n        v = findpar(v);\\n\\n        if(u == v) return;\\n\\n        if(size[u] < size[v]){\\n            par[u] = v;\\n            size[v] += size[u];\\n        }\\n        else{\\n            par[v] = u;\\n            size[u] += size[v]; \\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n\\nbool isValid(int i,int j,int n){\\n    if(i<0 || i>=n || j<0 || j>=n){\\n        return false;\\n    }\\n\\n    return true;\\n}\\n    vector<int>dx = {-1,0,1,0};\\n    vector<int>dy = {0,-1,0,1};\\n\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n\\n        DisjointSet ds(n*n);\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n\\n                if(grid[i][j] == 0) continue;\\n\\n                for(int idx=0;idx<4;idx++){\\n                    int newr = i + dx[idx];\\n                    int newc = j + dy[idx];\\n\\n                    if(isValid(newr,newc,n) && grid[newr][newc] == 1){\\n                        int node = i*n + j;\\n                        int adjnode = newr*n + newc;\\n\\n                        ds.unionbysz(node,adjnode);\\n                    }\\n                }\\n            }\\n        }\\n\\n        int mx = 0;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n\\n                if(grid[i][j] == 1) continue;\\n\\n                set<int>set;\\n\\n                for(int idx=0;idx<4;idx++){\\n                    int newr = i + dx[idx];\\n                    int newc = j + dy[idx];\\n\\n                    if(isValid(newr,newc,n) && grid[newr][newc] == 1){\\n                        set.insert(ds.findpar(newr*n + newc));\\n                    }\\n                }\\n\\n                int totalsize = 0;\\n\\n                for(auto it: set){\\n                    totalsize += ds.size[it];\\n                }\\n                mx = max(mx,totalsize + 1);\\n            }\\n        }\\n\\n        mx=max(mx,ds.size[ds.findpar(n*n-1)]);\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2761109,
                "title": "disjoint-set-python-striver-s-approach",
                "content": "# Code\\n```\\nclass DisjointSet():\\n    def __init__(self, n):\\n        self.rank = [0] * (n + 1)\\n        self.parent = [i for i in range(n + 1)]\\n        self.size = [1] * (n + 1)\\n\\n    def find_parent(self, node):\\n        if node == self.parent[node]:\\n            return node  # ultimate parent\\n        self.parent[node] = self.find_parent(self.parent[node])\\n        return self.parent[node]\\n\\n    def unionBySize(self, u, v):\\n        u = self.find_parent(u)\\n        v = self.find_parent(v)\\n        if u == v: return\\n        if self.size[u] < self.size[v]:\\n            self.parent[u] = v\\n            self.size[v] += self.size[u]\\n        else:\\n            self.parent[v] = u\\n            self.size[u] += self.size[v]\\n\\nclass Solution:\\n    def largestIsland(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        ds = DisjointSet(n * n)\\n        # first step is connecting the components\\n        delrow = [1, 0, -1, 0]\\n        delcol = [0, 1, 0, -1]\\n        for row in range(n):\\n            for col in range(n):\\n                if grid[row][col] == 0:\\n                    continue\\n                for ind in range(4):\\n                    nrow = row + delrow[ind]\\n                    ncol = col + delcol[ind]\\n                    if nrow >= 0 and nrow < n and ncol >= 0 and ncol < n \\\\\\n                        and grid[nrow][ncol] == 1:\\n                            nodeNo = row * n + col\\n                            adjNodeNo = nrow * n + ncol\\n                            ds.unionBySize(nodeNo, adjNodeNo)\\n        \\n        # making 0 -> 1\\n        sizeOflargestIsland = 0\\n        for row in range(n):\\n            for col in range(n):\\n                if grid[row][col] == 1:\\n                    continue\\n                # storing componenets\\n                setOfComponenents = set()\\n                for ind in range(4):\\n                    nrow = row + delrow[ind]\\n                    ncol = col + delcol[ind]\\n                    if nrow >= 0 and nrow < n and ncol >= 0 and ncol < n \\\\\\n                        and grid[nrow][ncol] == 1:\\n                            adjNodeNo = nrow * n + ncol\\n                            setOfComponenents.add(ds.find_parent(adjNodeNo))\\n                \\n                sizeOfIsland = 0\\n                for it in setOfComponenents:\\n                    sizeOfIsland += ds.size[it]\\n                sizeOflargestIsland = max(sizeOfIsland + 1, sizeOflargestIsland)\\n\\n        sizeOflargestIsland = max(sizeOflargestIsland, ds.size[ds.find_parent(n*n-1)])\\n\\n        return sizeOflargestIsland\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Union Find",
                    "Graph",
                    "Strongly Connected Component"
                ],
                "code": "```\\nclass DisjointSet():\\n    def __init__(self, n):\\n        self.rank = [0] * (n + 1)\\n        self.parent = [i for i in range(n + 1)]\\n        self.size = [1] * (n + 1)\\n\\n    def find_parent(self, node):\\n        if node == self.parent[node]:\\n            return node  # ultimate parent\\n        self.parent[node] = self.find_parent(self.parent[node])\\n        return self.parent[node]\\n\\n    def unionBySize(self, u, v):\\n        u = self.find_parent(u)\\n        v = self.find_parent(v)\\n        if u == v: return\\n        if self.size[u] < self.size[v]:\\n            self.parent[u] = v\\n            self.size[v] += self.size[u]\\n        else:\\n            self.parent[v] = u\\n            self.size[u] += self.size[v]\\n\\nclass Solution:\\n    def largestIsland(self, grid: List[List[int]]) -> int:\\n        n = len(grid)\\n        ds = DisjointSet(n * n)\\n        # first step is connecting the components\\n        delrow = [1, 0, -1, 0]\\n        delcol = [0, 1, 0, -1]\\n        for row in range(n):\\n            for col in range(n):\\n                if grid[row][col] == 0:\\n                    continue\\n                for ind in range(4):\\n                    nrow = row + delrow[ind]\\n                    ncol = col + delcol[ind]\\n                    if nrow >= 0 and nrow < n and ncol >= 0 and ncol < n \\\\\\n                        and grid[nrow][ncol] == 1:\\n                            nodeNo = row * n + col\\n                            adjNodeNo = nrow * n + ncol\\n                            ds.unionBySize(nodeNo, adjNodeNo)\\n        \\n        # making 0 -> 1\\n        sizeOflargestIsland = 0\\n        for row in range(n):\\n            for col in range(n):\\n                if grid[row][col] == 1:\\n                    continue\\n                # storing componenets\\n                setOfComponenents = set()\\n                for ind in range(4):\\n                    nrow = row + delrow[ind]\\n                    ncol = col + delcol[ind]\\n                    if nrow >= 0 and nrow < n and ncol >= 0 and ncol < n \\\\\\n                        and grid[nrow][ncol] == 1:\\n                            adjNodeNo = nrow * n + ncol\\n                            setOfComponenents.add(ds.find_parent(adjNodeNo))\\n                \\n                sizeOfIsland = 0\\n                for it in setOfComponenents:\\n                    sizeOfIsland += ds.size[it]\\n                sizeOflargestIsland = max(sizeOfIsland + 1, sizeOflargestIsland)\\n\\n        sizeOflargestIsland = max(sizeOflargestIsland, ds.size[ds.find_parent(n*n-1)])\\n\\n        return sizeOflargestIsland\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2713088,
                "title": "solution",
                "content": "class Solution {\\n    int count =0;\\n    int max=0;\\n    public int largestIsland(int[][] grid) {\\n        int c=0;\\n        for(int i[]: grid){\\n            for(int j: i){\\n                if(j==1){\\n                    c++;\\n                }\\n            }\\n        }\\n        if(c==0 ){\\n            return 1;// if all are zeroes\\n        }\\n        if(c== grid.length* grid.length){\\n            return c;//if all are ones\\n        }\\n        HashMap<Integer,Integer> hm = new HashMap<>();// storing components \\n        int id=2;\\n        for(int i=0 ; i<grid.length; i++){\\n            for(int j=0; j<grid.length; j++){\\n                if(grid[i][j]==1){\\n                    count=0;\\n                    dfs(grid, i, j, id);\\n                    hm.put(id, count);\\n                    id++;\\n                }\\n            }\\n        }\\n        for(int i=0;i <grid.length; i++){\\n            for(int j=0; j<grid.length; j++){\\n                if(grid[i][j]==0){\\n                    int ansforthatzero = bfs(grid,i , j, hm);\\n                    if(ansforthatzero>max){\\n                        max=ansforthatzero;\\n                    }\\n                }\\n            }\\n        }\\n        return max;\\n        \\n        \\n        \\n    }\\n    public void dfs(int [][]grid, int i, int j, int id){\\n        if(i<0 || j<0 || i>=grid.length || j>= grid.length || grid[i][j]==0 || grid[i][j]==id){\\n            return;\\n        }\\n        count++;\\n        grid[i][j]=id;\\n        dfs(grid, i+1, j, id);\\n        dfs(grid, i, j-1, id);\\n        dfs(grid, i, j+1, id);\\n        dfs(grid, i-1, j, id);\\n        \\n    }\\n    public int  bfs(int [][]grid, int i, int j, HashMap<Integer,Integer> hm){\\n        int dir[][]= {{0,1}, {0,-1}, {1,0}, {-1,0}};\\n        HashSet<Integer> hs= new HashSet<>();\\n        for(int k=0;k<4 ; k++){\\n            int nx= dir[k][0]+i;\\n            int ny= dir[k][1]+j;\\n            if(nx>=0 && ny>=0 && nx<=grid.length-1 && ny<=grid.length-1 && grid[nx][ny]!=0){\\n                hs.add(grid[nx][ny]);//getting all the four direction and adding in hashset because if 0 is surrounded by lets say 2,2,3,4, we cannot add 2 -> 2 times so thats why it is added one time \\n            }\\n        }\\n        int total=1;// total is taken 1  because when 0 is changed to 1 and it will be added to the ans because it is contributing 1 area to it \\n        for(int z: hs){\\n            total+= hm.get(z);\\n        }\\n        return total;\\n    }\\n}",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n    int count =0;\\n    int max=0;\\n    public int largestIsland(int[][] grid) {\\n        int c=0;\\n        for(int i[]: grid){\\n            for(int j: i){\\n                if(j==1){\\n                    c++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2637558,
                "title": "hot-and-sexy-piyasa",
                "content": "```\\n// DSU \\nclass DSU{\\n    private:\\n    vector<int>par,size,rank;\\n\\n   public:\\n    DSU(int n)\\n    {\\n        for(int i=0;i<=n;i++)\\n        {\\n            par.push_back(i);\\n            size.push_back(1);\\n            rank.push_back(0);\\n        }\\n    }\\n\\n    // by size+path \\n    public:\\n    int findPar(int node)\\n    {\\n        if(par[node]==node)return node;  // i am groot\\n        return par[node]=findPar(par[node]);\\n    }\\n\\n    public:\\n    void UnionSize(int u, int v)\\n    {\\n        int pu=findPar(u);\\n        int pv=findPar(v);\\n        if(pu==pv)return;\\n        // size matters\\n        if(size[pu]>size[pv])\\n        {\\n            par[pv]=pu;\\n            size[pu]+=size[pv];\\n        }\\n        else \\n        {\\n            par[pu]=pv;\\n            size[pv]+=size[pu];\\n        }\\n\\n    }\\n    \\n    /*\\n     // by Rank \\n    public:\\n    int findPar(int node)\\n    {\\n        if(par[node]==node)return node;  // i am groot\\n        return par[node]=findPar(par[node]);\\n    }\\n\\n    public:\\n    void UnionRank(int u, int v)\\n    {\\n        int pu=findPar(u);\\n        int pv=findPar(v);\\n        if(pu==pv)return;\\n        // Rank matters\\n        if(rank[pu]>rank[pv])\\n        {\\n            par[pv]=pu;\\n         //   size[pu]+=size[pv];\\n        }\\n        else if(rank[pv]>rank[pu])\\n        {\\n            par[pu]=pv;\\n        //    size[pv]+=size[pu];\\n        }\\n        else{\\n            par[pu]=pv;\\n            rank[pv]++;\\n        }\\n\\n    }\\n    */\\n\\n};\\n\\n\\nclass Solution {\\npublic:\\n\\n    int N;\\n    int dx[4]={1,-1,0,0};\\n    int dy[4]={0,0,1,-1};\\n    \\n    void dfs(int x, int y, vector<vector<int>>& g, vector<vector<int>>& vis, int& baap, DSU& dsu)\\n    {\\n        if(x<0 or y<0 or x>=N or y>=N or g[x][y]==0 or vis[x][y]==1)\\n         return ;\\n        int init=baap;\\n        int curr=x*N+y;\\n        dsu.UnionSize(init,curr);\\n        vis[x][y]=1;\\n        for(int r=0;r<4;r++)\\n            dfs(x+dx[r],y+dy[r],g,vis,baap,dsu);\\n    }\\n    \\n    \\n    int largestIsland(vector<vector<int>>& g) {\\n        int n=g.size();\\n        N=n;\\n            DSU dsu(n*n);\\n        vector<vector<int>> vis(n,vector<int>(n,0));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(g[i][j]==1 && vis[i][j]==0)\\n                {\\n                    int baap=i*N+j;\\n                    dfs(i,j,g,vis,baap,dsu);\\n                }\\n            }\\n        }\\n        \\n        unordered_map<int,int>hp;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                int x=i*N+j;\\n                int P=dsu.findPar(x);\\n                hp[P]++;\\n            }\\n        }\\n        if(hp.size()==1)return n*n;\\n        int nax=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(g[i][j]==0)\\n                {\\n                    unordered_set<int>st;\\n                    for(int r=0;r<4;r++)\\n                    {\\n                        int x=i+dx[r];\\n                        int y=j+dy[r];\\n                        if(x>=0 && y>=0 && x<n && y<n && g[x][y]==1)\\n                            st.insert(dsu.findPar(x*n+y));\\n                        int sum=1;\\n                        for(auto ll: st)\\n                        {\\n                            sum+=hp[ll];\\n                        }\\n                        nax=max(nax,sum);\\n                    }\\n                }\\n            }\\n        }\\n        return nax;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// DSU \\nclass DSU{\\n    private:\\n    vector<int>par,size,rank;\\n\\n   public:\\n    DSU(int n)\\n    {\\n        for(int i=0;i<=n;i++)\\n        {\\n            par.push_back(i);\\n            size.push_back(1);\\n            rank.push_back(0);\\n        }\\n    }\\n\\n    // by size+path \\n    public:\\n    int findPar(int node)\\n    {\\n        if(par[node]==node)return node;  // i am groot\\n        return par[node]=findPar(par[node]);\\n    }\\n\\n    public:\\n    void UnionSize(int u, int v)\\n    {\\n        int pu=findPar(u);\\n        int pv=findPar(v);\\n        if(pu==pv)return;\\n        // size matters\\n        if(size[pu]>size[pv])\\n        {\\n            par[pv]=pu;\\n            size[pu]+=size[pv];\\n        }\\n        else \\n        {\\n            par[pu]=pv;\\n            size[pv]+=size[pu];\\n        }\\n\\n    }\\n    \\n    /*\\n     // by Rank \\n    public:\\n    int findPar(int node)\\n    {\\n        if(par[node]==node)return node;  // i am groot\\n        return par[node]=findPar(par[node]);\\n    }\\n\\n    public:\\n    void UnionRank(int u, int v)\\n    {\\n        int pu=findPar(u);\\n        int pv=findPar(v);\\n        if(pu==pv)return;\\n        // Rank matters\\n        if(rank[pu]>rank[pv])\\n        {\\n            par[pv]=pu;\\n         //   size[pu]+=size[pv];\\n        }\\n        else if(rank[pv]>rank[pu])\\n        {\\n            par[pu]=pv;\\n        //    size[pv]+=size[pu];\\n        }\\n        else{\\n            par[pu]=pv;\\n            rank[pv]++;\\n        }\\n\\n    }\\n    */\\n\\n};\\n\\n\\nclass Solution {\\npublic:\\n\\n    int N;\\n    int dx[4]={1,-1,0,0};\\n    int dy[4]={0,0,1,-1};\\n    \\n    void dfs(int x, int y, vector<vector<int>>& g, vector<vector<int>>& vis, int& baap, DSU& dsu)\\n    {\\n        if(x<0 or y<0 or x>=N or y>=N or g[x][y]==0 or vis[x][y]==1)\\n         return ;\\n        int init=baap;\\n        int curr=x*N+y;\\n        dsu.UnionSize(init,curr);\\n        vis[x][y]=1;\\n        for(int r=0;r<4;r++)\\n            dfs(x+dx[r],y+dy[r],g,vis,baap,dsu);\\n    }\\n    \\n    \\n    int largestIsland(vector<vector<int>>& g) {\\n        int n=g.size();\\n        N=n;\\n            DSU dsu(n*n);\\n        vector<vector<int>> vis(n,vector<int>(n,0));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(g[i][j]==1 && vis[i][j]==0)\\n                {\\n                    int baap=i*N+j;\\n                    dfs(i,j,g,vis,baap,dsu);\\n                }\\n            }\\n        }\\n        \\n        unordered_map<int,int>hp;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                int x=i*N+j;\\n                int P=dsu.findPar(x);\\n                hp[P]++;\\n            }\\n        }\\n        if(hp.size()==1)return n*n;\\n        int nax=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(g[i][j]==0)\\n                {\\n                    unordered_set<int>st;\\n                    for(int r=0;r<4;r++)\\n                    {\\n                        int x=i+dx[r];\\n                        int y=j+dy[r];\\n                        if(x>=0 && y>=0 && x<n && y<n && g[x][y]==1)\\n                            st.insert(dsu.findPar(x*n+y));\\n                        int sum=1;\\n                        for(auto ll: st)\\n                        {\\n                            sum+=hp[ll];\\n                        }\\n                        nax=max(nax,sum);\\n                    }\\n                }\\n            }\\n        }\\n        return nax;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2460067,
                "title": "java-simple-easy-to-understand-using-dsu",
                "content": "```\\n// Approach :- 1. First find the maxSize among the number of islands without updating any value, can be done easily by maintaining size array in dsu.\\n// 2. After finding maxSize, now time to check which zero will help in making greater size, this can be done easily with the of help size array of dsu.\\n// 3. we maintain  set to store the visited parent / root and set will automatically remove duplicate roots\\n// 4 and at last update maxSize by traversing the set and get the value of root/ parent from parent array\\n\\nclass Solution {\\n    int[] par, size;\\n    int maxSize = -(int)1e9;\\n    public int findPar(int u){\\n        return par[u] == u ? u : (par[u] = findPar(par[u]));\\n    }\\n    public void union(int[][] grid, int i, int j, int[][] dir){\\n        int n = grid.length;\\n        int p1 = findPar(i * n + j);\\n        for(int[] d : dir){\\n            int r = i + d[0];\\n            int c = j + d[1];\\n            if(r >= 0 && c >= 0 && r < n && c < n && grid[r][c] == 1){\\n                int p2 = findPar(r * n + c);\\n                if(p1 != p2){\\n                    par[p2] = p1;\\n                    size[p1] += size[p2];\\n                }\\n            }\\n            maxSize = Math.max(maxSize, size[p1]);\\n        }\\n    }\\n    public int largestIsland(int[][] grid) {\\n        int n = grid.length;\\n        int[][] dir = {{1,0},{0,1},{-1,0},{0,-1}};\\n        par = new int[n * n];\\n        size = new int[n * n];\\n        for(int i = 0; i < n * n; i++){\\n            par[i] = i;\\n            size[i] = 1;\\n        }\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] == 1){\\n                    union(grid, i, j, dir);\\n                }\\n            }\\n        }\\n// here finding which zero make greater island\\n//Note :- we only need size, so no need to update grid\\n\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                if(grid[i][j] == 0){\\n                    HashSet<Integer> set = new HashSet<>();\\n                    for(int[] d : dir){\\n                        int r = i + d[0];\\n                        int c = j + d[1];\\n                        if(r >= 0 && c >= 0 && r < n && c < n && grid[r][c] == 1){\\n                            int p = findPar(r * n + c);\\n                            if(!set.contains(p))\\n                                set.add(p);\\n                        }\\n                    }\\n                    int currSize = 1;\\n                    for(int p : set)\\n                        currSize += (size[p]);   \\n        \\n                    maxSize = Math.max(currSize, maxSize);\\n                }\\n            }\\n        }\\n        return maxSize;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "class Solution {\\n    int[] par, size;\\n    int maxSize = -(int)1e9;\\n    public int findPar(int u){\\n        return par[u] == u ? u : (par[u] = findPar(par[u]));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2294186,
                "title": "python-convert-to-classic-union-find-interview-explanation",
                "content": "The objective of my article is not to provide the fastest way to solve this problem.\\nThere are articles by many other which are faster than this.\\nThe objective of this article is to **make minimal changes to a union find template to solve the problem**\\n\\nMy intuition:\\nI have solved the classic union find problem of largest land body.\\nLink: https://leetcode.com/problems/number-of-islands/\\n**Note:** highly recommend you to solve this first as the intuition becomes easier\\n\\nProblem breakdown:\\n1. Find **largest land body**.\\n2. Find which **water body to convert**. (This can be broken down further)\\n\\nNow, I have already **solved step 1 in the question above**.\\nOnly need to check for step 2.\\n\\n**Breaking down step 2** into more managable chunks:\\n1. Check for a water body\\n2. Check it\\'s **unique neighbours**\\n3. **Sum the size** of the unique neighbours\\n4. **Add 1 to this sum** as we converted this water body to land\\n\\n\\nHope my code explains how I am performing all these steps.\\nI have used the word **\"standard\"** to indicate that this can be replaced by any other union find template function.\\n**Note: This can be performed for any rectangular grid too**\\n```\\nclass Solution:\\n    def largestIsland(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        # parent array to keey track\\n        parent = list(range(m*n))\\n        # rank array used for union by rank and size calculation\\n        rank = [1 for _ in range(m*n)]\\n        \\n        # standard DSU find function\\n        def find(x):\\n            while x != parent[x]:\\n                parent[x] = parent[parent[x]]\\n                x = parent[x]\\n            return x\\n        \\n        # standard DSU union by rank function\\n        def union(x,y):\\n            parX, parY = find(x), find(y)\\n            if parX == parY: return\\n            if rank[parX] >= rank[parY]:\\n                rank[parX] += rank[parY]\\n                parent[parY] = parX\\n            else:\\n                rank[parY] += rank[parX]\\n                parent[parX] = parY\\n    \\n        # Step 1: join the land\\n\\n        # for each island we perform union operation\\n        for i, row in enumerate(grid):\\n            for j, val in enumerate(row):\\n                \\n                # important condition: if we have a water body, we set its rank to 0 (will be used in the next step)\\n                if not val: \\n                    rank[i*m+j] = 0\\n                    continue\\n                \\n                # performing union of land bodies\\n                for x,y in [(i-1, j),(i+1, j),(i, j+1),(i, j-1)]:\\n                    # outside of grid check\\n                    if not (0 <= x < m and 0 <= y < n): continue\\n                    \\n                    if grid[x][y]: union(i*m+j, x*m+y)\\n        \\n        # Step 2: convert a water body (if present)\\n        \\n        # the minimum final ans will always be the size of the largest land present \\n        ans = max(rank)\\n        for i, row in enumerate(grid):\\n            for j, val in enumerate(row):\\n                \\n                # we dont need to do anything if we encounter a land\\n                if val: continue\\n                \\n                neighbours = set()\\n                res = 0\\n                \\n                # \\n                for x,y in [(i-1, j),(i+1, j),(i, j+1),(i, j-1)]:\\n                    # outside of grid check\\n                    if not (0 <= x < m and 0 <= y < n): continue\\n                        \\n                    # checking unique neighbours by adding the parent to the set\\n                    # here we dont care if the neighbour is water as its rank is 0 so it contributes nothing\\n                    idx = x*m+y\\n                    neighbours.add(find(idx))\\n                \\n                # Once we have all unique neighbours, just add their ranks\\n                for idx in neighbours:\\n                    res += rank[idx]\\n                \\n                # res + 1 because we convert the current cell (i,j) to land too\\n                ans = max(ans, res+1)\\n        \\n        return ans\\n```\\n\\nTC: O(n^2*alpha(n)) where alpha is inverse ackerman function\\nSC: O(n^2)\\n\\nHappy to help if anyone has any questions",
                "solutionTags": [
                    "Python",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def largestIsland(self, grid: List[List[int]]) -> int:\\n        m, n = len(grid), len(grid[0])\\n        # parent array to keey track\\n        parent = list(range(m*n))\\n        # rank array used for union by rank and size calculation\\n        rank = [1 for _ in range(m*n)]\\n        \\n        # standard DSU find function\\n        def find(x):\\n            while x != parent[x]:\\n                parent[x] = parent[parent[x]]\\n                x = parent[x]\\n            return x\\n        \\n        # standard DSU union by rank function\\n        def union(x,y):\\n            parX, parY = find(x), find(y)\\n            if parX == parY: return\\n            if rank[parX] >= rank[parY]:\\n                rank[parX] += rank[parY]\\n                parent[parY] = parX\\n            else:\\n                rank[parY] += rank[parX]\\n                parent[parX] = parY\\n    \\n        # Step 1: join the land\\n\\n        # for each island we perform union operation\\n        for i, row in enumerate(grid):\\n            for j, val in enumerate(row):\\n                \\n                # important condition: if we have a water body, we set its rank to 0 (will be used in the next step)\\n                if not val: \\n                    rank[i*m+j] = 0\\n                    continue\\n                \\n                # performing union of land bodies\\n                for x,y in [(i-1, j),(i+1, j),(i, j+1),(i, j-1)]:\\n                    # outside of grid check\\n                    if not (0 <= x < m and 0 <= y < n): continue\\n                    \\n                    if grid[x][y]: union(i*m+j, x*m+y)\\n        \\n        # Step 2: convert a water body (if present)\\n        \\n        # the minimum final ans will always be the size of the largest land present \\n        ans = max(rank)\\n        for i, row in enumerate(grid):\\n            for j, val in enumerate(row):\\n                \\n                # we dont need to do anything if we encounter a land\\n                if val: continue\\n                \\n                neighbours = set()\\n                res = 0\\n                \\n                # \\n                for x,y in [(i-1, j),(i+1, j),(i, j+1),(i, j-1)]:\\n                    # outside of grid check\\n                    if not (0 <= x < m and 0 <= y < n): continue\\n                        \\n                    # checking unique neighbours by adding the parent to the set\\n                    # here we dont care if the neighbour is water as its rank is 0 so it contributes nothing\\n                    idx = x*m+y\\n                    neighbours.add(find(idx))\\n                \\n                # Once we have all unique neighbours, just add their ranks\\n                for idx in neighbours:\\n                    res += rank[idx]\\n                \\n                # res + 1 because we convert the current cell (i,j) to land too\\n                ans = max(ans, res+1)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2179606,
                "title": "c-dfs-easy-97",
                "content": "```\\nclass Solution {\\n    const int dx[4]={0,0,1,-1},dy[4]={1,-1,0,0}; //direction array\\npublic:\\n    bool isValid(int x,int y,int n,int m)\\n    {\\n        if(x>=n||x<0||y>=m||y<0)\\n            return 0;\\n        return 1;\\n    }\\n    int siz=0;\\n    void dfs(int x,int y,int n,int m,int counter,vector<vector<int>>&grid){\\n        grid[x][y]=counter; //labeling cell\\n        siz++;\\n        for(int i=0;i<4;i++)\\n        {\\n            int X=x+dx[i];\\n            int Y=y+dy[i];\\n            if(isValid(X,Y,n,m))\\n            {\\n                if(grid[X][Y]==1)\\n                dfs(X,Y,n,m,counter,grid);\\n            }\\n        }\\n    }\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        int counter=2;\\n        vector<int>arr;\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                \\n                if(grid[i][j]==1)\\n                {\\n                    siz=0;\\n                    dfs(i,j,n,m,counter,grid);\\n                    arr.push_back(siz);\\n                    ans=max(ans,siz);\\n                    counter++;\\n                }\\n                \\n            }\\n        }\\n        \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==0)\\n                {\\n                    set<int>s;\\n                    int temp=1;\\n                    for(int k=0;k<4;k++)\\n                    {\\n                        int x=i+dx[k],y=j+dy[k];\\n                        if(isValid(x,y,n,m))\\n                        {\\n                            if(grid[x][y])\\n                            s.insert(grid[x][y]);\\n                        }\\n                    }\\n                    for(auto &it:s)\\n                    {\\n                        \\n                        temp+=arr[it-2];\\n                    }\\n                    ans=max(ans,temp);\\n                }\\n                     \\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    const int dx[4]={0,0,1,-1},dy[4]={1,-1,0,0}; //direction array\\npublic:\\n    bool isValid(int x,int y,int n,int m)\\n    {\\n        if(x>=n||x<0||y>=m||y<0)\\n            return 0;\\n        return 1;\\n    }\\n    int siz=0;\\n    void dfs(int x,int y,int n,int m,int counter,vector<vector<int>>&grid){\\n        grid[x][y]=counter; //labeling cell\\n        siz++;\\n        for(int i=0;i<4;i++)\\n        {\\n            int X=x+dx[i];\\n            int Y=y+dy[i];\\n            if(isValid(X,Y,n,m))\\n            {\\n                if(grid[X][Y]==1)\\n                dfs(X,Y,n,m,counter,grid);\\n            }\\n        }\\n    }\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int n=grid.size(),m=grid[0].size();\\n        int counter=2;\\n        vector<int>arr;\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                \\n                if(grid[i][j]==1)\\n                {\\n                    siz=0;\\n                    dfs(i,j,n,m,counter,grid);\\n                    arr.push_back(siz);\\n                    ans=max(ans,siz);\\n                    counter++;\\n                }\\n                \\n            }\\n        }\\n        \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==0)\\n                {\\n                    set<int>s;\\n                    int temp=1;\\n                    for(int k=0;k<4;k++)\\n                    {\\n                        int x=i+dx[k],y=j+dy[k];\\n                        if(isValid(x,y,n,m))\\n                        {\\n                            if(grid[x][y])\\n                            s.insert(grid[x][y]);\\n                        }\\n                    }\\n                    for(auto &it:s)\\n                    {\\n                        \\n                        temp+=arr[it-2];\\n                    }\\n                    ans=max(ans,temp);\\n                }\\n                     \\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2069840,
                "title": "august-leetcoding-challenge-solution-100-accepted",
                "content": "```\\nclass Solution {\\npublic:\\n    int dir[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\\n    \\n//      for checking if the grid index is not out of bound.\\n    bool isValid(int i,int j,int n){\\n        if(i>=0 && j>=0 && i<n && j<n)return true;\\n        return false;\\n    }\\n    \\n    // making all adjacent one to the diff value.\\n    int dfs(int i,int j,vector<vector<int>> &grid,int num,int n){\\n        if(!isValid(i,j,n) || grid[i][j]!=1)return 0;\\n        \\n        int c=0;\\n        grid[i][j]=num;\\n        c+=dfs(i+1,j,grid,num,n);\\n        c+=dfs(i-1,j,grid,num,n);\\n        c+=dfs(i,j+1,grid,num,n);\\n        c+=dfs(i,j-1,grid,num,n);\\n        return 1+c;\\n    }\\n    \\n    // main fucntion\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int ans=INT_MIN;\\n        int num=2;\\n        vector<int> find(n*n+2);\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1){\\n                    int count=dfs(i,j,grid,num,n);\\n                    find[num]=count;\\n                    num++;\\n                    ans=max(ans,count);\\n                }\\n            }\\n        }\\n        \\n        // looking for maximum one for every index of 0.\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==0){\\n                    set<int> st;\\n                    if(isValid(i+1,j,n)){\\n                        st.insert(grid[i+1][j]);\\n                    }\\n                    if(isValid(i,j+1,n)){\\n                        st.insert(grid[i][j+1]);\\n                    }\\n                    if(isValid(i,j-1,n)){\\n                        st.insert(grid[i][j-1]);\\n                    }\\n                    if(isValid(i-1,j,n)){\\n                        st.insert(grid[i-1][j]);\\n                    }\\n                    int sum=1;\\n                    for(auto it:st){\\n                        sum+=find[it];\\n                    }\\n                    ans=max(ans,sum);\\n                }\\n            }\\n        }\\n        \\n        return ans;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dir[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\\n    \\n//      for checking if the grid index is not out of bound.\\n    bool isValid(int i,int j,int n){\\n        if(i>=0 && j>=0 && i<n && j<n)return true;\\n        return false;\\n    }\\n    \\n    // making all adjacent one to the diff value.\\n    int dfs(int i,int j,vector<vector<int>> &grid,int num,int n){\\n        if(!isValid(i,j,n) || grid[i][j]!=1)return 0;\\n        \\n        int c=0;\\n        grid[i][j]=num;\\n        c+=dfs(i+1,j,grid,num,n);\\n        c+=dfs(i-1,j,grid,num,n);\\n        c+=dfs(i,j+1,grid,num,n);\\n        c+=dfs(i,j-1,grid,num,n);\\n        return 1+c;\\n    }\\n    \\n    // main fucntion\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int ans=INT_MIN;\\n        int num=2;\\n        vector<int> find(n*n+2);\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1){\\n                    int count=dfs(i,j,grid,num,n);\\n                    find[num]=count;\\n                    num++;\\n                    ans=max(ans,count);\\n                }\\n            }\\n        }\\n        \\n        // looking for maximum one for every index of 0.\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==0){\\n                    set<int> st;\\n                    if(isValid(i+1,j,n)){\\n                        st.insert(grid[i+1][j]);\\n                    }\\n                    if(isValid(i,j+1,n)){\\n                        st.insert(grid[i][j+1]);\\n                    }\\n                    if(isValid(i,j-1,n)){\\n                        st.insert(grid[i][j-1]);\\n                    }\\n                    if(isValid(i-1,j,n)){\\n                        st.insert(grid[i-1][j]);\\n                    }\\n                    int sum=1;\\n                    for(auto it:st){\\n                        sum+=find[it];\\n                    }\\n                    ans=max(ans,sum);\\n                }\\n            }\\n        }\\n        \\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2048236,
                "title": "c-with-simple-explanation",
                "content": "I used simple two step process \\n\\n1) Coloured all the island using Depth FIrst-Search and Store their size in Map\\n2) Search the Zeros in Matrix and Explore it all four direction and Simply add the island size and store the biggest possible island connected by this \"zero\" in a variable.\\n\\nNow return biggest possible island, unless it is zero, else return size of whole matrix. because that means no zero exist.\\n```\\nclass Solution {\\npublic:\\n    bool is_safe(int i, int j, int n){\\n        return (i>=0 and j>=0 and i<n and j<n);\\n    }\\n    int dfs(vector<vector<int>>& g, vector<vector<int>> &vis, int i, int j, int clr){\\n        vis[i][j] = clr;\\n        \\n        int x[] = {-1, 1, 0, 0};\\n        int y[] = {0, 0, -1, 1};\\n        \\n        int c = 0;\\n        for(int d=0; d<4; d++){\\n            int nx = i+x[d], ny = j+y[d];\\n            if(is_safe(nx, ny, g.size()) and g[nx][ny]==1 and vis[nx][ny]!=clr){\\n                c += 1+dfs(g, vis, nx, ny, clr);\\n            }\\n        }\\n        return c;\\n    }\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        vector<vector<int>> vis(n, vector<int>(n, 0));\\n        int cnt = 2;\\n        unordered_map<int, int> island_size;\\n        \\n        int x[] = {-1, 1, 0, 0};\\n        int y[] = {0, 0, -1, 1};\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j] and !vis[i][j]){\\n                    int size = 1+dfs(grid, vis, i, j, cnt);\\n                    island_size[cnt] = size;\\n                    cnt++;\\n                }\\n            }\\n        }\\n        \\n        int big = 0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j]==0){\\n                    int temp = 1;\\n                    unordered_set<int> seen;\\n                    for(int d=0; d<4; d++){\\n                        if(is_safe(i+x[d], j+y[d], grid.size()) and vis[i+x[d]][j+y[d]]){\\n                            int clr = vis[i+x[d]][j+y[d]];\\n                            if(seen.find(clr)==seen.end()){\\n                                temp += island_size[clr];\\n                                seen.insert(clr);\\n                            }\\n                        }\\n                    }\\n                    big = max(big, temp);\\n                }\\n            }\\n        }\\n        return big==0?n*n:big;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool is_safe(int i, int j, int n){\\n        return (i>=0 and j>=0 and i<n and j<n);\\n    }\\n    int dfs(vector<vector<int>>& g, vector<vector<int>> &vis, int i, int j, int clr){\\n        vis[i][j] = clr;\\n        \\n        int x[] = {-1, 1, 0, 0};\\n        int y[] = {0, 0, -1, 1};\\n        \\n        int c = 0;\\n        for(int d=0; d<4; d++){\\n            int nx = i+x[d], ny = j+y[d];\\n            if(is_safe(nx, ny, g.size()) and g[nx][ny]==1 and vis[nx][ny]!=clr){\\n                c += 1+dfs(g, vis, nx, ny, clr);\\n            }\\n        }\\n        return c;\\n    }\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        vector<vector<int>> vis(n, vector<int>(n, 0));\\n        int cnt = 2;\\n        unordered_map<int, int> island_size;\\n        \\n        int x[] = {-1, 1, 0, 0};\\n        int y[] = {0, 0, -1, 1};\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j] and !vis[i][j]){\\n                    int size = 1+dfs(grid, vis, i, j, cnt);\\n                    island_size[cnt] = size;\\n                    cnt++;\\n                }\\n            }\\n        }\\n        \\n        int big = 0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j]==0){\\n                    int temp = 1;\\n                    unordered_set<int> seen;\\n                    for(int d=0; d<4; d++){\\n                        if(is_safe(i+x[d], j+y[d], grid.size()) and vis[i+x[d]][j+y[d]]){\\n                            int clr = vis[i+x[d]][j+y[d]];\\n                            if(seen.find(clr)==seen.end()){\\n                                temp += island_size[clr];\\n                                seen.insert(clr);\\n                            }\\n                        }\\n                    }\\n                    big = max(big, temp);\\n                }\\n            }\\n        }\\n        return big==0?n*n:big;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979845,
                "title": "c-solution-straight-forward-to-understand",
                "content": "```\\nclass Solution {\\nprivate: \\n    void findAIsland(vector<vector<int>>& grid, int i, const int j, const int islandInd, int& size)\\n    {\\n        if (grid[i][j] == 0 || grid[i][j] > 1) return;\\n        grid[i][j] = islandInd; size++;\\n        int n = grid.size();\\n        if (i > 0) findAIsland(grid, i-1, j, islandInd, size);\\n        if (i < n -1) findAIsland(grid, i+1, j, islandInd, size);\\n        if (j > 0) findAIsland(grid, i, j - 1, islandInd, size);\\n        if (j < n -1) findAIsland(grid, i, j + 1, islandInd, size);\\n    }\\npublic:\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int islandInd = 2; //Island index, starting from 2\\n        int n = grid.size();\\n        vector<int> islandSizes; // Size of each island\\n        int maxSize = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                int v = grid[i][j];\\n                if (v > 1) continue; //Already checked.\\n                if (v == 1)\\n                {\\n                    int size = 0;\\n                    findAIsland(grid, i, j, islandInd ++, size);\\n                    islandSizes.push_back(size);\\n                    if (size > maxSize) maxSize = size;\\n                }\\n            }\\n        }\\n        cout << maxSize << endl;\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (grid[i][j] == 0)\\n                {\\n                    set<int> nbIslandsInd; //Neighbor islands index, it is possible that more than one neighbor are the same island, use set to make sure the same island only accounted for once.\\n                    if (i > 0 && grid[i-1][j] > 1)\\n                        nbIslandsInd.insert(grid[i-1][j]);\\n                    if (i < (n - 1) && grid[i+1][j] > 1)\\n                        nbIslandsInd.insert(grid[i+1][j]);\\n                    if (j > 0 && grid[i][j - 1] > 1)\\n                        nbIslandsInd.insert(grid[i][j - 1]);\\n                    if (j < (n - 1) && grid[i][j + 1] > 1)\\n                        nbIslandsInd.insert(grid[i][j + 1]); \\n                    int mxTemp = 0; \\n                    for (auto id : nbIslandsInd)\\n                    {\\n                        mxTemp += islandSizes[id - 2];\\n                    }\\n                    maxSize = max(maxSize, mxTemp + 1);\\n                }\\n            }\\n        }\\n        \\n        return maxSize;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate: \\n    void findAIsland(vector<vector<int>>& grid, int i, const int j, const int islandInd, int& size)\\n    {\\n        if (grid[i][j] == 0 || grid[i][j] > 1) return;\\n        grid[i][j] = islandInd; size++;\\n        int n = grid.size();\\n        if (i > 0) findAIsland(grid, i-1, j, islandInd, size);\\n        if (i < n -1) findAIsland(grid, i+1, j, islandInd, size);\\n        if (j > 0) findAIsland(grid, i, j - 1, islandInd, size);\\n        if (j < n -1) findAIsland(grid, i, j + 1, islandInd, size);\\n    }\\npublic:\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int islandInd = 2; //Island index, starting from 2\\n        int n = grid.size();\\n        vector<int> islandSizes; // Size of each island\\n        int maxSize = 0;\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                int v = grid[i][j];\\n                if (v > 1) continue; //Already checked.\\n                if (v == 1)\\n                {\\n                    int size = 0;\\n                    findAIsland(grid, i, j, islandInd ++, size);\\n                    islandSizes.push_back(size);\\n                    if (size > maxSize) maxSize = size;\\n                }\\n            }\\n        }\\n        cout << maxSize << endl;\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (grid[i][j] == 0)\\n                {\\n                    set<int> nbIslandsInd; //Neighbor islands index, it is possible that more than one neighbor are the same island, use set to make sure the same island only accounted for once.\\n                    if (i > 0 && grid[i-1][j] > 1)\\n                        nbIslandsInd.insert(grid[i-1][j]);\\n                    if (i < (n - 1) && grid[i+1][j] > 1)\\n                        nbIslandsInd.insert(grid[i+1][j]);\\n                    if (j > 0 && grid[i][j - 1] > 1)\\n                        nbIslandsInd.insert(grid[i][j - 1]);\\n                    if (j < (n - 1) && grid[i][j + 1] > 1)\\n                        nbIslandsInd.insert(grid[i][j + 1]); \\n                    int mxTemp = 0; \\n                    for (auto id : nbIslandsInd)\\n                    {\\n                        mxTemp += islandSizes[id - 2];\\n                    }\\n                    maxSize = max(maxSize, mxTemp + 1);\\n                }\\n            }\\n        }\\n        \\n        return maxSize;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1593775,
                "title": "c-o-n-2-dfs-with-explanation",
                "content": "The first obvious solution is to traverse all zeros in the grid and do a DFS from there. But since we are doing a DFS on all zeros it would take O((N * N) ^ 2).\\n\\nThe more efficient solution is to store all islands area with a hashmap and their key would be their unique islands id.\\n\\nFor example = \\n```\\ngrid = [[1,1,0,0],\\n        [0,0,1,1],\\n\\t\\t[1,0,0,0]]\\n```\\n\\nAfter doing a DFS on all islands the new grid would be = \\n```\\ngrid = [[2,2,0,0],\\n        [0,0,3,3],\\n\\t\\t[4,0,0,0]]\\nhashmap = {\\n 2 : 2\\n 3: 2\\n 4: 1\\n}\\n//The mark starts at 2 because the islands are represented as 1\\n```\\n```\\n        int mark = 2\\n        unordered_map<int,int> islands_area;\\n        \\n         for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[i].size(); j++){\\n                if(grid[i][j] == 1){\\n                    int count = dfs(i, j, grid, mark); //This returns the area of an island,. If it returns 0 , that means we already have traversed the island before\\n                    \\n                    if(count != 0){\\n                        \\n                        islands_area[mark] = count;\\n                        mark++;\\n                    }\\n                    \\n                }\\n            }\\n        }\\n```\\n\\nAfter we traverse through all the islands, we are gonna traverse to all zeros in the grid and get all adjacent islands area + 1. \\nSince we have already calculated the islands area, we dont need to do a DFS again, we could just get the adjacent islands area in the hashmap and that\\'s why this algorithm is much faster than the brute force one.\\n```\\n for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid.size(); j++){\\n                if(grid[i][j] == 0){\\n                    set<int> unique_islands;\\n                    if(i  -  1 >= 0 && grid[i-1][j] != 0) unique_islands.insert(grid[i- 1][j]);\\n                    if(i  +  1 < grid.size() && grid[i + 1][j] != 0) unique_islands.insert(grid[i+ 1][j]);\\n                    if(j  -  1 >= 0 && grid[i][j - 1] != 0) unique_islands.insert(grid[i][j - 1]);\\n                    if(j  +  1 < grid[0].size() && grid[i][j + 1] != 0) unique_islands.insert(grid[i][j + 1]);\\n                    int sum = 1;\\n                    for(auto i : unique_islands) sum += islands_area[i];\\n                    result = max(result, sum);\\n                }\\n            }\\n        }\\n```\\nFull solution:\\n```\\nclass Solution {\\npublic:\\n    int dfs(int r, int c, vector<vector<int>> &grid, int &mark){      \\n        if(r < 0 || c < 0 || r >= grid.size() || c >= grid[0].size()) return 0;\\n        if(grid[r][c] == 0 || grid[r][c] ==  mark)  return 0;\\n        \\n        grid[r][c] = mark;\\n        int count = 1;\\n        count += dfs(r + 1, c, grid,mark);\\n        count += dfs(r - 1, c , grid, mark);\\n        count += dfs(r, c + 1, grid, mark);\\n        count += dfs(r, c - 1, grid,  mark);\\n        return count;\\n    }\\n    \\n \\n    int largestIsland(vector<vector<int>>& grid) {\\n        int result = 0;\\n        int mark = 2;\\n        unordered_map<int,int> islands_area;\\n        \\n         for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[i].size(); j++){\\n                if(grid[i][j] == 1){\\n                    int count = dfs(i, j, grid, mark);\\n                    \\n                    if(count != 0){\\n                        \\n                        islands_area[mark] = count;\\n                        mark++;\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        \\n        for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid.size(); j++){\\n                if(grid[i][j] == 0){\\n                    set<int> unique_islands;\\n                    if(i  -  1 >= 0 && grid[i-1][j] != 0) unique_islands.insert(grid[i- 1][j]);\\n                    if(i  +  1 < grid.size() && grid[i + 1][j] != 0) unique_islands.insert(grid[i+ 1][j]);\\n                    if(j  -  1 >= 0 && grid[i][j - 1] != 0) unique_islands.insert(grid[i][j - 1]);\\n                    if(j  +  1 < grid[0].size() && grid[i][j + 1] != 0) unique_islands.insert(grid[i][j + 1]);\\n                    int sum = 1;\\n                    for(auto i : unique_islands) sum += islands_area[i];\\n                    result = max(result, sum);\\n                }\\n            }\\n        }\\n        \\n\\n        \\n        return result == 0 ? grid.size() * grid[0].size() : result;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/564c15de-a24e-42a3-835a-95dd49e450d7_1637729750.0463912.png)\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\ngrid = [[1,1,0,0],\\n        [0,0,1,1],\\n\\t\\t[1,0,0,0]]\\n```\n```\\ngrid = [[2,2,0,0],\\n        [0,0,3,3],\\n\\t\\t[4,0,0,0]]\\nhashmap = {\\n 2 : 2\\n 3: 2\\n 4: 1\\n}\\n//The mark starts at 2 because the islands are represented as 1\\n```\n```\\n        int mark = 2\\n        unordered_map<int,int> islands_area;\\n        \\n         for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[i].size(); j++){\\n                if(grid[i][j] == 1){\\n                    int count = dfs(i, j, grid, mark); //This returns the area of an island,. If it returns 0 , that means we already have traversed the island before\\n                    \\n                    if(count != 0){\\n                        \\n                        islands_area[mark] = count;\\n                        mark++;\\n                    }\\n                    \\n                }\\n            }\\n        }\\n```\n```\\n for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid.size(); j++){\\n                if(grid[i][j] == 0){\\n                    set<int> unique_islands;\\n                    if(i  -  1 >= 0 && grid[i-1][j] != 0) unique_islands.insert(grid[i- 1][j]);\\n                    if(i  +  1 < grid.size() && grid[i + 1][j] != 0) unique_islands.insert(grid[i+ 1][j]);\\n                    if(j  -  1 >= 0 && grid[i][j - 1] != 0) unique_islands.insert(grid[i][j - 1]);\\n                    if(j  +  1 < grid[0].size() && grid[i][j + 1] != 0) unique_islands.insert(grid[i][j + 1]);\\n                    int sum = 1;\\n                    for(auto i : unique_islands) sum += islands_area[i];\\n                    result = max(result, sum);\\n                }\\n            }\\n        }\\n```\n```\\nclass Solution {\\npublic:\\n    int dfs(int r, int c, vector<vector<int>> &grid, int &mark){      \\n        if(r < 0 || c < 0 || r >= grid.size() || c >= grid[0].size()) return 0;\\n        if(grid[r][c] == 0 || grid[r][c] ==  mark)  return 0;\\n        \\n        grid[r][c] = mark;\\n        int count = 1;\\n        count += dfs(r + 1, c, grid,mark);\\n        count += dfs(r - 1, c , grid, mark);\\n        count += dfs(r, c + 1, grid, mark);\\n        count += dfs(r, c - 1, grid,  mark);\\n        return count;\\n    }\\n    \\n \\n    int largestIsland(vector<vector<int>>& grid) {\\n        int result = 0;\\n        int mark = 2;\\n        unordered_map<int,int> islands_area;\\n        \\n         for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[i].size(); j++){\\n                if(grid[i][j] == 1){\\n                    int count = dfs(i, j, grid, mark);\\n                    \\n                    if(count != 0){\\n                        \\n                        islands_area[mark] = count;\\n                        mark++;\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        \\n        for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid.size(); j++){\\n                if(grid[i][j] == 0){\\n                    set<int> unique_islands;\\n                    if(i  -  1 >= 0 && grid[i-1][j] != 0) unique_islands.insert(grid[i- 1][j]);\\n                    if(i  +  1 < grid.size() && grid[i + 1][j] != 0) unique_islands.insert(grid[i+ 1][j]);\\n                    if(j  -  1 >= 0 && grid[i][j - 1] != 0) unique_islands.insert(grid[i][j - 1]);\\n                    if(j  +  1 < grid[0].size() && grid[i][j + 1] != 0) unique_islands.insert(grid[i][j + 1]);\\n                    int sum = 1;\\n                    for(auto i : unique_islands) sum += islands_area[i];\\n                    result = max(result, sum);\\n                }\\n            }\\n        }\\n        \\n\\n        \\n        return result == 0 ? grid.size() * grid[0].size() : result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1541069,
                "title": "java-dfs-solution-beat-80-with-explanation",
                "content": "```\\n    private int[][] dirs = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\\n    Map<Integer, Integer> map = new HashMap<>();  //map is used to store <group number -> area>\\n    private int[][] group;\\n\\n    public int largestIsland(int[][] grid) {\\n        if (grid == null || grid.length == 0)\\n            return 0;\\n        int m = grid.length, n = grid[0].length;\\n        group = new int[m][n];\\n\\n        makeIslandGroups(grid, m, n);  //DFS the whole graph to group the island and store each island area into the map\\n\\n        int res = connectGroups(grid, m, n); //Scan the graph, if there is any 0, connect the 0 point with its surrounding groups\\n\\n        if (grid[0][0] == 1 && res == 0) //if any point is 1, but result is 0, mean all points in the graph is 1\\n            return m * n;\\n        return res;\\n    }\\n\\n    private void makeIslandGroups(int[][] grid, int m, int n) {\\n        int groupNum = 1;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    map.put(groupNum, dfs(grid, i, j, m, n, groupNum++));\\n                }\\n\\n            }\\n        }\\n    }\\n\\n    private int connectGroups(int[][] grid, int m, int n) {\\n        int max = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 0) {\\n                    int area = 1;\\n                    Set<Integer> set = new HashSet<>();\\n                    for (int[] dir : dirs) {\\n                        int x = i + dir[0], y = j + dir[1];\\n                        if (x >= 0 && x < m && y >= 0 && y < n && group[x][y] > 0) {\\n                            if (!set.contains(group[x][y])) {  //the surrounding groups may be duplicated, but we need to only add once\\n                                area += map.get(group[x][y]);\\n                                set.add(group[x][y]);\\n                            }\\n                        }\\n                    }\\n                    max = Math.max(max, area);\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n\\n    private int dfs(int[][] grid, int i, int j, int m, int n, int groupNum) {\\n        if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] == 0 || group[i][j] > 0)\\n            return 0;\\n        group[i][j] = groupNum;\\n        int res = 1;\\n        for (int[] dir : dirs) {\\n            res += dfs(grid, i + dir[0], j + dir[1], m, n, groupNum);\\n        }\\n        return res;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    private int[][] dirs = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\\n    Map<Integer, Integer> map = new HashMap<>();  //map is used to store <group number -> area>\\n    private int[][] group;\\n\\n    public int largestIsland(int[][] grid) {\\n        if (grid == null || grid.length == 0)\\n            return 0;\\n        int m = grid.length, n = grid[0].length;\\n        group = new int[m][n];\\n\\n        makeIslandGroups(grid, m, n);  //DFS the whole graph to group the island and store each island area into the map\\n\\n        int res = connectGroups(grid, m, n); //Scan the graph, if there is any 0, connect the 0 point with its surrounding groups\\n\\n        if (grid[0][0] == 1 && res == 0) //if any point is 1, but result is 0, mean all points in the graph is 1\\n            return m * n;\\n        return res;\\n    }\\n\\n    private void makeIslandGroups(int[][] grid, int m, int n) {\\n        int groupNum = 1;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    map.put(groupNum, dfs(grid, i, j, m, n, groupNum++));\\n                }\\n\\n            }\\n        }\\n    }\\n\\n    private int connectGroups(int[][] grid, int m, int n) {\\n        int max = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 0) {\\n                    int area = 1;\\n                    Set<Integer> set = new HashSet<>();\\n                    for (int[] dir : dirs) {\\n                        int x = i + dir[0], y = j + dir[1];\\n                        if (x >= 0 && x < m && y >= 0 && y < n && group[x][y] > 0) {\\n                            if (!set.contains(group[x][y])) {  //the surrounding groups may be duplicated, but we need to only add once\\n                                area += map.get(group[x][y]);\\n                                set.add(group[x][y]);\\n                            }\\n                        }\\n                    }\\n                    max = Math.max(max, area);\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n\\n    private int dfs(int[][] grid, int i, int j, int m, int n, int groupNum) {\\n        if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] == 0 || group[i][j] > 0)\\n            return 0;\\n        group[i][j] = groupNum;\\n        int res = 1;\\n        for (int[] dir : dirs) {\\n            res += dfs(grid, i + dir[0], j + dir[1], m, n, groupNum);\\n        }\\n        return res;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1451022,
                "title": "java-easy-approach-with-explanation-dfs-graph-component-preorder",
                "content": "```\\nclass Solution \\n{//T->O(n^2)  S->O(no of 1)\\n    public int largestIsland(int[][] grid)\\n    {\\n       //island -> component, 0 -> edge(undirected)\\n       int n= grid.length;//grid dimmension \\n       int index= 2;//indexing to store the Unique island area into the HashMap \\n        \\n       HashMap<Integer, Integer> map= new HashMap<>();//index -- area\\n        \\n       map.put(0, 0);//putting the 0 because when we are provided with only 0 matrix \\n       //like component finding in a disconnected undirected graph \\n       for(int i= 0; i< n; i++)\\n       {\\n           for(int j= 0; j< n; j++)\\n           {\\n               if(grid[i][j] == 1)\\n               {\\n                   int area= calcIslandArea(grid, n, i, j, index);//calculating the area of the island and storing into the area into the HashMap with a unique index \\n                   map.put(index, area);\\n                   index+= 1;//increasing the index for the next island or the component \\n               }\\n           }\\n       }\\n        \\n       int[][] trav= {{0,1},{0,-1},{1,0},{-1,0}};//traversing in 4 Direction \\n       int max0ConnectedArea= map.getOrDefault(2, 0);//putting the area of the first component if present in the map, else putting 0 \\n       for(int i= 0; i< n; i++)\\n       {\\n           for(int j= 0; j< n; j++)\\n           {\\n               if(grid[i][j] == 0)\\n               {\\n                   Set<Integer> set= new HashSet<>();//set stores only unique values \\n                   \\n                   //Searching(island) in 4 Direction of 0\\n                   for(int []dirc: trav)\\n                   {\\n                       //Current Updated co-ordinate\\n                       int i_= i+ dirc[0];\\n                       int j_= j+ dirc[1];\\n                       \\n                       if(i_< 0 || i_ >= n || j_< 0 || j_>= n)\\n                           continue;//index out of bound case \\n                       \\n                       set.add(grid[i_][j_]);//adding the island index into the set\\n                   }\\n                   \\n                   int surroundedArea= 1;//initializing with 1 because we are including 0 as the part of connected island area\\n                   for(int idx: set)\\n                       surroundedArea+= map.get(idx);//calculating the area\\n                   \\n                   max0ConnectedArea= Math.max(max0ConnectedArea, surroundedArea);//updating the current maximum connected island area, due to 0 swapping to 1\\n               }\\n           }\\n       }\\n       //0 is acting as a unit length bridge between two component or island \\n       return max0ConnectedArea;//returning the maximum connected island area, due to swapping of one 0 to 1 \\n    }\\n    \\n    private int calcIslandArea(int[][] grid, int n, int i, int j, int index)\\n    {//Preorder DFS Approach \\n        if(i< 0 || i >= n || j< 0 || j>= n || grid[i][j] != 1)\\n            return 0;\\n        \\n        grid[i][j]= index;//marking it as visited \\n        \\n        //Recursing down in 4 Direction \\n        int top= calcIslandArea(grid, n, i-1, j, index);\\n        int right= calcIslandArea(grid, n, i, j+1, index);\\n        int bottom= calcIslandArea(grid, n, i+1, j, index);\\n        int left= calcIslandArea(grid, n,i, j-1, index);\\n        \\n        return 1+ top+ right+ bottom+ left;//including me and moving in depth \\n    }\\n}//Please do Upvote, it helps a lot \\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution \\n{//T->O(n^2)  S->O(no of 1)\\n    public int largestIsland(int[][] grid)\\n    {\\n       //island -> component, 0 -> edge(undirected)\\n       int n= grid.length;//grid dimmension \\n       int index= 2;//indexing to store the Unique island area into the HashMap \\n        \\n       HashMap<Integer, Integer> map= new HashMap<>();//index -- area\\n        \\n       map.put(0, 0);//putting the 0 because when we are provided with only 0 matrix \\n       //like component finding in a disconnected undirected graph \\n       for(int i= 0; i< n; i++)\\n       {\\n           for(int j= 0; j< n; j++)\\n           {\\n               if(grid[i][j] == 1)\\n               {\\n                   int area= calcIslandArea(grid, n, i, j, index);//calculating the area of the island and storing into the area into the HashMap with a unique index \\n                   map.put(index, area);\\n                   index+= 1;//increasing the index for the next island or the component \\n               }\\n           }\\n       }\\n        \\n       int[][] trav= {{0,1},{0,-1},{1,0},{-1,0}};//traversing in 4 Direction \\n       int max0ConnectedArea= map.getOrDefault(2, 0);//putting the area of the first component if present in the map, else putting 0 \\n       for(int i= 0; i< n; i++)\\n       {\\n           for(int j= 0; j< n; j++)\\n           {\\n               if(grid[i][j] == 0)\\n               {\\n                   Set<Integer> set= new HashSet<>();//set stores only unique values \\n                   \\n                   //Searching(island) in 4 Direction of 0\\n                   for(int []dirc: trav)\\n                   {\\n                       //Current Updated co-ordinate\\n                       int i_= i+ dirc[0];\\n                       int j_= j+ dirc[1];\\n                       \\n                       if(i_< 0 || i_ >= n || j_< 0 || j_>= n)\\n                           continue;//index out of bound case \\n                       \\n                       set.add(grid[i_][j_]);//adding the island index into the set\\n                   }\\n                   \\n                   int surroundedArea= 1;//initializing with 1 because we are including 0 as the part of connected island area\\n                   for(int idx: set)\\n                       surroundedArea+= map.get(idx);//calculating the area\\n                   \\n                   max0ConnectedArea= Math.max(max0ConnectedArea, surroundedArea);//updating the current maximum connected island area, due to 0 swapping to 1\\n               }\\n           }\\n       }\\n       //0 is acting as a unit length bridge between two component or island \\n       return max0ConnectedArea;//returning the maximum connected island area, due to swapping of one 0 to 1 \\n    }\\n    \\n    private int calcIslandArea(int[][] grid, int n, int i, int j, int index)\\n    {//Preorder DFS Approach \\n        if(i< 0 || i >= n || j< 0 || j>= n || grid[i][j] != 1)\\n            return 0;\\n        \\n        grid[i][j]= index;//marking it as visited \\n        \\n        //Recursing down in 4 Direction \\n        int top= calcIslandArea(grid, n, i-1, j, index);\\n        int right= calcIslandArea(grid, n, i, j+1, index);\\n        int bottom= calcIslandArea(grid, n, i+1, j, index);\\n        int left= calcIslandArea(grid, n,i, j-1, index);\\n        \\n        return 1+ top+ right+ bottom+ left;//including me and moving in depth \\n    }\\n}//Please do Upvote, it helps a lot \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1386416,
                "title": "making-a-large-island-c-with-comments-and-picture",
                "content": "![image](https://assets.leetcode.com/users/images/736d70b9-0819-4657-9091-9c52b7e3b362_1628228002.8591135.png)\\n\\nFirst we will run DFS and update each group with unique ID and also keep track of area.\\n\\n![image](https://assets.leetcode.com/users/images/601ad6e8-7028-4f0b-8717-4d977e700dbb_1628228066.59406.png)\\n\\n\\nAfter this we will traverse the grid and for each 0, we will add the unique grid areas and find max which can be formed.\\n\\n\\n\\n\\n```\\n\\n```class Solution {\\npublic:\\n    bool isValid(int r,int c,int rows,int cols)\\n    {\\n        return r>=0 && r<rows && c>=0 && c<cols;\\n    }\\n    void dfs(int row,int col,int rows,int cols,vector<vector<int>>& grid,int id,int& area)\\n    {\\n        if(!isValid(row,col,rows,cols) || grid[row][col]==id || grid[row][col]==0)\\n            return;\\n        grid[row][col]=id;\\n        area++;\\n        dfs(row+1,col,rows,cols,grid,id,area);\\n        dfs(row-1,col,rows,cols,grid,id,area);\\n        dfs(row,col+1,rows,cols,grid,id,area);\\n        dfs(row,col-1,rows,cols,grid,id,area);\\n    }\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int rows=grid.size(),cols=grid[0].size(),id=2,maxArea=0,maxMergeArea=0;\\n        map<int,int> gridArea;\\n        for(int i=0;i<rows;i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    int area=0;\\n                    dfs(i,j,rows,cols,grid,id,area);             // Run DFS and update the connected 1\\'s with id and keep track of area in map-> gridArea\\n                    gridArea[id]=area;\\n                    id++;\\n                    maxArea=max(maxArea,area);\\n                }\\n            }\\n        }\\n\\t\\t//Now we have the second image, grid which has ID and map which has area. We can traverse the grid and for each 0, we will find the neighbor with unique gridID and calculate the area that can we formed with merging all unique grids surrounding 0.\\n        for(int i=0;i<rows;i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n                if(grid[i][j]==0)\\n                {\\n                    int mergeArea=1;      // Initial area is 1 because we are reverting 0 to 1, Now check all 4 directions and add unique Grid\\'s area.\\n                    map<int,int> m;\\n                    if(i-1>=0 && grid[i-1][j]!=0)\\n                    {\\n                        mergeArea+=gridArea[grid[i-1][j]];\\n                        m[grid[i-1][j]]++;\\n                    }\\n                    if(i+1<rows && grid[i+1][j]!=0)\\n                    {\\n                        if(m[grid[i+1][j]]==0)\\n                        {\\n                            mergeArea+=gridArea[grid[i+1][j]];\\n                            m[grid[i+1][j]]++;\\n                        }\\n                    }\\n                    if(j-1>=0 && grid[i][j-1]!=0)\\n                    {\\n                        if(m[grid[i][j-1]]==0)\\n                        {\\n                            mergeArea+=gridArea[grid[i][j-1]];\\n                            m[grid[i][j-1]]++;\\n                        }\\n                    }\\n                    if(j+1<cols && grid[i][j+1]!=0)\\n                    {\\n                        if(m[grid[i][j+1]]==0)\\n                        {\\n                            mergeArea+=gridArea[grid[i][j+1]];\\n                            m[grid[i][j+1]]++;\\n                        }\\n                    }\\n                    maxMergeArea=max(maxMergeArea,mergeArea);\\n                }\\n            }\\n        }\\n        return max(maxArea,maxMergeArea);\\n    }\\n};``",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1377243,
                "title": "python-3-solution-clean-80-fast-dfs",
                "content": "```\\nclass Solution:\\n    def largestIsland(self, grid: List[List[int]]) -> int:\\n        \\n        directions=[[1,0],[-1,0],[0,1],[0,-1]]\\n        def getislandsize(grid,i,j,islandID):\\n            if i <0 or j<0 or i>=len(grid) or j>=len(grid[0]) or grid[i][j]!=1:\\n                return 0\\n            grid[i][j]=islandID\\n            left=getislandsize(grid,i,j-1,islandID)\\n            right=getislandsize(grid,i,j+1,islandID)\\n            top=getislandsize(grid,i-1,j,islandID)\\n            bottom=getislandsize(grid,i+1,j,islandID)\\n            return left+right+top+bottom+1\\n                \\n        \\n\\n        if grid ==0 or len(grid)== 0:\\n            return 0\\n        else:\\n            maxx=0\\n            islandID=2\\n            m=len(grid)\\n            n=len(grid[0])\\n            mapp={}\\n            for i in range(0,m):\\n                for j in range (0,n):\\n                    if grid[i][j]==1:\\n                        size=getislandsize(grid,i,j,islandID)\\n                        maxx=max(maxx,size)\\n                        mapp[islandID]=size\\n                        islandID+=1\\n                        \\n            \\n            for i in range(0,m):\\n                for j in range (0,n):\\n                    if grid[i][j]==0:\\n                        sett=set()\\n                        for direction in directions:\\n                            x=direction[0]+i\\n                            y=direction[1]+j\\n                            if x>-1 and y>-1 and x<m and y<n and grid[x][y]!=0:\\n                                sett.add(grid[x][y])\\n                                \\n                                \\n                        summ=1\\n                        for num in sett:\\n                            value=mapp[num]\\n                            summ+=value\\n                        maxx=max(maxx,summ)\\n            return maxx\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestIsland(self, grid: List[List[int]]) -> int:\\n        \\n        directions=[[1,0],[-1,0],[0,1],[0,-1]]\\n        def getislandsize(grid,i,j,islandID):\\n            if i <0 or j<0 or i>=len(grid) or j>=len(grid[0]) or grid[i][j]!=1:\\n                return 0\\n            grid[i][j]=islandID\\n            left=getislandsize(grid,i,j-1,islandID)\\n            right=getislandsize(grid,i,j+1,islandID)\\n            top=getislandsize(grid,i-1,j,islandID)\\n            bottom=getislandsize(grid,i+1,j,islandID)\\n            return left+right+top+bottom+1\\n                \\n        \\n\\n        if grid ==0 or len(grid)== 0:\\n            return 0\\n        else:\\n            maxx=0\\n            islandID=2\\n            m=len(grid)\\n            n=len(grid[0])\\n            mapp={}\\n            for i in range(0,m):\\n                for j in range (0,n):\\n                    if grid[i][j]==1:\\n                        size=getislandsize(grid,i,j,islandID)\\n                        maxx=max(maxx,size)\\n                        mapp[islandID]=size\\n                        islandID+=1\\n                        \\n            \\n            for i in range(0,m):\\n                for j in range (0,n):\\n                    if grid[i][j]==0:\\n                        sett=set()\\n                        for direction in directions:\\n                            x=direction[0]+i\\n                            y=direction[1]+j\\n                            if x>-1 and y>-1 and x<m and y<n and grid[x][y]!=0:\\n                                sett.add(grid[x][y])\\n                                \\n                                \\n                        summ=1\\n                        for num in sett:\\n                            value=mapp[num]\\n                            summ+=value\\n                        maxx=max(maxx,summ)\\n            return maxx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1376199,
                "title": "detailed-explanation-of-dsu-approach-diagrams-annotated-code-python3",
                "content": "## 0. Understanding the Problem\\nGiven: A binary matrix\\nGoal: Return the largest possible island if we can flip one `0` to `1`. Think about it this way: flipping the *special* index from 0 to 1 is able to connect neighbouring islands, thus forming the largest island possible.\\n\\nExample:\\n![](https://i.imgur.com/tb1Zj9m.png)\\n\\nIn this case, forming a bridge of sorts between the top two islands is the best option, like so:\\n\\n![](https://i.imgur.com/aAyuBGe.png)\\n\\n## 1. Analogy\\nThink of the 0s as sea/ocean and 1s as land. On this land are living people. Each land piece of 1x1 has thus one person. \\n\\nGoal is to find the location of bridge. We only have one, and it too spans 1x1 block.\\n\\nNow while these islanders are happy on their own, to govern the territory, they appoint kings. These kings are the *representative* of the entire island. \\n\\nEach islander can thus start as their own kings, but as they take note of their *neighbouring* territories, they have to battle it out. The king with the bigger territory wins, and takes command over the other\\'s lands. In case there is a tie, we make the first one (index wise) to be the king.\\n\\nThe kings for our map are thus marked with a flag.\\n![](https://i.imgur.com/XeeIG58.png)\\n\\n## 2. Translation & DSU\\nThis problem can thus be solved by DSU. \\n\\n- Each \"king\" is just the representative of a particular disjoint set.\\n- The battle is just \"union\" of the sets. The bigger king wins because its the most efficient in allocation.\\n- Each \"islander\" starts as their own \"king\", aka in the DSU, `king[u] = u`.\\n- For taking account of their \"land sizes\", we have another dictionary, `size[u] = 1`, initialised by 1.\\n\\n\\nNow the solution will make sense. **For each cell in the map/grid, find if the sum of territories held by kings is the maximum possible or not.**\\n\\n## 3. Annotated Code\\n```\\nclass DSU:\\n    def __init__(self):\\n        self.king = {} # king = {location:location_of_king}\\n        self.size = {} # size[location] = size of territory under the king\\n    \\n    # initially, every islander is king\\n    # and territory size is 1\\n    def make_king(self, u):\\n        self.king[u] = u\\n        self.size[u] = 1\\n\\t\\n\\t# returns the king of a particular islander\\n    def find_king(self, u):\\n        if self.king[u] == u:\\n            return u\\n        self.king[u] = self.find_king(self.king[u]) # path compression, check references\\n        return self.king[u]\\n    \\n\\t# kings battle it out. first we find the rulers of lands u and v\\n    def unite_kings(self, u, v):\\n        u = self.find_king(u)\\n        v = self.find_king(v)\\n        \\n        if u == v: return\\n        if not self.size[u] > self.size[v]: u, v = v, u    \\n        # u gets the territory\\n        self.size[u] += self.size[v]\\n        self.king[v] = self.king[u] # v is now ruled by u\\n\\n    \\nclass Solution:\\n\\t# returns valid neighbours of graph with a particular value\\n\\t# if val is None, return both 0s and 1s containing neighbours\\n    def get_neighbours(self, u, val=None):\\n        r, c = u\\n        ans = []\\n        for dr, dc in zip([-1, 1, 0, 0], [0, 0, 1, -1]):\\n            nr, nc = r+dr, c+dc\\n            if 0 <= nr < self.n and 0 <= nc < self.n: # if in the valid range\\n                if val == 0 and self.grid[nr][nc] == 0: ans.append((nr, nc))\\n                if val == 1 and self.grid[nr][nc] == 1: ans.append((nr, nc))\\n                if val is None: ans.append((nr, nc))\\n        return ans\\n\\n    def largestIsland(self, grid: List[List[int]]) -> int:\\n        dsu = DSU()\\n        self.grid = grid\\n        self.n = len(grid)\\n        \\n        for r in range(self.n):\\n            for c in range(self.n):\\n                if grid[r][c]:\\n                    dsu.make_king((r, c)) # each islander is made king initially\\n        \\n        for r in range(self.n):\\n            for c in range(self.n):\\n                if grid[r][c]:\\n                    for neighbour in self.get_neighbours((r, c), val=1):\\n                        dsu.unite_kings(neighbour, (r, c)) # the kings battle it out\\n\\n        ans = -inf\\n        for r in range(self.n):\\n            for c in range(self.n):\\n                if not grid[r][c]:\\n\\t\\t\\t\\t# finding the unique kings surrounding the current location\\n                    kings = list(set([dsu.find_king(neighbour) for neighbour in self.get_neighbours((r, c), val=1)]))\\n\\t\\t\\t\\t\\t# getting the sum of all of their sizes\\n\\t\\t\\t\\t\\t# +1 because the current cell is also becoming 1 from a 0\\n                    ans = max(ans, 1+sum([dsu.size[king] for king in kings]))\\n\\n\\t\\t# if no cell is accessed, all are 1s.\\n        if ans == -inf: ans = self.n*self.n\\n        return ans\\n```\\n\\n## 4. References\\nhttps://cp-algorithms.com/data_structures/disjoint_set_union.html\\n\\nAny questions? Ask! Comments and criticisms are welcome. An upvote lets me know this is helpful!",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass DSU:\\n    def __init__(self):\\n        self.king = {} # king = {location:location_of_king}\\n        self.size = {} # size[location] = size of territory under the king\\n    \\n    # initially, every islander is king\\n    # and territory size is 1\\n    def make_king(self, u):\\n        self.king[u] = u\\n        self.size[u] = 1\\n\\t\\n\\t# returns the king of a particular islander\\n    def find_king(self, u):\\n        if self.king[u] == u:\\n            return u\\n        self.king[u] = self.find_king(self.king[u]) # path compression, check references\\n        return self.king[u]\\n    \\n\\t# kings battle it out. first we find the rulers of lands u and v\\n    def unite_kings(self, u, v):\\n        u = self.find_king(u)\\n        v = self.find_king(v)\\n        \\n        if u == v: return\\n        if not self.size[u] > self.size[v]: u, v = v, u    \\n        # u gets the territory\\n        self.size[u] += self.size[v]\\n        self.king[v] = self.king[u] # v is now ruled by u\\n\\n    \\nclass Solution:\\n\\t# returns valid neighbours of graph with a particular value\\n\\t# if val is None, return both 0s and 1s containing neighbours\\n    def get_neighbours(self, u, val=None):\\n        r, c = u\\n        ans = []\\n        for dr, dc in zip([-1, 1, 0, 0], [0, 0, 1, -1]):\\n            nr, nc = r+dr, c+dc\\n            if 0 <= nr < self.n and 0 <= nc < self.n: # if in the valid range\\n                if val == 0 and self.grid[nr][nc] == 0: ans.append((nr, nc))\\n                if val == 1 and self.grid[nr][nc] == 1: ans.append((nr, nc))\\n                if val is None: ans.append((nr, nc))\\n        return ans\\n\\n    def largestIsland(self, grid: List[List[int]]) -> int:\\n        dsu = DSU()\\n        self.grid = grid\\n        self.n = len(grid)\\n        \\n        for r in range(self.n):\\n            for c in range(self.n):\\n                if grid[r][c]:\\n                    dsu.make_king((r, c)) # each islander is made king initially\\n        \\n        for r in range(self.n):\\n            for c in range(self.n):\\n                if grid[r][c]:\\n                    for neighbour in self.get_neighbours((r, c), val=1):\\n                        dsu.unite_kings(neighbour, (r, c)) # the kings battle it out\\n\\n        ans = -inf\\n        for r in range(self.n):\\n            for c in range(self.n):\\n                if not grid[r][c]:\\n\\t\\t\\t\\t# finding the unique kings surrounding the current location\\n                    kings = list(set([dsu.find_king(neighbour) for neighbour in self.get_neighbours((r, c), val=1)]))\\n\\t\\t\\t\\t\\t# getting the sum of all of their sizes\\n\\t\\t\\t\\t\\t# +1 because the current cell is also becoming 1 from a 0\\n                    ans = max(ans, 1+sum([dsu.size[king] for king in kings]))\\n\\n\\t\\t# if no cell is accessed, all are 1s.\\n        if ans == -inf: ans = self.n*self.n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1376135,
                "title": "making-a-large-island-simple-dfs-c",
                "content": "| |Algorithm| |\\n\\n->first mark each and every island present initially with unique colors (this can be done using a simple dfs).\\n->then iterate through every index . if grid[i][j]==0 then we need to check if any of its 4 adjacent cells has grid[i][j]>0.\\n->if grid[i][j] >0 then we increase our ans by hashmap[grid[i][j]] .doing this for all 4 adjacent cells we update our max ans every time.(hashmap stores the count of every color in their respective island).\\n->return maxans\\n\\ncode in c++\\n\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int dx[4]={1,-1,0,0};\\n    int dy[4]={0,0,1,-1};\\n    int visit[501][501];\\n    map<int,int>mp;\\n    int val=2;\\n    int n;\\n    void dfs(int x,int y,vector<vector<int>>& grid)\\n    {\\n        visit[x][y]=1;\\n        ans++;\\n\\t\\t//marking the color\\n        grid[x][y]=val;\\n        for(int i=0;i<4;i++){\\n            int newx=x+dx[i];\\n            int newy=y+dy[i];\\n            if(newx>=0&&newx<n&&newy>=0&&newy<n&&!visit[newx][newy]&&grid[newx][newy]==1){\\n                dfs(newx,newy,grid);\\n            }\\n        }\\n        return;\\n        \\n        \\n    }\\n    int largestIsland(vector<vector<int>>& grid) {\\n        n=grid.size();\\n        int maxi=1;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(!visit[i][j]&&grid[i][j]==1){\\n                    dfs(i,j,grid);\\n\\t\\t\\t\\t\\t//marking size of each color island\\n                    mp[val]=ans;\\n                    ans=0;\\n                    val++;\\n                    \\n                }\\n            }\\n        }\\n        if(mp.count(2))\\n        maxi=mp[2];\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                ans=0;\\n                set<int>s;\\n                if(grid[i][j]==0)\\n                {for(int kk=0;kk<4;kk++){\\n                    int newx=i+dx[kk];\\n                    int newy=j+dy[kk];\\n                    if(newx>=0&&newy<n&&newx<n&&newy>=0&&grid[newx][newy]>0&&s.find(grid[newx][newy])==s.end()){\\n                        ans+=mp[grid[newx][newy]];\\n                        s.insert(grid[newx][newy]);\\n                    }\\n                }\\n                maxi=max(maxi,ans+1);}\\n            }\\n        }\\n                    \\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int dx[4]={1,-1,0,0};\\n    int dy[4]={0,0,1,-1};\\n    int visit[501][501];\\n    map<int,int>mp;\\n    int val=2;\\n    int n;\\n    void dfs(int x,int y,vector<vector<int>>& grid)\\n    {\\n        visit[x][y]=1;\\n        ans++;\\n\\t\\t//marking the color\\n        grid[x][y]=val;\\n        for(int i=0;i<4;i++){\\n            int newx=x+dx[i];\\n            int newy=y+dy[i];\\n            if(newx>=0&&newx<n&&newy>=0&&newy<n&&!visit[newx][newy]&&grid[newx][newy]==1){\\n                dfs(newx,newy,grid);\\n            }\\n        }\\n        return;\\n        \\n        \\n    }\\n    int largestIsland(vector<vector<int>>& grid) {\\n        n=grid.size();\\n        int maxi=1;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(!visit[i][j]&&grid[i][j]==1){\\n                    dfs(i,j,grid);\\n\\t\\t\\t\\t\\t//marking size of each color island\\n                    mp[val]=ans;\\n                    ans=0;\\n                    val++;\\n                    \\n                }\\n            }\\n        }\\n        if(mp.count(2))\\n        maxi=mp[2];\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                ans=0;\\n                set<int>s;\\n                if(grid[i][j]==0)\\n                {for(int kk=0;kk<4;kk++){\\n                    int newx=i+dx[kk];\\n                    int newy=j+dy[kk];\\n                    if(newx>=0&&newy<n&&newx<n&&newy>=0&&grid[newx][newy]>0&&s.find(grid[newx][newy])==s.end()){\\n                        ans+=mp[grid[newx][newy]];\\n                        s.insert(grid[newx][newy]);\\n                    }\\n                }\\n                maxi=max(maxi,ans+1);}\\n            }\\n        }\\n                    \\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1376002,
                "title": "python-simple-python-dfs-with-value-markers",
                "content": "```\\nclass Solution:\\n    def largestIsland(self, grid: List[List[int]]) -> int:\\n        gsize = [0, 0]    # Size of each group, index start from 2\\n        cur = 2\\n        \\n        def dfs(i, j, cur):\\n            if i < 0 or j < 0 or i == len(grid) or j == len(grid[0]) or grid[i][j] != 1: return\\n            gsize[cur] += 1\\n            grid[i][j] = cur\\n            for di, dj in [(-1, 0), (0, -1), (1, 0), (0, 1)]: \\n                dfs(i + di, j + dj, cur)\\n            \\n        todo = []\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):        \\n                if grid[i][j] == 0: todo.append((i, j))\\n                elif grid[i][j] == 1: \\n                    gsize.append(0)\\n                    dfs(i, j, cur)\\n                    cur += 1    # Move to the next group\\n                    \\n        if not todo: return gsize[2]    # Edge case: no zero in grid\\n        ans = 0\\n        for i, j in todo:\\n            visited = set()\\n            cur = 1\\n            for di, dj in [(-1, 0), (0, -1), (1, 0), (0, 1)]:\\n                if 0 <= i + di < len(grid) and 0 <= j + dj < len(grid[0]) and \\\\\\n                    grid[i + di][j + dj] not in visited:\\n                    cur += gsize[grid[i + di][j + dj]]\\n                    visited.add(grid[i + di][j + dj])\\n            ans = max(ans, cur)\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def largestIsland(self, grid: List[List[int]]) -> int:\\n        gsize = [0, 0]    # Size of each group, index start from 2\\n        cur = 2\\n        \\n        def dfs(i, j, cur):\\n            if i < 0 or j < 0 or i == len(grid) or j == len(grid[0]) or grid[i][j] != 1: return\\n            gsize[cur] += 1\\n            grid[i][j] = cur\\n            for di, dj in [(-1, 0), (0, -1), (1, 0), (0, 1)]: \\n                dfs(i + di, j + dj, cur)\\n            \\n        todo = []\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):        \\n                if grid[i][j] == 0: todo.append((i, j))\\n                elif grid[i][j] == 1: \\n                    gsize.append(0)\\n                    dfs(i, j, cur)\\n                    cur += 1    # Move to the next group\\n                    \\n        if not todo: return gsize[2]    # Edge case: no zero in grid\\n        ans = 0\\n        for i, j in todo:\\n            visited = set()\\n            cur = 1\\n            for di, dj in [(-1, 0), (0, -1), (1, 0), (0, 1)]:\\n                if 0 <= i + di < len(grid) and 0 <= j + dj < len(grid[0]) and \\\\\\n                    grid[i + di][j + dj] not in visited:\\n                    cur += gsize[grid[i + di][j + dj]]\\n                    visited.add(grid[i + di][j + dj])\\n            ans = max(ans, cur)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1351798,
                "title": "javascript-dfs-paint-grid-208ms-99-42",
                "content": "reference: https://leetcode.com/problems/making-a-large-island/discuss/127015/C%2B%2B-with-picture-O(n*m)\\n```\\nlet n, m, g, color;\\nconst largestIsland = (grid) => {\\n    g = grid;\\n    n = g.length;\\n    m = g[0].length;\\n    let res = 0;\\n    let sizes = [0, 0];\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < m; j++) {\\n            if (g[i][j] == 1) {\\n                let size = paint(i, j, sizes.length);\\n                sizes.push(size);\\n            }\\n        }\\n    }\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < m; j++) {\\n            if (g[i][j] == 0) {\\n                let se = new Set([getColor(i + 1, j), getColor(i - 1, j), getColor(i, j + 1), getColor(i, j - 1)]);\\n                let newSize = 1;\\n                for (const color of se) {\\n                    newSize += sizes[color];\\n                }\\n                res = Math.max(res, newSize);\\n            }\\n        }\\n    }\\n    return res == 0 ? n * m : res;\\n};\\n\\nconst paint = (i, j, color) => {\\n    if (getColor(i, j) != 1) return 0;\\n    g[i][j] = color;\\n    return 1 + paint(i + 1, j, color) + paint(i - 1, j, color) + paint(i, j + 1, color) + paint(i, j - 1, color);\\n};\\n\\nconst getColor = (i, j) => {\\n    return (i < 0 || j < 0 || i >= n || j >= m) ? 0 : g[i][j];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nlet n, m, g, color;\\nconst largestIsland = (grid) => {\\n    g = grid;\\n    n = g.length;\\n    m = g[0].length;\\n    let res = 0;\\n    let sizes = [0, 0];\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < m; j++) {\\n            if (g[i][j] == 1) {\\n                let size = paint(i, j, sizes.length);\\n                sizes.push(size);\\n            }\\n        }\\n    }\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < m; j++) {\\n            if (g[i][j] == 0) {\\n                let se = new Set([getColor(i + 1, j), getColor(i - 1, j), getColor(i, j + 1), getColor(i, j - 1)]);\\n                let newSize = 1;\\n                for (const color of se) {\\n                    newSize += sizes[color];\\n                }\\n                res = Math.max(res, newSize);\\n            }\\n        }\\n    }\\n    return res == 0 ? n * m : res;\\n};\\n\\nconst paint = (i, j, color) => {\\n    if (getColor(i, j) != 1) return 0;\\n    g[i][j] = color;\\n    return 1 + paint(i + 1, j, color) + paint(i - 1, j, color) + paint(i, j + 1, color) + paint(i, j - 1, color);\\n};\\n\\nconst getColor = (i, j) => {\\n    return (i < 0 || j < 0 || i >= n || j >= m) ? 0 : g[i][j];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1325963,
                "title": "beautiful-understandable-java-clean-optimal-sleek",
                "content": "```\\nclass Solution {\\n    /*\\n      Thoughts:\\n\\n      Unvisited islands maintain the value of 1. Once an island is visited recursively\\n      through a depth first search, its index is overwritten with a unique island tag.\\n      Depth first search will also compute size of island, so that the island\\'s tag\\n      is associated with its size.\\n      \\n      Once the array has been modified to have each island distinguished by a different\\n      numeric tag, must compute the square which is 0 and has the largest neighbors.\\n      \\n      Edge case - no islands: return 1 as filling in a square results in an island of 1\\n      Edge case - one big island: return the size of that big island\\n      Main occurence - size of that 0\\'s neighbors added together, plus 1,\\n                        as that 0 is the land bridge to connect the islands\\n      \\n    */\\n    private HashMap<Integer,Integer> islandSizes;\\n    private int n;\\n  \\n    public int largestIsland(int[][] grid) {\\n      n = grid.length;\\n      islandSizes = new HashMap<>();\\n      \\n      int islandTag = 2;\\n        for(int row = 0; row < n; row++)\\n          for(int col = 0; col < n; col++)\\n            if(grid[row][col] == 1)\\n              islandSizes.put(islandTag, sizeOfIsland(row,col,grid, islandTag++));\\n        \\n        int max = 1;\\n        for(Integer i : islandSizes.values())\\n          max = Math.max(max,i);\\n        for(int row = 0; row < n; row++)\\n          for(int col = 0; col < n; col++)\\n            if(grid[row][col] == 0)\\n              max = Math.max(max, maxNeighborValue(row,col, grid));\\n      \\n        return max;\\n    }\\n    /**\\n\\tOverwrites the island and its connections with islandTag, returns the total size of the\\n\\tconnected component (i.e. island)\\n\\t*/\\n    private int sizeOfIsland(int row, int col, int[][] grid, int islandTag){\\n      if(row >= n || col >= n || col < 0 || row < 0)\\n        return 0;\\n      else if (grid[row][col] != 1)\\n        return 0;\\n      else {\\n        grid[row][col] = islandTag;\\n        return 1 + sizeOfIsland(row+1,col,grid, islandTag) +\\n                   sizeOfIsland(row-1,col,grid, islandTag) +\\n                   sizeOfIsland(row,col+1,grid, islandTag) +\\n                   sizeOfIsland(row,col-1,grid, islandTag);\\n      }\\n    }\\n\\t\\n   /**\\n   Computes the size of the connected component (e.g. island) formed by turning this coordinate\\n   into land\\n   */\\n    private int maxNeighborValue(int row, int col, int[][] grid){\\n      Set<Integer> neighbors = new HashSet<>();\\n      if(col + 1 < n)\\n        neighbors.add(grid[row][col+1]);\\n      if(col - 1 >= 0)\\n        neighbors.add(grid[row][col-1]);\\n      if(row + 1 < n)\\n        neighbors.add(grid[row+1][col]);\\n      if(row - 1 >= 0 )\\n        neighbors.add(grid[row-1][col]);\\n      \\n      int sum = 1;\\n      for(Integer neighbor : neighbors)\\n        sum += islandSizes.getOrDefault(neighbor,0);\\n      return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    /*\\n      Thoughts:\\n\\n      Unvisited islands maintain the value of 1. Once an island is visited recursively\\n      through a depth first search, its index is overwritten with a unique island tag.\\n      Depth first search will also compute size of island, so that the island\\'s tag\\n      is associated with its size.\\n      \\n      Once the array has been modified to have each island distinguished by a different\\n      numeric tag, must compute the square which is 0 and has the largest neighbors.\\n      \\n      Edge case - no islands: return 1 as filling in a square results in an island of 1\\n      Edge case - one big island: return the size of that big island\\n      Main occurence - size of that 0\\'s neighbors added together, plus 1,\\n                        as that 0 is the land bridge to connect the islands\\n      \\n    */\\n    private HashMap<Integer,Integer> islandSizes;\\n    private int n;\\n  \\n    public int largestIsland(int[][] grid) {\\n      n = grid.length;\\n      islandSizes = new HashMap<>();\\n      \\n      int islandTag = 2;\\n        for(int row = 0; row < n; row++)\\n          for(int col = 0; col < n; col++)\\n            if(grid[row][col] == 1)\\n              islandSizes.put(islandTag, sizeOfIsland(row,col,grid, islandTag++));\\n        \\n        int max = 1;\\n        for(Integer i : islandSizes.values())\\n          max = Math.max(max,i);\\n        for(int row = 0; row < n; row++)\\n          for(int col = 0; col < n; col++)\\n            if(grid[row][col] == 0)\\n              max = Math.max(max, maxNeighborValue(row,col, grid));\\n      \\n        return max;\\n    }\\n    /**\\n\\tOverwrites the island and its connections with islandTag, returns the total size of the\\n\\tconnected component (i.e. island)\\n\\t*/\\n    private int sizeOfIsland(int row, int col, int[][] grid, int islandTag){\\n      if(row >= n || col >= n || col < 0 || row < 0)\\n        return 0;\\n      else if (grid[row][col] != 1)\\n        return 0;\\n      else {\\n        grid[row][col] = islandTag;\\n        return 1 + sizeOfIsland(row+1,col,grid, islandTag) +\\n                   sizeOfIsland(row-1,col,grid, islandTag) +\\n                   sizeOfIsland(row,col+1,grid, islandTag) +\\n                   sizeOfIsland(row,col-1,grid, islandTag);\\n      }\\n    }\\n\\t\\n   /**\\n   Computes the size of the connected component (e.g. island) formed by turning this coordinate\\n   into land\\n   */\\n    private int maxNeighborValue(int row, int col, int[][] grid){\\n      Set<Integer> neighbors = new HashSet<>();\\n      if(col + 1 < n)\\n        neighbors.add(grid[row][col+1]);\\n      if(col - 1 >= 0)\\n        neighbors.add(grid[row][col-1]);\\n      if(row + 1 < n)\\n        neighbors.add(grid[row+1][col]);\\n      if(row - 1 >= 0 )\\n        neighbors.add(grid[row-1][col]);\\n      \\n      int sum = 1;\\n      for(Integer neighbor : neighbors)\\n        sum += islandSizes.getOrDefault(neighbor,0);\\n      return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1208781,
                "title": "c-dfs",
                "content": "```\\npublic class Solution {\\n    \\n    private int[] dx = {-1, 1, 0, 0};\\n    private int[] dy = {0, 0, -1, 1};\\n    public int LargestIsland(int[][] grid) {\\n        \\n        int m = grid.Length;\\n        int n = grid[0].Length;   \\n        \\n        int groupId = 2; //gotcha, can\\'t have 0 or 1\\n        var map = new Dictionary<int, int>();\\n        \\n        var max = 0; \\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++)\\n            {               \\n                if(grid[i][j] == 1)\\n                {                      \\n                    map.Add(groupId, helper(grid, i, j, groupId));                    \\n                    max = Math.Max(max, map[groupId]); //gtocha  \\n                    groupId++;\\n                }                \\n            }   \\n        \\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++)\\n            {\\n                var set = new HashSet<int>();  \\n                if(grid[i][j] == 0)\\n                {                    \\n                    for(int k = 0; k < 4; k++)\\n                    {\\n                        var row = i + dx[k];\\n                        var col = j + dy[k];\\n\\n                        if(row >= 0 && row < grid.Length && col >= 0 && col < grid[0].Length && grid[row][col] > 1 && !set.Contains(grid[row][col])) //gothca\\n                            set.Add(grid[row][col]);\\n                    }                    \\n                }\\n                var curMax = 0;\\n                foreach(var id in set)\\n                {\\n                    curMax += map[id];\\n                }\\n                max = Math.Max(max, 1 + curMax);\\n            }\\n        \\n        return max;        \\n    }\\n    \\n    private int helper(int[][] grid, int r, int c, int groupId)\\n    {\\n        int area = 0;\\n        grid[r][c] = groupId;              \\n        \\n        for(int i = 0; i < 4; i++)\\n        {\\n            var row = r + dx[i];\\n            var col = c + dy[i];\\n            \\n            if(row >= 0 && row < grid.Length && col >= 0 && col < grid[0].Length && grid[row][col] == 1)\\n                area += helper(grid, row, col, groupId);\\n        }\\n        return 1 + area;\\n    }\\n}\\n\\n// Idea:\\n// 1) We run dfs for each 1 and get the size of the island, we mark the 1s with a GroupId.\\n// 2) We then store the groupid and count in a Map\\n// 3) We then loop over the grid and for each 0, see if we can merge islands by checking the adjoining islands\\n//   and claculate the largest island\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    \\n    private int[] dx = {-1, 1, 0, 0};\\n    private int[] dy = {0, 0, -1, 1};\\n    public int LargestIsland(int[][] grid) {\\n        \\n        int m = grid.Length;\\n        int n = grid[0].Length;   \\n        \\n        int groupId = 2; //gotcha, can\\'t have 0 or 1\\n        var map = new Dictionary<int, int>();\\n        \\n        var max = 0; \\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++)\\n            {               \\n                if(grid[i][j] == 1)\\n                {                      \\n                    map.Add(groupId, helper(grid, i, j, groupId));                    \\n                    max = Math.Max(max, map[groupId]); //gtocha  \\n                    groupId++;\\n                }                \\n            }   \\n        \\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++)\\n            {\\n                var set = new HashSet<int>();  \\n                if(grid[i][j] == 0)\\n                {                    \\n                    for(int k = 0; k < 4; k++)\\n                    {\\n                        var row = i + dx[k];\\n                        var col = j + dy[k];\\n\\n                        if(row >= 0 && row < grid.Length && col >= 0 && col < grid[0].Length && grid[row][col] > 1 && !set.Contains(grid[row][col])) //gothca\\n                            set.Add(grid[row][col]);\\n                    }                    \\n                }\\n                var curMax = 0;\\n                foreach(var id in set)\\n                {\\n                    curMax += map[id];\\n                }\\n                max = Math.Max(max, 1 + curMax);\\n            }\\n        \\n        return max;        \\n    }\\n    \\n    private int helper(int[][] grid, int r, int c, int groupId)\\n    {\\n        int area = 0;\\n        grid[r][c] = groupId;              \\n        \\n        for(int i = 0; i < 4; i++)\\n        {\\n            var row = r + dx[i];\\n            var col = c + dy[i];\\n            \\n            if(row >= 0 && row < grid.Length && col >= 0 && col < grid[0].Length && grid[row][col] == 1)\\n                area += helper(grid, row, col, groupId);\\n        }\\n        return 1 + area;\\n    }\\n}\\n\\n// Idea:\\n// 1) We run dfs for each 1 and get the size of the island, we mark the 1s with a GroupId.\\n// 2) We then store the groupid and count in a Map\\n// 3) We then loop over the grid and for each 0, see if we can merge islands by checking the adjoining islands\\n//   and claculate the largest island\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1043727,
                "title": "c-unionfind-16-ms-faster-than-99-02",
                "content": "```\\nclass Solution {\\n    \\n    struct UnionFind {\\n        UnionFind(int x, int y):parent(x*y), rank(x*y,1) {\\n            N = x;\\n            M = y;\\n            for(int i = 0; i < x; i++) {\\n                for(int j = 0; j < y; j++) {\\n                    int idx = M * i + j;\\n                    parent[idx] = idx;\\n                }\\n            }\\n        }\\n        \\n        void make_union(pair<int,int> x, pair<int,int> y) {\\n            auto px = find(x);\\n            auto py = find(y);\\n            if(px == py) \\n                return;\\n            \\n            parent[py] = px;\\n            rank[px] += rank[py];\\n        }\\n        \\n        int find(pair<int,int> x) {\\n            int idx = M * x.first + x.second;\\n            while(parent[idx] != idx) {\\n                idx = parent[idx];\\n            }\\n            return idx;\\n        }\\n        \\n        int get_rank(pair<int,int> x) {\\n            int idx = M * x.first + x.second;\\n            return rank[idx];\\n        }\\n        int get_rank(int idx) {\\n            return rank[idx];\\n        }        \\n        \\n        vector<int> parent;\\n        vector<int> rank;\\n        int N;\\n        int M;\\n    };\\n    \\n    int N;\\n    int M;\\n    \\npublic:\\n    int largestIsland(vector<vector<int>>& grid) {\\n        N = grid.size();\\n        M = grid[0].size();\\n        \\n        UnionFind uf(grid.size(), grid[0].size());\\n        \\n        for(int j = 1; j < M; j++) {\\n            if(grid[0][j-1] >0 && grid[0][j] > 0 ) {\\n                uf.make_union( {0, j-1}, {0, j});\\n            }\\n        }\\n        \\n        for(int i = 1; i < N; i++) {\\n            for(int j = 0; j < M; j++) {\\n                if(grid[i-1][j] >0 && grid[i][j] > 0 ) {\\n                    uf.make_union( {i-1, j}, {i, j});\\n                }                \\n                if(j > 0 && grid[i][j-1] >0 && grid[i][j] > 0 ) {\\n                    uf.make_union( {i, j-1}, {i, j});\\n                }\\n            }\\n        }\\n        \\n        \\n        int maxIsland = 0;\\n        int delta[] = {0,1,0,-1,0};\\n        int zeroFound = false;\\n        \\n        for(int i = 0; i < N; i++) {\\n            for(int j = 0; j < M; j++) {\\n                \\n                if(grid[i][j] > 0)\\n                    continue;\\n                \\n                zeroFound = true;\\n                                \\n                map<int, int> newIsland;\\n                for(int d = 0; d < 4; d++) {\\n                    int i1 = i + delta[d];\\n                    int j1 = j + delta[d+1];\\n                    \\n                    if(i1 >=0 && j1 >= 0 && i1< N && j1 < M && grid[i1][j1] > 0) {\\n                        auto p = uf.find({i1,j1});\\n                        newIsland[p] = uf.get_rank(p);\\n                    }\\n                }\\n\\n                int newSize = 1;\\n                for(auto& a : newIsland) {\\n                    newSize += a.second;\\n                }\\n                maxIsland = max(maxIsland, newSize);\\n            }\\n        }\\n                                \\n        return zeroFound ? maxIsland : N*M;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    struct UnionFind {\\n        UnionFind(int x, int y):parent(x*y), rank(x*y,1) {\\n            N = x;\\n            M = y;\\n            for(int i = 0; i < x; i++) {\\n                for(int j = 0; j < y; j++) {\\n                    int idx = M * i + j;\\n                    parent[idx] = idx;\\n                }\\n            }\\n        }\\n        \\n        void make_union(pair<int,int> x, pair<int,int> y) {\\n            auto px = find(x);\\n            auto py = find(y);\\n            if(px == py) \\n                return;\\n            \\n            parent[py] = px;\\n            rank[px] += rank[py];\\n        }\\n        \\n        int find(pair<int,int> x) {\\n            int idx = M * x.first + x.second;\\n            while(parent[idx] != idx) {\\n                idx = parent[idx];\\n            }\\n            return idx;\\n        }\\n        \\n        int get_rank(pair<int,int> x) {\\n            int idx = M * x.first + x.second;\\n            return rank[idx];\\n        }\\n        int get_rank(int idx) {\\n            return rank[idx];\\n        }        \\n        \\n        vector<int> parent;\\n        vector<int> rank;\\n        int N;\\n        int M;\\n    };\\n    \\n    int N;\\n    int M;\\n    \\npublic:\\n    int largestIsland(vector<vector<int>>& grid) {\\n        N = grid.size();\\n        M = grid[0].size();\\n        \\n        UnionFind uf(grid.size(), grid[0].size());\\n        \\n        for(int j = 1; j < M; j++) {\\n            if(grid[0][j-1] >0 && grid[0][j] > 0 ) {\\n                uf.make_union( {0, j-1}, {0, j});\\n            }\\n        }\\n        \\n        for(int i = 1; i < N; i++) {\\n            for(int j = 0; j < M; j++) {\\n                if(grid[i-1][j] >0 && grid[i][j] > 0 ) {\\n                    uf.make_union( {i-1, j}, {i, j});\\n                }                \\n                if(j > 0 && grid[i][j-1] >0 && grid[i][j] > 0 ) {\\n                    uf.make_union( {i, j-1}, {i, j});\\n                }\\n            }\\n        }\\n        \\n        \\n        int maxIsland = 0;\\n        int delta[] = {0,1,0,-1,0};\\n        int zeroFound = false;\\n        \\n        for(int i = 0; i < N; i++) {\\n            for(int j = 0; j < M; j++) {\\n                \\n                if(grid[i][j] > 0)\\n                    continue;\\n                \\n                zeroFound = true;\\n                                \\n                map<int, int> newIsland;\\n                for(int d = 0; d < 4; d++) {\\n                    int i1 = i + delta[d];\\n                    int j1 = j + delta[d+1];\\n                    \\n                    if(i1 >=0 && j1 >= 0 && i1< N && j1 < M && grid[i1][j1] > 0) {\\n                        auto p = uf.find({i1,j1});\\n                        newIsland[p] = uf.get_rank(p);\\n                    }\\n                }\\n\\n                int newSize = 1;\\n                for(auto& a : newIsland) {\\n                    newSize += a.second;\\n                }\\n                maxIsland = max(maxIsland, newSize);\\n            }\\n        }\\n                                \\n        return zeroFound ? maxIsland : N*M;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1018830,
                "title": "python3-union-find",
                "content": "```python\\nclass Solution:\\n    def largestIsland(self, grid: List[List[int]]) -> int:\\n        N = len(grid)\\n        \\n        self.tree = {}\\n        self.area = collections.defaultdict(int)\\n        zero_cells = set()\\n        \\n        for i in range(N):\\n            for j in range(N):\\n                if grid[i][j] == 1:\\n                    self.setRoot(i, j)\\n                    for dx, dy in ((-1, 0), (0, -1), (1, 0), (0, 1)):\\n                        nx, ny = i + dx, j + dy\\n                        if 0 <= nx < N and 0 <= ny < N and (nx, ny) in self.tree: \\n                            self.union((i, j), (nx, ny))                                             \\n                else:\\n                    zero_cells.add((i,j))\\n                    \\n        for key in self.tree:\\n            root = self.findRoot(key)\\n            self.area[root] += 1\\n        \\n        res = max(self.area.values()) if self.area.values() else 0\\n        for i, j in zero_cells:\\n            nei = set()\\n            for dx, dy in ((-1, 0), (1, 0), (0, -1), (0, 1)):\\n                nx, ny = i + dx, j + dy\\n                if 0 <= nx < N and 0 <= ny < N and grid[nx][ny] == 1:   \\n                    nei.add(self.findRoot((nx, ny)))\\n            res = max(res, 1 + sum(self.area[x] for x in nei))\\n        return res       \\n    \\n    def union(self, a, b):\\n        roota = self.findRoot(a)\\n        rootb = self.findRoot(b)\\n        \\n        if roota != rootb:\\n            self.tree[roota] = rootb\\n        \\n    def setRoot(self, x, y):\\n        if (x, y) not in self.tree:\\n            self.tree[(x,y)] = (x,y)\\n            \\n    def findRoot(self, a):\\n        if a != self.tree[a]:\\n            self.tree[a] = self.findRoot(self.tree[a])\\n        return self.tree[a]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def largestIsland(self, grid: List[List[int]]) -> int:\\n        N = len(grid)\\n        \\n        self.tree = {}\\n        self.area = collections.defaultdict(int)\\n        zero_cells = set()\\n        \\n        for i in range(N):\\n            for j in range(N):\\n                if grid[i][j] == 1:\\n                    self.setRoot(i, j)\\n                    for dx, dy in ((-1, 0), (0, -1), (1, 0), (0, 1)):\\n                        nx, ny = i + dx, j + dy\\n                        if 0 <= nx < N and 0 <= ny < N and (nx, ny) in self.tree: \\n                            self.union((i, j), (nx, ny))                                             \\n                else:\\n                    zero_cells.add((i,j))\\n                    \\n        for key in self.tree:\\n            root = self.findRoot(key)\\n            self.area[root] += 1\\n        \\n        res = max(self.area.values()) if self.area.values() else 0\\n        for i, j in zero_cells:\\n            nei = set()\\n            for dx, dy in ((-1, 0), (1, 0), (0, -1), (0, 1)):\\n                nx, ny = i + dx, j + dy\\n                if 0 <= nx < N and 0 <= ny < N and grid[nx][ny] == 1:   \\n                    nei.add(self.findRoot((nx, ny)))\\n            res = max(res, 1 + sum(self.area[x] for x in nei))\\n        return res       \\n    \\n    def union(self, a, b):\\n        roota = self.findRoot(a)\\n        rootb = self.findRoot(b)\\n        \\n        if roota != rootb:\\n            self.tree[roota] = rootb\\n        \\n    def setRoot(self, x, y):\\n        if (x, y) not in self.tree:\\n            self.tree[(x,y)] = (x,y)\\n            \\n    def findRoot(self, a):\\n        if a != self.tree[a]:\\n            self.tree[a] = self.findRoot(self.tree[a])\\n        return self.tree[a]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1014965,
                "title": "problem-breakdown-code-in-dsu",
                "content": "```\\n    /**\\n        Do union of all the nodes with \\'1\\' across 4D\\n        Now, all of them are grouped under a parent.\\n        Each parent will hold it\\'s group size. \\n        (All of the above are basics of DSU)\\n        \\n        For each \\'0\\' in the grid\\n            check for it\\'s 4D neighbours\\n                if neighbour is 1\\n                    update local size with the size of parent of the neighbour\\n                    \\n    **/\\n```\\n[Source](https://leetcode.com/problems/making-a-large-island/discuss/127980/Java-Solution-using-Union-Find)\\n```\\nfun largestIsland(grid: Array<IntArray>): Int {\\n        if (grid.isEmpty()) return 0\\n        val R = grid.size\\n        val C = grid[0].size\\n        val dsu = DSU(R * C)\\n        val dirs = listOf(0 to 1, 0 to -1, 1 to 0, -1 to 0)\\n        var maxArea = 0\\n        \\n        fun encode(r: Int, c: Int) = r * C + c\\n        \\n        fun isLegal(x: Int, y: Int) = x in 0 until R && y in 0 until C\\n        \\n        for (i in 0 until R) {\\n            for (j in 0 until C) {\\n                if (grid[i][j] == 1) {\\n                    val currentCell = encode(i, j)\\n                    for ((deltaI, deltaJ) in dirs) {\\n                        val (newX, newY) = i + deltaI to j + deltaJ\\n                        if (isLegal(newX, newY).not()) continue\\n                        if (grid[newX][newY] != 1) continue\\n                        val newCell = encode(newX, newY)\\n                        dsu.union(currentCell, newCell)\\n                    }\\n                }\\n            }\\n        }\\n        \\n        maxArea = dsu.maxSize\\n        \\n        for (i in 0 until R) {\\n            for (j in 0 until C) {\\n                if (grid[i][j] == 0) {\\n                    val seen: MutableSet<Int> = HashSet()\\n                    val currentCell = encode(i, j)\\n                    var currentAns = 1\\n                    for ((deltaI, deltaJ) in dirs) {\\n                        val (newX, newY) = i + deltaI to j + deltaJ\\n                        if (isLegal(newX, newY).not()) continue\\n                        if (grid[newX][newY] != 1) continue\\n                        val newCell = encode(newX, newY)\\n                        val newCellParent = dsu.find(newCell)\\n                        if (seen.contains(newCellParent).not()) {\\n                            currentAns += dsu.size[newCellParent]\\n                            seen.add(newCellParent)\\n                        }\\n                    }\\n                    maxArea = maxOf(maxArea, currentAns)\\n                }\\n            }\\n        }\\n        return maxArea\\n    }\\n```\\n\\n```\\nclass DSU(val N: Int) {\\n    val parent = IntArray(N)\\n    val size = IntArray(N)\\n    var maxSize = 1\\n    \\n    init {\\n        makeSet()\\n    }\\n    \\n    private fun makeSet() {\\n        for (i in 0 until N) {\\n            parent[i] = i\\n            size[i] = 1\\n        }\\n    }\\n    \\n    fun find(x: Int): Int {\\n        if (parent[x] != x) {\\n            parent[x] = find(parent[x])\\n        }\\n        return parent[x]\\n    }\\n    \\n    fun union(x: Int, y: Int): Boolean {\\n        val (xP, yP) = find(x) to find(y)\\n        if (xP == yP) return false\\n        if (size[xP] > size[yP]) {\\n            size[xP] += size[yP]\\n            parent[yP] = xP\\n            maxSize = maxOf(maxSize, size[xP])\\n        } else {\\n            size[yP] += size[xP]\\n            parent[xP] = yP\\n            maxSize = maxOf(maxSize, size[yP])\\n        }\\n        return true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n    /**\\n        Do union of all the nodes with \\'1\\' across 4D\\n        Now, all of them are grouped under a parent.\\n        Each parent will hold it\\'s group size. \\n        (All of the above are basics of DSU)\\n        \\n        For each \\'0\\' in the grid\\n            check for it\\'s 4D neighbours\\n                if neighbour is 1\\n                    update local size with the size of parent of the neighbour\\n                    \\n    **/\\n```\n```\\nfun largestIsland(grid: Array<IntArray>): Int {\\n        if (grid.isEmpty()) return 0\\n        val R = grid.size\\n        val C = grid[0].size\\n        val dsu = DSU(R * C)\\n        val dirs = listOf(0 to 1, 0 to -1, 1 to 0, -1 to 0)\\n        var maxArea = 0\\n        \\n        fun encode(r: Int, c: Int) = r * C + c\\n        \\n        fun isLegal(x: Int, y: Int) = x in 0 until R && y in 0 until C\\n        \\n        for (i in 0 until R) {\\n            for (j in 0 until C) {\\n                if (grid[i][j] == 1) {\\n                    val currentCell = encode(i, j)\\n                    for ((deltaI, deltaJ) in dirs) {\\n                        val (newX, newY) = i + deltaI to j + deltaJ\\n                        if (isLegal(newX, newY).not()) continue\\n                        if (grid[newX][newY] != 1) continue\\n                        val newCell = encode(newX, newY)\\n                        dsu.union(currentCell, newCell)\\n                    }\\n                }\\n            }\\n        }\\n        \\n        maxArea = dsu.maxSize\\n        \\n        for (i in 0 until R) {\\n            for (j in 0 until C) {\\n                if (grid[i][j] == 0) {\\n                    val seen: MutableSet<Int> = HashSet()\\n                    val currentCell = encode(i, j)\\n                    var currentAns = 1\\n                    for ((deltaI, deltaJ) in dirs) {\\n                        val (newX, newY) = i + deltaI to j + deltaJ\\n                        if (isLegal(newX, newY).not()) continue\\n                        if (grid[newX][newY] != 1) continue\\n                        val newCell = encode(newX, newY)\\n                        val newCellParent = dsu.find(newCell)\\n                        if (seen.contains(newCellParent).not()) {\\n                            currentAns += dsu.size[newCellParent]\\n                            seen.add(newCellParent)\\n                        }\\n                    }\\n                    maxArea = maxOf(maxArea, currentAns)\\n                }\\n            }\\n        }\\n        return maxArea\\n    }\\n```\n```\\nclass DSU(val N: Int) {\\n    val parent = IntArray(N)\\n    val size = IntArray(N)\\n    var maxSize = 1\\n    \\n    init {\\n        makeSet()\\n    }\\n    \\n    private fun makeSet() {\\n        for (i in 0 until N) {\\n            parent[i] = i\\n            size[i] = 1\\n        }\\n    }\\n    \\n    fun find(x: Int): Int {\\n        if (parent[x] != x) {\\n            parent[x] = find(parent[x])\\n        }\\n        return parent[x]\\n    }\\n    \\n    fun union(x: Int, y: Int): Boolean {\\n        val (xP, yP) = find(x) to find(y)\\n        if (xP == yP) return false\\n        if (size[xP] > size[yP]) {\\n            size[xP] += size[yP]\\n            parent[yP] = xP\\n            maxSize = maxOf(maxSize, size[xP])\\n        } else {\\n            size[yP] += size[xP]\\n            parent[xP] = yP\\n            maxSize = maxOf(maxSize, size[yP])\\n        }\\n        return true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 970047,
                "title": "java-bfs-solutions",
                "content": "\\tclass Solution {\\n\\t\\tprivate int r, c; \\n\\t\\tprivate int color = 2;\\n\\t\\tprivate int maxArea = 0;\\n\\t\\tprivate int[][] directions = {{0,1},{0,-1},{1,0},{-1,0}}; //easy to traverse 4 directions\\n\\t\\tprivate Map<Integer, Integer> map = new HashMap<>(); //<color, area>;\\n\\t\\tpublic int largestIsland(int[][] grid) {\\n\\n\\t\\t\\tr = grid.length;\\n\\t\\t\\tc = grid[0].length;\\n\\t\\t\\t//corner case\\n\\t\\t\\tif(grid == null || r== 0 || c == 0) return 0;\\n\\n\\t\\t\\t//find each island area, to mark diffrent color \\n\\t\\t\\tfor(int i = 0; i< r; i++){\\n\\t\\t\\t\\tfor(int j = 0; j<c; j++){\\n\\t\\t\\t\\t\\tif(grid[i][j] == 1){\\n\\t\\t\\t\\t\\t\\tbfs(grid, i, j, color);\\n\\t\\t\\t\\t\\t\\tcolor++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int i = 0; i<r; i++){\\n\\t\\t\\t\\tfor(int j = 0; j < c; j++){\\n\\t\\t\\t\\t\\tif(grid[i][j] == 0){\\n\\t\\t\\t\\t\\t\\tSet<Integer> s = new HashSet<>();//record how many colors around 4 directions\\n\\t\\t\\t\\t\\t\\tint area = 1;\\n\\n\\t\\t\\t\\t\\t\\tfor(int []d: directions){\\n\\t\\t\\t\\t\\t\\t\\tint nx = i + d[0];\\n\\t\\t\\t\\t\\t\\t\\tint ny = j + d[1];\\n\\t\\t\\t\\t\\t\\t\\tif(nx >= 0 && nx < r && ny >= 0 && ny < c && !s.contains(grid[nx][ny]) && grid[nx][ny] != 0){\\n\\t\\t\\t\\t\\t\\t\\t\\ts.add(grid[nx][ny]);\\n\\t\\t\\t\\t\\t\\t\\t\\tarea += map.get(grid[nx][ny]);\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tmaxArea = Math.max(maxArea, area);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn maxArea;\\n\\n\\t\\t}\\n\\n\\t\\tprivate void bfs(int[][]grid, int x, int y, int color){\\n\\n\\t\\t\\tQueue<int[]> queue = new LinkedList<>();\\n\\t\\t\\tint area = 0;\\n\\t\\t\\tqueue.offer(new int[]{x, y});\\n\\t\\t\\tgrid[x][y] = color;\\n\\n\\t\\t\\twhile(!queue.isEmpty()){\\n\\n\\t\\t\\t\\tint[] start = queue.poll();\\n\\n\\t\\t\\t\\tfor(int[]d: directions){\\n\\n\\t\\t\\t\\t\\tint nx = start[0] + d[0];\\n\\t\\t\\t\\t\\tint ny = start[1] + d[1];\\n\\n\\t\\t\\t\\t\\tif(nx >= 0 && nx < r && ny >= 0 && ny < c && grid[nx][ny] == 1){\\n\\n\\t\\t\\t\\t\\t\\tqueue.offer(new int[]{nx, ny});\\n\\t\\t\\t\\t\\t\\tgrid[nx][ny] = color;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tarea++;\\n\\t\\t\\t\\tmap.put(color, area);\\n\\t\\t\\t\\tmaxArea = Math.max(maxArea, area);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tprivate int r, c; \\n\\t\\tprivate int color = 2;\\n\\t\\tprivate int maxArea = 0;\\n\\t\\tprivate int[][] directions = {{0,1}",
                "codeTag": "Java"
            },
            {
                "id": 754252,
                "title": "c-simple-dfs",
                "content": "Approach- Find connected components (connected 1\\'s) and mark them with numbers\\nthen for a grid[i][j]==0 just merge its neighbour(left,right,up,down) components and compare with maximum\\nreturn maximum\\n\\n```\\nmap<pair<int,int>,int> visited;\\nmap<int,int> size_;\\nint n,m;\\nint dfs(vector<vector<int>>& mat,int i,int j,int comp)\\n{\\n    // if at invalid position or at \\'0\\'\\n    if(i<0 || j<0 || i>=n || j>=m || mat[i][j]!=1) return 0;\\n    \\n    // mark current component\\n    mat[i][j]=comp;\\n    \\n    // expand to neighbours\\n    return 1+dfs(mat,i-1,j,comp)+dfs(mat,i+1,j,comp)+dfs(mat,i,j-1,comp)+dfs(mat,i,j+1,comp);\\n}\\n\\n// function to check if current mat[i][j] is non zero and is with the matrix\\nint valid(vector<vector<int>>& mat,int i,int j)\\n{\\n    if(i<0 || j<0 || i>=n || j>=m || mat[i][j]==0) return 0;\\n    return 1;\\n}\\n\\nclass Solution {\\npublic:\\n    int largestIsland(vector<vector<int>>& grid) \\n    {\\n        int comp=2;\\n        n=grid.size(),m=grid[0].size();\\n        // clear things\\n        visited.clear(); size_.clear();\\n        \\n        // max_ is our final answer\\n        int max_=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(!visited[{i,j}] && grid[i][j]==1)\\n                {\\n                    // this component of 1\\'s mark all of them as \\'comp\\'\\n                    int x=dfs(grid,i,j,comp);\\n                    \\n                    // store size of current component\\n                    size_[comp]=x;\\n                    \\n                    // comp++ for next marking\\n                    comp++;\\n                    \\n                    // we can update max_ beacuse here no \\'0\\' has changed to \\'1\\', and we can do that as given atmost one \\'0\\' can be changed\\n                    max_=max(max_,size_[comp-1]);\\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==0)\\n                {\\n                    // set this \\'0\\' as 1 and try to merge neighbouring components , put them in set so we dont consider a component twice\\n                    //e.g\\n                    // 11100\\n                    // 11022\\n                    // 00302\\n                    //for grid[1][2]=0 neighbour components are 1,2 and 3\\n                    set<int> s;\\n                    if(valid(grid,i-1,j)) s.insert(grid[i-1][j]);\\n                    if(valid(grid,i+1,j)) s.insert(grid[i+1][j]);\\n                    if(valid(grid,i,j+1)) s.insert(grid[i][j+1]);\\n                    if(valid(grid,i,j-1)) s.insert(grid[i][j-1]);\\n                \\n                int ans=0;\\n                // merge components\\n                for(auto a:s)  ans+=size_[a];\\n                    \\n                //update max_;\\n                max_=max(max_,ans+1);\\n                }\\n            }\\n        }\\n        return max_;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nmap<pair<int,int>,int> visited;\\nmap<int,int> size_;\\nint n,m;\\nint dfs(vector<vector<int>>& mat,int i,int j,int comp)\\n{\\n    // if at invalid position or at \\'0\\'\\n    if(i<0 || j<0 || i>=n || j>=m || mat[i][j]!=1) return 0;\\n    \\n    // mark current component\\n    mat[i][j]=comp;\\n    \\n    // expand to neighbours\\n    return 1+dfs(mat,i-1,j,comp)+dfs(mat,i+1,j,comp)+dfs(mat,i,j-1,comp)+dfs(mat,i,j+1,comp);\\n}\\n\\n// function to check if current mat[i][j] is non zero and is with the matrix\\nint valid(vector<vector<int>>& mat,int i,int j)\\n{\\n    if(i<0 || j<0 || i>=n || j>=m || mat[i][j]==0) return 0;\\n    return 1;\\n}\\n\\nclass Solution {\\npublic:\\n    int largestIsland(vector<vector<int>>& grid) \\n    {\\n        int comp=2;\\n        n=grid.size(),m=grid[0].size();\\n        // clear things\\n        visited.clear(); size_.clear();\\n        \\n        // max_ is our final answer\\n        int max_=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(!visited[{i,j}] && grid[i][j]==1)\\n                {\\n                    // this component of 1\\'s mark all of them as \\'comp\\'\\n                    int x=dfs(grid,i,j,comp);\\n                    \\n                    // store size of current component\\n                    size_[comp]=x;\\n                    \\n                    // comp++ for next marking\\n                    comp++;\\n                    \\n                    // we can update max_ beacuse here no \\'0\\' has changed to \\'1\\', and we can do that as given atmost one \\'0\\' can be changed\\n                    max_=max(max_,size_[comp-1]);\\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==0)\\n                {\\n                    // set this \\'0\\' as 1 and try to merge neighbouring components , put them in set so we dont consider a component twice\\n                    //e.g\\n                    // 11100\\n                    // 11022\\n                    // 00302\\n                    //for grid[1][2]=0 neighbour components are 1,2 and 3\\n                    set<int> s;\\n                    if(valid(grid,i-1,j)) s.insert(grid[i-1][j]);\\n                    if(valid(grid,i+1,j)) s.insert(grid[i+1][j]);\\n                    if(valid(grid,i,j+1)) s.insert(grid[i][j+1]);\\n                    if(valid(grid,i,j-1)) s.insert(grid[i][j-1]);\\n                \\n                int ans=0;\\n                // merge components\\n                for(auto a:s)  ans+=size_[a];\\n                    \\n                //update max_;\\n                max_=max(max_,ans+1);\\n                }\\n            }\\n        }\\n        return max_;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 292252,
                "title": "ruby-coloring-grid-in-dfs-48ms",
                "content": "Color the grid with current number of steps (start from 2 :))\\n\\n```Ruby\\n# @param {Integer[][]} grid\\n# @return {Integer}\\nDXY = [[1, 0], [-1, 0], [0, 1], [0, -1]]\\ndef largest_island(grid)\\n    n = grid.length\\n    steps = 2\\n    countby = {}\\n    ans = 0\\n    \\n    n.times do |i|\\n        n.times do |j|\\n            if grid[i][j] == 1\\n                count = dfs(grid, i, j, steps) \\n                countby[steps] = count\\n                ans = count if ans < count\\n            end\\n            steps += 1\\n        end\\n    end\\n    \\n    n.times do |i|\\n        n.times do |j|\\n            if grid[i][j] == 0\\n                seen = {}\\n                count = 1\\n                DXY.each do |dx, dy|\\n                    nx = i + dx\\n                    ny = j + dy\\n                    if 0 <= nx and 0 <= ny and nx < n and ny < n and (step = grid[nx][ny]) != 0\\n                       if !seen[step] \\n                           count += countby[step]\\n                           seen[step] = true\\n                       end\\n                    end\\n                end\\n                ans = count if ans < count\\n            end\\n        end\\n    end\\n    \\n    ans\\nend\\n\\ndef dfs(grid, x, y, val)\\n    grid[x][y] = val\\n    n = grid.length\\n    count = 1\\n    DXY.each do |dx, dy|\\n        nx = x + dx\\n        ny = y + dy\\n        if 0 <= nx and 0 <= ny and nx < n and ny < n and grid[nx][ny] == 1\\n            count += dfs(grid, nx, ny, val)\\n        end\\n    end\\n    count\\nend\\n```",
                "solutionTags": [],
                "code": "```Ruby\\n# @param {Integer[][]} grid\\n# @return {Integer}\\nDXY = [[1, 0], [-1, 0], [0, 1], [0, -1]]\\ndef largest_island(grid)\\n    n = grid.length\\n    steps = 2\\n    countby = {}\\n    ans = 0\\n    \\n    n.times do |i|\\n        n.times do |j|\\n            if grid[i][j] == 1\\n                count = dfs(grid, i, j, steps) \\n                countby[steps] = count\\n                ans = count if ans < count\\n            end\\n            steps += 1\\n        end\\n    end\\n    \\n    n.times do |i|\\n        n.times do |j|\\n            if grid[i][j] == 0\\n                seen = {}\\n                count = 1\\n                DXY.each do |dx, dy|\\n                    nx = i + dx\\n                    ny = j + dy\\n                    if 0 <= nx and 0 <= ny and nx < n and ny < n and (step = grid[nx][ny]) != 0\\n                       if !seen[step] \\n                           count += countby[step]\\n                           seen[step] = true\\n                       end\\n                    end\\n                end\\n                ans = count if ans < count\\n            end\\n        end\\n    end\\n    \\n    ans\\nend\\n\\ndef dfs(grid, x, y, val)\\n    grid[x][y] = val\\n    n = grid.length\\n    count = 1\\n    DXY.each do |dx, dy|\\n        nx = x + dx\\n        ny = y + dy\\n        if 0 <= nx and 0 <= ny and nx < n and ny < n and grid[nx][ny] == 1\\n            count += dfs(grid, nx, ny, val)\\n        end\\n    end\\n    count\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 148980,
                "title": "easy-java",
                "content": "1. Give each island different name and calculate the area of each island.\\n2. Try each point grid[i][j] == 0 to see which island this point connects to. \\n\\n```\\n    Set<String> set = new HashSet<>();\\n    int res = 0;\\n    public int largestIsland(int[][] grid) {\\n        Map<String,String> map = new HashMap<>();\\n        int m = grid.length, index = 0;\\n        boolean[][] visited = new boolean[m][m];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1 && !visited[i][j]) {\\n                    helper(grid,visited,i,j);\\n                    for (String s : set) map.put(s,res + \"+\" + index);\\n                    res = 0;\\n                    set.clear();\\n                    index++;\\n                } \\n            }\\n        }\\n        int max = 0;\\n        int[][] neibor = new int[][]{{-1,0},{1,0},{0,-1},{0,1}};\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 0) {\\n                    int tempvalue = 1;\\n                    set.clear();\\n                    for (int k = 0; k < 4; k++) {\\n                        int row = i + neibor[k][0];\\n                        int col = j + neibor[k][1];\\n                        if (row >=0 && row < m && col >= 0 && col < m && grid[row][col] == 1) {\\n                            String temp = row + \"+\" + col;\\n                            String value = map.get(temp);\\n                            String[] strs = value.split(\"\\\\\\\\+\");\\n                            if (set.add(strs[1])) tempvalue += Integer.parseInt(strs[0]); \\n                        }\\n                    }\\n                    max = Math.max(max,tempvalue);\\n                }\\n            }\\n        }\\n        return max == 0 ? m*m : max;\\n    }\\n    \\n    public void helper(int[][] grid, boolean[][] visited, int temprow, int tempcol) {\\n        visited[temprow][tempcol] = true;\\n        int m = grid.length;\\n        set.add(temprow + \"+\" + tempcol);\\n        res++;\\n        int[][] neibor = new int[][]{{-1,0},{1,0},{0,-1},{0,1}};\\n        for (int i = 0; i < 4; i++) {\\n            int row = temprow + neibor[i][0];\\n            int col = tempcol + neibor[i][1];\\n            if (row >=0 && row < m && col >= 0 && col < m && grid[row][col] == 1 && !visited[row][col]) helper(grid, visited, row, col);\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    Set<String> set = new HashSet<>();\\n    int res = 0;\\n    public int largestIsland(int[][] grid) {\\n        Map<String,String> map = new HashMap<>();\\n        int m = grid.length, index = 0;\\n        boolean[][] visited = new boolean[m][m];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1 && !visited[i][j]) {\\n                    helper(grid,visited,i,j);\\n                    for (String s : set) map.put(s,res + \"+\" + index);\\n                    res = 0;\\n                    set.clear();\\n                    index++;\\n                } \\n            }\\n        }\\n        int max = 0;\\n        int[][] neibor = new int[][]{{-1,0},{1,0},{0,-1},{0,1}};\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 0) {\\n                    int tempvalue = 1;\\n                    set.clear();\\n                    for (int k = 0; k < 4; k++) {\\n                        int row = i + neibor[k][0];\\n                        int col = j + neibor[k][1];\\n                        if (row >=0 && row < m && col >= 0 && col < m && grid[row][col] == 1) {\\n                            String temp = row + \"+\" + col;\\n                            String value = map.get(temp);\\n                            String[] strs = value.split(\"\\\\\\\\+\");\\n                            if (set.add(strs[1])) tempvalue += Integer.parseInt(strs[0]); \\n                        }\\n                    }\\n                    max = Math.max(max,tempvalue);\\n                }\\n            }\\n        }\\n        return max == 0 ? m*m : max;\\n    }\\n    \\n    public void helper(int[][] grid, boolean[][] visited, int temprow, int tempcol) {\\n        visited[temprow][tempcol] = true;\\n        int m = grid.length;\\n        set.add(temprow + \"+\" + tempcol);\\n        res++;\\n        int[][] neibor = new int[][]{{-1,0},{1,0},{0,-1},{0,1}};\\n        for (int i = 0; i < 4; i++) {\\n            int row = temprow + neibor[i][0];\\n            int col = tempcol + neibor[i][1];\\n            if (row >=0 && row < m && col >= 0 && col < m && grid[row][col] == 1 && !visited[row][col]) helper(grid, visited, row, col);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4054496,
                "title": "java-step-by-step-explained-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N^2)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/d7dde3a3-4783-446f-ab54-600273116048_1694931365.0964365.png)\\n\\n\\n# Code\\n```\\nclass DisjointSet {\\n    List<Integer> rank = new ArrayList<>();\\n    List<Integer> parent = new ArrayList<>();\\n    List<Integer> size = new ArrayList<>();\\n\\n    public DisjointSet(int n) {\\n        // Initialize disjoint set data structure with n nodes\\n        for (int i = 0; i <= n; i++) {\\n            rank.add(0);       // Initialize rank of each node to 0\\n            parent.add(i);     // Initialize parent of each node to itself\\n            size.add(1);       // Initialize size of each component to 1\\n        }\\n    }\\n\\n    public int findUPar(int node) {\\n        // Find the ultimate parent of a node\\n        if (node == parent.get(node)) {\\n            return node;    // Node is its own parent, return itself\\n        }\\n        int ulp = findUPar(parent.get(node)); // Recursively find the ultimate parent\\n        parent.set(node, ulp); // Path compression - set parent to the ultimate parent\\n        return parent.get(node);\\n    }\\n\\n    public void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return; // They are already in the same component\\n        if (size.get(ulp_u) < size.get(ulp_v)) {\\n            // Attach the smaller component (ulp_u) to the larger component (ulp_v)\\n            parent.set(ulp_u, ulp_v);\\n            size.set(ulp_v, size.get(ulp_v) + size.get(ulp_u)); // Update the size\\n        } else {\\n            // Attach the smaller component (ulp_v) to the larger component (ulp_u)\\n            parent.set(ulp_v, ulp_u);\\n            size.set(ulp_u, size.get(ulp_u) + size.get(ulp_v)); // Update the size\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    private boolean isValid(int adjr, int adjc, int n){\\n        return adjr >= 0 && adjr < n && adjc >= 0 && adjc < n;\\n    }\\n\\n    public int largestIsland(int[][] grid) {\\n\\n        int n = grid.length;\\n        DisjointSet ds = new DisjointSet(n * n);\\n\\n        // Build the disjoint set based on the grid\\n        for(int row = 0; row < n; row++){\\n            for(int col = 0; col < n; col++){\\n                if(grid[row][col] == 0) continue;\\n\\n                int dr[] = {-1, 0, 1, 0};\\n                int dc[] = {0, -1, 0, 1};\\n\\n                for(int ind = 0; ind < 4; ind++){\\n                    int newr = row + dr[ind];\\n                    int newc = col + dc[ind];\\n\\n                    if(isValid(newr, newc, n) && grid[newr][newc] == 1){\\n                        int nodeNo = row * n + col;\\n                        int adjNodeNo = newr * n + newc;\\n                        ds.unionBySize(nodeNo, adjNodeNo);\\n                    }\\n                }\\n            }\\n        }\\n        int mx = 0;\\n\\n        // Traverse the grid to find the largest island size\\n        for(int row = 0; row < n; row++){\\n            for(int col = 0; col < n; col++){\\n                if(grid[row][col] == 1) continue;\\n\\n                int dr[] = {-1, 0, 1, 0};\\n                int dc[] = {0, -1, 0, 1};\\n\\n                HashSet<Integer> components = new HashSet<>();\\n                for(int ind = 0; ind < 4; ind++){\\n                    int newr = row + dr[ind];\\n                    int newc = col + dc[ind];\\n\\n                    if(isValid(newr,newc,n) && grid[newr][newc] == 1){\\n                        if(grid[newr][newc] == 1){\\n                            components.add(ds.findUPar(newr * n + newc));\\n                        }\\n                    }\\n                }\\n                int sizeTotal = 0;\\n\\n                for(Integer parents: components){\\n                    sizeTotal += ds.size.get(parents);\\n                }\\n                mx = Math.max(mx, sizeTotal + 1); // Add 1 for the current cell\\n            }\\n        }\\n\\n        // Find the maximum component size in the disjoint set\\n        for(int cellNo = 0; cellNo < n; cellNo++){\\n            mx = Math.max(mx, ds.size.get(ds.findUPar(cellNo)));\\n        }\\n        return mx; // Return the largest island size\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Breadth-First Search",
                    "Union Find",
                    "Matrix"
                ],
                "code": "```\\nclass DisjointSet {\\n    List<Integer> rank = new ArrayList<>();\\n    List<Integer> parent = new ArrayList<>();\\n    List<Integer> size = new ArrayList<>();\\n\\n    public DisjointSet(int n) {\\n        // Initialize disjoint set data structure with n nodes\\n        for (int i = 0; i <= n; i++) {\\n            rank.add(0);       // Initialize rank of each node to 0\\n            parent.add(i);     // Initialize parent of each node to itself\\n            size.add(1);       // Initialize size of each component to 1\\n        }\\n    }\\n\\n    public int findUPar(int node) {\\n        // Find the ultimate parent of a node\\n        if (node == parent.get(node)) {\\n            return node;    // Node is its own parent, return itself\\n        }\\n        int ulp = findUPar(parent.get(node)); // Recursively find the ultimate parent\\n        parent.set(node, ulp); // Path compression - set parent to the ultimate parent\\n        return parent.get(node);\\n    }\\n\\n    public void unionBySize(int u, int v) {\\n        int ulp_u = findUPar(u);\\n        int ulp_v = findUPar(v);\\n        if (ulp_u == ulp_v) return; // They are already in the same component\\n        if (size.get(ulp_u) < size.get(ulp_v)) {\\n            // Attach the smaller component (ulp_u) to the larger component (ulp_v)\\n            parent.set(ulp_u, ulp_v);\\n            size.set(ulp_v, size.get(ulp_v) + size.get(ulp_u)); // Update the size\\n        } else {\\n            // Attach the smaller component (ulp_v) to the larger component (ulp_u)\\n            parent.set(ulp_v, ulp_u);\\n            size.set(ulp_u, size.get(ulp_u) + size.get(ulp_v)); // Update the size\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    private boolean isValid(int adjr, int adjc, int n){\\n        return adjr >= 0 && adjr < n && adjc >= 0 && adjc < n;\\n    }\\n\\n    public int largestIsland(int[][] grid) {\\n\\n        int n = grid.length;\\n        DisjointSet ds = new DisjointSet(n * n);\\n\\n        // Build the disjoint set based on the grid\\n        for(int row = 0; row < n; row++){\\n            for(int col = 0; col < n; col++){\\n                if(grid[row][col] == 0) continue;\\n\\n                int dr[] = {-1, 0, 1, 0};\\n                int dc[] = {0, -1, 0, 1};\\n\\n                for(int ind = 0; ind < 4; ind++){\\n                    int newr = row + dr[ind];\\n                    int newc = col + dc[ind];\\n\\n                    if(isValid(newr, newc, n) && grid[newr][newc] == 1){\\n                        int nodeNo = row * n + col;\\n                        int adjNodeNo = newr * n + newc;\\n                        ds.unionBySize(nodeNo, adjNodeNo);\\n                    }\\n                }\\n            }\\n        }\\n        int mx = 0;\\n\\n        // Traverse the grid to find the largest island size\\n        for(int row = 0; row < n; row++){\\n            for(int col = 0; col < n; col++){\\n                if(grid[row][col] == 1) continue;\\n\\n                int dr[] = {-1, 0, 1, 0};\\n                int dc[] = {0, -1, 0, 1};\\n\\n                HashSet<Integer> components = new HashSet<>();\\n                for(int ind = 0; ind < 4; ind++){\\n                    int newr = row + dr[ind];\\n                    int newc = col + dc[ind];\\n\\n                    if(isValid(newr,newc,n) && grid[newr][newc] == 1){\\n                        if(grid[newr][newc] == 1){\\n                            components.add(ds.findUPar(newr * n + newc));\\n                        }\\n                    }\\n                }\\n                int sizeTotal = 0;\\n\\n                for(Integer parents: components){\\n                    sizeTotal += ds.size.get(parents);\\n                }\\n                mx = Math.max(mx, sizeTotal + 1); // Add 1 for the current cell\\n            }\\n        }\\n\\n        // Find the maximum component size in the disjoint set\\n        for(int cellNo = 0; cellNo < n; cellNo++){\\n            mx = Math.max(mx, ds.size.get(ds.findUPar(cellNo)));\\n        }\\n        return mx; // Return the largest island size\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4000239,
                "title": "simple-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nexplore all islands and mark them by number like : 1, 2, ...\\ncount size of islands for ex freq[1] =3... so on.\\nif we don\\'t change any 0 to 1 ans will be the largest island\\n\\nnow try to convert all 0  to 1 one-by-one, and at any state onverting any 0 to 1 can connect two or more or less islands together.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dir[4][2] = {{1, 0}, {0, -1}, {-1, 0}, {0, 1}};\\n    void dfs(int i, int j, vector<vector<int> > &grid, vector<vector<bool> > &visited, int val){\\n        grid[i][j]=val;\\n        visited[i][j]=true;\\n        int n = grid.size();\\n        for(int k=0; k<4; k++){\\n            if(i+dir[k][0]>=0 && i+dir[k][0]<n && j+dir[k][1]>=0 && j+dir[k][1]<n && grid[i+dir[k][0]][j+dir[k][1]] && !visited[i+dir[k][0]][j+dir[k][1]]){\\n                dfs(i+dir[k][0], j+dir[k][1], grid, visited, val);\\n            }\\n        }\\n\\n    }\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int cnt = 0;\\n        int n = grid.size();\\n        vector<vector<bool> > visited(n, vector<bool>(n, false));\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j] && !visited[i][j]){\\n                    dfs(i, j, grid, visited, ++cnt);\\n                }\\n            }\\n        }\\n        vector<int> freq(cnt+1, 0);\\n        int ans = 0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                freq[grid[i][j]]++;\\n                if(grid[i][j])ans = max(ans, freq[grid[i][j]]);\\n            }\\n        }\\n\\n        for(int i=0 ; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                \\n                if(grid[i][j]==0){\\n                    set<int> st;\\n\\n                    for(int k=0; k<4; k++){\\n                        if(i+dir[k][0]>=0 && i+dir[k][0]<n && j+dir[k][1]>=0 && j+dir[k][1]<n){\\n                            if(grid[i+dir[k][0]][j+dir[k][1]]){\\n                                st.insert(grid[i+dir[k][0]][j+dir[k][1]]);\\n                            }\\n                        }\\n                    }\\n                    int curr = 1;\\n                    for (auto it = st.begin(); it != st.end(); it++)curr+=freq[*it];\\n                    ans = max(ans, curr);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dir[4][2] = {{1, 0}, {0, -1}, {-1, 0}, {0, 1}};\\n    void dfs(int i, int j, vector<vector<int> > &grid, vector<vector<bool> > &visited, int val){\\n        grid[i][j]=val;\\n        visited[i][j]=true;\\n        int n = grid.size();\\n        for(int k=0; k<4; k++){\\n            if(i+dir[k][0]>=0 && i+dir[k][0]<n && j+dir[k][1]>=0 && j+dir[k][1]<n && grid[i+dir[k][0]][j+dir[k][1]] && !visited[i+dir[k][0]][j+dir[k][1]]){\\n                dfs(i+dir[k][0], j+dir[k][1], grid, visited, val);\\n            }\\n        }\\n\\n    }\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int cnt = 0;\\n        int n = grid.size();\\n        vector<vector<bool> > visited(n, vector<bool>(n, false));\\n\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j] && !visited[i][j]){\\n                    dfs(i, j, grid, visited, ++cnt);\\n                }\\n            }\\n        }\\n        vector<int> freq(cnt+1, 0);\\n        int ans = 0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                freq[grid[i][j]]++;\\n                if(grid[i][j])ans = max(ans, freq[grid[i][j]]);\\n            }\\n        }\\n\\n        for(int i=0 ; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                \\n                if(grid[i][j]==0){\\n                    set<int> st;\\n\\n                    for(int k=0; k<4; k++){\\n                        if(i+dir[k][0]>=0 && i+dir[k][0]<n && j+dir[k][1]>=0 && j+dir[k][1]<n){\\n                            if(grid[i+dir[k][0]][j+dir[k][1]]){\\n                                st.insert(grid[i+dir[k][0]][j+dir[k][1]]);\\n                            }\\n                        }\\n                    }\\n                    int curr = 1;\\n                    for (auto it = st.begin(); it != st.end(); it++)curr+=freq[*it];\\n                    ans = max(ans, curr);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3787791,
                "title": "clean-java-solution-union-find-concise-solution-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    class DSU {\\n        int[] parent;\\n        int[] size;\\n\\n        public DSU(int size) {\\n            this.size = new int[size];\\n            parent = new int[size];\\n            for (int i = 0; i < size; i++) {\\n                parent[i] = i;\\n                this.size[i] = 1;\\n            }\\n        }\\n\\n        public int find(int x) {\\n            if (parent[x] != x)\\n                parent[x] = find(parent[x]);\\n            return parent[x];\\n        }\\n\\n        // Union By Size\\n\\n        public boolean union(int x, int y) {\\n            int xr = find(x), yr = find(y);\\n            if (xr == yr) {\\n                return false;\\n            } else if (size[xr] < size[yr]) {\\n                parent[xr] = yr;\\n                size[yr] += size[xr];\\n            }\\n           else {\\n                parent[yr] = xr;\\n                size[xr] += size[yr];\\n            }\\n            return true;\\n        }\\n    }\\n\\n    public int largestIsland(int[][] grid) {\\n        int n = grid.length;\\n        DSU dsu = new DSU(n*n);\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 0)\\n                    continue;\\n                int[][] drc = {{1,0}, {-1,0}, {0,1}, {0,-1}};\\n                for (int[] d : drc){\\n                    int r = d[0] + i, c = d[1] + j;\\n                    boolean rbound = 0 <= r && r < n;\\n                    boolean cbound = 0 <= c && c < n;\\n                    if (rbound && cbound && grid[r][c] == 1){\\n                        dsu.union(i*n + j, r*n + c);\\n                    }\\n                }\\n            }\\n        }\\n        int maxSize = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1){\\n                    maxSize = Math.max(maxSize, dsu.size[dsu.find(i*n + j)]);\\n                    continue;\\n                }\\n                int[][] drc = {{1,0}, {-1,0}, {0,1}, {0,-1}};\\n                HashSet<Integer> visited = new HashSet<>();\\n                int currSize = 0;\\n                for (int[] d : drc){\\n                    int r = d[0] + i, c = d[1] + j;\\n                    boolean rbound = 0 <= r && r < n;\\n                    boolean cbound = 0 <= c && c < n;\\n\\n                    if (rbound && cbound && grid[r][c] == 1 && !visited.contains(dsu.find(r*n + c))){\\n                        visited.add(dsu.find(r*n + c));\\n                        currSize += dsu.size[dsu.parent[r*n + c]];\\n                    }\\n                }\\n                maxSize = Math.max(maxSize, currSize + 1);\\n            }\\n        }\\n\\n        return maxSize;\\n    }    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Union Find",
                    "Graph",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    class DSU {\\n        int[] parent;\\n        int[] size;\\n\\n        public DSU(int size) {\\n            this.size = new int[size];\\n            parent = new int[size];\\n            for (int i = 0; i < size; i++) {\\n                parent[i] = i;\\n                this.size[i] = 1;\\n            }\\n        }\\n\\n        public int find(int x) {\\n            if (parent[x] != x)\\n                parent[x] = find(parent[x]);\\n            return parent[x];\\n        }\\n\\n        // Union By Size\\n\\n        public boolean union(int x, int y) {\\n            int xr = find(x), yr = find(y);\\n            if (xr == yr) {\\n                return false;\\n            } else if (size[xr] < size[yr]) {\\n                parent[xr] = yr;\\n                size[yr] += size[xr];\\n            }\\n           else {\\n                parent[yr] = xr;\\n                size[xr] += size[yr];\\n            }\\n            return true;\\n        }\\n    }\\n\\n    public int largestIsland(int[][] grid) {\\n        int n = grid.length;\\n        DSU dsu = new DSU(n*n);\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 0)\\n                    continue;\\n                int[][] drc = {{1,0}, {-1,0}, {0,1}, {0,-1}};\\n                for (int[] d : drc){\\n                    int r = d[0] + i, c = d[1] + j;\\n                    boolean rbound = 0 <= r && r < n;\\n                    boolean cbound = 0 <= c && c < n;\\n                    if (rbound && cbound && grid[r][c] == 1){\\n                        dsu.union(i*n + j, r*n + c);\\n                    }\\n                }\\n            }\\n        }\\n        int maxSize = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1){\\n                    maxSize = Math.max(maxSize, dsu.size[dsu.find(i*n + j)]);\\n                    continue;\\n                }\\n                int[][] drc = {{1,0}, {-1,0}, {0,1}, {0,-1}};\\n                HashSet<Integer> visited = new HashSet<>();\\n                int currSize = 0;\\n                for (int[] d : drc){\\n                    int r = d[0] + i, c = d[1] + j;\\n                    boolean rbound = 0 <= r && r < n;\\n                    boolean cbound = 0 <= c && c < n;\\n\\n                    if (rbound && cbound && grid[r][c] == 1 && !visited.contains(dsu.find(r*n + c))){\\n                        visited.add(dsu.find(r*n + c));\\n                        currSize += dsu.size[dsu.parent[r*n + c]];\\n                    }\\n                }\\n                maxSize = Math.max(maxSize, currSize + 1);\\n            }\\n        }\\n\\n        return maxSize;\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484872,
                "title": "solution",
                "content": "```C++ []\\nauto $$ = [] { return ios::sync_with_stdio(0), cin.tie(0), 0; }();\\nint uf[500 * 500];\\nint find_(int i) {\\n    return uf[i] < 0 ? i : uf[i] = find_(uf[i]);\\n}\\nvoid unite_(int i, int j) {\\n    i = find_(i), j = find_(j);\\n    if (i == j) return;\\n    if (-uf[i] > -uf[j]) swap(i, j);\\n    uf[j] += uf[i], uf[i] = j;\\n}\\nconst int dirs[][2] = {0, 1, 1, 0, 0, -1, -1, 0};\\nvector<int> ex(4);\\n\\nclass Solution {\\npublic:\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        memset(uf, -1, sizeof(uf[0]) * n * n);\\n        for (int y = 0; y < n; y++) {\\n            for (int x = 0; x < n; x++) {\\n                if (!grid[y][x]) continue;\\n                for (int i : {0, 1}) {\\n                    int ay = y + dirs[i][0], ax = x + dirs[i][1];\\n                    if (ay == n || ax == n) continue;\\n                    if (grid[ay][ax]) unite_(y * n + x, ay * n + ax);\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for (int y = 0; y < n; y++) {\\n            for (int x = 0; x < n; x++) {\\n                if (grid[y][x]) {\\n                    ans = max(ans, -uf[find_(y * n + x)]);\\n                    continue;\\n                }\\n                int c = 0;\\n                ex.clear();\\n                for (auto [dy, dx] : dirs) {\\n                    int ay = y + dy, ax = x + dx;\\n                    if (!~ay || !~ax || ay == n || ax == n) continue;\\n                    if (!grid[ay][ax]) continue;\\n                    int i = find_(ay * n + ax);\\n                    if (find(ex.begin(), ex.end(), i) == ex.end())\\n                        ex.push_back(i);\\n                }\\n                for (int i : ex)\\n                    c += -uf[i];\\n                ans = max(ans, c + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def largestIsland(self, grid: List[List[int]]) -> int:\\n        rows = len(grid)\\n        area = 0\\n        def dfs(r,c,idx):\\n            grid[r][c] = idx\\n            nonlocal area\\n            area += 1\\n            for dr, dc in [[-1,0],[1,0],[0,-1],[0,1]]:\\n                nr, nc = r + dr, c + dc\\n                if nr >= 0 and nr < rows and nc < rows and nc >= 0 and grid[nr][nc] == 1:\\n                    dfs(nr,nc,idx)\\n        \\n        label = 2\\n        hashmap = {}\\n\\n        for r in range(rows):\\n            for c in range(rows):\\n                if grid[r][c] == 1:\\n                    area = 0\\n                    dfs(r,c,label)\\n                    hashmap[label] = area\\n                    label += 1\\n        \\n        if len(hashmap) == 0: return 1\\n        _max = max(hashmap.values())\\n\\n        for r in range(rows):\\n            for c in range(rows):\\n                if grid[r][c] == 0:\\n                    res = 1\\n                    visit = set()\\n                    for dr, dc in [[-1,0],[1,0],[0,-1],[0,1]]:\\n                        nr, nc = r + dr, c + dc\\n                        if nr >= 0 and nr < rows and nc < rows and nc >= 0 and grid[nr][nc] != 0 and grid[nr][nc] not in visit:\\n                            res += hashmap[grid[nr][nc]]\\n                            visit.add(grid[nr][nc])\\n                    _max = max(_max, res)\\n        \\n        return _max\\n```\\n\\n```Java []\\nclass Solution {\\n    public int largestIsland(int[][] grid) {\\n        int[] componentSizes = new int[grid.length * grid.length + 2];\\n        int max = 0;\\n        int id = 2;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid.length; j++) {\\n                if (grid[i][j] == 1) {\\n                    int[] size = new int[1];\\n                    dfs(grid, componentSizes, id, i, j);\\n                    if(componentSizes[id] > max){\\n                        max = componentSizes[id];\\n                    }\\n                    id++;\\n                }\\n            }\\n        }\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid.length; j++) {\\n                if (grid[i][j] == 0) {\\n                    max = Math.max(max, getNeighborSum(grid, componentSizes, i, j) + 1);\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n    private void dfs(int[][] grid, int[] componentSizes, int id, int i, int j) {\\n        if (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] != 1) return;\\n        grid[i][j] = id;\\n        componentSizes[id]++;\\n        dfs(grid, componentSizes, id, i-1, j);\\n        dfs(grid, componentSizes, id, i, j-1);\\n        dfs(grid, componentSizes, id, i+1, j);\\n        dfs(grid, componentSizes, id, i, j+1);\\n    }\\n    private int getNeighborSum(int[][] grid, int[] componentSizes, int i, int j) {\\n        int[] ids = new int[4];\\n        int sum = 0;\\n        if(i-1 >= 0){\\n            ids[0] = grid[i-1][j];\\n        }\\n        if(i+1 < grid.length){\\n            ids[1] = grid[i+1][j];\\n        }\\n        if(j-1 >= 0){\\n            ids[2] = grid[i][j-1];\\n        }\\n        if(j+1 < grid.length){\\n            ids[3] = grid[i][j+1];\\n        }\\n        sum = componentSizes[ids[0]];\\n        if(ids[1] != ids[0]){\\n            sum += componentSizes[ids[1]];\\n        }\\n        if(ids[2] != ids[0] && ids[2] != ids[1]){\\n            sum += componentSizes[ids[2]];\\n        }\\n        if(ids[3] != ids[0] && ids[3] != ids[1] && ids[3] != ids[2]){\\n            sum += componentSizes[ids[3]];\\n        }\\n        return sum;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nauto $$ = [] { return ios::sync_with_stdio(0), cin.tie(0), 0; }();\\nint uf[500 * 500];\\nint find_(int i) {\\n    return uf[i] < 0 ? i : uf[i] = find_(uf[i]);\\n}\\nvoid unite_(int i, int j) {\\n    i = find_(i), j = find_(j);\\n    if (i == j) return;\\n    if (-uf[i] > -uf[j]) swap(i, j);\\n    uf[j] += uf[i], uf[i] = j;\\n}\\nconst int dirs[][2] = {0, 1, 1, 0, 0, -1, -1, 0};\\nvector<int> ex(4);\\n\\nclass Solution {\\npublic:\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        memset(uf, -1, sizeof(uf[0]) * n * n);\\n        for (int y = 0; y < n; y++) {\\n            for (int x = 0; x < n; x++) {\\n                if (!grid[y][x]) continue;\\n                for (int i : {0, 1}) {\\n                    int ay = y + dirs[i][0], ax = x + dirs[i][1];\\n                    if (ay == n || ax == n) continue;\\n                    if (grid[ay][ax]) unite_(y * n + x, ay * n + ax);\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for (int y = 0; y < n; y++) {\\n            for (int x = 0; x < n; x++) {\\n                if (grid[y][x]) {\\n                    ans = max(ans, -uf[find_(y * n + x)]);\\n                    continue;\\n                }\\n                int c = 0;\\n                ex.clear();\\n                for (auto [dy, dx] : dirs) {\\n                    int ay = y + dy, ax = x + dx;\\n                    if (!~ay || !~ax || ay == n || ax == n) continue;\\n                    if (!grid[ay][ax]) continue;\\n                    int i = find_(ay * n + ax);\\n                    if (find(ex.begin(), ex.end(), i) == ex.end())\\n                        ex.push_back(i);\\n                }\\n                for (int i : ex)\\n                    c += -uf[i];\\n                ans = max(ans, c + 1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def largestIsland(self, grid: List[List[int]]) -> int:\\n        rows = len(grid)\\n        area = 0\\n        def dfs(r,c,idx):\\n            grid[r][c] = idx\\n            nonlocal area\\n            area += 1\\n            for dr, dc in [[-1,0],[1,0],[0,-1],[0,1]]:\\n                nr, nc = r + dr, c + dc\\n                if nr >= 0 and nr < rows and nc < rows and nc >= 0 and grid[nr][nc] == 1:\\n                    dfs(nr,nc,idx)\\n        \\n        label = 2\\n        hashmap = {}\\n\\n        for r in range(rows):\\n            for c in range(rows):\\n                if grid[r][c] == 1:\\n                    area = 0\\n                    dfs(r,c,label)\\n                    hashmap[label] = area\\n                    label += 1\\n        \\n        if len(hashmap) == 0: return 1\\n        _max = max(hashmap.values())\\n\\n        for r in range(rows):\\n            for c in range(rows):\\n                if grid[r][c] == 0:\\n                    res = 1\\n                    visit = set()\\n                    for dr, dc in [[-1,0],[1,0],[0,-1],[0,1]]:\\n                        nr, nc = r + dr, c + dc\\n                        if nr >= 0 and nr < rows and nc < rows and nc >= 0 and grid[nr][nc] != 0 and grid[nr][nc] not in visit:\\n                            res += hashmap[grid[nr][nc]]\\n                            visit.add(grid[nr][nc])\\n                    _max = max(_max, res)\\n        \\n        return _max\\n```\n```Java []\\nclass Solution {\\n    public int largestIsland(int[][] grid) {\\n        int[] componentSizes = new int[grid.length * grid.length + 2];\\n        int max = 0;\\n        int id = 2;\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid.length; j++) {\\n                if (grid[i][j] == 1) {\\n                    int[] size = new int[1];\\n                    dfs(grid, componentSizes, id, i, j);\\n                    if(componentSizes[id] > max){\\n                        max = componentSizes[id];\\n                    }\\n                    id++;\\n                }\\n            }\\n        }\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid.length; j++) {\\n                if (grid[i][j] == 0) {\\n                    max = Math.max(max, getNeighborSum(grid, componentSizes, i, j) + 1);\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n    private void dfs(int[][] grid, int[] componentSizes, int id, int i, int j) {\\n        if (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] != 1) return;\\n        grid[i][j] = id;\\n        componentSizes[id]++;\\n        dfs(grid, componentSizes, id, i-1, j);\\n        dfs(grid, componentSizes, id, i, j-1);\\n        dfs(grid, componentSizes, id, i+1, j);\\n        dfs(grid, componentSizes, id, i, j+1);\\n    }\\n    private int getNeighborSum(int[][] grid, int[] componentSizes, int i, int j) {\\n        int[] ids = new int[4];\\n        int sum = 0;\\n        if(i-1 >= 0){\\n            ids[0] = grid[i-1][j];\\n        }\\n        if(i+1 < grid.length){\\n            ids[1] = grid[i+1][j];\\n        }\\n        if(j-1 >= 0){\\n            ids[2] = grid[i][j-1];\\n        }\\n        if(j+1 < grid.length){\\n            ids[3] = grid[i][j+1];\\n        }\\n        sum = componentSizes[ids[0]];\\n        if(ids[1] != ids[0]){\\n            sum += componentSizes[ids[1]];\\n        }\\n        if(ids[2] != ids[0] && ids[2] != ids[1]){\\n            sum += componentSizes[ids[2]];\\n        }\\n        if(ids[3] != ids[0] && ids[3] != ids[1] && ids[3] != ids[2]){\\n            sum += componentSizes[ids[3]];\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3388923,
                "title": "one-go-solution-using-disjoint-set-intuitive-method-java",
                "content": "```\\nclass Solution {\\n    public int largestIsland(int[][] grid) {\\n        int n =grid.length;\\n        DisJointSet ds = new DisJointSet(n * n); \\n        int[] x= {0, 1, 0, -1}, y={1, 0, -1, 0};\\n        \\n        for(int i=0; i<n; i++){ // Connecting components for maxG cal!\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j] == 0) continue;\\n                 for(int k=0; k<4; k++){\\n                      int nr = i + x[k], nc = j + y[k];\\n                      if(isValid(nr, nc, n) && grid[nr][nc] == 1){\\n                          int cellR = (i * n) + j, cellC = (nr * n) + nc;\\n                          ds.unionBySize(cellR, cellC);\\n                      }\\n                  }\\n              }\\n          }\\n\\n        int maxGroup =0;\\n        for(int i=0; i<n; i++){ // Conversion ~ 0 -> 1!\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j] == 1) continue;\\n                Set<Integer> set = new HashSet<>();\\n                for(int k=0; k<4; k++){\\n                      int nr = i + x[k], nc = j + y[k];\\n                      if(isValid(nr, nc, n) && grid[nr][nc] == 1){\\n                          int cellC = (nr * n) + nc;\\n                          set.add(ds.findUParent(cellC));\\n                      }\\n                  }\\n                  int temSize =0;\\n                  for(int f: set) temSize += ds.size[f];\\n                  maxGroup = Math.max(maxGroup, temSize + 1);\\n              }\\n          }\\n        // Getting Ultimate parent!\\n        for(int i=0; i<n*n; i++) maxGroup = Math.max(maxGroup, ds.size[ds.findUParent(i)]);\\n        return maxGroup;\\n    }\\n    \\n    private boolean isValid(int i,int j,int n) {\\n        return (i>=0 && i<n && j>=0 && j<n); // It Lies inside the grid!\\n    }\\n    \\n\\t// DisjointSet Data Structure Follow-up Template!\\n    static class DisJointSet {\\n        protected int[] parent;\\n        protected int[] rank;\\n        protected int[] size;\\n        protected int length;\\n\\n        DisJointSet(int n) {\\n            this.parent = new int[n + 1];\\n            this.rank = new int[n + 1];\\n            this.size = new int[n + 1];\\n            this.length = n + 1;\\n            for(int i=0; i<=n; i++){\\n                parent[i] = i;\\n                size[i] = 1;\\n            }\\n        }\\n\\n        public int findUParent(int node) {\\n            if(node == parent[node]) return node;\\n            return parent[node] = findUParent(parent[node]); // path compression\\n        }\\n\\n        public void unionByRank(int u, int v) {\\n            int ultimateU = findUParent(u);\\n            int ultimateV = findUParent(v);\\n            if(ultimateV == ultimateU) return; //is both are same compenent\\n            if(rank[ultimateU] < rank[ultimateV])\\n                parent[ultimateU] = ultimateV;\\n            else if(rank[ultimateV] < rank[ultimateU])\\n                parent[ultimateV] = ultimateU;\\n            else{\\n                parent[ultimateU] = ultimateV;\\n                rank[ultimateV]++;\\n            }\\n        }\\n\\n        public void unionBySize(int u, int v) {\\n            int ultimateU = findUParent(u);\\n            int ultimateV = findUParent(v);\\n            if(ultimateV == ultimateU) return;\\n            if(size[ultimateU] < size[ultimateV]){\\n                parent[ultimateU] = ultimateV;\\n                size[ultimateV] += size[ultimateU];\\n            }else{\\n                parent[ultimateV] = ultimateU;\\n                size[ultimateU] += size[ultimateV];\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int largestIsland(int[][] grid) {\\n        int n =grid.length;\\n        DisJointSet ds = new DisJointSet(n * n); \\n        int[] x= {0, 1, 0, -1}, y={1, 0, -1, 0};\\n        \\n        for(int i=0; i<n; i++){ // Connecting components for maxG cal!\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j] == 0) continue;\\n                 for(int k=0; k<4; k++){\\n                      int nr = i + x[k], nc = j + y[k];\\n                      if(isValid(nr, nc, n) && grid[nr][nc] == 1){\\n                          int cellR = (i * n) + j, cellC = (nr * n) + nc;\\n                          ds.unionBySize(cellR, cellC);\\n                      }\\n                  }\\n              }\\n          }\\n\\n        int maxGroup =0;\\n        for(int i=0; i<n; i++){ // Conversion ~ 0 -> 1!\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j] == 1) continue;\\n                Set<Integer> set = new HashSet<>();\\n                for(int k=0; k<4; k++){\\n                      int nr = i + x[k], nc = j + y[k];\\n                      if(isValid(nr, nc, n) && grid[nr][nc] == 1){\\n                          int cellC = (nr * n) + nc;\\n                          set.add(ds.findUParent(cellC));\\n                      }\\n                  }\\n                  int temSize =0;\\n                  for(int f: set) temSize += ds.size[f];\\n                  maxGroup = Math.max(maxGroup, temSize + 1);\\n              }\\n          }\\n        // Getting Ultimate parent!\\n        for(int i=0; i<n*n; i++) maxGroup = Math.max(maxGroup, ds.size[ds.findUParent(i)]);\\n        return maxGroup;\\n    }\\n    \\n    private boolean isValid(int i,int j,int n) {\\n        return (i>=0 && i<n && j>=0 && j<n); // It Lies inside the grid!\\n    }\\n    \\n\\t// DisjointSet Data Structure Follow-up Template!\\n    static class DisJointSet {\\n        protected int[] parent;\\n        protected int[] rank;\\n        protected int[] size;\\n        protected int length;\\n\\n        DisJointSet(int n) {\\n            this.parent = new int[n + 1];\\n            this.rank = new int[n + 1];\\n            this.size = new int[n + 1];\\n            this.length = n + 1;\\n            for(int i=0; i<=n; i++){\\n                parent[i] = i;\\n                size[i] = 1;\\n            }\\n        }\\n\\n        public int findUParent(int node) {\\n            if(node == parent[node]) return node;\\n            return parent[node] = findUParent(parent[node]); // path compression\\n        }\\n\\n        public void unionByRank(int u, int v) {\\n            int ultimateU = findUParent(u);\\n            int ultimateV = findUParent(v);\\n            if(ultimateV == ultimateU) return; //is both are same compenent\\n            if(rank[ultimateU] < rank[ultimateV])\\n                parent[ultimateU] = ultimateV;\\n            else if(rank[ultimateV] < rank[ultimateU])\\n                parent[ultimateV] = ultimateU;\\n            else{\\n                parent[ultimateU] = ultimateV;\\n                rank[ultimateV]++;\\n            }\\n        }\\n\\n        public void unionBySize(int u, int v) {\\n            int ultimateU = findUParent(u);\\n            int ultimateV = findUParent(v);\\n            if(ultimateV == ultimateU) return;\\n            if(size[ultimateU] < size[ultimateV]){\\n                parent[ultimateU] = ultimateV;\\n                size[ultimateV] += size[ultimateU];\\n            }else{\\n                parent[ultimateV] = ultimateU;\\n                size[ultimateU] += size[ultimateV];\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3388362,
                "title": "c-o-n-time-and-o-1-space-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n\\xB2)$$ \\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\npublic class Solution \\n{\\n    public int LargestIsland(int[][] grid)\\n    {\\n        var islands = new Dictionary<int, int> {{0, 0}};\\n        var totalIslandsVolume = 0;\\n        for (int i = 0; i < grid.Length; i++)\\n        {\\n            for (int j = 0; j < grid[i].Length; j++)\\n            {\\n                if (grid[i][j] == 0 || grid[i][j] > 1) continue;\\n                int colorId = islands.Count + 1;\\n                int islandVolume = FloodFillIsland(grid, i, j, colorId);\\n                totalIslandsVolume += islandVolume;\\n                islands.Add(colorId, islandVolume);\\n            }\\n        }\\n\\n        if (totalIslandsVolume == grid.Length * grid[0].Length) \\n            return totalIslandsVolume;\\n        \\n        int max = 1;\\n        var uniqueIds = new HashSet<int>();\\n        for (int i = 0; i < grid.Length; i++)\\n        {\\n            for (int j = 0; j < grid[i].Length; j++)\\n            {\\n                if(grid[i][j] != 0) continue;\\n                \\n                uniqueIds.Add(GetIslandId(grid, i + 1, j));\\n                uniqueIds.Add(GetIslandId(grid, i - 1, j));\\n                uniqueIds.Add(GetIslandId(grid, i, j + 1));\\n                uniqueIds.Add(GetIslandId(grid, i, j - 1));\\n                \\n                var currMax = uniqueIds.Sum(id => islands[id]) + 1;\\n                max = Math.Max(currMax, max);\\n                uniqueIds.Clear();\\n            }\\n        }\\n        return max;\\n        \\n\\n        int FloodFillIsland(int[][] mtx, int i, int j, int color)\\n        {\\n            if (i < 0 || i >= mtx.Length || j < 0 || j >= mtx[i].Length)\\n                return 0;\\n\\n            if (mtx[i][j] == 0 || mtx[i][j] == color)\\n                return 0;\\n\\n            mtx[i][j] = color;\\n                \\n            return 1 + FloodFillIsland(mtx, i + 1, j, color)\\n                     + FloodFillIsland(mtx, i - 1, j, color)\\n                     + FloodFillIsland(mtx, i, j + 1, color)\\n                     + FloodFillIsland(mtx, i, j - 1, color);\\n        }\\n        \\n        int GetIslandId(int[][] mtx, int i, int j)\\n        {\\n            if (i < 0 || i >= mtx.Length || j < 0 || j >= mtx[i].Length)\\n                return 0;\\n\\n            return mtx[i][j];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int LargestIsland(int[][] grid)\\n    {\\n        var islands = new Dictionary<int, int> {{0, 0}};\\n        var totalIslandsVolume = 0;\\n        for (int i = 0; i < grid.Length; i++)\\n        {\\n            for (int j = 0; j < grid[i].Length; j++)\\n            {\\n                if (grid[i][j] == 0 || grid[i][j] > 1) continue;\\n                int colorId = islands.Count + 1;\\n                int islandVolume = FloodFillIsland(grid, i, j, colorId);\\n                totalIslandsVolume += islandVolume;\\n                islands.Add(colorId, islandVolume);\\n            }\\n        }\\n\\n        if (totalIslandsVolume == grid.Length * grid[0].Length) \\n            return totalIslandsVolume;\\n        \\n        int max = 1;\\n        var uniqueIds = new HashSet<int>();\\n        for (int i = 0; i < grid.Length; i++)\\n        {\\n            for (int j = 0; j < grid[i].Length; j++)\\n            {\\n                if(grid[i][j] != 0) continue;\\n                \\n                uniqueIds.Add(GetIslandId(grid, i + 1, j));\\n                uniqueIds.Add(GetIslandId(grid, i - 1, j));\\n                uniqueIds.Add(GetIslandId(grid, i, j + 1));\\n                uniqueIds.Add(GetIslandId(grid, i, j - 1));\\n                \\n                var currMax = uniqueIds.Sum(id => islands[id]) + 1;\\n                max = Math.Max(currMax, max);\\n                uniqueIds.Clear();\\n            }\\n        }\\n        return max;\\n        \\n\\n        int FloodFillIsland(int[][] mtx, int i, int j, int color)\\n        {\\n            if (i < 0 || i >= mtx.Length || j < 0 || j >= mtx[i].Length)\\n                return 0;\\n\\n            if (mtx[i][j] == 0 || mtx[i][j] == color)\\n                return 0;\\n\\n            mtx[i][j] = color;\\n                \\n            return 1 + FloodFillIsland(mtx, i + 1, j, color)\\n                     + FloodFillIsland(mtx, i - 1, j, color)\\n                     + FloodFillIsland(mtx, i, j + 1, color)\\n                     + FloodFillIsland(mtx, i, j - 1, color);\\n        }\\n        \\n        int GetIslandId(int[][] mtx, int i, int j)\\n        {\\n            if (i < 0 || i >= mtx.Length || j < 0 || j >= mtx[i].Length)\\n                return 0;\\n\\n            return mtx[i][j];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3106235,
                "title": "java-solution-graph-union-find-easy-understanding-faster-than-99-logic",
                "content": "# Intuition\\nJust club all the islands initially using union-find then check for each zero if making it one can help is making a bridge between two islands. Also, take a max island size as answer and update it if island size can be increased by making 0 as 1(bridge is formed).\\n\\n# Code\\n```\\nclass Solution {\\n    public int largestIsland(int[][] grid) {\\n        int n=grid.length;\\n        DisjointSet ds=new DisjointSet(n*n);\\n        for(int i=0;i<n;i++) { //clustering islands\\n            for(int j=0;j<n;j++) {\\n                if(grid[i][j]==1) {\\n                    if(i-1>=0 && grid[i-1][j]==1) {\\n                        ds.union(getIndex(i, j, n), getIndex(i-1, j, n));\\n                    }\\n                    if(j-1>=0 && grid[i][j-1]==1) {\\n                        ds.union(getIndex(i, j, n), getIndex(i, j-1, n));\\n                    }\\n                }\\n            }\\n        }\\n\\n        int ans=Integer.MIN_VALUE;\\n        for(int x: ds.sets) {\\n            if(x<0) {\\n                ans=Math.max(ans, -x);\\n            }\\n        }\\n\\n        //check if any 0 is made 1 then any bridge is formed between islands\\n        for(int i=0;i<n;i++) { \\n            for(int j=0;j<n;j++) {\\n                if(grid[i][j]==0) {\\n                    int size=1;\\n                    int p1, p2, p3, p4;\\n                    p1=p2=p3=p4=-1;\\n                    if(i-1>=0 && grid[i-1][j]==1) { //up\\n                        p1=ds.find(getIndex(i-1, j, n));\\n                        size+=-ds.sets[p1];\\n                    }\\n                    if(i+1<n && grid[i+1][j]==1) { //down\\n                        p2=ds.find(getIndex(i+1, j, n));\\n                        if(p1!=p2) {\\n                            size+=-ds.sets[p2];\\n                        }\\n                    }\\n                    if(j-1>=0 && grid[i][j-1]==1) { //left\\n                        p3=ds.find(getIndex(i, j-1, n));\\n                        if(p1!=p3 & p2!=p3) {\\n                            size+=-ds.sets[p3];\\n                        }\\n                    }\\n                    if(j+1<n && grid[i][j+1]==1) { //right\\n                        p4=ds.find(getIndex(i, j+1, n));\\n                        if(p1!=p4 & p2!=p4 && p3!=p4) {\\n                            size+=-ds.sets[p4];\\n                        }\\n                    }\\n                    ans=Math.max(ans, size);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private int getIndex(int i, int j, int N) {\\n        return i*N+j;\\n    }\\n\\n    private class DisjointSet {\\n        int sets[];\\n        DisjointSet(int size) {\\n            sets=new int[size];\\n            Arrays.fill(sets, -1);\\n        }\\n\\n        public int find(int idx) {\\n            if(sets[idx]<0) return idx;\\n            else return find(sets[idx]);\\n        }\\n\\n        public int union(int i1, int i2) {\\n            int p1=find(i1);\\n            int p2=find(i2);\\n            if(p1==p2) {\\n                return sets[p1];\\n            }else {\\n                int w1=-sets[p1];\\n                int w2=-sets[p2];\\n                if(w1>=w2) {\\n                    sets[p2]=p1;\\n                    return sets[p1]=-(w1+w2);\\n                }else {\\n                    sets[p1]=p2;\\n                    return sets[p2]=-(w1+w2);\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int largestIsland(int[][] grid) {\\n        int n=grid.length;\\n        DisjointSet ds=new DisjointSet(n*n);\\n        for(int i=0;i<n;i++) { //clustering islands\\n            for(int j=0;j<n;j++) {\\n                if(grid[i][j]==1) {\\n                    if(i-1>=0 && grid[i-1][j]==1) {\\n                        ds.union(getIndex(i, j, n), getIndex(i-1, j, n));\\n                    }\\n                    if(j-1>=0 && grid[i][j-1]==1) {\\n                        ds.union(getIndex(i, j, n), getIndex(i, j-1, n));\\n                    }\\n                }\\n            }\\n        }\\n\\n        int ans=Integer.MIN_VALUE;\\n        for(int x: ds.sets) {\\n            if(x<0) {\\n                ans=Math.max(ans, -x);\\n            }\\n        }\\n\\n        //check if any 0 is made 1 then any bridge is formed between islands\\n        for(int i=0;i<n;i++) { \\n            for(int j=0;j<n;j++) {\\n                if(grid[i][j]==0) {\\n                    int size=1;\\n                    int p1, p2, p3, p4;\\n                    p1=p2=p3=p4=-1;\\n                    if(i-1>=0 && grid[i-1][j]==1) { //up\\n                        p1=ds.find(getIndex(i-1, j, n));\\n                        size+=-ds.sets[p1];\\n                    }\\n                    if(i+1<n && grid[i+1][j]==1) { //down\\n                        p2=ds.find(getIndex(i+1, j, n));\\n                        if(p1!=p2) {\\n                            size+=-ds.sets[p2];\\n                        }\\n                    }\\n                    if(j-1>=0 && grid[i][j-1]==1) { //left\\n                        p3=ds.find(getIndex(i, j-1, n));\\n                        if(p1!=p3 & p2!=p3) {\\n                            size+=-ds.sets[p3];\\n                        }\\n                    }\\n                    if(j+1<n && grid[i][j+1]==1) { //right\\n                        p4=ds.find(getIndex(i, j+1, n));\\n                        if(p1!=p4 & p2!=p4 && p3!=p4) {\\n                            size+=-ds.sets[p4];\\n                        }\\n                    }\\n                    ans=Math.max(ans, size);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private int getIndex(int i, int j, int N) {\\n        return i*N+j;\\n    }\\n\\n    private class DisjointSet {\\n        int sets[];\\n        DisjointSet(int size) {\\n            sets=new int[size];\\n            Arrays.fill(sets, -1);\\n        }\\n\\n        public int find(int idx) {\\n            if(sets[idx]<0) return idx;\\n            else return find(sets[idx]);\\n        }\\n\\n        public int union(int i1, int i2) {\\n            int p1=find(i1);\\n            int p2=find(i2);\\n            if(p1==p2) {\\n                return sets[p1];\\n            }else {\\n                int w1=-sets[p1];\\n                int w2=-sets[p2];\\n                if(w1>=w2) {\\n                    sets[p2]=p1;\\n                    return sets[p1]=-(w1+w2);\\n                }else {\\n                    sets[p1]=p2;\\n                    return sets[p2]=-(w1+w2);\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3009642,
                "title": "dfs-based-solution-using-unique-id-for-each-island",
                "content": "\\nfirst store all the islands in a list using bfs/dfs\\nmark all the islands with a index within the grid\\ncreate a hash map with key as index and size of island as the value\\nThis will be done by itetrating over teh entire grid once O(m*n)\\nwe will have to iterate over the grid again, checking for 0s and flipping\\nevery 0 to 1 and see if the size of islands that can be formed. \\nWe can do this either by iterating over the grid again (which will result\\nin a TLE). So rather, we capture all the water cells in our first iteration \\nand then only iterate on the water cells in the next run\\n\\n```\\nclass Solution:\\n    def largestIsland(self, grid: List[List[int]]) -> int:\\n        \\n        m, n = len(grid), len(grid[0])\\n\\n        def is_valid(i, j):\\n            return 0 <= i < m and 0 <= j < n\\n\\n        def get_neighbors(i, j):\\n            return [(i+1,j), (i-1,j), (i,j+1), (i,j-1)]\\n\\n        def dfs(i,j, index):\\n            grid[i][j] = index\\n            count = 1\\n            for nei in get_neighbors(i, j):\\n                x, y = nei\\n                if is_valid(x, y) and grid[x][y] == 1:\\n                    grid[x][y] = index\\n                    count+=dfs(x,y, index)\\n            return count\\n\\n        islands_map = {}\\n        self.max_len = 0\\n        water_cells = set()\\n\\n        index = 2\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 0:\\n                    water_cells.add((i,j))\\n                elif grid[i][j] == 1:\\n                    size = dfs(i, j, index)\\n                    islands_map[index] = size\\n                    self.max_len = max(self.max_len, size)\\n                    index+=1\\n        \\n        for cell in water_cells:\\n            i, j = cell\\n            # make it 1 and see, how big island can be formed idxs = set()\\n            idxs = set()\\n            island_len = 1\\n            for nei in get_neighbors(i, j):\\n                x, y = nei\\n                if is_valid(x, y) and grid[x][y] in islands_map and grid[x][y] not in idxs:\\n                    idxs.add(grid[x][y])\\n                    island_len+=islands_map[grid[x][y]]\\n\\n            self.max_len = max(self.max_len, island_len)\\n        return self.max_len\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def largestIsland(self, grid: List[List[int]]) -> int:\\n        \\n        m, n = len(grid), len(grid[0])\\n\\n        def is_valid(i, j):\\n            return 0 <= i < m and 0 <= j < n\\n\\n        def get_neighbors(i, j):\\n            return [(i+1,j), (i-1,j), (i,j+1), (i,j-1)]\\n\\n        def dfs(i,j, index):\\n            grid[i][j] = index\\n            count = 1\\n            for nei in get_neighbors(i, j):\\n                x, y = nei\\n                if is_valid(x, y) and grid[x][y] == 1:\\n                    grid[x][y] = index\\n                    count+=dfs(x,y, index)\\n            return count\\n\\n        islands_map = {}\\n        self.max_len = 0\\n        water_cells = set()\\n\\n        index = 2\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 0:\\n                    water_cells.add((i,j))\\n                elif grid[i][j] == 1:\\n                    size = dfs(i, j, index)\\n                    islands_map[index] = size\\n                    self.max_len = max(self.max_len, size)\\n                    index+=1\\n        \\n        for cell in water_cells:\\n            i, j = cell\\n            # make it 1 and see, how big island can be formed idxs = set()\\n            idxs = set()\\n            island_len = 1\\n            for nei in get_neighbors(i, j):\\n                x, y = nei\\n                if is_valid(x, y) and grid[x][y] in islands_map and grid[x][y] not in idxs:\\n                    idxs.add(grid[x][y])\\n                    island_len+=islands_map[grid[x][y]]\\n\\n            self.max_len = max(self.max_len, island_len)\\n        return self.max_len\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2953768,
                "title": "clean-code-using-disjoint-set-beats-96",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DisjointSet \\n{    \\npublic: \\nvector<int> rank, parent, size; \\n    DisjointSet(int n) \\n{\\n        rank.resize(n+1, 0); \\n        parent.resize(n+1);\\n        size.resize(n+1); \\n        for(int i = 0;i<=n;i++) {\\n            parent[i] = i; \\n            size[i] = 1; \\n        }\\n    }\\n\\n    int findUPar(int node) \\n   {\\n        if(node == parent[node])\\n            return node; \\n        return parent[node] = findUPar(parent[node]); \\n    }\\n\\n    void unionByRank(int u, int v) \\n {\\n        int ulp_u = findUPar(u); \\n        int ulp_v = findUPar(v); \\n        if(ulp_u == ulp_v) return; \\n        if(rank[ulp_u] < rank[ulp_v]) {\\n            parent[ulp_u] = ulp_v; \\n        }\\n        else if(rank[ulp_v] < rank[ulp_u]) {\\n            parent[ulp_v] = ulp_u; \\n        }\\n        else {\\n            parent[ulp_v] = ulp_u; \\n            rank[ulp_u]++; \\n        }\\n    }\\n\\n    void unionBySize(int u, int v)\\n {\\n        int ulp_u = findUPar(u); \\n        int ulp_v = findUPar(v); \\n        if(ulp_u == ulp_v) return; \\n        if(size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v; \\n            size[ulp_v] += size[ulp_u]; \\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v]; \\n        }\\n    }\\n}; \\nclass Solution {\\n\\npublic:\\n    int findnode(int row,int col,int s)\\n    {\\n        return (row*s)+col;\\n    }\\n    int largestIsland(vector<vector<int>>& grid) \\n    {\\n        \\n        int s=grid.size();\\n        DisjointSet ds(s*s);\\n\\n        int drow[]={-1,0,1,0};\\n        int dcol[]={0,1,0,-1};\\n        \\n        int nonconverted=0;//store the maximum nodes if none of them are converted\\n\\n        vector<vector<int>>visited(s,vector<int>(s,0));\\n\\n        for(int row=0;row<s;row++)\\n        {\\n            for(int col=0;col<s;col++)\\n            {\\n                if(grid[row][col]==1 && visited[row][col]!=1)\\n                {\\n                    visited[row][col]=1;\\n                    for(int i=0;i<4;i++)\\n                    {\\n                        int nrow=row+drow[i];\\n                        int ncol=col+dcol[i];\\n                        \\n                        if(nrow>=0 && nrow<s && ncol>=0 && ncol<s && grid[nrow][ncol]==1 )\\n                        {\\n                            int nodeno=findnode(row,col,s);\\n                            int adj_nodeno=findnode(nrow,ncol,s);\\n                            ds.unionBySize(nodeno,adj_nodeno);\\n                            nonconverted=max(nonconverted,ds.size[ds.findUPar(nodeno)]);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        int converted=0;\\n        for(int row=0;row<s;row++)\\n        {\\n            for(int col=0;col<s;col++)\\n            {\\n                if(grid[row][col]==0)\\n                {\\n                    set<int>st;\\n                    for(int i=0;i<4;i++)\\n                    {\\n                        int nrow=row+drow[i];\\n                        int ncol=col+dcol[i];\\n                        if(nrow>=0 && nrow<s && ncol>=0 && ncol<s && grid[nrow][ncol]==1)\\n                        {\\n                            int adj_nodeno=findnode(nrow,ncol,s);\\n                            int par=ds.findUPar(adj_nodeno);\\n                            st.insert(par);\\n                        }\\n                    }\\n                    int temp=0;\\n                    for(auto it:st)\\n                        temp+=ds.size[it];\\n                    converted=max(converted,temp);\\n                }\\n            }\\n        }\\n        return max(converted+1,nonconverted);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DisjointSet \\n{    \\npublic: \\nvector<int> rank, parent, size; \\n    DisjointSet(int n) \\n{\\n        rank.resize(n+1, 0); \\n        parent.resize(n+1);\\n        size.resize(n+1); \\n        for(int i = 0;i<=n;i++) {\\n            parent[i] = i; \\n            size[i] = 1; \\n        }\\n    }\\n\\n    int findUPar(int node) \\n   {\\n        if(node == parent[node])\\n            return node; \\n        return parent[node] = findUPar(parent[node]); \\n    }\\n\\n    void unionByRank(int u, int v) \\n {\\n        int ulp_u = findUPar(u); \\n        int ulp_v = findUPar(v); \\n        if(ulp_u == ulp_v) return; \\n        if(rank[ulp_u] < rank[ulp_v]) {\\n            parent[ulp_u] = ulp_v; \\n        }\\n        else if(rank[ulp_v] < rank[ulp_u]) {\\n            parent[ulp_v] = ulp_u; \\n        }\\n        else {\\n            parent[ulp_v] = ulp_u; \\n            rank[ulp_u]++; \\n        }\\n    }\\n\\n    void unionBySize(int u, int v)\\n {\\n        int ulp_u = findUPar(u); \\n        int ulp_v = findUPar(v); \\n        if(ulp_u == ulp_v) return; \\n        if(size[ulp_u] < size[ulp_v]) {\\n            parent[ulp_u] = ulp_v; \\n            size[ulp_v] += size[ulp_u]; \\n        }\\n        else {\\n            parent[ulp_v] = ulp_u;\\n            size[ulp_u] += size[ulp_v]; \\n        }\\n    }\\n}; \\nclass Solution {\\n\\npublic:\\n    int findnode(int row,int col,int s)\\n    {\\n        return (row*s)+col;\\n    }\\n    int largestIsland(vector<vector<int>>& grid) \\n    {\\n        \\n        int s=grid.size();\\n        DisjointSet ds(s*s);\\n\\n        int drow[]={-1,0,1,0};\\n        int dcol[]={0,1,0,-1};\\n        \\n        int nonconverted=0;//store the maximum nodes if none of them are converted\\n\\n        vector<vector<int>>visited(s,vector<int>(s,0));\\n\\n        for(int row=0;row<s;row++)\\n        {\\n            for(int col=0;col<s;col++)\\n            {\\n                if(grid[row][col]==1 && visited[row][col]!=1)\\n                {\\n                    visited[row][col]=1;\\n                    for(int i=0;i<4;i++)\\n                    {\\n                        int nrow=row+drow[i];\\n                        int ncol=col+dcol[i];\\n                        \\n                        if(nrow>=0 && nrow<s && ncol>=0 && ncol<s && grid[nrow][ncol]==1 )\\n                        {\\n                            int nodeno=findnode(row,col,s);\\n                            int adj_nodeno=findnode(nrow,ncol,s);\\n                            ds.unionBySize(nodeno,adj_nodeno);\\n                            nonconverted=max(nonconverted,ds.size[ds.findUPar(nodeno)]);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        int converted=0;\\n        for(int row=0;row<s;row++)\\n        {\\n            for(int col=0;col<s;col++)\\n            {\\n                if(grid[row][col]==0)\\n                {\\n                    set<int>st;\\n                    for(int i=0;i<4;i++)\\n                    {\\n                        int nrow=row+drow[i];\\n                        int ncol=col+dcol[i];\\n                        if(nrow>=0 && nrow<s && ncol>=0 && ncol<s && grid[nrow][ncol]==1)\\n                        {\\n                            int adj_nodeno=findnode(nrow,ncol,s);\\n                            int par=ds.findUPar(adj_nodeno);\\n                            st.insert(par);\\n                        }\\n                    }\\n                    int temp=0;\\n                    for(auto it:st)\\n                        temp+=ds.size[it];\\n                    converted=max(converted,temp);\\n                }\\n            }\\n        }\\n        return max(converted+1,nonconverted);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2944594,
                "title": "java-one-of-the-easiest-solution-striver-s-approach-union-by-size-explanation",
                "content": "```\\nclass Solution {\\n    public static int largestIsland(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        DisjointSet ds = new DisjointSet(n * m);\\n        int[] xcor = {1, -1, 0, 0};\\n        int[] ycor = {0, 0, -1, 1};\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1) {\\n                    int u = i * m + j;\\n                    for (int k = 0; k < 4; k++) {\\n                        int xtemp = xcor[k] + i;\\n                        int ytemp = ycor[k] + j;\\n                        if (isValid(xtemp, ytemp, n, m)) {\\n                            if (grid[xtemp][ytemp] == 1) {\\n                                int v = xtemp * m + ytemp;\\n                                ds.unionBySize(u, v);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        int zeros = 0;\\n        int max = Integer.MIN_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 0) {\\n                    zeros++;\\n                    int allDirCount = 1;\\n                    HashSet<Integer> upsca = new HashSet<>();\\n                    for (int k = 0; k < 4; k++) {\\n                        int xtemp = xcor[k] + i;\\n                        int ytemp = ycor[k] + j;\\n                        if (isValid(xtemp, ytemp, n, m)) {\\n                            if (grid[xtemp][ytemp] == 1) {\\n                                int v = xtemp * m + ytemp;\\n                                int curUp = ds.findUP(v);\\n                                if(upsca.contains(curUp)) continue;\\n                                allDirCount += ds.size.get(curUp);\\n                                upsca.add(curUp);\\n                            }\\n                        }\\n                    }\\n                    max = Math.max(max, allDirCount);\\n                }\\n            }\\n        }\\n        if(zeros == 0) return ds.size.get(0);\\n        return max;\\n    }\\n    \\n    private static boolean isValid(int x, int y, int n, int m) {\\n        return x >= 0 && x < n && y >= 0 && y < m;\\n    }\\n\\n    static class DisjointSet {\\n        List<Integer> size = new ArrayList<>();\\n        List<Integer> parent = new ArrayList<>();\\n\\n        DisjointSet(int n) {\\n            for (int i = 0; i < n; i++) {\\n                size.add(1);\\n                parent.add(i);\\n            }\\n        }\\n\\n        int findUP(int node) {\\n            if (node == parent.get(node)) return node;\\n            int up = findUP(parent.get(node));\\n            parent.set(node, up);\\n            return up;\\n        }\\n\\n        void unionBySize(int u, int v) {\\n            int pu = findUP(u);\\n            int pv = findUP(v);\\n            if (pu == pv) {\\n                return;\\n            }\\n            if (size.get(pu) < size.get(pv)) {\\n                parent.set(pu, pv);\\n                size.set(pv, size.get(pu) + size.get(pv));\\n            } else {\\n                parent.set(pv, pu);\\n                size.set(pu, size.get(pv) + size.get(pu));\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public static int largestIsland(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        DisjointSet ds = new DisjointSet(n * m);\\n        int[] xcor = {1, -1, 0, 0};\\n        int[] ycor = {0, 0, -1, 1};\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1) {\\n                    int u = i * m + j;\\n                    for (int k = 0; k < 4; k++) {\\n                        int xtemp = xcor[k] + i;\\n                        int ytemp = ycor[k] + j;\\n                        if (isValid(xtemp, ytemp, n, m)) {\\n                            if (grid[xtemp][ytemp] == 1) {\\n                                int v = xtemp * m + ytemp;\\n                                ds.unionBySize(u, v);\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        int zeros = 0;\\n        int max = Integer.MIN_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 0) {\\n                    zeros++;\\n                    int allDirCount = 1;\\n                    HashSet<Integer> upsca = new HashSet<>();\\n                    for (int k = 0; k < 4; k++) {\\n                        int xtemp = xcor[k] + i;\\n                        int ytemp = ycor[k] + j;\\n                        if (isValid(xtemp, ytemp, n, m)) {\\n                            if (grid[xtemp][ytemp] == 1) {\\n                                int v = xtemp * m + ytemp;\\n                                int curUp = ds.findUP(v);\\n                                if(upsca.contains(curUp)) continue;\\n                                allDirCount += ds.size.get(curUp);\\n                                upsca.add(curUp);\\n                            }\\n                        }\\n                    }\\n                    max = Math.max(max, allDirCount);\\n                }\\n            }\\n        }\\n        if(zeros == 0) return ds.size.get(0);\\n        return max;\\n    }\\n    \\n    private static boolean isValid(int x, int y, int n, int m) {\\n        return x >= 0 && x < n && y >= 0 && y < m;\\n    }\\n\\n    static class DisjointSet {\\n        List<Integer> size = new ArrayList<>();\\n        List<Integer> parent = new ArrayList<>();\\n\\n        DisjointSet(int n) {\\n            for (int i = 0; i < n; i++) {\\n                size.add(1);\\n                parent.add(i);\\n            }\\n        }\\n\\n        int findUP(int node) {\\n            if (node == parent.get(node)) return node;\\n            int up = findUP(parent.get(node));\\n            parent.set(node, up);\\n            return up;\\n        }\\n\\n        void unionBySize(int u, int v) {\\n            int pu = findUP(u);\\n            int pv = findUP(v);\\n            if (pu == pv) {\\n                return;\\n            }\\n            if (size.get(pu) < size.get(pv)) {\\n                parent.set(pu, pv);\\n                size.set(pv, size.get(pu) + size.get(pv));\\n            } else {\\n                parent.set(pv, pu);\\n                size.set(pu, size.get(pv) + size.get(pu));\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2590688,
                "title": "c-dfs-and-bfs-methods-but-tle-xd",
                "content": "\\n```\\nint largestIsland(std::vector<std::vector<int>>& grid) {\\n\\t// dfs method\\n\\tconst int m = grid.size(), n = grid[0].size();\\n\\tint result = 0;\\n\\tbool has_zero = false;\\n\\tfor (int i = 0; i < m; i++) {\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tif (grid[i][j] == 1) continue;\\n\\t\\t\\tgrid[i][j] = 1;\\n\\n\\t\\t\\tstd::vector<std::vector<bool>> visited(m, std::vector<bool>(n));\\n\\t\\t\\tresult = std::max(result, helper(grid, i, j, visited));\\n\\t\\t\\tif (result == m * n) return result;\\n\\n\\t\\t\\tgrid[i][j] = 0;\\n\\t\\t\\thas_zero = true;\\n\\t\\t}\\n\\t}\\n\\treturn has_zero ? result : m * n;\\n}\\nint helper(std::vector<std::vector<int>>& grid, int i, int j, \\n\\t\\t   std::vector<std::vector<bool>>& visited) {\\n\\tconst int m = grid.size(), n = grid[0].size();\\n\\tif (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] == 0 || visited[i][j]) return 0;\\n\\tvisited[i][j] = true;\\n\\treturn 1 + helper(grid, i - 1, j, visited) \\n\\t\\t\\t + helper(grid, i + 1, j, visited) \\n\\t\\t\\t + helper(grid, i, j - 1, visited) \\n\\t\\t\\t + helper(grid, i, j + 1, visited);\\n}\\n```\\n```\\nTime Limit Exceeded, 66 / 75 test cases passed\\n```\\n\\n```\\nint largestIsland(std::vector<std::vector<int>>& grid) {\\n\\t// bfs method\\n\\tconst int m = grid.size(), n = grid[0].size();\\n\\tint result = 0;\\n\\tbool has_zero = false;\\n\\tstd::vector<int> dir_x{0, -1, 0, 1}, dir_y{-1, 0, 1, 0};\\n\\tfor (int i = 0; i < m; i ++) {\\n\\t\\t for (int j = 0; j < n; j++) {\\n\\t\\t\\t if (grid[i][j] == 1) continue;\\n\\t\\t\\t std::vector<std::vector<bool>> visited(m, std::vector<bool>(n));\\n\\t\\t\\t std::queue<int> queue_{{i * n + j}};\\n\\t\\t\\t int sum = 0;\\n\\t\\t\\t while (!queue_.empty()) {\\n\\t\\t\\t\\t int temp = queue_.front(); queue_.pop();\\n\\t\\t\\t\\t sum++;\\n\\t\\t\\t\\t for (int k = 0; k < 4; k++) {\\n\\t\\t\\t\\t\\t const int x = temp / n + dir_x[k];\\n\\t\\t\\t\\t\\t const int y = temp % n + dir_y[k];\\n\\t\\t\\t\\t\\t if (x < 0 || x >= m || y < 0 || y >= n \\n\\t\\t\\t\\t\\t\\t || grid[x][y] == 0 || visited[x][y]) continue;\\n\\t\\t\\t\\t\\t visited[x][y] = true;\\n\\t\\t\\t\\t\\t queue_.push(x * n + y);\\n\\t\\t\\t\\t }\\n\\t\\t\\t }\\n\\t\\t\\t result = std::max(result, sum);\\n\\t\\t\\t if (result == m * n) return result;\\n\\t\\t\\t has_zero = true;\\n\\t\\t }\\n\\t}\\n\\treturn has_zero ? result : m * n;\\n}\\n```\\n```\\nTime Limit Exceeded, 67 / 75 test cases passed\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nint largestIsland(std::vector<std::vector<int>>& grid) {\\n\\t// dfs method\\n\\tconst int m = grid.size(), n = grid[0].size();\\n\\tint result = 0;\\n\\tbool has_zero = false;\\n\\tfor (int i = 0; i < m; i++) {\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tif (grid[i][j] == 1) continue;\\n\\t\\t\\tgrid[i][j] = 1;\\n\\n\\t\\t\\tstd::vector<std::vector<bool>> visited(m, std::vector<bool>(n));\\n\\t\\t\\tresult = std::max(result, helper(grid, i, j, visited));\\n\\t\\t\\tif (result == m * n) return result;\\n\\n\\t\\t\\tgrid[i][j] = 0;\\n\\t\\t\\thas_zero = true;\\n\\t\\t}\\n\\t}\\n\\treturn has_zero ? result : m * n;\\n}\\nint helper(std::vector<std::vector<int>>& grid, int i, int j, \\n\\t\\t   std::vector<std::vector<bool>>& visited) {\\n\\tconst int m = grid.size(), n = grid[0].size();\\n\\tif (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] == 0 || visited[i][j]) return 0;\\n\\tvisited[i][j] = true;\\n\\treturn 1 + helper(grid, i - 1, j, visited) \\n\\t\\t\\t + helper(grid, i + 1, j, visited) \\n\\t\\t\\t + helper(grid, i, j - 1, visited) \\n\\t\\t\\t + helper(grid, i, j + 1, visited);\\n}\\n```\n```\\nTime Limit Exceeded, 66 / 75 test cases passed\\n```\n```\\nint largestIsland(std::vector<std::vector<int>>& grid) {\\n\\t// bfs method\\n\\tconst int m = grid.size(), n = grid[0].size();\\n\\tint result = 0;\\n\\tbool has_zero = false;\\n\\tstd::vector<int> dir_x{0, -1, 0, 1}, dir_y{-1, 0, 1, 0};\\n\\tfor (int i = 0; i < m; i ++) {\\n\\t\\t for (int j = 0; j < n; j++) {\\n\\t\\t\\t if (grid[i][j] == 1) continue;\\n\\t\\t\\t std::vector<std::vector<bool>> visited(m, std::vector<bool>(n));\\n\\t\\t\\t std::queue<int> queue_{{i * n + j}};\\n\\t\\t\\t int sum = 0;\\n\\t\\t\\t while (!queue_.empty()) {\\n\\t\\t\\t\\t int temp = queue_.front(); queue_.pop();\\n\\t\\t\\t\\t sum++;\\n\\t\\t\\t\\t for (int k = 0; k < 4; k++) {\\n\\t\\t\\t\\t\\t const int x = temp / n + dir_x[k];\\n\\t\\t\\t\\t\\t const int y = temp % n + dir_y[k];\\n\\t\\t\\t\\t\\t if (x < 0 || x >= m || y < 0 || y >= n \\n\\t\\t\\t\\t\\t\\t || grid[x][y] == 0 || visited[x][y]) continue;\\n\\t\\t\\t\\t\\t visited[x][y] = true;\\n\\t\\t\\t\\t\\t queue_.push(x * n + y);\\n\\t\\t\\t\\t }\\n\\t\\t\\t }\\n\\t\\t\\t result = std::max(result, sum);\\n\\t\\t\\t if (result == m * n) return result;\\n\\t\\t\\t has_zero = true;\\n\\t\\t }\\n\\t}\\n\\treturn has_zero ? result : m * n;\\n}\\n```\n```\\nTime Limit Exceeded, 67 / 75 test cases passed\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2512651,
                "title": "c-python-union-find-solution-with-explanation",
                "content": "### union find\\nfiirst, use union find to track the size of island, then traverse every ```0``` in the gird, calaulte union area around the ```0```\\nthe min of ```ans``` is 1, even if the zeros array, change one ```0``` to ```1``` at least.\\n\\ntc is```O(n^2)```, sc is the same as tc.\\n\\n### python\\n```python\\nclass DSU:\\n    def __init__(self, size):\\n        self.parent = [i for i in range(size)]\\n        self.size = [1] * size\\n\\n    def find(self, x):\\n        if self.parent[x] != x:\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n\\n    def union(self, p, q):\\n        rootp, rootq = self.find(p), self.find(q)\\n        if rootp == rootq: return\\n        if self.size[rootp] > self.size[rootq]:\\n            self.parent[rootq] = rootp\\n            self.size[rootp]+=self.size[rootq]\\n        else:\\n            self.parent[rootp] = rootq\\n            self.size[rootq] += self.size[rootp]\\n\\nclass Solution:\\n    def largestIsland(self, grid: List[List[int]]) -> int:\\n        numRow, numCol, ans = len(grid), len(grid[0]), 1\\n        dsu, directions = DSU(numRow*numCol), [[1,0],[0,1],[-1,0],[0,-1]]\\n        \\n        for i in range(numRow):\\n            for j in range(numCol):\\n                if grid[i][j] == 1:\\n                    for dx, dy in directions:\\n                        nextX, nextY = i+dx, j+dy\\n                        if nextX<0 or nextY<0 or nextX>=numRow or nextY>=numCol or grid[nextX][nextY] == 0: continue\\n                        dsu.union(i*numCol+j, nextX*numCol+nextY)\\n                        ans = max(ans, dsu.size[dsu.find(i*numCol+j)])\\n        for i in range(numRow):\\n            for j in range(numCol):\\n                if grid[i][j] == 0:\\n                    neighborToSize = {}\\n                    for dx, dy in directions:\\n                        nextX, nextY = i+dx, j+dy\\n                        if nextX<0 or nextY<0 or nextX>=numRow or nextY>=numCol or grid[nextX][nextY] == 0: continue\\n                        p = dsu.find(nextX*numCol+nextY)\\n                        neighborToSize[p] = dsu.size[p]\\n                    ans = max(ans, sum(neighborToSize.values()) + 1)\\n        return ans \\n```\\n\\n### c++\\n```cpp\\nconst int dirs[] {0,1,0,-1,0};\\n\\nclass DSU {\\npublic:\\n    vector<int> parent, size;\\n    DSU (int size): parent(size), size(size, 1) {\\n        for (int i = 0; i < size; i+=1)\\n            parent[i] = i;\\n    }\\n    int find(int p) {\\n        if (this -> parent[p] != p)\\n            this -> parent[p] = this -> find(this -> parent[p]);\\n        return this -> parent[p];\\n    }\\n    \\n    void join(int p, int q) {\\n        int pp = this -> find(p), pq = this -> find(q);\\n        if(pp == pq) return;\\n        this -> parent[pq] = pp;\\n        this -> size[pp] += this -> size[pq];\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int size = grid.size(), cnt = 0;\\n        DSU dsu (size * size);\\n        for (int i = 0; i < size; i+=1) {\\n            for (int j = 0; j < size; j+=1) {\\n                if (grid[i][j]) {\\n                    cnt += 1;\\n                    for (int k = 0, ni, nj; k < 4; k+=1) {\\n                        ni = i + dirs[k], nj = j + dirs[k+1];\\n                        if (0 <= ni && size > ni && 0 <= nj && size > nj && grid[ni][nj])\\n                            dsu.join(i * size + j, ni * size + nj);\\n                    }\\n                }\\n            }\\n        }\\n        if (cnt == size * size) return size * size;\\n        unordered_set<int> s;\\n        int ans = 0;\\n        for (int i = 0; i < size; i+=1) {\\n            for (int j = 0, area; j < size; j+=1) {\\n                if (grid[i][j] == 0) {\\n                    area = 1;\\n                    for (int k = 0, ni, nj, g; k < 4; k+=1) {\\n                        ni = i + dirs[k], nj = j + dirs[k+1];\\n                        if (0 <= ni && size > ni && 0 <= nj && size > nj && grid[ni][nj]) {\\n                            g = dsu.find(ni * size + nj);\\n                            if (s.count(g) == 0) {\\n                                area += dsu.size[g];\\n                                s.emplace(g);\\n                            }\\n                        }\\n                    }\\n                    if (area > ans) ans = area;\\n                    s.clear();\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Union Find"
                ],
                "code": "```0```\n```0```\n```ans```\n```0```\n```1```\n```O(n^2)```\n```python\\nclass DSU:\\n    def __init__(self, size):\\n        self.parent = [i for i in range(size)]\\n        self.size = [1] * size\\n\\n    def find(self, x):\\n        if self.parent[x] != x:\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n\\n    def union(self, p, q):\\n        rootp, rootq = self.find(p), self.find(q)\\n        if rootp == rootq: return\\n        if self.size[rootp] > self.size[rootq]:\\n            self.parent[rootq] = rootp\\n            self.size[rootp]+=self.size[rootq]\\n        else:\\n            self.parent[rootp] = rootq\\n            self.size[rootq] += self.size[rootp]\\n\\nclass Solution:\\n    def largestIsland(self, grid: List[List[int]]) -> int:\\n        numRow, numCol, ans = len(grid), len(grid[0]), 1\\n        dsu, directions = DSU(numRow*numCol), [[1,0],[0,1],[-1,0],[0,-1]]\\n        \\n        for i in range(numRow):\\n            for j in range(numCol):\\n                if grid[i][j] == 1:\\n                    for dx, dy in directions:\\n                        nextX, nextY = i+dx, j+dy\\n                        if nextX<0 or nextY<0 or nextX>=numRow or nextY>=numCol or grid[nextX][nextY] == 0: continue\\n                        dsu.union(i*numCol+j, nextX*numCol+nextY)\\n                        ans = max(ans, dsu.size[dsu.find(i*numCol+j)])\\n        for i in range(numRow):\\n            for j in range(numCol):\\n                if grid[i][j] == 0:\\n                    neighborToSize = {}\\n                    for dx, dy in directions:\\n                        nextX, nextY = i+dx, j+dy\\n                        if nextX<0 or nextY<0 or nextX>=numRow or nextY>=numCol or grid[nextX][nextY] == 0: continue\\n                        p = dsu.find(nextX*numCol+nextY)\\n                        neighborToSize[p] = dsu.size[p]\\n                    ans = max(ans, sum(neighborToSize.values()) + 1)\\n        return ans \\n```\n```cpp\\nconst int dirs[] {0,1,0,-1,0};\\n\\nclass DSU {\\npublic:\\n    vector<int> parent, size;\\n    DSU (int size): parent(size), size(size, 1) {\\n        for (int i = 0; i < size; i+=1)\\n            parent[i] = i;\\n    }\\n    int find(int p) {\\n        if (this -> parent[p] != p)\\n            this -> parent[p] = this -> find(this -> parent[p]);\\n        return this -> parent[p];\\n    }\\n    \\n    void join(int p, int q) {\\n        int pp = this -> find(p), pq = this -> find(q);\\n        if(pp == pq) return;\\n        this -> parent[pq] = pp;\\n        this -> size[pp] += this -> size[pq];\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int size = grid.size(), cnt = 0;\\n        DSU dsu (size * size);\\n        for (int i = 0; i < size; i+=1) {\\n            for (int j = 0; j < size; j+=1) {\\n                if (grid[i][j]) {\\n                    cnt += 1;\\n                    for (int k = 0, ni, nj; k < 4; k+=1) {\\n                        ni = i + dirs[k], nj = j + dirs[k+1];\\n                        if (0 <= ni && size > ni && 0 <= nj && size > nj && grid[ni][nj])\\n                            dsu.join(i * size + j, ni * size + nj);\\n                    }\\n                }\\n            }\\n        }\\n        if (cnt == size * size) return size * size;\\n        unordered_set<int> s;\\n        int ans = 0;\\n        for (int i = 0; i < size; i+=1) {\\n            for (int j = 0, area; j < size; j+=1) {\\n                if (grid[i][j] == 0) {\\n                    area = 1;\\n                    for (int k = 0, ni, nj, g; k < 4; k+=1) {\\n                        ni = i + dirs[k], nj = j + dirs[k+1];\\n                        if (0 <= ni && size > ni && 0 <= nj && size > nj && grid[ni][nj]) {\\n                            g = dsu.find(ni * size + nj);\\n                            if (s.count(g) == 0) {\\n                                area += dsu.size[g];\\n                                s.emplace(g);\\n                            }\\n                        }\\n                    }\\n                    if (area > ans) ans = area;\\n                    s.clear();\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2377922,
                "title": "89-tc-and-50-sc-easy-python-solution",
                "content": "```\\ndef largestIsland(self, grid: List[List[int]]) -> int:\\n\\t@lru_cache(None)\\n\\tdef dfs(i, j, c):\\n\\t\\tgrid[i][j] = c\\n\\t\\ttemp = 1\\n\\t\\tfor x, y in dir:\\n\\t\\t\\tif(0<=i+x<n and 0<=j+y<n and grid[i+x][j+y] == 1):\\n\\t\\t\\t\\ttemp += dfs(i+x, j+y, c)\\n\\t\\treturn temp\\n\\tn = len(grid)\\n\\tdir = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n\\tarea = dict()\\n\\tc = 2\\n\\tpos = []\\n\\tfor i in range(n):\\n\\t\\tfor j in range(n):\\n\\t\\t\\tif(grid[i][j] == 1):\\n\\t\\t\\t\\tarea[c] = dfs(i, j, c)\\n\\t\\t\\t\\tc += 1\\n\\t\\t\\telif(grid[i][j] == 0):\\n\\t\\t\\t\\tpos.append((i, j))\\n\\tans = 0\\n\\tif not(pos): return n**2\\n\\tfor i, j in pos:\\n\\t\\tneigh = set()\\n\\t\\tfor x, y in dir:\\n\\t\\t\\tif(0<=i+x<n and 0<=j+y<n and grid[i+x][j+y] != 0):\\n\\t\\t\\t\\tneigh.add(grid[i+x][j+y])\\n\\t\\tneigh = list(neigh)\\n\\t\\tneigh = [area[i] for i in neigh]\\n\\t\\tans = max(ans, 1 + sum(neigh))\\n\\treturn ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\ndef largestIsland(self, grid: List[List[int]]) -> int:\\n\\t@lru_cache(None)\\n\\tdef dfs(i, j, c):\\n\\t\\tgrid[i][j] = c\\n\\t\\ttemp = 1\\n\\t\\tfor x, y in dir:\\n\\t\\t\\tif(0<=i+x<n and 0<=j+y<n and grid[i+x][j+y] == 1):\\n\\t\\t\\t\\ttemp += dfs(i+x, j+y, c)\\n\\t\\treturn temp\\n\\tn = len(grid)\\n\\tdir = [(1, 0), (-1, 0), (0, 1), (0, -1)]\\n\\tarea = dict()\\n\\tc = 2\\n\\tpos = []\\n\\tfor i in range(n):\\n\\t\\tfor j in range(n):\\n\\t\\t\\tif(grid[i][j] == 1):\\n\\t\\t\\t\\tarea[c] = dfs(i, j, c)\\n\\t\\t\\t\\tc += 1\\n\\t\\t\\telif(grid[i][j] == 0):\\n\\t\\t\\t\\tpos.append((i, j))\\n\\tans = 0\\n\\tif not(pos): return n**2\\n\\tfor i, j in pos:\\n\\t\\tneigh = set()\\n\\t\\tfor x, y in dir:\\n\\t\\t\\tif(0<=i+x<n and 0<=j+y<n and grid[i+x][j+y] != 0):\\n\\t\\t\\t\\tneigh.add(grid[i+x][j+y])\\n\\t\\tneigh = list(neigh)\\n\\t\\tneigh = [area[i] for i in neigh]\\n\\t\\tans = max(ans, 1 + sum(neigh))\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2371262,
                "title": "c-dfs-easy-beginner-graph-coloring",
                "content": "```\\nclass Solution {\\npublic:\\n    int col=2;  //color of island\\n    int dir[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\\n    \\n    \\n    int dfs(vector<vector<int>>& grid,int i,int j,vector<vector<int>> &vis,vector<pair<int,int>>& c,int col)\\n    {\\n        if(i<0 || i>=grid.size() || j<0 || j>=grid[0].size() ||grid[i][j]==0||vis[i][j]!=-1)\\n            return 0;\\n        \\n        vis[i][j]=1;\\n        grid[i][j]=col;\\n        c.push_back(make_pair(i,j));\\n        return (1+dfs(grid,i+1,j,vis,c,col)+dfs(grid,i,j-1,vis,c,col)+dfs(grid,i,j+1,vis,c,col)+dfs(grid,i-1,j,vis,c,col));\\n    }\\n    \\n    int largestIsland(vector<vector<int>>& grid) \\n    {\\n        int n=grid.size();\\n        vector<vector<int>> vis(n,vector<int>(n,-1));\\n        int res=1;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==1 && vis[i][j]==-1)\\n                {\\n                    vector<pair<int,int>> c;\\n                    int ans=dfs(grid,i,j,vis,c,col);\\n                    res=max(res,ans);  \\n                    mp[col]=ans;\\n                    col++;\\n                }\\n            }\\n        }\\n      \\n      for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==0)\\n                {\\n                    set<int> temp;\\n                    if(i-1>=0)\\n                       temp.insert(grid[i-1][j]);\\n                    if(i+1<n)\\n                       temp.insert(grid[i+1][j]);\\n                    if(j-1>=0)\\n                       temp.insert(grid[i][j-1]);\\n                    if(j+1<n)\\n                       temp.insert(grid[i][j+1]);\\n                    int z=0;\\n                    for(auto it:temp)\\n                        z+=mp[it];\\n                    res=max(res,z+1);\\n                    }\\n                    else\\n                    {\\n                        continue;\\n                    }\\n                }\\n            }\\n            //cout<<endl;\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int col=2;  //color of island\\n    int dir[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\\n    \\n    \\n    int dfs(vector<vector<int>>& grid,int i,int j,vector<vector<int>> &vis,vector<pair<int,int>>& c,int col)\\n    {\\n        if(i<0 || i>=grid.size() || j<0 || j>=grid[0].size() ||grid[i][j]==0||vis[i][j]!=-1)\\n            return 0;\\n        \\n        vis[i][j]=1;\\n        grid[i][j]=col;\\n        c.push_back(make_pair(i,j));\\n        return (1+dfs(grid,i+1,j,vis,c,col)+dfs(grid,i,j-1,vis,c,col)+dfs(grid,i,j+1,vis,c,col)+dfs(grid,i-1,j,vis,c,col));\\n    }\\n    \\n    int largestIsland(vector<vector<int>>& grid) \\n    {\\n        int n=grid.size();\\n        vector<vector<int>> vis(n,vector<int>(n,-1));\\n        int res=1;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==1 && vis[i][j]==-1)\\n                {\\n                    vector<pair<int,int>> c;\\n                    int ans=dfs(grid,i,j,vis,c,col);\\n                    res=max(res,ans);  \\n                    mp[col]=ans;\\n                    col++;\\n                }\\n            }\\n        }\\n      \\n      for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==0)\\n                {\\n                    set<int> temp;\\n                    if(i-1>=0)\\n                       temp.insert(grid[i-1][j]);\\n                    if(i+1<n)\\n                       temp.insert(grid[i+1][j]);\\n                    if(j-1>=0)\\n                       temp.insert(grid[i][j-1]);\\n                    if(j+1<n)\\n                       temp.insert(grid[i][j+1]);\\n                    int z=0;\\n                    for(auto it:temp)\\n                        z+=mp[it];\\n                    res=max(res,z+1);\\n                    }\\n                    else\\n                    {\\n                        continue;\\n                    }\\n                }\\n            }\\n            //cout<<endl;\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2359801,
                "title": "c-dfs-unordered-map",
                "content": "```\\nclass Solution {\\n    int solve(int i,int j,int n,int m,vector<vector<int>>& grid, int id){\\n        \\n        if(i<0 || i>=n || j<0 || j>=m || grid[i][j] != 1)\\n            return 0;\\n        \\n        grid[i][j] = id;\\n        int ans = 1;\\n        ans += solve(i+1,j,n,m,grid, id);\\n        ans += solve(i,j+1,n,m,grid, id);\\n        ans += solve(i-1,j,n,m,grid, id);\\n        ans += solve(i,j-1,n,m,grid, id);\\n        return ans;\\n    }\\npublic:\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        int id = 2;\\n        unordered_map<int, int>mp;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j] == 1){\\n                    int area = solve(i,j,n,m,grid, id);\\n                    ans = max(ans, area);\\n                    mp[id++] = area;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j] == 0){\\n                    set<int>st;\\n                    if(i+1 < n && grid[i+1][j] != 0) {\\n                        st.insert(grid[i+1][j]);\\n                    }\\n                    if(i-1 >= 0 && grid[i-1][j] != 0) {\\n                        st.insert(grid[i-1][j]);\\n                    }\\n                    if(j+1 < m && grid[i][j+1] != 0) {\\n                        st.insert(grid[i][j+1]);\\n                    }\\n                    if(j-1 >= 0 && grid[i][j-1] != 0) {\\n                        st.insert(grid[i][j-1]);\\n                    }\\n                    int area = 1;\\n                    for(auto it : st) {\\n                        area+=mp[it];\\n                    }\\n                    ans = max(area, ans);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int solve(int i,int j,int n,int m,vector<vector<int>>& grid, int id){\\n        \\n        if(i<0 || i>=n || j<0 || j>=m || grid[i][j] != 1)\\n            return 0;\\n        \\n        grid[i][j] = id;\\n        int ans = 1;\\n        ans += solve(i+1,j,n,m,grid, id);\\n        ans += solve(i,j+1,n,m,grid, id);\\n        ans += solve(i-1,j,n,m,grid, id);\\n        ans += solve(i,j-1,n,m,grid, id);\\n        return ans;\\n    }\\npublic:\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        int id = 2;\\n        unordered_map<int, int>mp;\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j] == 1){\\n                    int area = solve(i,j,n,m,grid, id);\\n                    ans = max(ans, area);\\n                    mp[id++] = area;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j] == 0){\\n                    set<int>st;\\n                    if(i+1 < n && grid[i+1][j] != 0) {\\n                        st.insert(grid[i+1][j]);\\n                    }\\n                    if(i-1 >= 0 && grid[i-1][j] != 0) {\\n                        st.insert(grid[i-1][j]);\\n                    }\\n                    if(j+1 < m && grid[i][j+1] != 0) {\\n                        st.insert(grid[i][j+1]);\\n                    }\\n                    if(j-1 >= 0 && grid[i][j-1] != 0) {\\n                        st.insert(grid[i][j-1]);\\n                    }\\n                    int area = 1;\\n                    for(auto it : st) {\\n                        area+=mp[it];\\n                    }\\n                    ans = max(area, ans);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2337839,
                "title": "c-dfs",
                "content": "\\nFirst traverse the entire matrix and check the maximum possible island and then check for the possibility to merge two or more islands by changing atmost one 0.\\n\\nTo identify already visited cell, initialise all the cells that belong to a particular island with a specific **id** and then store the size of that particular id in a map.\\n\\nTraverse the entire grid again to check for any possible links between islands.\\nwhenever the value of a grid is 0, see the 4 directions for any island and then add the size of it to ans.\\nTo check that size of any island is not added multiple times, we use a hashset to store the id\\'s of visited islands.\\n\\nFinally, update the the result with maximum of result and obtained value+1.\\n+1 is added since the 0 considered will be modified to 1.\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int largestIsland(vector<vector<int>>& a) {\\n        int n=a.size();\\n        int res=0,id=2,ans=0;\\n        pair<int,int>p;\\n        unordered_map<int,int>mp;\\n        mp[0]=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(a[i][j]!=1)\\n                    continue;\\n                queue<pair<int,int>>q;\\n                a[i][j]=id;\\n                q.push({i,j});\\n                ans=0;\\n                while(!q.empty()){\\n                    p=q.front();\\n                    q.pop();\\n                    ans++;\\n                    if(p.first+1<n && a[p.first+1][p.second]==1){\\n                        a[p.first+1][p.second]=id;\\n                        q.push({p.first+1,p.second});\\n                    }\\n                    if(p.second+1<n && a[p.first][p.second+1]==1){\\n                        a[p.first][p.second+1]=id;\\n                        q.push({p.first,p.second+1});\\n                    }\\n                    if(p.first-1>=0 && a[p.first-1][p.second]==1){\\n                        a[p.first-1][p.second]=id;\\n                        q.push({p.first-1,p.second});\\n                    }\\n                    if(p.second-1>=0 && a[p.first][p.second-1]==1){\\n                        a[p.first][p.second-1]=id;\\n                        q.push({p.first,p.second-1});\\n                    }\\n                }\\n                res=max(res,ans);\\n                mp[id]=ans;\\n                id++;\\n            }\\n        }\\n        int x=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(a[i][j]==0){\\n                    x=0;\\n                    unordered_set<int>s;\\n                    if(i+1<n && a[i+1][j]!=0){\\n                        if(s.find(a[i+1][j])==s.end()){\\n                            s.insert(a[i+1][j]);\\n                            x+=mp[a[i+1][j]];\\n                        }\\n                    }\\n                    if(j+1<n && a[i][j+1]!=0)\\n                    {\\n                        if(s.find(a[i][j+1])==s.end()){\\n                            s.insert(a[i][j+1]);\\n                            x+=mp[a[i][j+1]];\\n                        }\\n                    }\\n                    if(i-1>=0 && a[i-1][j]!=0){\\n                        if(s.find(a[i-1][j])==s.end()){\\n                            s.insert(a[i-1][j]);\\n                            x+=mp[a[i-1][j]];\\n                        }\\n                    }\\n                    if(j-1>=0 && a[i][j-1]!=0)\\n                    {\\n                        if(s.find(a[i][j-1])==s.end()){\\n                            s.insert(a[i][j-1]);\\n                            x+=mp[a[i][j-1]];\\n                        }\\n                    }\\n                    res=max(res,x+1);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestIsland(vector<vector<int>>& a) {\\n        int n=a.size();\\n        int res=0,id=2,ans=0;\\n        pair<int,int>p;\\n        unordered_map<int,int>mp;\\n        mp[0]=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(a[i][j]!=1)\\n                    continue;\\n                queue<pair<int,int>>q;\\n                a[i][j]=id;\\n                q.push({i,j});\\n                ans=0;\\n                while(!q.empty()){\\n                    p=q.front();\\n                    q.pop();\\n                    ans++;\\n                    if(p.first+1<n && a[p.first+1][p.second]==1){\\n                        a[p.first+1][p.second]=id;\\n                        q.push({p.first+1,p.second});\\n                    }\\n                    if(p.second+1<n && a[p.first][p.second+1]==1){\\n                        a[p.first][p.second+1]=id;\\n                        q.push({p.first,p.second+1});\\n                    }\\n                    if(p.first-1>=0 && a[p.first-1][p.second]==1){\\n                        a[p.first-1][p.second]=id;\\n                        q.push({p.first-1,p.second});\\n                    }\\n                    if(p.second-1>=0 && a[p.first][p.second-1]==1){\\n                        a[p.first][p.second-1]=id;\\n                        q.push({p.first,p.second-1});\\n                    }\\n                }\\n                res=max(res,ans);\\n                mp[id]=ans;\\n                id++;\\n            }\\n        }\\n        int x=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(a[i][j]==0){\\n                    x=0;\\n                    unordered_set<int>s;\\n                    if(i+1<n && a[i+1][j]!=0){\\n                        if(s.find(a[i+1][j])==s.end()){\\n                            s.insert(a[i+1][j]);\\n                            x+=mp[a[i+1][j]];\\n                        }\\n                    }\\n                    if(j+1<n && a[i][j+1]!=0)\\n                    {\\n                        if(s.find(a[i][j+1])==s.end()){\\n                            s.insert(a[i][j+1]);\\n                            x+=mp[a[i][j+1]];\\n                        }\\n                    }\\n                    if(i-1>=0 && a[i-1][j]!=0){\\n                        if(s.find(a[i-1][j])==s.end()){\\n                            s.insert(a[i-1][j]);\\n                            x+=mp[a[i-1][j]];\\n                        }\\n                    }\\n                    if(j-1>=0 && a[i][j-1]!=0)\\n                    {\\n                        if(s.find(a[i][j-1])==s.end()){\\n                            s.insert(a[i][j-1]);\\n                            x+=mp[a[i][j-1]];\\n                        }\\n                    }\\n                    res=max(res,x+1);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2329205,
                "title": "python-oop-solution-with-in-line-comments-faster-than-99-3-o-n-2-new-shorter-solution-added",
                "content": "First we find the islands\\n* We choose a cell doesnt matter which but assume cell[0][0]\\n* If the value of cell is zero we skip it and choose another node and go back to the previous step. Otherwise, move on to the next step\\n* we use a recursive approach to find all cells connected to this cell. Up, down, right, or left cells of this cell are connected to it if the value of them is one. \\n* We call connected cells one island, and we use a unique identifier to distinguish them. We can use the same grid to mark the cells. However, since 1 is already reserved, our unique identifier starts from 2 and goes up\\n* We choose another cell given that the cell value is 1 (it should not be zero and not belonging to an island, any value more than 1,) and basically going back to step 1\\n\\nThen, we search among the cells with value 0, to see by filling which cell with 1 we can have the biggest possible island.\\nThis process is simple. We just go through all cells with value zero and sum up the size of the four islands in the 4 direction of that cell. \\n\\n\\n\\n```\\nclass Solution:\\n    def largestIsland(self, grid: List[List[int]]) -> int:\\n        class solver:\\n            #defining some of the parameters can be used in multiple functions\\n            def __init__(self, grid):    \\n                self.grid = grid\\n                self.dic = dict() #this dictionary contains the unique island number as key and list of members as value\\n                self.n = len(grid)\\n                self.counter = 1 #this is a unique identifier for each island\\n            \\n            #this funcion is a recursive approach to find all cells connected to cell rowi, coli\\n            #this function changes 1 to a unique identifier, self.counter, for each island\\n            def connector(self, rowi, coli):\\n                self.grid[rowi][coli] = self.counter\\n                self.dic[self.counter].append([rowi,coli])\\n                if coli>0 and grid[rowi][coli-1]==1:\\n                    self.connector(rowi, coli-1)\\n                if coli<self.n-1 and grid[rowi][coli+1]==1:\\n                    self.connector(rowi, coli+1)\\n                if rowi>0 and grid[rowi-1][coli]==1:\\n                    self.connector(rowi-1, coli)\\n                if rowi<self.n-1 and grid[rowi+1][coli]==1:\\n                    self.connector(rowi+1, coli)\\n                    \\n            #this function goes through all nodes which do not belong to an island yet but the value is still one \\n            def island_tagger(self):\\n                for rowi in range(self.n):\\n                    for coli in range(self.n):    \\n                        if self.grid[rowi][coli]==1:\\n                            self.counter+=1\\n                            self.dic[self.counter] = []\\n                            self.connector(rowi, coli)\\n\\n            #this function sums the total number of memers in the 4 directions of a cel\\n            def neighbour_counter(self, row, col):\\n                total = 0\\n                grouped_list = [] #if for example the cell on the left and the cell on right belongs to the same island, we do not want to count them twice so we check that using this list\\n                if row!=0:\\n                    if grid[row-1][col]!=0:\\n                        total+=len(self.dic[grid[row-1][col]])\\n                        grouped_list.append(grid[row-1][col])\\n                if row!=self.n-1:\\n                    if grid[row+1][col]!=0 and grid[row+1][col] not in grouped_list:\\n                        print(grid[row+1][col])\\n                        total+=len(self.dic[grid[row+1][col]])   \\n                        grouped_list.append(grid[row+1][col])\\n                if col!=0:\\n                    if grid[row][col-1]!=0 and grid[row][col-1] not in grouped_list:                    \\n                        total+=len(self.dic[grid[row][col-1]])\\n                        grouped_list.append(grid[row][col-1])\\n                if col!=self.n-1:\\n                    if grid[row][col+1]!=0 and grid[row][col+1] not in grouped_list:                    \\n                        total+=len(self.dic[grid[row][col+1]])           \\n                        grouped_list.append(grid[row-1][col+1])\\n                return total\\n\\n            #we go through all the cells are zero to find the one giving us the maximum\\n            def find_best_point(self):\\n                max_total = [(None,None), 0] #we could have just saved the number without (row, col) but it improves the debugging speed\\n                for rowi in range(self.n):\\n                    for coli in range(self.n):\\n                        if grid[rowi][coli]==0:\\n                            total = self.neighbour_counter(rowi, coli)+1\\n                            if total>max_total[1]:\\n                                max_total[1] = total\\n                                max_total[0] = (rowi,coli)\\n                if max_total[0][0] is None: #if no there is no cell with zero value, the biggest island is equal to the whole map\\n                    return [(None,None), s.n*s.n]\\n                return max_total                    \\n        s = solver(grid)\\n        s.island_tagger() \\n        return s.find_best_point()[1] \\n```\\n\\n![image](https://assets.leetcode.com/users/images/e8290f69-c4be-41d0-ae6c-94f8b6dddffd_1658706271.1702182.png)\\n\\n\\nThe exact same solution but more compacted by using more for loops:\\n```\\n#island_tagger\\n#dic: size of each island\\n#going through all zero cells and and count the size of their neighbours\\n\\nclass Solution:\\n    def largestIsland(self, grid: List[List[int]]) -> int:\\n        class solver:\\n            #defining some of the parameters can be used in multiple functions\\n            def __init__(self, grid):    \\n                self.grid = grid\\n                self.dic = dict() #this dictionary contains the unique island number as key and list of members as value\\n                self.n = len(grid)\\n                self.counter = 1 #this is a unique identifier for each island\\n            \\n            #this funcion is a recursive approach to find all cells connected to cell rowi, coli\\n            #this function changes 1 to a unique identifier, self.counter, for each island\\n            def connector(self, row, col):\\n                self.grid[row][col] = self.counter\\n                self.dic[self.counter].append([row,col])\\n                for rowi,coli in [(row-1,col), (row+1,col), (row,col-1), (row,col+1)]:\\n                    if -1<rowi<self.n and -1<coli<self.n and grid[rowi][coli]==1:    \\n                            self.connector(rowi, coli)\\n                    \\n            #this function goes through all nodes which do not belong to an island yet but the value is still one \\n            def island_tagger(self):\\n                for rowi in range(self.n):\\n                    for coli in range(self.n):    \\n                        if self.grid[rowi][coli]==1:\\n                            self.counter+=1\\n                            self.dic[self.counter] = []\\n                            self.connector(rowi, coli)\\n\\n            #this function sums the total number of memers in the 4 directions of a cel\\n            def neighbour_counter(self, row, col):\\n                total = 0\\n                grouped_list = [] #if for example the cell on the left and the cell on right belongs to the same island, we do not want to count them twice so we check that using this list\\n                for rowi,coli in [(row-1,col), (row+1,col), (row,col-1), (row,col+1)]:\\n                    if -1<rowi<self.n and -1<coli<self.n and grid[rowi][coli]!=0 and grid[rowi][coli] not in grouped_list:\\n                            total+=len(self.dic[grid[rowi][coli]])\\n                            grouped_list.append(grid[rowi][coli])\\n                return total\\n\\n            #we go through all the cells are zero to find the one giving us the maximum\\n            def find_best_point(self):\\n                max_total = [(None,None), 0] #we could have just saved the number without (row, col) but it improves the debugging speed\\n                for rowi in range(self.n):\\n                    for coli in range(self.n):\\n                        if grid[rowi][coli]==0:\\n                            total = self.neighbour_counter(rowi, coli)+1\\n                            if total>max_total[1]:\\n                                max_total[1] = total\\n                                max_total[0] = (rowi,coli)\\n                if max_total[0][0] is None: #if no there is no cell with zero value, the biggest island is equal to the whole map\\n                    return [(None,None), s.n*s.n]\\n                return max_total                    \\n        s = solver(grid)\\n        s.island_tagger() \\n        return s.find_best_point()[1] \\n                            \\n        \\n```\\n\\n\\n\\n\\n\\n\\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\nNew shorter solution\\n```\\nclass Solution:\\n    def largestIsland(self, grid: List[List[int]]) -> int:\\n        row_n = len(grid)\\n        col_n = len(grid[0])\\n\\n        #this is a dfs search conting the number of connected components in each island \\n        def dfs(row, col):\\n            nonlocal counter\\n            grid[row][col]=name\\n            counter+=1\\n            print([row, col], counter)\\n            for row_i, col_i in [[0,1],[1,0],[0,-1],[-1,0]]:\\n                if -1<row_i+row<row_n and -1<col_i+col<col_n and grid[row_i+row][col_i+col]==1:\\n                    dfs(row_i+row, col_i+col)\\n\\n        #a for loop that makes sure we covered all islands and their sizes\\n        islands = dict()\\n        counter_max=0\\n        name=1   \\n        for row in range(row_n):\\n            for col in range(col_n):\\n                if grid[row][col]==1:\\n                    counter=0\\n                    name+=1\\n                    dfs(row, col)\\n                    islands[name]=counter\\n                    counter_max=max(counter_max, counter)\\n                        \\n        #now, we investigate connecting which two or more (maximum 4) islands gives us maximum sizes\\n        #connecting occurs when we convert a cell of zero value to one\\n        for row in range(row_n):\\n            for col in range(col_n):\\n                if grid[row][col]==0:\\n                    counter=1\\n                    soundings = set()\\n                    for row_i, col_i in [[0,1],[1,0],[0,-1],[-1,0]]:\\n                        if -1<row_i+row<row_n and -1<col_i+col<col_n:\\n                            if islands.get(grid[row_i+row][col_i+col]):\\n                                soundings.add(grid[row_i+row][col_i+col]) #we keep it as a set to avoid double counting \\n                    for i in soundings:\\n                        counter+=islands[i]\\n                    counter_max=max(counter_max, counter)\\n                \\n        return counter_max\\n```\\n\\nPlease consider clicking on \"upvote\" botton if you found this solution useful. \\nThank you",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def largestIsland(self, grid: List[List[int]]) -> int:\\n        class solver:\\n            #defining some of the parameters can be used in multiple functions\\n            def __init__(self, grid):    \\n                self.grid = grid\\n                self.dic = dict() #this dictionary contains the unique island number as key and list of members as value\\n                self.n = len(grid)\\n                self.counter = 1 #this is a unique identifier for each island\\n            \\n            #this funcion is a recursive approach to find all cells connected to cell rowi, coli\\n            #this function changes 1 to a unique identifier, self.counter, for each island\\n            def connector(self, rowi, coli):\\n                self.grid[rowi][coli] = self.counter\\n                self.dic[self.counter].append([rowi,coli])\\n                if coli>0 and grid[rowi][coli-1]==1:\\n                    self.connector(rowi, coli-1)\\n                if coli<self.n-1 and grid[rowi][coli+1]==1:\\n                    self.connector(rowi, coli+1)\\n                if rowi>0 and grid[rowi-1][coli]==1:\\n                    self.connector(rowi-1, coli)\\n                if rowi<self.n-1 and grid[rowi+1][coli]==1:\\n                    self.connector(rowi+1, coli)\\n                    \\n            #this function goes through all nodes which do not belong to an island yet but the value is still one \\n            def island_tagger(self):\\n                for rowi in range(self.n):\\n                    for coli in range(self.n):    \\n                        if self.grid[rowi][coli]==1:\\n                            self.counter+=1\\n                            self.dic[self.counter] = []\\n                            self.connector(rowi, coli)\\n\\n            #this function sums the total number of memers in the 4 directions of a cel\\n            def neighbour_counter(self, row, col):\\n                total = 0\\n                grouped_list = [] #if for example the cell on the left and the cell on right belongs to the same island, we do not want to count them twice so we check that using this list\\n                if row!=0:\\n                    if grid[row-1][col]!=0:\\n                        total+=len(self.dic[grid[row-1][col]])\\n                        grouped_list.append(grid[row-1][col])\\n                if row!=self.n-1:\\n                    if grid[row+1][col]!=0 and grid[row+1][col] not in grouped_list:\\n                        print(grid[row+1][col])\\n                        total+=len(self.dic[grid[row+1][col]])   \\n                        grouped_list.append(grid[row+1][col])\\n                if col!=0:\\n                    if grid[row][col-1]!=0 and grid[row][col-1] not in grouped_list:                    \\n                        total+=len(self.dic[grid[row][col-1]])\\n                        grouped_list.append(grid[row][col-1])\\n                if col!=self.n-1:\\n                    if grid[row][col+1]!=0 and grid[row][col+1] not in grouped_list:                    \\n                        total+=len(self.dic[grid[row][col+1]])           \\n                        grouped_list.append(grid[row-1][col+1])\\n                return total\\n\\n            #we go through all the cells are zero to find the one giving us the maximum\\n            def find_best_point(self):\\n                max_total = [(None,None), 0] #we could have just saved the number without (row, col) but it improves the debugging speed\\n                for rowi in range(self.n):\\n                    for coli in range(self.n):\\n                        if grid[rowi][coli]==0:\\n                            total = self.neighbour_counter(rowi, coli)+1\\n                            if total>max_total[1]:\\n                                max_total[1] = total\\n                                max_total[0] = (rowi,coli)\\n                if max_total[0][0] is None: #if no there is no cell with zero value, the biggest island is equal to the whole map\\n                    return [(None,None), s.n*s.n]\\n                return max_total                    \\n        s = solver(grid)\\n        s.island_tagger() \\n        return s.find_best_point()[1] \\n```\n```\\n#island_tagger\\n#dic: size of each island\\n#going through all zero cells and and count the size of their neighbours\\n\\nclass Solution:\\n    def largestIsland(self, grid: List[List[int]]) -> int:\\n        class solver:\\n            #defining some of the parameters can be used in multiple functions\\n            def __init__(self, grid):    \\n                self.grid = grid\\n                self.dic = dict() #this dictionary contains the unique island number as key and list of members as value\\n                self.n = len(grid)\\n                self.counter = 1 #this is a unique identifier for each island\\n            \\n            #this funcion is a recursive approach to find all cells connected to cell rowi, coli\\n            #this function changes 1 to a unique identifier, self.counter, for each island\\n            def connector(self, row, col):\\n                self.grid[row][col] = self.counter\\n                self.dic[self.counter].append([row,col])\\n                for rowi,coli in [(row-1,col), (row+1,col), (row,col-1), (row,col+1)]:\\n                    if -1<rowi<self.n and -1<coli<self.n and grid[rowi][coli]==1:    \\n                            self.connector(rowi, coli)\\n                    \\n            #this function goes through all nodes which do not belong to an island yet but the value is still one \\n            def island_tagger(self):\\n                for rowi in range(self.n):\\n                    for coli in range(self.n):    \\n                        if self.grid[rowi][coli]==1:\\n                            self.counter+=1\\n                            self.dic[self.counter] = []\\n                            self.connector(rowi, coli)\\n\\n            #this function sums the total number of memers in the 4 directions of a cel\\n            def neighbour_counter(self, row, col):\\n                total = 0\\n                grouped_list = [] #if for example the cell on the left and the cell on right belongs to the same island, we do not want to count them twice so we check that using this list\\n                for rowi,coli in [(row-1,col), (row+1,col), (row,col-1), (row,col+1)]:\\n                    if -1<rowi<self.n and -1<coli<self.n and grid[rowi][coli]!=0 and grid[rowi][coli] not in grouped_list:\\n                            total+=len(self.dic[grid[rowi][coli]])\\n                            grouped_list.append(grid[rowi][coli])\\n                return total\\n\\n            #we go through all the cells are zero to find the one giving us the maximum\\n            def find_best_point(self):\\n                max_total = [(None,None), 0] #we could have just saved the number without (row, col) but it improves the debugging speed\\n                for rowi in range(self.n):\\n                    for coli in range(self.n):\\n                        if grid[rowi][coli]==0:\\n                            total = self.neighbour_counter(rowi, coli)+1\\n                            if total>max_total[1]:\\n                                max_total[1] = total\\n                                max_total[0] = (rowi,coli)\\n                if max_total[0][0] is None: #if no there is no cell with zero value, the biggest island is equal to the whole map\\n                    return [(None,None), s.n*s.n]\\n                return max_total                    \\n        s = solver(grid)\\n        s.island_tagger() \\n        return s.find_best_point()[1] \\n                            \\n        \\n```\n```\\nclass Solution:\\n    def largestIsland(self, grid: List[List[int]]) -> int:\\n        row_n = len(grid)\\n        col_n = len(grid[0])\\n\\n        #this is a dfs search conting the number of connected components in each island \\n        def dfs(row, col):\\n            nonlocal counter\\n            grid[row][col]=name\\n            counter+=1\\n            print([row, col], counter)\\n            for row_i, col_i in [[0,1],[1,0],[0,-1],[-1,0]]:\\n                if -1<row_i+row<row_n and -1<col_i+col<col_n and grid[row_i+row][col_i+col]==1:\\n                    dfs(row_i+row, col_i+col)\\n\\n        #a for loop that makes sure we covered all islands and their sizes\\n        islands = dict()\\n        counter_max=0\\n        name=1   \\n        for row in range(row_n):\\n            for col in range(col_n):\\n                if grid[row][col]==1:\\n                    counter=0\\n                    name+=1\\n                    dfs(row, col)\\n                    islands[name]=counter\\n                    counter_max=max(counter_max, counter)\\n                        \\n        #now, we investigate connecting which two or more (maximum 4) islands gives us maximum sizes\\n        #connecting occurs when we convert a cell of zero value to one\\n        for row in range(row_n):\\n            for col in range(col_n):\\n                if grid[row][col]==0:\\n                    counter=1\\n                    soundings = set()\\n                    for row_i, col_i in [[0,1],[1,0],[0,-1],[-1,0]]:\\n                        if -1<row_i+row<row_n and -1<col_i+col<col_n:\\n                            if islands.get(grid[row_i+row][col_i+col]):\\n                                soundings.add(grid[row_i+row][col_i+col]) #we keep it as a set to avoid double counting \\n                    for i in soundings:\\n                        counter+=islands[i]\\n                    counter_max=max(counter_max, counter)\\n                \\n        return counter_max\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2312261,
                "title": "java-dfs-o-n-m-time-space",
                "content": "```\\nclass Solution {\\n    private final int[][] dirs = {{-1, 0}, {0, -1}, {0, 1}, {1, 0}};\\n    \\n    public int largestIsland(int[][] grid) {\\n        if (grid == null || grid.length == 0) {\\n            return 0;\\n        }\\n        int max = 0;\\n        int islandId = 2;\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1) {\\n                    int size = getIslandSize(grid, i, j, islandId);\\n                    max = Math.max(max, size);\\n                    map.put(islandId++, size);\\n                }\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 0) {\\n                    Set<Integer> set = new HashSet<>();\\n                    for (int[] dir : dirs) {\\n                        int x = i + dir[0];\\n                        int y = j + dir[1];\\n                        if (x >= 0 && y >= 0 && x < n && y < m && grid[x][y] != 0) {\\n                            set.add(grid[x][y]);\\n                        }\\n                    }\\n                    int sum = 1;\\n                    for (int id : set) {\\n                        sum += map.get(id);\\n                    }\\n                    max = Math.max(max, sum);\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n    \\n    private int getIslandSize(int[][] grid, int i, int j, int islandId) {\\n        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] != 1) {\\n            return 0;\\n        }\\n        grid[i][j] = islandId;\\n        int left = getIslandSize(grid, i, j - 1, islandId);\\n        int up = getIslandSize(grid, i - 1, j, islandId);\\n        int down = getIslandSize(grid, i + 1, j, islandId);\\n        int right = getIslandSize(grid, i, j + 1, islandId);\\n        return left + right + down + up + 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private final int[][] dirs = {{-1, 0}, {0, -1}, {0, 1}, {1, 0}};\\n    \\n    public int largestIsland(int[][] grid) {\\n        if (grid == null || grid.length == 0) {\\n            return 0;\\n        }\\n        int max = 0;\\n        int islandId = 2;\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 1) {\\n                    int size = getIslandSize(grid, i, j, islandId);\\n                    max = Math.max(max, size);\\n                    map.put(islandId++, size);\\n                }\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid[i][j] == 0) {\\n                    Set<Integer> set = new HashSet<>();\\n                    for (int[] dir : dirs) {\\n                        int x = i + dir[0];\\n                        int y = j + dir[1];\\n                        if (x >= 0 && y >= 0 && x < n && y < m && grid[x][y] != 0) {\\n                            set.add(grid[x][y]);\\n                        }\\n                    }\\n                    int sum = 1;\\n                    for (int id : set) {\\n                        sum += map.get(id);\\n                    }\\n                    max = Math.max(max, sum);\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n    \\n    private int getIslandSize(int[][] grid, int i, int j, int islandId) {\\n        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] != 1) {\\n            return 0;\\n        }\\n        grid[i][j] = islandId;\\n        int left = getIslandSize(grid, i, j - 1, islandId);\\n        int up = getIslandSize(grid, i - 1, j, islandId);\\n        int down = getIslandSize(grid, i + 1, j, islandId);\\n        int right = getIslandSize(grid, i, j + 1, islandId);\\n        return left + right + down + up + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2221551,
                "title": "c-beat-100-using-union-find-o-n-2",
                "content": "#### **General Approch :**\\nIn such questions (no. of island,max area island,large island....) we basically need the components of graph and ans can be calculated easily with properties of components , use union-find and for every 1 check is there a 1 to down or right , is there then make that edge i.e union, after that use a map to count every unique parent (a unique component) and its freq(the no. of vertexes in that component).\\n\\nthen just check for every 0 its top ,left,down,right and if there any adjacent components add thier area(freq), then just take max of that for every 0.\\n\\n```\\n#pragma GCC optimize(\"Ofast\")\\nclass Solution {\\npublic:\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int n = grid.size(),v=n*n,nodenum,ulp;\\n        \\n        int * parent =new int[v];\\n        int *rank = new int[v];\\n        \\n        for(int i=0;i<v;i++){\\n        parent[i]=i;\\n        rank[i]=0;}\\n        \\n\\t\\t// now for every edge call union\\n\\t\\t\\n        for(int i=0;i<n;i++)\\n        for(int j=0;j<n;j++)\\n        if(grid[i][j]){\\n        nodenum = i*n+j;\\n        \\n        if((j+1)<n && grid[i][j+1])\\n        union_rank(nodenum,nodenum+1,parent,rank);\\n            \\n        if((i+1)<n && grid[i+1][j])\\n        union_rank(nodenum,nodenum+n,parent,rank);\\n            \\n        }\\n        \\n        delete []rank;\\n        \\n        unordered_map<int,int> map;         //final parent to area mapping\\n        \\n       for(int i=0;i<n;i++)\\n        for(int j=0;j<n;j++)\\n        if(grid[i][j]){\\n          nodenum = i*n+j;\\n          ulp = findp(nodenum,parent);\\n          map[ulp]+=1;\\n        }\\n        \\n        int ans=INT_MIN,temp,p;\\n\\t\\t\\n\\t//IMPORTANT.     // to check in each iteration that this component area has already counted\\n\\t\\tset<int> minimap;   \\n        \\n        for(int i=0;i<n;i++)\\n        for(int j=0;j<n;j++)\\n        if(!grid[i][j]){\\n        minimap.clear();\\n        nodenum = i*n+j;\\n        temp=1;\\n            \\n            //TOP\\n            if(i>0 && grid[i-1][j]){\\n            p = parent[nodenum-n];\\n            minimap.insert(p);\\n            temp+=map[p];}\\n            \\n            //DOWN\\n            \\n            if(i<(n-1) && grid[i+1][j]){\\n            p = parent[nodenum+n];\\n            \\n            if(minimap.find(p)==minimap.end()){\\n            temp+=map[p];\\n            minimap.insert(p);}\\n        }\\n            //RIGHT\\n            \\n            if(j<(n-1) && grid[i][j+1]){\\n            p = parent[nodenum+1];\\n            \\n            if(minimap.find(p)==minimap.end()){\\n            temp+=map[p];\\n            minimap.insert(p);}\\n            }     \\n            ////LEFT\\n            \\n            if(j>0 && grid[i][j-1]){\\n            p = parent[nodenum-1];\\n            \\n            if(minimap.find(p)==minimap.end()){\\n            temp+=map[p];\\n            minimap.insert(p);}\\n            }\\n            \\n            if(ans<temp)\\n            ans = temp;\\n            \\n        }\\n        \\n        \\n        ans = (ans==INT_MIN)?v:ans;\\n        return(ans);\\n    }\\n    int findp(int v,int* parent){\\n        if(v == parent[v])\\n        return(v);\\n        \\n        return(parent[v]=findp(parent[v],parent));\\n    }\\n    \\n    void union_rank(int u,int v,int* parent,int* rank){\\n        u= findp(u,parent);\\n        v = findp(v,parent);\\n        \\n        if(rank[u]>rank[v])\\n        parent[v]=u;\\n        \\n        else if(rank[u]<rank[v])\\n        parent[u]=v;\\n        \\n        else{\\n        parent[v]=u;\\n        rank[u]+=1;\\n        }\\n        \\n        return;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\n#pragma GCC optimize(\"Ofast\")\\nclass Solution {\\npublic:\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int n = grid.size(),v=n*n,nodenum,ulp;\\n        \\n        int * parent =new int[v];\\n        int *rank = new int[v];\\n        \\n        for(int i=0;i<v;i++){\\n        parent[i]=i;\\n        rank[i]=0;}\\n        \\n\\t\\t// now for every edge call union\\n\\t\\t\\n        for(int i=0;i<n;i++)\\n        for(int j=0;j<n;j++)\\n        if(grid[i][j]){\\n        nodenum = i*n+j;\\n        \\n        if((j+1)<n && grid[i][j+1])\\n        union_rank(nodenum,nodenum+1,parent,rank);\\n            \\n        if((i+1)<n && grid[i+1][j])\\n        union_rank(nodenum,nodenum+n,parent,rank);\\n            \\n        }\\n        \\n        delete []rank;\\n        \\n        unordered_map<int,int> map;         //final parent to area mapping\\n        \\n       for(int i=0;i<n;i++)\\n        for(int j=0;j<n;j++)\\n        if(grid[i][j]){\\n          nodenum = i*n+j;\\n          ulp = findp(nodenum,parent);\\n          map[ulp]+=1;\\n        }\\n        \\n        int ans=INT_MIN,temp,p;\\n\\t\\t\\n\\t//IMPORTANT.     // to check in each iteration that this component area has already counted\\n\\t\\tset<int> minimap;   \\n        \\n        for(int i=0;i<n;i++)\\n        for(int j=0;j<n;j++)\\n        if(!grid[i][j]){\\n        minimap.clear();\\n        nodenum = i*n+j;\\n        temp=1;\\n            \\n            //TOP\\n            if(i>0 && grid[i-1][j]){\\n            p = parent[nodenum-n];\\n            minimap.insert(p);\\n            temp+=map[p];}\\n            \\n            //DOWN\\n            \\n            if(i<(n-1) && grid[i+1][j]){\\n            p = parent[nodenum+n];\\n            \\n            if(minimap.find(p)==minimap.end()){\\n            temp+=map[p];\\n            minimap.insert(p);}\\n        }\\n            //RIGHT\\n            \\n            if(j<(n-1) && grid[i][j+1]){\\n            p = parent[nodenum+1];\\n            \\n            if(minimap.find(p)==minimap.end()){\\n            temp+=map[p];\\n            minimap.insert(p);}\\n            }     \\n            ////LEFT\\n            \\n            if(j>0 && grid[i][j-1]){\\n            p = parent[nodenum-1];\\n            \\n            if(minimap.find(p)==minimap.end()){\\n            temp+=map[p];\\n            minimap.insert(p);}\\n            }\\n            \\n            if(ans<temp)\\n            ans = temp;\\n            \\n        }\\n        \\n        \\n        ans = (ans==INT_MIN)?v:ans;\\n        return(ans);\\n    }\\n    int findp(int v,int* parent){\\n        if(v == parent[v])\\n        return(v);\\n        \\n        return(parent[v]=findp(parent[v],parent));\\n    }\\n    \\n    void union_rank(int u,int v,int* parent,int* rank){\\n        u= findp(u,parent);\\n        v = findp(v,parent);\\n        \\n        if(rank[u]>rank[v])\\n        parent[v]=u;\\n        \\n        else if(rank[u]<rank[v])\\n        parent[u]=v;\\n        \\n        else{\\n        parent[v]=u;\\n        rank[u]+=1;\\n        }\\n        \\n        return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2197359,
                "title": "c-bfs-with-counting-number-of-lands-in-islands",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> DIR = {1, 0, -1, 0, 1};\\n    unordered_map<int, int> hash;\\n    int n, color = 2;\\n    int largestIsland(vector<vector<int>>& g) {\\n        n = g.size();\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < n; j++)\\n                if(g[i][j] == 1){\\n                    hash[color] = helper(g, i, j);\\n                    color++;\\n                }\\n        int result = -1;\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < n; j++)\\n                if(!g[i][j])\\n                    result = max(result, check(g, i, j));\\n        return result == -1 ? n * n : result + 1;\\n    }\\n    int check(vector<vector<int>>& g, int i, int j){\\n        unordered_set<int> set;\\n        for(int k = 0; k < 4; k++){\\n            int nr = i + DIR[k], nc = j + DIR[k + 1];\\n            if(nr < 0 || nc < 0 || nr == n || nc == n || !g[nr][nc])\\n                continue;\\n            set.insert(g[nr][nc]);\\n        }\\n        int count = 0;\\n        for(auto& a: set)\\n            count += hash[a];\\n        return count;\\n    }\\n    int helper(vector<vector<int>>& g, int i, int j){\\n        if(i < 0 || j < 0 || i == n || j == n || g[i][j] != 1)\\n            return 0;\\n        g[i][j] = color;\\n        int sum = 1;\\n        for(int k = 0; k < 4; k++)\\n            sum += helper(g, i + DIR[k], j + DIR[k + 1]);\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> DIR = {1, 0, -1, 0, 1};\\n    unordered_map<int, int> hash;\\n    int n, color = 2;\\n    int largestIsland(vector<vector<int>>& g) {\\n        n = g.size();\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < n; j++)\\n                if(g[i][j] == 1){\\n                    hash[color] = helper(g, i, j);\\n                    color++;\\n                }\\n        int result = -1;\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < n; j++)\\n                if(!g[i][j])\\n                    result = max(result, check(g, i, j));\\n        return result == -1 ? n * n : result + 1;\\n    }\\n    int check(vector<vector<int>>& g, int i, int j){\\n        unordered_set<int> set;\\n        for(int k = 0; k < 4; k++){\\n            int nr = i + DIR[k], nc = j + DIR[k + 1];\\n            if(nr < 0 || nc < 0 || nr == n || nc == n || !g[nr][nc])\\n                continue;\\n            set.insert(g[nr][nc]);\\n        }\\n        int count = 0;\\n        for(auto& a: set)\\n            count += hash[a];\\n        return count;\\n    }\\n    int helper(vector<vector<int>>& g, int i, int j){\\n        if(i < 0 || j < 0 || i == n || j == n || g[i][j] != 1)\\n            return 0;\\n        g[i][j] = color;\\n        int sum = 1;\\n        for(int k = 0; k < 4; k++)\\n            sum += helper(g, i + DIR[k], j + DIR[k + 1]);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2164068,
                "title": "python3-union-find",
                "content": "```\\nclass Solution:\\n    \\n    def largestIsland(self, grid: List[List[int]]) -> int:\\n        \\n        \\n        # Union Find Functions\\n        n = len(grid)\\n        parent = [i for i in range(0, n*n)]\\n        size = [1 for i in range(0, n*n)]\\n        def union(x,y):\\n            x_ref = find(x)\\n            y_ref = find(y)\\n            if x_ref != y_ref:\\n                parent[y_ref] = x_ref\\n                size[x_ref] += size[y_ref]\\n        \\n        def find(x):\\n            if x==parent[x]:\\n                return x\\n            parent[x] = find(parent[x])\\n            return parent[x]\\n        \\n        containsOne = False\\n        dirs = [[0,1],[1,0],[0,-1],[-1,0]]\\n        \\n        # Create islands using 1 Union\\n        for i in range(0, len(grid)):\\n            for j in range(0, len(grid)):\\n                if grid[i][j] == 0:\\n                    continue\\n                containsOne = True\\n                for d in dirs:\\n                    r = i + d[0]\\n                    c = j + d[1]\\n                    if r>=0 and c>=0 and r<n and c<n and grid[r][c] == 1:\\n                        union(i*n+j, r*n+c)\\n        \\n        # if all zero, return 1 (we can change one zero to one)\\n        if not containsOne:\\n            return 1\\n        \\n        max_island = max(size)\\n        # We can change one zero to one. Merging island in that case\\n        for i in range(0, n):\\n            for j in range(0, n):\\n                if grid[i][j] == 0:\\n                    visit = set()\\n                    island = 0\\n                    for d in dirs:\\n                        r = i + d[0]\\n                        c = j + d[1]\\n                        if r>=0 and c>=0 and r<n and c<n and grid[r][c] == 1:\\n                            par_ref = find(r*n+c)\\n                            if par_ref not in visit:\\n                                island += size[par_ref]\\n                                visit.add(par_ref)\\n                    \\n                    max_island = max(island+1, max_island)\\n        \\n        return max_island\\n                            \\n\\n\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def largestIsland(self, grid: List[List[int]]) -> int:\\n        \\n        \\n        # Union Find Functions\\n        n = len(grid)\\n        parent = [i for i in range(0, n*n)]\\n        size = [1 for i in range(0, n*n)]\\n        def union(x,y):\\n            x_ref = find(x)\\n            y_ref = find(y)\\n            if x_ref != y_ref:\\n                parent[y_ref] = x_ref\\n                size[x_ref] += size[y_ref]\\n        \\n        def find(x):\\n            if x==parent[x]:\\n                return x\\n            parent[x] = find(parent[x])\\n            return parent[x]\\n        \\n        containsOne = False\\n        dirs = [[0,1],[1,0],[0,-1],[-1,0]]\\n        \\n        # Create islands using 1 Union\\n        for i in range(0, len(grid)):\\n            for j in range(0, len(grid)):\\n                if grid[i][j] == 0:\\n                    continue\\n                containsOne = True\\n                for d in dirs:\\n                    r = i + d[0]\\n                    c = j + d[1]\\n                    if r>=0 and c>=0 and r<n and c<n and grid[r][c] == 1:\\n                        union(i*n+j, r*n+c)\\n        \\n        # if all zero, return 1 (we can change one zero to one)\\n        if not containsOne:\\n            return 1\\n        \\n        max_island = max(size)\\n        # We can change one zero to one. Merging island in that case\\n        for i in range(0, n):\\n            for j in range(0, n):\\n                if grid[i][j] == 0:\\n                    visit = set()\\n                    island = 0\\n                    for d in dirs:\\n                        r = i + d[0]\\n                        c = j + d[1]\\n                        if r>=0 and c>=0 and r<n and c<n and grid[r][c] == 1:\\n                            par_ref = find(r*n+c)\\n                            if par_ref not in visit:\\n                                island += size[par_ref]\\n                                visit.add(par_ref)\\n                    \\n                    max_island = max(island+1, max_island)\\n        \\n        return max_island\\n                            \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2123920,
                "title": "cpp-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    int di[4]{-1, 1, 0, 0};\\n    int dj[4]{0, 0, -1, 1};\\n    \\n    bool isVal(int i, int j, vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        return i >= 0 && i < n && j >= 0 && j < m && grid[i][j] != 0;\\n    }\\n    \\n    \\n    int markIsland(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& vis, int cpt) {\\n        int size = 0;\\n        grid[i][j] = cpt; \\n        for(int k = 0; k < 4; k++) {\\n            int ni = i + di[k];\\n            int nj = j + dj[k];\\n            if(isVal(ni, nj, grid) && vis[ni][nj] == 0) {\\n                vis[ni][nj] = 1;\\n                size += markIsland(ni, nj, grid, vis, cpt);\\n            }\\n        }\\n        return 1 + size;\\n    }\\n    \\n    set<int> getIslands(int i, int j, vector<vector<int>>& grid) {\\n        set<int> s;\\n        for(int k = 0; k < 4; k++) {\\n            int ni = i + di[k];\\n            int nj = j + dj[k];\\n            if(isVal(ni, nj, grid)) {\\n               s.insert(grid[ni][nj]);\\n            }\\n        }\\n        return s;\\n    }\\n    \\n    int largestIsland(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        \\n        vector<vector<int>>vis (n,vector<int>(m,0));\\n        unordered_map<int, int> mp;\\n    \\n        int cpt = 1;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(vis[i][j] == 0 && grid[i][j] == 1) {\\n                    vis[i][j] = 1;\\n                    int size = markIsland(i, j, grid, vis, cpt);\\n                    mp[cpt] = size;\\n                    cpt++;\\n                }\\n                \\n            }\\n        }\\n        \\n        \\n        // get count of surrounding component\\n        int ans = 0;\\n        bool flag = false;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] == 0) {\\n                    flag = true;\\n                    int area = 0; \\n                    set<int> s = getIslands(i, j, grid);\\n                    \\n                    for(auto it : s) {\\n                        int size = mp[it];\\n                        area += size;\\n                    }\\n                    \\n                    area++;\\n                    ans = max(ans, area);\\n                }\\n            }\\n        }\\n        \\n        \\n        return flag ? ans : n * m;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int di[4]{-1, 1, 0, 0};\\n    int dj[4]{0, 0, -1, 1};\\n    \\n    bool isVal(int i, int j, vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        return i >= 0 && i < n && j >= 0 && j < m && grid[i][j] != 0;\\n    }\\n    \\n    \\n    int markIsland(int i, int j, vector<vector<int>>& grid, vector<vector<int>>& vis, int cpt) {\\n        int size = 0;\\n        grid[i][j] = cpt; \\n        for(int k = 0; k < 4; k++) {\\n            int ni = i + di[k];\\n            int nj = j + dj[k];\\n            if(isVal(ni, nj, grid) && vis[ni][nj] == 0) {\\n                vis[ni][nj] = 1;\\n                size += markIsland(ni, nj, grid, vis, cpt);\\n            }\\n        }\\n        return 1 + size;\\n    }\\n    \\n    set<int> getIslands(int i, int j, vector<vector<int>>& grid) {\\n        set<int> s;\\n        for(int k = 0; k < 4; k++) {\\n            int ni = i + di[k];\\n            int nj = j + dj[k];\\n            if(isVal(ni, nj, grid)) {\\n               s.insert(grid[ni][nj]);\\n            }\\n        }\\n        return s;\\n    }\\n    \\n    int largestIsland(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        \\n        vector<vector<int>>vis (n,vector<int>(m,0));\\n        unordered_map<int, int> mp;\\n    \\n        int cpt = 1;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(vis[i][j] == 0 && grid[i][j] == 1) {\\n                    vis[i][j] = 1;\\n                    int size = markIsland(i, j, grid, vis, cpt);\\n                    mp[cpt] = size;\\n                    cpt++;\\n                }\\n                \\n            }\\n        }\\n        \\n        \\n        // get count of surrounding component\\n        int ans = 0;\\n        bool flag = false;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < m; j++) {\\n                if(grid[i][j] == 0) {\\n                    flag = true;\\n                    int area = 0; \\n                    set<int> s = getIslands(i, j, grid);\\n                    \\n                    for(auto it : s) {\\n                        int size = mp[it];\\n                        area += size;\\n                    }\\n                    \\n                    area++;\\n                    ans = max(ans, area);\\n                }\\n            }\\n        }\\n        \\n        \\n        return flag ? ans : n * m;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2089528,
                "title": "c-easy-to-understand-2-methods",
                "content": "**Component Wise Approach \\nTime Complexity O(NxN)**\\n```\\nclass Solution {\\npublic:\\n    bool isValid(int new_x,int new_y,int n)\\n    {\\n        if(new_x>=0&&new_y>=0&&new_x<n&&new_y<n)\\n            return true;\\n        \\n        return false;\\n    }\\n    int getArea(vector<vector<int>>& grid,int i,int j,int id,int n)\\n    {\\n        if(i<0||j<0||i>=n||j>=n||grid[i][j]!=1)\\n        return 0;\\n        grid[i][j]=id;\\n        return 1+getArea(grid,i+1,j,id,n)+getArea(grid,i,j-1,id,n)+getArea(grid,i,j+1,id,n)+getArea(grid,i-1,j,id,n);\\n    }\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int gridID=2;\\n        map<int,int> area;\\n        bool ok=false;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    area[gridID]=getArea(grid,i,j,gridID,n);\\n                    gridID++;\\n                    ok=true;\\n                }\\n            }\\n        }\\n        if(!ok)\\n        return 1;\\n        int ans=area[2],curr=0;\\n        vector<vector<int>> dir(4);\\n        dir={{0,1},{1,0},{-1,0},{0,-1}};\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                \\n                if(grid[i][j]==0)\\n                {\\n                    set<int> st;\\n                    curr=1;\\n                    for(auto d:dir)\\n                    {\\n                        int new_x,new_y;\\n                        new_x=i+d[0];\\n                        new_y=j+d[1];\\n                       \\n                        if(isValid(new_x,new_y,n))\\n                        {\\n                            int ID=grid[new_x][new_y];\\n                            if(st.find(ID)==st.end())\\n                            {\\n                            curr+=area[ID];\\n                            st.insert(ID);\\n                            }\\n                        }\\n                    }\\n                    ans=max(ans,curr);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Brute Force Approach Gives TLE\\nTime Complexity O(NxNxNxN)**\\n```\\nclass Solution {\\npublic:\\n\\n    int dfs(vector<vector<int>>& grid,int i,int j)\\n    {\\n        vector<vector<int>> dir(4);\\n        dir={{0,1},{1,0},{-1,0},{0,-1}};\\n        set<int> st;\\n        stack<int> s;\\n        int n;\\n        n=grid.size();\\n        s.push(i*n+j);\\n        st.insert(i*n+j);\\n        while(!s.empty())\\n        {\\n            int val=s.top();\\n            s.pop();\\n            int x=val/n;\\n            int y=val%n;\\n            for(auto v:dir)\\n            {\\n                int new_x,new_y;\\n                new_x=x+v[0];\\n                new_y=y+v[1];\\n                if(new_x>=0&&new_x<n&&new_y>=0&&new_y<n&&grid[new_x][new_y]==1&&st.find(new_x*n+new_y)==st.end())\\n                {\\n                    st.insert(new_x*n+new_y);\\n                    s.push(new_x*n+new_y);\\n                }\\n            }\\n        }\\n        return st.size();\\n    }\\n    int largestIsland(vector<vector<int>>& grid) {\\n\\n     int n=grid.size();\\n     int m=grid[0].size();\\n     int ans=INT_MIN; \\n     for(int i=0;i<n;i++)\\n     {\\n         for(int j=0;j<m;j++)\\n         {\\n             if(grid[i][j]==0)\\n             {\\n                 grid[i][j]=1;\\n                 ans=max(ans,dfs(grid,i,j));\\n                 grid[i][j]=0;\\n             }\\n         }\\n     }\\n    if(ans==INT_MIN)\\n    return n*n;\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(int new_x,int new_y,int n)\\n    {\\n        if(new_x>=0&&new_y>=0&&new_x<n&&new_y<n)\\n            return true;\\n        \\n        return false;\\n    }\\n    int getArea(vector<vector<int>>& grid,int i,int j,int id,int n)\\n    {\\n        if(i<0||j<0||i>=n||j>=n||grid[i][j]!=1)\\n        return 0;\\n        grid[i][j]=id;\\n        return 1+getArea(grid,i+1,j,id,n)+getArea(grid,i,j-1,id,n)+getArea(grid,i,j+1,id,n)+getArea(grid,i-1,j,id,n);\\n    }\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int gridID=2;\\n        map<int,int> area;\\n        bool ok=false;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    area[gridID]=getArea(grid,i,j,gridID,n);\\n                    gridID++;\\n                    ok=true;\\n                }\\n            }\\n        }\\n        if(!ok)\\n        return 1;\\n        int ans=area[2],curr=0;\\n        vector<vector<int>> dir(4);\\n        dir={{0,1},{1,0},{-1,0},{0,-1}};\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                \\n                if(grid[i][j]==0)\\n                {\\n                    set<int> st;\\n                    curr=1;\\n                    for(auto d:dir)\\n                    {\\n                        int new_x,new_y;\\n                        new_x=i+d[0];\\n                        new_y=j+d[1];\\n                       \\n                        if(isValid(new_x,new_y,n))\\n                        {\\n                            int ID=grid[new_x][new_y];\\n                            if(st.find(ID)==st.end())\\n                            {\\n                            curr+=area[ID];\\n                            st.insert(ID);\\n                            }\\n                        }\\n                    }\\n                    ans=max(ans,curr);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\n    int dfs(vector<vector<int>>& grid,int i,int j)\\n    {\\n        vector<vector<int>> dir(4);\\n        dir={{0,1},{1,0},{-1,0},{0,-1}};\\n        set<int> st;\\n        stack<int> s;\\n        int n;\\n        n=grid.size();\\n        s.push(i*n+j);\\n        st.insert(i*n+j);\\n        while(!s.empty())\\n        {\\n            int val=s.top();\\n            s.pop();\\n            int x=val/n;\\n            int y=val%n;\\n            for(auto v:dir)\\n            {\\n                int new_x,new_y;\\n                new_x=x+v[0];\\n                new_y=y+v[1];\\n                if(new_x>=0&&new_x<n&&new_y>=0&&new_y<n&&grid[new_x][new_y]==1&&st.find(new_x*n+new_y)==st.end())\\n                {\\n                    st.insert(new_x*n+new_y);\\n                    s.push(new_x*n+new_y);\\n                }\\n            }\\n        }\\n        return st.size();\\n    }\\n    int largestIsland(vector<vector<int>>& grid) {\\n\\n     int n=grid.size();\\n     int m=grid[0].size();\\n     int ans=INT_MIN; \\n     for(int i=0;i<n;i++)\\n     {\\n         for(int j=0;j<m;j++)\\n         {\\n             if(grid[i][j]==0)\\n             {\\n                 grid[i][j]=1;\\n                 ans=max(ans,dfs(grid,i,j));\\n                 grid[i][j]=0;\\n             }\\n         }\\n     }\\n    if(ans==INT_MIN)\\n    return n*n;\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2057054,
                "title": "c-dfs-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int dir[5]={1,0,-1,0,1};\\n    unordered_map<int,int> component_size;\\n    void paint(vector<vector<int>>& grid,int i,int j,int color)\\n    {\\n        if(i<0||j<0||i>=grid.size()||j>=grid[0].size()||grid[i][j]!=1)\\n            return;\\n        grid[i][j]=color;\\n        component_size[color]++;\\n        for(int k=0;k<4;k++)\\n        {\\n            paint(grid,i+dir[k],j+dir[k+1],color);\\n        }\\n    }\\n    int largestIsland(vector<vector<int>>& grid) \\n    {\\n        int m=grid.size(),n=grid[0].size();\\n        int color=2;\\n        int ans=1;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]!=1)\\n                    continue;\\n                paint(grid,i,j,color++);\\n                ans=max(ans,component_size[color-1]);\\n            }\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]!=0)\\n                    continue;\\n                unordered_set<int> s;\\n                for(int k=0;k<4;k++)\\n                {\\n                    int x=i+dir[k],y=j+dir[k+1];\\n                    if(x<0||y<0||x>=grid.size()||y>=grid[0].size()||grid[x][y]==0)\\n                        continue;\\n                    s.insert(grid[x][y]);\\n                    int temp=1;\\n                    for(auto &val:s)\\n                    {\\n                        temp+=component_size[val];\\n                    }\\n                    ans=max(ans,temp);\\n                    \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    int dir[5]={1,0,-1,0,1}",
                "codeTag": "Java"
            },
            {
                "id": 2018668,
                "title": "union-find-rank-clean-code-with-o-n-m-time-space",
                "content": "The idea here is to first create set (or component) of all adjacent ones and assign them unique id. Unique id here will be nothing but the root. So each component will have only one root (unique). Using dfs, we can create sets and also get the size of each set.  Finally, we can search for \\'0\\' and keep adding the size of 4 adjacent component. Note that we also have to make sure that the adjacent components have unique roots (other wise we may end up adding same component size again & again). \\n\\nIf you want to learn Disjoint Sets, I recommend this awesome page:\\nhttps://cp-algorithms.com/data_structures/disjoint_set_union.html\\n \\n Feel free to post any doubts :)\\n \\n```\\nclass Solution {\\nprivate:\\n    int n, m;\\n    vector<int> parent, ran;\\n    bool vis[502][502];\\n    vector<int> dx, dy;\\n    unordered_map<int, int> mp;\\n    vector<vector<int> > v;\\npublic:\\n    void makeSet(int u) {\\n        parent[u] = u;\\n        ran[u] = 0;\\n    }\\n    int findSet(int u) {\\n        if (u == parent[u]) return u;\\n        return findSet(parent[u]);\\n    }\\n    void unionSet(int u, int v) {\\n        u = findSet(u);\\n        v = findSet(v);\\n        if (v == u) return;\\n        if (ran[u] < ran[v]) swap(u, v);\\n        parent[v] = u;\\n        if (ran[u] == ran[v]) ran[u]++;\\n    }\\n    void dfs(int i, int j, int& size) {\\n        vis[i][j] = true;\\n        size++;\\n        for(int p=0;p<4;p++) {\\n            int x = i + dx[p], y = j + dy[p];\\n            if (x < 0 || x >= n || y < 0 || y >= m) continue;\\n            if (vis[x][y] || v[x][y] == 0) continue;\\n            unionSet(i * m + j, x * m + y);\\n            dfs(x, y, size);\\n        }\\n    }\\n    int largestIsland(vector<vector<int>>& V) {\\n        v = V;\\n        n = v.size();\\n        m = v[0].size();\\n        dx = {0, 1, 0, -1}; dy = {1, 0, -1, 0};\\n        memset(vis, false, sizeof vis);\\n        parent.resize(n * m + 2);\\n        ran.resize(n * m + 2);\\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<m;j++) \\n                makeSet(i * m + j);\\n        }\\n        int ans = 0;\\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<m;j++) {\\n                if (!vis[i][j] && v[i][j] == 1) {\\n                    int size = 0;\\n                    dfs(i, j, size);\\n                    ans = max(ans, size);\\n                    mp[findSet(i * m + j)] = size;\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<m;j++) {\\n                if (v[i][j] == 0) {\\n                    set<int> st; int temp = 0;\\n                    for(int p=0;p<4;p++) {\\n                        int x = i + dx[p], y = j + dy[p];\\n                        if (x >= 0 && x < n && y >= 0 && y < m && v[x][y] == 1) {\\n                            int root = findSet(x * m + y);\\n                            if (st.find(root) == st.end()) {\\n                                st.insert(root);\\n                                temp += mp[root];\\n                            }\\n                        }\\n                    }\\n                    ans = max(ans, temp + 1);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n//   0 1 2\\n// 0 1 0 1\\n// 1 1 1 0\\n// 2 0 0 1\\n\\n// m = 3\\n// i * m + j\\n\\n// i,j\\n// 0,0     0\\n// 0,1     1\\n// 0,2     2    \\n// 1,0     3\\n// 1,1     4\\n// 1,2     5\\n// 2,0     6\\n// 2,1     7\\n// 2,2     8\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int n, m;\\n    vector<int> parent, ran;\\n    bool vis[502][502];\\n    vector<int> dx, dy;\\n    unordered_map<int, int> mp;\\n    vector<vector<int> > v;\\npublic:\\n    void makeSet(int u) {\\n        parent[u] = u;\\n        ran[u] = 0;\\n    }\\n    int findSet(int u) {\\n        if (u == parent[u]) return u;\\n        return findSet(parent[u]);\\n    }\\n    void unionSet(int u, int v) {\\n        u = findSet(u);\\n        v = findSet(v);\\n        if (v == u) return;\\n        if (ran[u] < ran[v]) swap(u, v);\\n        parent[v] = u;\\n        if (ran[u] == ran[v]) ran[u]++;\\n    }\\n    void dfs(int i, int j, int& size) {\\n        vis[i][j] = true;\\n        size++;\\n        for(int p=0;p<4;p++) {\\n            int x = i + dx[p], y = j + dy[p];\\n            if (x < 0 || x >= n || y < 0 || y >= m) continue;\\n            if (vis[x][y] || v[x][y] == 0) continue;\\n            unionSet(i * m + j, x * m + y);\\n            dfs(x, y, size);\\n        }\\n    }\\n    int largestIsland(vector<vector<int>>& V) {\\n        v = V;\\n        n = v.size();\\n        m = v[0].size();\\n        dx = {0, 1, 0, -1}; dy = {1, 0, -1, 0};\\n        memset(vis, false, sizeof vis);\\n        parent.resize(n * m + 2);\\n        ran.resize(n * m + 2);\\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<m;j++) \\n                makeSet(i * m + j);\\n        }\\n        int ans = 0;\\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<m;j++) {\\n                if (!vis[i][j] && v[i][j] == 1) {\\n                    int size = 0;\\n                    dfs(i, j, size);\\n                    ans = max(ans, size);\\n                    mp[findSet(i * m + j)] = size;\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<m;j++) {\\n                if (v[i][j] == 0) {\\n                    set<int> st; int temp = 0;\\n                    for(int p=0;p<4;p++) {\\n                        int x = i + dx[p], y = j + dy[p];\\n                        if (x >= 0 && x < n && y >= 0 && y < m && v[x][y] == 1) {\\n                            int root = findSet(x * m + y);\\n                            if (st.find(root) == st.end()) {\\n                                st.insert(root);\\n                                temp += mp[root];\\n                            }\\n                        }\\n                    }\\n                    ans = max(ans, temp + 1);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n//   0 1 2\\n// 0 1 0 1\\n// 1 1 1 0\\n// 2 0 0 1\\n\\n// m = 3\\n// i * m + j\\n\\n// i,j\\n// 0,0     0\\n// 0,1     1\\n// 0,2     2    \\n// 1,0     3\\n// 1,1     4\\n// 1,2     5\\n// 2,0     6\\n// 2,1     7\\n// 2,2     8\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1954589,
                "title": "c-union-find-96-fast-86-memory-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int parent[500001] = {0};\\n    int vsize[500001] = {0};\\n    int n;\\n    \\n    bool valid(int x, int y, int n)\\n    {\\n        return (x>=0 && x<n && y>=0 && y<n);\\n    }\\n    \\n    void make(int x)\\n    {\\n        parent[x] = x;\\n        vsize[x] = 1;\\n    }\\n    \\n    int find(int x)\\n    {\\n        if(x == parent[x]) return x;\\n        return parent[x] = find(parent[x]);\\n    }\\n    \\n    void join(int a, int b)\\n    {\\n        a = find(a);\\n        b = find(b);\\n        if(a == b) return;\\n        if(vsize[a] < vsize[b]) swap(a, b);\\n        parent[b] = a;\\n        vsize[a] += vsize[b];\\n    }\\n    \\n    int largestIsland(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        int ans = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                if(grid[i][j]) make(1000*i + j);\\n            }\\n        }\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                if(grid[i][j])\\n                {\\n                    if(i && grid[i-1][j]) join(1000*i + j, 1000*(i-1) + j);\\n                    if(j && grid[i][j-1]) join(1000*i + j, 1000*i + j-1);\\n                    if(i<n-1 && grid[i+1][j]) join(1000*i + j, 1000*(i+1) + j);\\n                    if(j<n-1 && grid[i][j+1]) join(1000*i + j, 1000*i + j + 1);\\n                }\\n            }\\n        }\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                if(grid[i][j]) ans = max(ans, vsize[1000*i + j]-1);\\n                int pp = 0;\\n                if(grid[i][j] == 0)\\n                {\\n                    set<int> s;\\n                    if(valid(i+1,j,n) && grid[i+1][j]) s.insert(find(1000*(i+1) + j));\\n                    if(valid(i-1,j,n) && grid[i-1][j]) s.insert(find(1000*(i-1) + j));\\n                    if(valid(i,j-1,n) && grid[i][j-1]) s.insert(find(1000*i + j - 1));\\n                    if(valid(i,j+1,n) && grid[i][j+1]) s.insert(find(1000*i + j + 1));\\n                    for(auto qq: s) pp+=vsize[qq];\\n                }\\n                ans = max(ans, pp);\\n            }\\n        }\\n        \\n        return ans+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int parent[500001] = {0};\\n    int vsize[500001] = {0};\\n    int n;\\n    \\n    bool valid(int x, int y, int n)\\n    {\\n        return (x>=0 && x<n && y>=0 && y<n);\\n    }\\n    \\n    void make(int x)\\n    {\\n        parent[x] = x;\\n        vsize[x] = 1;\\n    }\\n    \\n    int find(int x)\\n    {\\n        if(x == parent[x]) return x;\\n        return parent[x] = find(parent[x]);\\n    }\\n    \\n    void join(int a, int b)\\n    {\\n        a = find(a);\\n        b = find(b);\\n        if(a == b) return;\\n        if(vsize[a] < vsize[b]) swap(a, b);\\n        parent[b] = a;\\n        vsize[a] += vsize[b];\\n    }\\n    \\n    int largestIsland(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        int ans = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                if(grid[i][j]) make(1000*i + j);\\n            }\\n        }\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                if(grid[i][j])\\n                {\\n                    if(i && grid[i-1][j]) join(1000*i + j, 1000*(i-1) + j);\\n                    if(j && grid[i][j-1]) join(1000*i + j, 1000*i + j-1);\\n                    if(i<n-1 && grid[i+1][j]) join(1000*i + j, 1000*(i+1) + j);\\n                    if(j<n-1 && grid[i][j+1]) join(1000*i + j, 1000*i + j + 1);\\n                }\\n            }\\n        }\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                if(grid[i][j]) ans = max(ans, vsize[1000*i + j]-1);\\n                int pp = 0;\\n                if(grid[i][j] == 0)\\n                {\\n                    set<int> s;\\n                    if(valid(i+1,j,n) && grid[i+1][j]) s.insert(find(1000*(i+1) + j));\\n                    if(valid(i-1,j,n) && grid[i-1][j]) s.insert(find(1000*(i-1) + j));\\n                    if(valid(i,j-1,n) && grid[i][j-1]) s.insert(find(1000*i + j - 1));\\n                    if(valid(i,j+1,n) && grid[i][j+1]) s.insert(find(1000*i + j + 1));\\n                    for(auto qq: s) pp+=vsize[qq];\\n                }\\n                ans = max(ans, pp);\\n            }\\n        }\\n        \\n        return ans+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1940980,
                "title": "python-dfs-beat-95",
                "content": "```\\n\\nclass Solution:\\n    def largestIsland(self, grid: List[List[int]]) -> int:\\n        if not grid or not grid[0]:\\n            return 0\\n        \\n        m = len(grid)\\n        n = len(grid[0])\\n        color_ = 2\\n        dic = defaultdict(int)\\n        dic[0] = 0\\n        \\n        def getarea(x, y):\\n            nonlocal grid, color_, m, n\\n            if x < 0 or y < 0 or x >= m or y >=n or grid[x][y] != 1:\\n                return 0\\n            grid[x][y] = color_\\n            return 1 + getarea(x - 1, y) + getarea(x + 1, y) + getarea(x, y - 1) + getarea(x, y + 1)\\n        \\n        def getcolor(x, y):\\n            nonlocal grid, m, n\\n            return 0 if (x < 0 or y < 0 or x >= m or y >= n) else grid[x][y] \\n        \\n        ans = float(\\'-inf\\')\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    tmp = getarea(i, j)\\n                    dic[color_] = tmp\\n                    ans = max(ans, tmp)\\n                    color_ += 1\\n        \\n#         print(color_, grid, dic)\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 0:\\n                    colorset = set([getcolor(i - 1, j), getcolor(i + 1, j), getcolor(i, j - 1), getcolor(i, j + 1)])\\n                    tmp = 1\\n                    for c in colorset:\\n                        tmp += dic[c]\\n                    ans = max(ans, tmp)\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\n\\nclass Solution:\\n    def largestIsland(self, grid: List[List[int]]) -> int:\\n        if not grid or not grid[0]:\\n            return 0\\n        \\n        m = len(grid)\\n        n = len(grid[0])\\n        color_ = 2\\n        dic = defaultdict(int)\\n        dic[0] = 0\\n        \\n        def getarea(x, y):\\n            nonlocal grid, color_, m, n\\n            if x < 0 or y < 0 or x >= m or y >=n or grid[x][y] != 1:\\n                return 0\\n            grid[x][y] = color_\\n            return 1 + getarea(x - 1, y) + getarea(x + 1, y) + getarea(x, y - 1) + getarea(x, y + 1)\\n        \\n        def getcolor(x, y):\\n            nonlocal grid, m, n\\n            return 0 if (x < 0 or y < 0 or x >= m or y >= n) else grid[x][y] \\n        \\n        ans = float(\\'-inf\\')\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 1:\\n                    tmp = getarea(i, j)\\n                    dic[color_] = tmp\\n                    ans = max(ans, tmp)\\n                    color_ += 1\\n        \\n#         print(color_, grid, dic)\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j] == 0:\\n                    colorset = set([getcolor(i - 1, j), getcolor(i + 1, j), getcolor(i, j - 1), getcolor(i, j + 1)])\\n                    tmp = 1\\n                    for c in colorset:\\n                        tmp += dic[c]\\n                    ans = max(ans, tmp)\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908442,
                "title": "c-bfs-island-size",
                "content": "```\\nclass Solution {\\nprivate:\\n    int rSize, cSize;\\n    const int dir[5] = {0, 1, 0, -1, 0};\\n    unordered_map<int, int> sizeLookup;\\n    \\n    bool inBound(int r, int c) {\\n        return (r >= 0 && c >= 0 && r < rSize && c < cSize);\\n    }\\n    \\n    // store result in memo\\n    int bfs(int r, int c, int islandCnt, vector<vector<int>> &memo, vector<vector<int>> &grid) {\\n        queue<pair<int, int>> bfsQ;\\n        bfsQ.emplace(r, c);\\n        memo[r][c] = islandCnt;\\n        \\n        int size = 0;\\n        while (!bfsQ.empty()) {\\n            int currR = bfsQ.front().first;\\n            int currC = bfsQ.front().second;\\n            bfsQ.pop();\\n            size++;\\n            for (int i = 0; i < 4; i++) {\\n                int nextR = currR + dir[i];\\n                int nextC = currC + dir[i + 1];\\n                if (inBound(nextR, nextC) && grid[nextR][nextC] == 1 && memo[nextR][nextC] == -1) {\\n                    memo[nextR][nextC] = islandCnt;\\n                    bfsQ.emplace(nextR, nextC);\\n                }\\n            }\\n        }\\n        sizeLookup[islandCnt] = size;\\n        return size;\\n    }\\npublic:\\n    int largestIsland(vector<vector<int>>& grid) {\\n        rSize = grid.size();\\n        cSize = grid[0].size();\\n        \\n        vector<vector<int>> memo(rSize, vector<int>(cSize, -1));\\n        \\n        int islandCnt = 0;\\n        int res = 0;\\n        \\n        // mark down each island\\'s size\\n        for (int r = 0; r < rSize; r++) {\\n            for (int c = 0; c < cSize; c++) {\\n                if (grid[r][c] == 1 && memo[r][c] == -1) {\\n                    res = max(res, bfs(r, c, islandCnt++, memo, grid));\\n                }\\n            }\\n        }\\n        \\n        // for each empty slot, sum all islands connected to this slot\\n        for (int r = 0; r < rSize; r++) {\\n            for (int c = 0; c < cSize; c++) {\\n                if (grid[r][c] == 0) {\\n                    vector<int> connectSize(4, 0);\\n                    unordered_set<int> connected;\\n                    for (int i = 0; i < 4; i++) {\\n                        int searchR = r + dir[i];\\n                        int searchC = c + dir[i + 1];\\n                        int islandNo = inBound(searchR, searchC) ? memo[searchR][searchC] : -1;\\n                        if (islandNo >= 0 && !connected.count(islandNo)) {\\n                            connected.insert(islandNo);\\n                            connectSize[i] = sizeLookup[islandNo];\\n                        }\\n                    }\\n                    res = max(res, accumulate(connectSize.begin(), connectSize.end(), 0) + 1);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int rSize, cSize;\\n    const int dir[5] = {0, 1, 0, -1, 0};\\n    unordered_map<int, int> sizeLookup;\\n    \\n    bool inBound(int r, int c) {\\n        return (r >= 0 && c >= 0 && r < rSize && c < cSize);\\n    }\\n    \\n    // store result in memo\\n    int bfs(int r, int c, int islandCnt, vector<vector<int>> &memo, vector<vector<int>> &grid) {\\n        queue<pair<int, int>> bfsQ;\\n        bfsQ.emplace(r, c);\\n        memo[r][c] = islandCnt;\\n        \\n        int size = 0;\\n        while (!bfsQ.empty()) {\\n            int currR = bfsQ.front().first;\\n            int currC = bfsQ.front().second;\\n            bfsQ.pop();\\n            size++;\\n            for (int i = 0; i < 4; i++) {\\n                int nextR = currR + dir[i];\\n                int nextC = currC + dir[i + 1];\\n                if (inBound(nextR, nextC) && grid[nextR][nextC] == 1 && memo[nextR][nextC] == -1) {\\n                    memo[nextR][nextC] = islandCnt;\\n                    bfsQ.emplace(nextR, nextC);\\n                }\\n            }\\n        }\\n        sizeLookup[islandCnt] = size;\\n        return size;\\n    }\\npublic:\\n    int largestIsland(vector<vector<int>>& grid) {\\n        rSize = grid.size();\\n        cSize = grid[0].size();\\n        \\n        vector<vector<int>> memo(rSize, vector<int>(cSize, -1));\\n        \\n        int islandCnt = 0;\\n        int res = 0;\\n        \\n        // mark down each island\\'s size\\n        for (int r = 0; r < rSize; r++) {\\n            for (int c = 0; c < cSize; c++) {\\n                if (grid[r][c] == 1 && memo[r][c] == -1) {\\n                    res = max(res, bfs(r, c, islandCnt++, memo, grid));\\n                }\\n            }\\n        }\\n        \\n        // for each empty slot, sum all islands connected to this slot\\n        for (int r = 0; r < rSize; r++) {\\n            for (int c = 0; c < cSize; c++) {\\n                if (grid[r][c] == 0) {\\n                    vector<int> connectSize(4, 0);\\n                    unordered_set<int> connected;\\n                    for (int i = 0; i < 4; i++) {\\n                        int searchR = r + dir[i];\\n                        int searchC = c + dir[i + 1];\\n                        int islandNo = inBound(searchR, searchC) ? memo[searchR][searchC] : -1;\\n                        if (islandNo >= 0 && !connected.count(islandNo)) {\\n                            connected.insert(islandNo);\\n                            connectSize[i] = sizeLookup[islandNo];\\n                        }\\n                    }\\n                    res = max(res, accumulate(connectSize.begin(), connectSize.end(), 0) + 1);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1860987,
                "title": "c-bfs-faster-than-98-in-space-and-time-both",
                "content": "okay\\nso,the idea/approch is \\n1. calculate the area of every island  and mark them  ***-1(visited)***\\n2. give every island a  ***name/id *** \\n3. store the calculated area in map with help of id \\n4. mark the corner of island with there id \\n5. now traverse to the matrix once again \\n6. if matrix[i][j]==0 then \\n7.  we will have four places to check top,bottom,left,right\\n8.  and if there is island over the four places/position they will be marked with there id \\n9.  add the area of adjesent positions with the help of map and id\\n10.  maximise the area \\n**note --- **\\n**if the id at the adjesent are same add only one time **\\neg, \\n1 1 1\\n1 0 1\\n1 1 1\\n\\nlet the id of the island is 2\\nthe over new matrix will be \\n2 2 2\\n2 0 2\\n2 2 2\\naround matrix[1][1] id is same at all adjecent so  add one time only\\ncode\\n```\\nclass Solution {\\npublic:\\n    int largestIsland(vector<vector<int>>& grid) {\\n        \\n        int n= grid.size();\\n        int m= grid[0].size();\\n        if(n==1) return 1;\\n        int curr=0;\\n        int id=2;\\n        queue<pair<int,int>> q;\\n        unordered_map<int,int> mp;\\n         mp[0]=0;  int ans=0;\\n        bool f=0,p=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    curr++;\\n                    vector<pair<int,int>> corner;\\n                    corner.push_back({i,j});\\n                    q.push({i,j});\\n                    grid[i][j]=-1;\\n                    while(!q.empty()){\\n                        int a=q.front().first;\\n                        int b=q.front().second;\\n                        q.pop();\\n                        if(a>0 && grid[a-1][b]==1){\\n                            q.push({a-1,b});\\n                            grid[a-1][b]=-1;\\n                           curr++;\\n                        }else if(a>0 && grid[a-1][b]==0) f=1;\\n                        \\n                        if(b>0 && grid[a][b-1]==1){\\n                            q.push({a,b-1});\\n                            grid[a][b-1]=-1;\\n                            curr++;\\n                        }else  if(b>0 && grid[a][b-1]==0) f=1;\\n                        \\n                        if(a<n-1 && grid[a+1][b]==1){\\n                            q.push({a+1,b});\\n                            grid[a+1][b]=-1;\\n                            curr++;\\n                        }else if(a<n-1 && grid[a+1][b]==0) f=1;\\n                        \\n                        if(b<m-1 && grid[a][b+1]==1){\\n                            q.push({a,b+1});\\n                            grid[a][b+1]=-1;\\n                            curr++;\\n                        }else if(b<m-1 && grid[a][b+1]==0) f=1;\\n                        \\n                        if(f) corner.push_back({a,b});\\n                    }\\n                    mp[id]=curr;\\n                    ans=max(ans,curr);\\n                    curr=0;\\n                    for(auto &it:corner){\\n                        int x=it.first;\\n                        int y=it.second;\\n                        grid[x][y]=id;\\n                       \\n                    }\\n                    id++;\\n                }\\n            }\\n        }\\n      \\n        int temp=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==0){\\n                    int a=0,b=0,c=0,d=0;\\n                    if(i>0)   a=grid[i-1][j];\\n                    if(j>0)   b=grid[i][j-1];\\n                    if(i<n-1) d=grid[i+1][j];\\n                    if(j<m-1) c=grid[i][j+1];\\n                    if(a!=b && a!=c && a!=d && a>0) temp= temp+mp[a];\\n                    if(b!=c && b!=d && b>0)         temp=temp+mp[b];\\n                    if(c!=d && c>0)                 temp=temp+mp[c];\\n                    if(d>0) temp=temp+mp[d];\\n                    // cout<<temp<<\" \";\\n                    ans=max(ans,temp+1);\\n                       temp=0;\\n                }\\n          \\n            }\\n                  }\\n       return ans; \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int largestIsland(vector<vector<int>>& grid) {\\n        \\n        int n= grid.size();\\n        int m= grid[0].size();\\n        if(n==1) return 1;\\n        int curr=0;\\n        int id=2;\\n        queue<pair<int,int>> q;\\n        unordered_map<int,int> mp;\\n         mp[0]=0;  int ans=0;\\n        bool f=0,p=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1){\\n                    curr++;\\n                    vector<pair<int,int>> corner;\\n                    corner.push_back({i,j});\\n                    q.push({i,j});\\n                    grid[i][j]=-1;\\n                    while(!q.empty()){\\n                        int a=q.front().first;\\n                        int b=q.front().second;\\n                        q.pop();\\n                        if(a>0 && grid[a-1][b]==1){\\n                            q.push({a-1,b});\\n                            grid[a-1][b]=-1;\\n                           curr++;\\n                        }else if(a>0 && grid[a-1][b]==0) f=1;\\n                        \\n                        if(b>0 && grid[a][b-1]==1){\\n                            q.push({a,b-1});\\n                            grid[a][b-1]=-1;\\n                            curr++;\\n                        }else  if(b>0 && grid[a][b-1]==0) f=1;\\n                        \\n                        if(a<n-1 && grid[a+1][b]==1){\\n                            q.push({a+1,b});\\n                            grid[a+1][b]=-1;\\n                            curr++;\\n                        }else if(a<n-1 && grid[a+1][b]==0) f=1;\\n                        \\n                        if(b<m-1 && grid[a][b+1]==1){\\n                            q.push({a,b+1});\\n                            grid[a][b+1]=-1;\\n                            curr++;\\n                        }else if(b<m-1 && grid[a][b+1]==0) f=1;\\n                        \\n                        if(f) corner.push_back({a,b});\\n                    }\\n                    mp[id]=curr;\\n                    ans=max(ans,curr);\\n                    curr=0;\\n                    for(auto &it:corner){\\n                        int x=it.first;\\n                        int y=it.second;\\n                        grid[x][y]=id;\\n                       \\n                    }\\n                    id++;\\n                }\\n            }\\n        }\\n      \\n        int temp=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==0){\\n                    int a=0,b=0,c=0,d=0;\\n                    if(i>0)   a=grid[i-1][j];\\n                    if(j>0)   b=grid[i][j-1];\\n                    if(i<n-1) d=grid[i+1][j];\\n                    if(j<m-1) c=grid[i][j+1];\\n                    if(a!=b && a!=c && a!=d && a>0) temp= temp+mp[a];\\n                    if(b!=c && b!=d && b>0)         temp=temp+mp[b];\\n                    if(c!=d && c>0)                 temp=temp+mp[c];\\n                    if(d>0) temp=temp+mp[d];\\n                    // cout<<temp<<\" \";\\n                    ans=max(ans,temp+1);\\n                       temp=0;\\n                }\\n          \\n            }\\n                  }\\n       return ans; \\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1800473,
                "title": "java-bfs-o-n-n-time",
                "content": "```\\nclass Solution {\\n\\n    int[][] dirs = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n\\n    public int largestIsland(int[][] grid) {\\n        int N = grid.length;\\n        int islandId = 2;\\n        Map<Integer, Integer> islandIdToSizeMap = new HashMap<>();\\n        int biggestIslandSize = 0;\\n        \\n        for (int row = 0; row < N; row++) {\\n            for (int col = 0; col < N; col++) {\\n                if (grid[row][col] == 1) {\\n                    int islandSize = getIslandSize(row, col, grid, islandId);\\n                    islandIdToSizeMap.put(islandId, islandSize);\\n                    biggestIslandSize = Math.max(biggestIslandSize, islandSize);\\n                    islandId++;\\n                }\\n            }\\n        }\\n\\n        for (int row = 0; row < N; row++) {\\n            for (int col = 0; col < N; col++) {\\n                if (grid[row][col] == 0) {\\n                    Set<Integer> seenIslands = new HashSet<>();\\n                    int sumAdjacentIslandsSize = 0;\\n                    for (int[] dir : dirs) {\\n                        int nextRow = row + dir[0];\\n                        int newCol = col + dir[1];\\n                        if (nextRow >= 0 && nextRow < N && newCol >= 0 && newCol < N && grid[nextRow][newCol] != 0 && !seenIslands.contains(grid[nextRow][newCol])) {\\n                            sumAdjacentIslandsSize += islandIdToSizeMap.get(grid[nextRow][newCol]);\\n                            seenIslands.add(grid[nextRow][newCol]);\\n                        }\\n                    }\\n                    biggestIslandSize = Math.max(biggestIslandSize, sumAdjacentIslandsSize + 1);\\n                }\\n            }\\n        }\\n\\n        return biggestIslandSize;\\n    }\\n\\n\\n    private int getIslandSize(int row, int col, int[][] grid, int islandId) {\\n        Queue<int[]> q = new LinkedList<>();\\n        grid[row][col] = islandId;\\n        q.offer(new int[]{row, col});\\n\\n        int islandSize = 0;\\n        while (!q.isEmpty()) {\\n            islandSize++;\\n            int[] curr = q.poll();\\n            row = curr[0];\\n            col = curr[1];\\n            for (int[] dir : dirs) {\\n                int nextRow = row + dir[0];\\n                int nextCol = col + dir[1];\\n                if (nextRow >= 0 && nextRow < grid.length && nextCol >= 0 && nextCol < grid.length && grid[nextRow][nextCol] == 1) {\\n                    q.offer(new int[]{nextRow, nextCol});\\n                    grid[nextRow][nextCol] = islandId;\\n                }\\n            }\\n        }\\n\\n        return islandSize;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n\\n    int[][] dirs = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n\\n    public int largestIsland(int[][] grid) {\\n        int N = grid.length;\\n        int islandId = 2;\\n        Map<Integer, Integer> islandIdToSizeMap = new HashMap<>();\\n        int biggestIslandSize = 0;\\n        \\n        for (int row = 0; row < N; row++) {\\n            for (int col = 0; col < N; col++) {\\n                if (grid[row][col] == 1) {\\n                    int islandSize = getIslandSize(row, col, grid, islandId);\\n                    islandIdToSizeMap.put(islandId, islandSize);\\n                    biggestIslandSize = Math.max(biggestIslandSize, islandSize);\\n                    islandId++;\\n                }\\n            }\\n        }\\n\\n        for (int row = 0; row < N; row++) {\\n            for (int col = 0; col < N; col++) {\\n                if (grid[row][col] == 0) {\\n                    Set<Integer> seenIslands = new HashSet<>();\\n                    int sumAdjacentIslandsSize = 0;\\n                    for (int[] dir : dirs) {\\n                        int nextRow = row + dir[0];\\n                        int newCol = col + dir[1];\\n                        if (nextRow >= 0 && nextRow < N && newCol >= 0 && newCol < N && grid[nextRow][newCol] != 0 && !seenIslands.contains(grid[nextRow][newCol])) {\\n                            sumAdjacentIslandsSize += islandIdToSizeMap.get(grid[nextRow][newCol]);\\n                            seenIslands.add(grid[nextRow][newCol]);\\n                        }\\n                    }\\n                    biggestIslandSize = Math.max(biggestIslandSize, sumAdjacentIslandsSize + 1);\\n                }\\n            }\\n        }\\n\\n        return biggestIslandSize;\\n    }\\n\\n\\n    private int getIslandSize(int row, int col, int[][] grid, int islandId) {\\n        Queue<int[]> q = new LinkedList<>();\\n        grid[row][col] = islandId;\\n        q.offer(new int[]{row, col});\\n\\n        int islandSize = 0;\\n        while (!q.isEmpty()) {\\n            islandSize++;\\n            int[] curr = q.poll();\\n            row = curr[0];\\n            col = curr[1];\\n            for (int[] dir : dirs) {\\n                int nextRow = row + dir[0];\\n                int nextCol = col + dir[1];\\n                if (nextRow >= 0 && nextRow < grid.length && nextCol >= 0 && nextCol < grid.length && grid[nextRow][nextCol] == 1) {\\n                    q.offer(new int[]{nextRow, nextCol});\\n                    grid[nextRow][nextCol] = islandId;\\n                }\\n            }\\n        }\\n\\n        return islandSize;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1755310,
                "title": "easy-bfs-solution-with-explanation",
                "content": "The main idea of this solution is to update the adjacent `0`s to an island with the size of the island. That way if two neighbouring islands share the same set of `0`s, those cells (with the common `0`s) should be able to tell the maximum size of island (by combining the neighbour islands) if the `0` was turned to `1`. Refer the following:\\n\\n![image](https://assets.leetcode.com/users/images/12893b7b-60bd-4dca-99c8-0948d758348c_1644318239.5530734.png)\\n\\nWhat we can do to achieve this is:\\n1. traverse the grid and find a `1` cell. Start BFS from there while keeping track of the size of the island & record any neighbouring adjacent `0` cell encountered while visiting all the cells of one island. \\n2. Once we have the size of the island, update the cells having `0` adjacent to the island with the calculated size.\\n3. Find the maximum value recorded so far.\\n4. Add 1 to the maximum value recorded (since the cell is `0` and has to be converted to `1` which will add to the size), and return it as answer.\\n\\nNote: If the entire grid is an island then steps 2 to 4 won\\'t be happening as there won\\'t be any adjacent `0` cell. In this case its easy to identify if the entire grid has been visited already by checking if the size of the island is equal to `n*n`. If so, return that value as answer.\\n\\n\\n```\\nclass Solution {\\n    class Pair{\\n        int x,y;\\n        public Pair(int x,int y){\\n            this.x= x;\\n            this.y=y;\\n        }\\n    }\\n\\n    public int largestIsland(int[][] grid) {\\n        int n = grid.length;\\n        int[][]mem = new int[n][n];\\n\\n        Set<Pair> visited = new HashSet<>();\\n        int[][]dirs = new int[][]{\\n                {-1,0}, {1,0}, {0,-1}, {0,1}\\n        };\\n\\n        int overallMaxSize = 0;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1 && !visited.contains(new Pair(i,j))){\\n\\n                    Set<Pair>zeros = new HashSet<>();\\n\\n                    ArrayDeque<Pair> dq = new ArrayDeque<>();\\n                    dq.add(new Pair(i,j));\\n                    visited.add(new Pair(i,j));\\n                    int size = 1;\\n                    while(!dq.isEmpty()){\\n\\n                        Pair cur = dq.removeFirst();\\n                        for(int[]dir:dirs){\\n                            int x = cur.x + dir[0], y = cur.y + dir[1];\\n                            if(0<=x && x<n && 0<=y && y<n){\\n                                if(grid[x][y] == 0){\\n                                    zeros.add(new Pair(x,y));\\n                                }\\n                                else if(!visited.contains(new Pair(x,y))){\\n                                    Pair coords = new Pair(x,y);\\n                                    dq.add(coords);\\n                                    visited.add(coords);\\n                                    size++;\\n                                }   \\n                            }\\n                        }\\n                    }\\n\\n                    if(size == n*n) // the entire grid represents an island, nothing can be bigger than this.\\n                        return size;\\n\\n\\n                    for(Pair coords:zeros){\\n                        mem[coords.x][coords.y]+=size;\\n                        overallMaxSize = Math.max(overallMaxSize, mem[coords.x][coords.y]);\\n                    }\\n\\n                }\\n            }\\n        }\\n        return overallMaxSize+1;\\n    }\\n}\\n```\\n\\nPlease leave an upvote if this solution has helped!!\\n\\nThanks.",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    class Pair{\\n        int x,y;\\n        public Pair(int x,int y){\\n            this.x= x;\\n            this.y=y;\\n        }\\n    }\\n\\n    public int largestIsland(int[][] grid) {\\n        int n = grid.length;\\n        int[][]mem = new int[n][n];\\n\\n        Set<Pair> visited = new HashSet<>();\\n        int[][]dirs = new int[][]{\\n                {-1,0}, {1,0}, {0,-1}, {0,1}\\n        };\\n\\n        int overallMaxSize = 0;\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1 && !visited.contains(new Pair(i,j))){\\n\\n                    Set<Pair>zeros = new HashSet<>();\\n\\n                    ArrayDeque<Pair> dq = new ArrayDeque<>();\\n                    dq.add(new Pair(i,j));\\n                    visited.add(new Pair(i,j));\\n                    int size = 1;\\n                    while(!dq.isEmpty()){\\n\\n                        Pair cur = dq.removeFirst();\\n                        for(int[]dir:dirs){\\n                            int x = cur.x + dir[0], y = cur.y + dir[1];\\n                            if(0<=x && x<n && 0<=y && y<n){\\n                                if(grid[x][y] == 0){\\n                                    zeros.add(new Pair(x,y));\\n                                }\\n                                else if(!visited.contains(new Pair(x,y))){\\n                                    Pair coords = new Pair(x,y);\\n                                    dq.add(coords);\\n                                    visited.add(coords);\\n                                    size++;\\n                                }   \\n                            }\\n                        }\\n                    }\\n\\n                    if(size == n*n) // the entire grid represents an island, nothing can be bigger than this.\\n                        return size;\\n\\n\\n                    for(Pair coords:zeros){\\n                        mem[coords.x][coords.y]+=size;\\n                        overallMaxSize = Math.max(overallMaxSize, mem[coords.x][coords.y]);\\n                    }\\n\\n                }\\n            }\\n        }\\n        return overallMaxSize+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1689649,
                "title": "making-a-large-island",
                "content": "```\\npublic class Pair{\\n    int x;int y;\\n    public Pair(int x,int y){\\n        this.x =x;\\n        this.y =y;\\n    }\\n}\\nclass Solution {\\n    \\n    public boolean isValid(Pair temp,int n,int m){\\n        if(temp.x>=n || temp.x<0 || temp.y>=m || temp.y<0)\\n            return false;\\n        return true;\\n    }\\n    public int largestIsland(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int visited[][] = new int[n][m];\\n        int X[] = {0,0,1,-1};\\n        int Y[] = {1,-1,0,0};\\n        int groupID = 0;\\n        int maxGroupSize[] = new int [n*m+1];\\n        int maxSize = 0;\\n        int ans  =0;\\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<m;j++){\\n                if(visited[i][j] > 0 || grid[i][j] == 0) continue;\\n                Queue<Pair> q = new LinkedList<>();\\n                q.add(new Pair(i,j));\\n                groupID++;\\n                visited[i][j]  = groupID;\\n                int size =0;\\n                while(q.size()!=0) {\\n                    Pair current = q.peek();\\n                    q.remove();\\n                    size++;\\n                    for(int k=0;k<4;k++){\\n                        Pair temp = new Pair(current.x+ X[k],current.y+Y[k]);\\n                            if(isValid(temp,n,m) && visited[temp.x][temp.y] ==0 && grid[temp.x][temp.y] == 1) {\\n                                q.add(temp);\\n                                visited[temp.x][temp.y]  = groupID;\\n                            }\\n                    }\\n                }\\n                maxGroupSize[groupID] = size;  \\n                ans = Math.max(ans,size);\\n                \\n            }\\n        }\\n        // System.out.println(Arrays.toString(maxGroupSize));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j] == 1) continue;\\n                // Pair current = new Pair(i,j);\\n                int arrT[] = new int[4];\\n                int t=0;\\n                int tempAns =1;\\n                for(int k=0;k<4;k++){\\n                     Pair temp = new Pair(i+X[k],j+Y[k]);\\n                    if(isValid(temp,n,m) && grid[temp.x][temp.y] == 1) {\\n                        arrT[t] = visited[temp.x][temp.y];\\n                        t++;\\n                    }\\n                }\\n                Arrays.sort(arrT);\\n                tempAns +=maxGroupSize[arrT[0]];\\n                for(int k =1;k<4;k++){\\n                    if(arrT[k-1] != arrT[k]) tempAns+=maxGroupSize[arrT[k]];\\n                }\\n                ans = Math.max(tempAns,ans);                \\n            }\\n        }        \\n       return ans;              \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\npublic class Pair{\\n    int x;int y;\\n    public Pair(int x,int y){\\n        this.x =x;\\n        this.y =y;\\n    }\\n}\\nclass Solution {\\n    \\n    public boolean isValid(Pair temp,int n,int m){\\n        if(temp.x>=n || temp.x<0 || temp.y>=m || temp.y<0)\\n            return false;\\n        return true;\\n    }\\n    public int largestIsland(int[][] grid) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int visited[][] = new int[n][m];\\n        int X[] = {0,0,1,-1};\\n        int Y[] = {1,-1,0,0};\\n        int groupID = 0;\\n        int maxGroupSize[] = new int [n*m+1];\\n        int maxSize = 0;\\n        int ans  =0;\\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<m;j++){\\n                if(visited[i][j] > 0 || grid[i][j] == 0) continue;\\n                Queue<Pair> q = new LinkedList<>();\\n                q.add(new Pair(i,j));\\n                groupID++;\\n                visited[i][j]  = groupID;\\n                int size =0;\\n                while(q.size()!=0) {\\n                    Pair current = q.peek();\\n                    q.remove();\\n                    size++;\\n                    for(int k=0;k<4;k++){\\n                        Pair temp = new Pair(current.x+ X[k],current.y+Y[k]);\\n                            if(isValid(temp,n,m) && visited[temp.x][temp.y] ==0 && grid[temp.x][temp.y] == 1) {\\n                                q.add(temp);\\n                                visited[temp.x][temp.y]  = groupID;\\n                            }\\n                    }\\n                }\\n                maxGroupSize[groupID] = size;  \\n                ans = Math.max(ans,size);\\n                \\n            }\\n        }\\n        // System.out.println(Arrays.toString(maxGroupSize));\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j] == 1) continue;\\n                // Pair current = new Pair(i,j);\\n                int arrT[] = new int[4];\\n                int t=0;\\n                int tempAns =1;\\n                for(int k=0;k<4;k++){\\n                     Pair temp = new Pair(i+X[k],j+Y[k]);\\n                    if(isValid(temp,n,m) && grid[temp.x][temp.y] == 1) {\\n                        arrT[t] = visited[temp.x][temp.y];\\n                        t++;\\n                    }\\n                }\\n                Arrays.sort(arrT);\\n                tempAns +=maxGroupSize[arrT[0]];\\n                for(int k =1;k<4;k++){\\n                    if(arrT[k-1] != arrT[k]) tempAns+=maxGroupSize[arrT[k]];\\n                }\\n                ans = Math.max(tempAns,ans);                \\n            }\\n        }        \\n       return ans;              \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1659090,
                "title": "java-union-find-solution",
                "content": "Every island is a cluster containing items with value ```1```. So we can use union find to model the problem. \\n- First, iterate the ```grid```, add all items using union find ```union``` method. We may stop early if all items are ```1```. Slightly different with typlical union find with rank implementation, we also keep track of the size for each cluster ```clusterSize```. For ```clusterSize[i]``` it records the number of items in the cluster where we use ```i``` as root. \\n- Second, loop the grid again for every ```0```, check its four directions neighbors, if they are ```1``` then sum up the size of the cluster  (island size) which it belongs to.  Their neighbors may belongs up to four different clusters or they may all belong to one. \\n- Keep track of a max island size variable and compare with every possible new island size calculated in step 2. \\n```\\nclass Solution {\\n    class UnionFind{\\n        int[] parents;\\n        int[] rank;\\n        int[] clusterSize;\\n        \\n        public UnionFind(int size){            \\n            parents = new int[size];\\n            rank = new int[size];\\n            clusterSize = new int[size];\\n            \\n            for(int i = 0; i < size; i++) {\\n                rank[i] = 1;\\n                parents[i] = i;\\n                clusterSize[i] = 1;\\n            }\\n        }\\n        \\n        public int find(int x){\\n            if (x == parents[x]) {\\n                return x;\\n            }\\n            \\n            parents[x] = find(parents[x]);\\n            return parents[x];\\n        }\\n        \\n        public void union(int x, int y){\\n            int rootX = find(x);\\n            int rootY = find(y);\\n\\n            if (rootX == rootY) {\\n                return;\\n            }\\n            \\n            int rankX = rank[rootX];\\n            int rankY = rank[rootY];\\n            \\n            if (rankX > rankY) {\\n                parents[rootY] = rootX;\\n                clusterSize[rootX] += clusterSize[rootY];\\n            }\\n            else if (rankY > rankX){\\n                parents[rootX] = rootY;\\n                clusterSize[rootY] += clusterSize[rootX];\\n            }\\n            else{\\n                parents[rootY] = rootX;\\n                rank[rootX]++;\\n                clusterSize[rootX] += clusterSize[rootY];\\n            }\\n        }\\n        \\n        public int getClusterSize(int x) {\\n            return clusterSize[x];\\n        }\\n    }\\n    \\n    public int largestIsland(int[][] grid) {\\n        int n = grid.length;\\n        int[][] directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        UnionFind uf = new UnionFind(n * n);\\n        \\n        boolean hasZero = false;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < n; j++){\\n                if (grid[i][j] == 0) {\\n                    hasZero = true;\\n                    continue;\\n                }\\n                \\n                // union all nodes with value 1, no need to check four directions. just right and down.\\n                if (i + 1 < n && grid[i + 1][j] == 1) {\\n                    uf.union(i * n + j, (i + 1) * n + j);\\n                }\\n                \\n                if (j + 1 < n && grid[i][j + 1] == 1) {\\n                    uf.union(i * n + j, i * n + (j + 1));\\n                }\\n            }\\n        }\\n        \\n        if (!hasZero) {\\n            return n * n;\\n        }\\n        \\n        int maxIslandSize = 1;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    continue;\\n                }\\n                \\n                HashSet<Integer> set = new HashSet<>();\\n                int islandSize = 1;\\n\\n                for(int[] direction: directions){\\n                    int newX = i + direction[0];\\n                    int newY = j + direction[1];\\n                    \\n                    if (newX >= 0 && newX < n && newY >= 0 && newY < n && grid[newX][newY] == 1) \\n                    {\\n                        int newRoot = uf.find(newX * n + newY);\\n                        if(!set.contains(newRoot)) {\\n                            islandSize += uf.getClusterSize(newRoot);\\n                            set.add(newRoot);\\n                        }\\n                    }\\n                }\\n                \\n                maxIslandSize = Math.max(maxIslandSize, islandSize);\\n            }\\n        }\\n        \\n        return maxIslandSize;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```1```\n```grid```\n```union```\n```1```\n```clusterSize```\n```clusterSize[i]```\n```i```\n```0```\n```1```\n```\\nclass Solution {\\n    class UnionFind{\\n        int[] parents;\\n        int[] rank;\\n        int[] clusterSize;\\n        \\n        public UnionFind(int size){            \\n            parents = new int[size];\\n            rank = new int[size];\\n            clusterSize = new int[size];\\n            \\n            for(int i = 0; i < size; i++) {\\n                rank[i] = 1;\\n                parents[i] = i;\\n                clusterSize[i] = 1;\\n            }\\n        }\\n        \\n        public int find(int x){\\n            if (x == parents[x]) {\\n                return x;\\n            }\\n            \\n            parents[x] = find(parents[x]);\\n            return parents[x];\\n        }\\n        \\n        public void union(int x, int y){\\n            int rootX = find(x);\\n            int rootY = find(y);\\n\\n            if (rootX == rootY) {\\n                return;\\n            }\\n            \\n            int rankX = rank[rootX];\\n            int rankY = rank[rootY];\\n            \\n            if (rankX > rankY) {\\n                parents[rootY] = rootX;\\n                clusterSize[rootX] += clusterSize[rootY];\\n            }\\n            else if (rankY > rankX){\\n                parents[rootX] = rootY;\\n                clusterSize[rootY] += clusterSize[rootX];\\n            }\\n            else{\\n                parents[rootY] = rootX;\\n                rank[rootX]++;\\n                clusterSize[rootX] += clusterSize[rootY];\\n            }\\n        }\\n        \\n        public int getClusterSize(int x) {\\n            return clusterSize[x];\\n        }\\n    }\\n    \\n    public int largestIsland(int[][] grid) {\\n        int n = grid.length;\\n        int[][] directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n        UnionFind uf = new UnionFind(n * n);\\n        \\n        boolean hasZero = false;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < n; j++){\\n                if (grid[i][j] == 0) {\\n                    hasZero = true;\\n                    continue;\\n                }\\n                \\n                // union all nodes with value 1, no need to check four directions. just right and down.\\n                if (i + 1 < n && grid[i + 1][j] == 1) {\\n                    uf.union(i * n + j, (i + 1) * n + j);\\n                }\\n                \\n                if (j + 1 < n && grid[i][j + 1] == 1) {\\n                    uf.union(i * n + j, i * n + (j + 1));\\n                }\\n            }\\n        }\\n        \\n        if (!hasZero) {\\n            return n * n;\\n        }\\n        \\n        int maxIslandSize = 1;\\n        for(int i = 0; i < n; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    continue;\\n                }\\n                \\n                HashSet<Integer> set = new HashSet<>();\\n                int islandSize = 1;\\n\\n                for(int[] direction: directions){\\n                    int newX = i + direction[0];\\n                    int newY = j + direction[1];\\n                    \\n                    if (newX >= 0 && newX < n && newY >= 0 && newY < n && grid[newX][newY] == 1) \\n                    {\\n                        int newRoot = uf.find(newX * n + newY);\\n                        if(!set.contains(newRoot)) {\\n                            islandSize += uf.getClusterSize(newRoot);\\n                            set.add(newRoot);\\n                        }\\n                    }\\n                }\\n                \\n                maxIslandSize = Math.max(maxIslandSize, islandSize);\\n            }\\n        }\\n        \\n        return maxIslandSize;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1620581,
                "title": "swift-dfs-self-explanatory-code",
                "content": "```\\nclass Solution {\\n    func largestIsland(_ grid: [[Int]]) -> Int {\\n        var connectedGrid = grid\\n        var parentID = 2, parentLengthMap = [Int:Int]()\\n        for row in 0..<grid.count {\\n            for col in 0..<grid[0].count {\\n                if connectedGrid[row][col] == 1 {\\n                    var currentLength = 1\\n                    largestIslandDFSHelper(row, col, &connectedGrid, parentID, &currentLength)\\n                    parentLengthMap[parentID] = currentLength\\n                    parentID += 1\\n                }\\n            }\\n        }\\n        \\n        var maxLength = Int.min\\n        for row in 0..<grid.count {\\n            for col in 0..<grid[0].count {\\n                if connectedGrid[row][col] == 0 {\\n                    var currentLength = 1, parentIdSet = Set<Int>()\\n                    for (r, c) in [(0, -1), (-1, 0), (0, 1), (1, 0)] {\\n                        let (newR, newC) = (row + r, col + c)\\n                        if newR < 0 || newR >= connectedGrid.count || newC < 0 || newC >= connectedGrid[0].count || connectedGrid[newR][newC] == 0 {\\n                            continue\\n                        }\\n                        let currentParentID = connectedGrid[newR][newC]\\n                        if !parentIdSet.contains(currentParentID) {\\n                            currentLength += parentLengthMap[currentParentID]!\\n                            parentIdSet.insert(currentParentID)\\n                        }\\n                    }\\n                    maxLength = max(maxLength, currentLength)\\n                }\\n            }\\n        }\\n        return maxLength == Int.min ? parentLengthMap.values.first! : maxLength\\n    }\\n    \\n    func largestIslandDFSHelper(_ row: Int, _ col: Int, _ connectedGrid: inout [[Int]], _ parentID: Int, _ currentLength: inout Int) {\\n        connectedGrid[row][col] = parentID\\n        for (r, c) in [(0, -1), (-1, 0), (0, 1), (1, 0)] {\\n            let (newR, newC) = (row + r, col + c)\\n            if newR < 0 || newR >= connectedGrid.count || newC < 0 || newC >= connectedGrid[0].count || connectedGrid[newR][newC] != 1 {\\n                continue\\n            }\\n            currentLength += 1\\n            largestIslandDFSHelper(newR, newC, &connectedGrid, parentID, &currentLength)\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    func largestIsland(_ grid: [[Int]]) -> Int {\\n        var connectedGrid = grid\\n        var parentID = 2, parentLengthMap = [Int:Int]()\\n        for row in 0..<grid.count {\\n            for col in 0..<grid[0].count {\\n                if connectedGrid[row][col] == 1 {\\n                    var currentLength = 1\\n                    largestIslandDFSHelper(row, col, &connectedGrid, parentID, &currentLength)\\n                    parentLengthMap[parentID] = currentLength\\n                    parentID += 1\\n                }\\n            }\\n        }\\n        \\n        var maxLength = Int.min\\n        for row in 0..<grid.count {\\n            for col in 0..<grid[0].count {\\n                if connectedGrid[row][col] == 0 {\\n                    var currentLength = 1, parentIdSet = Set<Int>()\\n                    for (r, c) in [(0, -1), (-1, 0), (0, 1), (1, 0)] {\\n                        let (newR, newC) = (row + r, col + c)\\n                        if newR < 0 || newR >= connectedGrid.count || newC < 0 || newC >= connectedGrid[0].count || connectedGrid[newR][newC] == 0 {\\n                            continue\\n                        }\\n                        let currentParentID = connectedGrid[newR][newC]\\n                        if !parentIdSet.contains(currentParentID) {\\n                            currentLength += parentLengthMap[currentParentID]!\\n                            parentIdSet.insert(currentParentID)\\n                        }\\n                    }\\n                    maxLength = max(maxLength, currentLength)\\n                }\\n            }\\n        }\\n        return maxLength == Int.min ? parentLengthMap.values.first! : maxLength\\n    }\\n    \\n    func largestIslandDFSHelper(_ row: Int, _ col: Int, _ connectedGrid: inout [[Int]], _ parentID: Int, _ currentLength: inout Int) {\\n        connectedGrid[row][col] = parentID\\n        for (r, c) in [(0, -1), (-1, 0), (0, 1), (1, 0)] {\\n            let (newR, newC) = (row + r, col + c)\\n            if newR < 0 || newR >= connectedGrid.count || newC < 0 || newC >= connectedGrid[0].count || connectedGrid[newR][newC] != 1 {\\n                continue\\n            }\\n            currentLength += 1\\n            largestIslandDFSHelper(newR, newC, &connectedGrid, parentID, &currentLength)\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1616168,
                "title": "self-explanatory-solution-with-o-rows-cols-time",
                "content": "```\\nclass Solution {\\n    private int [][]dirs = {\\n        {0, 1},\\n        {0, -1},\\n        {1, 0},\\n        {-1, 0}\\n    };\\n        \\n    public int largestIsland(int[][] grid) {\\n        if(grid == null || grid.length == 0){\\n            return 0;\\n        }\\n        \\n        Map<Integer, Integer> islandMap = new HashMap<>();\\n        int key = 2;\\n        int ans =  0;\\n        \\n        //calculate area of each island and name them with unique key\\n        for(int i=0; i<grid.length; i++){\\n            for(int j=0; j<grid[0].length; j++){\\n                if(grid[i][j] == 1){\\n                    int area = dfs(grid, i, j, key);\\n                    ans = Math.max(area, ans);\\n                    islandMap.put(key,area);\\n                    key++;\\n                }\\n            }\\n        }\\n        \\n        \\n        // now check every possible 0 and its neighbor islands\\n        for(int i=0; i<grid.length; i++){\\n            for(int j=0; j<grid[0].length; j++){\\n                if(grid[i][j] == 0){\\n                    ans = Math.max(ans, checkNeighborIslands(grid, i, j, islandMap));\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private int checkNeighborIslands(int [][]grid, int r, int c, Map<Integer, Integer> islandMap){\\n        int neighborIslandArea = 0;\\n        Set<Integer> seen = new HashSet<>();\\n        \\n        for(int []dir : dirs){\\n            int nr = dir[0] + r;\\n            int nc = dir[1] + c;\\n            \\n            if(nr >= 0 && nc >= 0 && nr < grid.length && nc < grid[0].length && islandMap.containsKey(grid[nr][nc]) && !seen.contains(grid[nr][nc])){\\n                neighborIslandArea += islandMap.get(grid[nr][nc]);\\n                seen.add(grid[nr][nc]);\\n            }\\n        }\\n        \\n        return neighborIslandArea + 1;\\n    }\\n    \\n    \\n    private int dfs(int [][]grid, int r, int c, int key){\\n        if(r >= 0 && c >= 0 && r < grid.length && c < grid[0].length && grid[r][c] == 1){\\n            grid[r][c] = key;\\n            \\n            int ans = 1;\\n            for(int []dir : dirs){\\n                int nr = r + dir[0];\\n                int nc = c + dir[1];\\n                \\n              ans += dfs(grid, nr, nc, key);\\n            }\\n            \\n            return ans;\\n        }\\n        \\n        return 0;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    private int [][]dirs = {\\n        {0, 1},\\n        {0, -1},\\n        {1, 0},\\n        {-1, 0}\\n    };\\n        \\n    public int largestIsland(int[][] grid) {\\n        if(grid == null || grid.length == 0){\\n            return 0;\\n        }\\n        \\n        Map<Integer, Integer> islandMap = new HashMap<>();\\n        int key = 2;\\n        int ans =  0;\\n        \\n        //calculate area of each island and name them with unique key\\n        for(int i=0; i<grid.length; i++){\\n            for(int j=0; j<grid[0].length; j++){\\n                if(grid[i][j] == 1){\\n                    int area = dfs(grid, i, j, key);\\n                    ans = Math.max(area, ans);\\n                    islandMap.put(key,area);\\n                    key++;\\n                }\\n            }\\n        }\\n        \\n        \\n        // now check every possible 0 and its neighbor islands\\n        for(int i=0; i<grid.length; i++){\\n            for(int j=0; j<grid[0].length; j++){\\n                if(grid[i][j] == 0){\\n                    ans = Math.max(ans, checkNeighborIslands(grid, i, j, islandMap));\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private int checkNeighborIslands(int [][]grid, int r, int c, Map<Integer, Integer> islandMap){\\n        int neighborIslandArea = 0;\\n        Set<Integer> seen = new HashSet<>();\\n        \\n        for(int []dir : dirs){\\n            int nr = dir[0] + r;\\n            int nc = dir[1] + c;\\n            \\n            if(nr >= 0 && nc >= 0 && nr < grid.length && nc < grid[0].length && islandMap.containsKey(grid[nr][nc]) && !seen.contains(grid[nr][nc])){\\n                neighborIslandArea += islandMap.get(grid[nr][nc]);\\n                seen.add(grid[nr][nc]);\\n            }\\n        }\\n        \\n        return neighborIslandArea + 1;\\n    }\\n    \\n    \\n    private int dfs(int [][]grid, int r, int c, int key){\\n        if(r >= 0 && c >= 0 && r < grid.length && c < grid[0].length && grid[r][c] == 1){\\n            grid[r][c] = key;\\n            \\n            int ans = 1;\\n            for(int []dir : dirs){\\n                int nr = r + dir[0];\\n                int nc = c + dir[1];\\n                \\n              ans += dfs(grid, nr, nc, key);\\n            }\\n            \\n            return ans;\\n        }\\n        \\n        return 0;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1615110,
                "title": "c-union-find-dfs-mark-islands-tc-o-n2-sc-o-n2-very-fast",
                "content": "\\n\\n```\\nclass unionFind {\\npublic:\\n    vector<int> rank, parent;\\n    unionFind(int size) {\\n        rank.resize(size + 1);\\n        parent.resize(size + 1);\\n        for (int i = 0; i < size; ++i) {\\n            rank[i] = 1;\\n            parent[i] = i;\\n        }\\n    }\\n    \\n    int find(int node) {\\n        if (node == parent[node]) return parent[node];\\n        return parent[node] = find(parent[node]);\\n    }\\n    \\n    void merge(int x, int y) {\\n        int rootX = find(x);\\n        int rootY = find(y);\\n        if (rootX == rootY) return;\\n        if (rank[rootX] >= rank[rootY]) {\\n            parent[rootY] = rootX;\\n        } else {\\n            parent[rootX] = rootY;\\n        }\\n    }\\n        \\n};\\n    \\n\\nclass Solution {\\npublic:\\n    int n, m;\\n    static const int nax = 501;\\n    bool visited[nax][nax];\\n    bool isValid(int x, int y) {\\n        return (x >= 0 && x < n && y >= 0 && y < m);\\n    }\\n    \\n    int dfs(int x, int y, unionFind &uf, int par, vector<vector<int>>& grid) {\\n        uf.merge(par, x * m + y);\\n        int cnt = 1;\\n        visited[x][y] = true;\\n        int d[] = {-1, 0, 1, 0, -1};\\n        for (int i = 0; i < 4; ++i) {\\n            int u = x + d[i];\\n            int v = y + d[i + 1];\\n            if (isValid(u, v) && grid[u][v] && visited[u][v] == false) {\\n                cnt += dfs(u, v, uf, par, grid);\\n            }\\n        }\\n        return cnt;\\n    }\\n    \\n    int largestIsland(vector<vector<int>>& grid) {\\n        unordered_map<int, int> mp;\\n        n = grid.size();\\n        m = grid[0].size();\\n\\t\\t//we are going to represent each node in a single array\\n        unionFind uf(n * m);\\n        for (int i = 0; i < n; ++i) for (int j = 0; j < m; ++j) visited[i][j] = false;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (visited[i][j] == false && grid[i][j]) {\\n\\t\\t\\t\\t    //Get the number of nodes connected in this island\\n                    int cnt = dfs(i, j, uf, i * m + j, grid);\\n                    mp[i * m + j] = cnt;\\n                }\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (grid[i][j] == 0) {\\n                    int curr = 0;\\n                    int d[] = {-1, 0, 1, 0, -1};\\n                    set<int> s;\\n                    for (int k = 0; k < 4; ++k) {\\n                        int u = i + d[k];\\n                        int v = j + d[k + 1];\\n                        if (isValid(u, v)) {\\n\\t\\t\\t\\t\\t\\t    //get the parent of the current node and where this node belongs\\n\\t\\t\\t\\t\\t\\t    //we will be using current node to merge multiple islands into a single big island\\n                            int par = uf.find(u * m + v);\\n                            s.insert(par);\\n                        }\\n                    }\\n\\t\\t\\t\\t\\tfor (auto a: s) {\\n\\t\\t\\t\\t\\t\\tcurr += mp[a];\\n\\t\\t\\t\\t\\t}\\n                    ans = max(ans, curr + 1);\\n                }\\n            }\\n        }\\n\\t\\t//If the answer remains 0, that means, there was no zero in the matrix.\\n        return (ans == 0? n * m: ans);\\n    }\\n};\\n```\\n\\n\\nUpdate:\\n\\nOne optimization could be done If we are allowed to modify the input grid. Since we need to identify the island using (x, y). We can mark the island in the matrix itself.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int n, m;\\n    static const int nax = 501;\\n    bool visited[nax][nax];\\n    bool isValid(int x, int y) {\\n        return (x >= 0 && x < n && y >= 0 && y < m);\\n    }\\n    \\n    int dfs(int x, int y, int par, vector<vector<int>>& grid) {\\n        int cnt = 1;\\n        visited[x][y] = true;\\n        grid[x][y] = par;\\n        int d[] = {-1, 0, 1, 0, -1};\\n        for (int i = 0; i < 4; ++i) {\\n            int u = x + d[i];\\n            int v = y + d[i + 1];\\n            if (isValid(u, v) && grid[u][v] == 1 && visited[u][v] == false) {\\n                cnt += dfs(u, v, par, grid);\\n            }\\n        }\\n        return cnt;\\n    }\\n    \\n    int largestIsland(vector<vector<int>>& grid) {\\n        unordered_map<int, int> mp;\\n        n = grid.size();\\n        m = grid[0].size();\\n        int islandId = 5;\\n        for (int i = 0; i < n; ++i) for (int j = 0; j < m; ++j) visited[i][j] = false;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (visited[i][j] == false && grid[i][j] == 1) {\\n                    int cnt = dfs(i, j, islandId, grid);\\n                    mp[islandId] = cnt;\\n                    ++islandId;\\n                }\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (grid[i][j] == 0) {\\n                    int curr = 0;\\n                    int d[] = {-1, 0, 1, 0, -1};\\n                    set<int> s;\\n                    for (int k = 0; k < 4; ++k) {\\n                        int u = i + d[k];\\n                        int v = j + d[k + 1];\\n                        if (isValid(u, v)) {\\n                            int par = grid[u][v];\\n                            s.insert(par);\\n                        }\\n                    }\\n                    for (auto a: s) {\\n                        curr += mp[a];\\n                    }\\n                    ans = max(ans, curr + 1);\\n                }\\n            }\\n        }\\n        return (ans == 0? n * m: ans);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass unionFind {\\npublic:\\n    vector<int> rank, parent;\\n    unionFind(int size) {\\n        rank.resize(size + 1);\\n        parent.resize(size + 1);\\n        for (int i = 0; i < size; ++i) {\\n            rank[i] = 1;\\n            parent[i] = i;\\n        }\\n    }\\n    \\n    int find(int node) {\\n        if (node == parent[node]) return parent[node];\\n        return parent[node] = find(parent[node]);\\n    }\\n    \\n    void merge(int x, int y) {\\n        int rootX = find(x);\\n        int rootY = find(y);\\n        if (rootX == rootY) return;\\n        if (rank[rootX] >= rank[rootY]) {\\n            parent[rootY] = rootX;\\n        } else {\\n            parent[rootX] = rootY;\\n        }\\n    }\\n        \\n};\\n    \\n\\nclass Solution {\\npublic:\\n    int n, m;\\n    static const int nax = 501;\\n    bool visited[nax][nax];\\n    bool isValid(int x, int y) {\\n        return (x >= 0 && x < n && y >= 0 && y < m);\\n    }\\n    \\n    int dfs(int x, int y, unionFind &uf, int par, vector<vector<int>>& grid) {\\n        uf.merge(par, x * m + y);\\n        int cnt = 1;\\n        visited[x][y] = true;\\n        int d[] = {-1, 0, 1, 0, -1};\\n        for (int i = 0; i < 4; ++i) {\\n            int u = x + d[i];\\n            int v = y + d[i + 1];\\n            if (isValid(u, v) && grid[u][v] && visited[u][v] == false) {\\n                cnt += dfs(u, v, uf, par, grid);\\n            }\\n        }\\n        return cnt;\\n    }\\n    \\n    int largestIsland(vector<vector<int>>& grid) {\\n        unordered_map<int, int> mp;\\n        n = grid.size();\\n        m = grid[0].size();\\n\\t\\t//we are going to represent each node in a single array\\n        unionFind uf(n * m);\\n        for (int i = 0; i < n; ++i) for (int j = 0; j < m; ++j) visited[i][j] = false;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (visited[i][j] == false && grid[i][j]) {\\n\\t\\t\\t\\t    //Get the number of nodes connected in this island\\n                    int cnt = dfs(i, j, uf, i * m + j, grid);\\n                    mp[i * m + j] = cnt;\\n                }\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (grid[i][j] == 0) {\\n                    int curr = 0;\\n                    int d[] = {-1, 0, 1, 0, -1};\\n                    set<int> s;\\n                    for (int k = 0; k < 4; ++k) {\\n                        int u = i + d[k];\\n                        int v = j + d[k + 1];\\n                        if (isValid(u, v)) {\\n\\t\\t\\t\\t\\t\\t    //get the parent of the current node and where this node belongs\\n\\t\\t\\t\\t\\t\\t    //we will be using current node to merge multiple islands into a single big island\\n                            int par = uf.find(u * m + v);\\n                            s.insert(par);\\n                        }\\n                    }\\n\\t\\t\\t\\t\\tfor (auto a: s) {\\n\\t\\t\\t\\t\\t\\tcurr += mp[a];\\n\\t\\t\\t\\t\\t}\\n                    ans = max(ans, curr + 1);\\n                }\\n            }\\n        }\\n\\t\\t//If the answer remains 0, that means, there was no zero in the matrix.\\n        return (ans == 0? n * m: ans);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int n, m;\\n    static const int nax = 501;\\n    bool visited[nax][nax];\\n    bool isValid(int x, int y) {\\n        return (x >= 0 && x < n && y >= 0 && y < m);\\n    }\\n    \\n    int dfs(int x, int y, int par, vector<vector<int>>& grid) {\\n        int cnt = 1;\\n        visited[x][y] = true;\\n        grid[x][y] = par;\\n        int d[] = {-1, 0, 1, 0, -1};\\n        for (int i = 0; i < 4; ++i) {\\n            int u = x + d[i];\\n            int v = y + d[i + 1];\\n            if (isValid(u, v) && grid[u][v] == 1 && visited[u][v] == false) {\\n                cnt += dfs(u, v, par, grid);\\n            }\\n        }\\n        return cnt;\\n    }\\n    \\n    int largestIsland(vector<vector<int>>& grid) {\\n        unordered_map<int, int> mp;\\n        n = grid.size();\\n        m = grid[0].size();\\n        int islandId = 5;\\n        for (int i = 0; i < n; ++i) for (int j = 0; j < m; ++j) visited[i][j] = false;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (visited[i][j] == false && grid[i][j] == 1) {\\n                    int cnt = dfs(i, j, islandId, grid);\\n                    mp[islandId] = cnt;\\n                    ++islandId;\\n                }\\n            }\\n        }\\n        \\n        int ans = 0;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (grid[i][j] == 0) {\\n                    int curr = 0;\\n                    int d[] = {-1, 0, 1, 0, -1};\\n                    set<int> s;\\n                    for (int k = 0; k < 4; ++k) {\\n                        int u = i + d[k];\\n                        int v = j + d[k + 1];\\n                        if (isValid(u, v)) {\\n                            int par = grid[u][v];\\n                            s.insert(par);\\n                        }\\n                    }\\n                    for (auto a: s) {\\n                        curr += mp[a];\\n                    }\\n                    ans = max(ans, curr + 1);\\n                }\\n            }\\n        }\\n        return (ans == 0? n * m: ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1602736,
                "title": "java-146ms-with-comments",
                "content": "```\\nclass Solution {\\n    public int largestIsland(int[][] grid) {\\n        \\n        int gridSize = grid.length * grid[0].length;\\n        \\n        // find connecting points between two islands\\n        // basically 0s sorrounded by at least two 1s\\n        Set<int[]> connections = new HashSet<>();\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                int count = 0;\\n                if (grid[i][j] == 0) {\\n                    count += i > 0 ? grid[i - 1][j] : 0;\\n                    count += i < grid.length - 1 ? grid[i + 1][j] : 0;\\n                    count += j > 0 ? grid[i][j - 1] : 0;\\n                    count += j < grid[0].length - 1 ? grid[i][j + 1] : 0;\\n                    if (count > 1) {\\n                        connections.add(new int[] { i, j });\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if (connections.isEmpty()) {\\n            // no connecting points\\n            int count = 0;\\n            for (int i = 0; i < grid.length; i++) {\\n                for (int j = 0; j < grid[0].length; j++) {                \\n                    if (grid[i][j] == 1) {\\n                        count++;\\n                    }\\n                }\\n            }\\n            // edge case all 1s\\n            return count == gridSize ? count : count + 1;\\n        }\\n        \\n        // islands are named starting with 2 and incrementing by 1\\n        // maintaing count per island\\n        Map<String, Integer> islandSizeMap = new HashMap<>();        \\n        int island = 2;\\n        \\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                \\n                if (grid[i][j] != 1) {\\n                    // previously calculated island or 0. ignore it.\\n                    continue;\\n                }\\n\\n                Queue<int[]> queue = new LinkedList<>();\\n                queue.add(new int[] { i, j });\\n\\n                int size = 0;\\n                String name = String.valueOf(island);\\n                \\n                while (!queue.isEmpty()) {\\n                    int[] pos = queue.poll();\\n                    int row = pos[0];\\n                    int col = pos[1];\\n                    \\n                    if (grid[row][col] != 1) {\\n                        // we could add duplicate 1s whose value must have been\\n                        // already updated with island number. ignore them.\\n                        continue;\\n                    }\\n                    \\n                    grid[row][col] = island;                    \\n                    size++;\\n\\n                    if (row > 0 && grid[row - 1][col] == 1) {\\n                        queue.add(new int[] { row - 1, col });\\n                    }\\n                    if (row < grid.length - 1 && grid[row + 1][col] == 1) {\\n                        queue.add(new int[] { row + 1, col });\\n                    }\\n                    if (col > 0 && grid[row][col - 1] == 1) {\\n                        queue.add(new int[] { row, col - 1 });\\n                    }\\n                    if (col < grid[0].length - 1 && grid[row][col + 1] == 1) {\\n                        queue.add(new int[] { row, col + 1 });\\n                    }\\n                }\\n\\n                // add island size per island\\n                islandSizeMap.put(name, size);   \\n                // proceed to name next island\\n                island++;\\n            }\\n        }\\n        \\n        int maxSize = 0;        \\n        \\n        for (int[] connection : connections) {\\n            int row = connection[0];\\n            int col = connection[1];\\n            \\n            // finding connecting islands for every connection point\\n            Set<Integer> neighborIslands = new HashSet<>(4);\\n            \\n            if (row > 0 && grid[row - 1][col] > 0) {\\n                neighborIslands.add(grid[row - 1][col]);\\n            }\\n            if (row < grid.length - 1 && grid[row + 1][col] > 0) {\\n                neighborIslands.add(grid[row + 1][col]);\\n            }\\n            if (col > 0 && grid[row][col - 1] > 0) {\\n                neighborIslands.add(grid[row][col - 1]);\\n            }\\n            if (col < grid[0].length - 1 && grid[row][col + 1] > 0) {\\n                neighborIslands.add(grid[row][col + 1]);\\n            }\\n            \\n            int total = 0;\\n            for (int neighborIsland : neighborIslands) {\\n                total += islandSizeMap.get(String.valueOf(neighborIsland));\\n            }\\n            // comparing the total size against max found so far\\n            maxSize = Math.max(maxSize, total);\\n        }\\n        \\n        // +1 for including the connection point\\n        return maxSize + 1;\\n    }    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int largestIsland(int[][] grid) {\\n        \\n        int gridSize = grid.length * grid[0].length;\\n        \\n        // find connecting points between two islands\\n        // basically 0s sorrounded by at least two 1s\\n        Set<int[]> connections = new HashSet<>();\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                int count = 0;\\n                if (grid[i][j] == 0) {\\n                    count += i > 0 ? grid[i - 1][j] : 0;\\n                    count += i < grid.length - 1 ? grid[i + 1][j] : 0;\\n                    count += j > 0 ? grid[i][j - 1] : 0;\\n                    count += j < grid[0].length - 1 ? grid[i][j + 1] : 0;\\n                    if (count > 1) {\\n                        connections.add(new int[] { i, j });\\n                    }\\n                }\\n            }\\n        }\\n        \\n        if (connections.isEmpty()) {\\n            // no connecting points\\n            int count = 0;\\n            for (int i = 0; i < grid.length; i++) {\\n                for (int j = 0; j < grid[0].length; j++) {                \\n                    if (grid[i][j] == 1) {\\n                        count++;\\n                    }\\n                }\\n            }\\n            // edge case all 1s\\n            return count == gridSize ? count : count + 1;\\n        }\\n        \\n        // islands are named starting with 2 and incrementing by 1\\n        // maintaing count per island\\n        Map<String, Integer> islandSizeMap = new HashMap<>();        \\n        int island = 2;\\n        \\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                \\n                if (grid[i][j] != 1) {\\n                    // previously calculated island or 0. ignore it.\\n                    continue;\\n                }\\n\\n                Queue<int[]> queue = new LinkedList<>();\\n                queue.add(new int[] { i, j });\\n\\n                int size = 0;\\n                String name = String.valueOf(island);\\n                \\n                while (!queue.isEmpty()) {\\n                    int[] pos = queue.poll();\\n                    int row = pos[0];\\n                    int col = pos[1];\\n                    \\n                    if (grid[row][col] != 1) {\\n                        // we could add duplicate 1s whose value must have been\\n                        // already updated with island number. ignore them.\\n                        continue;\\n                    }\\n                    \\n                    grid[row][col] = island;                    \\n                    size++;\\n\\n                    if (row > 0 && grid[row - 1][col] == 1) {\\n                        queue.add(new int[] { row - 1, col });\\n                    }\\n                    if (row < grid.length - 1 && grid[row + 1][col] == 1) {\\n                        queue.add(new int[] { row + 1, col });\\n                    }\\n                    if (col > 0 && grid[row][col - 1] == 1) {\\n                        queue.add(new int[] { row, col - 1 });\\n                    }\\n                    if (col < grid[0].length - 1 && grid[row][col + 1] == 1) {\\n                        queue.add(new int[] { row, col + 1 });\\n                    }\\n                }\\n\\n                // add island size per island\\n                islandSizeMap.put(name, size);   \\n                // proceed to name next island\\n                island++;\\n            }\\n        }\\n        \\n        int maxSize = 0;        \\n        \\n        for (int[] connection : connections) {\\n            int row = connection[0];\\n            int col = connection[1];\\n            \\n            // finding connecting islands for every connection point\\n            Set<Integer> neighborIslands = new HashSet<>(4);\\n            \\n            if (row > 0 && grid[row - 1][col] > 0) {\\n                neighborIslands.add(grid[row - 1][col]);\\n            }\\n            if (row < grid.length - 1 && grid[row + 1][col] > 0) {\\n                neighborIslands.add(grid[row + 1][col]);\\n            }\\n            if (col > 0 && grid[row][col - 1] > 0) {\\n                neighborIslands.add(grid[row][col - 1]);\\n            }\\n            if (col < grid[0].length - 1 && grid[row][col + 1] > 0) {\\n                neighborIslands.add(grid[row][col + 1]);\\n            }\\n            \\n            int total = 0;\\n            for (int neighborIsland : neighborIslands) {\\n                total += islandSizeMap.get(String.valueOf(neighborIsland));\\n            }\\n            // comparing the total size against max found so far\\n            maxSize = Math.max(maxSize, total);\\n        }\\n        \\n        // +1 for including the connection point\\n        return maxSize + 1;\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1598036,
                "title": "java-dfs-n-2",
                "content": "```\\nclass Solution {\\n    private Map<Integer, Integer> areaMap;\\n    private int N;\\n    \\n    // up, down, left, right\\n    private int[][] moves = {\\n        { -1, 0 }, { 1, 0 }, { 0, -1 }, { 0, 1 }\\n    };\\n    \\n    private int getIslandArea(int[][] grid, int index, int r, int c) {\\n        int islandArea = 1;\\n        \\n        grid[r][c] = index;\\n        \\n        for (int[] move : moves) {\\n            int nr = r + move[0];\\n            int nc = c + move[1];\\n            \\n            if (nr < 0 || nc < 0 || nr >= N || nc >= N || grid[nr][nc] != 1) {\\n                continue;\\n            }\\n \\n            islandArea += getIslandArea(grid, index, nr, nc);   \\n        }\\n        \\n        return islandArea;\\n    }\\n    \\n    private int getNeighborIslandArea(int[][] grid, int r, int c) {\\n        int neighborAreas = 1;\\n                    \\n        Set<Integer> visitedIslands = new HashSet<>();\\n\\n        for (int[] move : moves) {\\n            int nr = r + move[0];\\n            int nc = c + move[1];\\n\\n            if (nr < 0 || nc < 0 || nr >= N || nc >= N) {\\n                continue;\\n            }\\n\\n            int index = grid[nr][nc];\\n\\n            if (index > 0 && !visitedIslands.contains(index)) {\\n                neighborAreas += areaMap.get(index);\\n                visitedIslands.add(index);\\n            }\\n        }\\n        \\n        return neighborAreas;\\n    }\\n    \\n    public int largestIsland(int[][] grid) {\\n        this.N = grid.length;\\n        this.areaMap = new HashMap<>();\\n        \\n        int islandIndex = 2;\\n        int maxIsland = 0;\\n        \\n        // Find areas and map island index to grid\\n        for (int r = 0; r < N; r++) {\\n            for (int c = 0; c < N; c++) {\\n                if (grid[r][c] == 1) {\\n                    int area = getIslandArea(grid, islandIndex, r, c);\\n                    maxIsland = Math.max(maxIsland, area);\\n                    areaMap.put(islandIndex++, area);\\n                }\\n            }\\n        }\\n\\n        // Connect two or more neighboring islands\\n        for (int r = 0; r < N; r++) {\\n            for (int c = 0; c < N; c++) {\\n                if (grid[r][c] == 0) {\\n                    int area = getNeighborIslandArea(grid, r, c);\\n                    maxIsland = Math.max(maxIsland, area);\\n                }\\n            }\\n        }\\n        \\n        return maxIsland;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private Map<Integer, Integer> areaMap;\\n    private int N;\\n    \\n    // up, down, left, right\\n    private int[][] moves = {\\n        { -1, 0 }, { 1, 0 }, { 0, -1 }, { 0, 1 }\\n    };\\n    \\n    private int getIslandArea(int[][] grid, int index, int r, int c) {\\n        int islandArea = 1;\\n        \\n        grid[r][c] = index;\\n        \\n        for (int[] move : moves) {\\n            int nr = r + move[0];\\n            int nc = c + move[1];\\n            \\n            if (nr < 0 || nc < 0 || nr >= N || nc >= N || grid[nr][nc] != 1) {\\n                continue;\\n            }\\n \\n            islandArea += getIslandArea(grid, index, nr, nc);   \\n        }\\n        \\n        return islandArea;\\n    }\\n    \\n    private int getNeighborIslandArea(int[][] grid, int r, int c) {\\n        int neighborAreas = 1;\\n                    \\n        Set<Integer> visitedIslands = new HashSet<>();\\n\\n        for (int[] move : moves) {\\n            int nr = r + move[0];\\n            int nc = c + move[1];\\n\\n            if (nr < 0 || nc < 0 || nr >= N || nc >= N) {\\n                continue;\\n            }\\n\\n            int index = grid[nr][nc];\\n\\n            if (index > 0 && !visitedIslands.contains(index)) {\\n                neighborAreas += areaMap.get(index);\\n                visitedIslands.add(index);\\n            }\\n        }\\n        \\n        return neighborAreas;\\n    }\\n    \\n    public int largestIsland(int[][] grid) {\\n        this.N = grid.length;\\n        this.areaMap = new HashMap<>();\\n        \\n        int islandIndex = 2;\\n        int maxIsland = 0;\\n        \\n        // Find areas and map island index to grid\\n        for (int r = 0; r < N; r++) {\\n            for (int c = 0; c < N; c++) {\\n                if (grid[r][c] == 1) {\\n                    int area = getIslandArea(grid, islandIndex, r, c);\\n                    maxIsland = Math.max(maxIsland, area);\\n                    areaMap.put(islandIndex++, area);\\n                }\\n            }\\n        }\\n\\n        // Connect two or more neighboring islands\\n        for (int r = 0; r < N; r++) {\\n            for (int c = 0; c < N; c++) {\\n                if (grid[r][c] == 0) {\\n                    int area = getNeighborIslandArea(grid, r, c);\\n                    maxIsland = Math.max(maxIsland, area);\\n                }\\n            }\\n        }\\n        \\n        return maxIsland;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1593636,
                "title": "python-dfs-wondeirng-if-any-optimize-i-belive-it-is-o-nxn-o-nxn-easier-understand",
                "content": "\\n```\\nclass Solution:\\n    def largestIsland(self, grid: List[List[int]]) -> int:\\n        if not grid:\\n            return \\n        \\n\\t\\t# DFS find islands size\\n        def dfs(i,j, color):\\n            grid[i][j] = color\\n            count = 1\\n            for m,n in [(i+1,j),(i-1,j),(i,j+1),(i,j-1)]:\\n                if 0 <= m < length and 0 <= n < length and grid[m][n] == 1:\\n                    count += dfs(m,n,color)\\n            return count    \\n                    \\n        \\n        # LOOP grid to record water(all 0s), island(1s), and islands size {2:size, 3:size ...}\\n        length = len(grid)\\n        color = 2\\n        water = set()\\n        island = defaultdict(int)\\n        for i in range(length):\\n            for j in range(length):\\n                if grid[i][j] == 0:\\n                    water.add((i,j))\\n                elif grid[i][j] == 1:\\n                    size = dfs(i,j, color)\\n                    island[color] = size\\n                    color += 1\\n        \\n        # print(grid)\\n        # print(island)\\n        # print(water)\\n\\t\\t# if no water, return n x n\\n        if len(water) == 0: return length*length\\n\\t\\t\\n\\t\\t# LOOP all water try to change it to 1 and find 4 directions adding size if any saved islands, and then find the larger one\\n        large_island = 0\\n        for x,y in water:\\n            now_island = 1     # as we changed this water to 1, so, init current_island size = 1\\n            visit = set()           # just in case 4 directions has the same saved islands visited\\n            for r,c in [(x+1,y),(x-1,y),(x,y+1),(x,y-1)]:\\n                if 0 <= r < length and 0 <= c < length:\\n                    col = grid[r][c]\\n                    if col not in visit and col in island:\\n                        now_island += island[col]\\n                        visit.add(col)\\n            large_island = max(large_island, now_island)\\n        \\n        return large_island\\n    \\n    \\n     # [1,0,1,0],\\n     # [0,1,1,0],\\n     # [1,0,0,1],\\n     # [1,0,1,0]\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "class Solution:\\n    def largestIsland(self, grid: List[List[int]]) -> int:\\n        if not grid:\\n            return \\n        \\n\\t\\t# DFS find islands size\\n        def dfs(i,j, color):\\n            grid[i][j] = color\\n            count = 1\\n            for m,n in [(i+1,j),(i-1,j),(i,j+1),(i,j-1)]:\\n                if 0 <= m < length and 0 <= n < length and grid[m][n] == 1:\\n                    count += dfs(m,n,color)\\n            return count    \\n                    \\n        \\n        # LOOP grid to record water(all 0s), island(1s), and islands size {2:size, 3:size ...}",
                "codeTag": "Java"
            },
            {
                "id": 1585472,
                "title": "c-bfs-dfs-clean-code-easy-understand-explanation-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n     \\n    // for calculating the area and \\'unique-id\\' of the island\\n     void dfs(vector<vector<int>> &grid, unordered_map<int,int>&mp, int i, int j, int island_id)\\n     {\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size())\\n            return;\\n        if(grid[i][j]!=1)\\n            return;\\n         \\n        mp[island_id]++; // (id, area)\\n        grid[i][j] = island_id; // It is also marked as visited automatically while setting the \\'id\\'\\n         \\n        dfs(grid,mp,i+1,j,island_id);\\n        dfs(grid,mp,i-1,j,island_id);\\n        dfs(grid,mp,i,j+1,island_id);\\n        dfs(grid,mp,i,j-1,island_id);\\n    }\\n    \\n    int largestIsland(vector<vector<int>>& grid) {\\n        \\n        int m=grid.size(), n=grid[0].size(), island_id=2;\\n        unordered_map<int,int> mp;\\n        int dx[4]={1,-1,0,0};\\n        int dy[4]={0,0,1,-1};\\n        \\n        int area=0;        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1){\\n                    dfs(grid,mp,i,j,island_id);\\n\\t\\t\\t\\t\\t// We have to find the largest island in case there are no 0\\'s in the grid\\n                    area=max(area,mp[island_id]);// It is useful when all islands are far away for each other by two or more cells\\n                    island_id++;\\n                }\\n           }\\n        }\\n        \\n        \\n        // BFS starts...\\n        // we will push the 0\\'s in the queue. From each 0, we will start a bfs of size 1\\n        queue<pair<int,int>> q;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==0)\\n                    q.push({i,j});\\n            }\\n        }\\n        \\n        while(!q.empty())\\n        {\\n            auto p = q.front();\\n            q.pop();\\n            int x = p.first;\\n            int y = p.second;\\n            // Unordered Set to make sure the islands are unique\\n            unordered_set<int> s;\\n            int tmp = 1; // tmp == 1 because current cell also counts in area (when it is changing from \\'0\\' to \\'1\\')\\n            for(int i=0;i<4;i++)\\n            {\\n                int r = x+dx[i];\\n                int c = y+dy[i];\\n                if(r>=0 && r<=m-1 && c>=0 && c<=n-1 && grid[r][c] != 0)\\n                {\\n                    // BFS of Size - 1 \\n\\t\\t\\t\\t\\t// we do not need to push here because we pushed  already all coordinates where cell has  \\'zero\\' \\n                    int i_id = grid[r][c]; // get island id  \\n                    if(s.find(i_id)==s.end()){ // using set for Optimization : because it may be possible that cell has \\'0\\' surrounded by same island by more than one sides. out of \\'4\\'\\n                        s.insert(i_id);\\n                        tmp+=mp[i_id]; //summation of area of all islands which are near to \\'0\\' cell. \\n                    }    \\n                }\\n            }\\n            \\n            area = max(area, tmp);\\n            \\n        }\\n        return area;\\n    }\\n};\\n```\\n**Please Upvote if it helps you : )**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n     \\n    // for calculating the area and \\'unique-id\\' of the island\\n     void dfs(vector<vector<int>> &grid, unordered_map<int,int>&mp, int i, int j, int island_id)\\n     {\\n        if(i<0 || j<0 || i>=grid.size() || j>=grid[0].size())\\n            return;\\n        if(grid[i][j]!=1)\\n            return;\\n         \\n        mp[island_id]++; // (id, area)\\n        grid[i][j] = island_id; // It is also marked as visited automatically while setting the \\'id\\'\\n         \\n        dfs(grid,mp,i+1,j,island_id);\\n        dfs(grid,mp,i-1,j,island_id);\\n        dfs(grid,mp,i,j+1,island_id);\\n        dfs(grid,mp,i,j-1,island_id);\\n    }\\n    \\n    int largestIsland(vector<vector<int>>& grid) {\\n        \\n        int m=grid.size(), n=grid[0].size(), island_id=2;\\n        unordered_map<int,int> mp;\\n        int dx[4]={1,-1,0,0};\\n        int dy[4]={0,0,1,-1};\\n        \\n        int area=0;        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1){\\n                    dfs(grid,mp,i,j,island_id);\\n\\t\\t\\t\\t\\t// We have to find the largest island in case there are no 0\\'s in the grid\\n                    area=max(area,mp[island_id]);// It is useful when all islands are far away for each other by two or more cells\\n                    island_id++;\\n                }\\n           }\\n        }\\n        \\n        \\n        // BFS starts...\\n        // we will push the 0\\'s in the queue. From each 0, we will start a bfs of size 1\\n        queue<pair<int,int>> q;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==0)\\n                    q.push({i,j});\\n            }\\n        }\\n        \\n        while(!q.empty())\\n        {\\n            auto p = q.front();\\n            q.pop();\\n            int x = p.first;\\n            int y = p.second;\\n            // Unordered Set to make sure the islands are unique\\n            unordered_set<int> s;\\n            int tmp = 1; // tmp == 1 because current cell also counts in area (when it is changing from \\'0\\' to \\'1\\')\\n            for(int i=0;i<4;i++)\\n            {\\n                int r = x+dx[i];\\n                int c = y+dy[i];\\n                if(r>=0 && r<=m-1 && c>=0 && c<=n-1 && grid[r][c] != 0)\\n                {\\n                    // BFS of Size - 1 \\n\\t\\t\\t\\t\\t// we do not need to push here because we pushed  already all coordinates where cell has  \\'zero\\' \\n                    int i_id = grid[r][c]; // get island id  \\n                    if(s.find(i_id)==s.end()){ // using set for Optimization : because it may be possible that cell has \\'0\\' surrounded by same island by more than one sides. out of \\'4\\'\\n                        s.insert(i_id);\\n                        tmp+=mp[i_id]; //summation of area of all islands which are near to \\'0\\' cell. \\n                    }    \\n                }\\n            }\\n            \\n            area = max(area, tmp);\\n            \\n        }\\n        return area;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1543018,
                "title": "python-simple-explained-with-comments-and-image",
                "content": "More notes:\\n- https://paulonteri.notion.site/Union-find-disjoint-set-ebb6361b79834fa6a82d0e410b6af9a2\\n- https://github.com/paulonteri/data-structures-and-algorithms\\n\\nIsland visualization:\\n![image](https://assets.leetcode.com/users/images/26a5beea-7c27-4804-b1ba-4b4737945423_1635312110.4245791.png)\\n\\n\\n```\\nfrom collections import defaultdict\\nfrom typing import List\\n\\n\\n# O(N^2) time | O(N^2) space\\n# we traverse the graph twice in the worst case, for time, and only store row*col nodes, for space\\nclass Solution:\\n    def largestIsland(self, grid: List[List[int]]):\\n        \"\"\" \\n        * Based on union find: https://www.notion.so/paulonteri/Trees-Graphs-edc3401e06c044f29a2d714d20ffe185#02cd6da5a64447feab03037d22d40b38\\n\\n        - Group nodes into different islands\\n            - store the island sizes\\n            - record the island_id for each node\\n        - For each 0, try to merge its surrounding islands\\n        \"\"\"\\n        island_sizes, child_to_island_id = self.create_islands(grid)\\n\\n        largest_island = 0\\n        if island_sizes:\\n            largest_island = max(island_sizes.values())\\n\\n        for row in range(len(grid)):\\n            for col in range(len(grid[0])):\\n                if grid[row][col] != 0:\\n                    continue\\n                \"\"\" \\n                Try to connect the surrounding islands\\n                if we have seen the island before, we don\\'t need to do anything\\n                \"\"\"\\n                seen_island_ids = set()\\n\\n                top_island, top = self.get_node_island_and_size(grid, row-1, col, island_sizes, child_to_island_id)\\n                seen_island_ids.add(top_island)\\n\\n                bottom_island, bottom = self.get_node_island_and_size(grid, row+1, col, island_sizes, child_to_island_id)\\n                # is part of an island we saw above (in this case part of top_island)\\n                if bottom_island in seen_island_ids:\\n                    bottom = 0\\n                seen_island_ids.add(bottom_island)\\n\\n                left_island, left = self.get_node_island_and_size(grid, row, col-1, island_sizes, child_to_island_id)\\n                if left_island in seen_island_ids:\\n                    left = 0\\n                seen_island_ids.add(left_island)\\n\\n                right_island, right = self.get_node_island_and_size(grid, row, col+1, island_sizes, child_to_island_id)\\n                if right_island in seen_island_ids:\\n                    right = 0\\n                seen_island_ids.add(right_island)\\n\\n                # merge all neighbouring islands + the current node (1)\\n                largest_island = max(largest_island, 1+top+bottom+left+right)\\n\\n        return largest_island\\n\\n    def get_node_island_and_size(self, grid, row, col, island_sizes, child_to_island_id):\\n        \"\"\" Returns the node\\'s island_id and size \"\"\"\\n        if row < 0 or col < 0 or row >= len(grid) or col >= len(grid[0]):\\n            return None, 0\\n        if grid[row][col] == 0:\\n            return None, 0\\n        island_id = child_to_island_id[(row, col)]\\n        return island_id, island_sizes[island_id]\\n\\n    def create_islands(self, grid: List[List[int]]):\\n        \"\"\"\\n        Creates islands\\n        - returns:\\n            - a dict of { `island_id` -> `island_size` }\\n            - a dict of {`child/node` -> `island_id` }\\n        \"\"\"\\n        island_sizes = defaultdict(int)\\n        child_to_island_id = {}\\n\\n        def group_into_island(row, col, island_id):\\n            if row < 0 or col < 0 or row >= len(grid) or col >= len(grid[0]):\\n                return\\n            if (row, col) in child_to_island_id:\\n                return  # skip if part of an island\\n            if grid[row][col] == 0:\\n                return\\n\\n            island_sizes[island_id] += 1\\n            child_to_island_id[(row, col)] = island_id\\n\\n            group_into_island(row-1, col, island_id)\\n            group_into_island(row, col-1, island_id)\\n            group_into_island(row+1, col, island_id)\\n            group_into_island(row, col+1, island_id)\\n\\n        curr_id = -1\\n        for row in range(len(grid)):\\n            for col in range(len(grid[0])):\\n                group_into_island(row, col, curr_id)\\n                curr_id -= 1\\n\\n        return island_sizes, child_to_island_id\\n\\n\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Union Find"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom typing import List\\n\\n\\n# O(N^2) time | O(N^2) space\\n# we traverse the graph twice in the worst case, for time, and only store row*col nodes, for space\\nclass Solution:\\n    def largestIsland(self, grid: List[List[int]]):\\n        \"\"\" \\n        * Based on union find: https://www.notion.so/paulonteri/Trees-Graphs-edc3401e06c044f29a2d714d20ffe185#02cd6da5a64447feab03037d22d40b38\\n\\n        - Group nodes into different islands\\n            - store the island sizes\\n            - record the island_id for each node\\n        - For each 0, try to merge its surrounding islands\\n        \"\"\"\\n        island_sizes, child_to_island_id = self.create_islands(grid)\\n\\n        largest_island = 0\\n        if island_sizes:\\n            largest_island = max(island_sizes.values())\\n\\n        for row in range(len(grid)):\\n            for col in range(len(grid[0])):\\n                if grid[row][col] != 0:\\n                    continue\\n                \"\"\" \\n                Try to connect the surrounding islands\\n                if we have seen the island before, we don\\'t need to do anything\\n                \"\"\"\\n                seen_island_ids = set()\\n\\n                top_island, top = self.get_node_island_and_size(grid, row-1, col, island_sizes, child_to_island_id)\\n                seen_island_ids.add(top_island)\\n\\n                bottom_island, bottom = self.get_node_island_and_size(grid, row+1, col, island_sizes, child_to_island_id)\\n                # is part of an island we saw above (in this case part of top_island)\\n                if bottom_island in seen_island_ids:\\n                    bottom = 0\\n                seen_island_ids.add(bottom_island)\\n\\n                left_island, left = self.get_node_island_and_size(grid, row, col-1, island_sizes, child_to_island_id)\\n                if left_island in seen_island_ids:\\n                    left = 0\\n                seen_island_ids.add(left_island)\\n\\n                right_island, right = self.get_node_island_and_size(grid, row, col+1, island_sizes, child_to_island_id)\\n                if right_island in seen_island_ids:\\n                    right = 0\\n                seen_island_ids.add(right_island)\\n\\n                # merge all neighbouring islands + the current node (1)\\n                largest_island = max(largest_island, 1+top+bottom+left+right)\\n\\n        return largest_island\\n\\n    def get_node_island_and_size(self, grid, row, col, island_sizes, child_to_island_id):\\n        \"\"\" Returns the node\\'s island_id and size \"\"\"\\n        if row < 0 or col < 0 or row >= len(grid) or col >= len(grid[0]):\\n            return None, 0\\n        if grid[row][col] == 0:\\n            return None, 0\\n        island_id = child_to_island_id[(row, col)]\\n        return island_id, island_sizes[island_id]\\n\\n    def create_islands(self, grid: List[List[int]]):\\n        \"\"\"\\n        Creates islands\\n        - returns:\\n            - a dict of { `island_id` -> `island_size` }\\n            - a dict of {`child/node` -> `island_id` }\\n        \"\"\"\\n        island_sizes = defaultdict(int)\\n        child_to_island_id = {}\\n\\n        def group_into_island(row, col, island_id):\\n            if row < 0 or col < 0 or row >= len(grid) or col >= len(grid[0]):\\n                return\\n            if (row, col) in child_to_island_id:\\n                return  # skip if part of an island\\n            if grid[row][col] == 0:\\n                return\\n\\n            island_sizes[island_id] += 1\\n            child_to_island_id[(row, col)] = island_id\\n\\n            group_into_island(row-1, col, island_id)\\n            group_into_island(row, col-1, island_id)\\n            group_into_island(row+1, col, island_id)\\n            group_into_island(row, col+1, island_id)\\n\\n        curr_id = -1\\n        for row in range(len(grid)):\\n            for col in range(len(grid[0])):\\n                group_into_island(row, col, curr_id)\\n                curr_id -= 1\\n\\n        return island_sizes, child_to_island_id\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1519722,
                "title": "python-solution-with-comments",
                "content": "```\\nclass Solution:\\n    def largestIsland(self, grid: List[List[int]]) -> int:        \\n        maxIslandSize = 0\\n        IslandSizeList = [0, 0] # we start the index at 2, because 0, 1 in already used in question\\n        IslandTag = 2 # we start the index at 2\\n        \\n        # First we use recursive to find all the island, \\n        # so we will need to create a helper.\\n        # We also create a IslandTag to split all the island and give them an index.\\n        for column in range(len(grid)):\\n            for row in range(len(grid[0])):\\n                if grid[column][row] == 1:\\n                    islandSize = self.helper(grid, 1, row, column, IslandTag)\\n                    maxIslandSize = max(maxIslandSize, islandSize)\\n                    IslandSizeList.append(islandSize) # store each island size into the IslandSizeList\\n                    IslandTag += 1\\n        \\n        # In our second step, \\n        # we will go through the grid again and find the 0s inside the grid.\\n        # And we check that zero\\'s top, bottom, right, left to see all the island, \\n        # and we add all the island size.\\n        # Last, we always get the greater size value into our maxIslandSize which is the answer.\\n        for column in range(len(grid)):\\n            for row in range(len(grid[0])):\\n                tmpIslandSize = 0\\n                if grid[column][row] == 0:\\n                    tmp = []\\n                    if row > 0 and grid[column][row-1] != 0 and grid[column][row-1] not in tmp:\\n                        tmp.append(grid[column][row-1])\\n                        tmpIslandSize += IslandSizeList[grid[column][row-1]]\\n                    if row < len(grid[0])-1 and grid[column][row+1] != 0 and grid[column][row+1] not in tmp:\\n                        tmp.append(grid[column][row+1])\\n                        tmpIslandSize += IslandSizeList[grid[column][row+1]]\\n                    if column > 0 and grid[column-1][row] != 0 and grid[column-1][row] not in tmp:\\n                        tmp.append(grid[column-1][row])\\n                        tmpIslandSize += IslandSizeList[grid[column-1][row]]\\n                    if column < len(grid)-1 and grid[column+1][row] != 0 and grid[column+1][row] not in tmp:\\n                        tmp.append(grid[column+1][row])\\n                        tmpIslandSize += IslandSizeList[grid[column+1][row]]\\n                        \\n                    maxIslandSize = max(maxIslandSize, tmpIslandSize+1)\\n                \\n        return maxIslandSize\\n\\n        \\n    def helper(self, grid, size, row, column, IslandTag):\\n        grid[column][row] = IslandTag # give the IslandTag into the grid\\n        # If four sides are invalid, then we return.\\n        if not 0 <= row < len(grid[0]) or not 0 <= column < len(grid): \\n            return size\\n        \\n        # for each side, we check whether is boundary and whether is 1(island).\\n        if (row + 1) < len(grid[0]) and grid[column][row+1] == 1:\\n            right = self.helper(grid, size+1, row+1, column, IslandTag)\\n        else:\\n            right = size\\n            \\n        if (row - 1) >= 0 and grid[column][row-1] == 1:\\n            left = self.helper(grid, size+1, row-1, column, IslandTag)\\n        else:\\n            left = size            \\n\\n        if (column + 1) < len(grid) and grid[column+1][row] == 1:\\n            bottom = self.helper(grid, size+1, row, column+1, IslandTag)\\n        else:\\n            bottom = size\\n            \\n        if (column - 1) >= 0 and grid[column-1][row] == 1:\\n            top = self.helper(grid, size+1, row, column-1, IslandTag)\\n        else:\\n            top = size\\n            \\n            \\n        return right + left + bottom + top - size*3\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def largestIsland(self, grid: List[List[int]]) -> int:        \\n        maxIslandSize = 0\\n        IslandSizeList = [0, 0] # we start the index at 2, because 0, 1 in already used in question\\n        IslandTag = 2 # we start the index at 2\\n        \\n        # First we use recursive to find all the island, \\n        # so we will need to create a helper.\\n        # We also create a IslandTag to split all the island and give them an index.\\n        for column in range(len(grid)):\\n            for row in range(len(grid[0])):\\n                if grid[column][row] == 1:\\n                    islandSize = self.helper(grid, 1, row, column, IslandTag)\\n                    maxIslandSize = max(maxIslandSize, islandSize)\\n                    IslandSizeList.append(islandSize) # store each island size into the IslandSizeList\\n                    IslandTag += 1\\n        \\n        # In our second step, \\n        # we will go through the grid again and find the 0s inside the grid.\\n        # And we check that zero\\'s top, bottom, right, left to see all the island, \\n        # and we add all the island size.\\n        # Last, we always get the greater size value into our maxIslandSize which is the answer.\\n        for column in range(len(grid)):\\n            for row in range(len(grid[0])):\\n                tmpIslandSize = 0\\n                if grid[column][row] == 0:\\n                    tmp = []\\n                    if row > 0 and grid[column][row-1] != 0 and grid[column][row-1] not in tmp:\\n                        tmp.append(grid[column][row-1])\\n                        tmpIslandSize += IslandSizeList[grid[column][row-1]]\\n                    if row < len(grid[0])-1 and grid[column][row+1] != 0 and grid[column][row+1] not in tmp:\\n                        tmp.append(grid[column][row+1])\\n                        tmpIslandSize += IslandSizeList[grid[column][row+1]]\\n                    if column > 0 and grid[column-1][row] != 0 and grid[column-1][row] not in tmp:\\n                        tmp.append(grid[column-1][row])\\n                        tmpIslandSize += IslandSizeList[grid[column-1][row]]\\n                    if column < len(grid)-1 and grid[column+1][row] != 0 and grid[column+1][row] not in tmp:\\n                        tmp.append(grid[column+1][row])\\n                        tmpIslandSize += IslandSizeList[grid[column+1][row]]\\n                        \\n                    maxIslandSize = max(maxIslandSize, tmpIslandSize+1)\\n                \\n        return maxIslandSize\\n\\n        \\n    def helper(self, grid, size, row, column, IslandTag):\\n        grid[column][row] = IslandTag # give the IslandTag into the grid\\n        # If four sides are invalid, then we return.\\n        if not 0 <= row < len(grid[0]) or not 0 <= column < len(grid): \\n            return size\\n        \\n        # for each side, we check whether is boundary and whether is 1(island).\\n        if (row + 1) < len(grid[0]) and grid[column][row+1] == 1:\\n            right = self.helper(grid, size+1, row+1, column, IslandTag)\\n        else:\\n            right = size\\n            \\n        if (row - 1) >= 0 and grid[column][row-1] == 1:\\n            left = self.helper(grid, size+1, row-1, column, IslandTag)\\n        else:\\n            left = size            \\n\\n        if (column + 1) < len(grid) and grid[column+1][row] == 1:\\n            bottom = self.helper(grid, size+1, row, column+1, IslandTag)\\n        else:\\n            bottom = size\\n            \\n        if (column - 1) >= 0 and grid[column-1][row] == 1:\\n            top = self.helper(grid, size+1, row, column-1, IslandTag)\\n        else:\\n            top = size\\n            \\n            \\n        return right + left + bottom + top - size*3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1493786,
                "title": "java-with-dfs",
                "content": "```\\nclass Solution {\\n    \\n    int N;\\n    int size = 0;\\n    int[][] dir = new int[][]{{0,1},{0,-1},{-1,0},{1,0}};\\n    public int largestIsland(int[][] grid) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int res = 0;\\n        N = grid.length;\\n        int colorId = 2; // because the board val it\\'s either 1 or 0\\n        for (int i = 0; i < N; i++) {\\n            for (int j = 0; j < N; j++) {\\n                if (grid[i][j] == 1) {\\n                    dfs(grid, i, j, colorId);\\n                    res = Math.max(res, size);\\n                    map.put(colorId, size);\\n                    size = 0;\\n                    colorId++;    \\n                }\\n            }\\n        }\\n        \\n        for (int i = 0; i < N; i++) {\\n            for (int j = 0; j < N; j++) {\\n                if (grid[i][j] == 0) {\\n                    int landSize = 1;\\n                    Set<Integer> seen = new HashSet<>();\\n                    for (int[] d : dir) {\\n                        int x = d[0] + i, y = d[1] + j;\\n                        if (x >= N || x < 0 || y >= N || y < 0) {continue;}\\n                        if (map.get(grid[x][y]) != null && !seen.contains(grid[x][y])) {\\n                            seen.add(grid[x][y]);\\n                            landSize += map.get(grid[x][y]);\\n                        }\\n                    }\\n                    res = Math.max(res, landSize);\\n                }        \\n            }\\n        }\\n        return res;\\n    }\\n    public void dfs(int[][] grid, int i, int j, int colorId) {\\n        if (i < 0 || j < 0 || i >= N || j >= N || grid[i][j] != 1) {\\n            return;\\n        }\\n        size++;\\n        grid[i][j] = colorId;\\n        for (int[] d : dir) {\\n            dfs(grid, i + d[0], j + d[1], colorId);\\n        }\\n        \\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int N;\\n    int size = 0;\\n    int[][] dir = new int[][]{{0,1},{0,-1},{-1,0},{1,0}};\\n    public int largestIsland(int[][] grid) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int res = 0;\\n        N = grid.length;\\n        int colorId = 2; // because the board val it\\'s either 1 or 0\\n        for (int i = 0; i < N; i++) {\\n            for (int j = 0; j < N; j++) {\\n                if (grid[i][j] == 1) {\\n                    dfs(grid, i, j, colorId);\\n                    res = Math.max(res, size);\\n                    map.put(colorId, size);\\n                    size = 0;\\n                    colorId++;    \\n                }\\n            }\\n        }\\n        \\n        for (int i = 0; i < N; i++) {\\n            for (int j = 0; j < N; j++) {\\n                if (grid[i][j] == 0) {\\n                    int landSize = 1;\\n                    Set<Integer> seen = new HashSet<>();\\n                    for (int[] d : dir) {\\n                        int x = d[0] + i, y = d[1] + j;\\n                        if (x >= N || x < 0 || y >= N || y < 0) {continue;}\\n                        if (map.get(grid[x][y]) != null && !seen.contains(grid[x][y])) {\\n                            seen.add(grid[x][y]);\\n                            landSize += map.get(grid[x][y]);\\n                        }\\n                    }\\n                    res = Math.max(res, landSize);\\n                }        \\n            }\\n        }\\n        return res;\\n    }\\n    public void dfs(int[][] grid, int i, int j, int colorId) {\\n        if (i < 0 || j < 0 || i >= N || j >= N || grid[i][j] != 1) {\\n            return;\\n        }\\n        size++;\\n        grid[i][j] = colorId;\\n        for (int[] d : dir) {\\n            dfs(grid, i + d[0], j + d[1], colorId);\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1448780,
                "title": "c-bfs-graph-colouring-approach",
                "content": "### Problem necessitates Flood fill Concepts and Coloring the graphs.\\n\\n### Approach\\n\\n* We first traverse accross components that are not connected\\n* We give them some color (0, 1, 2 ,3 ... ), so that we may distuinguish among connected components. \\n* and store their size.\\n* We then in another loop traverse only at points of no Land i.e. where `grid[i][j] == 0`, because now we are only interested in the points where **value of grid is 0** and **which can serve b/w two connected components**. \\n* and check what is the colour of the point located to its `(left | right | down | up)`. *may be this was bit difficult to implement.*\\n\\n#### Implementation(BFS) as discussed above.\\n\\n```cpp\\n\\nint dr[] = {1, -1, 0, 0};\\nint dc[] = {0, 0, -1, 1};\\nint largestIsland(vector<vector<int>> &grid) {\\n\\tint n = grid.size();\\n\\tint m = grid[0].size();\\n\\n\\tvector<vector<int>> used(n, vector<int>(m, false));\\n\\tqueue<pair<int, int>> qu;\\n\\tmap<int, int> mp;\\n\\n\\tint color = 1;\\n\\tmp[0] = 0;\\n\\tint ans = 0;\\n\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tfor (int j = 0; j < m; j++) {\\n\\t\\t\\tif (grid[i][j] == 1 and !used[i][j]) {\\n\\t\\t\\t\\tint Size = 1;\\n\\t\\t\\t\\tqu.push({i, j});\\n\\t\\t\\t\\tused[i][j] = color;\\n\\n\\t\\t\\t\\twhile (!qu.empty()) {\\n\\t\\t\\t\\t\\tauto [r, c] = qu.front();\\n\\t\\t\\t\\t\\tqu.pop();\\n\\n\\t\\t\\t\\t\\tfor (int k = 0; k < 4; k++) {\\n\\t\\t\\t\\t\\t\\tint rr = r + dr[k];\\n\\t\\t\\t\\t\\t\\tint cc = c + dc[k];\\n\\n\\t\\t\\t\\t\\t\\tif (rr < 0 or cc < 0 or rr >= n or cc >= n or used[rr][cc] or grid[rr][cc] != 1)\\n\\t\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t\\tqu.push({rr, cc});\\n\\t\\t\\t\\t\\t\\tused[rr][cc] = color;\\n\\t\\t\\t\\t\\t\\tSize++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans = max(ans, Size);\\n\\t\\t\\t\\tmp[color] = Size;\\n\\t\\t\\t\\tcolor++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tfor (int j = 0; j < m; j++) {\\n\\t\\t\\tif (grid[i][j] == 0) {\\n\\t\\t\\t\\tint sum = 0;\\n\\t\\t\\t\\tmap<int, bool> usedColor;\\n\\t\\t\\t\\tfor (int k = 0; k < 4; k++) {\\n\\t\\t\\t\\t\\tint rr = i + dr[k];\\n\\t\\t\\t\\t\\tint cc = j + dc[k];\\n\\n\\t\\t\\t\\t\\tif (rr < 0 or cc < 0 or rr >= n or cc >= n)\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\tint currentColor = used[rr][cc];\\n\\t\\t\\t\\t\\tif (usedColor.count(currentColor))\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\t\\tsum += (mp[currentColor]);\\n\\t\\t\\t\\t\\tif (currentColor != 0) {\\n\\t\\t\\t\\t\\t\\tusedColor[currentColor] = true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans = max(ans, sum + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```cpp\\n\\nint dr[] = {1, -1, 0, 0};\\nint dc[] = {0, 0, -1, 1};\\nint largestIsland(vector<vector<int>> &grid) {\\n\\tint n = grid.size();\\n\\tint m = grid[0].size();\\n\\n\\tvector<vector<int>> used(n, vector<int>(m, false));\\n\\tqueue<pair<int, int>> qu;\\n\\tmap<int, int> mp;\\n\\n\\tint color = 1;\\n\\tmp[0] = 0;\\n\\tint ans = 0;\\n\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tfor (int j = 0; j < m; j++) {\\n\\t\\t\\tif (grid[i][j] == 1 and !used[i][j]) {\\n\\t\\t\\t\\tint Size = 1;\\n\\t\\t\\t\\tqu.push({i, j});\\n\\t\\t\\t\\tused[i][j] = color;\\n\\n\\t\\t\\t\\twhile (!qu.empty()) {\\n\\t\\t\\t\\t\\tauto [r, c] = qu.front();\\n\\t\\t\\t\\t\\tqu.pop();\\n\\n\\t\\t\\t\\t\\tfor (int k = 0; k < 4; k++) {\\n\\t\\t\\t\\t\\t\\tint rr = r + dr[k];\\n\\t\\t\\t\\t\\t\\tint cc = c + dc[k];\\n\\n\\t\\t\\t\\t\\t\\tif (rr < 0 or cc < 0 or rr >= n or cc >= n or used[rr][cc] or grid[rr][cc] != 1)\\n\\t\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t\\tqu.push({rr, cc});\\n\\t\\t\\t\\t\\t\\tused[rr][cc] = color;\\n\\t\\t\\t\\t\\t\\tSize++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans = max(ans, Size);\\n\\t\\t\\t\\tmp[color] = Size;\\n\\t\\t\\t\\tcolor++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tfor (int j = 0; j < m; j++) {\\n\\t\\t\\tif (grid[i][j] == 0) {\\n\\t\\t\\t\\tint sum = 0;\\n\\t\\t\\t\\tmap<int, bool> usedColor;\\n\\t\\t\\t\\tfor (int k = 0; k < 4; k++) {\\n\\t\\t\\t\\t\\tint rr = i + dr[k];\\n\\t\\t\\t\\t\\tint cc = j + dc[k];\\n\\n\\t\\t\\t\\t\\tif (rr < 0 or cc < 0 or rr >= n or cc >= n)\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\tint currentColor = used[rr][cc];\\n\\t\\t\\t\\t\\tif (usedColor.count(currentColor))\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\n\\t\\t\\t\\t\\tsum += (mp[currentColor]);\\n\\t\\t\\t\\t\\tif (currentColor != 0) {\\n\\t\\t\\t\\t\\t\\tusedColor[currentColor] = true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans = max(ans, sum + 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1415752,
                "title": "c-clean-and-concise-code",
                "content": "class Solution {\\npublic:\\n    \\n    \\n    int count=0;\\n    vector<int>temp={-1,0,1,0,-1};\\n    \\n    void dfs(vector<vector<int>>&grid,int i,int j,int island_Id){\\n        \\n        if(i<0||j<0||i>=grid.size()||j>=grid[0].size()||grid[i][j]!=1)     {\\n            return;\\n        }\\n        \\n        if(grid[i][j]==1){\\n            grid[i][j]=island_Id;\\n            count++;\\n\\n            dfs(grid,i+1,j,island_Id);\\n            dfs(grid,i-1,j,island_Id);\\n            dfs(grid,i,j+1,island_Id);\\n            dfs(grid,i,j-1,island_Id);\\n            \\n        }\\n        \\n    }\\n    \\n    \\n    \\n    int largestIsland(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        int maxval=0;\\n        int island_Id=2;\\n        map<int,int>mp;\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                \\n                if(grid[i][j]==1){\\n                    \\n                    dfs(grid,i,j,island_Id);\\n                    maxval=max(maxval,count);\\n                    mp[island_Id]=count;\\n                    count=0;\\n                    island_Id++;\\n                    \\n                }\\n                \\n            }\\n        }\\n        \\n        \\n        for(int i=0;i<m;i++){\\n            \\n            for(int j=0;j<n;j++){\\n                \\n                if(grid[i][j]==0){\\n                    \\n                 set<int>st;\\n                \\n                \\n                for(int k=0;k<temp.size()-1;k++){\\n                    \\n            if(i+temp[k]>=0 && i+temp[k]<m && j+temp[k+1]>=0 && j+temp[k+1]<n && grid[i+temp[k]][j+temp[k+1]]!=0){\\n                        \\n                   st.insert(grid[i+temp[k]][j+temp[k+1]]);\\n                \\n                    }\\n                }\\n                    \\n                    int sum=1;\\n                    \\n                    for(auto itr:st){\\n                        sum+=mp[itr];\\n                    }\\n                    \\n                    maxval=max(maxval,sum);\\n                    \\n               }     \\n            }\\n        }\\n        \\n        return maxval;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    \\n    int count=0;\\n    vector<int>temp={-1,0,1,0,-1}",
                "codeTag": "Java"
            },
            {
                "id": 1411580,
                "title": "c-dfs-depth-first-search",
                "content": "First run DFS according to the similar problem largest island,worth noting is the fact that wach 1 would be a part of a particular island and\\nafter running the dfs as per the similar problem we will be able to get the area of the island related to the 1 which belongs to that particular island number .\\n\\nThen,thereafter just pick each 0 and then search for all the ones in its neighbour,check the island number where these neighbours belong to and the area assciated with that isalnd number,add a 1 to that area and thus find the max.\\nq?Why are we adding 1 to that max area,coz that particular 0 would finally add up to the area by becoming a 1.\\n\\nRefer the code for more details.\\n```\\nclass Solution {\\npublic:\\n    int dx[4]={-1,1,0,0};\\n    int dy[4]={0,0,-1,1};\\n    int n,m;\\n    bool isvalid(int x,int y,vector<vector<bool>>& visited,vector<vector<int>>& grid){\\n        if(x>=0 and x<n and y>=0 and y<m and grid[x][y]==1 and visited[x][y]==false){\\n            return true;\\n        }\\n        return false;\\n    }\\n    int dfs(int x,int y,vector<vector<bool>>& visited,vector<vector<int>>& island,int islandnumber,vector<vector<int>>& grid,int& ans){\\n        visited[x][y]=true;\\n        island[x][y]=islandnumber;\\n        ans++;\\n        for(int i=0;i<4;i++){\\n            int new_x=x+dx[i],new_y=y+dy[i];\\n            if(isvalid(new_x,new_y,visited,grid)){\\n              dfs(new_x,new_y,visited,island,islandnumber,grid,ans);    \\n            }\\n        }\\n        return ans;\\n        \\n    }\\n    int largestIsland(vector<vector<int>>& grid) {\\n        n=grid.size();\\n         m=grid[0].size();\\n        int res=1;\\n        vector<vector<bool>> visited(n,vector<bool> (m,false));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                visited[i][j]=false;\\n            }\\n        }\\n        vector<vector<int>> island(n,vector<int>(m,0));\\n          for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                island[i][j]=0;\\n            }\\n        }\\n         int islandnumber=1,zeroes=0;;\\n        int ans;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1 and visited[i][j]==false){\\n                    ans=0;\\n                    int temp=dfs(i,j,visited,island,islandnumber,grid,ans);\\n                    mp[islandnumber]=temp;\\n                    islandnumber++;\\n                }\\n                else if(grid[i][j]==0)\\n                {\\n                    zeroes++;\\n                }\\n            }\\n        }\\n        if(zeroes==0){\\n            return n*m;\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==0){\\n                    int temp=1;\\n                     unordered_set<int> st;\\n                    for(int k=0;k<4;k++){\\n                        int new_x=i+dx[k],new_y=j+dy[k];\\n                        if(new_x>=0 and new_x<n and new_y>=0 and new_y<m and grid[new_x][new_y]==1){\\n                            int ok=island[new_x][new_y];//ok stands for the island number of that 1\\n                            if(st.find(ok)==st.end()){ //if suppose the down 1 and right side 1 belong to the same island,we have to prevent overcounting\\n                                temp+=mp[ok];\\n                                st.insert(ok);\\n                            }\\n                        }\\n                    }\\n                    res=max(res,temp);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dx[4]={-1,1,0,0};\\n    int dy[4]={0,0,-1,1};\\n    int n,m;\\n    bool isvalid(int x,int y,vector<vector<bool>>& visited,vector<vector<int>>& grid){\\n        if(x>=0 and x<n and y>=0 and y<m and grid[x][y]==1 and visited[x][y]==false){\\n            return true;\\n        }\\n        return false;\\n    }\\n    int dfs(int x,int y,vector<vector<bool>>& visited,vector<vector<int>>& island,int islandnumber,vector<vector<int>>& grid,int& ans){\\n        visited[x][y]=true;\\n        island[x][y]=islandnumber;\\n        ans++;\\n        for(int i=0;i<4;i++){\\n            int new_x=x+dx[i],new_y=y+dy[i];\\n            if(isvalid(new_x,new_y,visited,grid)){\\n              dfs(new_x,new_y,visited,island,islandnumber,grid,ans);    \\n            }\\n        }\\n        return ans;\\n        \\n    }\\n    int largestIsland(vector<vector<int>>& grid) {\\n        n=grid.size();\\n         m=grid[0].size();\\n        int res=1;\\n        vector<vector<bool>> visited(n,vector<bool> (m,false));\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                visited[i][j]=false;\\n            }\\n        }\\n        vector<vector<int>> island(n,vector<int>(m,0));\\n          for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                island[i][j]=0;\\n            }\\n        }\\n         int islandnumber=1,zeroes=0;;\\n        int ans;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1 and visited[i][j]==false){\\n                    ans=0;\\n                    int temp=dfs(i,j,visited,island,islandnumber,grid,ans);\\n                    mp[islandnumber]=temp;\\n                    islandnumber++;\\n                }\\n                else if(grid[i][j]==0)\\n                {\\n                    zeroes++;\\n                }\\n            }\\n        }\\n        if(zeroes==0){\\n            return n*m;\\n        }\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==0){\\n                    int temp=1;\\n                     unordered_set<int> st;\\n                    for(int k=0;k<4;k++){\\n                        int new_x=i+dx[k],new_y=j+dy[k];\\n                        if(new_x>=0 and new_x<n and new_y>=0 and new_y<m and grid[new_x][new_y]==1){\\n                            int ok=island[new_x][new_y];//ok stands for the island number of that 1\\n                            if(st.find(ok)==st.end()){ //if suppose the down 1 and right side 1 belong to the same island,we have to prevent overcounting\\n                                temp+=mp[ok];\\n                                st.insert(ok);\\n                            }\\n                        }\\n                    }\\n                    res=max(res,temp);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1409554,
                "title": "java-2-solutions-assign-colour-repeated-dfs-solutions-optimized",
                "content": "**Repeated DFS Solution [TLE]:**\\n```\\nclass Solution {\\n    public int largestIsland(int[][] grid) {\\n        if(grid==null || grid.length==0) return 0;\\n        int max=dfs(grid,0,0,new boolean[grid.length][grid[0].length]);\\n        \\n        boolean visited[][]=new boolean [grid.length][grid[0].length];\\n        \\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]==0){\\n                    grid[i][j]=1;\\n                    max=Math.max(max,dfs(grid,i,j,new boolean[grid.length][grid[0].length]));\\n                    grid[i][j]=0;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n    \\n    public int dfs(int grid[][], int i, int j, boolean visited[][]){\\n        if(i>=0 && j>=0 && i<grid.length && j<grid[0].length && grid[i][j]==1 && !visited[i][j]){\\n            int area=1;\\n            visited[i][j]=true;\\n\\n            area+=dfs(grid,i+1,j,visited);\\n            area+=dfs(grid,i-1,j,visited);\\n            area+=dfs(grid,i,j+1,visited);\\n            area+=dfs(grid,i,j-1,visited);\\n            \\n            return area;\\n        }\\n        else return 0;\\n    }\\n}\\n```\\n\\n**Colour & DFS Solution:**\\n```\\nclass Solution {\\n    public int largestIsland(int[][] grid) {\\n        int n=grid.length;\\n        \\n        int color=2;\\n        int A[]=new int[n*n+2];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1){\\n                    A[color]=getColor(grid,i,j,color++);\\n                }\\n            }\\n        }\\n        \\n        boolean seeZero=false;\\n        int ans=0;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==0){\\n                    seeZero=true;\\n                    \\n                    Set<Integer> set=new HashSet<>();\\n                    \\n                    if(i-1>=0) set.add(grid[i-1][j]);\\n                    if(j-1>=0) set.add(grid[i][j-1]);\\n                    if(i+1<n) set.add(grid[i+1][j]);\\n                    if(j+1<n) set.add(grid[i][j+1]);\\n                    \\n                    int area=1;\\n                    for(int x:set){\\n                        area+=A[x];\\n                    }\\n                    ans=Math.max(ans,area);\\n                }\\n            }\\n        }\\n        return seeZero ? ans : n*n;\\n    }\\n    \\n    public int getColor(int grid[][], int i, int j, int color){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j]!=1) return 0;\\n        else{\\n            grid[i][j]=color;\\n            \\n            return 1+getColor(grid,i+1,j,color)+getColor(grid,i,j+1,color)\\n\\t\\t\\t\\t\\t+getColor(grid,i,j-1,color)+getColor(grid,i-1,j,color);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int largestIsland(int[][] grid) {\\n        if(grid==null || grid.length==0) return 0;\\n        int max=dfs(grid,0,0,new boolean[grid.length][grid[0].length]);\\n        \\n        boolean visited[][]=new boolean [grid.length][grid[0].length];\\n        \\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(grid[i][j]==0){\\n                    grid[i][j]=1;\\n                    max=Math.max(max,dfs(grid,i,j,new boolean[grid.length][grid[0].length]));\\n                    grid[i][j]=0;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n    \\n    public int dfs(int grid[][], int i, int j, boolean visited[][]){\\n        if(i>=0 && j>=0 && i<grid.length && j<grid[0].length && grid[i][j]==1 && !visited[i][j]){\\n            int area=1;\\n            visited[i][j]=true;\\n\\n            area+=dfs(grid,i+1,j,visited);\\n            area+=dfs(grid,i-1,j,visited);\\n            area+=dfs(grid,i,j+1,visited);\\n            area+=dfs(grid,i,j-1,visited);\\n            \\n            return area;\\n        }\\n        else return 0;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int largestIsland(int[][] grid) {\\n        int n=grid.length;\\n        \\n        int color=2;\\n        int A[]=new int[n*n+2];\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1){\\n                    A[color]=getColor(grid,i,j,color++);\\n                }\\n            }\\n        }\\n        \\n        boolean seeZero=false;\\n        int ans=0;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==0){\\n                    seeZero=true;\\n                    \\n                    Set<Integer> set=new HashSet<>();\\n                    \\n                    if(i-1>=0) set.add(grid[i-1][j]);\\n                    if(j-1>=0) set.add(grid[i][j-1]);\\n                    if(i+1<n) set.add(grid[i+1][j]);\\n                    if(j+1<n) set.add(grid[i][j+1]);\\n                    \\n                    int area=1;\\n                    for(int x:set){\\n                        area+=A[x];\\n                    }\\n                    ans=Math.max(ans,area);\\n                }\\n            }\\n        }\\n        return seeZero ? ans : n*n;\\n    }\\n    \\n    public int getColor(int grid[][], int i, int j, int color){\\n        if(i<0 || j<0 || i>=grid.length || j>=grid[0].length || grid[i][j]!=1) return 0;\\n        else{\\n            grid[i][j]=color;\\n            \\n            return 1+getColor(grid,i+1,j,color)+getColor(grid,i,j+1,color)\\n\\t\\t\\t\\t\\t+getColor(grid,i,j-1,color)+getColor(grid,i-1,j,color);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1385096,
                "title": "so-simple-basic-c-solution-o-n-2-time-o-n-2-space-complexity",
                "content": "This Post describe a simple, neat & clean approach which is understandable to everyone i assure you. I am sharing here my simple approach in the hope that it will help someone. \\n\\nThis problem is similar & extenstion to count the number of cell ( land ) in the largest island problem. that we solve using simple DFS ( Depth First Search ) call. \\n\\nSimliary this problem also have the two main concept and the whole solution goes around that.\\n1. Seprate the all island by making them legal property ( mean assign them a unique id )\\n2. Go every cell having zero value & get the sum of all adjacent island\\'s piece\\'s count ( cell ) & take maximum. \\n\\nHere we see that we need the count of the every island\\'s pieces. so to escape the repitative computation we will store all island\\'s pieces count precomputed in a vector ( array ) [ named in code : \"islandPieces\" ] \\n\\n```\\n// direction vectors through iterating it move to all four direction\\n    int dx[4] = {1,0,-1,0};\\n    int dy[4] = {0,-1,0,1};\\n    \\n\\t//====================================================================================================\\n\\t\\n    // simple Dfs which returning the total number cell connected to each other having value \"1\" ( pieces of a island ) \\n    int Dfs(vector<vector<int>> &grid, int row, int col, int &id){\\n        \\n        // check outOfBound condition of grid\\n        // and we will go only on that cell having value 1 \\n        // if a cell not having value 1 than it means two cases\\n        //                              1. value = 0 (cell can\\'t dominate to that island)\\n        //                              2. value > 1 (cell is the part of another island)\\n        \\n        if(row < 0 || col < 0 || row >= grid.size() || col >= grid[0].size() || grid[row][col] != 1) return 0;\\n        \\n        int pieces = 1;\\n        \\n        // change the value of that cell (indicating the island number)\\n        grid[row][col] = id;\\n        for(int i = 0; i < 4; i++){\\n            pieces += Dfs(grid, row+dx[i], col+dy[i], id);\\n        }\\n        \\n        return pieces;\\n    }\\n    \\n\\t//===================================================================================================\\n\\t\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        \\n        // make a vector having the total count of cell containing by a island \\n        // islandPieces :   \\n        //     1. index => id of island \\n        //     2. value => count of cell in a island \\n        vector<int> islandPieces((n*n)/2+3, 0); // maximum island can be half of the total cell + 2 (for predefined values {\"0\", \"1\"})\\n        int id = 2; // starging value of id from \"2\" because \"0\" for no island \"1\" for any island\\n        \\n        int largestIsland = 0;\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                \\n                // only call Dfs from the grid cell having value 1 because their is land not on 0\\n                if(grid[i][j] == 1){\\n                    \\n                    // here we substitute 2 from k only to start the index from 0 to use first two cell\\n                    islandPieces[id] = Dfs(grid, i, j, id);\\n                    largestIsland = max(largestIsland, islandPieces[id]);\\n                    id++;\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\t//**************************************************************************//\\n                \\n        // final loop for check one by one cell if we change there value \"0\" to \"1\"\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                \\n                // this condition states that\\n                //   ------------->  what will be the biggest island if i change this cell value to \"1\"\\n                if(grid[i][j] == 0){\\n                    int tempIsland = 0;\\n                    \\n                    // take set for uniuqe islands \\n                    set<int> uniqueIsland;\\n                    \\n                    // iterate to all \"4\" direction\\n                    for(int k = 0; k < 4; k++){\\n                        int nextCellRow = i + dx[k];\\n                        int nextCellCol = j + dy[k];\\n\\n                        if(nextCellRow < 0 || nextCellCol < 0 || nextCellRow >= n || nextCellCol >= n) continue;\\n                        \\n                        uniqueIsland.insert(grid[nextCellRow][nextCellCol]);\\n                    }\\n                    \\n                    // sum the all neighbours island\\'s cell count\\n                    // because after set \\'0\\' to \\'1\\' all island will be connected and will be merge in one island\\n                    for(auto &it : uniqueIsland){\\n                        tempIsland += islandPieces[it];\\n                    }\\n                    \\n                    tempIsland += 1; // add 1 for this cell ( changed \"0\" to \"1\")\\n                    \\n                    // take the largest \\n                    largestIsland = max(largestIsland, tempIsland);\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\t//**************************************************************************//\\n        \\n        return largestIsland;\\n\\n```\\n\\nHope you will like it. I feel happy when i contribute something to this community.",
                "solutionTags": [
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\n// direction vectors through iterating it move to all four direction\\n    int dx[4] = {1,0,-1,0};\\n    int dy[4] = {0,-1,0,1};\\n    \\n\\t//====================================================================================================\\n\\t\\n    // simple Dfs which returning the total number cell connected to each other having value \"1\" ( pieces of a island ) \\n    int Dfs(vector<vector<int>> &grid, int row, int col, int &id){\\n        \\n        // check outOfBound condition of grid\\n        // and we will go only on that cell having value 1 \\n        // if a cell not having value 1 than it means two cases\\n        //                              1. value = 0 (cell can\\'t dominate to that island)\\n        //                              2. value > 1 (cell is the part of another island)\\n        \\n        if(row < 0 || col < 0 || row >= grid.size() || col >= grid[0].size() || grid[row][col] != 1) return 0;\\n        \\n        int pieces = 1;\\n        \\n        // change the value of that cell (indicating the island number)\\n        grid[row][col] = id;\\n        for(int i = 0; i < 4; i++){\\n            pieces += Dfs(grid, row+dx[i], col+dy[i], id);\\n        }\\n        \\n        return pieces;\\n    }\\n    \\n\\t//===================================================================================================\\n\\t\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        \\n        // make a vector having the total count of cell containing by a island \\n        // islandPieces :   \\n        //     1. index => id of island \\n        //     2. value => count of cell in a island \\n        vector<int> islandPieces((n*n)/2+3, 0); // maximum island can be half of the total cell + 2 (for predefined values {\"0\", \"1\"})\\n        int id = 2; // starging value of id from \"2\" because \"0\" for no island \"1\" for any island\\n        \\n        int largestIsland = 0;\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                \\n                // only call Dfs from the grid cell having value 1 because their is land not on 0\\n                if(grid[i][j] == 1){\\n                    \\n                    // here we substitute 2 from k only to start the index from 0 to use first two cell\\n                    islandPieces[id] = Dfs(grid, i, j, id);\\n                    largestIsland = max(largestIsland, islandPieces[id]);\\n                    id++;\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\t//**************************************************************************//\\n                \\n        // final loop for check one by one cell if we change there value \"0\" to \"1\"\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                \\n                // this condition states that\\n                //   ------------->  what will be the biggest island if i change this cell value to \"1\"\\n                if(grid[i][j] == 0){\\n                    int tempIsland = 0;\\n                    \\n                    // take set for uniuqe islands \\n                    set<int> uniqueIsland;\\n                    \\n                    // iterate to all \"4\" direction\\n                    for(int k = 0; k < 4; k++){\\n                        int nextCellRow = i + dx[k];\\n                        int nextCellCol = j + dy[k];\\n\\n                        if(nextCellRow < 0 || nextCellCol < 0 || nextCellRow >= n || nextCellCol >= n) continue;\\n                        \\n                        uniqueIsland.insert(grid[nextCellRow][nextCellCol]);\\n                    }\\n                    \\n                    // sum the all neighbours island\\'s cell count\\n                    // because after set \\'0\\' to \\'1\\' all island will be connected and will be merge in one island\\n                    for(auto &it : uniqueIsland){\\n                        tempIsland += islandPieces[it];\\n                    }\\n                    \\n                    tempIsland += 1; // add 1 for this cell ( changed \"0\" to \"1\")\\n                    \\n                    // take the largest \\n                    largestIsland = max(largestIsland, tempIsland);\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\t//**************************************************************************//\\n        \\n        return largestIsland;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1379883,
                "title": "100-in-runtime-and-memory-rust-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn largest_island(mut grid: Vec<Vec<i32>>) -> i32 {\\n        use std::collections::HashMap;\\n\\n        fn neighbours(row: i32, col: i32) -> [(i32, i32); 4] {\\n            [\\n                (row + 1, col),\\n                (row, col + 1),\\n                (row - 1, col),\\n                (row, col - 1),\\n            ]\\n        }\\n\\n        fn dfs(grid: &mut Vec<Vec<i32>>, row: i32, col: i32, index: i32) -> i32 {\\n            let mut area = 1;\\n            grid[row as usize][col as usize] = index;\\n\\n            for (neighbour_row, neighbour_col) in neighbours(row, col).iter() {\\n                if *neighbour_col >= 0\\n                    && *neighbour_col < grid[row as usize].len() as i32\\n                    && *neighbour_row >= 0\\n                    && *neighbour_row < grid.len() as i32\\n                    && grid[*neighbour_row as usize][*neighbour_col as usize] == 1\\n                {\\n                    area += dfs(grid, *neighbour_row, *neighbour_col, index);\\n                }\\n            }\\n\\n            area\\n        }\\n\\n        let mut areas = HashMap::new();\\n        let mut index = 2;\\n        for row in 0..grid.len() {\\n            for col in 0..grid[row].len() {\\n                if grid[row][col] == 1 {\\n                    areas.insert(index, dfs(&mut grid, row as i32, col as i32, index));\\n                    index += 1;\\n                }\\n            }\\n        }\\n\\n        let mut max_area = match areas.len() {\\n            0 => return 1,\\n            1 => *areas.values().next().unwrap(),\\n            _ => *areas.values().max().unwrap(),\\n        };\\n\\n        for row in 0..grid.len() {\\n            for col in 0..grid[row].len() {\\n                if grid[row][col] == 0 {\\n                    let mut area = 1;\\n                    let mut covered_index = Vec::new();\\n                    for (neighbour_row, neighbour_col) in neighbours(row as i32, col as i32).iter()\\n                    {\\n                        if *neighbour_col >= 0\\n                            && *neighbour_col < grid[row].len() as i32\\n                            && *neighbour_row >= 0\\n                            && *neighbour_row < grid.len() as i32\\n                            && grid[*neighbour_row as usize][*neighbour_col as usize] > 0\\n                            && !covered_index\\n                                .contains(&grid[*neighbour_row as usize][*neighbour_col as usize])\\n                        {\\n                            area += areas\\n                                .get(&grid[*neighbour_row as usize][*neighbour_col as usize])\\n                                .unwrap();\\n                            covered_index\\n                                .push(grid[*neighbour_row as usize][*neighbour_col as usize])\\n                        }\\n                    }\\n                    max_area = area.max(max_area);\\n                }\\n            }\\n        }\\n\\n        max_area\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn largest_island(mut grid: Vec<Vec<i32>>) -> i32 {\\n        use std::collections::HashMap;\\n\\n        fn neighbours(row: i32, col: i32) -> [(i32, i32); 4] {\\n            [\\n                (row + 1, col),\\n                (row, col + 1),\\n                (row - 1, col),\\n                (row, col - 1),\\n            ]\\n        }\\n\\n        fn dfs(grid: &mut Vec<Vec<i32>>, row: i32, col: i32, index: i32) -> i32 {\\n            let mut area = 1;\\n            grid[row as usize][col as usize] = index;\\n\\n            for (neighbour_row, neighbour_col) in neighbours(row, col).iter() {\\n                if *neighbour_col >= 0\\n                    && *neighbour_col < grid[row as usize].len() as i32\\n                    && *neighbour_row >= 0\\n                    && *neighbour_row < grid.len() as i32\\n                    && grid[*neighbour_row as usize][*neighbour_col as usize] == 1\\n                {\\n                    area += dfs(grid, *neighbour_row, *neighbour_col, index);\\n                }\\n            }\\n\\n            area\\n        }\\n\\n        let mut areas = HashMap::new();\\n        let mut index = 2;\\n        for row in 0..grid.len() {\\n            for col in 0..grid[row].len() {\\n                if grid[row][col] == 1 {\\n                    areas.insert(index, dfs(&mut grid, row as i32, col as i32, index));\\n                    index += 1;\\n                }\\n            }\\n        }\\n\\n        let mut max_area = match areas.len() {\\n            0 => return 1,\\n            1 => *areas.values().next().unwrap(),\\n            _ => *areas.values().max().unwrap(),\\n        };\\n\\n        for row in 0..grid.len() {\\n            for col in 0..grid[row].len() {\\n                if grid[row][col] == 0 {\\n                    let mut area = 1;\\n                    let mut covered_index = Vec::new();\\n                    for (neighbour_row, neighbour_col) in neighbours(row as i32, col as i32).iter()\\n                    {\\n                        if *neighbour_col >= 0\\n                            && *neighbour_col < grid[row].len() as i32\\n                            && *neighbour_row >= 0\\n                            && *neighbour_row < grid.len() as i32\\n                            && grid[*neighbour_row as usize][*neighbour_col as usize] > 0\\n                            && !covered_index\\n                                .contains(&grid[*neighbour_row as usize][*neighbour_col as usize])\\n                        {\\n                            area += areas\\n                                .get(&grid[*neighbour_row as usize][*neighbour_col as usize])\\n                                .unwrap();\\n                            covered_index\\n                                .push(grid[*neighbour_row as usize][*neighbour_col as usize])\\n                        }\\n                    }\\n                    max_area = area.max(max_area);\\n                }\\n            }\\n        }\\n\\n        max_area\\n\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1379372,
                "title": "python-solution-using-modified-ufds-with-path-compression-o-n-2-time-and-space-complexity",
                "content": "The modified UFDS has 1 extra attribute: sizes. Notice there are also several modifications on the union method. \\n\\n*This code could be optimized further.\\n\\n```\\nclass Solution(object):\\n    def largestIsland(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        class UnionFind:\\n            def __init__(self, N):\\n                self.rank = [0 for _ in range(N)]\\n                self.parent = [i for i in range(N)]\\n                self.sizes = [1 for i in range(N)]\\n                self.circles = N\\n                \\n            def find(self, i):\\n                if self.parent[i] == i: return i\\n                self.parent[i] = self.find(self.parent[i]) #path comrpession\\n                return self.parent[i]\\n            \\n            def union(self, i, j):\\n                x, y = self.find(i), self.find(j)\\n                \\n                if x != y:\\n                    if self.rank[x] > self.rank[y]: \\n                        self.parent[y] = x\\n                        self.sizes[x] += self.sizes[y]\\n                    else:\\n                        self.parent[x] = y\\n                        if self.rank[x] == self.rank[y]: self.rank[y] += 1\\n                        self.sizes[y] += self.sizes[x]\\n                    self.circles -= 1\\n        ufds = UnionFind(len(grid)*len(grid))\\n    \\n        for i in range(len(grid)):\\n            for j in range(len(grid)):\\n                el = grid[i][j]\\n                if el == 1:\\n                 \\n                    if i-1 >= 0 and grid[i-1][j] == 1:\\n                        ufds.union(i*len(grid) + j, (i-1)*len(grid)+j)\\n                        \\n                    if j-1 >= 0  and grid[i][j-1] == 1:\\n                        ufds.union(i*len(grid) + j, (i)*len(grid)+j-1)\\n        largest = max(ufds.sizes)\\n       \\n        for i in range(len(grid)):\\n            for j in range(len(grid)):\\n               \\n                if grid[i][j] == 0:\\n\\n              \\n                    parents = []\\n                    cur = 1\\n                    if i-1 >= 0 and grid[i-1][j] == 1:\\n                  \\n                        parent = ufds.find((i-1)*len(grid) + j)\\n                        if parent not in parents:\\n                            parents.append(parent)\\n                            cur += ufds.sizes[parent]\\n                    if j-1 >= 0  and grid[i][j-1] == 1:\\n                      \\n                        parent = ufds.find((i)*len(grid) + j-1)\\n                        if parent not in parents:\\n                            parents.append(parent)\\n                            cur += ufds.sizes[parent]\\n                    if j+1 < len(grid)  and grid[i][j+1] == 1:\\n                    \\n                        parent = ufds.find((i)*len(grid) + j+1)\\n                        if parent not in parents:\\n                            parents.append(parent)\\n                            cur += ufds.sizes[parent]\\n                    if i+1 <len(grid)  and grid[i+1][j] == 1:\\n                       \\n                        parent = ufds.find((i+1)*len(grid) + j)\\n                        if parent not in parents:\\n                            parents.append(parent)\\n                            cur += ufds.sizes[parent]\\n                    largest = max(largest,cur)\\n     \\n        return largest\\n                        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def largestIsland(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        class UnionFind:\\n            def __init__(self, N):\\n                self.rank = [0 for _ in range(N)]\\n                self.parent = [i for i in range(N)]\\n                self.sizes = [1 for i in range(N)]\\n                self.circles = N\\n                \\n            def find(self, i):\\n                if self.parent[i] == i: return i\\n                self.parent[i] = self.find(self.parent[i]) #path comrpession\\n                return self.parent[i]\\n            \\n            def union(self, i, j):\\n                x, y = self.find(i), self.find(j)\\n                \\n                if x != y:\\n                    if self.rank[x] > self.rank[y]: \\n                        self.parent[y] = x\\n                        self.sizes[x] += self.sizes[y]\\n                    else:\\n                        self.parent[x] = y\\n                        if self.rank[x] == self.rank[y]: self.rank[y] += 1\\n                        self.sizes[y] += self.sizes[x]\\n                    self.circles -= 1\\n        ufds = UnionFind(len(grid)*len(grid))\\n    \\n        for i in range(len(grid)):\\n            for j in range(len(grid)):\\n                el = grid[i][j]\\n                if el == 1:\\n                 \\n                    if i-1 >= 0 and grid[i-1][j] == 1:\\n                        ufds.union(i*len(grid) + j, (i-1)*len(grid)+j)\\n                        \\n                    if j-1 >= 0  and grid[i][j-1] == 1:\\n                        ufds.union(i*len(grid) + j, (i)*len(grid)+j-1)\\n        largest = max(ufds.sizes)\\n       \\n        for i in range(len(grid)):\\n            for j in range(len(grid)):\\n               \\n                if grid[i][j] == 0:\\n\\n              \\n                    parents = []\\n                    cur = 1\\n                    if i-1 >= 0 and grid[i-1][j] == 1:\\n                  \\n                        parent = ufds.find((i-1)*len(grid) + j)\\n                        if parent not in parents:\\n                            parents.append(parent)\\n                            cur += ufds.sizes[parent]\\n                    if j-1 >= 0  and grid[i][j-1] == 1:\\n                      \\n                        parent = ufds.find((i)*len(grid) + j-1)\\n                        if parent not in parents:\\n                            parents.append(parent)\\n                            cur += ufds.sizes[parent]\\n                    if j+1 < len(grid)  and grid[i][j+1] == 1:\\n                    \\n                        parent = ufds.find((i)*len(grid) + j+1)\\n                        if parent not in parents:\\n                            parents.append(parent)\\n                            cur += ufds.sizes[parent]\\n                    if i+1 <len(grid)  and grid[i+1][j] == 1:\\n                       \\n                        parent = ufds.find((i+1)*len(grid) + j)\\n                        if parent not in parents:\\n                            parents.append(parent)\\n                            cur += ufds.sizes[parent]\\n                    largest = max(largest,cur)\\n     \\n        return largest\\n                        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1379207,
                "title": "dfs-scc-c-explained-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    unordered_map<int, int> size; //store size of each connected component by assigning an id to every cell of the connected component which will act as a key in the map\\n    int vis[502][502]; //store -1 for unvisited cell and cell id for visited\\n    \\n    int dfs(int i, int j, vector<vector<int>>& grid, int islandNum){ //islandNum is the id\\n        if(i<0 || i>=n || j<0 || j>=m || grid[i][j]==0 || vis[i][j]!=-1){\\n            return 0;\\n        }\\n        vis[i][j]=islandNum;\\n        int size=1; //all connected components have same id\\n        size+=dfs(i+1,j,grid,islandNum);\\n        size+=dfs(i-1,j,grid,islandNum);\\n        size+=dfs(i,j+1,grid,islandNum);\\n        size+=dfs(i,j-1,grid,islandNum);\\n        return size;\\n    }\\n    \\n    int largestIsland(vector<vector<int>>& grid) {\\n        n=grid.size();\\n        m=grid[0].size();\\n        memset(vis,-1,sizeof(vis));\\n        int l=1; // set id initally as 1\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1 && vis[i][j]==-1){\\n                    size[l]=dfs(i, j, grid, l);\\n                    l++; //increment id for next connected component\\n                }\\n            }\\n        }\\n        \\n        int maxarea=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==0){ //if we find a 0, we will try to find diff connected components attached to it, i.e, with different ids\\n                    int area=1;\\n                    set<int> s; //set assures diff id\\n                    if(i+1<n) \\n                    s.insert(vis[i+1][j]); //vis array holds id for a particular cell\\n                    if(i-1>=0)\\n                    s.insert(vis[i-1][j]);\\n                    if(j+1<m) \\n                    s.insert(vis[i][j+1]);\\n                    if(j-1>=0) \\n                    s.insert(vis[i][j-1]);\\n                    for(int c: s){\\n                        area+=size[c]; //adding size for every unique connected component\\n                    }\\n                    maxarea=max(maxarea, area); //finding max atlast\\n                }\\n            }\\n        }\\n        if(maxarea!=0)\\n        return maxarea;\\n\\t\\t //if the maxarea isn\\'t even 1 which would have been the case if atleast one 0 existed, we know the grid consists of all 1s \\n        return n*m;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    unordered_map<int, int> size; //store size of each connected component by assigning an id to every cell of the connected component which will act as a key in the map\\n    int vis[502][502]; //store -1 for unvisited cell and cell id for visited\\n    \\n    int dfs(int i, int j, vector<vector<int>>& grid, int islandNum){ //islandNum is the id\\n        if(i<0 || i>=n || j<0 || j>=m || grid[i][j]==0 || vis[i][j]!=-1){\\n            return 0;\\n        }\\n        vis[i][j]=islandNum;\\n        int size=1; //all connected components have same id\\n        size+=dfs(i+1,j,grid,islandNum);\\n        size+=dfs(i-1,j,grid,islandNum);\\n        size+=dfs(i,j+1,grid,islandNum);\\n        size+=dfs(i,j-1,grid,islandNum);\\n        return size;\\n    }\\n    \\n    int largestIsland(vector<vector<int>>& grid) {\\n        n=grid.size();\\n        m=grid[0].size();\\n        memset(vis,-1,sizeof(vis));\\n        int l=1; // set id initally as 1\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==1 && vis[i][j]==-1){\\n                    size[l]=dfs(i, j, grid, l);\\n                    l++; //increment id for next connected component\\n                }\\n            }\\n        }\\n        \\n        int maxarea=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid[i][j]==0){ //if we find a 0, we will try to find diff connected components attached to it, i.e, with different ids\\n                    int area=1;\\n                    set<int> s; //set assures diff id\\n                    if(i+1<n) \\n                    s.insert(vis[i+1][j]); //vis array holds id for a particular cell\\n                    if(i-1>=0)\\n                    s.insert(vis[i-1][j]);\\n                    if(j+1<m) \\n                    s.insert(vis[i][j+1]);\\n                    if(j-1>=0) \\n                    s.insert(vis[i][j-1]);\\n                    for(int c: s){\\n                        area+=size[c]; //adding size for every unique connected component\\n                    }\\n                    maxarea=max(maxarea, area); //finding max atlast\\n                }\\n            }\\n        }\\n        if(maxarea!=0)\\n        return maxarea;\\n\\t\\t //if the maxarea isn\\'t even 1 which would have been the case if atleast one 0 existed, we know the grid consists of all 1s \\n        return n*m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1379015,
                "title": "c-solution-using-dsu-union-find",
                "content": "# C++ DSU solution\\n\\nFirst just iterate over all the 1\\'s and then union them with their neighbours, with max O(log N) per union.\\nInitialize your answer with max size of the exisiting sets.\\n\\nThen iterate over all the 0\\'s and check all the distinct neighbouring sets, then update answer with the max of answer or the sum of all the distinct neighbouring sets + 1 (including the current cell). \\n\\nThe implementation the DSU is simple but pretty good since it stores all the set leaders with the size of the sets, so implementation is easier with less space used.\\n\\nThis algorithm effectively works in O(N^2) but worst case scenario is `O(N^2 * logN)`.\\n\\n```\\nconst int N = 250000;\\nconst int dx[] = {-1, 0, 1, 0};\\nconst int dy[] = {0, -1, 0, 1};\\n\\nclass Solution {\\npublic:\\n    int n;\\n    \\n    bool valid(int& x, int& y) {\\n        return (x>=0 && y>=0 && x<n && y<n);\\n    }\\n    \\n    int par[N];\\n\\n    void make_set() {\\n        memset(par, -1, sizeof(par));\\n    }\\n\\n    int find_set(int x) {\\n        if(par[x] < 0)\\n            return x;\\n\\n        return par[x] = find_set(par[x]);\\n    }\\n\\n    int size_set(int x) {\\n        return -par[find_set(x)];\\n    }\\n\\n    bool union_set(int a, int b) {\\n        a = find_set(a), b = find_set(b);\\n\\n        if(a != b) {\\n            if(par[a] > par[b])\\n                swap(a, b);\\n\\n            par[a] += par[b];\\n            par[b] = a;\\n        }\\n\\n        return (a != b);\\n    }\\n    \\n    int largestIsland(vector<vector<int>>& arr) {\\n        n = arr.size();\\n        \\n        make_set();\\n        \\n        int ans = 0;\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<n; j++) {\\n                if(arr[i][j]) {\\n                    for(int k=0; k<4; k++) {\\n                        int x = i + dx[k];\\n                        int y = j + dy[k];\\n                        \\n                        if(valid(x, y) && arr[x][y]) {\\n                            union_set(i * n + j, x * n + y);\\n                        }\\n                    }\\n                    \\n                    ans = max(ans, size_set(i * n + j));\\n                }\\n            }\\n        }\\n        \\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<n; j++) {\\n                if(!arr[i][j]) {\\n                    set<int> s;\\n                    for(int k=0; k<4; k++) {\\n                        int x = i + dx[k];\\n                        int y = j + dy[k];\\n                        \\n                        if(valid(x, y) && arr[x][y]) {\\n                            s.insert(find_set(x * n + y));\\n                        }\\n                    }\\n                    \\n                    int temp = 1;\\n                    for(auto& x:s) {\\n                        temp += size_set(x);\\n                    }\\n                    \\n                    ans = max(ans, temp);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n     }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst int N = 250000;\\nconst int dx[] = {-1, 0, 1, 0};\\nconst int dy[] = {0, -1, 0, 1};\\n\\nclass Solution {\\npublic:\\n    int n;\\n    \\n    bool valid(int& x, int& y) {\\n        return (x>=0 && y>=0 && x<n && y<n);\\n    }\\n    \\n    int par[N];\\n\\n    void make_set() {\\n        memset(par, -1, sizeof(par));\\n    }\\n\\n    int find_set(int x) {\\n        if(par[x] < 0)\\n            return x;\\n\\n        return par[x] = find_set(par[x]);\\n    }\\n\\n    int size_set(int x) {\\n        return -par[find_set(x)];\\n    }\\n\\n    bool union_set(int a, int b) {\\n        a = find_set(a), b = find_set(b);\\n\\n        if(a != b) {\\n            if(par[a] > par[b])\\n                swap(a, b);\\n\\n            par[a] += par[b];\\n            par[b] = a;\\n        }\\n\\n        return (a != b);\\n    }\\n    \\n    int largestIsland(vector<vector<int>>& arr) {\\n        n = arr.size();\\n        \\n        make_set();\\n        \\n        int ans = 0;\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<n; j++) {\\n                if(arr[i][j]) {\\n                    for(int k=0; k<4; k++) {\\n                        int x = i + dx[k];\\n                        int y = j + dy[k];\\n                        \\n                        if(valid(x, y) && arr[x][y]) {\\n                            union_set(i * n + j, x * n + y);\\n                        }\\n                    }\\n                    \\n                    ans = max(ans, size_set(i * n + j));\\n                }\\n            }\\n        }\\n        \\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<n; j++) {\\n                if(!arr[i][j]) {\\n                    set<int> s;\\n                    for(int k=0; k<4; k++) {\\n                        int x = i + dx[k];\\n                        int y = j + dy[k];\\n                        \\n                        if(valid(x, y) && arr[x][y]) {\\n                            s.insert(find_set(x * n + y));\\n                        }\\n                    }\\n                    \\n                    int temp = 1;\\n                    for(auto& x:s) {\\n                        temp += size_set(x);\\n                    }\\n                    \\n                    ans = max(ans, temp);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1378424,
                "title": "easy-faster-than-96-solution",
                "content": "# Easy & faster than 96% solution\\n**Approach: simple solution using dfs and assigning island_id.**\\n1. First we do dfs one by one on each cell of grid if it is not visited already.\\n2. Visited cell will be assigned as island id  so that we do not traverse that cell again in the grid.\\nAnd find area of island by counting 1\\'s around all 4 directions of a cell using DFS.\\n3. Now store the count which is passed by reference to it\\'s corresponding island id using a map and also update maximum area till now.\\n4. Now traverse again for all 0\\'s in the grid and check if we put 1 here then maximum area increases or not and update maximum Area till now.\\nNote : island_id should not be assigned as 0 or 1(as it is already in our grid so we will not be able to know if it is traversed or not ) so i have started with 2 and incremented for next island.\\n \\n```\\nclass Solution {\\npublic:\\n    void dfsIsland(vector<vector<int>> &grid,int i,int j,int &count,int n,int id){\\n        if(i<0 || j<0 || i>=n || j>=n) return;\\n        if(grid[i][j]!=1) return;   //either 0 or already traversed\\n        //fill particualar cell with grid id\\n        grid[i][j]=id;\\n        count++;\\n        //traverse in all four directions\\n        dfsIsland(grid,i+1,j,count,n,id);\\n        dfsIsland(grid,i,j+1,count,n,id);\\n        dfsIsland(grid,i-1,j,count,n,id);\\n        dfsIsland(grid,i,j-1,count,n,id);\\n        return;\\n    }\\n    int largestIsland(vector<vector<int>>& grid) {\\n        unordered_map<int,int> id;  //store id and size\\n        int n=grid.size();\\n        int island_id=2;  //initialize island id with 2 as 1 is already present there\\n        int ans=1;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1){  //cell that is not visted already and not 0\\n                    int count=0;\\n                    dfsIsland(grid,i,j,count,n,island_id);\\n                    id[island_id]=count;\\n                    ans=max(ans,count);\\n                    island_id++;\\n                } \\n            }\\n        }\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==0){\\n                    set<int> s; //store count of unique id\\n                    if(i-1>=0 && grid[i-1][j]>1){\\n                        s.insert(grid[i-1][j]);\\n                    }\\n                    if(j-1>=0 && grid[i][j-1]>1){\\n                        s.insert(grid[i][j-1]);\\n                    }\\n                    if(i+1<n && grid[i+1][j]>1){\\n                        s.insert(grid[i+1][j]);\\n                    }\\n                    if(j+1<n && grid[i][j+1]>1){\\n                        s.insert(grid[i][j+1]);\\n                    }\\n                    int sum=1;\\n                    for(auto x:s) sum+=id[x]; \\n                    ans=max(ans,sum);\\n                } \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfsIsland(vector<vector<int>> &grid,int i,int j,int &count,int n,int id){\\n        if(i<0 || j<0 || i>=n || j>=n) return;\\n        if(grid[i][j]!=1) return;   //either 0 or already traversed\\n        //fill particualar cell with grid id\\n        grid[i][j]=id;\\n        count++;\\n        //traverse in all four directions\\n        dfsIsland(grid,i+1,j,count,n,id);\\n        dfsIsland(grid,i,j+1,count,n,id);\\n        dfsIsland(grid,i-1,j,count,n,id);\\n        dfsIsland(grid,i,j-1,count,n,id);\\n        return;\\n    }\\n    int largestIsland(vector<vector<int>>& grid) {\\n        unordered_map<int,int> id;  //store id and size\\n        int n=grid.size();\\n        int island_id=2;  //initialize island id with 2 as 1 is already present there\\n        int ans=1;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==1){  //cell that is not visted already and not 0\\n                    int count=0;\\n                    dfsIsland(grid,i,j,count,n,island_id);\\n                    id[island_id]=count;\\n                    ans=max(ans,count);\\n                    island_id++;\\n                } \\n            }\\n        }\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid[i][j]==0){\\n                    set<int> s; //store count of unique id\\n                    if(i-1>=0 && grid[i-1][j]>1){\\n                        s.insert(grid[i-1][j]);\\n                    }\\n                    if(j-1>=0 && grid[i][j-1]>1){\\n                        s.insert(grid[i][j-1]);\\n                    }\\n                    if(i+1<n && grid[i+1][j]>1){\\n                        s.insert(grid[i+1][j]);\\n                    }\\n                    if(j+1<n && grid[i][j+1]>1){\\n                        s.insert(grid[i][j+1]);\\n                    }\\n                    int sum=1;\\n                    for(auto x:s) sum+=id[x]; \\n                    ans=max(ans,sum);\\n                } \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1377943,
                "title": "kotlin-bfs-flooding-clean",
                "content": "```\\nclass Solution {\\n    fun largestIsland(grid: Array<IntArray>): Int {\\n        val n = grid.size\\n        val firstLabel = 2\\n        val sizes = mutableMapOf<Int, Int>()\\n        val steps = arrayOf(Pair(-1, 0), Pair(1, 0), Pair(0, -1), Pair(0, 1))\\n\\n        fun label(row: Int, col: Int): Int =\\n            if (row < 0 || row >= n || col < 0 || col >= n) 0 else grid[row][col]\\n\\n        fun conquerIsland(label: Int, row: Int, col: Int): Int {\\n            val queue = mutableListOf<Pair<Int, Int>>()\\n            var size = 1\\n            grid[row][col] = label\\n            queue.add(Pair(row, col))\\n            while (queue.isNotEmpty()) {\\n                val (r, c) = queue.removeAt(0)\\n                for (step in steps) {\\n                    val nextR = r + step.first\\n                    val nextC = c + step.second\\n                    if (label(nextR, nextC) == 1) {\\n                        size++\\n                        grid[nextR][nextC] = label\\n                        queue.add(Pair(nextR, nextC))\\n                    }\\n                }\\n            }\\n            return size\\n        }\\n\\n        fun discoverIslands() {\\n            var k = firstLabel\\n            for (row in 0 until n) {\\n                for (col in 0 until n) {\\n                    if (grid[row][col] == 1) {\\n                        val size = conquerIsland(k, row, col)\\n                        sizes[k] = size\\n                        k++\\n                    }\\n                }\\n            }\\n        }\\n\\n        fun largestCombinedIsland(): Int {\\n            var maxSize = sizes.getOrDefault(firstLabel, 0)\\n            for (row in 0 until n) {\\n                for (col in 0 until n) {\\n                    if (grid[row][col] == 0) {\\n                        val neighbors = steps.map { (dr, dc) -> label(row + dr, col + dc) }.toSet()\\n                        val combinedSize = neighbors.map { label -> sizes.getOrDefault(label, 0) }.sum()\\n                        maxSize = maxOf(combinedSize + 1, maxSize)\\n                    }\\n                }\\n            }\\n            return maxSize\\n        }\\n\\n        discoverIslands()\\n        return largestCombinedIsland()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun largestIsland(grid: Array<IntArray>): Int {\\n        val n = grid.size\\n        val firstLabel = 2\\n        val sizes = mutableMapOf<Int, Int>()\\n        val steps = arrayOf(Pair(-1, 0), Pair(1, 0), Pair(0, -1), Pair(0, 1))\\n\\n        fun label(row: Int, col: Int): Int =\\n            if (row < 0 || row >= n || col < 0 || col >= n) 0 else grid[row][col]\\n\\n        fun conquerIsland(label: Int, row: Int, col: Int): Int {\\n            val queue = mutableListOf<Pair<Int, Int>>()\\n            var size = 1\\n            grid[row][col] = label\\n            queue.add(Pair(row, col))\\n            while (queue.isNotEmpty()) {\\n                val (r, c) = queue.removeAt(0)\\n                for (step in steps) {\\n                    val nextR = r + step.first\\n                    val nextC = c + step.second\\n                    if (label(nextR, nextC) == 1) {\\n                        size++\\n                        grid[nextR][nextC] = label\\n                        queue.add(Pair(nextR, nextC))\\n                    }\\n                }\\n            }\\n            return size\\n        }\\n\\n        fun discoverIslands() {\\n            var k = firstLabel\\n            for (row in 0 until n) {\\n                for (col in 0 until n) {\\n                    if (grid[row][col] == 1) {\\n                        val size = conquerIsland(k, row, col)\\n                        sizes[k] = size\\n                        k++\\n                    }\\n                }\\n            }\\n        }\\n\\n        fun largestCombinedIsland(): Int {\\n            var maxSize = sizes.getOrDefault(firstLabel, 0)\\n            for (row in 0 until n) {\\n                for (col in 0 until n) {\\n                    if (grid[row][col] == 0) {\\n                        val neighbors = steps.map { (dr, dc) -> label(row + dr, col + dc) }.toSet()\\n                        val combinedSize = neighbors.map { label -> sizes.getOrDefault(label, 0) }.sum()\\n                        maxSize = maxOf(combinedSize + 1, maxSize)\\n                    }\\n                }\\n            }\\n            return maxSize\\n        }\\n\\n        discoverIslands()\\n        return largestCombinedIsland()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1377932,
                "title": "java-bfs-solution-with-explanation-meaningful-variables",
                "content": "```\\nclass Solution {\\n    private int R;\\n    private int C;\\n    private int[] dx = {-1,0,0,1};\\n    private int[] dy = {0,-1,1,0};\\n    public int largestIsland(int[][] grid) {\\n        this.R = grid.length;\\n        this.C = grid[0].length;\\n        \\n        int max = 0;\\n        int id = 2;\\n        Map<Integer, Integer> area = new HashMap<>();\\n        area.put(0, 0); // We\\'ll need this for later, when we\\'re testing the 0s -> 1\\n        for (int row = 0; row < R; row++) {\\n            for (int col = 0; col < C; col++) {\\n                if (grid[row][col] == 1) {\\n                    int islandArea = bfs(grid, row, col, id);\\n                    area.put(id, islandArea);\\n                    max = Math.max(max, islandArea); // Just in case all gird spots are 1s.\\n                    id++;\\n                }\\n            }\\n        }\\n        \\n        // Now we need to check all the 0s, and look in the 4 directions, add up the total areas + 1 and update the max\\n        for (int row = 0; row < R; row++) {\\n            for (int col = 0; col < C; col++) {\\n                if (grid[row][col] == 0) {\\n                    int sum = 1;\\n                    Set<Integer> idSeen = new HashSet<>();\\n                    for (int i = 0; i < dx.length; i++) {\\n                        int newRow = row + dx[i];\\n                        int newCol = col + dy[i];\\n                        if (isInbounds(newRow, newCol) && !idSeen.contains(grid[newRow][newCol])) {\\n                            idSeen.add(grid[newRow][newCol]);\\n                            sum += area.get(grid[newRow][newCol]);\\n                        }\\n                    }\\n                    \\n                    max = Math.max(max, sum);\\n                }\\n            }\\n        }\\n        \\n        return max;\\n    }\\n    \\n    // Count the current islands area, and mark each spot with the ID\\n    private int bfs(int[][] grid, int x, int y, int id) {\\n        Queue<int[]> queue = new ArrayDeque<>();\\n        int area = 0;\\n        queue.add(new int[]{x,y});\\n        grid[x][y] = id;\\n        while (!queue.isEmpty()) {\\n            area++;\\n            int row = queue.peek()[0];\\n            int col = queue.poll()[1];\\n            for (int i = 0; i < dx.length; i++) {\\n                int newRow = row + dx[i];\\n                int newCol = col + dy[i];\\n                if (isInbounds(newRow, newCol) && grid[newRow][newCol] == 1) {\\n                    grid[newRow][newCol] = id;\\n                    queue.add(new int[]{newRow, newCol});\\n                }\\n            }\\n        }\\n        \\n        return area;\\n    }\\n    \\n    private boolean isInbounds(int row, int col) {\\n        return (row >= 0 && row < R && col >= 0 && col < C);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    private int R;\\n    private int C;\\n    private int[] dx = {-1,0,0,1}",
                "codeTag": "Java"
            },
            {
                "id": 1377879,
                "title": "simple-c-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    //function to mark the id\\n    void mark(vector<vector<int>>& G, int i, int j, int n, int id)\\n    {\\n        G[i][j] = id;\\n        \\n        if(i-1 >= 0 and G[i-1][j] == 1)\\n            mark(G, i-1, j, n, id);\\n        \\n        if(i+1 < n and G[i+1][j] == 1)\\n            mark(G, i+1, j, n, id);\\n        \\n        if(j-1 >= 0 and G[i][j-1] == 1)\\n            mark(G, i, j-1, n, id);\\n        \\n        if(j+1 < n and G[i][j+1] == 1)\\n            mark(G, i, j+1, n, id);\\n    }\\n    \\n    //function to calculate area of island\\n    int calcArea(vector<vector<int>>& G, vector<vector<bool>>& visited, int i, int j, int n)\\n    {\\n        int area = 1;\\n        visited[i][j] = true;   //mark true if visited\\n        \\n        if(i-1 >= 0 and G[i-1][j] == 1 and !visited[i-1][j])\\n            area += calcArea(G, visited, i-1, j, n);\\n        \\n        if(i+1 < n and G[i+1][j] == 1 and !visited[i+1][j])\\n            area += calcArea(G, visited, i+1, j, n);\\n        \\n        if(j-1 >= 0 and G[i][j-1] == 1 and !visited[i][j-1])\\n            area += calcArea(G, visited, i, j-1, n);\\n        \\n        if(j+1 < n and G[i][j+1] == 1 and !visited[i][j+1])\\n            area += calcArea(G, visited, i, j+1, n);\\n        \\n        return area;\\n    }\\n    \\n    int largestIsland(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();    //size of the matrix\\n        vector<vector<bool>> visited(n, vector<bool>(n, false));   //mark the mark the island whether visited earlier or not\\n        map<int,int> mp;    //map between island id and area of that island       \\n        int maxArea = 0;    //maximum area ever counted      \\n        int id = 2;   //next id of the island to be assigned\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            if(grid[i][j] == 1)\\n            {\\n                int area = calcArea(grid, visited, i, j, n);\\n                maxArea = max(maxArea, area);\\n                mark(grid, i, j, n, id);\\n                \\n                mp.insert({id,area});  //mapping id and area of island\\n                \\n                id++;\\n            }\\n        }\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                if(grid[i][j] == 0)             \\n                {\\n                    set<int> diffIsland; //stores the id\\'s of different neighbour island \\n                    int tArea = 1;\\n                    \\n                    if(i+1 < n)\\n                        diffIsland.insert(grid[i+1][j]);\\n                    if(i-1 >= 0)\\n                        diffIsland.insert(grid[i-1][j]);\\n                    if(j+1 < n)\\n                        diffIsland.insert(grid[i][j+1]);\\n                    if(j-1 >= 0)\\n                        diffIsland.insert(grid[i][j-1]);\\n                    \\n                    // adding areas of neighbour islands\\n                    for(int it : diffIsland)\\n                        tArea += mp[it];\\n                    \\n                    maxArea = max(maxArea, tArea);\\n                }\\n            }\\n        }\\n        \\n        return maxArea;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    //function to mark the id\\n    void mark(vector<vector<int>>& G, int i, int j, int n, int id)\\n    {\\n        G[i][j] = id;\\n        \\n        if(i-1 >= 0 and G[i-1][j] == 1)\\n            mark(G, i-1, j, n, id);\\n        \\n        if(i+1 < n and G[i+1][j] == 1)\\n            mark(G, i+1, j, n, id);\\n        \\n        if(j-1 >= 0 and G[i][j-1] == 1)\\n            mark(G, i, j-1, n, id);\\n        \\n        if(j+1 < n and G[i][j+1] == 1)\\n            mark(G, i, j+1, n, id);\\n    }\\n    \\n    //function to calculate area of island\\n    int calcArea(vector<vector<int>>& G, vector<vector<bool>>& visited, int i, int j, int n)\\n    {\\n        int area = 1;\\n        visited[i][j] = true;   //mark true if visited\\n        \\n        if(i-1 >= 0 and G[i-1][j] == 1 and !visited[i-1][j])\\n            area += calcArea(G, visited, i-1, j, n);\\n        \\n        if(i+1 < n and G[i+1][j] == 1 and !visited[i+1][j])\\n            area += calcArea(G, visited, i+1, j, n);\\n        \\n        if(j-1 >= 0 and G[i][j-1] == 1 and !visited[i][j-1])\\n            area += calcArea(G, visited, i, j-1, n);\\n        \\n        if(j+1 < n and G[i][j+1] == 1 and !visited[i][j+1])\\n            area += calcArea(G, visited, i, j+1, n);\\n        \\n        return area;\\n    }\\n    \\n    int largestIsland(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();    //size of the matrix\\n        vector<vector<bool>> visited(n, vector<bool>(n, false));   //mark the mark the island whether visited earlier or not\\n        map<int,int> mp;    //map between island id and area of that island       \\n        int maxArea = 0;    //maximum area ever counted      \\n        int id = 2;   //next id of the island to be assigned\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            if(grid[i][j] == 1)\\n            {\\n                int area = calcArea(grid, visited, i, j, n);\\n                maxArea = max(maxArea, area);\\n                mark(grid, i, j, n, id);\\n                \\n                mp.insert({id,area});  //mapping id and area of island\\n                \\n                id++;\\n            }\\n        }\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                if(grid[i][j] == 0)             \\n                {\\n                    set<int> diffIsland; //stores the id\\'s of different neighbour island \\n                    int tArea = 1;\\n                    \\n                    if(i+1 < n)\\n                        diffIsland.insert(grid[i+1][j]);\\n                    if(i-1 >= 0)\\n                        diffIsland.insert(grid[i-1][j]);\\n                    if(j+1 < n)\\n                        diffIsland.insert(grid[i][j+1]);\\n                    if(j-1 >= 0)\\n                        diffIsland.insert(grid[i][j-1]);\\n                    \\n                    // adding areas of neighbour islands\\n                    for(int it : diffIsland)\\n                        tArea += mp[it];\\n                    \\n                    maxArea = max(maxArea, tArea);\\n                }\\n            }\\n        }\\n        \\n        return maxArea;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1377667,
                "title": "python-simple-explanation-o-n-2",
                "content": "```\\nclass Solution:\\n    def largestIsland(self, grid: List[List[int]]) -> int:\\n        R, C = len(grid), len(grid[0])\\n        sizes = [0] #island number to size. island number 0 will always be of size 0\\n        \\n        def find(x, y):\\n            #do not consider outof range or any numbered islands (numbers are negative in grid)\\n            if x == R or x == -1 or y == C or y == -1 or grid[x][y] < 1:\\n                return 0\\n                \\n            grid[x][y] = -len(sizes) #numbering islands -1, -2, -3, ....\\n            return 1 + find(x+1, y) + find(x, y+1) + find(x-1, y) + find(x, y-1)\\n        \\n       \\n        #find all islands.\\n        for i in range(R): #TC: O(R*C)\\n            for j in range(C):\\n                if grid[i][j] != 1: continue\\n                    \\n                area = find(i, j)\\n                sizes.append(area)\\n                \\n           \\n        #find a 0 which connects 2 or more islands. sum up their value\\n        largest = max(sizes)\\n        for i in range(R):  #TC: O(R*C)\\n            for j in range(C):\\n                if grid[i][j] != 0: continue\\n                    \\n                diffIslands = set() #find all different islands. \\n                \\n                #a \\'0\\' can be touching same island in all directions.\\n                #so navigate in all available directions of \\'0\\'. find what is the number in the grid\\n                #that number is island number only represented negatively. so multiply by -1\\n                diffIslands.add(-1*grid[min(R-1,i+1)][j])\\n                diffIslands.add(-1*grid[max(0,i-1)][j])\\n                diffIslands.add(-1*grid[i][min(C-1,j+1)])\\n                diffIslands.add(-1*grid[i][max(0,j-1)])\\n                \\n                #from sizes array sum all diffrent islands touching \\'0\\'. add 1 for current \\'0\\'\\n                s = sum([sizes[i] for i in diffIslands])\\n                largest = max(largest, 1+s)\\n               \\n        \\n        return largest\\n                        \\n        #TC: O(R*C) = O(N^2)    \\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def largestIsland(self, grid: List[List[int]]) -> int:\\n        R, C = len(grid), len(grid[0])\\n        sizes = [0] #island number to size. island number 0 will always be of size 0\\n        \\n        def find(x, y):\\n            #do not consider outof range or any numbered islands (numbers are negative in grid)\\n            if x == R or x == -1 or y == C or y == -1 or grid[x][y] < 1:\\n                return 0\\n                \\n            grid[x][y] = -len(sizes) #numbering islands -1, -2, -3, ....\\n            return 1 + find(x+1, y) + find(x, y+1) + find(x-1, y) + find(x, y-1)\\n        \\n       \\n        #find all islands.\\n        for i in range(R): #TC: O(R*C)\\n            for j in range(C):\\n                if grid[i][j] != 1: continue\\n                    \\n                area = find(i, j)\\n                sizes.append(area)\\n                \\n           \\n        #find a 0 which connects 2 or more islands. sum up their value\\n        largest = max(sizes)\\n        for i in range(R):  #TC: O(R*C)\\n            for j in range(C):\\n                if grid[i][j] != 0: continue\\n                    \\n                diffIslands = set() #find all different islands. \\n                \\n                #a \\'0\\' can be touching same island in all directions.\\n                #so navigate in all available directions of \\'0\\'. find what is the number in the grid\\n                #that number is island number only represented negatively. so multiply by -1\\n                diffIslands.add(-1*grid[min(R-1,i+1)][j])\\n                diffIslands.add(-1*grid[max(0,i-1)][j])\\n                diffIslands.add(-1*grid[i][min(C-1,j+1)])\\n                diffIslands.add(-1*grid[i][max(0,j-1)])\\n                \\n                #from sizes array sum all diffrent islands touching \\'0\\'. add 1 for current \\'0\\'\\n                s = sum([sizes[i] for i in diffIslands])\\n                largest = max(largest, 1+s)\\n               \\n        \\n        return largest\\n                        \\n        #TC: O(R*C) = O(N^2)    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1377224,
                "title": "c-solution-95-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int dir[4][2] = {{1,0},{-1,0},{0,1},{0,-1}};\\n    \\n    int islandsize(vector<vector<int>>& grid, int i, int j, int id){\\n        if(i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size() || grid[i][j] != 1) return 0;\\n        grid[i][j] = id;\\n        \\n        int left = islandsize(grid, i-1, j, id);\\n        int right = islandsize(grid, i+1, j, id);\\n        int up = islandsize(grid, i, j-1, id);\\n        int down = islandsize(grid, i, j+1, id);\\n        return (left + right + up + down) + 1;\\n    }\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        if(m == 0) return 0;\\n        int ans = -1, id = 2;\\n        unordered_map<int,int>mp;\\n        \\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++)\\n                if(grid[i][j] == 1){\\n                    int size = islandsize(grid, i, j, id);\\n                    ans = max(ans, size);\\n                    mp[id++] = size;\\n                }\\n        \\n         for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++)\\n                if(grid[i][j] == 0){\\n                    set<int>s;\\n                    for(auto di : dir){\\n                        int x = di[0] + i, y = di[1] + j;\\n                        if(x > -1 && y > -1 && x < m && y < n && grid[x][y] != 0) \\n                            s.insert(grid[x][y]);\\n                    }\\n                    int sum = 1;\\n                    for(int val : s) \\n                        sum += mp[val];\\n                    \\n                    ans = max(ans, sum);\\n                }\\n        return ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dir[4][2] = {{1,0},{-1,0},{0,1},{0,-1}};\\n    \\n    int islandsize(vector<vector<int>>& grid, int i, int j, int id){\\n        if(i < 0 || j < 0 || i >= grid.size() || j >= grid[0].size() || grid[i][j] != 1) return 0;\\n        grid[i][j] = id;\\n        \\n        int left = islandsize(grid, i-1, j, id);\\n        int right = islandsize(grid, i+1, j, id);\\n        int up = islandsize(grid, i, j-1, id);\\n        int down = islandsize(grid, i, j+1, id);\\n        return (left + right + up + down) + 1;\\n    }\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int m = grid.size(), n = grid[0].size();\\n        if(m == 0) return 0;\\n        int ans = -1, id = 2;\\n        unordered_map<int,int>mp;\\n        \\n        for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++)\\n                if(grid[i][j] == 1){\\n                    int size = islandsize(grid, i, j, id);\\n                    ans = max(ans, size);\\n                    mp[id++] = size;\\n                }\\n        \\n         for(int i = 0; i < m; i++)\\n            for(int j = 0; j < n; j++)\\n                if(grid[i][j] == 0){\\n                    set<int>s;\\n                    for(auto di : dir){\\n                        int x = di[0] + i, y = di[1] + j;\\n                        if(x > -1 && y > -1 && x < m && y < n && grid[x][y] != 0) \\n                            s.insert(grid[x][y]);\\n                    }\\n                    int sum = 1;\\n                    for(int val : s) \\n                        sum += mp[val];\\n                    \\n                    ans = max(ans, sum);\\n                }\\n        return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1377134,
                "title": "cpp-solution-making-a-large-island",
                "content": "```\\nclass Solution {\\npublic:\\n    int getisland(vector<vector<int>>&grid,int id,int i,int j)\\n    {\\n        if(i<0 or j<0 or j>=grid[0].size() or i>=grid.size() or grid[i][j]!=1)\\n        {\\n            return 0;\\n        }\\n        grid[i][j]=id;\\n        int left=getisland(grid,id,i,j-1);\\n        int right=getisland(grid,id,i,j+1);\\n        int top=getisland(grid,id,i-1,j);\\n        int bottom=getisland(grid,id,i+1,j);\\n        return left+right+top+bottom+1;\\n        \\n    }\\n    int largestIsland(vector<vector<int>>& grid) \\n    {\\n        int dir[4][4]={{1,0},{0,1},{-1,0},{0,-1}};\\n        if(grid.size()==0)\\n        {\\n            return 0;\\n        }\\n        int id=2,max=0;\\n        int n=grid.size(),m=grid[0].size();\\n        map<int,int> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    int size=getisland(grid,id,i,j);\\n                    if(size>max)\\n                    {\\n                        max=size;\\n                    }\\n                    mp[id]=size;\\n                    id++;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==0)\\n                {\\n                    set<int>s;\\n                    for(int k=0;k<4;k++)\\n                    {\\n                        int x=dir[k][0]+i,y=dir[k][1]+j;\\n                        if(x>=0 and y>=0 and x<m and y<n and grid[x][y]!=0)\\n                        {\\n                            s.insert(grid[x][y]);\\n                        }\\n                    }\\n                    int sum=1;\\n                  \\n                    for(auto x:s)\\n                    {\\n                        int val=mp[x];\\n                        sum=sum+val;\\n                    }\\n                    if(sum>max)\\n                    {\\n                        max=sum;\\n                    }\\n                }\\n            }\\n        }\\n                   \\n        return max;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getisland(vector<vector<int>>&grid,int id,int i,int j)\\n    {\\n        if(i<0 or j<0 or j>=grid[0].size() or i>=grid.size() or grid[i][j]!=1)\\n        {\\n            return 0;\\n        }\\n        grid[i][j]=id;\\n        int left=getisland(grid,id,i,j-1);\\n        int right=getisland(grid,id,i,j+1);\\n        int top=getisland(grid,id,i-1,j);\\n        int bottom=getisland(grid,id,i+1,j);\\n        return left+right+top+bottom+1;\\n        \\n    }\\n    int largestIsland(vector<vector<int>>& grid) \\n    {\\n        int dir[4][4]={{1,0},{0,1},{-1,0},{0,-1}};\\n        if(grid.size()==0)\\n        {\\n            return 0;\\n        }\\n        int id=2,max=0;\\n        int n=grid.size(),m=grid[0].size();\\n        map<int,int> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==1)\\n                {\\n                    int size=getisland(grid,id,i,j);\\n                    if(size>max)\\n                    {\\n                        max=size;\\n                    }\\n                    mp[id]=size;\\n                    id++;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid[i][j]==0)\\n                {\\n                    set<int>s;\\n                    for(int k=0;k<4;k++)\\n                    {\\n                        int x=dir[k][0]+i,y=dir[k][1]+j;\\n                        if(x>=0 and y>=0 and x<m and y<n and grid[x][y]!=0)\\n                        {\\n                            s.insert(grid[x][y]);\\n                        }\\n                    }\\n                    int sum=1;\\n                  \\n                    for(auto x:s)\\n                    {\\n                        int val=mp[x];\\n                        sum=sum+val;\\n                    }\\n                    if(sum>max)\\n                    {\\n                        max=sum;\\n                    }\\n                }\\n            }\\n        }\\n                   \\n        return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1376871,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int largestIsland(int[][] grid) {\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0,0);\\n        int n = grid.length;\\n        int gridId = 2;\\n        // Task 1 assign id and value for each grid(1)\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j]==1){\\n                    int size = assignIdandReturnArea(grid, i, j, gridId);\\n                    map.put(gridId,size);\\n                    gridId++;\\n                }   \\n            }\\n        }\\n        \\n        int res = map.getOrDefault(2,0);\\n        \\n        for(int i=0; i<n;i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j]==0){\\n                    // we will use set to avoid adding isLand with same id\\n                    Set<Integer> set = new HashSet<>();\\n                    \\n                    set.add(i>0?grid[i-1][j]:0); // top id\\n                    set.add(i<grid.length-1?grid[i+1][j]:0); // bottom id\\n                    set.add(j>0?grid[i][j-1]:0); // left id\\n                    set.add(j<grid[0].length-1?grid[i][j+1]:0); // right id\\n                    \\n                    int totalArea = 1; // we need to count the current island as well\\n                    for(int id:set){\\n                        totalArea += map.get(id); \\n                    }\\n                    res = Math.max(res, totalArea);\\n                }\\n            }\\n        }\\n     return res;     \\n    }\\n    \\n    private int assignIdandReturnArea(int[][] grid, int i, int j, int id){\\n        if(i<0 || j<0 || j>=grid[0].length || i>=grid.length || grid[i][j]!=1) return 0;\\n        \\n        grid[i][j] = id;\\n        \\n        return 1 + assignIdandReturnArea(grid, i-1, j, id) + assignIdandReturnArea(grid, i+1, j, id) +\\n            assignIdandReturnArea(grid, i, j-1, id) + assignIdandReturnArea(grid, i, j+1, id);\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int largestIsland(int[][] grid) {\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        map.put(0,0);\\n        int n = grid.length;\\n        int gridId = 2;\\n        // Task 1 assign id and value for each grid(1)\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j]==1){\\n                    int size = assignIdandReturnArea(grid, i, j, gridId);\\n                    map.put(gridId,size);\\n                    gridId++;\\n                }   \\n            }\\n        }\\n        \\n        int res = map.getOrDefault(2,0);\\n        \\n        for(int i=0; i<n;i++){\\n            for(int j=0; j<n; j++){\\n                if(grid[i][j]==0){\\n                    // we will use set to avoid adding isLand with same id\\n                    Set<Integer> set = new HashSet<>();\\n                    \\n                    set.add(i>0?grid[i-1][j]:0); // top id\\n                    set.add(i<grid.length-1?grid[i+1][j]:0); // bottom id\\n                    set.add(j>0?grid[i][j-1]:0); // left id\\n                    set.add(j<grid[0].length-1?grid[i][j+1]:0); // right id\\n                    \\n                    int totalArea = 1; // we need to count the current island as well\\n                    for(int id:set){\\n                        totalArea += map.get(id); \\n                    }\\n                    res = Math.max(res, totalArea);\\n                }\\n            }\\n        }\\n     return res;     \\n    }\\n    \\n    private int assignIdandReturnArea(int[][] grid, int i, int j, int id){\\n        if(i<0 || j<0 || j>=grid[0].length || i>=grid.length || grid[i][j]!=1) return 0;\\n        \\n        grid[i][j] = id;\\n        \\n        return 1 + assignIdandReturnArea(grid, i-1, j, id) + assignIdandReturnArea(grid, i+1, j, id) +\\n            assignIdandReturnArea(grid, i, j-1, id) + assignIdandReturnArea(grid, i, j+1, id);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1376700,
                "title": "c-bfs-o-n-2-5",
                "content": "```\\nclass Solution {\\npublic:\\n    int n, idx = 2;\\n    pair<int, int> dir[4] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n    void bfs(int r, int c, vector<vector<int>> &grid, vector<int> &area) {\\n        queue<pair<int, int>> q;\\n        q.emplace(r, c);\\n        int cnt = 0;\\n        grid[r][c] = idx;\\n        for (; !q.empty();) {\\n            auto [i, j] = q.front();\\n            cnt++;\\n            q.pop();\\n            for (auto &d : dir) {\\n                int ni = i + d.first, nj = j + d.second;\\n                if (ni >= 0 && nj >= 0 && ni < n && nj < n && grid[ni][nj] == 1) {\\n                    grid[ni][nj] = idx;\\n                    q.emplace(ni, nj);\\n                }\\n            }\\n        }\\n        area[idx++] = cnt; \\n    }\\n    int largestIsland(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        if (n == 1) return 1;\\n        vector<int> area(n * n * 2);\\n        int ans = 0;\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < n; c++) {\\n                if (grid[r][c] == 1)\\n                    bfs(r, c, grid, area);\\n            }\\n        }\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < n; c++) {\\n                unordered_set<int> s;\\n                s.emplace(grid[r][c]);\\n                for (auto &d : dir) {\\n                    int nr = r + d.first, nc = c + d.second;\\n                    if (nr >= 0 && nr < n && nc >= 0 && nc < n) {\\n                        s.emplace(grid[nr][nc]);\\n                    }\\n                }\\n                int sum = !grid[r][c];\\n                for (auto idx : s)\\n                    sum += area[idx];\\n                ans = max(ans, sum);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int n, idx = 2;\\n    pair<int, int> dir[4] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\\n    void bfs(int r, int c, vector<vector<int>> &grid, vector<int> &area) {\\n        queue<pair<int, int>> q;\\n        q.emplace(r, c);\\n        int cnt = 0;\\n        grid[r][c] = idx;\\n        for (; !q.empty();) {\\n            auto [i, j] = q.front();\\n            cnt++;\\n            q.pop();\\n            for (auto &d : dir) {\\n                int ni = i + d.first, nj = j + d.second;\\n                if (ni >= 0 && nj >= 0 && ni < n && nj < n && grid[ni][nj] == 1) {\\n                    grid[ni][nj] = idx;\\n                    q.emplace(ni, nj);\\n                }\\n            }\\n        }\\n        area[idx++] = cnt; \\n    }\\n    int largestIsland(vector<vector<int>>& grid) {\\n        n = grid.size();\\n        if (n == 1) return 1;\\n        vector<int> area(n * n * 2);\\n        int ans = 0;\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < n; c++) {\\n                if (grid[r][c] == 1)\\n                    bfs(r, c, grid, area);\\n            }\\n        }\\n        for (int r = 0; r < n; r++) {\\n            for (int c = 0; c < n; c++) {\\n                unordered_set<int> s;\\n                s.emplace(grid[r][c]);\\n                for (auto &d : dir) {\\n                    int nr = r + d.first, nc = c + d.second;\\n                    if (nr >= 0 && nr < n && nc >= 0 && nc < n) {\\n                        s.emplace(grid[nr][nc]);\\n                    }\\n                }\\n                int sum = !grid[r][c];\\n                for (auto idx : s)\\n                    sum += area[idx];\\n                ans = max(ans, sum);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1376612,
                "title": "easy-c-solution-using-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int r,c;\\n    unordered_map<int,int> mp;   \\n    vector<int> dx = {1,0,0,-1};\\n    vector<int> dy = {0,1,-1,0};\\n    int size=0;\\n    bool isValid(int i, int j){\\n        return (i>=0&&j>=0&&i<r&&j<c);\\n    }\\n    void dfs(vector<vector<int>>& a, int i, int j,int& id,vector<vector<int>>& b,vector<vector<bool>>& vis){\\n        vis[i][j]=true;\\n        size+=1;\\n        b[i][j]=id;\\n        for(int q=0;q<4;q++){\\n            int nr = i+dx[q];\\n            int nc = j+dy[q];\\n            if(isValid(nr,nc)){\\n                if(a[nr][nc]==1){\\n                    if(vis[nr][nc]==false) dfs(a,nr,nc,id,b,vis);\\n                }\\n            }\\n        }\\n    }\\n    int largestIsland(vector<vector<int>>& a) {\\n        r=a.size(), c=a[0].size();\\n        vector<vector<int>> b(r,vector<int>(c,0)); \\n        bool ones=false,zeros=false;\\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n                if(a[i][j]==0)zeros=true;\\n                else ones=true;\\n            }\\n        }\\n        if(ones == false) return 1;\\n        if(zeros == false) return (int)(r*c);\\n        int res = 0;\\n        int id = 2;\\n        vector<vector<bool>> vis(r,vector<bool>(c,false));\\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n                size=0;\\n                if(a[i][j]==1 && vis[i][j]==false){\\n                    dfs(a,i,j,id,b,vis);\\n                    mp[id] = size;\\n                    id += 1;\\n                }\\n            }\\n        }\\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n                if(b[i][j]==0){\\n                    set<int> s;\\n                    for(int q=0;q<4;q++){\\n                        int nr = i+dx[q];\\n                        int nc = j+dy[q];\\n                        if(isValid(nr,nc)){\\n                            if(b[nr][nc]!=0){\\n                                s.insert(b[nr][nc]);   \\n                            }\\n                        }\\n                    }\\n                    int curr = 1;\\n                    for(auto it : s){\\n                        curr += mp[it];\\n                    }\\n                    res = max(res, curr);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Feel free to share your approach/suggestions.**",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int r,c;\\n    unordered_map<int,int> mp;   \\n    vector<int> dx = {1,0,0,-1};\\n    vector<int> dy = {0,1,-1,0};\\n    int size=0;\\n    bool isValid(int i, int j){\\n        return (i>=0&&j>=0&&i<r&&j<c);\\n    }\\n    void dfs(vector<vector<int>>& a, int i, int j,int& id,vector<vector<int>>& b,vector<vector<bool>>& vis){\\n        vis[i][j]=true;\\n        size+=1;\\n        b[i][j]=id;\\n        for(int q=0;q<4;q++){\\n            int nr = i+dx[q];\\n            int nc = j+dy[q];\\n            if(isValid(nr,nc)){\\n                if(a[nr][nc]==1){\\n                    if(vis[nr][nc]==false) dfs(a,nr,nc,id,b,vis);\\n                }\\n            }\\n        }\\n    }\\n    int largestIsland(vector<vector<int>>& a) {\\n        r=a.size(), c=a[0].size();\\n        vector<vector<int>> b(r,vector<int>(c,0)); \\n        bool ones=false,zeros=false;\\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n                if(a[i][j]==0)zeros=true;\\n                else ones=true;\\n            }\\n        }\\n        if(ones == false) return 1;\\n        if(zeros == false) return (int)(r*c);\\n        int res = 0;\\n        int id = 2;\\n        vector<vector<bool>> vis(r,vector<bool>(c,false));\\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n                size=0;\\n                if(a[i][j]==1 && vis[i][j]==false){\\n                    dfs(a,i,j,id,b,vis);\\n                    mp[id] = size;\\n                    id += 1;\\n                }\\n            }\\n        }\\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n                if(b[i][j]==0){\\n                    set<int> s;\\n                    for(int q=0;q<4;q++){\\n                        int nr = i+dx[q];\\n                        int nc = j+dy[q];\\n                        if(isValid(nr,nc)){\\n                            if(b[nr][nc]!=0){\\n                                s.insert(b[nr][nc]);   \\n                            }\\n                        }\\n                    }\\n                    int curr = 1;\\n                    for(auto it : s){\\n                        curr += mp[it];\\n                    }\\n                    res = max(res, curr);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1376436,
                "title": "making-a-large-island-linear-time-and-space",
                "content": "Let\\'s start from creating a disjoint set of all islands, using compressed path and ranking improvements. Also, we will store the size of each connected set on its parent, in the same way like we storing the rank.\\n\\nWhile building such union, we will keep track of max island we have encountered till now. After finishing first iteration over the table, we will make another iteration on each zero, and summarize sizes of all distinctive islands, touching current cell, add 1 for the current cel and take max between it and curent max island size.\\n\\nUpon finishing second iteration, we have an answer. \\nTime complexity will be O(m \\\\* \\u03B1(m, size)), where m is number of operations (additions, unions and finds), bound by O(size), and size = n * n, so, the time complexity will be \\u2248O(n * n), or linear with the grid size.\\nThe meory complexity is bound by O(n * n) as well.\\n\\n[Disjoint set explained](https://www.cs.princeton.edu/courses/archive/spring13/cos423/lectures/UnionFind.pdf)\\n\\n```\\nfunction largestIsland(grid: number[][]): number {\\n    const size = grid.length;\\n    const dSet = new DisjointSet<number>();\\n\\n    let maxIsland = 0;\\n    for (let i = 0; i < size; i++) {\\n        for (let j = 0; j < size; j++) {\\n            if (grid[i][j] === 1) {\\n                const key = calcKey(i, j, size);\\n                dSet.add(key);\\n                getNeighbors(key, size).filter(dSet.has.bind(dSet)).forEach((neighbor: number) => dSet.union(key, neighbor));\\n                maxIsland = Math.max(dSet.getSetSize(key), maxIsland);\\n            }\\n        }\\n    }\\n\\n    for (let i = 0; i < size; i++) {\\n        for (let j = 0; j < size; j++) {\\n            if (grid[i][j] === 0) {\\n                maxIsland = Math.max(maxIsland, 1 + combineNeighbors(dSet, i, j, size));\\n            }\\n        }\\n    }\\n\\n    return maxIsland;\\n};\\n\\nfunction combineNeighbors(dSet: DisjointSet<number>, i: number, j: number, size: number) {\\n    const islands = Array.from(new Set(getNeighbors(calcKey(i, j, size), size).filter(dSet.has.bind(dSet)).map(dSet.getAncestor.bind(dSet))));\\n    return islands.map(anc => dSet.getSetSize(anc.parent)).reduce((iSize, acc) => acc + iSize, 0);\\n}\\n\\nfunction offset(size: number): number {\\n    return size + 1;\\n}\\n\\nfunction calcKey(i: number, j: number, size: number): number {\\n    return i * offset(size)+ j;\\n}\\n\\nfunction getNeighbors(key: number, size: number): number[] {\\n    return [key - offset(size), key + offset(size), key - 1, key + 1]\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction largestIsland(grid: number[][]): number {\\n    const size = grid.length;\\n    const dSet = new DisjointSet<number>();\\n\\n    let maxIsland = 0;\\n    for (let i = 0; i < size; i++) {\\n        for (let j = 0; j < size; j++) {\\n            if (grid[i][j] === 1) {\\n                const key = calcKey(i, j, size);\\n                dSet.add(key);\\n                getNeighbors(key, size).filter(dSet.has.bind(dSet)).forEach((neighbor: number) => dSet.union(key, neighbor));\\n                maxIsland = Math.max(dSet.getSetSize(key), maxIsland);\\n            }\\n        }\\n    }\\n\\n    for (let i = 0; i < size; i++) {\\n        for (let j = 0; j < size; j++) {\\n            if (grid[i][j] === 0) {\\n                maxIsland = Math.max(maxIsland, 1 + combineNeighbors(dSet, i, j, size));\\n            }\\n        }\\n    }\\n\\n    return maxIsland;\\n};\\n\\nfunction combineNeighbors(dSet: DisjointSet<number>, i: number, j: number, size: number) {\\n    const islands = Array.from(new Set(getNeighbors(calcKey(i, j, size), size).filter(dSet.has.bind(dSet)).map(dSet.getAncestor.bind(dSet))));\\n    return islands.map(anc => dSet.getSetSize(anc.parent)).reduce((iSize, acc) => acc + iSize, 0);\\n}\\n\\nfunction offset(size: number): number {\\n    return size + 1;\\n}\\n\\nfunction calcKey(i: number, j: number, size: number): number {\\n    return i * offset(size)+ j;\\n}\\n\\nfunction getNeighbors(key: number, size: number): number[] {\\n    return [key - offset(size), key + offset(size), key - 1, key + 1]\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1751488,
                "content": [
                    {
                        "username": "harshit4me",
                        "content": "Peoples are mad. below it has written, don\\'t post any solutions but they are stilling pasting. We have another option also to post the solutions."
                    },
                    {
                        "username": "michaeljosephhearn",
                        "content": "This was fun, do easier island problems then work up to this one. <3"
                    },
                    {
                        "username": "allenlsy",
                        "content": "I think the official implementation behind python3 is wrong. For this case:\\n\\n[[1,0,1,0],[0,0,0,1],[1,0,1,0]]\\n\\nThe largest island should be 4. But when I run the code with custom test cases, the expected result is 3, which is wrong.\\n"
                    },
                    {
                        "username": "rahulraikwar00",
                        "content": "Grid should be n*n! according to question!"
                    },
                    {
                        "username": "wenjunwang2014",
                        "content": "For a case such like \\n[[1,1,0,1],[1,0,0,1]]\\nThe answer should be 6, however the test code gives 4."
                    },
                    {
                        "username": "Vibhoar_Bajaj",
                        "content": "the question states n*n"
                    },
                    {
                        "username": "SeineAle",
                        "content": "I am ashamed of 1754 ms rt and 480 mb mem in  C ++but I am proud that I did it smh."
                    },
                    {
                        "username": "ssredotime",
                        "content": "I love problems like this. So much more satisfying than some medium or easy labelled array problem \"find the kth smallest permutation of the maximum noncontiguous subarray after optionally removing up to j elements at indices where (i, nums[i]) are co-prime\"."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Logic is not difficult. But the implementation part is a bit long.\\nUsed Python BFS + Hashmap for solving. "
                    },
                    {
                        "username": "CodeCrusader1",
                        "content": "class DSU {\\n    int[] parent;\\n    int[] size;\\n    int max;\\n\\n    public DSU(int n) {\\n        parent = new int[n];\\n        size = new int[n];\\n        max = 0;\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = -1;\\n            size[i] = 1;\\n        }\\n    }\\n\\n\\n    public int biggest() {\\n        return max;\\n    }\\n\\n    public int find(int x) {\\n        if (parent[x] != x)\\n            parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n\\n    public void addIsland(int x) {\\n        if (parent[x] >= 0)\\n            return;\\n        parent[x] = x;\\n        max=Math.max(max,1);\\n    }\\n\\n    public void union(int x, int y) {\\n        int px = find(x), py = find(y);\\n\\n        if (px != py) {\\n            if (size[px] >= size[py]) {\\n                size[px] += size[py];\\n                parent[py] = px;\\n                max = Math.max(max, size[px]);\\n            } else {\\n                size[py] += size[px];\\n                parent[px] = py;\\n                max = Math.max(max, size[py]);\\n            }\\n        }\\n    }\\n      public int getS(int x) {\\n          int px= find(x);\\n        return size[px];\\n    }\\n\\n    public boolean check(int x){\\n        if (parent[x] >= 0) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    public int largestIsland(int[][] grid) {\\n        int n = grid.length;\\n        DSU set = new DSU(n * n);\\n        int drow[] = {-1, 1, 0, 0};\\n        int dcol[] = {0, 0, -1, 1};\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    set.addIsland(i*n+j);\\n                    for (int k = 0; k < 4; k++) {\\n                        int dr = i + drow[k];\\n                        int dc = j + dcol[k];\\n                        int child = n * dr + dc;\\n                        if (dr >= 0 && dr < n && dc >= 0 && dc < n)\\n                           if(set.check(dr*n+dc))\\n                            set.union(i * n + j, child);\\n                    }\\n                }\\n            }\\n        } \\n         int res=set.biggest();\\n         for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                 \\n                if (grid[i][j] == 0) {                    \\n                    int temp=1;\\n                    Set<Integer> hs= new HashSet<>();\\n                    for (int k = 0; k < 4; k++) {\\n                        int dr = i + drow[k];\\n                        int dc = j + dcol[k];\\n                        int child = n * dr + dc;\\n                        if (dr >= 0 && dr < n && dc >= 0 && dc < n)\\n                           if(set.check(dr*n+dc)){\\n                              if( hs.add(set.find(child))){\\n                                    temp+=set.getS(child);\\n                              }\\n\\n                           }                             \\n                    }\\n                res= Math.max(res,temp);\\n                }\\n\\n            }\\n        }\\n\\n       return res;\\n    }\\n}\\n"
                    },
                    {
                        "username": "tr1ten",
                        "content": "WTH with this python runtime? \\nInitially i submitted the code (N^2) it threw TLE, again i submitted the same code now it beats 70% python solution in runtime. "
                    },
                    {
                        "username": "AnantDuhan",
                        "content": "```\\nclass DisjointSet {\\npublic:\\n    vector<int> rank, parent, size;\\n\\tDisjointSet(int n) {\\n\\t\\trank.resize(n + 1, 0);\\n\\t\\tsize.resize(n + 1);\\n\\t\\tparent.resize(n + 1);\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tparent[i] = i;\\n\\t\\t\\tsize[i] = 1;\\n\\t\\t}\\n\\t}\\n\\n\\t// finding ultimate parent\\n\\tint findUltimateParent(int node) {\\n\\t\\tif (node == parent[node])\\n\\t\\t\\treturn node;\\n\\t\\treturn parent[node] = findUltimateParent(parent[node]);\\n\\t}\\n\\n\\tvoid unionByRank(int u, int v) {\\n\\t\\tint UltimateParent_u = findUltimateParent(u);\\n\\t\\tint UltimateParent_v = findUltimateParent(v);\\n\\n\\t\\tif (UltimateParent_u == UltimateParent_v)\\n\\t\\t\\treturn;\\n\\n\\t\\tif (rank[UltimateParent_u] < rank[UltimateParent_v])\\n\\t\\t\\tparent[UltimateParent_u] = UltimateParent_v;\\n\\t\\telse if (rank[UltimateParent_v] < rank[UltimateParent_u])\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\telse {\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\t\\trank[UltimateParent_u]++;\\n\\t\\t}\\n\\t}\\n\\n\\tvoid unionBySize(int u, int v) {\\n\\t\\tint UltimateParent_u = findUltimateParent(u);\\n\\t\\tint UltimateParent_v = findUltimateParent(v);\\n\\n\\t\\tif (UltimateParent_u == UltimateParent_v)\\n\\t\\t\\treturn;\\n\\n\\t\\tif (rank[UltimateParent_u] < rank[UltimateParent_v]) {\\n\\t\\t\\tparent[UltimateParent_u] = UltimateParent_v;\\n\\t\\t\\tsize[UltimateParent_v] += size[UltimateParent_u];\\n\\t\\t} else {\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\t\\tsize[UltimateParent_u] += size[UltimateParent_v];\\n\\t\\t}\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        DisjointSet ds(n*n);\\n\\n        // Connecting components -> step-1\\n        for(int row=0;row<n;row++) {\\n            for(int col=0;col<n;col++) {\\n                if(grid[row][col] == 0)\\n                    continue;\\n                int delrow[] = {-1, 0, 1, 0};\\n                int delcol[] = {0, -1, 0, 1};\\n\\n                for(int i=0;i<4;i++) {\\n                    int nrow = row + delrow[i];\\n                    int ncol = col + delcol[i];\\n                    if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < n) {\\n                        if(grid[nrow][ncol] == 1) {\\n                            int nodeNumber = row * n + col;\\n                            int adjNodeNumber = nrow * n + ncol;\\n                            ds.unionBySize(nodeNumber, adjNodeNumber);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Try Changing 0 to 1 -> step-2\\n        int maxi = 0;\\n        for(int row=0;row<n;row++) {\\n            for(int col=0;col<n;col++) {\\n                if(grid[row][col] == 1)\\n                    continue;\\n                int delrow[] = {-1, 0, 1, 0};\\n                int delcol[] = {0, -1, 0, 1};\\n\\n                set<int> components;\\n                for(int i=0;i<4;i++) {\\n                    int nrow = row + delrow[i];\\n                    int ncol = col + delcol[i];\\n\\n                    if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < n) {\\n                        if(grid[nrow][ncol] == 1) {\\n                            components.insert(ds.findUltimateParent(nrow * n + ncol));       \\n                        }\\n                    }\\n                }\\n                int totalSize = 0;\\n                for(auto it: components) {\\n                    totalSize += ds.size[it];\\n                }\\n                maxi = max(maxi, totalSize + 1);\\n            }\\n        }\\n\\n        for(int cellNumber = 0; cellNumber < n * n; cellNumber++) {\\n            maxi = max(maxi, ds.size[ds.findUltimateParent(cellNumber)]);\\n        }\\n        return maxi;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avminus",
                        "content": "solution kyu daal raha hai discuss mein bro"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Nice solution !! I have done the same just with dfs !"
                    }
                ]
            },
            {
                "id": 1889738,
                "content": [
                    {
                        "username": "harshit4me",
                        "content": "Peoples are mad. below it has written, don\\'t post any solutions but they are stilling pasting. We have another option also to post the solutions."
                    },
                    {
                        "username": "michaeljosephhearn",
                        "content": "This was fun, do easier island problems then work up to this one. <3"
                    },
                    {
                        "username": "allenlsy",
                        "content": "I think the official implementation behind python3 is wrong. For this case:\\n\\n[[1,0,1,0],[0,0,0,1],[1,0,1,0]]\\n\\nThe largest island should be 4. But when I run the code with custom test cases, the expected result is 3, which is wrong.\\n"
                    },
                    {
                        "username": "rahulraikwar00",
                        "content": "Grid should be n*n! according to question!"
                    },
                    {
                        "username": "wenjunwang2014",
                        "content": "For a case such like \\n[[1,1,0,1],[1,0,0,1]]\\nThe answer should be 6, however the test code gives 4."
                    },
                    {
                        "username": "Vibhoar_Bajaj",
                        "content": "the question states n*n"
                    },
                    {
                        "username": "SeineAle",
                        "content": "I am ashamed of 1754 ms rt and 480 mb mem in  C ++but I am proud that I did it smh."
                    },
                    {
                        "username": "ssredotime",
                        "content": "I love problems like this. So much more satisfying than some medium or easy labelled array problem \"find the kth smallest permutation of the maximum noncontiguous subarray after optionally removing up to j elements at indices where (i, nums[i]) are co-prime\"."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Logic is not difficult. But the implementation part is a bit long.\\nUsed Python BFS + Hashmap for solving. "
                    },
                    {
                        "username": "CodeCrusader1",
                        "content": "class DSU {\\n    int[] parent;\\n    int[] size;\\n    int max;\\n\\n    public DSU(int n) {\\n        parent = new int[n];\\n        size = new int[n];\\n        max = 0;\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = -1;\\n            size[i] = 1;\\n        }\\n    }\\n\\n\\n    public int biggest() {\\n        return max;\\n    }\\n\\n    public int find(int x) {\\n        if (parent[x] != x)\\n            parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n\\n    public void addIsland(int x) {\\n        if (parent[x] >= 0)\\n            return;\\n        parent[x] = x;\\n        max=Math.max(max,1);\\n    }\\n\\n    public void union(int x, int y) {\\n        int px = find(x), py = find(y);\\n\\n        if (px != py) {\\n            if (size[px] >= size[py]) {\\n                size[px] += size[py];\\n                parent[py] = px;\\n                max = Math.max(max, size[px]);\\n            } else {\\n                size[py] += size[px];\\n                parent[px] = py;\\n                max = Math.max(max, size[py]);\\n            }\\n        }\\n    }\\n      public int getS(int x) {\\n          int px= find(x);\\n        return size[px];\\n    }\\n\\n    public boolean check(int x){\\n        if (parent[x] >= 0) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    public int largestIsland(int[][] grid) {\\n        int n = grid.length;\\n        DSU set = new DSU(n * n);\\n        int drow[] = {-1, 1, 0, 0};\\n        int dcol[] = {0, 0, -1, 1};\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    set.addIsland(i*n+j);\\n                    for (int k = 0; k < 4; k++) {\\n                        int dr = i + drow[k];\\n                        int dc = j + dcol[k];\\n                        int child = n * dr + dc;\\n                        if (dr >= 0 && dr < n && dc >= 0 && dc < n)\\n                           if(set.check(dr*n+dc))\\n                            set.union(i * n + j, child);\\n                    }\\n                }\\n            }\\n        } \\n         int res=set.biggest();\\n         for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                 \\n                if (grid[i][j] == 0) {                    \\n                    int temp=1;\\n                    Set<Integer> hs= new HashSet<>();\\n                    for (int k = 0; k < 4; k++) {\\n                        int dr = i + drow[k];\\n                        int dc = j + dcol[k];\\n                        int child = n * dr + dc;\\n                        if (dr >= 0 && dr < n && dc >= 0 && dc < n)\\n                           if(set.check(dr*n+dc)){\\n                              if( hs.add(set.find(child))){\\n                                    temp+=set.getS(child);\\n                              }\\n\\n                           }                             \\n                    }\\n                res= Math.max(res,temp);\\n                }\\n\\n            }\\n        }\\n\\n       return res;\\n    }\\n}\\n"
                    },
                    {
                        "username": "tr1ten",
                        "content": "WTH with this python runtime? \\nInitially i submitted the code (N^2) it threw TLE, again i submitted the same code now it beats 70% python solution in runtime. "
                    },
                    {
                        "username": "AnantDuhan",
                        "content": "```\\nclass DisjointSet {\\npublic:\\n    vector<int> rank, parent, size;\\n\\tDisjointSet(int n) {\\n\\t\\trank.resize(n + 1, 0);\\n\\t\\tsize.resize(n + 1);\\n\\t\\tparent.resize(n + 1);\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tparent[i] = i;\\n\\t\\t\\tsize[i] = 1;\\n\\t\\t}\\n\\t}\\n\\n\\t// finding ultimate parent\\n\\tint findUltimateParent(int node) {\\n\\t\\tif (node == parent[node])\\n\\t\\t\\treturn node;\\n\\t\\treturn parent[node] = findUltimateParent(parent[node]);\\n\\t}\\n\\n\\tvoid unionByRank(int u, int v) {\\n\\t\\tint UltimateParent_u = findUltimateParent(u);\\n\\t\\tint UltimateParent_v = findUltimateParent(v);\\n\\n\\t\\tif (UltimateParent_u == UltimateParent_v)\\n\\t\\t\\treturn;\\n\\n\\t\\tif (rank[UltimateParent_u] < rank[UltimateParent_v])\\n\\t\\t\\tparent[UltimateParent_u] = UltimateParent_v;\\n\\t\\telse if (rank[UltimateParent_v] < rank[UltimateParent_u])\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\telse {\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\t\\trank[UltimateParent_u]++;\\n\\t\\t}\\n\\t}\\n\\n\\tvoid unionBySize(int u, int v) {\\n\\t\\tint UltimateParent_u = findUltimateParent(u);\\n\\t\\tint UltimateParent_v = findUltimateParent(v);\\n\\n\\t\\tif (UltimateParent_u == UltimateParent_v)\\n\\t\\t\\treturn;\\n\\n\\t\\tif (rank[UltimateParent_u] < rank[UltimateParent_v]) {\\n\\t\\t\\tparent[UltimateParent_u] = UltimateParent_v;\\n\\t\\t\\tsize[UltimateParent_v] += size[UltimateParent_u];\\n\\t\\t} else {\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\t\\tsize[UltimateParent_u] += size[UltimateParent_v];\\n\\t\\t}\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        DisjointSet ds(n*n);\\n\\n        // Connecting components -> step-1\\n        for(int row=0;row<n;row++) {\\n            for(int col=0;col<n;col++) {\\n                if(grid[row][col] == 0)\\n                    continue;\\n                int delrow[] = {-1, 0, 1, 0};\\n                int delcol[] = {0, -1, 0, 1};\\n\\n                for(int i=0;i<4;i++) {\\n                    int nrow = row + delrow[i];\\n                    int ncol = col + delcol[i];\\n                    if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < n) {\\n                        if(grid[nrow][ncol] == 1) {\\n                            int nodeNumber = row * n + col;\\n                            int adjNodeNumber = nrow * n + ncol;\\n                            ds.unionBySize(nodeNumber, adjNodeNumber);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Try Changing 0 to 1 -> step-2\\n        int maxi = 0;\\n        for(int row=0;row<n;row++) {\\n            for(int col=0;col<n;col++) {\\n                if(grid[row][col] == 1)\\n                    continue;\\n                int delrow[] = {-1, 0, 1, 0};\\n                int delcol[] = {0, -1, 0, 1};\\n\\n                set<int> components;\\n                for(int i=0;i<4;i++) {\\n                    int nrow = row + delrow[i];\\n                    int ncol = col + delcol[i];\\n\\n                    if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < n) {\\n                        if(grid[nrow][ncol] == 1) {\\n                            components.insert(ds.findUltimateParent(nrow * n + ncol));       \\n                        }\\n                    }\\n                }\\n                int totalSize = 0;\\n                for(auto it: components) {\\n                    totalSize += ds.size[it];\\n                }\\n                maxi = max(maxi, totalSize + 1);\\n            }\\n        }\\n\\n        for(int cellNumber = 0; cellNumber < n * n; cellNumber++) {\\n            maxi = max(maxi, ds.size[ds.findUltimateParent(cellNumber)]);\\n        }\\n        return maxi;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avminus",
                        "content": "solution kyu daal raha hai discuss mein bro"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Nice solution !! I have done the same just with dfs !"
                    }
                ]
            },
            {
                "id": 1573778,
                "content": [
                    {
                        "username": "harshit4me",
                        "content": "Peoples are mad. below it has written, don\\'t post any solutions but they are stilling pasting. We have another option also to post the solutions."
                    },
                    {
                        "username": "michaeljosephhearn",
                        "content": "This was fun, do easier island problems then work up to this one. <3"
                    },
                    {
                        "username": "allenlsy",
                        "content": "I think the official implementation behind python3 is wrong. For this case:\\n\\n[[1,0,1,0],[0,0,0,1],[1,0,1,0]]\\n\\nThe largest island should be 4. But when I run the code with custom test cases, the expected result is 3, which is wrong.\\n"
                    },
                    {
                        "username": "rahulraikwar00",
                        "content": "Grid should be n*n! according to question!"
                    },
                    {
                        "username": "wenjunwang2014",
                        "content": "For a case such like \\n[[1,1,0,1],[1,0,0,1]]\\nThe answer should be 6, however the test code gives 4."
                    },
                    {
                        "username": "Vibhoar_Bajaj",
                        "content": "the question states n*n"
                    },
                    {
                        "username": "SeineAle",
                        "content": "I am ashamed of 1754 ms rt and 480 mb mem in  C ++but I am proud that I did it smh."
                    },
                    {
                        "username": "ssredotime",
                        "content": "I love problems like this. So much more satisfying than some medium or easy labelled array problem \"find the kth smallest permutation of the maximum noncontiguous subarray after optionally removing up to j elements at indices where (i, nums[i]) are co-prime\"."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Logic is not difficult. But the implementation part is a bit long.\\nUsed Python BFS + Hashmap for solving. "
                    },
                    {
                        "username": "CodeCrusader1",
                        "content": "class DSU {\\n    int[] parent;\\n    int[] size;\\n    int max;\\n\\n    public DSU(int n) {\\n        parent = new int[n];\\n        size = new int[n];\\n        max = 0;\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = -1;\\n            size[i] = 1;\\n        }\\n    }\\n\\n\\n    public int biggest() {\\n        return max;\\n    }\\n\\n    public int find(int x) {\\n        if (parent[x] != x)\\n            parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n\\n    public void addIsland(int x) {\\n        if (parent[x] >= 0)\\n            return;\\n        parent[x] = x;\\n        max=Math.max(max,1);\\n    }\\n\\n    public void union(int x, int y) {\\n        int px = find(x), py = find(y);\\n\\n        if (px != py) {\\n            if (size[px] >= size[py]) {\\n                size[px] += size[py];\\n                parent[py] = px;\\n                max = Math.max(max, size[px]);\\n            } else {\\n                size[py] += size[px];\\n                parent[px] = py;\\n                max = Math.max(max, size[py]);\\n            }\\n        }\\n    }\\n      public int getS(int x) {\\n          int px= find(x);\\n        return size[px];\\n    }\\n\\n    public boolean check(int x){\\n        if (parent[x] >= 0) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    public int largestIsland(int[][] grid) {\\n        int n = grid.length;\\n        DSU set = new DSU(n * n);\\n        int drow[] = {-1, 1, 0, 0};\\n        int dcol[] = {0, 0, -1, 1};\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    set.addIsland(i*n+j);\\n                    for (int k = 0; k < 4; k++) {\\n                        int dr = i + drow[k];\\n                        int dc = j + dcol[k];\\n                        int child = n * dr + dc;\\n                        if (dr >= 0 && dr < n && dc >= 0 && dc < n)\\n                           if(set.check(dr*n+dc))\\n                            set.union(i * n + j, child);\\n                    }\\n                }\\n            }\\n        } \\n         int res=set.biggest();\\n         for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                 \\n                if (grid[i][j] == 0) {                    \\n                    int temp=1;\\n                    Set<Integer> hs= new HashSet<>();\\n                    for (int k = 0; k < 4; k++) {\\n                        int dr = i + drow[k];\\n                        int dc = j + dcol[k];\\n                        int child = n * dr + dc;\\n                        if (dr >= 0 && dr < n && dc >= 0 && dc < n)\\n                           if(set.check(dr*n+dc)){\\n                              if( hs.add(set.find(child))){\\n                                    temp+=set.getS(child);\\n                              }\\n\\n                           }                             \\n                    }\\n                res= Math.max(res,temp);\\n                }\\n\\n            }\\n        }\\n\\n       return res;\\n    }\\n}\\n"
                    },
                    {
                        "username": "tr1ten",
                        "content": "WTH with this python runtime? \\nInitially i submitted the code (N^2) it threw TLE, again i submitted the same code now it beats 70% python solution in runtime. "
                    },
                    {
                        "username": "AnantDuhan",
                        "content": "```\\nclass DisjointSet {\\npublic:\\n    vector<int> rank, parent, size;\\n\\tDisjointSet(int n) {\\n\\t\\trank.resize(n + 1, 0);\\n\\t\\tsize.resize(n + 1);\\n\\t\\tparent.resize(n + 1);\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tparent[i] = i;\\n\\t\\t\\tsize[i] = 1;\\n\\t\\t}\\n\\t}\\n\\n\\t// finding ultimate parent\\n\\tint findUltimateParent(int node) {\\n\\t\\tif (node == parent[node])\\n\\t\\t\\treturn node;\\n\\t\\treturn parent[node] = findUltimateParent(parent[node]);\\n\\t}\\n\\n\\tvoid unionByRank(int u, int v) {\\n\\t\\tint UltimateParent_u = findUltimateParent(u);\\n\\t\\tint UltimateParent_v = findUltimateParent(v);\\n\\n\\t\\tif (UltimateParent_u == UltimateParent_v)\\n\\t\\t\\treturn;\\n\\n\\t\\tif (rank[UltimateParent_u] < rank[UltimateParent_v])\\n\\t\\t\\tparent[UltimateParent_u] = UltimateParent_v;\\n\\t\\telse if (rank[UltimateParent_v] < rank[UltimateParent_u])\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\telse {\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\t\\trank[UltimateParent_u]++;\\n\\t\\t}\\n\\t}\\n\\n\\tvoid unionBySize(int u, int v) {\\n\\t\\tint UltimateParent_u = findUltimateParent(u);\\n\\t\\tint UltimateParent_v = findUltimateParent(v);\\n\\n\\t\\tif (UltimateParent_u == UltimateParent_v)\\n\\t\\t\\treturn;\\n\\n\\t\\tif (rank[UltimateParent_u] < rank[UltimateParent_v]) {\\n\\t\\t\\tparent[UltimateParent_u] = UltimateParent_v;\\n\\t\\t\\tsize[UltimateParent_v] += size[UltimateParent_u];\\n\\t\\t} else {\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\t\\tsize[UltimateParent_u] += size[UltimateParent_v];\\n\\t\\t}\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        DisjointSet ds(n*n);\\n\\n        // Connecting components -> step-1\\n        for(int row=0;row<n;row++) {\\n            for(int col=0;col<n;col++) {\\n                if(grid[row][col] == 0)\\n                    continue;\\n                int delrow[] = {-1, 0, 1, 0};\\n                int delcol[] = {0, -1, 0, 1};\\n\\n                for(int i=0;i<4;i++) {\\n                    int nrow = row + delrow[i];\\n                    int ncol = col + delcol[i];\\n                    if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < n) {\\n                        if(grid[nrow][ncol] == 1) {\\n                            int nodeNumber = row * n + col;\\n                            int adjNodeNumber = nrow * n + ncol;\\n                            ds.unionBySize(nodeNumber, adjNodeNumber);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Try Changing 0 to 1 -> step-2\\n        int maxi = 0;\\n        for(int row=0;row<n;row++) {\\n            for(int col=0;col<n;col++) {\\n                if(grid[row][col] == 1)\\n                    continue;\\n                int delrow[] = {-1, 0, 1, 0};\\n                int delcol[] = {0, -1, 0, 1};\\n\\n                set<int> components;\\n                for(int i=0;i<4;i++) {\\n                    int nrow = row + delrow[i];\\n                    int ncol = col + delcol[i];\\n\\n                    if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < n) {\\n                        if(grid[nrow][ncol] == 1) {\\n                            components.insert(ds.findUltimateParent(nrow * n + ncol));       \\n                        }\\n                    }\\n                }\\n                int totalSize = 0;\\n                for(auto it: components) {\\n                    totalSize += ds.size[it];\\n                }\\n                maxi = max(maxi, totalSize + 1);\\n            }\\n        }\\n\\n        for(int cellNumber = 0; cellNumber < n * n; cellNumber++) {\\n            maxi = max(maxi, ds.size[ds.findUltimateParent(cellNumber)]);\\n        }\\n        return maxi;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avminus",
                        "content": "solution kyu daal raha hai discuss mein bro"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Nice solution !! I have done the same just with dfs !"
                    }
                ]
            },
            {
                "id": 1571942,
                "content": [
                    {
                        "username": "harshit4me",
                        "content": "Peoples are mad. below it has written, don\\'t post any solutions but they are stilling pasting. We have another option also to post the solutions."
                    },
                    {
                        "username": "michaeljosephhearn",
                        "content": "This was fun, do easier island problems then work up to this one. <3"
                    },
                    {
                        "username": "allenlsy",
                        "content": "I think the official implementation behind python3 is wrong. For this case:\\n\\n[[1,0,1,0],[0,0,0,1],[1,0,1,0]]\\n\\nThe largest island should be 4. But when I run the code with custom test cases, the expected result is 3, which is wrong.\\n"
                    },
                    {
                        "username": "rahulraikwar00",
                        "content": "Grid should be n*n! according to question!"
                    },
                    {
                        "username": "wenjunwang2014",
                        "content": "For a case such like \\n[[1,1,0,1],[1,0,0,1]]\\nThe answer should be 6, however the test code gives 4."
                    },
                    {
                        "username": "Vibhoar_Bajaj",
                        "content": "the question states n*n"
                    },
                    {
                        "username": "SeineAle",
                        "content": "I am ashamed of 1754 ms rt and 480 mb mem in  C ++but I am proud that I did it smh."
                    },
                    {
                        "username": "ssredotime",
                        "content": "I love problems like this. So much more satisfying than some medium or easy labelled array problem \"find the kth smallest permutation of the maximum noncontiguous subarray after optionally removing up to j elements at indices where (i, nums[i]) are co-prime\"."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Logic is not difficult. But the implementation part is a bit long.\\nUsed Python BFS + Hashmap for solving. "
                    },
                    {
                        "username": "CodeCrusader1",
                        "content": "class DSU {\\n    int[] parent;\\n    int[] size;\\n    int max;\\n\\n    public DSU(int n) {\\n        parent = new int[n];\\n        size = new int[n];\\n        max = 0;\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = -1;\\n            size[i] = 1;\\n        }\\n    }\\n\\n\\n    public int biggest() {\\n        return max;\\n    }\\n\\n    public int find(int x) {\\n        if (parent[x] != x)\\n            parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n\\n    public void addIsland(int x) {\\n        if (parent[x] >= 0)\\n            return;\\n        parent[x] = x;\\n        max=Math.max(max,1);\\n    }\\n\\n    public void union(int x, int y) {\\n        int px = find(x), py = find(y);\\n\\n        if (px != py) {\\n            if (size[px] >= size[py]) {\\n                size[px] += size[py];\\n                parent[py] = px;\\n                max = Math.max(max, size[px]);\\n            } else {\\n                size[py] += size[px];\\n                parent[px] = py;\\n                max = Math.max(max, size[py]);\\n            }\\n        }\\n    }\\n      public int getS(int x) {\\n          int px= find(x);\\n        return size[px];\\n    }\\n\\n    public boolean check(int x){\\n        if (parent[x] >= 0) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    public int largestIsland(int[][] grid) {\\n        int n = grid.length;\\n        DSU set = new DSU(n * n);\\n        int drow[] = {-1, 1, 0, 0};\\n        int dcol[] = {0, 0, -1, 1};\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    set.addIsland(i*n+j);\\n                    for (int k = 0; k < 4; k++) {\\n                        int dr = i + drow[k];\\n                        int dc = j + dcol[k];\\n                        int child = n * dr + dc;\\n                        if (dr >= 0 && dr < n && dc >= 0 && dc < n)\\n                           if(set.check(dr*n+dc))\\n                            set.union(i * n + j, child);\\n                    }\\n                }\\n            }\\n        } \\n         int res=set.biggest();\\n         for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                 \\n                if (grid[i][j] == 0) {                    \\n                    int temp=1;\\n                    Set<Integer> hs= new HashSet<>();\\n                    for (int k = 0; k < 4; k++) {\\n                        int dr = i + drow[k];\\n                        int dc = j + dcol[k];\\n                        int child = n * dr + dc;\\n                        if (dr >= 0 && dr < n && dc >= 0 && dc < n)\\n                           if(set.check(dr*n+dc)){\\n                              if( hs.add(set.find(child))){\\n                                    temp+=set.getS(child);\\n                              }\\n\\n                           }                             \\n                    }\\n                res= Math.max(res,temp);\\n                }\\n\\n            }\\n        }\\n\\n       return res;\\n    }\\n}\\n"
                    },
                    {
                        "username": "tr1ten",
                        "content": "WTH with this python runtime? \\nInitially i submitted the code (N^2) it threw TLE, again i submitted the same code now it beats 70% python solution in runtime. "
                    },
                    {
                        "username": "AnantDuhan",
                        "content": "```\\nclass DisjointSet {\\npublic:\\n    vector<int> rank, parent, size;\\n\\tDisjointSet(int n) {\\n\\t\\trank.resize(n + 1, 0);\\n\\t\\tsize.resize(n + 1);\\n\\t\\tparent.resize(n + 1);\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tparent[i] = i;\\n\\t\\t\\tsize[i] = 1;\\n\\t\\t}\\n\\t}\\n\\n\\t// finding ultimate parent\\n\\tint findUltimateParent(int node) {\\n\\t\\tif (node == parent[node])\\n\\t\\t\\treturn node;\\n\\t\\treturn parent[node] = findUltimateParent(parent[node]);\\n\\t}\\n\\n\\tvoid unionByRank(int u, int v) {\\n\\t\\tint UltimateParent_u = findUltimateParent(u);\\n\\t\\tint UltimateParent_v = findUltimateParent(v);\\n\\n\\t\\tif (UltimateParent_u == UltimateParent_v)\\n\\t\\t\\treturn;\\n\\n\\t\\tif (rank[UltimateParent_u] < rank[UltimateParent_v])\\n\\t\\t\\tparent[UltimateParent_u] = UltimateParent_v;\\n\\t\\telse if (rank[UltimateParent_v] < rank[UltimateParent_u])\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\telse {\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\t\\trank[UltimateParent_u]++;\\n\\t\\t}\\n\\t}\\n\\n\\tvoid unionBySize(int u, int v) {\\n\\t\\tint UltimateParent_u = findUltimateParent(u);\\n\\t\\tint UltimateParent_v = findUltimateParent(v);\\n\\n\\t\\tif (UltimateParent_u == UltimateParent_v)\\n\\t\\t\\treturn;\\n\\n\\t\\tif (rank[UltimateParent_u] < rank[UltimateParent_v]) {\\n\\t\\t\\tparent[UltimateParent_u] = UltimateParent_v;\\n\\t\\t\\tsize[UltimateParent_v] += size[UltimateParent_u];\\n\\t\\t} else {\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\t\\tsize[UltimateParent_u] += size[UltimateParent_v];\\n\\t\\t}\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        DisjointSet ds(n*n);\\n\\n        // Connecting components -> step-1\\n        for(int row=0;row<n;row++) {\\n            for(int col=0;col<n;col++) {\\n                if(grid[row][col] == 0)\\n                    continue;\\n                int delrow[] = {-1, 0, 1, 0};\\n                int delcol[] = {0, -1, 0, 1};\\n\\n                for(int i=0;i<4;i++) {\\n                    int nrow = row + delrow[i];\\n                    int ncol = col + delcol[i];\\n                    if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < n) {\\n                        if(grid[nrow][ncol] == 1) {\\n                            int nodeNumber = row * n + col;\\n                            int adjNodeNumber = nrow * n + ncol;\\n                            ds.unionBySize(nodeNumber, adjNodeNumber);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Try Changing 0 to 1 -> step-2\\n        int maxi = 0;\\n        for(int row=0;row<n;row++) {\\n            for(int col=0;col<n;col++) {\\n                if(grid[row][col] == 1)\\n                    continue;\\n                int delrow[] = {-1, 0, 1, 0};\\n                int delcol[] = {0, -1, 0, 1};\\n\\n                set<int> components;\\n                for(int i=0;i<4;i++) {\\n                    int nrow = row + delrow[i];\\n                    int ncol = col + delcol[i];\\n\\n                    if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < n) {\\n                        if(grid[nrow][ncol] == 1) {\\n                            components.insert(ds.findUltimateParent(nrow * n + ncol));       \\n                        }\\n                    }\\n                }\\n                int totalSize = 0;\\n                for(auto it: components) {\\n                    totalSize += ds.size[it];\\n                }\\n                maxi = max(maxi, totalSize + 1);\\n            }\\n        }\\n\\n        for(int cellNumber = 0; cellNumber < n * n; cellNumber++) {\\n            maxi = max(maxi, ds.size[ds.findUltimateParent(cellNumber)]);\\n        }\\n        return maxi;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avminus",
                        "content": "solution kyu daal raha hai discuss mein bro"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Nice solution !! I have done the same just with dfs !"
                    }
                ]
            },
            {
                "id": 2059330,
                "content": [
                    {
                        "username": "harshit4me",
                        "content": "Peoples are mad. below it has written, don\\'t post any solutions but they are stilling pasting. We have another option also to post the solutions."
                    },
                    {
                        "username": "michaeljosephhearn",
                        "content": "This was fun, do easier island problems then work up to this one. <3"
                    },
                    {
                        "username": "allenlsy",
                        "content": "I think the official implementation behind python3 is wrong. For this case:\\n\\n[[1,0,1,0],[0,0,0,1],[1,0,1,0]]\\n\\nThe largest island should be 4. But when I run the code with custom test cases, the expected result is 3, which is wrong.\\n"
                    },
                    {
                        "username": "rahulraikwar00",
                        "content": "Grid should be n*n! according to question!"
                    },
                    {
                        "username": "wenjunwang2014",
                        "content": "For a case such like \\n[[1,1,0,1],[1,0,0,1]]\\nThe answer should be 6, however the test code gives 4."
                    },
                    {
                        "username": "Vibhoar_Bajaj",
                        "content": "the question states n*n"
                    },
                    {
                        "username": "SeineAle",
                        "content": "I am ashamed of 1754 ms rt and 480 mb mem in  C ++but I am proud that I did it smh."
                    },
                    {
                        "username": "ssredotime",
                        "content": "I love problems like this. So much more satisfying than some medium or easy labelled array problem \"find the kth smallest permutation of the maximum noncontiguous subarray after optionally removing up to j elements at indices where (i, nums[i]) are co-prime\"."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Logic is not difficult. But the implementation part is a bit long.\\nUsed Python BFS + Hashmap for solving. "
                    },
                    {
                        "username": "CodeCrusader1",
                        "content": "class DSU {\\n    int[] parent;\\n    int[] size;\\n    int max;\\n\\n    public DSU(int n) {\\n        parent = new int[n];\\n        size = new int[n];\\n        max = 0;\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = -1;\\n            size[i] = 1;\\n        }\\n    }\\n\\n\\n    public int biggest() {\\n        return max;\\n    }\\n\\n    public int find(int x) {\\n        if (parent[x] != x)\\n            parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n\\n    public void addIsland(int x) {\\n        if (parent[x] >= 0)\\n            return;\\n        parent[x] = x;\\n        max=Math.max(max,1);\\n    }\\n\\n    public void union(int x, int y) {\\n        int px = find(x), py = find(y);\\n\\n        if (px != py) {\\n            if (size[px] >= size[py]) {\\n                size[px] += size[py];\\n                parent[py] = px;\\n                max = Math.max(max, size[px]);\\n            } else {\\n                size[py] += size[px];\\n                parent[px] = py;\\n                max = Math.max(max, size[py]);\\n            }\\n        }\\n    }\\n      public int getS(int x) {\\n          int px= find(x);\\n        return size[px];\\n    }\\n\\n    public boolean check(int x){\\n        if (parent[x] >= 0) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    public int largestIsland(int[][] grid) {\\n        int n = grid.length;\\n        DSU set = new DSU(n * n);\\n        int drow[] = {-1, 1, 0, 0};\\n        int dcol[] = {0, 0, -1, 1};\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    set.addIsland(i*n+j);\\n                    for (int k = 0; k < 4; k++) {\\n                        int dr = i + drow[k];\\n                        int dc = j + dcol[k];\\n                        int child = n * dr + dc;\\n                        if (dr >= 0 && dr < n && dc >= 0 && dc < n)\\n                           if(set.check(dr*n+dc))\\n                            set.union(i * n + j, child);\\n                    }\\n                }\\n            }\\n        } \\n         int res=set.biggest();\\n         for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                 \\n                if (grid[i][j] == 0) {                    \\n                    int temp=1;\\n                    Set<Integer> hs= new HashSet<>();\\n                    for (int k = 0; k < 4; k++) {\\n                        int dr = i + drow[k];\\n                        int dc = j + dcol[k];\\n                        int child = n * dr + dc;\\n                        if (dr >= 0 && dr < n && dc >= 0 && dc < n)\\n                           if(set.check(dr*n+dc)){\\n                              if( hs.add(set.find(child))){\\n                                    temp+=set.getS(child);\\n                              }\\n\\n                           }                             \\n                    }\\n                res= Math.max(res,temp);\\n                }\\n\\n            }\\n        }\\n\\n       return res;\\n    }\\n}\\n"
                    },
                    {
                        "username": "tr1ten",
                        "content": "WTH with this python runtime? \\nInitially i submitted the code (N^2) it threw TLE, again i submitted the same code now it beats 70% python solution in runtime. "
                    },
                    {
                        "username": "AnantDuhan",
                        "content": "```\\nclass DisjointSet {\\npublic:\\n    vector<int> rank, parent, size;\\n\\tDisjointSet(int n) {\\n\\t\\trank.resize(n + 1, 0);\\n\\t\\tsize.resize(n + 1);\\n\\t\\tparent.resize(n + 1);\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tparent[i] = i;\\n\\t\\t\\tsize[i] = 1;\\n\\t\\t}\\n\\t}\\n\\n\\t// finding ultimate parent\\n\\tint findUltimateParent(int node) {\\n\\t\\tif (node == parent[node])\\n\\t\\t\\treturn node;\\n\\t\\treturn parent[node] = findUltimateParent(parent[node]);\\n\\t}\\n\\n\\tvoid unionByRank(int u, int v) {\\n\\t\\tint UltimateParent_u = findUltimateParent(u);\\n\\t\\tint UltimateParent_v = findUltimateParent(v);\\n\\n\\t\\tif (UltimateParent_u == UltimateParent_v)\\n\\t\\t\\treturn;\\n\\n\\t\\tif (rank[UltimateParent_u] < rank[UltimateParent_v])\\n\\t\\t\\tparent[UltimateParent_u] = UltimateParent_v;\\n\\t\\telse if (rank[UltimateParent_v] < rank[UltimateParent_u])\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\telse {\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\t\\trank[UltimateParent_u]++;\\n\\t\\t}\\n\\t}\\n\\n\\tvoid unionBySize(int u, int v) {\\n\\t\\tint UltimateParent_u = findUltimateParent(u);\\n\\t\\tint UltimateParent_v = findUltimateParent(v);\\n\\n\\t\\tif (UltimateParent_u == UltimateParent_v)\\n\\t\\t\\treturn;\\n\\n\\t\\tif (rank[UltimateParent_u] < rank[UltimateParent_v]) {\\n\\t\\t\\tparent[UltimateParent_u] = UltimateParent_v;\\n\\t\\t\\tsize[UltimateParent_v] += size[UltimateParent_u];\\n\\t\\t} else {\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\t\\tsize[UltimateParent_u] += size[UltimateParent_v];\\n\\t\\t}\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        DisjointSet ds(n*n);\\n\\n        // Connecting components -> step-1\\n        for(int row=0;row<n;row++) {\\n            for(int col=0;col<n;col++) {\\n                if(grid[row][col] == 0)\\n                    continue;\\n                int delrow[] = {-1, 0, 1, 0};\\n                int delcol[] = {0, -1, 0, 1};\\n\\n                for(int i=0;i<4;i++) {\\n                    int nrow = row + delrow[i];\\n                    int ncol = col + delcol[i];\\n                    if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < n) {\\n                        if(grid[nrow][ncol] == 1) {\\n                            int nodeNumber = row * n + col;\\n                            int adjNodeNumber = nrow * n + ncol;\\n                            ds.unionBySize(nodeNumber, adjNodeNumber);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Try Changing 0 to 1 -> step-2\\n        int maxi = 0;\\n        for(int row=0;row<n;row++) {\\n            for(int col=0;col<n;col++) {\\n                if(grid[row][col] == 1)\\n                    continue;\\n                int delrow[] = {-1, 0, 1, 0};\\n                int delcol[] = {0, -1, 0, 1};\\n\\n                set<int> components;\\n                for(int i=0;i<4;i++) {\\n                    int nrow = row + delrow[i];\\n                    int ncol = col + delcol[i];\\n\\n                    if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < n) {\\n                        if(grid[nrow][ncol] == 1) {\\n                            components.insert(ds.findUltimateParent(nrow * n + ncol));       \\n                        }\\n                    }\\n                }\\n                int totalSize = 0;\\n                for(auto it: components) {\\n                    totalSize += ds.size[it];\\n                }\\n                maxi = max(maxi, totalSize + 1);\\n            }\\n        }\\n\\n        for(int cellNumber = 0; cellNumber < n * n; cellNumber++) {\\n            maxi = max(maxi, ds.size[ds.findUltimateParent(cellNumber)]);\\n        }\\n        return maxi;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avminus",
                        "content": "solution kyu daal raha hai discuss mein bro"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Nice solution !! I have done the same just with dfs !"
                    }
                ]
            },
            {
                "id": 2048496,
                "content": [
                    {
                        "username": "harshit4me",
                        "content": "Peoples are mad. below it has written, don\\'t post any solutions but they are stilling pasting. We have another option also to post the solutions."
                    },
                    {
                        "username": "michaeljosephhearn",
                        "content": "This was fun, do easier island problems then work up to this one. <3"
                    },
                    {
                        "username": "allenlsy",
                        "content": "I think the official implementation behind python3 is wrong. For this case:\\n\\n[[1,0,1,0],[0,0,0,1],[1,0,1,0]]\\n\\nThe largest island should be 4. But when I run the code with custom test cases, the expected result is 3, which is wrong.\\n"
                    },
                    {
                        "username": "rahulraikwar00",
                        "content": "Grid should be n*n! according to question!"
                    },
                    {
                        "username": "wenjunwang2014",
                        "content": "For a case such like \\n[[1,1,0,1],[1,0,0,1]]\\nThe answer should be 6, however the test code gives 4."
                    },
                    {
                        "username": "Vibhoar_Bajaj",
                        "content": "the question states n*n"
                    },
                    {
                        "username": "SeineAle",
                        "content": "I am ashamed of 1754 ms rt and 480 mb mem in  C ++but I am proud that I did it smh."
                    },
                    {
                        "username": "ssredotime",
                        "content": "I love problems like this. So much more satisfying than some medium or easy labelled array problem \"find the kth smallest permutation of the maximum noncontiguous subarray after optionally removing up to j elements at indices where (i, nums[i]) are co-prime\"."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Logic is not difficult. But the implementation part is a bit long.\\nUsed Python BFS + Hashmap for solving. "
                    },
                    {
                        "username": "CodeCrusader1",
                        "content": "class DSU {\\n    int[] parent;\\n    int[] size;\\n    int max;\\n\\n    public DSU(int n) {\\n        parent = new int[n];\\n        size = new int[n];\\n        max = 0;\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = -1;\\n            size[i] = 1;\\n        }\\n    }\\n\\n\\n    public int biggest() {\\n        return max;\\n    }\\n\\n    public int find(int x) {\\n        if (parent[x] != x)\\n            parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n\\n    public void addIsland(int x) {\\n        if (parent[x] >= 0)\\n            return;\\n        parent[x] = x;\\n        max=Math.max(max,1);\\n    }\\n\\n    public void union(int x, int y) {\\n        int px = find(x), py = find(y);\\n\\n        if (px != py) {\\n            if (size[px] >= size[py]) {\\n                size[px] += size[py];\\n                parent[py] = px;\\n                max = Math.max(max, size[px]);\\n            } else {\\n                size[py] += size[px];\\n                parent[px] = py;\\n                max = Math.max(max, size[py]);\\n            }\\n        }\\n    }\\n      public int getS(int x) {\\n          int px= find(x);\\n        return size[px];\\n    }\\n\\n    public boolean check(int x){\\n        if (parent[x] >= 0) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    public int largestIsland(int[][] grid) {\\n        int n = grid.length;\\n        DSU set = new DSU(n * n);\\n        int drow[] = {-1, 1, 0, 0};\\n        int dcol[] = {0, 0, -1, 1};\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    set.addIsland(i*n+j);\\n                    for (int k = 0; k < 4; k++) {\\n                        int dr = i + drow[k];\\n                        int dc = j + dcol[k];\\n                        int child = n * dr + dc;\\n                        if (dr >= 0 && dr < n && dc >= 0 && dc < n)\\n                           if(set.check(dr*n+dc))\\n                            set.union(i * n + j, child);\\n                    }\\n                }\\n            }\\n        } \\n         int res=set.biggest();\\n         for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                 \\n                if (grid[i][j] == 0) {                    \\n                    int temp=1;\\n                    Set<Integer> hs= new HashSet<>();\\n                    for (int k = 0; k < 4; k++) {\\n                        int dr = i + drow[k];\\n                        int dc = j + dcol[k];\\n                        int child = n * dr + dc;\\n                        if (dr >= 0 && dr < n && dc >= 0 && dc < n)\\n                           if(set.check(dr*n+dc)){\\n                              if( hs.add(set.find(child))){\\n                                    temp+=set.getS(child);\\n                              }\\n\\n                           }                             \\n                    }\\n                res= Math.max(res,temp);\\n                }\\n\\n            }\\n        }\\n\\n       return res;\\n    }\\n}\\n"
                    },
                    {
                        "username": "tr1ten",
                        "content": "WTH with this python runtime? \\nInitially i submitted the code (N^2) it threw TLE, again i submitted the same code now it beats 70% python solution in runtime. "
                    },
                    {
                        "username": "AnantDuhan",
                        "content": "```\\nclass DisjointSet {\\npublic:\\n    vector<int> rank, parent, size;\\n\\tDisjointSet(int n) {\\n\\t\\trank.resize(n + 1, 0);\\n\\t\\tsize.resize(n + 1);\\n\\t\\tparent.resize(n + 1);\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tparent[i] = i;\\n\\t\\t\\tsize[i] = 1;\\n\\t\\t}\\n\\t}\\n\\n\\t// finding ultimate parent\\n\\tint findUltimateParent(int node) {\\n\\t\\tif (node == parent[node])\\n\\t\\t\\treturn node;\\n\\t\\treturn parent[node] = findUltimateParent(parent[node]);\\n\\t}\\n\\n\\tvoid unionByRank(int u, int v) {\\n\\t\\tint UltimateParent_u = findUltimateParent(u);\\n\\t\\tint UltimateParent_v = findUltimateParent(v);\\n\\n\\t\\tif (UltimateParent_u == UltimateParent_v)\\n\\t\\t\\treturn;\\n\\n\\t\\tif (rank[UltimateParent_u] < rank[UltimateParent_v])\\n\\t\\t\\tparent[UltimateParent_u] = UltimateParent_v;\\n\\t\\telse if (rank[UltimateParent_v] < rank[UltimateParent_u])\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\telse {\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\t\\trank[UltimateParent_u]++;\\n\\t\\t}\\n\\t}\\n\\n\\tvoid unionBySize(int u, int v) {\\n\\t\\tint UltimateParent_u = findUltimateParent(u);\\n\\t\\tint UltimateParent_v = findUltimateParent(v);\\n\\n\\t\\tif (UltimateParent_u == UltimateParent_v)\\n\\t\\t\\treturn;\\n\\n\\t\\tif (rank[UltimateParent_u] < rank[UltimateParent_v]) {\\n\\t\\t\\tparent[UltimateParent_u] = UltimateParent_v;\\n\\t\\t\\tsize[UltimateParent_v] += size[UltimateParent_u];\\n\\t\\t} else {\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\t\\tsize[UltimateParent_u] += size[UltimateParent_v];\\n\\t\\t}\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        DisjointSet ds(n*n);\\n\\n        // Connecting components -> step-1\\n        for(int row=0;row<n;row++) {\\n            for(int col=0;col<n;col++) {\\n                if(grid[row][col] == 0)\\n                    continue;\\n                int delrow[] = {-1, 0, 1, 0};\\n                int delcol[] = {0, -1, 0, 1};\\n\\n                for(int i=0;i<4;i++) {\\n                    int nrow = row + delrow[i];\\n                    int ncol = col + delcol[i];\\n                    if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < n) {\\n                        if(grid[nrow][ncol] == 1) {\\n                            int nodeNumber = row * n + col;\\n                            int adjNodeNumber = nrow * n + ncol;\\n                            ds.unionBySize(nodeNumber, adjNodeNumber);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Try Changing 0 to 1 -> step-2\\n        int maxi = 0;\\n        for(int row=0;row<n;row++) {\\n            for(int col=0;col<n;col++) {\\n                if(grid[row][col] == 1)\\n                    continue;\\n                int delrow[] = {-1, 0, 1, 0};\\n                int delcol[] = {0, -1, 0, 1};\\n\\n                set<int> components;\\n                for(int i=0;i<4;i++) {\\n                    int nrow = row + delrow[i];\\n                    int ncol = col + delcol[i];\\n\\n                    if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < n) {\\n                        if(grid[nrow][ncol] == 1) {\\n                            components.insert(ds.findUltimateParent(nrow * n + ncol));       \\n                        }\\n                    }\\n                }\\n                int totalSize = 0;\\n                for(auto it: components) {\\n                    totalSize += ds.size[it];\\n                }\\n                maxi = max(maxi, totalSize + 1);\\n            }\\n        }\\n\\n        for(int cellNumber = 0; cellNumber < n * n; cellNumber++) {\\n            maxi = max(maxi, ds.size[ds.findUltimateParent(cellNumber)]);\\n        }\\n        return maxi;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avminus",
                        "content": "solution kyu daal raha hai discuss mein bro"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Nice solution !! I have done the same just with dfs !"
                    }
                ]
            },
            {
                "id": 2027202,
                "content": [
                    {
                        "username": "harshit4me",
                        "content": "Peoples are mad. below it has written, don\\'t post any solutions but they are stilling pasting. We have another option also to post the solutions."
                    },
                    {
                        "username": "michaeljosephhearn",
                        "content": "This was fun, do easier island problems then work up to this one. <3"
                    },
                    {
                        "username": "allenlsy",
                        "content": "I think the official implementation behind python3 is wrong. For this case:\\n\\n[[1,0,1,0],[0,0,0,1],[1,0,1,0]]\\n\\nThe largest island should be 4. But when I run the code with custom test cases, the expected result is 3, which is wrong.\\n"
                    },
                    {
                        "username": "rahulraikwar00",
                        "content": "Grid should be n*n! according to question!"
                    },
                    {
                        "username": "wenjunwang2014",
                        "content": "For a case such like \\n[[1,1,0,1],[1,0,0,1]]\\nThe answer should be 6, however the test code gives 4."
                    },
                    {
                        "username": "Vibhoar_Bajaj",
                        "content": "the question states n*n"
                    },
                    {
                        "username": "SeineAle",
                        "content": "I am ashamed of 1754 ms rt and 480 mb mem in  C ++but I am proud that I did it smh."
                    },
                    {
                        "username": "ssredotime",
                        "content": "I love problems like this. So much more satisfying than some medium or easy labelled array problem \"find the kth smallest permutation of the maximum noncontiguous subarray after optionally removing up to j elements at indices where (i, nums[i]) are co-prime\"."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Logic is not difficult. But the implementation part is a bit long.\\nUsed Python BFS + Hashmap for solving. "
                    },
                    {
                        "username": "CodeCrusader1",
                        "content": "class DSU {\\n    int[] parent;\\n    int[] size;\\n    int max;\\n\\n    public DSU(int n) {\\n        parent = new int[n];\\n        size = new int[n];\\n        max = 0;\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = -1;\\n            size[i] = 1;\\n        }\\n    }\\n\\n\\n    public int biggest() {\\n        return max;\\n    }\\n\\n    public int find(int x) {\\n        if (parent[x] != x)\\n            parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n\\n    public void addIsland(int x) {\\n        if (parent[x] >= 0)\\n            return;\\n        parent[x] = x;\\n        max=Math.max(max,1);\\n    }\\n\\n    public void union(int x, int y) {\\n        int px = find(x), py = find(y);\\n\\n        if (px != py) {\\n            if (size[px] >= size[py]) {\\n                size[px] += size[py];\\n                parent[py] = px;\\n                max = Math.max(max, size[px]);\\n            } else {\\n                size[py] += size[px];\\n                parent[px] = py;\\n                max = Math.max(max, size[py]);\\n            }\\n        }\\n    }\\n      public int getS(int x) {\\n          int px= find(x);\\n        return size[px];\\n    }\\n\\n    public boolean check(int x){\\n        if (parent[x] >= 0) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    public int largestIsland(int[][] grid) {\\n        int n = grid.length;\\n        DSU set = new DSU(n * n);\\n        int drow[] = {-1, 1, 0, 0};\\n        int dcol[] = {0, 0, -1, 1};\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    set.addIsland(i*n+j);\\n                    for (int k = 0; k < 4; k++) {\\n                        int dr = i + drow[k];\\n                        int dc = j + dcol[k];\\n                        int child = n * dr + dc;\\n                        if (dr >= 0 && dr < n && dc >= 0 && dc < n)\\n                           if(set.check(dr*n+dc))\\n                            set.union(i * n + j, child);\\n                    }\\n                }\\n            }\\n        } \\n         int res=set.biggest();\\n         for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                 \\n                if (grid[i][j] == 0) {                    \\n                    int temp=1;\\n                    Set<Integer> hs= new HashSet<>();\\n                    for (int k = 0; k < 4; k++) {\\n                        int dr = i + drow[k];\\n                        int dc = j + dcol[k];\\n                        int child = n * dr + dc;\\n                        if (dr >= 0 && dr < n && dc >= 0 && dc < n)\\n                           if(set.check(dr*n+dc)){\\n                              if( hs.add(set.find(child))){\\n                                    temp+=set.getS(child);\\n                              }\\n\\n                           }                             \\n                    }\\n                res= Math.max(res,temp);\\n                }\\n\\n            }\\n        }\\n\\n       return res;\\n    }\\n}\\n"
                    },
                    {
                        "username": "tr1ten",
                        "content": "WTH with this python runtime? \\nInitially i submitted the code (N^2) it threw TLE, again i submitted the same code now it beats 70% python solution in runtime. "
                    },
                    {
                        "username": "AnantDuhan",
                        "content": "```\\nclass DisjointSet {\\npublic:\\n    vector<int> rank, parent, size;\\n\\tDisjointSet(int n) {\\n\\t\\trank.resize(n + 1, 0);\\n\\t\\tsize.resize(n + 1);\\n\\t\\tparent.resize(n + 1);\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tparent[i] = i;\\n\\t\\t\\tsize[i] = 1;\\n\\t\\t}\\n\\t}\\n\\n\\t// finding ultimate parent\\n\\tint findUltimateParent(int node) {\\n\\t\\tif (node == parent[node])\\n\\t\\t\\treturn node;\\n\\t\\treturn parent[node] = findUltimateParent(parent[node]);\\n\\t}\\n\\n\\tvoid unionByRank(int u, int v) {\\n\\t\\tint UltimateParent_u = findUltimateParent(u);\\n\\t\\tint UltimateParent_v = findUltimateParent(v);\\n\\n\\t\\tif (UltimateParent_u == UltimateParent_v)\\n\\t\\t\\treturn;\\n\\n\\t\\tif (rank[UltimateParent_u] < rank[UltimateParent_v])\\n\\t\\t\\tparent[UltimateParent_u] = UltimateParent_v;\\n\\t\\telse if (rank[UltimateParent_v] < rank[UltimateParent_u])\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\telse {\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\t\\trank[UltimateParent_u]++;\\n\\t\\t}\\n\\t}\\n\\n\\tvoid unionBySize(int u, int v) {\\n\\t\\tint UltimateParent_u = findUltimateParent(u);\\n\\t\\tint UltimateParent_v = findUltimateParent(v);\\n\\n\\t\\tif (UltimateParent_u == UltimateParent_v)\\n\\t\\t\\treturn;\\n\\n\\t\\tif (rank[UltimateParent_u] < rank[UltimateParent_v]) {\\n\\t\\t\\tparent[UltimateParent_u] = UltimateParent_v;\\n\\t\\t\\tsize[UltimateParent_v] += size[UltimateParent_u];\\n\\t\\t} else {\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\t\\tsize[UltimateParent_u] += size[UltimateParent_v];\\n\\t\\t}\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        DisjointSet ds(n*n);\\n\\n        // Connecting components -> step-1\\n        for(int row=0;row<n;row++) {\\n            for(int col=0;col<n;col++) {\\n                if(grid[row][col] == 0)\\n                    continue;\\n                int delrow[] = {-1, 0, 1, 0};\\n                int delcol[] = {0, -1, 0, 1};\\n\\n                for(int i=0;i<4;i++) {\\n                    int nrow = row + delrow[i];\\n                    int ncol = col + delcol[i];\\n                    if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < n) {\\n                        if(grid[nrow][ncol] == 1) {\\n                            int nodeNumber = row * n + col;\\n                            int adjNodeNumber = nrow * n + ncol;\\n                            ds.unionBySize(nodeNumber, adjNodeNumber);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Try Changing 0 to 1 -> step-2\\n        int maxi = 0;\\n        for(int row=0;row<n;row++) {\\n            for(int col=0;col<n;col++) {\\n                if(grid[row][col] == 1)\\n                    continue;\\n                int delrow[] = {-1, 0, 1, 0};\\n                int delcol[] = {0, -1, 0, 1};\\n\\n                set<int> components;\\n                for(int i=0;i<4;i++) {\\n                    int nrow = row + delrow[i];\\n                    int ncol = col + delcol[i];\\n\\n                    if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < n) {\\n                        if(grid[nrow][ncol] == 1) {\\n                            components.insert(ds.findUltimateParent(nrow * n + ncol));       \\n                        }\\n                    }\\n                }\\n                int totalSize = 0;\\n                for(auto it: components) {\\n                    totalSize += ds.size[it];\\n                }\\n                maxi = max(maxi, totalSize + 1);\\n            }\\n        }\\n\\n        for(int cellNumber = 0; cellNumber < n * n; cellNumber++) {\\n            maxi = max(maxi, ds.size[ds.findUltimateParent(cellNumber)]);\\n        }\\n        return maxi;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avminus",
                        "content": "solution kyu daal raha hai discuss mein bro"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Nice solution !! I have done the same just with dfs !"
                    }
                ]
            },
            {
                "id": 2023162,
                "content": [
                    {
                        "username": "harshit4me",
                        "content": "Peoples are mad. below it has written, don\\'t post any solutions but they are stilling pasting. We have another option also to post the solutions."
                    },
                    {
                        "username": "michaeljosephhearn",
                        "content": "This was fun, do easier island problems then work up to this one. <3"
                    },
                    {
                        "username": "allenlsy",
                        "content": "I think the official implementation behind python3 is wrong. For this case:\\n\\n[[1,0,1,0],[0,0,0,1],[1,0,1,0]]\\n\\nThe largest island should be 4. But when I run the code with custom test cases, the expected result is 3, which is wrong.\\n"
                    },
                    {
                        "username": "rahulraikwar00",
                        "content": "Grid should be n*n! according to question!"
                    },
                    {
                        "username": "wenjunwang2014",
                        "content": "For a case such like \\n[[1,1,0,1],[1,0,0,1]]\\nThe answer should be 6, however the test code gives 4."
                    },
                    {
                        "username": "Vibhoar_Bajaj",
                        "content": "the question states n*n"
                    },
                    {
                        "username": "SeineAle",
                        "content": "I am ashamed of 1754 ms rt and 480 mb mem in  C ++but I am proud that I did it smh."
                    },
                    {
                        "username": "ssredotime",
                        "content": "I love problems like this. So much more satisfying than some medium or easy labelled array problem \"find the kth smallest permutation of the maximum noncontiguous subarray after optionally removing up to j elements at indices where (i, nums[i]) are co-prime\"."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Logic is not difficult. But the implementation part is a bit long.\\nUsed Python BFS + Hashmap for solving. "
                    },
                    {
                        "username": "CodeCrusader1",
                        "content": "class DSU {\\n    int[] parent;\\n    int[] size;\\n    int max;\\n\\n    public DSU(int n) {\\n        parent = new int[n];\\n        size = new int[n];\\n        max = 0;\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = -1;\\n            size[i] = 1;\\n        }\\n    }\\n\\n\\n    public int biggest() {\\n        return max;\\n    }\\n\\n    public int find(int x) {\\n        if (parent[x] != x)\\n            parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n\\n    public void addIsland(int x) {\\n        if (parent[x] >= 0)\\n            return;\\n        parent[x] = x;\\n        max=Math.max(max,1);\\n    }\\n\\n    public void union(int x, int y) {\\n        int px = find(x), py = find(y);\\n\\n        if (px != py) {\\n            if (size[px] >= size[py]) {\\n                size[px] += size[py];\\n                parent[py] = px;\\n                max = Math.max(max, size[px]);\\n            } else {\\n                size[py] += size[px];\\n                parent[px] = py;\\n                max = Math.max(max, size[py]);\\n            }\\n        }\\n    }\\n      public int getS(int x) {\\n          int px= find(x);\\n        return size[px];\\n    }\\n\\n    public boolean check(int x){\\n        if (parent[x] >= 0) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    public int largestIsland(int[][] grid) {\\n        int n = grid.length;\\n        DSU set = new DSU(n * n);\\n        int drow[] = {-1, 1, 0, 0};\\n        int dcol[] = {0, 0, -1, 1};\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    set.addIsland(i*n+j);\\n                    for (int k = 0; k < 4; k++) {\\n                        int dr = i + drow[k];\\n                        int dc = j + dcol[k];\\n                        int child = n * dr + dc;\\n                        if (dr >= 0 && dr < n && dc >= 0 && dc < n)\\n                           if(set.check(dr*n+dc))\\n                            set.union(i * n + j, child);\\n                    }\\n                }\\n            }\\n        } \\n         int res=set.biggest();\\n         for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                 \\n                if (grid[i][j] == 0) {                    \\n                    int temp=1;\\n                    Set<Integer> hs= new HashSet<>();\\n                    for (int k = 0; k < 4; k++) {\\n                        int dr = i + drow[k];\\n                        int dc = j + dcol[k];\\n                        int child = n * dr + dc;\\n                        if (dr >= 0 && dr < n && dc >= 0 && dc < n)\\n                           if(set.check(dr*n+dc)){\\n                              if( hs.add(set.find(child))){\\n                                    temp+=set.getS(child);\\n                              }\\n\\n                           }                             \\n                    }\\n                res= Math.max(res,temp);\\n                }\\n\\n            }\\n        }\\n\\n       return res;\\n    }\\n}\\n"
                    },
                    {
                        "username": "tr1ten",
                        "content": "WTH with this python runtime? \\nInitially i submitted the code (N^2) it threw TLE, again i submitted the same code now it beats 70% python solution in runtime. "
                    },
                    {
                        "username": "AnantDuhan",
                        "content": "```\\nclass DisjointSet {\\npublic:\\n    vector<int> rank, parent, size;\\n\\tDisjointSet(int n) {\\n\\t\\trank.resize(n + 1, 0);\\n\\t\\tsize.resize(n + 1);\\n\\t\\tparent.resize(n + 1);\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tparent[i] = i;\\n\\t\\t\\tsize[i] = 1;\\n\\t\\t}\\n\\t}\\n\\n\\t// finding ultimate parent\\n\\tint findUltimateParent(int node) {\\n\\t\\tif (node == parent[node])\\n\\t\\t\\treturn node;\\n\\t\\treturn parent[node] = findUltimateParent(parent[node]);\\n\\t}\\n\\n\\tvoid unionByRank(int u, int v) {\\n\\t\\tint UltimateParent_u = findUltimateParent(u);\\n\\t\\tint UltimateParent_v = findUltimateParent(v);\\n\\n\\t\\tif (UltimateParent_u == UltimateParent_v)\\n\\t\\t\\treturn;\\n\\n\\t\\tif (rank[UltimateParent_u] < rank[UltimateParent_v])\\n\\t\\t\\tparent[UltimateParent_u] = UltimateParent_v;\\n\\t\\telse if (rank[UltimateParent_v] < rank[UltimateParent_u])\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\telse {\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\t\\trank[UltimateParent_u]++;\\n\\t\\t}\\n\\t}\\n\\n\\tvoid unionBySize(int u, int v) {\\n\\t\\tint UltimateParent_u = findUltimateParent(u);\\n\\t\\tint UltimateParent_v = findUltimateParent(v);\\n\\n\\t\\tif (UltimateParent_u == UltimateParent_v)\\n\\t\\t\\treturn;\\n\\n\\t\\tif (rank[UltimateParent_u] < rank[UltimateParent_v]) {\\n\\t\\t\\tparent[UltimateParent_u] = UltimateParent_v;\\n\\t\\t\\tsize[UltimateParent_v] += size[UltimateParent_u];\\n\\t\\t} else {\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\t\\tsize[UltimateParent_u] += size[UltimateParent_v];\\n\\t\\t}\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        DisjointSet ds(n*n);\\n\\n        // Connecting components -> step-1\\n        for(int row=0;row<n;row++) {\\n            for(int col=0;col<n;col++) {\\n                if(grid[row][col] == 0)\\n                    continue;\\n                int delrow[] = {-1, 0, 1, 0};\\n                int delcol[] = {0, -1, 0, 1};\\n\\n                for(int i=0;i<4;i++) {\\n                    int nrow = row + delrow[i];\\n                    int ncol = col + delcol[i];\\n                    if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < n) {\\n                        if(grid[nrow][ncol] == 1) {\\n                            int nodeNumber = row * n + col;\\n                            int adjNodeNumber = nrow * n + ncol;\\n                            ds.unionBySize(nodeNumber, adjNodeNumber);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Try Changing 0 to 1 -> step-2\\n        int maxi = 0;\\n        for(int row=0;row<n;row++) {\\n            for(int col=0;col<n;col++) {\\n                if(grid[row][col] == 1)\\n                    continue;\\n                int delrow[] = {-1, 0, 1, 0};\\n                int delcol[] = {0, -1, 0, 1};\\n\\n                set<int> components;\\n                for(int i=0;i<4;i++) {\\n                    int nrow = row + delrow[i];\\n                    int ncol = col + delcol[i];\\n\\n                    if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < n) {\\n                        if(grid[nrow][ncol] == 1) {\\n                            components.insert(ds.findUltimateParent(nrow * n + ncol));       \\n                        }\\n                    }\\n                }\\n                int totalSize = 0;\\n                for(auto it: components) {\\n                    totalSize += ds.size[it];\\n                }\\n                maxi = max(maxi, totalSize + 1);\\n            }\\n        }\\n\\n        for(int cellNumber = 0; cellNumber < n * n; cellNumber++) {\\n            maxi = max(maxi, ds.size[ds.findUltimateParent(cellNumber)]);\\n        }\\n        return maxi;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avminus",
                        "content": "solution kyu daal raha hai discuss mein bro"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Nice solution !! I have done the same just with dfs !"
                    }
                ]
            },
            {
                "id": 1708166,
                "content": [
                    {
                        "username": "harshit4me",
                        "content": "Peoples are mad. below it has written, don\\'t post any solutions but they are stilling pasting. We have another option also to post the solutions."
                    },
                    {
                        "username": "michaeljosephhearn",
                        "content": "This was fun, do easier island problems then work up to this one. <3"
                    },
                    {
                        "username": "allenlsy",
                        "content": "I think the official implementation behind python3 is wrong. For this case:\\n\\n[[1,0,1,0],[0,0,0,1],[1,0,1,0]]\\n\\nThe largest island should be 4. But when I run the code with custom test cases, the expected result is 3, which is wrong.\\n"
                    },
                    {
                        "username": "rahulraikwar00",
                        "content": "Grid should be n*n! according to question!"
                    },
                    {
                        "username": "wenjunwang2014",
                        "content": "For a case such like \\n[[1,1,0,1],[1,0,0,1]]\\nThe answer should be 6, however the test code gives 4."
                    },
                    {
                        "username": "Vibhoar_Bajaj",
                        "content": "the question states n*n"
                    },
                    {
                        "username": "SeineAle",
                        "content": "I am ashamed of 1754 ms rt and 480 mb mem in  C ++but I am proud that I did it smh."
                    },
                    {
                        "username": "ssredotime",
                        "content": "I love problems like this. So much more satisfying than some medium or easy labelled array problem \"find the kth smallest permutation of the maximum noncontiguous subarray after optionally removing up to j elements at indices where (i, nums[i]) are co-prime\"."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Logic is not difficult. But the implementation part is a bit long.\\nUsed Python BFS + Hashmap for solving. "
                    },
                    {
                        "username": "CodeCrusader1",
                        "content": "class DSU {\\n    int[] parent;\\n    int[] size;\\n    int max;\\n\\n    public DSU(int n) {\\n        parent = new int[n];\\n        size = new int[n];\\n        max = 0;\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = -1;\\n            size[i] = 1;\\n        }\\n    }\\n\\n\\n    public int biggest() {\\n        return max;\\n    }\\n\\n    public int find(int x) {\\n        if (parent[x] != x)\\n            parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n\\n    public void addIsland(int x) {\\n        if (parent[x] >= 0)\\n            return;\\n        parent[x] = x;\\n        max=Math.max(max,1);\\n    }\\n\\n    public void union(int x, int y) {\\n        int px = find(x), py = find(y);\\n\\n        if (px != py) {\\n            if (size[px] >= size[py]) {\\n                size[px] += size[py];\\n                parent[py] = px;\\n                max = Math.max(max, size[px]);\\n            } else {\\n                size[py] += size[px];\\n                parent[px] = py;\\n                max = Math.max(max, size[py]);\\n            }\\n        }\\n    }\\n      public int getS(int x) {\\n          int px= find(x);\\n        return size[px];\\n    }\\n\\n    public boolean check(int x){\\n        if (parent[x] >= 0) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    public int largestIsland(int[][] grid) {\\n        int n = grid.length;\\n        DSU set = new DSU(n * n);\\n        int drow[] = {-1, 1, 0, 0};\\n        int dcol[] = {0, 0, -1, 1};\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    set.addIsland(i*n+j);\\n                    for (int k = 0; k < 4; k++) {\\n                        int dr = i + drow[k];\\n                        int dc = j + dcol[k];\\n                        int child = n * dr + dc;\\n                        if (dr >= 0 && dr < n && dc >= 0 && dc < n)\\n                           if(set.check(dr*n+dc))\\n                            set.union(i * n + j, child);\\n                    }\\n                }\\n            }\\n        } \\n         int res=set.biggest();\\n         for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                 \\n                if (grid[i][j] == 0) {                    \\n                    int temp=1;\\n                    Set<Integer> hs= new HashSet<>();\\n                    for (int k = 0; k < 4; k++) {\\n                        int dr = i + drow[k];\\n                        int dc = j + dcol[k];\\n                        int child = n * dr + dc;\\n                        if (dr >= 0 && dr < n && dc >= 0 && dc < n)\\n                           if(set.check(dr*n+dc)){\\n                              if( hs.add(set.find(child))){\\n                                    temp+=set.getS(child);\\n                              }\\n\\n                           }                             \\n                    }\\n                res= Math.max(res,temp);\\n                }\\n\\n            }\\n        }\\n\\n       return res;\\n    }\\n}\\n"
                    },
                    {
                        "username": "tr1ten",
                        "content": "WTH with this python runtime? \\nInitially i submitted the code (N^2) it threw TLE, again i submitted the same code now it beats 70% python solution in runtime. "
                    },
                    {
                        "username": "AnantDuhan",
                        "content": "```\\nclass DisjointSet {\\npublic:\\n    vector<int> rank, parent, size;\\n\\tDisjointSet(int n) {\\n\\t\\trank.resize(n + 1, 0);\\n\\t\\tsize.resize(n + 1);\\n\\t\\tparent.resize(n + 1);\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tparent[i] = i;\\n\\t\\t\\tsize[i] = 1;\\n\\t\\t}\\n\\t}\\n\\n\\t// finding ultimate parent\\n\\tint findUltimateParent(int node) {\\n\\t\\tif (node == parent[node])\\n\\t\\t\\treturn node;\\n\\t\\treturn parent[node] = findUltimateParent(parent[node]);\\n\\t}\\n\\n\\tvoid unionByRank(int u, int v) {\\n\\t\\tint UltimateParent_u = findUltimateParent(u);\\n\\t\\tint UltimateParent_v = findUltimateParent(v);\\n\\n\\t\\tif (UltimateParent_u == UltimateParent_v)\\n\\t\\t\\treturn;\\n\\n\\t\\tif (rank[UltimateParent_u] < rank[UltimateParent_v])\\n\\t\\t\\tparent[UltimateParent_u] = UltimateParent_v;\\n\\t\\telse if (rank[UltimateParent_v] < rank[UltimateParent_u])\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\telse {\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\t\\trank[UltimateParent_u]++;\\n\\t\\t}\\n\\t}\\n\\n\\tvoid unionBySize(int u, int v) {\\n\\t\\tint UltimateParent_u = findUltimateParent(u);\\n\\t\\tint UltimateParent_v = findUltimateParent(v);\\n\\n\\t\\tif (UltimateParent_u == UltimateParent_v)\\n\\t\\t\\treturn;\\n\\n\\t\\tif (rank[UltimateParent_u] < rank[UltimateParent_v]) {\\n\\t\\t\\tparent[UltimateParent_u] = UltimateParent_v;\\n\\t\\t\\tsize[UltimateParent_v] += size[UltimateParent_u];\\n\\t\\t} else {\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\t\\tsize[UltimateParent_u] += size[UltimateParent_v];\\n\\t\\t}\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        DisjointSet ds(n*n);\\n\\n        // Connecting components -> step-1\\n        for(int row=0;row<n;row++) {\\n            for(int col=0;col<n;col++) {\\n                if(grid[row][col] == 0)\\n                    continue;\\n                int delrow[] = {-1, 0, 1, 0};\\n                int delcol[] = {0, -1, 0, 1};\\n\\n                for(int i=0;i<4;i++) {\\n                    int nrow = row + delrow[i];\\n                    int ncol = col + delcol[i];\\n                    if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < n) {\\n                        if(grid[nrow][ncol] == 1) {\\n                            int nodeNumber = row * n + col;\\n                            int adjNodeNumber = nrow * n + ncol;\\n                            ds.unionBySize(nodeNumber, adjNodeNumber);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Try Changing 0 to 1 -> step-2\\n        int maxi = 0;\\n        for(int row=0;row<n;row++) {\\n            for(int col=0;col<n;col++) {\\n                if(grid[row][col] == 1)\\n                    continue;\\n                int delrow[] = {-1, 0, 1, 0};\\n                int delcol[] = {0, -1, 0, 1};\\n\\n                set<int> components;\\n                for(int i=0;i<4;i++) {\\n                    int nrow = row + delrow[i];\\n                    int ncol = col + delcol[i];\\n\\n                    if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < n) {\\n                        if(grid[nrow][ncol] == 1) {\\n                            components.insert(ds.findUltimateParent(nrow * n + ncol));       \\n                        }\\n                    }\\n                }\\n                int totalSize = 0;\\n                for(auto it: components) {\\n                    totalSize += ds.size[it];\\n                }\\n                maxi = max(maxi, totalSize + 1);\\n            }\\n        }\\n\\n        for(int cellNumber = 0; cellNumber < n * n; cellNumber++) {\\n            maxi = max(maxi, ds.size[ds.findUltimateParent(cellNumber)]);\\n        }\\n        return maxi;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avminus",
                        "content": "solution kyu daal raha hai discuss mein bro"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Nice solution !! I have done the same just with dfs !"
                    }
                ]
            },
            {
                "id": 1683721,
                "content": [
                    {
                        "username": "harshit4me",
                        "content": "Peoples are mad. below it has written, don\\'t post any solutions but they are stilling pasting. We have another option also to post the solutions."
                    },
                    {
                        "username": "michaeljosephhearn",
                        "content": "This was fun, do easier island problems then work up to this one. <3"
                    },
                    {
                        "username": "allenlsy",
                        "content": "I think the official implementation behind python3 is wrong. For this case:\\n\\n[[1,0,1,0],[0,0,0,1],[1,0,1,0]]\\n\\nThe largest island should be 4. But when I run the code with custom test cases, the expected result is 3, which is wrong.\\n"
                    },
                    {
                        "username": "rahulraikwar00",
                        "content": "Grid should be n*n! according to question!"
                    },
                    {
                        "username": "wenjunwang2014",
                        "content": "For a case such like \\n[[1,1,0,1],[1,0,0,1]]\\nThe answer should be 6, however the test code gives 4."
                    },
                    {
                        "username": "Vibhoar_Bajaj",
                        "content": "the question states n*n"
                    },
                    {
                        "username": "SeineAle",
                        "content": "I am ashamed of 1754 ms rt and 480 mb mem in  C ++but I am proud that I did it smh."
                    },
                    {
                        "username": "ssredotime",
                        "content": "I love problems like this. So much more satisfying than some medium or easy labelled array problem \"find the kth smallest permutation of the maximum noncontiguous subarray after optionally removing up to j elements at indices where (i, nums[i]) are co-prime\"."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Logic is not difficult. But the implementation part is a bit long.\\nUsed Python BFS + Hashmap for solving. "
                    },
                    {
                        "username": "CodeCrusader1",
                        "content": "class DSU {\\n    int[] parent;\\n    int[] size;\\n    int max;\\n\\n    public DSU(int n) {\\n        parent = new int[n];\\n        size = new int[n];\\n        max = 0;\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = -1;\\n            size[i] = 1;\\n        }\\n    }\\n\\n\\n    public int biggest() {\\n        return max;\\n    }\\n\\n    public int find(int x) {\\n        if (parent[x] != x)\\n            parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n\\n    public void addIsland(int x) {\\n        if (parent[x] >= 0)\\n            return;\\n        parent[x] = x;\\n        max=Math.max(max,1);\\n    }\\n\\n    public void union(int x, int y) {\\n        int px = find(x), py = find(y);\\n\\n        if (px != py) {\\n            if (size[px] >= size[py]) {\\n                size[px] += size[py];\\n                parent[py] = px;\\n                max = Math.max(max, size[px]);\\n            } else {\\n                size[py] += size[px];\\n                parent[px] = py;\\n                max = Math.max(max, size[py]);\\n            }\\n        }\\n    }\\n      public int getS(int x) {\\n          int px= find(x);\\n        return size[px];\\n    }\\n\\n    public boolean check(int x){\\n        if (parent[x] >= 0) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    public int largestIsland(int[][] grid) {\\n        int n = grid.length;\\n        DSU set = new DSU(n * n);\\n        int drow[] = {-1, 1, 0, 0};\\n        int dcol[] = {0, 0, -1, 1};\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    set.addIsland(i*n+j);\\n                    for (int k = 0; k < 4; k++) {\\n                        int dr = i + drow[k];\\n                        int dc = j + dcol[k];\\n                        int child = n * dr + dc;\\n                        if (dr >= 0 && dr < n && dc >= 0 && dc < n)\\n                           if(set.check(dr*n+dc))\\n                            set.union(i * n + j, child);\\n                    }\\n                }\\n            }\\n        } \\n         int res=set.biggest();\\n         for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                 \\n                if (grid[i][j] == 0) {                    \\n                    int temp=1;\\n                    Set<Integer> hs= new HashSet<>();\\n                    for (int k = 0; k < 4; k++) {\\n                        int dr = i + drow[k];\\n                        int dc = j + dcol[k];\\n                        int child = n * dr + dc;\\n                        if (dr >= 0 && dr < n && dc >= 0 && dc < n)\\n                           if(set.check(dr*n+dc)){\\n                              if( hs.add(set.find(child))){\\n                                    temp+=set.getS(child);\\n                              }\\n\\n                           }                             \\n                    }\\n                res= Math.max(res,temp);\\n                }\\n\\n            }\\n        }\\n\\n       return res;\\n    }\\n}\\n"
                    },
                    {
                        "username": "tr1ten",
                        "content": "WTH with this python runtime? \\nInitially i submitted the code (N^2) it threw TLE, again i submitted the same code now it beats 70% python solution in runtime. "
                    },
                    {
                        "username": "AnantDuhan",
                        "content": "```\\nclass DisjointSet {\\npublic:\\n    vector<int> rank, parent, size;\\n\\tDisjointSet(int n) {\\n\\t\\trank.resize(n + 1, 0);\\n\\t\\tsize.resize(n + 1);\\n\\t\\tparent.resize(n + 1);\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tparent[i] = i;\\n\\t\\t\\tsize[i] = 1;\\n\\t\\t}\\n\\t}\\n\\n\\t// finding ultimate parent\\n\\tint findUltimateParent(int node) {\\n\\t\\tif (node == parent[node])\\n\\t\\t\\treturn node;\\n\\t\\treturn parent[node] = findUltimateParent(parent[node]);\\n\\t}\\n\\n\\tvoid unionByRank(int u, int v) {\\n\\t\\tint UltimateParent_u = findUltimateParent(u);\\n\\t\\tint UltimateParent_v = findUltimateParent(v);\\n\\n\\t\\tif (UltimateParent_u == UltimateParent_v)\\n\\t\\t\\treturn;\\n\\n\\t\\tif (rank[UltimateParent_u] < rank[UltimateParent_v])\\n\\t\\t\\tparent[UltimateParent_u] = UltimateParent_v;\\n\\t\\telse if (rank[UltimateParent_v] < rank[UltimateParent_u])\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\telse {\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\t\\trank[UltimateParent_u]++;\\n\\t\\t}\\n\\t}\\n\\n\\tvoid unionBySize(int u, int v) {\\n\\t\\tint UltimateParent_u = findUltimateParent(u);\\n\\t\\tint UltimateParent_v = findUltimateParent(v);\\n\\n\\t\\tif (UltimateParent_u == UltimateParent_v)\\n\\t\\t\\treturn;\\n\\n\\t\\tif (rank[UltimateParent_u] < rank[UltimateParent_v]) {\\n\\t\\t\\tparent[UltimateParent_u] = UltimateParent_v;\\n\\t\\t\\tsize[UltimateParent_v] += size[UltimateParent_u];\\n\\t\\t} else {\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\t\\tsize[UltimateParent_u] += size[UltimateParent_v];\\n\\t\\t}\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        DisjointSet ds(n*n);\\n\\n        // Connecting components -> step-1\\n        for(int row=0;row<n;row++) {\\n            for(int col=0;col<n;col++) {\\n                if(grid[row][col] == 0)\\n                    continue;\\n                int delrow[] = {-1, 0, 1, 0};\\n                int delcol[] = {0, -1, 0, 1};\\n\\n                for(int i=0;i<4;i++) {\\n                    int nrow = row + delrow[i];\\n                    int ncol = col + delcol[i];\\n                    if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < n) {\\n                        if(grid[nrow][ncol] == 1) {\\n                            int nodeNumber = row * n + col;\\n                            int adjNodeNumber = nrow * n + ncol;\\n                            ds.unionBySize(nodeNumber, adjNodeNumber);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Try Changing 0 to 1 -> step-2\\n        int maxi = 0;\\n        for(int row=0;row<n;row++) {\\n            for(int col=0;col<n;col++) {\\n                if(grid[row][col] == 1)\\n                    continue;\\n                int delrow[] = {-1, 0, 1, 0};\\n                int delcol[] = {0, -1, 0, 1};\\n\\n                set<int> components;\\n                for(int i=0;i<4;i++) {\\n                    int nrow = row + delrow[i];\\n                    int ncol = col + delcol[i];\\n\\n                    if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < n) {\\n                        if(grid[nrow][ncol] == 1) {\\n                            components.insert(ds.findUltimateParent(nrow * n + ncol));       \\n                        }\\n                    }\\n                }\\n                int totalSize = 0;\\n                for(auto it: components) {\\n                    totalSize += ds.size[it];\\n                }\\n                maxi = max(maxi, totalSize + 1);\\n            }\\n        }\\n\\n        for(int cellNumber = 0; cellNumber < n * n; cellNumber++) {\\n            maxi = max(maxi, ds.size[ds.findUltimateParent(cellNumber)]);\\n        }\\n        return maxi;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avminus",
                        "content": "solution kyu daal raha hai discuss mein bro"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Nice solution !! I have done the same just with dfs !"
                    }
                ]
            },
            {
                "id": 1751488,
                "content": [
                    {
                        "username": "harshit4me",
                        "content": "Peoples are mad. below it has written, don\\'t post any solutions but they are stilling pasting. We have another option also to post the solutions."
                    },
                    {
                        "username": "michaeljosephhearn",
                        "content": "This was fun, do easier island problems then work up to this one. <3"
                    },
                    {
                        "username": "allenlsy",
                        "content": "I think the official implementation behind python3 is wrong. For this case:\\n\\n[[1,0,1,0],[0,0,0,1],[1,0,1,0]]\\n\\nThe largest island should be 4. But when I run the code with custom test cases, the expected result is 3, which is wrong.\\n"
                    },
                    {
                        "username": "rahulraikwar00",
                        "content": "Grid should be n*n! according to question!"
                    },
                    {
                        "username": "wenjunwang2014",
                        "content": "For a case such like \\n[[1,1,0,1],[1,0,0,1]]\\nThe answer should be 6, however the test code gives 4."
                    },
                    {
                        "username": "Vibhoar_Bajaj",
                        "content": "the question states n*n"
                    },
                    {
                        "username": "SeineAle",
                        "content": "I am ashamed of 1754 ms rt and 480 mb mem in  C ++but I am proud that I did it smh."
                    },
                    {
                        "username": "ssredotime",
                        "content": "I love problems like this. So much more satisfying than some medium or easy labelled array problem \"find the kth smallest permutation of the maximum noncontiguous subarray after optionally removing up to j elements at indices where (i, nums[i]) are co-prime\"."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Logic is not difficult. But the implementation part is a bit long.\\nUsed Python BFS + Hashmap for solving. "
                    },
                    {
                        "username": "CodeCrusader1",
                        "content": "class DSU {\\n    int[] parent;\\n    int[] size;\\n    int max;\\n\\n    public DSU(int n) {\\n        parent = new int[n];\\n        size = new int[n];\\n        max = 0;\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = -1;\\n            size[i] = 1;\\n        }\\n    }\\n\\n\\n    public int biggest() {\\n        return max;\\n    }\\n\\n    public int find(int x) {\\n        if (parent[x] != x)\\n            parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n\\n    public void addIsland(int x) {\\n        if (parent[x] >= 0)\\n            return;\\n        parent[x] = x;\\n        max=Math.max(max,1);\\n    }\\n\\n    public void union(int x, int y) {\\n        int px = find(x), py = find(y);\\n\\n        if (px != py) {\\n            if (size[px] >= size[py]) {\\n                size[px] += size[py];\\n                parent[py] = px;\\n                max = Math.max(max, size[px]);\\n            } else {\\n                size[py] += size[px];\\n                parent[px] = py;\\n                max = Math.max(max, size[py]);\\n            }\\n        }\\n    }\\n      public int getS(int x) {\\n          int px= find(x);\\n        return size[px];\\n    }\\n\\n    public boolean check(int x){\\n        if (parent[x] >= 0) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    public int largestIsland(int[][] grid) {\\n        int n = grid.length;\\n        DSU set = new DSU(n * n);\\n        int drow[] = {-1, 1, 0, 0};\\n        int dcol[] = {0, 0, -1, 1};\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    set.addIsland(i*n+j);\\n                    for (int k = 0; k < 4; k++) {\\n                        int dr = i + drow[k];\\n                        int dc = j + dcol[k];\\n                        int child = n * dr + dc;\\n                        if (dr >= 0 && dr < n && dc >= 0 && dc < n)\\n                           if(set.check(dr*n+dc))\\n                            set.union(i * n + j, child);\\n                    }\\n                }\\n            }\\n        } \\n         int res=set.biggest();\\n         for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                 \\n                if (grid[i][j] == 0) {                    \\n                    int temp=1;\\n                    Set<Integer> hs= new HashSet<>();\\n                    for (int k = 0; k < 4; k++) {\\n                        int dr = i + drow[k];\\n                        int dc = j + dcol[k];\\n                        int child = n * dr + dc;\\n                        if (dr >= 0 && dr < n && dc >= 0 && dc < n)\\n                           if(set.check(dr*n+dc)){\\n                              if( hs.add(set.find(child))){\\n                                    temp+=set.getS(child);\\n                              }\\n\\n                           }                             \\n                    }\\n                res= Math.max(res,temp);\\n                }\\n\\n            }\\n        }\\n\\n       return res;\\n    }\\n}\\n"
                    },
                    {
                        "username": "tr1ten",
                        "content": "WTH with this python runtime? \\nInitially i submitted the code (N^2) it threw TLE, again i submitted the same code now it beats 70% python solution in runtime. "
                    },
                    {
                        "username": "AnantDuhan",
                        "content": "```\\nclass DisjointSet {\\npublic:\\n    vector<int> rank, parent, size;\\n\\tDisjointSet(int n) {\\n\\t\\trank.resize(n + 1, 0);\\n\\t\\tsize.resize(n + 1);\\n\\t\\tparent.resize(n + 1);\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tparent[i] = i;\\n\\t\\t\\tsize[i] = 1;\\n\\t\\t}\\n\\t}\\n\\n\\t// finding ultimate parent\\n\\tint findUltimateParent(int node) {\\n\\t\\tif (node == parent[node])\\n\\t\\t\\treturn node;\\n\\t\\treturn parent[node] = findUltimateParent(parent[node]);\\n\\t}\\n\\n\\tvoid unionByRank(int u, int v) {\\n\\t\\tint UltimateParent_u = findUltimateParent(u);\\n\\t\\tint UltimateParent_v = findUltimateParent(v);\\n\\n\\t\\tif (UltimateParent_u == UltimateParent_v)\\n\\t\\t\\treturn;\\n\\n\\t\\tif (rank[UltimateParent_u] < rank[UltimateParent_v])\\n\\t\\t\\tparent[UltimateParent_u] = UltimateParent_v;\\n\\t\\telse if (rank[UltimateParent_v] < rank[UltimateParent_u])\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\telse {\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\t\\trank[UltimateParent_u]++;\\n\\t\\t}\\n\\t}\\n\\n\\tvoid unionBySize(int u, int v) {\\n\\t\\tint UltimateParent_u = findUltimateParent(u);\\n\\t\\tint UltimateParent_v = findUltimateParent(v);\\n\\n\\t\\tif (UltimateParent_u == UltimateParent_v)\\n\\t\\t\\treturn;\\n\\n\\t\\tif (rank[UltimateParent_u] < rank[UltimateParent_v]) {\\n\\t\\t\\tparent[UltimateParent_u] = UltimateParent_v;\\n\\t\\t\\tsize[UltimateParent_v] += size[UltimateParent_u];\\n\\t\\t} else {\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\t\\tsize[UltimateParent_u] += size[UltimateParent_v];\\n\\t\\t}\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        DisjointSet ds(n*n);\\n\\n        // Connecting components -> step-1\\n        for(int row=0;row<n;row++) {\\n            for(int col=0;col<n;col++) {\\n                if(grid[row][col] == 0)\\n                    continue;\\n                int delrow[] = {-1, 0, 1, 0};\\n                int delcol[] = {0, -1, 0, 1};\\n\\n                for(int i=0;i<4;i++) {\\n                    int nrow = row + delrow[i];\\n                    int ncol = col + delcol[i];\\n                    if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < n) {\\n                        if(grid[nrow][ncol] == 1) {\\n                            int nodeNumber = row * n + col;\\n                            int adjNodeNumber = nrow * n + ncol;\\n                            ds.unionBySize(nodeNumber, adjNodeNumber);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Try Changing 0 to 1 -> step-2\\n        int maxi = 0;\\n        for(int row=0;row<n;row++) {\\n            for(int col=0;col<n;col++) {\\n                if(grid[row][col] == 1)\\n                    continue;\\n                int delrow[] = {-1, 0, 1, 0};\\n                int delcol[] = {0, -1, 0, 1};\\n\\n                set<int> components;\\n                for(int i=0;i<4;i++) {\\n                    int nrow = row + delrow[i];\\n                    int ncol = col + delcol[i];\\n\\n                    if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < n) {\\n                        if(grid[nrow][ncol] == 1) {\\n                            components.insert(ds.findUltimateParent(nrow * n + ncol));       \\n                        }\\n                    }\\n                }\\n                int totalSize = 0;\\n                for(auto it: components) {\\n                    totalSize += ds.size[it];\\n                }\\n                maxi = max(maxi, totalSize + 1);\\n            }\\n        }\\n\\n        for(int cellNumber = 0; cellNumber < n * n; cellNumber++) {\\n            maxi = max(maxi, ds.size[ds.findUltimateParent(cellNumber)]);\\n        }\\n        return maxi;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avminus",
                        "content": "solution kyu daal raha hai discuss mein bro"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Nice solution !! I have done the same just with dfs !"
                    }
                ]
            },
            {
                "id": 1889738,
                "content": [
                    {
                        "username": "harshit4me",
                        "content": "Peoples are mad. below it has written, don\\'t post any solutions but they are stilling pasting. We have another option also to post the solutions."
                    },
                    {
                        "username": "michaeljosephhearn",
                        "content": "This was fun, do easier island problems then work up to this one. <3"
                    },
                    {
                        "username": "allenlsy",
                        "content": "I think the official implementation behind python3 is wrong. For this case:\\n\\n[[1,0,1,0],[0,0,0,1],[1,0,1,0]]\\n\\nThe largest island should be 4. But when I run the code with custom test cases, the expected result is 3, which is wrong.\\n"
                    },
                    {
                        "username": "rahulraikwar00",
                        "content": "Grid should be n*n! according to question!"
                    },
                    {
                        "username": "wenjunwang2014",
                        "content": "For a case such like \\n[[1,1,0,1],[1,0,0,1]]\\nThe answer should be 6, however the test code gives 4."
                    },
                    {
                        "username": "Vibhoar_Bajaj",
                        "content": "the question states n*n"
                    },
                    {
                        "username": "SeineAle",
                        "content": "I am ashamed of 1754 ms rt and 480 mb mem in  C ++but I am proud that I did it smh."
                    },
                    {
                        "username": "ssredotime",
                        "content": "I love problems like this. So much more satisfying than some medium or easy labelled array problem \"find the kth smallest permutation of the maximum noncontiguous subarray after optionally removing up to j elements at indices where (i, nums[i]) are co-prime\"."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Logic is not difficult. But the implementation part is a bit long.\\nUsed Python BFS + Hashmap for solving. "
                    },
                    {
                        "username": "CodeCrusader1",
                        "content": "class DSU {\\n    int[] parent;\\n    int[] size;\\n    int max;\\n\\n    public DSU(int n) {\\n        parent = new int[n];\\n        size = new int[n];\\n        max = 0;\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = -1;\\n            size[i] = 1;\\n        }\\n    }\\n\\n\\n    public int biggest() {\\n        return max;\\n    }\\n\\n    public int find(int x) {\\n        if (parent[x] != x)\\n            parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n\\n    public void addIsland(int x) {\\n        if (parent[x] >= 0)\\n            return;\\n        parent[x] = x;\\n        max=Math.max(max,1);\\n    }\\n\\n    public void union(int x, int y) {\\n        int px = find(x), py = find(y);\\n\\n        if (px != py) {\\n            if (size[px] >= size[py]) {\\n                size[px] += size[py];\\n                parent[py] = px;\\n                max = Math.max(max, size[px]);\\n            } else {\\n                size[py] += size[px];\\n                parent[px] = py;\\n                max = Math.max(max, size[py]);\\n            }\\n        }\\n    }\\n      public int getS(int x) {\\n          int px= find(x);\\n        return size[px];\\n    }\\n\\n    public boolean check(int x){\\n        if (parent[x] >= 0) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    public int largestIsland(int[][] grid) {\\n        int n = grid.length;\\n        DSU set = new DSU(n * n);\\n        int drow[] = {-1, 1, 0, 0};\\n        int dcol[] = {0, 0, -1, 1};\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    set.addIsland(i*n+j);\\n                    for (int k = 0; k < 4; k++) {\\n                        int dr = i + drow[k];\\n                        int dc = j + dcol[k];\\n                        int child = n * dr + dc;\\n                        if (dr >= 0 && dr < n && dc >= 0 && dc < n)\\n                           if(set.check(dr*n+dc))\\n                            set.union(i * n + j, child);\\n                    }\\n                }\\n            }\\n        } \\n         int res=set.biggest();\\n         for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                 \\n                if (grid[i][j] == 0) {                    \\n                    int temp=1;\\n                    Set<Integer> hs= new HashSet<>();\\n                    for (int k = 0; k < 4; k++) {\\n                        int dr = i + drow[k];\\n                        int dc = j + dcol[k];\\n                        int child = n * dr + dc;\\n                        if (dr >= 0 && dr < n && dc >= 0 && dc < n)\\n                           if(set.check(dr*n+dc)){\\n                              if( hs.add(set.find(child))){\\n                                    temp+=set.getS(child);\\n                              }\\n\\n                           }                             \\n                    }\\n                res= Math.max(res,temp);\\n                }\\n\\n            }\\n        }\\n\\n       return res;\\n    }\\n}\\n"
                    },
                    {
                        "username": "tr1ten",
                        "content": "WTH with this python runtime? \\nInitially i submitted the code (N^2) it threw TLE, again i submitted the same code now it beats 70% python solution in runtime. "
                    },
                    {
                        "username": "AnantDuhan",
                        "content": "```\\nclass DisjointSet {\\npublic:\\n    vector<int> rank, parent, size;\\n\\tDisjointSet(int n) {\\n\\t\\trank.resize(n + 1, 0);\\n\\t\\tsize.resize(n + 1);\\n\\t\\tparent.resize(n + 1);\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tparent[i] = i;\\n\\t\\t\\tsize[i] = 1;\\n\\t\\t}\\n\\t}\\n\\n\\t// finding ultimate parent\\n\\tint findUltimateParent(int node) {\\n\\t\\tif (node == parent[node])\\n\\t\\t\\treturn node;\\n\\t\\treturn parent[node] = findUltimateParent(parent[node]);\\n\\t}\\n\\n\\tvoid unionByRank(int u, int v) {\\n\\t\\tint UltimateParent_u = findUltimateParent(u);\\n\\t\\tint UltimateParent_v = findUltimateParent(v);\\n\\n\\t\\tif (UltimateParent_u == UltimateParent_v)\\n\\t\\t\\treturn;\\n\\n\\t\\tif (rank[UltimateParent_u] < rank[UltimateParent_v])\\n\\t\\t\\tparent[UltimateParent_u] = UltimateParent_v;\\n\\t\\telse if (rank[UltimateParent_v] < rank[UltimateParent_u])\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\telse {\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\t\\trank[UltimateParent_u]++;\\n\\t\\t}\\n\\t}\\n\\n\\tvoid unionBySize(int u, int v) {\\n\\t\\tint UltimateParent_u = findUltimateParent(u);\\n\\t\\tint UltimateParent_v = findUltimateParent(v);\\n\\n\\t\\tif (UltimateParent_u == UltimateParent_v)\\n\\t\\t\\treturn;\\n\\n\\t\\tif (rank[UltimateParent_u] < rank[UltimateParent_v]) {\\n\\t\\t\\tparent[UltimateParent_u] = UltimateParent_v;\\n\\t\\t\\tsize[UltimateParent_v] += size[UltimateParent_u];\\n\\t\\t} else {\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\t\\tsize[UltimateParent_u] += size[UltimateParent_v];\\n\\t\\t}\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        DisjointSet ds(n*n);\\n\\n        // Connecting components -> step-1\\n        for(int row=0;row<n;row++) {\\n            for(int col=0;col<n;col++) {\\n                if(grid[row][col] == 0)\\n                    continue;\\n                int delrow[] = {-1, 0, 1, 0};\\n                int delcol[] = {0, -1, 0, 1};\\n\\n                for(int i=0;i<4;i++) {\\n                    int nrow = row + delrow[i];\\n                    int ncol = col + delcol[i];\\n                    if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < n) {\\n                        if(grid[nrow][ncol] == 1) {\\n                            int nodeNumber = row * n + col;\\n                            int adjNodeNumber = nrow * n + ncol;\\n                            ds.unionBySize(nodeNumber, adjNodeNumber);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Try Changing 0 to 1 -> step-2\\n        int maxi = 0;\\n        for(int row=0;row<n;row++) {\\n            for(int col=0;col<n;col++) {\\n                if(grid[row][col] == 1)\\n                    continue;\\n                int delrow[] = {-1, 0, 1, 0};\\n                int delcol[] = {0, -1, 0, 1};\\n\\n                set<int> components;\\n                for(int i=0;i<4;i++) {\\n                    int nrow = row + delrow[i];\\n                    int ncol = col + delcol[i];\\n\\n                    if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < n) {\\n                        if(grid[nrow][ncol] == 1) {\\n                            components.insert(ds.findUltimateParent(nrow * n + ncol));       \\n                        }\\n                    }\\n                }\\n                int totalSize = 0;\\n                for(auto it: components) {\\n                    totalSize += ds.size[it];\\n                }\\n                maxi = max(maxi, totalSize + 1);\\n            }\\n        }\\n\\n        for(int cellNumber = 0; cellNumber < n * n; cellNumber++) {\\n            maxi = max(maxi, ds.size[ds.findUltimateParent(cellNumber)]);\\n        }\\n        return maxi;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avminus",
                        "content": "solution kyu daal raha hai discuss mein bro"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Nice solution !! I have done the same just with dfs !"
                    }
                ]
            },
            {
                "id": 1573778,
                "content": [
                    {
                        "username": "harshit4me",
                        "content": "Peoples are mad. below it has written, don\\'t post any solutions but they are stilling pasting. We have another option also to post the solutions."
                    },
                    {
                        "username": "michaeljosephhearn",
                        "content": "This was fun, do easier island problems then work up to this one. <3"
                    },
                    {
                        "username": "allenlsy",
                        "content": "I think the official implementation behind python3 is wrong. For this case:\\n\\n[[1,0,1,0],[0,0,0,1],[1,0,1,0]]\\n\\nThe largest island should be 4. But when I run the code with custom test cases, the expected result is 3, which is wrong.\\n"
                    },
                    {
                        "username": "rahulraikwar00",
                        "content": "Grid should be n*n! according to question!"
                    },
                    {
                        "username": "wenjunwang2014",
                        "content": "For a case such like \\n[[1,1,0,1],[1,0,0,1]]\\nThe answer should be 6, however the test code gives 4."
                    },
                    {
                        "username": "Vibhoar_Bajaj",
                        "content": "the question states n*n"
                    },
                    {
                        "username": "SeineAle",
                        "content": "I am ashamed of 1754 ms rt and 480 mb mem in  C ++but I am proud that I did it smh."
                    },
                    {
                        "username": "ssredotime",
                        "content": "I love problems like this. So much more satisfying than some medium or easy labelled array problem \"find the kth smallest permutation of the maximum noncontiguous subarray after optionally removing up to j elements at indices where (i, nums[i]) are co-prime\"."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Logic is not difficult. But the implementation part is a bit long.\\nUsed Python BFS + Hashmap for solving. "
                    },
                    {
                        "username": "CodeCrusader1",
                        "content": "class DSU {\\n    int[] parent;\\n    int[] size;\\n    int max;\\n\\n    public DSU(int n) {\\n        parent = new int[n];\\n        size = new int[n];\\n        max = 0;\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = -1;\\n            size[i] = 1;\\n        }\\n    }\\n\\n\\n    public int biggest() {\\n        return max;\\n    }\\n\\n    public int find(int x) {\\n        if (parent[x] != x)\\n            parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n\\n    public void addIsland(int x) {\\n        if (parent[x] >= 0)\\n            return;\\n        parent[x] = x;\\n        max=Math.max(max,1);\\n    }\\n\\n    public void union(int x, int y) {\\n        int px = find(x), py = find(y);\\n\\n        if (px != py) {\\n            if (size[px] >= size[py]) {\\n                size[px] += size[py];\\n                parent[py] = px;\\n                max = Math.max(max, size[px]);\\n            } else {\\n                size[py] += size[px];\\n                parent[px] = py;\\n                max = Math.max(max, size[py]);\\n            }\\n        }\\n    }\\n      public int getS(int x) {\\n          int px= find(x);\\n        return size[px];\\n    }\\n\\n    public boolean check(int x){\\n        if (parent[x] >= 0) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    public int largestIsland(int[][] grid) {\\n        int n = grid.length;\\n        DSU set = new DSU(n * n);\\n        int drow[] = {-1, 1, 0, 0};\\n        int dcol[] = {0, 0, -1, 1};\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    set.addIsland(i*n+j);\\n                    for (int k = 0; k < 4; k++) {\\n                        int dr = i + drow[k];\\n                        int dc = j + dcol[k];\\n                        int child = n * dr + dc;\\n                        if (dr >= 0 && dr < n && dc >= 0 && dc < n)\\n                           if(set.check(dr*n+dc))\\n                            set.union(i * n + j, child);\\n                    }\\n                }\\n            }\\n        } \\n         int res=set.biggest();\\n         for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                 \\n                if (grid[i][j] == 0) {                    \\n                    int temp=1;\\n                    Set<Integer> hs= new HashSet<>();\\n                    for (int k = 0; k < 4; k++) {\\n                        int dr = i + drow[k];\\n                        int dc = j + dcol[k];\\n                        int child = n * dr + dc;\\n                        if (dr >= 0 && dr < n && dc >= 0 && dc < n)\\n                           if(set.check(dr*n+dc)){\\n                              if( hs.add(set.find(child))){\\n                                    temp+=set.getS(child);\\n                              }\\n\\n                           }                             \\n                    }\\n                res= Math.max(res,temp);\\n                }\\n\\n            }\\n        }\\n\\n       return res;\\n    }\\n}\\n"
                    },
                    {
                        "username": "tr1ten",
                        "content": "WTH with this python runtime? \\nInitially i submitted the code (N^2) it threw TLE, again i submitted the same code now it beats 70% python solution in runtime. "
                    },
                    {
                        "username": "AnantDuhan",
                        "content": "```\\nclass DisjointSet {\\npublic:\\n    vector<int> rank, parent, size;\\n\\tDisjointSet(int n) {\\n\\t\\trank.resize(n + 1, 0);\\n\\t\\tsize.resize(n + 1);\\n\\t\\tparent.resize(n + 1);\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tparent[i] = i;\\n\\t\\t\\tsize[i] = 1;\\n\\t\\t}\\n\\t}\\n\\n\\t// finding ultimate parent\\n\\tint findUltimateParent(int node) {\\n\\t\\tif (node == parent[node])\\n\\t\\t\\treturn node;\\n\\t\\treturn parent[node] = findUltimateParent(parent[node]);\\n\\t}\\n\\n\\tvoid unionByRank(int u, int v) {\\n\\t\\tint UltimateParent_u = findUltimateParent(u);\\n\\t\\tint UltimateParent_v = findUltimateParent(v);\\n\\n\\t\\tif (UltimateParent_u == UltimateParent_v)\\n\\t\\t\\treturn;\\n\\n\\t\\tif (rank[UltimateParent_u] < rank[UltimateParent_v])\\n\\t\\t\\tparent[UltimateParent_u] = UltimateParent_v;\\n\\t\\telse if (rank[UltimateParent_v] < rank[UltimateParent_u])\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\telse {\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\t\\trank[UltimateParent_u]++;\\n\\t\\t}\\n\\t}\\n\\n\\tvoid unionBySize(int u, int v) {\\n\\t\\tint UltimateParent_u = findUltimateParent(u);\\n\\t\\tint UltimateParent_v = findUltimateParent(v);\\n\\n\\t\\tif (UltimateParent_u == UltimateParent_v)\\n\\t\\t\\treturn;\\n\\n\\t\\tif (rank[UltimateParent_u] < rank[UltimateParent_v]) {\\n\\t\\t\\tparent[UltimateParent_u] = UltimateParent_v;\\n\\t\\t\\tsize[UltimateParent_v] += size[UltimateParent_u];\\n\\t\\t} else {\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\t\\tsize[UltimateParent_u] += size[UltimateParent_v];\\n\\t\\t}\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        DisjointSet ds(n*n);\\n\\n        // Connecting components -> step-1\\n        for(int row=0;row<n;row++) {\\n            for(int col=0;col<n;col++) {\\n                if(grid[row][col] == 0)\\n                    continue;\\n                int delrow[] = {-1, 0, 1, 0};\\n                int delcol[] = {0, -1, 0, 1};\\n\\n                for(int i=0;i<4;i++) {\\n                    int nrow = row + delrow[i];\\n                    int ncol = col + delcol[i];\\n                    if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < n) {\\n                        if(grid[nrow][ncol] == 1) {\\n                            int nodeNumber = row * n + col;\\n                            int adjNodeNumber = nrow * n + ncol;\\n                            ds.unionBySize(nodeNumber, adjNodeNumber);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Try Changing 0 to 1 -> step-2\\n        int maxi = 0;\\n        for(int row=0;row<n;row++) {\\n            for(int col=0;col<n;col++) {\\n                if(grid[row][col] == 1)\\n                    continue;\\n                int delrow[] = {-1, 0, 1, 0};\\n                int delcol[] = {0, -1, 0, 1};\\n\\n                set<int> components;\\n                for(int i=0;i<4;i++) {\\n                    int nrow = row + delrow[i];\\n                    int ncol = col + delcol[i];\\n\\n                    if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < n) {\\n                        if(grid[nrow][ncol] == 1) {\\n                            components.insert(ds.findUltimateParent(nrow * n + ncol));       \\n                        }\\n                    }\\n                }\\n                int totalSize = 0;\\n                for(auto it: components) {\\n                    totalSize += ds.size[it];\\n                }\\n                maxi = max(maxi, totalSize + 1);\\n            }\\n        }\\n\\n        for(int cellNumber = 0; cellNumber < n * n; cellNumber++) {\\n            maxi = max(maxi, ds.size[ds.findUltimateParent(cellNumber)]);\\n        }\\n        return maxi;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avminus",
                        "content": "solution kyu daal raha hai discuss mein bro"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Nice solution !! I have done the same just with dfs !"
                    }
                ]
            },
            {
                "id": 1571942,
                "content": [
                    {
                        "username": "harshit4me",
                        "content": "Peoples are mad. below it has written, don\\'t post any solutions but they are stilling pasting. We have another option also to post the solutions."
                    },
                    {
                        "username": "michaeljosephhearn",
                        "content": "This was fun, do easier island problems then work up to this one. <3"
                    },
                    {
                        "username": "allenlsy",
                        "content": "I think the official implementation behind python3 is wrong. For this case:\\n\\n[[1,0,1,0],[0,0,0,1],[1,0,1,0]]\\n\\nThe largest island should be 4. But when I run the code with custom test cases, the expected result is 3, which is wrong.\\n"
                    },
                    {
                        "username": "rahulraikwar00",
                        "content": "Grid should be n*n! according to question!"
                    },
                    {
                        "username": "wenjunwang2014",
                        "content": "For a case such like \\n[[1,1,0,1],[1,0,0,1]]\\nThe answer should be 6, however the test code gives 4."
                    },
                    {
                        "username": "Vibhoar_Bajaj",
                        "content": "the question states n*n"
                    },
                    {
                        "username": "SeineAle",
                        "content": "I am ashamed of 1754 ms rt and 480 mb mem in  C ++but I am proud that I did it smh."
                    },
                    {
                        "username": "ssredotime",
                        "content": "I love problems like this. So much more satisfying than some medium or easy labelled array problem \"find the kth smallest permutation of the maximum noncontiguous subarray after optionally removing up to j elements at indices where (i, nums[i]) are co-prime\"."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Logic is not difficult. But the implementation part is a bit long.\\nUsed Python BFS + Hashmap for solving. "
                    },
                    {
                        "username": "CodeCrusader1",
                        "content": "class DSU {\\n    int[] parent;\\n    int[] size;\\n    int max;\\n\\n    public DSU(int n) {\\n        parent = new int[n];\\n        size = new int[n];\\n        max = 0;\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = -1;\\n            size[i] = 1;\\n        }\\n    }\\n\\n\\n    public int biggest() {\\n        return max;\\n    }\\n\\n    public int find(int x) {\\n        if (parent[x] != x)\\n            parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n\\n    public void addIsland(int x) {\\n        if (parent[x] >= 0)\\n            return;\\n        parent[x] = x;\\n        max=Math.max(max,1);\\n    }\\n\\n    public void union(int x, int y) {\\n        int px = find(x), py = find(y);\\n\\n        if (px != py) {\\n            if (size[px] >= size[py]) {\\n                size[px] += size[py];\\n                parent[py] = px;\\n                max = Math.max(max, size[px]);\\n            } else {\\n                size[py] += size[px];\\n                parent[px] = py;\\n                max = Math.max(max, size[py]);\\n            }\\n        }\\n    }\\n      public int getS(int x) {\\n          int px= find(x);\\n        return size[px];\\n    }\\n\\n    public boolean check(int x){\\n        if (parent[x] >= 0) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    public int largestIsland(int[][] grid) {\\n        int n = grid.length;\\n        DSU set = new DSU(n * n);\\n        int drow[] = {-1, 1, 0, 0};\\n        int dcol[] = {0, 0, -1, 1};\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    set.addIsland(i*n+j);\\n                    for (int k = 0; k < 4; k++) {\\n                        int dr = i + drow[k];\\n                        int dc = j + dcol[k];\\n                        int child = n * dr + dc;\\n                        if (dr >= 0 && dr < n && dc >= 0 && dc < n)\\n                           if(set.check(dr*n+dc))\\n                            set.union(i * n + j, child);\\n                    }\\n                }\\n            }\\n        } \\n         int res=set.biggest();\\n         for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                 \\n                if (grid[i][j] == 0) {                    \\n                    int temp=1;\\n                    Set<Integer> hs= new HashSet<>();\\n                    for (int k = 0; k < 4; k++) {\\n                        int dr = i + drow[k];\\n                        int dc = j + dcol[k];\\n                        int child = n * dr + dc;\\n                        if (dr >= 0 && dr < n && dc >= 0 && dc < n)\\n                           if(set.check(dr*n+dc)){\\n                              if( hs.add(set.find(child))){\\n                                    temp+=set.getS(child);\\n                              }\\n\\n                           }                             \\n                    }\\n                res= Math.max(res,temp);\\n                }\\n\\n            }\\n        }\\n\\n       return res;\\n    }\\n}\\n"
                    },
                    {
                        "username": "tr1ten",
                        "content": "WTH with this python runtime? \\nInitially i submitted the code (N^2) it threw TLE, again i submitted the same code now it beats 70% python solution in runtime. "
                    },
                    {
                        "username": "AnantDuhan",
                        "content": "```\\nclass DisjointSet {\\npublic:\\n    vector<int> rank, parent, size;\\n\\tDisjointSet(int n) {\\n\\t\\trank.resize(n + 1, 0);\\n\\t\\tsize.resize(n + 1);\\n\\t\\tparent.resize(n + 1);\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tparent[i] = i;\\n\\t\\t\\tsize[i] = 1;\\n\\t\\t}\\n\\t}\\n\\n\\t// finding ultimate parent\\n\\tint findUltimateParent(int node) {\\n\\t\\tif (node == parent[node])\\n\\t\\t\\treturn node;\\n\\t\\treturn parent[node] = findUltimateParent(parent[node]);\\n\\t}\\n\\n\\tvoid unionByRank(int u, int v) {\\n\\t\\tint UltimateParent_u = findUltimateParent(u);\\n\\t\\tint UltimateParent_v = findUltimateParent(v);\\n\\n\\t\\tif (UltimateParent_u == UltimateParent_v)\\n\\t\\t\\treturn;\\n\\n\\t\\tif (rank[UltimateParent_u] < rank[UltimateParent_v])\\n\\t\\t\\tparent[UltimateParent_u] = UltimateParent_v;\\n\\t\\telse if (rank[UltimateParent_v] < rank[UltimateParent_u])\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\telse {\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\t\\trank[UltimateParent_u]++;\\n\\t\\t}\\n\\t}\\n\\n\\tvoid unionBySize(int u, int v) {\\n\\t\\tint UltimateParent_u = findUltimateParent(u);\\n\\t\\tint UltimateParent_v = findUltimateParent(v);\\n\\n\\t\\tif (UltimateParent_u == UltimateParent_v)\\n\\t\\t\\treturn;\\n\\n\\t\\tif (rank[UltimateParent_u] < rank[UltimateParent_v]) {\\n\\t\\t\\tparent[UltimateParent_u] = UltimateParent_v;\\n\\t\\t\\tsize[UltimateParent_v] += size[UltimateParent_u];\\n\\t\\t} else {\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\t\\tsize[UltimateParent_u] += size[UltimateParent_v];\\n\\t\\t}\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        DisjointSet ds(n*n);\\n\\n        // Connecting components -> step-1\\n        for(int row=0;row<n;row++) {\\n            for(int col=0;col<n;col++) {\\n                if(grid[row][col] == 0)\\n                    continue;\\n                int delrow[] = {-1, 0, 1, 0};\\n                int delcol[] = {0, -1, 0, 1};\\n\\n                for(int i=0;i<4;i++) {\\n                    int nrow = row + delrow[i];\\n                    int ncol = col + delcol[i];\\n                    if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < n) {\\n                        if(grid[nrow][ncol] == 1) {\\n                            int nodeNumber = row * n + col;\\n                            int adjNodeNumber = nrow * n + ncol;\\n                            ds.unionBySize(nodeNumber, adjNodeNumber);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Try Changing 0 to 1 -> step-2\\n        int maxi = 0;\\n        for(int row=0;row<n;row++) {\\n            for(int col=0;col<n;col++) {\\n                if(grid[row][col] == 1)\\n                    continue;\\n                int delrow[] = {-1, 0, 1, 0};\\n                int delcol[] = {0, -1, 0, 1};\\n\\n                set<int> components;\\n                for(int i=0;i<4;i++) {\\n                    int nrow = row + delrow[i];\\n                    int ncol = col + delcol[i];\\n\\n                    if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < n) {\\n                        if(grid[nrow][ncol] == 1) {\\n                            components.insert(ds.findUltimateParent(nrow * n + ncol));       \\n                        }\\n                    }\\n                }\\n                int totalSize = 0;\\n                for(auto it: components) {\\n                    totalSize += ds.size[it];\\n                }\\n                maxi = max(maxi, totalSize + 1);\\n            }\\n        }\\n\\n        for(int cellNumber = 0; cellNumber < n * n; cellNumber++) {\\n            maxi = max(maxi, ds.size[ds.findUltimateParent(cellNumber)]);\\n        }\\n        return maxi;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avminus",
                        "content": "solution kyu daal raha hai discuss mein bro"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Nice solution !! I have done the same just with dfs !"
                    }
                ]
            },
            {
                "id": 2059330,
                "content": [
                    {
                        "username": "harshit4me",
                        "content": "Peoples are mad. below it has written, don\\'t post any solutions but they are stilling pasting. We have another option also to post the solutions."
                    },
                    {
                        "username": "michaeljosephhearn",
                        "content": "This was fun, do easier island problems then work up to this one. <3"
                    },
                    {
                        "username": "allenlsy",
                        "content": "I think the official implementation behind python3 is wrong. For this case:\\n\\n[[1,0,1,0],[0,0,0,1],[1,0,1,0]]\\n\\nThe largest island should be 4. But when I run the code with custom test cases, the expected result is 3, which is wrong.\\n"
                    },
                    {
                        "username": "rahulraikwar00",
                        "content": "Grid should be n*n! according to question!"
                    },
                    {
                        "username": "wenjunwang2014",
                        "content": "For a case such like \\n[[1,1,0,1],[1,0,0,1]]\\nThe answer should be 6, however the test code gives 4."
                    },
                    {
                        "username": "Vibhoar_Bajaj",
                        "content": "the question states n*n"
                    },
                    {
                        "username": "SeineAle",
                        "content": "I am ashamed of 1754 ms rt and 480 mb mem in  C ++but I am proud that I did it smh."
                    },
                    {
                        "username": "ssredotime",
                        "content": "I love problems like this. So much more satisfying than some medium or easy labelled array problem \"find the kth smallest permutation of the maximum noncontiguous subarray after optionally removing up to j elements at indices where (i, nums[i]) are co-prime\"."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Logic is not difficult. But the implementation part is a bit long.\\nUsed Python BFS + Hashmap for solving. "
                    },
                    {
                        "username": "CodeCrusader1",
                        "content": "class DSU {\\n    int[] parent;\\n    int[] size;\\n    int max;\\n\\n    public DSU(int n) {\\n        parent = new int[n];\\n        size = new int[n];\\n        max = 0;\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = -1;\\n            size[i] = 1;\\n        }\\n    }\\n\\n\\n    public int biggest() {\\n        return max;\\n    }\\n\\n    public int find(int x) {\\n        if (parent[x] != x)\\n            parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n\\n    public void addIsland(int x) {\\n        if (parent[x] >= 0)\\n            return;\\n        parent[x] = x;\\n        max=Math.max(max,1);\\n    }\\n\\n    public void union(int x, int y) {\\n        int px = find(x), py = find(y);\\n\\n        if (px != py) {\\n            if (size[px] >= size[py]) {\\n                size[px] += size[py];\\n                parent[py] = px;\\n                max = Math.max(max, size[px]);\\n            } else {\\n                size[py] += size[px];\\n                parent[px] = py;\\n                max = Math.max(max, size[py]);\\n            }\\n        }\\n    }\\n      public int getS(int x) {\\n          int px= find(x);\\n        return size[px];\\n    }\\n\\n    public boolean check(int x){\\n        if (parent[x] >= 0) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    public int largestIsland(int[][] grid) {\\n        int n = grid.length;\\n        DSU set = new DSU(n * n);\\n        int drow[] = {-1, 1, 0, 0};\\n        int dcol[] = {0, 0, -1, 1};\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    set.addIsland(i*n+j);\\n                    for (int k = 0; k < 4; k++) {\\n                        int dr = i + drow[k];\\n                        int dc = j + dcol[k];\\n                        int child = n * dr + dc;\\n                        if (dr >= 0 && dr < n && dc >= 0 && dc < n)\\n                           if(set.check(dr*n+dc))\\n                            set.union(i * n + j, child);\\n                    }\\n                }\\n            }\\n        } \\n         int res=set.biggest();\\n         for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                 \\n                if (grid[i][j] == 0) {                    \\n                    int temp=1;\\n                    Set<Integer> hs= new HashSet<>();\\n                    for (int k = 0; k < 4; k++) {\\n                        int dr = i + drow[k];\\n                        int dc = j + dcol[k];\\n                        int child = n * dr + dc;\\n                        if (dr >= 0 && dr < n && dc >= 0 && dc < n)\\n                           if(set.check(dr*n+dc)){\\n                              if( hs.add(set.find(child))){\\n                                    temp+=set.getS(child);\\n                              }\\n\\n                           }                             \\n                    }\\n                res= Math.max(res,temp);\\n                }\\n\\n            }\\n        }\\n\\n       return res;\\n    }\\n}\\n"
                    },
                    {
                        "username": "tr1ten",
                        "content": "WTH with this python runtime? \\nInitially i submitted the code (N^2) it threw TLE, again i submitted the same code now it beats 70% python solution in runtime. "
                    },
                    {
                        "username": "AnantDuhan",
                        "content": "```\\nclass DisjointSet {\\npublic:\\n    vector<int> rank, parent, size;\\n\\tDisjointSet(int n) {\\n\\t\\trank.resize(n + 1, 0);\\n\\t\\tsize.resize(n + 1);\\n\\t\\tparent.resize(n + 1);\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tparent[i] = i;\\n\\t\\t\\tsize[i] = 1;\\n\\t\\t}\\n\\t}\\n\\n\\t// finding ultimate parent\\n\\tint findUltimateParent(int node) {\\n\\t\\tif (node == parent[node])\\n\\t\\t\\treturn node;\\n\\t\\treturn parent[node] = findUltimateParent(parent[node]);\\n\\t}\\n\\n\\tvoid unionByRank(int u, int v) {\\n\\t\\tint UltimateParent_u = findUltimateParent(u);\\n\\t\\tint UltimateParent_v = findUltimateParent(v);\\n\\n\\t\\tif (UltimateParent_u == UltimateParent_v)\\n\\t\\t\\treturn;\\n\\n\\t\\tif (rank[UltimateParent_u] < rank[UltimateParent_v])\\n\\t\\t\\tparent[UltimateParent_u] = UltimateParent_v;\\n\\t\\telse if (rank[UltimateParent_v] < rank[UltimateParent_u])\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\telse {\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\t\\trank[UltimateParent_u]++;\\n\\t\\t}\\n\\t}\\n\\n\\tvoid unionBySize(int u, int v) {\\n\\t\\tint UltimateParent_u = findUltimateParent(u);\\n\\t\\tint UltimateParent_v = findUltimateParent(v);\\n\\n\\t\\tif (UltimateParent_u == UltimateParent_v)\\n\\t\\t\\treturn;\\n\\n\\t\\tif (rank[UltimateParent_u] < rank[UltimateParent_v]) {\\n\\t\\t\\tparent[UltimateParent_u] = UltimateParent_v;\\n\\t\\t\\tsize[UltimateParent_v] += size[UltimateParent_u];\\n\\t\\t} else {\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\t\\tsize[UltimateParent_u] += size[UltimateParent_v];\\n\\t\\t}\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        DisjointSet ds(n*n);\\n\\n        // Connecting components -> step-1\\n        for(int row=0;row<n;row++) {\\n            for(int col=0;col<n;col++) {\\n                if(grid[row][col] == 0)\\n                    continue;\\n                int delrow[] = {-1, 0, 1, 0};\\n                int delcol[] = {0, -1, 0, 1};\\n\\n                for(int i=0;i<4;i++) {\\n                    int nrow = row + delrow[i];\\n                    int ncol = col + delcol[i];\\n                    if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < n) {\\n                        if(grid[nrow][ncol] == 1) {\\n                            int nodeNumber = row * n + col;\\n                            int adjNodeNumber = nrow * n + ncol;\\n                            ds.unionBySize(nodeNumber, adjNodeNumber);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Try Changing 0 to 1 -> step-2\\n        int maxi = 0;\\n        for(int row=0;row<n;row++) {\\n            for(int col=0;col<n;col++) {\\n                if(grid[row][col] == 1)\\n                    continue;\\n                int delrow[] = {-1, 0, 1, 0};\\n                int delcol[] = {0, -1, 0, 1};\\n\\n                set<int> components;\\n                for(int i=0;i<4;i++) {\\n                    int nrow = row + delrow[i];\\n                    int ncol = col + delcol[i];\\n\\n                    if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < n) {\\n                        if(grid[nrow][ncol] == 1) {\\n                            components.insert(ds.findUltimateParent(nrow * n + ncol));       \\n                        }\\n                    }\\n                }\\n                int totalSize = 0;\\n                for(auto it: components) {\\n                    totalSize += ds.size[it];\\n                }\\n                maxi = max(maxi, totalSize + 1);\\n            }\\n        }\\n\\n        for(int cellNumber = 0; cellNumber < n * n; cellNumber++) {\\n            maxi = max(maxi, ds.size[ds.findUltimateParent(cellNumber)]);\\n        }\\n        return maxi;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avminus",
                        "content": "solution kyu daal raha hai discuss mein bro"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Nice solution !! I have done the same just with dfs !"
                    }
                ]
            },
            {
                "id": 2048496,
                "content": [
                    {
                        "username": "harshit4me",
                        "content": "Peoples are mad. below it has written, don\\'t post any solutions but they are stilling pasting. We have another option also to post the solutions."
                    },
                    {
                        "username": "michaeljosephhearn",
                        "content": "This was fun, do easier island problems then work up to this one. <3"
                    },
                    {
                        "username": "allenlsy",
                        "content": "I think the official implementation behind python3 is wrong. For this case:\\n\\n[[1,0,1,0],[0,0,0,1],[1,0,1,0]]\\n\\nThe largest island should be 4. But when I run the code with custom test cases, the expected result is 3, which is wrong.\\n"
                    },
                    {
                        "username": "rahulraikwar00",
                        "content": "Grid should be n*n! according to question!"
                    },
                    {
                        "username": "wenjunwang2014",
                        "content": "For a case such like \\n[[1,1,0,1],[1,0,0,1]]\\nThe answer should be 6, however the test code gives 4."
                    },
                    {
                        "username": "Vibhoar_Bajaj",
                        "content": "the question states n*n"
                    },
                    {
                        "username": "SeineAle",
                        "content": "I am ashamed of 1754 ms rt and 480 mb mem in  C ++but I am proud that I did it smh."
                    },
                    {
                        "username": "ssredotime",
                        "content": "I love problems like this. So much more satisfying than some medium or easy labelled array problem \"find the kth smallest permutation of the maximum noncontiguous subarray after optionally removing up to j elements at indices where (i, nums[i]) are co-prime\"."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Logic is not difficult. But the implementation part is a bit long.\\nUsed Python BFS + Hashmap for solving. "
                    },
                    {
                        "username": "CodeCrusader1",
                        "content": "class DSU {\\n    int[] parent;\\n    int[] size;\\n    int max;\\n\\n    public DSU(int n) {\\n        parent = new int[n];\\n        size = new int[n];\\n        max = 0;\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = -1;\\n            size[i] = 1;\\n        }\\n    }\\n\\n\\n    public int biggest() {\\n        return max;\\n    }\\n\\n    public int find(int x) {\\n        if (parent[x] != x)\\n            parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n\\n    public void addIsland(int x) {\\n        if (parent[x] >= 0)\\n            return;\\n        parent[x] = x;\\n        max=Math.max(max,1);\\n    }\\n\\n    public void union(int x, int y) {\\n        int px = find(x), py = find(y);\\n\\n        if (px != py) {\\n            if (size[px] >= size[py]) {\\n                size[px] += size[py];\\n                parent[py] = px;\\n                max = Math.max(max, size[px]);\\n            } else {\\n                size[py] += size[px];\\n                parent[px] = py;\\n                max = Math.max(max, size[py]);\\n            }\\n        }\\n    }\\n      public int getS(int x) {\\n          int px= find(x);\\n        return size[px];\\n    }\\n\\n    public boolean check(int x){\\n        if (parent[x] >= 0) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    public int largestIsland(int[][] grid) {\\n        int n = grid.length;\\n        DSU set = new DSU(n * n);\\n        int drow[] = {-1, 1, 0, 0};\\n        int dcol[] = {0, 0, -1, 1};\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    set.addIsland(i*n+j);\\n                    for (int k = 0; k < 4; k++) {\\n                        int dr = i + drow[k];\\n                        int dc = j + dcol[k];\\n                        int child = n * dr + dc;\\n                        if (dr >= 0 && dr < n && dc >= 0 && dc < n)\\n                           if(set.check(dr*n+dc))\\n                            set.union(i * n + j, child);\\n                    }\\n                }\\n            }\\n        } \\n         int res=set.biggest();\\n         for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                 \\n                if (grid[i][j] == 0) {                    \\n                    int temp=1;\\n                    Set<Integer> hs= new HashSet<>();\\n                    for (int k = 0; k < 4; k++) {\\n                        int dr = i + drow[k];\\n                        int dc = j + dcol[k];\\n                        int child = n * dr + dc;\\n                        if (dr >= 0 && dr < n && dc >= 0 && dc < n)\\n                           if(set.check(dr*n+dc)){\\n                              if( hs.add(set.find(child))){\\n                                    temp+=set.getS(child);\\n                              }\\n\\n                           }                             \\n                    }\\n                res= Math.max(res,temp);\\n                }\\n\\n            }\\n        }\\n\\n       return res;\\n    }\\n}\\n"
                    },
                    {
                        "username": "tr1ten",
                        "content": "WTH with this python runtime? \\nInitially i submitted the code (N^2) it threw TLE, again i submitted the same code now it beats 70% python solution in runtime. "
                    },
                    {
                        "username": "AnantDuhan",
                        "content": "```\\nclass DisjointSet {\\npublic:\\n    vector<int> rank, parent, size;\\n\\tDisjointSet(int n) {\\n\\t\\trank.resize(n + 1, 0);\\n\\t\\tsize.resize(n + 1);\\n\\t\\tparent.resize(n + 1);\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tparent[i] = i;\\n\\t\\t\\tsize[i] = 1;\\n\\t\\t}\\n\\t}\\n\\n\\t// finding ultimate parent\\n\\tint findUltimateParent(int node) {\\n\\t\\tif (node == parent[node])\\n\\t\\t\\treturn node;\\n\\t\\treturn parent[node] = findUltimateParent(parent[node]);\\n\\t}\\n\\n\\tvoid unionByRank(int u, int v) {\\n\\t\\tint UltimateParent_u = findUltimateParent(u);\\n\\t\\tint UltimateParent_v = findUltimateParent(v);\\n\\n\\t\\tif (UltimateParent_u == UltimateParent_v)\\n\\t\\t\\treturn;\\n\\n\\t\\tif (rank[UltimateParent_u] < rank[UltimateParent_v])\\n\\t\\t\\tparent[UltimateParent_u] = UltimateParent_v;\\n\\t\\telse if (rank[UltimateParent_v] < rank[UltimateParent_u])\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\telse {\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\t\\trank[UltimateParent_u]++;\\n\\t\\t}\\n\\t}\\n\\n\\tvoid unionBySize(int u, int v) {\\n\\t\\tint UltimateParent_u = findUltimateParent(u);\\n\\t\\tint UltimateParent_v = findUltimateParent(v);\\n\\n\\t\\tif (UltimateParent_u == UltimateParent_v)\\n\\t\\t\\treturn;\\n\\n\\t\\tif (rank[UltimateParent_u] < rank[UltimateParent_v]) {\\n\\t\\t\\tparent[UltimateParent_u] = UltimateParent_v;\\n\\t\\t\\tsize[UltimateParent_v] += size[UltimateParent_u];\\n\\t\\t} else {\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\t\\tsize[UltimateParent_u] += size[UltimateParent_v];\\n\\t\\t}\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        DisjointSet ds(n*n);\\n\\n        // Connecting components -> step-1\\n        for(int row=0;row<n;row++) {\\n            for(int col=0;col<n;col++) {\\n                if(grid[row][col] == 0)\\n                    continue;\\n                int delrow[] = {-1, 0, 1, 0};\\n                int delcol[] = {0, -1, 0, 1};\\n\\n                for(int i=0;i<4;i++) {\\n                    int nrow = row + delrow[i];\\n                    int ncol = col + delcol[i];\\n                    if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < n) {\\n                        if(grid[nrow][ncol] == 1) {\\n                            int nodeNumber = row * n + col;\\n                            int adjNodeNumber = nrow * n + ncol;\\n                            ds.unionBySize(nodeNumber, adjNodeNumber);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Try Changing 0 to 1 -> step-2\\n        int maxi = 0;\\n        for(int row=0;row<n;row++) {\\n            for(int col=0;col<n;col++) {\\n                if(grid[row][col] == 1)\\n                    continue;\\n                int delrow[] = {-1, 0, 1, 0};\\n                int delcol[] = {0, -1, 0, 1};\\n\\n                set<int> components;\\n                for(int i=0;i<4;i++) {\\n                    int nrow = row + delrow[i];\\n                    int ncol = col + delcol[i];\\n\\n                    if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < n) {\\n                        if(grid[nrow][ncol] == 1) {\\n                            components.insert(ds.findUltimateParent(nrow * n + ncol));       \\n                        }\\n                    }\\n                }\\n                int totalSize = 0;\\n                for(auto it: components) {\\n                    totalSize += ds.size[it];\\n                }\\n                maxi = max(maxi, totalSize + 1);\\n            }\\n        }\\n\\n        for(int cellNumber = 0; cellNumber < n * n; cellNumber++) {\\n            maxi = max(maxi, ds.size[ds.findUltimateParent(cellNumber)]);\\n        }\\n        return maxi;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avminus",
                        "content": "solution kyu daal raha hai discuss mein bro"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Nice solution !! I have done the same just with dfs !"
                    }
                ]
            },
            {
                "id": 2027202,
                "content": [
                    {
                        "username": "harshit4me",
                        "content": "Peoples are mad. below it has written, don\\'t post any solutions but they are stilling pasting. We have another option also to post the solutions."
                    },
                    {
                        "username": "michaeljosephhearn",
                        "content": "This was fun, do easier island problems then work up to this one. <3"
                    },
                    {
                        "username": "allenlsy",
                        "content": "I think the official implementation behind python3 is wrong. For this case:\\n\\n[[1,0,1,0],[0,0,0,1],[1,0,1,0]]\\n\\nThe largest island should be 4. But when I run the code with custom test cases, the expected result is 3, which is wrong.\\n"
                    },
                    {
                        "username": "rahulraikwar00",
                        "content": "Grid should be n*n! according to question!"
                    },
                    {
                        "username": "wenjunwang2014",
                        "content": "For a case such like \\n[[1,1,0,1],[1,0,0,1]]\\nThe answer should be 6, however the test code gives 4."
                    },
                    {
                        "username": "Vibhoar_Bajaj",
                        "content": "the question states n*n"
                    },
                    {
                        "username": "SeineAle",
                        "content": "I am ashamed of 1754 ms rt and 480 mb mem in  C ++but I am proud that I did it smh."
                    },
                    {
                        "username": "ssredotime",
                        "content": "I love problems like this. So much more satisfying than some medium or easy labelled array problem \"find the kth smallest permutation of the maximum noncontiguous subarray after optionally removing up to j elements at indices where (i, nums[i]) are co-prime\"."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Logic is not difficult. But the implementation part is a bit long.\\nUsed Python BFS + Hashmap for solving. "
                    },
                    {
                        "username": "CodeCrusader1",
                        "content": "class DSU {\\n    int[] parent;\\n    int[] size;\\n    int max;\\n\\n    public DSU(int n) {\\n        parent = new int[n];\\n        size = new int[n];\\n        max = 0;\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = -1;\\n            size[i] = 1;\\n        }\\n    }\\n\\n\\n    public int biggest() {\\n        return max;\\n    }\\n\\n    public int find(int x) {\\n        if (parent[x] != x)\\n            parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n\\n    public void addIsland(int x) {\\n        if (parent[x] >= 0)\\n            return;\\n        parent[x] = x;\\n        max=Math.max(max,1);\\n    }\\n\\n    public void union(int x, int y) {\\n        int px = find(x), py = find(y);\\n\\n        if (px != py) {\\n            if (size[px] >= size[py]) {\\n                size[px] += size[py];\\n                parent[py] = px;\\n                max = Math.max(max, size[px]);\\n            } else {\\n                size[py] += size[px];\\n                parent[px] = py;\\n                max = Math.max(max, size[py]);\\n            }\\n        }\\n    }\\n      public int getS(int x) {\\n          int px= find(x);\\n        return size[px];\\n    }\\n\\n    public boolean check(int x){\\n        if (parent[x] >= 0) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    public int largestIsland(int[][] grid) {\\n        int n = grid.length;\\n        DSU set = new DSU(n * n);\\n        int drow[] = {-1, 1, 0, 0};\\n        int dcol[] = {0, 0, -1, 1};\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    set.addIsland(i*n+j);\\n                    for (int k = 0; k < 4; k++) {\\n                        int dr = i + drow[k];\\n                        int dc = j + dcol[k];\\n                        int child = n * dr + dc;\\n                        if (dr >= 0 && dr < n && dc >= 0 && dc < n)\\n                           if(set.check(dr*n+dc))\\n                            set.union(i * n + j, child);\\n                    }\\n                }\\n            }\\n        } \\n         int res=set.biggest();\\n         for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                 \\n                if (grid[i][j] == 0) {                    \\n                    int temp=1;\\n                    Set<Integer> hs= new HashSet<>();\\n                    for (int k = 0; k < 4; k++) {\\n                        int dr = i + drow[k];\\n                        int dc = j + dcol[k];\\n                        int child = n * dr + dc;\\n                        if (dr >= 0 && dr < n && dc >= 0 && dc < n)\\n                           if(set.check(dr*n+dc)){\\n                              if( hs.add(set.find(child))){\\n                                    temp+=set.getS(child);\\n                              }\\n\\n                           }                             \\n                    }\\n                res= Math.max(res,temp);\\n                }\\n\\n            }\\n        }\\n\\n       return res;\\n    }\\n}\\n"
                    },
                    {
                        "username": "tr1ten",
                        "content": "WTH with this python runtime? \\nInitially i submitted the code (N^2) it threw TLE, again i submitted the same code now it beats 70% python solution in runtime. "
                    },
                    {
                        "username": "AnantDuhan",
                        "content": "```\\nclass DisjointSet {\\npublic:\\n    vector<int> rank, parent, size;\\n\\tDisjointSet(int n) {\\n\\t\\trank.resize(n + 1, 0);\\n\\t\\tsize.resize(n + 1);\\n\\t\\tparent.resize(n + 1);\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tparent[i] = i;\\n\\t\\t\\tsize[i] = 1;\\n\\t\\t}\\n\\t}\\n\\n\\t// finding ultimate parent\\n\\tint findUltimateParent(int node) {\\n\\t\\tif (node == parent[node])\\n\\t\\t\\treturn node;\\n\\t\\treturn parent[node] = findUltimateParent(parent[node]);\\n\\t}\\n\\n\\tvoid unionByRank(int u, int v) {\\n\\t\\tint UltimateParent_u = findUltimateParent(u);\\n\\t\\tint UltimateParent_v = findUltimateParent(v);\\n\\n\\t\\tif (UltimateParent_u == UltimateParent_v)\\n\\t\\t\\treturn;\\n\\n\\t\\tif (rank[UltimateParent_u] < rank[UltimateParent_v])\\n\\t\\t\\tparent[UltimateParent_u] = UltimateParent_v;\\n\\t\\telse if (rank[UltimateParent_v] < rank[UltimateParent_u])\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\telse {\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\t\\trank[UltimateParent_u]++;\\n\\t\\t}\\n\\t}\\n\\n\\tvoid unionBySize(int u, int v) {\\n\\t\\tint UltimateParent_u = findUltimateParent(u);\\n\\t\\tint UltimateParent_v = findUltimateParent(v);\\n\\n\\t\\tif (UltimateParent_u == UltimateParent_v)\\n\\t\\t\\treturn;\\n\\n\\t\\tif (rank[UltimateParent_u] < rank[UltimateParent_v]) {\\n\\t\\t\\tparent[UltimateParent_u] = UltimateParent_v;\\n\\t\\t\\tsize[UltimateParent_v] += size[UltimateParent_u];\\n\\t\\t} else {\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\t\\tsize[UltimateParent_u] += size[UltimateParent_v];\\n\\t\\t}\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        DisjointSet ds(n*n);\\n\\n        // Connecting components -> step-1\\n        for(int row=0;row<n;row++) {\\n            for(int col=0;col<n;col++) {\\n                if(grid[row][col] == 0)\\n                    continue;\\n                int delrow[] = {-1, 0, 1, 0};\\n                int delcol[] = {0, -1, 0, 1};\\n\\n                for(int i=0;i<4;i++) {\\n                    int nrow = row + delrow[i];\\n                    int ncol = col + delcol[i];\\n                    if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < n) {\\n                        if(grid[nrow][ncol] == 1) {\\n                            int nodeNumber = row * n + col;\\n                            int adjNodeNumber = nrow * n + ncol;\\n                            ds.unionBySize(nodeNumber, adjNodeNumber);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Try Changing 0 to 1 -> step-2\\n        int maxi = 0;\\n        for(int row=0;row<n;row++) {\\n            for(int col=0;col<n;col++) {\\n                if(grid[row][col] == 1)\\n                    continue;\\n                int delrow[] = {-1, 0, 1, 0};\\n                int delcol[] = {0, -1, 0, 1};\\n\\n                set<int> components;\\n                for(int i=0;i<4;i++) {\\n                    int nrow = row + delrow[i];\\n                    int ncol = col + delcol[i];\\n\\n                    if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < n) {\\n                        if(grid[nrow][ncol] == 1) {\\n                            components.insert(ds.findUltimateParent(nrow * n + ncol));       \\n                        }\\n                    }\\n                }\\n                int totalSize = 0;\\n                for(auto it: components) {\\n                    totalSize += ds.size[it];\\n                }\\n                maxi = max(maxi, totalSize + 1);\\n            }\\n        }\\n\\n        for(int cellNumber = 0; cellNumber < n * n; cellNumber++) {\\n            maxi = max(maxi, ds.size[ds.findUltimateParent(cellNumber)]);\\n        }\\n        return maxi;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avminus",
                        "content": "solution kyu daal raha hai discuss mein bro"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Nice solution !! I have done the same just with dfs !"
                    }
                ]
            },
            {
                "id": 2023162,
                "content": [
                    {
                        "username": "harshit4me",
                        "content": "Peoples are mad. below it has written, don\\'t post any solutions but they are stilling pasting. We have another option also to post the solutions."
                    },
                    {
                        "username": "michaeljosephhearn",
                        "content": "This was fun, do easier island problems then work up to this one. <3"
                    },
                    {
                        "username": "allenlsy",
                        "content": "I think the official implementation behind python3 is wrong. For this case:\\n\\n[[1,0,1,0],[0,0,0,1],[1,0,1,0]]\\n\\nThe largest island should be 4. But when I run the code with custom test cases, the expected result is 3, which is wrong.\\n"
                    },
                    {
                        "username": "rahulraikwar00",
                        "content": "Grid should be n*n! according to question!"
                    },
                    {
                        "username": "wenjunwang2014",
                        "content": "For a case such like \\n[[1,1,0,1],[1,0,0,1]]\\nThe answer should be 6, however the test code gives 4."
                    },
                    {
                        "username": "Vibhoar_Bajaj",
                        "content": "the question states n*n"
                    },
                    {
                        "username": "SeineAle",
                        "content": "I am ashamed of 1754 ms rt and 480 mb mem in  C ++but I am proud that I did it smh."
                    },
                    {
                        "username": "ssredotime",
                        "content": "I love problems like this. So much more satisfying than some medium or easy labelled array problem \"find the kth smallest permutation of the maximum noncontiguous subarray after optionally removing up to j elements at indices where (i, nums[i]) are co-prime\"."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Logic is not difficult. But the implementation part is a bit long.\\nUsed Python BFS + Hashmap for solving. "
                    },
                    {
                        "username": "CodeCrusader1",
                        "content": "class DSU {\\n    int[] parent;\\n    int[] size;\\n    int max;\\n\\n    public DSU(int n) {\\n        parent = new int[n];\\n        size = new int[n];\\n        max = 0;\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = -1;\\n            size[i] = 1;\\n        }\\n    }\\n\\n\\n    public int biggest() {\\n        return max;\\n    }\\n\\n    public int find(int x) {\\n        if (parent[x] != x)\\n            parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n\\n    public void addIsland(int x) {\\n        if (parent[x] >= 0)\\n            return;\\n        parent[x] = x;\\n        max=Math.max(max,1);\\n    }\\n\\n    public void union(int x, int y) {\\n        int px = find(x), py = find(y);\\n\\n        if (px != py) {\\n            if (size[px] >= size[py]) {\\n                size[px] += size[py];\\n                parent[py] = px;\\n                max = Math.max(max, size[px]);\\n            } else {\\n                size[py] += size[px];\\n                parent[px] = py;\\n                max = Math.max(max, size[py]);\\n            }\\n        }\\n    }\\n      public int getS(int x) {\\n          int px= find(x);\\n        return size[px];\\n    }\\n\\n    public boolean check(int x){\\n        if (parent[x] >= 0) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    public int largestIsland(int[][] grid) {\\n        int n = grid.length;\\n        DSU set = new DSU(n * n);\\n        int drow[] = {-1, 1, 0, 0};\\n        int dcol[] = {0, 0, -1, 1};\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    set.addIsland(i*n+j);\\n                    for (int k = 0; k < 4; k++) {\\n                        int dr = i + drow[k];\\n                        int dc = j + dcol[k];\\n                        int child = n * dr + dc;\\n                        if (dr >= 0 && dr < n && dc >= 0 && dc < n)\\n                           if(set.check(dr*n+dc))\\n                            set.union(i * n + j, child);\\n                    }\\n                }\\n            }\\n        } \\n         int res=set.biggest();\\n         for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                 \\n                if (grid[i][j] == 0) {                    \\n                    int temp=1;\\n                    Set<Integer> hs= new HashSet<>();\\n                    for (int k = 0; k < 4; k++) {\\n                        int dr = i + drow[k];\\n                        int dc = j + dcol[k];\\n                        int child = n * dr + dc;\\n                        if (dr >= 0 && dr < n && dc >= 0 && dc < n)\\n                           if(set.check(dr*n+dc)){\\n                              if( hs.add(set.find(child))){\\n                                    temp+=set.getS(child);\\n                              }\\n\\n                           }                             \\n                    }\\n                res= Math.max(res,temp);\\n                }\\n\\n            }\\n        }\\n\\n       return res;\\n    }\\n}\\n"
                    },
                    {
                        "username": "tr1ten",
                        "content": "WTH with this python runtime? \\nInitially i submitted the code (N^2) it threw TLE, again i submitted the same code now it beats 70% python solution in runtime. "
                    },
                    {
                        "username": "AnantDuhan",
                        "content": "```\\nclass DisjointSet {\\npublic:\\n    vector<int> rank, parent, size;\\n\\tDisjointSet(int n) {\\n\\t\\trank.resize(n + 1, 0);\\n\\t\\tsize.resize(n + 1);\\n\\t\\tparent.resize(n + 1);\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tparent[i] = i;\\n\\t\\t\\tsize[i] = 1;\\n\\t\\t}\\n\\t}\\n\\n\\t// finding ultimate parent\\n\\tint findUltimateParent(int node) {\\n\\t\\tif (node == parent[node])\\n\\t\\t\\treturn node;\\n\\t\\treturn parent[node] = findUltimateParent(parent[node]);\\n\\t}\\n\\n\\tvoid unionByRank(int u, int v) {\\n\\t\\tint UltimateParent_u = findUltimateParent(u);\\n\\t\\tint UltimateParent_v = findUltimateParent(v);\\n\\n\\t\\tif (UltimateParent_u == UltimateParent_v)\\n\\t\\t\\treturn;\\n\\n\\t\\tif (rank[UltimateParent_u] < rank[UltimateParent_v])\\n\\t\\t\\tparent[UltimateParent_u] = UltimateParent_v;\\n\\t\\telse if (rank[UltimateParent_v] < rank[UltimateParent_u])\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\telse {\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\t\\trank[UltimateParent_u]++;\\n\\t\\t}\\n\\t}\\n\\n\\tvoid unionBySize(int u, int v) {\\n\\t\\tint UltimateParent_u = findUltimateParent(u);\\n\\t\\tint UltimateParent_v = findUltimateParent(v);\\n\\n\\t\\tif (UltimateParent_u == UltimateParent_v)\\n\\t\\t\\treturn;\\n\\n\\t\\tif (rank[UltimateParent_u] < rank[UltimateParent_v]) {\\n\\t\\t\\tparent[UltimateParent_u] = UltimateParent_v;\\n\\t\\t\\tsize[UltimateParent_v] += size[UltimateParent_u];\\n\\t\\t} else {\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\t\\tsize[UltimateParent_u] += size[UltimateParent_v];\\n\\t\\t}\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        DisjointSet ds(n*n);\\n\\n        // Connecting components -> step-1\\n        for(int row=0;row<n;row++) {\\n            for(int col=0;col<n;col++) {\\n                if(grid[row][col] == 0)\\n                    continue;\\n                int delrow[] = {-1, 0, 1, 0};\\n                int delcol[] = {0, -1, 0, 1};\\n\\n                for(int i=0;i<4;i++) {\\n                    int nrow = row + delrow[i];\\n                    int ncol = col + delcol[i];\\n                    if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < n) {\\n                        if(grid[nrow][ncol] == 1) {\\n                            int nodeNumber = row * n + col;\\n                            int adjNodeNumber = nrow * n + ncol;\\n                            ds.unionBySize(nodeNumber, adjNodeNumber);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Try Changing 0 to 1 -> step-2\\n        int maxi = 0;\\n        for(int row=0;row<n;row++) {\\n            for(int col=0;col<n;col++) {\\n                if(grid[row][col] == 1)\\n                    continue;\\n                int delrow[] = {-1, 0, 1, 0};\\n                int delcol[] = {0, -1, 0, 1};\\n\\n                set<int> components;\\n                for(int i=0;i<4;i++) {\\n                    int nrow = row + delrow[i];\\n                    int ncol = col + delcol[i];\\n\\n                    if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < n) {\\n                        if(grid[nrow][ncol] == 1) {\\n                            components.insert(ds.findUltimateParent(nrow * n + ncol));       \\n                        }\\n                    }\\n                }\\n                int totalSize = 0;\\n                for(auto it: components) {\\n                    totalSize += ds.size[it];\\n                }\\n                maxi = max(maxi, totalSize + 1);\\n            }\\n        }\\n\\n        for(int cellNumber = 0; cellNumber < n * n; cellNumber++) {\\n            maxi = max(maxi, ds.size[ds.findUltimateParent(cellNumber)]);\\n        }\\n        return maxi;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avminus",
                        "content": "solution kyu daal raha hai discuss mein bro"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Nice solution !! I have done the same just with dfs !"
                    }
                ]
            },
            {
                "id": 1708166,
                "content": [
                    {
                        "username": "harshit4me",
                        "content": "Peoples are mad. below it has written, don\\'t post any solutions but they are stilling pasting. We have another option also to post the solutions."
                    },
                    {
                        "username": "michaeljosephhearn",
                        "content": "This was fun, do easier island problems then work up to this one. <3"
                    },
                    {
                        "username": "allenlsy",
                        "content": "I think the official implementation behind python3 is wrong. For this case:\\n\\n[[1,0,1,0],[0,0,0,1],[1,0,1,0]]\\n\\nThe largest island should be 4. But when I run the code with custom test cases, the expected result is 3, which is wrong.\\n"
                    },
                    {
                        "username": "rahulraikwar00",
                        "content": "Grid should be n*n! according to question!"
                    },
                    {
                        "username": "wenjunwang2014",
                        "content": "For a case such like \\n[[1,1,0,1],[1,0,0,1]]\\nThe answer should be 6, however the test code gives 4."
                    },
                    {
                        "username": "Vibhoar_Bajaj",
                        "content": "the question states n*n"
                    },
                    {
                        "username": "SeineAle",
                        "content": "I am ashamed of 1754 ms rt and 480 mb mem in  C ++but I am proud that I did it smh."
                    },
                    {
                        "username": "ssredotime",
                        "content": "I love problems like this. So much more satisfying than some medium or easy labelled array problem \"find the kth smallest permutation of the maximum noncontiguous subarray after optionally removing up to j elements at indices where (i, nums[i]) are co-prime\"."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Logic is not difficult. But the implementation part is a bit long.\\nUsed Python BFS + Hashmap for solving. "
                    },
                    {
                        "username": "CodeCrusader1",
                        "content": "class DSU {\\n    int[] parent;\\n    int[] size;\\n    int max;\\n\\n    public DSU(int n) {\\n        parent = new int[n];\\n        size = new int[n];\\n        max = 0;\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = -1;\\n            size[i] = 1;\\n        }\\n    }\\n\\n\\n    public int biggest() {\\n        return max;\\n    }\\n\\n    public int find(int x) {\\n        if (parent[x] != x)\\n            parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n\\n    public void addIsland(int x) {\\n        if (parent[x] >= 0)\\n            return;\\n        parent[x] = x;\\n        max=Math.max(max,1);\\n    }\\n\\n    public void union(int x, int y) {\\n        int px = find(x), py = find(y);\\n\\n        if (px != py) {\\n            if (size[px] >= size[py]) {\\n                size[px] += size[py];\\n                parent[py] = px;\\n                max = Math.max(max, size[px]);\\n            } else {\\n                size[py] += size[px];\\n                parent[px] = py;\\n                max = Math.max(max, size[py]);\\n            }\\n        }\\n    }\\n      public int getS(int x) {\\n          int px= find(x);\\n        return size[px];\\n    }\\n\\n    public boolean check(int x){\\n        if (parent[x] >= 0) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    public int largestIsland(int[][] grid) {\\n        int n = grid.length;\\n        DSU set = new DSU(n * n);\\n        int drow[] = {-1, 1, 0, 0};\\n        int dcol[] = {0, 0, -1, 1};\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    set.addIsland(i*n+j);\\n                    for (int k = 0; k < 4; k++) {\\n                        int dr = i + drow[k];\\n                        int dc = j + dcol[k];\\n                        int child = n * dr + dc;\\n                        if (dr >= 0 && dr < n && dc >= 0 && dc < n)\\n                           if(set.check(dr*n+dc))\\n                            set.union(i * n + j, child);\\n                    }\\n                }\\n            }\\n        } \\n         int res=set.biggest();\\n         for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                 \\n                if (grid[i][j] == 0) {                    \\n                    int temp=1;\\n                    Set<Integer> hs= new HashSet<>();\\n                    for (int k = 0; k < 4; k++) {\\n                        int dr = i + drow[k];\\n                        int dc = j + dcol[k];\\n                        int child = n * dr + dc;\\n                        if (dr >= 0 && dr < n && dc >= 0 && dc < n)\\n                           if(set.check(dr*n+dc)){\\n                              if( hs.add(set.find(child))){\\n                                    temp+=set.getS(child);\\n                              }\\n\\n                           }                             \\n                    }\\n                res= Math.max(res,temp);\\n                }\\n\\n            }\\n        }\\n\\n       return res;\\n    }\\n}\\n"
                    },
                    {
                        "username": "tr1ten",
                        "content": "WTH with this python runtime? \\nInitially i submitted the code (N^2) it threw TLE, again i submitted the same code now it beats 70% python solution in runtime. "
                    },
                    {
                        "username": "AnantDuhan",
                        "content": "```\\nclass DisjointSet {\\npublic:\\n    vector<int> rank, parent, size;\\n\\tDisjointSet(int n) {\\n\\t\\trank.resize(n + 1, 0);\\n\\t\\tsize.resize(n + 1);\\n\\t\\tparent.resize(n + 1);\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tparent[i] = i;\\n\\t\\t\\tsize[i] = 1;\\n\\t\\t}\\n\\t}\\n\\n\\t// finding ultimate parent\\n\\tint findUltimateParent(int node) {\\n\\t\\tif (node == parent[node])\\n\\t\\t\\treturn node;\\n\\t\\treturn parent[node] = findUltimateParent(parent[node]);\\n\\t}\\n\\n\\tvoid unionByRank(int u, int v) {\\n\\t\\tint UltimateParent_u = findUltimateParent(u);\\n\\t\\tint UltimateParent_v = findUltimateParent(v);\\n\\n\\t\\tif (UltimateParent_u == UltimateParent_v)\\n\\t\\t\\treturn;\\n\\n\\t\\tif (rank[UltimateParent_u] < rank[UltimateParent_v])\\n\\t\\t\\tparent[UltimateParent_u] = UltimateParent_v;\\n\\t\\telse if (rank[UltimateParent_v] < rank[UltimateParent_u])\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\telse {\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\t\\trank[UltimateParent_u]++;\\n\\t\\t}\\n\\t}\\n\\n\\tvoid unionBySize(int u, int v) {\\n\\t\\tint UltimateParent_u = findUltimateParent(u);\\n\\t\\tint UltimateParent_v = findUltimateParent(v);\\n\\n\\t\\tif (UltimateParent_u == UltimateParent_v)\\n\\t\\t\\treturn;\\n\\n\\t\\tif (rank[UltimateParent_u] < rank[UltimateParent_v]) {\\n\\t\\t\\tparent[UltimateParent_u] = UltimateParent_v;\\n\\t\\t\\tsize[UltimateParent_v] += size[UltimateParent_u];\\n\\t\\t} else {\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\t\\tsize[UltimateParent_u] += size[UltimateParent_v];\\n\\t\\t}\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        DisjointSet ds(n*n);\\n\\n        // Connecting components -> step-1\\n        for(int row=0;row<n;row++) {\\n            for(int col=0;col<n;col++) {\\n                if(grid[row][col] == 0)\\n                    continue;\\n                int delrow[] = {-1, 0, 1, 0};\\n                int delcol[] = {0, -1, 0, 1};\\n\\n                for(int i=0;i<4;i++) {\\n                    int nrow = row + delrow[i];\\n                    int ncol = col + delcol[i];\\n                    if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < n) {\\n                        if(grid[nrow][ncol] == 1) {\\n                            int nodeNumber = row * n + col;\\n                            int adjNodeNumber = nrow * n + ncol;\\n                            ds.unionBySize(nodeNumber, adjNodeNumber);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Try Changing 0 to 1 -> step-2\\n        int maxi = 0;\\n        for(int row=0;row<n;row++) {\\n            for(int col=0;col<n;col++) {\\n                if(grid[row][col] == 1)\\n                    continue;\\n                int delrow[] = {-1, 0, 1, 0};\\n                int delcol[] = {0, -1, 0, 1};\\n\\n                set<int> components;\\n                for(int i=0;i<4;i++) {\\n                    int nrow = row + delrow[i];\\n                    int ncol = col + delcol[i];\\n\\n                    if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < n) {\\n                        if(grid[nrow][ncol] == 1) {\\n                            components.insert(ds.findUltimateParent(nrow * n + ncol));       \\n                        }\\n                    }\\n                }\\n                int totalSize = 0;\\n                for(auto it: components) {\\n                    totalSize += ds.size[it];\\n                }\\n                maxi = max(maxi, totalSize + 1);\\n            }\\n        }\\n\\n        for(int cellNumber = 0; cellNumber < n * n; cellNumber++) {\\n            maxi = max(maxi, ds.size[ds.findUltimateParent(cellNumber)]);\\n        }\\n        return maxi;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avminus",
                        "content": "solution kyu daal raha hai discuss mein bro"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Nice solution !! I have done the same just with dfs !"
                    }
                ]
            },
            {
                "id": 1683721,
                "content": [
                    {
                        "username": "harshit4me",
                        "content": "Peoples are mad. below it has written, don\\'t post any solutions but they are stilling pasting. We have another option also to post the solutions."
                    },
                    {
                        "username": "michaeljosephhearn",
                        "content": "This was fun, do easier island problems then work up to this one. <3"
                    },
                    {
                        "username": "allenlsy",
                        "content": "I think the official implementation behind python3 is wrong. For this case:\\n\\n[[1,0,1,0],[0,0,0,1],[1,0,1,0]]\\n\\nThe largest island should be 4. But when I run the code with custom test cases, the expected result is 3, which is wrong.\\n"
                    },
                    {
                        "username": "rahulraikwar00",
                        "content": "Grid should be n*n! according to question!"
                    },
                    {
                        "username": "wenjunwang2014",
                        "content": "For a case such like \\n[[1,1,0,1],[1,0,0,1]]\\nThe answer should be 6, however the test code gives 4."
                    },
                    {
                        "username": "Vibhoar_Bajaj",
                        "content": "the question states n*n"
                    },
                    {
                        "username": "SeineAle",
                        "content": "I am ashamed of 1754 ms rt and 480 mb mem in  C ++but I am proud that I did it smh."
                    },
                    {
                        "username": "ssredotime",
                        "content": "I love problems like this. So much more satisfying than some medium or easy labelled array problem \"find the kth smallest permutation of the maximum noncontiguous subarray after optionally removing up to j elements at indices where (i, nums[i]) are co-prime\"."
                    },
                    {
                        "username": "code__HARD",
                        "content": "Logic is not difficult. But the implementation part is a bit long.\\nUsed Python BFS + Hashmap for solving. "
                    },
                    {
                        "username": "CodeCrusader1",
                        "content": "class DSU {\\n    int[] parent;\\n    int[] size;\\n    int max;\\n\\n    public DSU(int n) {\\n        parent = new int[n];\\n        size = new int[n];\\n        max = 0;\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = -1;\\n            size[i] = 1;\\n        }\\n    }\\n\\n\\n    public int biggest() {\\n        return max;\\n    }\\n\\n    public int find(int x) {\\n        if (parent[x] != x)\\n            parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n\\n    public void addIsland(int x) {\\n        if (parent[x] >= 0)\\n            return;\\n        parent[x] = x;\\n        max=Math.max(max,1);\\n    }\\n\\n    public void union(int x, int y) {\\n        int px = find(x), py = find(y);\\n\\n        if (px != py) {\\n            if (size[px] >= size[py]) {\\n                size[px] += size[py];\\n                parent[py] = px;\\n                max = Math.max(max, size[px]);\\n            } else {\\n                size[py] += size[px];\\n                parent[px] = py;\\n                max = Math.max(max, size[py]);\\n            }\\n        }\\n    }\\n      public int getS(int x) {\\n          int px= find(x);\\n        return size[px];\\n    }\\n\\n    public boolean check(int x){\\n        if (parent[x] >= 0) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    public int largestIsland(int[][] grid) {\\n        int n = grid.length;\\n        DSU set = new DSU(n * n);\\n        int drow[] = {-1, 1, 0, 0};\\n        int dcol[] = {0, 0, -1, 1};\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid[i][j] == 1) {\\n                    set.addIsland(i*n+j);\\n                    for (int k = 0; k < 4; k++) {\\n                        int dr = i + drow[k];\\n                        int dc = j + dcol[k];\\n                        int child = n * dr + dc;\\n                        if (dr >= 0 && dr < n && dc >= 0 && dc < n)\\n                           if(set.check(dr*n+dc))\\n                            set.union(i * n + j, child);\\n                    }\\n                }\\n            }\\n        } \\n         int res=set.biggest();\\n         for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < n; j++) {\\n                 \\n                if (grid[i][j] == 0) {                    \\n                    int temp=1;\\n                    Set<Integer> hs= new HashSet<>();\\n                    for (int k = 0; k < 4; k++) {\\n                        int dr = i + drow[k];\\n                        int dc = j + dcol[k];\\n                        int child = n * dr + dc;\\n                        if (dr >= 0 && dr < n && dc >= 0 && dc < n)\\n                           if(set.check(dr*n+dc)){\\n                              if( hs.add(set.find(child))){\\n                                    temp+=set.getS(child);\\n                              }\\n\\n                           }                             \\n                    }\\n                res= Math.max(res,temp);\\n                }\\n\\n            }\\n        }\\n\\n       return res;\\n    }\\n}\\n"
                    },
                    {
                        "username": "tr1ten",
                        "content": "WTH with this python runtime? \\nInitially i submitted the code (N^2) it threw TLE, again i submitted the same code now it beats 70% python solution in runtime. "
                    },
                    {
                        "username": "AnantDuhan",
                        "content": "```\\nclass DisjointSet {\\npublic:\\n    vector<int> rank, parent, size;\\n\\tDisjointSet(int n) {\\n\\t\\trank.resize(n + 1, 0);\\n\\t\\tsize.resize(n + 1);\\n\\t\\tparent.resize(n + 1);\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tparent[i] = i;\\n\\t\\t\\tsize[i] = 1;\\n\\t\\t}\\n\\t}\\n\\n\\t// finding ultimate parent\\n\\tint findUltimateParent(int node) {\\n\\t\\tif (node == parent[node])\\n\\t\\t\\treturn node;\\n\\t\\treturn parent[node] = findUltimateParent(parent[node]);\\n\\t}\\n\\n\\tvoid unionByRank(int u, int v) {\\n\\t\\tint UltimateParent_u = findUltimateParent(u);\\n\\t\\tint UltimateParent_v = findUltimateParent(v);\\n\\n\\t\\tif (UltimateParent_u == UltimateParent_v)\\n\\t\\t\\treturn;\\n\\n\\t\\tif (rank[UltimateParent_u] < rank[UltimateParent_v])\\n\\t\\t\\tparent[UltimateParent_u] = UltimateParent_v;\\n\\t\\telse if (rank[UltimateParent_v] < rank[UltimateParent_u])\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\telse {\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\t\\trank[UltimateParent_u]++;\\n\\t\\t}\\n\\t}\\n\\n\\tvoid unionBySize(int u, int v) {\\n\\t\\tint UltimateParent_u = findUltimateParent(u);\\n\\t\\tint UltimateParent_v = findUltimateParent(v);\\n\\n\\t\\tif (UltimateParent_u == UltimateParent_v)\\n\\t\\t\\treturn;\\n\\n\\t\\tif (rank[UltimateParent_u] < rank[UltimateParent_v]) {\\n\\t\\t\\tparent[UltimateParent_u] = UltimateParent_v;\\n\\t\\t\\tsize[UltimateParent_v] += size[UltimateParent_u];\\n\\t\\t} else {\\n\\t\\t\\tparent[UltimateParent_v] = UltimateParent_u;\\n\\t\\t\\tsize[UltimateParent_u] += size[UltimateParent_v];\\n\\t\\t}\\n\\t}\\n};\\n\\nclass Solution {\\npublic:\\n    int largestIsland(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        DisjointSet ds(n*n);\\n\\n        // Connecting components -> step-1\\n        for(int row=0;row<n;row++) {\\n            for(int col=0;col<n;col++) {\\n                if(grid[row][col] == 0)\\n                    continue;\\n                int delrow[] = {-1, 0, 1, 0};\\n                int delcol[] = {0, -1, 0, 1};\\n\\n                for(int i=0;i<4;i++) {\\n                    int nrow = row + delrow[i];\\n                    int ncol = col + delcol[i];\\n                    if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < n) {\\n                        if(grid[nrow][ncol] == 1) {\\n                            int nodeNumber = row * n + col;\\n                            int adjNodeNumber = nrow * n + ncol;\\n                            ds.unionBySize(nodeNumber, adjNodeNumber);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Try Changing 0 to 1 -> step-2\\n        int maxi = 0;\\n        for(int row=0;row<n;row++) {\\n            for(int col=0;col<n;col++) {\\n                if(grid[row][col] == 1)\\n                    continue;\\n                int delrow[] = {-1, 0, 1, 0};\\n                int delcol[] = {0, -1, 0, 1};\\n\\n                set<int> components;\\n                for(int i=0;i<4;i++) {\\n                    int nrow = row + delrow[i];\\n                    int ncol = col + delcol[i];\\n\\n                    if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < n) {\\n                        if(grid[nrow][ncol] == 1) {\\n                            components.insert(ds.findUltimateParent(nrow * n + ncol));       \\n                        }\\n                    }\\n                }\\n                int totalSize = 0;\\n                for(auto it: components) {\\n                    totalSize += ds.size[it];\\n                }\\n                maxi = max(maxi, totalSize + 1);\\n            }\\n        }\\n\\n        for(int cellNumber = 0; cellNumber < n * n; cellNumber++) {\\n            maxi = max(maxi, ds.size[ds.findUltimateParent(cellNumber)]);\\n        }\\n        return maxi;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "avminus",
                        "content": "solution kyu daal raha hai discuss mein bro"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "Nice solution !! I have done the same just with dfs !"
                    }
                ]
            }
        ]
    },
    {
        "title": "Smallest String With Swaps",
        "question_content": "<p>You are given a string <code>s</code>, and an array of pairs of indices in the string&nbsp;<code>pairs</code>&nbsp;where&nbsp;<code>pairs[i] =&nbsp;[a, b]</code>&nbsp;indicates 2 indices(0-indexed) of the string.</p>\n\n<p>You can&nbsp;swap the characters at any pair of indices in the given&nbsp;<code>pairs</code>&nbsp;<strong>any number of times</strong>.</p>\n\n<p>Return the&nbsp;lexicographically smallest string that <code>s</code>&nbsp;can be changed to after using the swaps.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;dcab&quot;, pairs = [[0,3],[1,2]]\n<strong>Output:</strong> &quot;bacd&quot;\n<strong>Explaination:</strong> \nSwap s[0] and s[3], s = &quot;bcad&quot;\nSwap s[1] and s[2], s = &quot;bacd&quot;\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;dcab&quot;, pairs = [[0,3],[1,2],[0,2]]\n<strong>Output:</strong> &quot;abcd&quot;\n<strong>Explaination: </strong>\nSwap s[0] and s[3], s = &quot;bcad&quot;\nSwap s[0] and s[2], s = &quot;acbd&quot;\nSwap s[1] and s[2], s = &quot;abcd&quot;</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;cba&quot;, pairs = [[0,1],[1,2]]\n<strong>Output:</strong> &quot;abc&quot;\n<strong>Explaination: </strong>\nSwap s[0] and s[1], s = &quot;bca&quot;\nSwap s[1] and s[2], s = &quot;bac&quot;\nSwap s[0] and s[1], s = &quot;abc&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10^5</code></li>\n\t<li><code>0 &lt;= pairs.length &lt;= 10^5</code></li>\n\t<li><code>0 &lt;= pairs[i][0], pairs[i][1] &lt;&nbsp;s.length</code></li>\n\t<li><code>s</code>&nbsp;only contains lower case English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 387524,
                "title": "short-python-union-find-solution-w-explanation",
                "content": "The core of the idea is that if (0, 1) is an exchange pair and (0, 2) is an exchange pair, then any 2 in (0, 1, 2) can be exchanged.\\n\\nThis implies, we can build connected components where each component is a list of indices that can be exchanged with any of them. In Union find terms, we simply iterate through each pair, and do a union on the indices in the pair.\\nAt the end of the union of all the pairs, we have built connected component of indices that can be exchanged with each other.\\n \\nThen we build a sorted list of characters for every connected component.\\n \\nThe final step is, we iterate through all the indices, and for each index we locate its component id and find the sorted list correspondng to that component and grab the next lowest character from that list.\\n\\nThis way for every index, we find the lowest possible character that can be exchanged and fitted there.\\n\\n```\\n def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        class UF:\\n            def __init__(self, n): self.p = list(range(n))\\n            def union(self, x, y): self.p[self.find(x)] = self.find(y)\\n            def find(self, x):\\n                if x != self.p[x]: self.p[x] = self.find(self.p[x])\\n                return self.p[x]\\n        uf, res, m = UF(len(s)), [], defaultdict(list)\\n        for x,y in pairs: \\n            uf.union(x,y)\\n        for i in range(len(s)): \\n            m[uf.find(i)].append(s[i])\\n        for comp_id in m.keys(): \\n            m[comp_id].sort(reverse=True)\\n        for i in range(len(s)): \\n            res.append(m[uf.find(i)].pop())\\n        return \\'\\'.join(res)\\n```",
                "solutionTags": [],
                "code": "```\\n def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        class UF:\\n            def __init__(self, n): self.p = list(range(n))\\n            def union(self, x, y): self.p[self.find(x)] = self.find(y)\\n            def find(self, x):\\n                if x != self.p[x]: self.p[x] = self.find(self.p[x])\\n                return self.p[x]\\n        uf, res, m = UF(len(s)), [], defaultdict(list)\\n        for x,y in pairs: \\n            uf.union(x,y)\\n        for i in range(len(s)): \\n            m[uf.find(i)].append(s[i])\\n        for comp_id in m.keys(): \\n            m[comp_id].sort(reverse=True)\\n        for i in range(len(s)): \\n            res.append(m[uf.find(i)].pop())\\n        return \\'\\'.join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 388257,
                "title": "c-with-picture-union-find",
                "content": "# Intuition\\nIf a group of characters is interconnected by swap pairs, you can freely rearrange characters within that group.\\n\\nIn this example, we have two group of interconnected characters, so we can make rearrangements to achieve the smallest string as shown in the picture below.\\n```\\n\"zdcyxbwa\"\\n[[0,3],[4,6],[3,4],[1,7],[2,5],[5,7]]\\n```\\n![image](https://assets.leetcode.com/users/votrubac/image_1569195129.png)\\n# Solution\\nIdentify groups using union-find. For each group, collect all its characters in a string.\\n> Note that in the disjoined set ```ds```, the find operation returns the parent index (```p```). We use that index to identify the group, and put all group characters into ```m[p]```.\\n\\nSort the string, then put the rearranged characters back to their respective positions in the group.\\n```\\nint find(vector<int>& ds, int i) {\\n  return ds[i] < 0 ? i : ds[i] = find(ds, ds[i]);\\n}\\nstring smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n  vector<int> ds(s.size(), -1);\\n  vector<vector<int>> m(s.size());\\n  for (auto& p : pairs) {\\n    auto i = find(ds, p[0]), j = find(ds, p[1]);\\n    if (i != j) \\n        ds[j] = i;\\n  }\\n  for (auto i = 0; i < s.size(); ++i) \\n      m[find(ds, i)].push_back(i);\\n  for (auto &ids : m) {\\n    string ss = \"\";\\n    for (auto id : ids) \\n        ss += s[id];\\n    sort(begin(ss), end(ss));\\n    for (auto i = 0; i < ids.size(); ++i) \\n        s[ids[i]] = ss[i];\\n  }\\n  return s;\\n}\\n```\\n## Disjoint set optimizations\\nNote that, in the ```find``` function, we are using path compression. In other words, we \"flatten\" our hierarchy every time we search, so that elements references the parent index directly: ```ds[i] = find(ds, ds[i]);```. Without path compression, you will get TLE on the last test case. \\n\\nIn addition, we can store the count of elements (negated) in the parent of the group. Then, when merging two groups, we add elements from the smaller group into the larger one. That way, we reduce the number of recursive calls for the ```find``` function to \"flatten\" newly added elements.\\n\\nBelow is the optimized solution (the changes are for ```if (i != j)``` condition). Note that, for this problem, this optimization is not that important (though the runtime went down from 140 to 128 ms for me) since we only have 26 elements. Though, it may help you quite a bit when you deal with larger groups.\\n```\\nint find(vector<int>& ds, int i) {\\n  return ds[i] < 0 ? i : ds[i] = find(ds, ds[i]);\\n}\\nstring smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n  vector<int> ds(s.size(), -1);\\n  vector<vector<int>> m(s.size());\\n  for (auto& p : pairs) {\\n    auto i = find(ds, p[0]), j = find(ds, p[1]);\\n    if (i != j) {\\n        if (-ds[i] < -ds[j]) \\n            swap(i, j);\\n        ds[i] += ds[j];\\n        ds[j] = i;\\n    }\\n  }\\n  for (auto i = 0; i < s.size(); ++i) \\n      m[find(ds, i)].push_back(i);\\n  for (auto &ids : m) {\\n    string ss = \"\";\\n    for (auto id : ids) \\n        ss += s[id];\\n    sort(begin(ss), end(ss));\\n    for (auto i = 0; i < ids.size(); ++i) \\n        s[ids[i]] = ss[i];\\n  }\\n  return s;\\n}\\n```\\n## Complexity Analysis\\n- Runtime: O(n log n)\\n- Memory: O(n)",
                "solutionTags": [],
                "code": "```\\n\"zdcyxbwa\"\\n[[0,3],[4,6],[3,4],[1,7],[2,5],[5,7]]\\n```\n```ds```\n```p```\n```m[p]```\n```\\nint find(vector<int>& ds, int i) {\\n  return ds[i] < 0 ? i : ds[i] = find(ds, ds[i]);\\n}\\nstring smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n  vector<int> ds(s.size(), -1);\\n  vector<vector<int>> m(s.size());\\n  for (auto& p : pairs) {\\n    auto i = find(ds, p[0]), j = find(ds, p[1]);\\n    if (i != j) \\n        ds[j] = i;\\n  }\\n  for (auto i = 0; i < s.size(); ++i) \\n      m[find(ds, i)].push_back(i);\\n  for (auto &ids : m) {\\n    string ss = \"\";\\n    for (auto id : ids) \\n        ss += s[id];\\n    sort(begin(ss), end(ss));\\n    for (auto i = 0; i < ids.size(); ++i) \\n        s[ids[i]] = ss[i];\\n  }\\n  return s;\\n}\\n```\n```find```\n```ds[i] = find(ds, ds[i]);```\n```find```\n```if (i != j)```\n```\\nint find(vector<int>& ds, int i) {\\n  return ds[i] < 0 ? i : ds[i] = find(ds, ds[i]);\\n}\\nstring smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n  vector<int> ds(s.size(), -1);\\n  vector<vector<int>> m(s.size());\\n  for (auto& p : pairs) {\\n    auto i = find(ds, p[0]), j = find(ds, p[1]);\\n    if (i != j) {\\n        if (-ds[i] < -ds[j]) \\n            swap(i, j);\\n        ds[i] += ds[j];\\n        ds[j] = i;\\n    }\\n  }\\n  for (auto i = 0; i < s.size(); ++i) \\n      m[find(ds, i)].push_back(i);\\n  for (auto &ids : m) {\\n    string ss = \"\";\\n    for (auto id : ids) \\n        ss += s[id];\\n    sort(begin(ss), end(ss));\\n    for (auto i = 0; i < ids.size(); ++i) \\n        s[ids[i]] = ss[i];\\n  }\\n  return s;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 388055,
                "title": "java-union-find-priorityqueue-easy-to-understand",
                "content": "Problem abstract: Sort the characters within each connected group.\\n\\n1. For each the given `pairs`, create connected groups using union-find. Always mark the smaller index as parent;\\n2. For each character in `s`, create mapping from `root -> a list of candidate char`. Since we want to use the smallest one every time we pick from them, use `PriorityQueue`.\\n3. Finally, for each index, choose the first char in the associated `pq` and append into result.\\n\\n```Java\\nclass Solution {\\n    private int[] parent;\\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        if (s == null || s.length() == 0) {\\n            return null;\\n        }\\n        parent = new int[s.length()];\\n        for (int i = 0; i < parent.length; i++) {\\n            parent[i] = i;\\n        }\\n        \\n        for (List<Integer> pair : pairs) {\\n            union(pair.get(0), pair.get(1));\\n        }\\n        \\n        Map<Integer, PriorityQueue<Character>> map = new HashMap<>();\\n        char[] sChar = s.toCharArray();\\n        for (int i = 0; i < sChar.length; i++) {\\n            int root = find(i);\\n            map.putIfAbsent(root, new PriorityQueue<>());\\n            map.get(root).offer(sChar[i]);\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < sChar.length; i++) {\\n            sb.append(map.get(find(i)).poll());\\n        }\\n        return sb.toString();\\n    }\\n    private int find(int index) {\\n        while (parent[index] != index) {\\n            parent[index] = parent[parent[index]];\\n            index = parent[index];\\n        }\\n        return index;\\n    }\\n    private void union(int a, int b) {\\n        int aParent = find(a);\\n        int bParent = find(b);\\n        if (aParent < bParent) {\\n            parent[bParent] = aParent;\\n        } else {\\n            parent[aParent] = bParent;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Java\\nclass Solution {\\n    private int[] parent;\\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        if (s == null || s.length() == 0) {\\n            return null;\\n        }\\n        parent = new int[s.length()];\\n        for (int i = 0; i < parent.length; i++) {\\n            parent[i] = i;\\n        }\\n        \\n        for (List<Integer> pair : pairs) {\\n            union(pair.get(0), pair.get(1));\\n        }\\n        \\n        Map<Integer, PriorityQueue<Character>> map = new HashMap<>();\\n        char[] sChar = s.toCharArray();\\n        for (int i = 0; i < sChar.length; i++) {\\n            int root = find(i);\\n            map.putIfAbsent(root, new PriorityQueue<>());\\n            map.get(root).offer(sChar[i]);\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < sChar.length; i++) {\\n            sb.append(map.get(find(i)).poll());\\n        }\\n        return sb.toString();\\n    }\\n    private int find(int index) {\\n        while (parent[index] != index) {\\n            parent[index] = parent[parent[index]];\\n            index = parent[index];\\n        }\\n        return index;\\n    }\\n    private void union(int a, int b) {\\n        int aParent = find(a);\\n        int bParent = find(b);\\n        if (aParent < bParent) {\\n            parent[bParent] = aParent;\\n        } else {\\n            parent[aParent] = bParent;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 387536,
                "title": "c-o-nlogn-simple-dfs-solution",
                "content": "**Observation**\\nWhen there are multiple indices that overlap each other eg: [1,2] and [2,3] we can always get the characters at those indices (1,2,3) at any of the indice we like by swapping in some permutation. \\nThese overlapped indices form our \"connected graph or connected components\" and these belong to one group.\\neg: [2,3],[4,5],[3,6],[2,7] for a string of length 8 we have the following groups:\\n* 0\\n* 1\\n* 2,3,6,7\\n* 4,5\\n\\nWe use this observation to build our solution.\\n\\n**Solution**\\nAll we need to do is get all those groups of indices that can be swapped with each other and sort the string formed by those indices since they can always be replaced/swapped by any other charater in those indices as noted above.\\nRepeat this for all the groups and you get your sorted string.\\n```c++\\nclass Solution {\\npublic:\\n    vector<int> indices;                                                 //Stores indices of same group.\\n    vector<bool> visited;\\n    vector<vector<int>> adjList;\\n    string indiceString;                                                 //Stores  string formed by indices in the same group.\\n    void dfs(string &s,int n)                                             //DFS to get all indices in same group.\\n    {\\n        visited[n]=true;\\n        indices.push_back(n);\\n        indiceString+=s[n];\\n        for(int &i:adjList[n])\\n            if(!visited[i])\\n               dfs(s,i);\\n    }\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) \\n    {\\n        adjList.resize(s.length());\\n        visited.resize(s.length(),false);\\n        for(vector<int> &v:pairs)                               //Create adjacency list using the indice pairs\\n            adjList[v[0]].push_back(v[1]),adjList[v[1]].push_back(v[0]);\\n        for(int i=0;i<s.length();i++)\\n            if(!visited[i])\\n            {\\n                indiceString=\"\";                              //Clear string formed by one group of indices before finding next group.\\n                indices.clear();                             //Clear indices vector before finding another group.\\n                dfs(s,i);\\n                sort(indiceString.begin(),indiceString.end());                    //Sort the characters in the same group.\\n                sort(indices.begin(),indices.end());                                  //Sort the indices in the same group.            \\n                for(int i=0;i<indices.size();i++)          //Replace all the indices in the same group with the sorted characters.\\n                    s[indices[i]]=indiceString[i];\\n            }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    vector<int> indices;                                                 //Stores indices of same group.\\n    vector<bool> visited;\\n    vector<vector<int>> adjList;\\n    string indiceString;                                                 //Stores  string formed by indices in the same group.\\n    void dfs(string &s,int n)                                             //DFS to get all indices in same group.\\n    {\\n        visited[n]=true;\\n        indices.push_back(n);\\n        indiceString+=s[n];\\n        for(int &i:adjList[n])\\n            if(!visited[i])\\n               dfs(s,i);\\n    }\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) \\n    {\\n        adjList.resize(s.length());\\n        visited.resize(s.length(),false);\\n        for(vector<int> &v:pairs)                               //Create adjacency list using the indice pairs\\n            adjList[v[0]].push_back(v[1]),adjList[v[1]].push_back(v[0]);\\n        for(int i=0;i<s.length();i++)\\n            if(!visited[i])\\n            {\\n                indiceString=\"\";                              //Clear string formed by one group of indices before finding next group.\\n                indices.clear();                             //Clear indices vector before finding another group.\\n                dfs(s,i);\\n                sort(indiceString.begin(),indiceString.end());                    //Sort the characters in the same group.\\n                sort(indices.begin(),indices.end());                                  //Sort the indices in the same group.            \\n                for(int i=0;i<indices.size();i++)          //Replace all the indices in the same group with the sorted characters.\\n                    s[indices[i]]=indiceString[i];\\n            }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1985185,
                "title": "python3-union-find-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nThe main idea here is to represent the string as a graph (indexes are nodes and pairs are edges). We can swap characters only if they connected with an edge. Since we can swap chars any amount of time within formed by edges groups, any char in such a group can be placed to any place within the group. That means we can simply sort chars within every group, and resulting string will be the lexicographically smallest one. So we do it in three steps:\\n\\n1. Form groups using Union-Find data structure\\n2. Convert union-find to a hashmap with chars and indexes as values\\n3. Sort chars and indeses for every groups and form the result\\n\\nTime: **O(nlogn)**\\nSpace: **O(n)**\\n\\nRuntime: 749 ms, faster than **82.09%** of Python3 online submissions for Smallest String With Swaps.\\nMemory Usage: 50.3 MB, less than **93.45%** of Python3 online submissions for Smallest String With Swaps.\\n\\n```\\nclass Solution:\\n    def union(self, a, b):\\n        self.parent[self.find(a)] = self.find(b)\\n\\t\\t\\n    def find(self, a):\\n        if self.parent[a] != a:\\n            self.parent[a] = self.find(self.parent[a])\\n\\n        return self.parent[a]\\n        \\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n\\t\\t# 1. Union-Find\\n        self.parent = list(range(len(s)))\\n        for a, b in pairs:\\n            self.union(a, b)\\n\\n\\t\\t# 2. Grouping\\n        group = defaultdict(lambda: ([], []))  \\n        for i, ch in enumerate(s):\\n            parent = self.find(i)\\n            group[parent][0].append(i)\\n            group[parent][1].append(ch)\\n\\n\\t\\t# 3. Sorting\\n        res = [\\'\\'] * len(s)\\n        for ids, chars in group.values():\\n            ids.sort()\\n            chars.sort()\\n            for ch, i in zip(chars, ids):\\n                res[i] = ch\\n                \\n        return \\'\\'.join(res)\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def union(self, a, b):\\n        self.parent[self.find(a)] = self.find(b)\\n\\t\\t\\n    def find(self, a):\\n        if self.parent[a] != a:\\n            self.parent[a] = self.find(self.parent[a])\\n\\n        return self.parent[a]\\n        \\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n\\t\\t# 1. Union-Find\\n        self.parent = list(range(len(s)))\\n        for a, b in pairs:\\n            self.union(a, b)\\n\\n\\t\\t# 2. Grouping\\n        group = defaultdict(lambda: ([], []))  \\n        for i, ch in enumerate(s):\\n            parent = self.find(i)\\n            group[parent][0].append(i)\\n            group[parent][1].append(ch)\\n\\n\\t\\t# 3. Sorting\\n        res = [\\'\\'] * len(s)\\n        for ids, chars in group.values():\\n            ids.sort()\\n            chars.sort()\\n            for ch, i in zip(chars, ids):\\n                res[i] = ch\\n                \\n        return \\'\\'.join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1986381,
                "title": "python-union-find-clean-concise",
                "content": "**Idea**\\n- We use Union-FInd data structure to group indices that are swappable together.\\n- Then sort chars in each group, then write back to the result.\\n```python\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.size = n\\n        self.parent = [i for i in range(n)]\\n        \\n    def find(self, u):\\n        if u != self.parent[u]:\\n            self.parent[u] = self.find(self.parent[u])  # Path compression\\n        return self.parent[u]\\n    \\n    def union(self, u, v):\\n        pu = self.find(u)\\n        pv = self.find(v)\\n        if pu == pv: return False\\n        self.parent[pu] = pv\\n        return True\\n    \\n    def getGroups(self):\\n        groups = defaultdict(list)\\n        for u in range(self.size):\\n            groups[self.find(u)].append(u)\\n        return groups.values()\\n        \\n\\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        n, m = len(s), len(pairs)\\n        uf = UnionFind(n)\\n        for u, v in pairs:\\n            uf.union(u, v)\\n            \\n        groups = uf.getGroups()\\n        res = [\\'-\\'] * n\\n        for group in groups:\\n            chars = [s[i] for i in group]\\n            chars.sort()\\n            group.sort()\\n            for i, c in zip(group, chars):\\n                res[i] = c\\n        return \"\".join(res)\\n```\\n**Complexity**\\n- Time: `O(NlogN + M)`, where `N` is length of string `s`, `M` is number of pairs.\\n- Space: `O(N)`",
                "solutionTags": [],
                "code": "```python\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.size = n\\n        self.parent = [i for i in range(n)]\\n        \\n    def find(self, u):\\n        if u != self.parent[u]:\\n            self.parent[u] = self.find(self.parent[u])  # Path compression\\n        return self.parent[u]\\n    \\n    def union(self, u, v):\\n        pu = self.find(u)\\n        pv = self.find(v)\\n        if pu == pv: return False\\n        self.parent[pu] = pv\\n        return True\\n    \\n    def getGroups(self):\\n        groups = defaultdict(list)\\n        for u in range(self.size):\\n            groups[self.find(u)].append(u)\\n        return groups.values()\\n        \\n\\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        n, m = len(s), len(pairs)\\n        uf = UnionFind(n)\\n        for u, v in pairs:\\n            uf.union(u, v)\\n            \\n        groups = uf.getGroups()\\n        res = [\\'-\\'] * n\\n        for group in groups:\\n            chars = [s[i] for i in group]\\n            chars.sort()\\n            group.sort()\\n            for i, c in zip(group, chars):\\n                res[i] = c\\n        return \"\".join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 387534,
                "title": "union-find-java-sol",
                "content": "Starting there are N separate items.\\nIf we union the swap pairs, we end up with a set of disjoint indexes representing separate graphs.\\nFor every character index, find the graph the character belongs to (Using parent operation) & find the smallest permutation for every graph.\\n\\n-> Extract separate graphs, mapping the characters and there vertices.\\n-> Sort the characters in ascending order within each graph.\\n-> Put the characters in correct position after populating the output,  by taking the characters from the graph.\\n\\n\\n\\n```\\n private class UnionFind {\\n\\n        public int[] size;\\n        public int[] parent;\\n\\n        UnionFind(int count) {\\n            size = new int[count];\\n            parent = new int[count];\\n            for (int i = 0; i < count; i++) {\\n                size[i] = 1;\\n                parent[i] = i;\\n            }\\n        }\\n\\n        int find(int p) {\\n            while (p != parent[p]) {\\n                parent[p] = parent[parent[p]];\\n                p = parent[p];\\n            }\\n            return p;\\n        }\\n\\n        int union(int p, int q) {\\n            int pRoot = find(p);\\n            int qRoot = find(q);\\n            if (pRoot == qRoot) {\\n                return size[pRoot];\\n            }\\n            if (size[pRoot] > size[qRoot]) {\\n                parent[qRoot] = pRoot;\\n                size[pRoot] += size[qRoot];\\n                return size[pRoot];\\n            } else {\\n                parent[pRoot] = qRoot;\\n                size[qRoot] += size[pRoot];\\n                return size[qRoot];\\n            }\\n\\n        }\\n    }\\n\\n    public String smallestStringWithSwaps(String s, List<List<Integer>> swaps) {\\n        int N = s.length();\\n\\n        UnionFind uf = new UnionFind(N);\\n        for (List<Integer> swap : swaps) {\\n            uf.union(swap.get(0), swap.get(1));\\n        }\\n\\n\\n        Map<Integer, List<Character>> graphs = new HashMap<>();\\n        for (int i = 0; i < N; i++) {\\n            int head = uf.find(i);\\n            List<Character> characters = graphs.computeIfAbsent(head, (dummy) -> new ArrayList<>());\\n            characters.add(s.charAt(i));\\n        }\\n\\n        for (List<Character> characters : graphs.values()) {\\n            Collections.sort(characters);\\n        }\\n\\n        StringBuilder sb = new StringBuilder(N);\\n        for (int i = 0; i < N; i++) {\\n            List<Character> characters = graphs.get(uf.find(i));\\n            char currentMin = characters.remove(0);\\n            sb.append(currentMin);\\n        }\\n        return sb.toString();\\n\\n\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n private class UnionFind {\\n\\n        public int[] size;\\n        public int[] parent;\\n\\n        UnionFind(int count) {\\n            size = new int[count];\\n            parent = new int[count];\\n            for (int i = 0; i < count; i++) {\\n                size[i] = 1;\\n                parent[i] = i;\\n            }\\n        }\\n\\n        int find(int p) {\\n            while (p != parent[p]) {\\n                parent[p] = parent[parent[p]];\\n                p = parent[p];\\n            }\\n            return p;\\n        }\\n\\n        int union(int p, int q) {\\n            int pRoot = find(p);\\n            int qRoot = find(q);\\n            if (pRoot == qRoot) {\\n                return size[pRoot];\\n            }\\n            if (size[pRoot] > size[qRoot]) {\\n                parent[qRoot] = pRoot;\\n                size[pRoot] += size[qRoot];\\n                return size[pRoot];\\n            } else {\\n                parent[pRoot] = qRoot;\\n                size[qRoot] += size[pRoot];\\n                return size[qRoot];\\n            }\\n\\n        }\\n    }\\n\\n    public String smallestStringWithSwaps(String s, List<List<Integer>> swaps) {\\n        int N = s.length();\\n\\n        UnionFind uf = new UnionFind(N);\\n        for (List<Integer> swap : swaps) {\\n            uf.union(swap.get(0), swap.get(1));\\n        }\\n\\n\\n        Map<Integer, List<Character>> graphs = new HashMap<>();\\n        for (int i = 0; i < N; i++) {\\n            int head = uf.find(i);\\n            List<Character> characters = graphs.computeIfAbsent(head, (dummy) -> new ArrayList<>());\\n            characters.add(s.charAt(i));\\n        }\\n\\n        for (List<Character> characters : graphs.values()) {\\n            Collections.sort(characters);\\n        }\\n\\n        StringBuilder sb = new StringBuilder(N);\\n        for (int i = 0; i < N; i++) {\\n            List<Character> characters = graphs.get(uf.find(i));\\n            char currentMin = characters.remove(0);\\n            sb.append(currentMin);\\n        }\\n        return sb.toString();\\n\\n\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 405917,
                "title": "disjoint-set-solution-in-c",
                "content": "Commented well.\\n\\n```\\nclass Solution {\\nprivate:\\n    /*\\n     * Find the subset a vertex belongs to.\\n     */\\n    int find(vector<int> &ss, int x) {\\n        if (ss[x] == -1) return x;\\n        return ss[x] = find(ss, ss[x]);\\n    }\\n    \\n    /*\\n     * Unionize two subsets. \\n     */\\n    void _union(vector<int> &ss, int x, int y) {\\n        int xp = find(ss, x);\\n        int yp = find(ss, y);\\n        if (xp != yp) ss[yp] = xp;\\n    }\\n\\npublic:\\n    \\n    /* We use disjoint set (or Union-Find) to form subsets */\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        \\n        /* \\n         * Treat index of string s as vertex. Create parent subsets \\n         * and initialize them to -1 - this means the subsets don\\'t\\n         * have parent info yet.\\n         */\\n        vector<int> ss;\\n        for (int i = 0; i < s.size(); i++) ss.push_back(-1);\\n        \\n        /*\\n         * Go through each pair one by one. Find the subsets\\n         * that the vertices of the pair belong to. If they \\n         * are different, unionize them.\\n         */\\n        for (int i = 0; i < pairs.size(); ++i) {\\n            int x = find(ss, pairs[i][0]), y = find(ss, pairs[i][1]);            \\n            if (x != y) _union(ss, x, y);\\n        }\\n        \\n        /* Create separate vectors from the subsets */\\n        unordered_map<int, vector<int>> m;\\n        for (int i = 0; i < s.size(); i++) m[find(ss, i)].push_back(i);\\n        \\n        /* Sort the vertices in each vector and change the original \\n         * array based on the sorted results \\n         */\\n        for (auto x : m) {\\n            string str = \"\"; int j = 0;\\n            for (auto i : x.second) { str += s[i]; }\\n            sort(str.begin(), str.end());\\n            for (auto i : x.second) { s[i] = str[j++]; }\\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    /*\\n     * Find the subset a vertex belongs to.\\n     */\\n    int find(vector<int> &ss, int x) {\\n        if (ss[x] == -1) return x;\\n        return ss[x] = find(ss, ss[x]);\\n    }\\n    \\n    /*\\n     * Unionize two subsets. \\n     */\\n    void _union(vector<int> &ss, int x, int y) {\\n        int xp = find(ss, x);\\n        int yp = find(ss, y);\\n        if (xp != yp) ss[yp] = xp;\\n    }\\n\\npublic:\\n    \\n    /* We use disjoint set (or Union-Find) to form subsets */\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        \\n        /* \\n         * Treat index of string s as vertex. Create parent subsets \\n         * and initialize them to -1 - this means the subsets don\\'t\\n         * have parent info yet.\\n         */\\n        vector<int> ss;\\n        for (int i = 0; i < s.size(); i++) ss.push_back(-1);\\n        \\n        /*\\n         * Go through each pair one by one. Find the subsets\\n         * that the vertices of the pair belong to. If they \\n         * are different, unionize them.\\n         */\\n        for (int i = 0; i < pairs.size(); ++i) {\\n            int x = find(ss, pairs[i][0]), y = find(ss, pairs[i][1]);            \\n            if (x != y) _union(ss, x, y);\\n        }\\n        \\n        /* Create separate vectors from the subsets */\\n        unordered_map<int, vector<int>> m;\\n        for (int i = 0; i < s.size(); i++) m[find(ss, i)].push_back(i);\\n        \\n        /* Sort the vertices in each vector and change the original \\n         * array based on the sorted results \\n         */\\n        for (auto x : m) {\\n            string str = \"\"; int j = 0;\\n            for (auto i : x.second) { str += s[i]; }\\n            sort(str.begin(), str.end());\\n            for (auto i : x.second) { s[i] = str[j++]; }\\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 387589,
                "title": "simple-python-dfs-solution-with-explanation",
                "content": "Use standard DFS to find the connected components.\\nIn each component, sort the indices and characters, assign the characters to the indices.\\n\\n```\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        def dfs(i):\\n            visited[i] = True\\n            component.append(i)\\n            for j in adj_lst[i]:\\n                if not visited[j]:\\n                    dfs(j)\\n            \\n        n = len(s)\\n        adj_lst = [[] for _ in range(n)]\\n        for i, j in pairs:\\n            adj_lst[i].append(j)\\n            adj_lst[j].append(i)\\n        visited = [False for _ in range(n)]\\n        lst = list(s)\\n        for i in range(n):\\n            if not visited[i]:\\n                component = []\\n                dfs(i)\\n                component.sort()\\n                chars = [lst[k] for k in component]\\n                chars.sort()\\n                for i in range(len(component)):\\n                    lst[component[i]] = chars[i]\\n        return \\'\\'.join(lst)\\n```\\nLet n = len(s), m = len(pairs), \\nspace complexity: O(n)\\ntime complexity: dfs O(n+m), sort: O(n log n).",
                "solutionTags": [],
                "code": "```\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        def dfs(i):\\n            visited[i] = True\\n            component.append(i)\\n            for j in adj_lst[i]:\\n                if not visited[j]:\\n                    dfs(j)\\n            \\n        n = len(s)\\n        adj_lst = [[] for _ in range(n)]\\n        for i, j in pairs:\\n            adj_lst[i].append(j)\\n            adj_lst[j].append(i)\\n        visited = [False for _ in range(n)]\\n        lst = list(s)\\n        for i in range(n):\\n            if not visited[i]:\\n                component = []\\n                dfs(i)\\n                component.sort()\\n                chars = [lst[k] for k in component]\\n                chars.sort()\\n                for i in range(len(component)):\\n                    lst[component[i]] = chars[i]\\n        return \\'\\'.join(lst)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1199922,
                "title": "simple-c-solution-full-concept-explained-with-code",
                "content": "**We just need to group all pairs using DSU. And after grouping them together we will have connected componend (pairs) together. Which means we have to sort each connected component because we need smallest lexical string. **\\n\\n***Suppose The Input Is ***\\ns = \"dcab\", pairs = [[0,3],[1,2]]\\n\\nThen 0---3 is forming one group let\\'s say 0 \\n1--2 is forming one group let\\'s say 1 \\n\\n**So,  we have two connected component**\\nindex->      0  1 2 3\\n Now         \"d c a b\"   sort the connected component i.e indexes sort(0,3) and (1,2) \\n                 \"b c a d\"   (0,3 sorted)\\n\\t\\t\\t\\t \"b a c d\"   (1,3 sorted)\\n\\t\\t\\t\\t \\n\\t\\t\\t\\t \"b a c d\"   (answer)\\n\\n***Suppose The Input Is \\ns = \"dcab\", pairs = [[0,3],[1,2],[0,2]]\\t***\\n\\nThen 0---3 is forming one group let\\'s say 0 \\n1--2 is forming one group let\\'s say 1\\nagain 0--2 is forming group since 0 and 2 was already in group , hence everyone is under same group (DSU)\\n**0-1-2-3 is under same group . Hence we have only 1 connected component **. \\n\\n**So,  we have one connected component**\\nindex->      0  1 2 3\\n Now         \"d c a b\"   sort the connected component i.e sort indexes (0,1,2,3)\\n                  \"a b c d\"  sorted (0,1,2,3)\\n\\t\\t\\t\\t  \\t\\t\\t\\t  \\n\\t\\t\\t\\t  \"a b c d\" (answer)\\n\\t\\t\\t\\t \\n\\t\\t\\t   \\n```\\nclass Solution {\\n    vector<int>parent; \\npublic:\\n    \\n    int findParent(int n){\\n        if(parent[n]==n){\\n            return n; \\n        }\\n        return parent[n] = findParent(parent[n]); \\n    }\\n    \\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        \\n        parent.resize(s.length());\\n        map<int , set<int>>obj;\\n        set<int>idx;\\n        string ans=s;\\n        \\n        \\n        for(int i=0; i<parent.size(); i++){\\n            parent[i]=i;\\n        }\\n        \\n        for(int i=0; i<pairs.size(); i++){\\n            int u = pairs[i][0];\\n            int v = pairs[i][1];\\n            int fx = findParent(u);\\n            int fy = findParent(v);\\n            \\n            if(fx!=fy){\\n                parent[fy]=fx; \\n            }\\n                 \\n        }\\n        for(int i=0; i<pairs.size(); i++){\\n            \\n            int u = pairs[i][0];\\n            int v = pairs[i][1];\\n            \\n            int fx = findParent(u);\\n            obj[fx].insert(u);\\n            obj[fx].insert(v);\\n              \\n        }\\n        \\n        for(auto it = obj.begin(); it!=obj.end(); it++){\\n            \\n            idx = it->second;\\n            vector<pair<char,int>>t; \\n            auto index=idx.begin(); \\n            \\n            for(index=idx.begin(); index!=idx.end(); index++){\\n                 \\n                 int pos = *index;\\n                 char ch = s[pos]; \\n                 t.push_back({ch,pos}); \\n            }\\n            \\n            sort(t.begin() , t.end()); \\n            index=idx.begin(); \\n            \\n            for(int i=0; i<t.size(); i++){ \\n                 \\n                ans[*index] = t[i].first;\\n                index++; \\n            } \\n        \\n        }\\n       \\n        return ans;\\n    }\\n};\\n```\\n                     \\n\\t\\t\\t\\t\\t                            \"Do Upvote If You Liked The Solution\"",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    vector<int>parent; \\npublic:\\n    \\n    int findParent(int n){\\n        if(parent[n]==n){\\n            return n; \\n        }\\n        return parent[n] = findParent(parent[n]); \\n    }\\n    \\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        \\n        parent.resize(s.length());\\n        map<int , set<int>>obj;\\n        set<int>idx;\\n        string ans=s;\\n        \\n        \\n        for(int i=0; i<parent.size(); i++){\\n            parent[i]=i;\\n        }\\n        \\n        for(int i=0; i<pairs.size(); i++){\\n            int u = pairs[i][0];\\n            int v = pairs[i][1];\\n            int fx = findParent(u);\\n            int fy = findParent(v);\\n            \\n            if(fx!=fy){\\n                parent[fy]=fx; \\n            }\\n                 \\n        }\\n        for(int i=0; i<pairs.size(); i++){\\n            \\n            int u = pairs[i][0];\\n            int v = pairs[i][1];\\n            \\n            int fx = findParent(u);\\n            obj[fx].insert(u);\\n            obj[fx].insert(v);\\n              \\n        }\\n        \\n        for(auto it = obj.begin(); it!=obj.end(); it++){\\n            \\n            idx = it->second;\\n            vector<pair<char,int>>t; \\n            auto index=idx.begin(); \\n            \\n            for(index=idx.begin(); index!=idx.end(); index++){\\n                 \\n                 int pos = *index;\\n                 char ch = s[pos]; \\n                 t.push_back({ch,pos}); \\n            }\\n            \\n            sort(t.begin() , t.end()); \\n            index=idx.begin(); \\n            \\n            for(int i=0; i<t.size(); i++){ \\n                 \\n                ans[*index] = t[i].first;\\n                index++; \\n            } \\n        \\n        }\\n       \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1985907,
                "title": "c-graph-connected-components-with-pictures",
                "content": "consider each char **position** in string as a **vertex** ,\\nand **pairs** as **edges** of  the **graph**\\n\\n**1**. Built the graph from  char positions (as vertices) and pairs (as edges)\\n**2**. Find all Connected Components\\n**3**. **Sort chars among connected components** and merge to create final output string\\n(why because, if u closely look at the connected components, pairs exists such way that **there exists a set of swaps** using pairs **for swapping any 2 chars** on the component, **so we can just sort all chars among the connected**  for getting the  lexicographically smaller one)\\n\\n![image](https://assets.leetcode.com/users/images/d0e9e0c0-5a7c-493b-8d94-7d22817eb6e7_1651046245.238913.png)\\n\\n\\n```\\nstring smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        int V = s.size();\\n        vector<vector<int>> graph(V);\\n        for(auto p: pairs) {\\n            graph[p[0]].push_back(p[1]);\\n            graph[p[1]].push_back(p[0]);\\n        }\\n        vector<bool> visit(V, false);\\n        vector<vector<int>> ConnCombs;\\n\\t\\t/*finding connected componets*/\\n        for(int u = 0; u < V; ++u) {\\n            if(visit[u] == false) {\\n                vector<int> comb = getConnComb(graph, visit, u);\\n                ConnCombs.push_back(comb);\\n            }\\n        }\\n        /*Building output string from Computed connected components*/\\n        string output(s.size(),\\' \\');\\n        for(auto &combPos: ConnCombs) {\\n            vector<char> combChars;\\n            for(auto pos: combPos) {\\n                combChars.push_back(s[pos]);\\n            }\\n            sort(combPos.begin(), combPos.end());\\n            sort(combChars.begin(), combChars.end());\\n            for(int i = 0; i < combPos.size(); ++i) {\\n                output[combPos[i]] = combChars[i];\\n            }\\n        }\\n        ////\\n        return output;\\n     }\\n```\\n```\\n/*DFS using stack to find connected vertices in the graph*/\\nvector<int> getConnComb(vector<vector<int>>& graph, vector<bool>& visit, int u) {\\n         vector<int> cmb;\\n         stack<int> S;\\n         S.push(u);\\n         visit[u] = true;\\n         cmb.push_back(u);\\n         while(!S.empty()) {\\n             int uu = S.top();\\n             S.pop();\\n             for(auto v: graph[uu]) {\\n                 if(visit[v] == false) {\\n                     visit[v] = true;\\n                     S.push(v);\\n                     cmb.push_back(v);\\n                 }\\n             }\\n         }\\n         return cmb;\\n     }\\n```\\nComplexity\\n* Time  : **O(NlogN + M)**, where N is length of string s, M is number of pairs.\\n* Space   : **O(N + M)**\\nOR\\n* Time  : **O(VlogV + E)**, where V is number of vertices, E is number of edges.\\n* Space   : **O(V + E)**\\n\\n**Upvote if u liked :)**\\n",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph",
                    "Strongly Connected Component"
                ],
                "code": "```\\nstring smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        int V = s.size();\\n        vector<vector<int>> graph(V);\\n        for(auto p: pairs) {\\n            graph[p[0]].push_back(p[1]);\\n            graph[p[1]].push_back(p[0]);\\n        }\\n        vector<bool> visit(V, false);\\n        vector<vector<int>> ConnCombs;\\n\\t\\t/*finding connected componets*/\\n        for(int u = 0; u < V; ++u) {\\n            if(visit[u] == false) {\\n                vector<int> comb = getConnComb(graph, visit, u);\\n                ConnCombs.push_back(comb);\\n            }\\n        }\\n        /*Building output string from Computed connected components*/\\n        string output(s.size(),\\' \\');\\n        for(auto &combPos: ConnCombs) {\\n            vector<char> combChars;\\n            for(auto pos: combPos) {\\n                combChars.push_back(s[pos]);\\n            }\\n            sort(combPos.begin(), combPos.end());\\n            sort(combChars.begin(), combChars.end());\\n            for(int i = 0; i < combPos.size(); ++i) {\\n                output[combPos[i]] = combChars[i];\\n            }\\n        }\\n        ////\\n        return output;\\n     }\\n```\n```\\n/*DFS using stack to find connected vertices in the graph*/\\nvector<int> getConnComb(vector<vector<int>>& graph, vector<bool>& visit, int u) {\\n         vector<int> cmb;\\n         stack<int> S;\\n         S.push(u);\\n         visit[u] = true;\\n         cmb.push_back(u);\\n         while(!S.empty()) {\\n             int uu = S.top();\\n             S.pop();\\n             for(auto v: graph[uu]) {\\n                 if(visit[v] == false) {\\n                     visit[v] = true;\\n                     S.push(v);\\n                     cmb.push_back(v);\\n                 }\\n             }\\n         }\\n         return cmb;\\n     }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1452514,
                "title": "python3-explained",
                "content": "```\\nclass UnionFind:\\n    def __init__(self, size):\\n        self.root = [i for i in range(size)]\\n        self.rank = [1] * size\\n    def find(self, x):\\n        if x == self.root[x]:\\n            return x\\n        self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n    def union(self, x, y):\\n        rootX = self.find(x)\\n        rootY = self.find(y)\\n        if rootX != rootY:\\n            if self.rank[rootX] > self.rank[rootY]:\\n                self.root[rootY] = rootX\\n            elif self.rank[rootX] < self.rank[rootY]:\\n                self.root[rootX] = rootY\\n            else:\\n                self.root[rootY] = rootX\\n                self.rank[rootX] += 1\\n    def connected(self, x, y):\\n        return self.find(x) == self.find(y)\\n\\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]):\\n        N=len(s)\\n        DSU=UnionFind(N)\\n        for x,y in pairs:\\n            DSU.union(x,y)\\n        parent=[DSU.find(i) for i in range(N)]\\n        dict=defaultdict(deque)\\n        for i in range(N):\\n            dict[parent[i]].append(s[i])\\n        for key in dict:\\n            dict[key]=deque(sorted(dict[key]))\\n        ans=\"\"\\n        for i in range(N):\\n            dict_key=parent[i]\\n            ans+=dict[dict_key].popleft()\\n        return ans\\n    \"\"\"\\n    hint---->any number of times.\\n    from these words we conclude that we can swap any numbers of time\\n \\xA0 \\xA0so we will form union fromeach pair in \\xA0pairs.\\n \\xA0 \\xA0eg. s = \"dcab\", pairs = [[0,3],[1,2]]\\n \\xA0 \\xA0there will be two union .\\n \\xA0 0:[0,3]\\n    1:[1,2]\\n \\xA0 \\xA0so in one union we can swap any number of times,we will make unions using union-find .\\n    after union operation,parent array will look like this [0,1,1,0]\\n    after each union is formed we will make dictionary  where value will \\n    store character values of indexes in every union [here there are two union with parent 0 and 1] and parent as keys.\\n    i have used dictionary of deque which i will explain below.\\n    from above example\\n    0:[d,b]  0->d ,3->b\\n    1:[c,a]  1->c,2->a\\n    after this we will sort each value in dictionary\\n    0:[b,d]\\n    1:[c,a]\\n    the reason of using deque is that after we iterate through parent array we have to get\\n    the first char in each values in dictionary of perticular union,so every time i will pop from\\n    left,which is also minimum of that group.\\n    \"\"\"\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass UnionFind:\\n    def __init__(self, size):\\n        self.root = [i for i in range(size)]\\n        self.rank = [1] * size\\n    def find(self, x):\\n        if x == self.root[x]:\\n            return x\\n        self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n    def union(self, x, y):\\n        rootX = self.find(x)\\n        rootY = self.find(y)\\n        if rootX != rootY:\\n            if self.rank[rootX] > self.rank[rootY]:\\n                self.root[rootY] = rootX\\n            elif self.rank[rootX] < self.rank[rootY]:\\n                self.root[rootX] = rootY\\n            else:\\n                self.root[rootY] = rootX\\n                self.rank[rootX] += 1\\n    def connected(self, x, y):\\n        return self.find(x) == self.find(y)\\n\\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]):\\n        N=len(s)\\n        DSU=UnionFind(N)\\n        for x,y in pairs:\\n            DSU.union(x,y)\\n        parent=[DSU.find(i) for i in range(N)]\\n        dict=defaultdict(deque)\\n        for i in range(N):\\n            dict[parent[i]].append(s[i])\\n        for key in dict:\\n            dict[key]=deque(sorted(dict[key]))\\n        ans=\"\"\\n        for i in range(N):\\n            dict_key=parent[i]\\n            ans+=dict[dict_key].popleft()\\n        return ans\\n    \"\"\"\\n    hint---->any number of times.\\n    from these words we conclude that we can swap any numbers of time\\n \\xA0 \\xA0so we will form union fromeach pair in \\xA0pairs.\\n \\xA0 \\xA0eg. s = \"dcab\", pairs = [[0,3],[1,2]]\\n \\xA0 \\xA0there will be two union .\\n \\xA0 0:[0,3]\\n    1:[1,2]\\n \\xA0 \\xA0so in one union we can swap any number of times,we will make unions using union-find .\\n    after union operation,parent array will look like this [0,1,1,0]\\n    after each union is formed we will make dictionary  where value will \\n    store character values of indexes in every union [here there are two union with parent 0 and 1] and parent as keys.\\n    i have used dictionary of deque which i will explain below.\\n    from above example\\n    0:[d,b]  0->d ,3->b\\n    1:[c,a]  1->c,2->a\\n    after this we will sort each value in dictionary\\n    0:[b,d]\\n    1:[c,a]\\n    the reason of using deque is that after we iterate through parent array we have to get\\n    the first char in each values in dictionary of perticular union,so every time i will pop from\\n    left,which is also minimum of that group.\\n    \"\"\"\\n",
                "codeTag": "Java"
            },
            {
                "id": 753004,
                "title": "clean-python-dfs-o-n-log-n",
                "content": "**Clean Python DFS | O( n log n )**\\n\\nThe code below presents a clean Python DFS solution for this problem. The algorithm works as follows:\\n\\n1. The initial idea is that each pair of swappable letters in \"pairs\" can be treated as an edge in a (undirected) graph. This works because, in the limit case, we could do bubble sort across connected letters.\\n\\n2. We then go one step further and treat each index s[i] as a node, and convert the array \"pairs\" into a dictionary \"d\" of connected nodes.\\n\\n3. While our dictionary \"d\" has entries, we choose one element in \"d\" and visit all connected nodes, returning a list of detected points. We sort this list, and place the results back in our final string/array. Since each node can only be visited once, this process has a linear time complexity of O(E), where E is the number of edges in our graph ( E = len(pairs) ).\\n\\n4. Once all nodes have been visited, we exit our function and return the final string, with all its connected sections sorted .\\n\\nI hope the explanation was helpful. The code below achieves a top Speed rating.\\n\\nCheers,\\n\\n```\\nclass Solution:\\n    def smallestStringWithSwaps(self, s, pairs):\\n        d = defaultdict(list)\\n        for a,b in pairs:\\n            d[a].append(b)\\n            d[b].append(a)\\n        #\\n        def dfs(x,A):\\n            if x in d:\\n                A.append(x)\\n                for y in d.pop(x):\\n                    dfs(y,A)\\n        #\\n        s    = list(s)\\n        while d:\\n            x = next(iter(d))\\n            A = []\\n            dfs(x,A)\\n            A = sorted(A)\\n            B = sorted([ s[i] for i in A ])\\n            for i,b in enumerate(B):\\n                s[A[i]] = b\\n        return \\'\\'.join(s)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallestStringWithSwaps(self, s, pairs):\\n        d = defaultdict(list)\\n        for a,b in pairs:\\n            d[a].append(b)\\n            d[b].append(a)\\n        #\\n        def dfs(x,A):\\n            if x in d:\\n                A.append(x)\\n                for y in d.pop(x):\\n                    dfs(y,A)\\n        #\\n        s    = list(s)\\n        while d:\\n            x = next(iter(d))\\n            A = []\\n            dfs(x,A)\\n            A = sorted(A)\\n            B = sorted([ s[i] for i in A ])\\n            for i,b in enumerate(B):\\n                s[A[i]] = b\\n        return \\'\\'.join(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1985307,
                "title": "cpp-solution-dfs-code-with-explanation",
                "content": "**Problem Statment**\\nWe have a string of lowercase English letters and some pairs of the form (a, b) where a and b are indices in the string. Our goal is to find the lexicographically smallest string by swapping the characters at indices a and b. There is no restriction on the maximum number of swaps.\\n\\n**Solution Logic**\\n\\nWe will create the adjacency list using the pairs given.\\nEX.-- for each pair (x, y) we will add an edge from x to y and from y to x. Then we will iterate over the indices from 0 to n-1 where n is the length of the given string s. For each index, if it has not been visited yet, we will perform a DFS and store the vertices (index) and the characters at these indices in a list. Each list will represent a different component in the graph. Then we will sort each list of indices and each list of characters and place the i th  character at the i th index in the string smallestString.\\n\\n```\\nclass Solution {\\npublic:\\n    static const int N = 100001;\\n    vector<int> vec[N];\\n    bool checked[N];\\n    \\n    void DFS(string& s, int vertex, vector<char>& characters, vector<int>& indices) {\\n        //Adding the character and index \\n        characters.push_back(s[vertex]);\\n        indices.push_back(vertex);\\n        \\n        checked[vertex] = true;\\n        \\n        for (int itr : vec[vertex]) {\\n            if (!checked[itr]) {\\n                DFS(s, itr, characters, indices);\\n            }\\n        }\\n    }\\n    \\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        // creating vecacency list\\n        for (vector<int> edge : pairs) {\\n            int source = edge[0];\\n            int destination = edge[1];\\n            \\n            vec[source].push_back(destination);\\n            vec[destination].push_back(source);\\n        }\\n        \\n        for (int vertex = 0; vertex < s.size(); vertex++) {\\n            // If not covered in the DFS\\n            if (!checked[vertex]) {\\n                vector<char> characters;\\n                vector<int> indices;\\n                \\n                DFS(s, vertex, characters, indices);\\n                // Sort\\n                sort(characters.begin(), characters.end());\\n                sort(indices.begin(), indices.end());\\n\\n                // storing the sorted character\\n                for (int index = 0; index < characters.size(); index++) {\\n                    s[indices[index]] = characters[index];\\n                }\\n            }\\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static const int N = 100001;\\n    vector<int> vec[N];\\n    bool checked[N];\\n    \\n    void DFS(string& s, int vertex, vector<char>& characters, vector<int>& indices) {\\n        //Adding the character and index \\n        characters.push_back(s[vertex]);\\n        indices.push_back(vertex);\\n        \\n        checked[vertex] = true;\\n        \\n        for (int itr : vec[vertex]) {\\n            if (!checked[itr]) {\\n                DFS(s, itr, characters, indices);\\n            }\\n        }\\n    }\\n    \\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        // creating vecacency list\\n        for (vector<int> edge : pairs) {\\n            int source = edge[0];\\n            int destination = edge[1];\\n            \\n            vec[source].push_back(destination);\\n            vec[destination].push_back(source);\\n        }\\n        \\n        for (int vertex = 0; vertex < s.size(); vertex++) {\\n            // If not covered in the DFS\\n            if (!checked[vertex]) {\\n                vector<char> characters;\\n                vector<int> indices;\\n                \\n                DFS(s, vertex, characters, indices);\\n                // Sort\\n                sort(characters.begin(), characters.end());\\n                sort(indices.begin(), indices.end());\\n\\n                // storing the sorted character\\n                for (int index = 0; index < characters.size(); index++) {\\n                    s[indices[index]] = characters[index];\\n                }\\n            }\\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 718207,
                "title": "java-unionfind-and-priorityqueue-hard",
                "content": "This should be a hard problem\\n```\\nclass Solution {\\n    int n, p[];\\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        n = s.length();\\n        p = new int[n];\\n        Map<Integer, PriorityQueue<Character>> map = new HashMap<>();\\n        for (int i = 0; i < n; i++) p[i] = i;\\n        for (List<Integer> l : pairs) {\\n            union(l.get(0), l.get(1));\\n        }\\n        for (int i = 0; i < n; i++) {\\n            map.computeIfAbsent(find(i), k -> new PriorityQueue<>((a, b) -> a - b));\\n            map.get(p[i]).offer(s.charAt(i));\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < n; i++) {\\n            sb.append(map.get(p[i]).poll());\\n        }\\n        return sb.toString();\\n    }\\n    \\n    private int find(int i) {\\n        if (i != p[i]) p[i] = find(p[i]);\\n        return p[i];\\n    }\\n    \\n    private void union(int i, int j) {\\n        int pi = find(i), pj = find(j);\\n        if (pi > pj) {\\n            p[pi] = pj;  // p[pi] other than p[i];\\n        } else {\\n            p[pj] = pi;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int n, p[];\\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        n = s.length();\\n        p = new int[n];\\n        Map<Integer, PriorityQueue<Character>> map = new HashMap<>();\\n        for (int i = 0; i < n; i++) p[i] = i;\\n        for (List<Integer> l : pairs) {\\n            union(l.get(0), l.get(1));\\n        }\\n        for (int i = 0; i < n; i++) {\\n            map.computeIfAbsent(find(i), k -> new PriorityQueue<>((a, b) -> a - b));\\n            map.get(p[i]).offer(s.charAt(i));\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < n; i++) {\\n            sb.append(map.get(p[i]).poll());\\n        }\\n        return sb.toString();\\n    }\\n    \\n    private int find(int i) {\\n        if (i != p[i]) p[i] = find(p[i]);\\n        return p[i];\\n    }\\n    \\n    private void union(int i, int j) {\\n        int pi = find(i), pj = find(j);\\n        if (pi > pj) {\\n            p[pi] = pj;  // p[pi] other than p[i];\\n        } else {\\n            p[pj] = pi;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1985216,
                "title": "c-super-janky-dfs-group-sets-sort-put-back-together",
                "content": "1) Built an adjcency list\\n2) dfs to connect all the pairs into their sets\\n3) sorted every set of strings\\n4) put back together a string from the sorted sets\\n\\n**mega janky implementation.  Watch me solve it live on stream 6pm PT.  Link in my profile.**\\n\\n```\\nclass Solution {\\n    \\npublic:\\n    void dfs(vector<vector<int>>& adjList, int x, unordered_set<int>& seen, vector<string>& sets, int seti, unordered_map<int, int>& parentSet, string& s) {\\n        if(seen.find(x) != seen.end()) return;\\n        seen.insert(x);\\n        sets[seti].push_back(s[x]);\\n        parentSet[x] = seti;\\n        auto& children = adjList[x];\\n        for(auto child : children) {\\n            dfs(adjList, child, seen, sets, seti, parentSet, s);\\n        }\\n    }\\n    \\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        int n = s.length();\\n        vector<vector<int>> adjList(n);\\n        \\n        for(auto& pair : pairs) {\\n            adjList[pair[0]].push_back(pair[1]);\\n            adjList[pair[1]].push_back(pair[0]);\\n        }\\n        \\n        unordered_set<int> seen;\\n        vector<string> sets;\\n        unordered_map<int, int> parentSet;\\n        int seti = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(seen.find(i) == seen.end()) {\\n                string newSet = \"\";\\n                sets.push_back(newSet);\\n                dfs(adjList, i, seen, sets, seti, parentSet, s);\\n                seti++;\\n            }\\n        }\\n        int setSize = sets.size();\\n        \\n        vector<int> its(setSize);\\n        for(auto& thing : sets) {\\n            sort(thing.begin(), thing.end());\\n        }\\n        for(int i = 0; i < n; i++) {\\n            int j = parentSet[i];      \\n            s[i]  = sets[j][its[j]++];  \\n        }\\n\\n        return s;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\npublic:\\n    void dfs(vector<vector<int>>& adjList, int x, unordered_set<int>& seen, vector<string>& sets, int seti, unordered_map<int, int>& parentSet, string& s) {\\n        if(seen.find(x) != seen.end()) return;\\n        seen.insert(x);\\n        sets[seti].push_back(s[x]);\\n        parentSet[x] = seti;\\n        auto& children = adjList[x];\\n        for(auto child : children) {\\n            dfs(adjList, child, seen, sets, seti, parentSet, s);\\n        }\\n    }\\n    \\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        int n = s.length();\\n        vector<vector<int>> adjList(n);\\n        \\n        for(auto& pair : pairs) {\\n            adjList[pair[0]].push_back(pair[1]);\\n            adjList[pair[1]].push_back(pair[0]);\\n        }\\n        \\n        unordered_set<int> seen;\\n        vector<string> sets;\\n        unordered_map<int, int> parentSet;\\n        int seti = 0;\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(seen.find(i) == seen.end()) {\\n                string newSet = \"\";\\n                sets.push_back(newSet);\\n                dfs(adjList, i, seen, sets, seti, parentSet, s);\\n                seti++;\\n            }\\n        }\\n        int setSize = sets.size();\\n        \\n        vector<int> its(setSize);\\n        for(auto& thing : sets) {\\n            sort(thing.begin(), thing.end());\\n        }\\n        for(int i = 0; i < n; i++) {\\n            int j = parentSet[i];      \\n            s[i]  = sets[j][its[j]++];  \\n        }\\n\\n        return s;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 387560,
                "title": "java-union-find-with-hashmap-of-priorityqueue",
                "content": "```\\nclass Solution {\\n    int[] parent;\\n    int[] level;\\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        char[] cs = s.toCharArray();\\n        parent = new int[cs.length];\\n        level = new int[cs.length];\\n        HashMap<Integer, PriorityQueue<Character>> map = new HashMap<>();\\n        for (int i = 0; i < parent.length; i++)\\n            parent[i] = i;\\n        for (List<Integer> pair : pairs) \\n            union(pair.get(0), pair.get(1));\\n        for (int i = 0; i < cs.length; i++) {\\n            int p = find(i);\\n            PriorityQueue<Character> pq = map.getOrDefault(p, new PriorityQueue<Character>());\\n            pq.offer(cs[i]);\\n            map.putIfAbsent(p, pq);\\n        }\\n        for (int i = 0; i < cs.length; i++) \\n            cs[i] = map.get(find(i)).poll();\\n        return new String(cs);\\n    }\\n    \\n    private void union(int a, int b) {\\n        int pa = find(a);\\n        int pb = find(b);\\n        if (pa != pb) {\\n            if (level[pa] > level[pb])\\n                parent[pb] = pa;\\n            else if (level[pb] > level[pa])\\n                parent[pa] = pb;\\n            else {\\n                parent[pb] = pa;\\n                level[pa]++;\\n            }\\n        }\\n    }\\n    \\n    private int find(int a) {\\n        if (parent[a] == a)\\n            return a;\\n        parent[a] = find(parent[a]);\\n        return parent[a];\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Union Find",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    int[] parent;\\n    int[] level;\\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        char[] cs = s.toCharArray();\\n        parent = new int[cs.length];\\n        level = new int[cs.length];\\n        HashMap<Integer, PriorityQueue<Character>> map = new HashMap<>();\\n        for (int i = 0; i < parent.length; i++)\\n            parent[i] = i;\\n        for (List<Integer> pair : pairs) \\n            union(pair.get(0), pair.get(1));\\n        for (int i = 0; i < cs.length; i++) {\\n            int p = find(i);\\n            PriorityQueue<Character> pq = map.getOrDefault(p, new PriorityQueue<Character>());\\n            pq.offer(cs[i]);\\n            map.putIfAbsent(p, pq);\\n        }\\n        for (int i = 0; i < cs.length; i++) \\n            cs[i] = map.get(find(i)).poll();\\n        return new String(cs);\\n    }\\n    \\n    private void union(int a, int b) {\\n        int pa = find(a);\\n        int pb = find(b);\\n        if (pa != pb) {\\n            if (level[pa] > level[pb])\\n                parent[pb] = pa;\\n            else if (level[pb] > level[pa])\\n                parent[pa] = pb;\\n            else {\\n                parent[pb] = pa;\\n                level[pa]++;\\n            }\\n        }\\n    }\\n    \\n    private int find(int a) {\\n        if (parent[a] == a)\\n            return a;\\n        parent[a] = find(parent[a]);\\n        return parent[a];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 387538,
                "title": "java-union-find-solution-with-hashmap",
                "content": "```\\nclass Solution {\\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        int[] p = new int[s.length()];\\n        for (int i = 0; i < p.length; i++) p[i] = i;\\n        for (List<Integer> pair : pairs) {\\n            union(p, pair.get(0), pair.get(1));\\n        }\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for (int i = 0; i < p.length; i++) {\\n            int fath = find(p, i);\\n            if (!map.containsKey(fath)) map.put(fath, new ArrayList<Integer>());\\n            map.get(fath).add(i);\\n        }\\n        char[] arr = s.toCharArray();\\n        for (Map.Entry<Integer, List<Integer>> entry : map.entrySet()) {\\n            List<Integer> group = entry.getValue();\\n            List<Character> temp = new ArrayList<>();\\n            for (int ind : group) temp.add(arr[ind]);\\n            Collections.sort(temp);\\n            for (int i = 0; i < group.size(); i++) {\\n                arr[group.get(i)] = temp.get(i);\\n            }\\n        }\\n        return new String(arr);\\n    }\\n    public void union (int[] p, int nodeA, int nodeB) {\\n        int A = find(p, nodeA);\\n        int B = find(p, nodeB);\\n        if (A != B) p[A] = B;\\n    }\\n    \\n    public int find(int[] p, int node) {\\n        if (p[node] == node) return node;\\n        return p[node] = find(p, p[node]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        int[] p = new int[s.length()];\\n        for (int i = 0; i < p.length; i++) p[i] = i;\\n        for (List<Integer> pair : pairs) {\\n            union(p, pair.get(0), pair.get(1));\\n        }\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for (int i = 0; i < p.length; i++) {\\n            int fath = find(p, i);\\n            if (!map.containsKey(fath)) map.put(fath, new ArrayList<Integer>());\\n            map.get(fath).add(i);\\n        }\\n        char[] arr = s.toCharArray();\\n        for (Map.Entry<Integer, List<Integer>> entry : map.entrySet()) {\\n            List<Integer> group = entry.getValue();\\n            List<Character> temp = new ArrayList<>();\\n            for (int ind : group) temp.add(arr[ind]);\\n            Collections.sort(temp);\\n            for (int i = 0; i < group.size(); i++) {\\n                arr[group.get(i)] = temp.get(i);\\n            }\\n        }\\n        return new String(arr);\\n    }\\n    public void union (int[] p, int nodeA, int nodeB) {\\n        int A = find(p, nodeA);\\n        int B = find(p, nodeB);\\n        if (A != B) p[A] = B;\\n    }\\n    \\n    public int find(int[] p, int node) {\\n        if (p[node] == node) return node;\\n        return p[node] = find(p, p[node]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1985211,
                "title": "easy-solution-union-find-o",
                "content": "***UNION FIND***\\n```\\nclass Solution {\\n    int[] parent;\\n    int[] rank;\\n    \\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        int n =s.length();\\n        parent = new int[n];\\n        rank = new int[n];\\n        \\n        for(int i = 0; i<n; i++) parent[i] = i;\\n        \\n        for(List<Integer> v : pairs){\\n            union(v.get(0), v.get(1));  // union of all the pairs that can be swappped\\n        }\\n        for(int i = 0; i<n; i++){\\n            parent[i] = find(parent[i]); // making sure that the connected components have a same parent in parent[i]\\n        }\\n        \\n        HashMap<Integer, ArrayList<Character>> map = new HashMap<>();\\n        \\n        for(int i = 0; i<n; i++){\\n            ArrayList<Character> list = map.getOrDefault(parent[i], new ArrayList<>());\\n            list.add(s.charAt(i));\\n            map.put(parent[i], list); // adding all the character corresponding to thier parent Index\\n        }\\n        \\n        for(ArrayList<Character> a : map.values()){\\n            Collections.sort(a, (x,y) -> y-x);  // sorting all the connected components\\n        }\\n        \\n        char[] ch = new char[n];\\n        for(int i = 0; i<n; i++){\\n            ch[i] = map.get(parent[i]).remove(map.get(parent[i]).size() - 1); // making our ans\\n        }\\n        \\n        return new String(ch);\\n    }\\n    \\n    void union(int a, int b){\\n        int x = find(a), y = find(b);\\n        if(x == y) return;\\n        if(rank[x] > rank[y]){\\n            parent[y] = x;\\n        }else if(rank[y] > rank[x]){\\n            parent[x] = y;\\n        }else{\\n            parent[x] = y;\\n            rank[y]++;\\n        }\\n    }\\n    \\n    int find(int x){\\n        if(parent[x] != x){\\n            parent[x] = find(parent[x]);\\n        }\\n        return parent[x];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    int[] parent;\\n    int[] rank;\\n    \\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        int n =s.length();\\n        parent = new int[n];\\n        rank = new int[n];\\n        \\n        for(int i = 0; i<n; i++) parent[i] = i;\\n        \\n        for(List<Integer> v : pairs){\\n            union(v.get(0), v.get(1));  // union of all the pairs that can be swappped\\n        }\\n        for(int i = 0; i<n; i++){\\n            parent[i] = find(parent[i]); // making sure that the connected components have a same parent in parent[i]\\n        }\\n        \\n        HashMap<Integer, ArrayList<Character>> map = new HashMap<>();\\n        \\n        for(int i = 0; i<n; i++){\\n            ArrayList<Character> list = map.getOrDefault(parent[i], new ArrayList<>());\\n            list.add(s.charAt(i));\\n            map.put(parent[i], list); // adding all the character corresponding to thier parent Index\\n        }\\n        \\n        for(ArrayList<Character> a : map.values()){\\n            Collections.sort(a, (x,y) -> y-x);  // sorting all the connected components\\n        }\\n        \\n        char[] ch = new char[n];\\n        for(int i = 0; i<n; i++){\\n            ch[i] = map.get(parent[i]).remove(map.get(parent[i]).size() - 1); // making our ans\\n        }\\n        \\n        return new String(ch);\\n    }\\n    \\n    void union(int a, int b){\\n        int x = find(a), y = find(b);\\n        if(x == y) return;\\n        if(rank[x] > rank[y]){\\n            parent[y] = x;\\n        }else if(rank[y] > rank[x]){\\n            parent[x] = y;\\n        }else{\\n            parent[x] = y;\\n            rank[y]++;\\n        }\\n    }\\n    \\n    int find(int x){\\n        if(parent[x] != x){\\n            parent[x] = find(parent[x]);\\n        }\\n        return parent[x];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1770983,
                "title": "python3-union-find-priority-queue-heap-easy-to-understand",
                "content": "Method 1: Union-find + sort\\nTC: O(nlogn)\\nSC: O(n)\\n```\\nclass UnionFind:\\n    def __init__(self, size: int):\\n        self.root = [i for i in range(size)]\\n        self.rank = [1 for _ in range(size)]\\n        \\n    def find(self, x: int) -> int:\\n        if x == self.root[x]:\\n            return x\\n        \\n        self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n    \\n    def union(self, x: int, y: int) -> None:\\n        root_x, root_y = self.find(x), self.find(y)\\n        if root_x != root_y:\\n            if self.rank[root_x] > self.rank[root_y]:\\n                self.root[root_y] = root_x\\n            elif self.rank[root_x] < self.rank[root_y]:\\n                self.root[root_x] = root_y\\n            else:\\n                self.root[root_y] = root_x\\n                self.rank[root_x] += 1\\n    \\n    def connected(self, x: int, y: int) -> bool:\\n        return self.find(x) == self.find(y)\\n\\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        n = len(s)\\n        uf = UnionFind(n)\\n        for x, y in pairs:\\n            uf.union(x, y)\\n        \\n        alias = defaultdict(list)\\n        for i in range(n):\\n            root = uf.find(i)\\n            alias[root].append(s[i])\\n        for i in alias:\\n            alias[i].sort(reverse=True)\\n                \\n        res = []\\n        for i in range(n):\\n            res.append(alias[uf.find(i)].pop())\\n        \\n        return \\'\\'.join(res)\\n```\\n\\nMethod 2: Union-find + priority queue\\nTC: O(nlogk)\\nSC: O(n)\\n```\\nclass UnionFind:\\n    def __init__(self, size: int):\\n        self.root = [i for i in range(size)]\\n        self.rank = [1 for _ in range(size)]\\n        \\n    def find(self, x: int) -> int:\\n        if x == self.root[x]:\\n            return x\\n        \\n        self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n    \\n    def union(self, x: int, y: int) -> None:\\n        root_x, root_y = self.find(x), self.find(y)\\n        if root_x != root_y:\\n            if self.rank[root_x] > self.rank[root_y]:\\n                self.root[root_y] = root_x\\n            elif self.rank[root_x] < self.rank[root_y]:\\n                self.root[root_x] = root_y\\n            else:\\n                self.root[root_y] = root_x\\n                self.rank[root_x] += 1\\n    \\n    def connected(self, x: int, y: int) -> bool:\\n        return self.find(x) == self.find(y)\\n\\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        n = len(s)\\n        uf = UnionFind(n)\\n        for x, y in pairs:\\n            uf.union(x, y)\\n        \\n        alias = defaultdict(list)\\n        for i in range(n):\\n            root = uf.find(i)\\n            heappush(alias[root], s[i])\\n        \\n        res = []\\n        for i in range(n):\\n            res.append(heappop(alias[uf.find(i)]))\\n        \\n        return \\'\\'.join(res)\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Union Find",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass UnionFind:\\n    def __init__(self, size: int):\\n        self.root = [i for i in range(size)]\\n        self.rank = [1 for _ in range(size)]\\n        \\n    def find(self, x: int) -> int:\\n        if x == self.root[x]:\\n            return x\\n        \\n        self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n    \\n    def union(self, x: int, y: int) -> None:\\n        root_x, root_y = self.find(x), self.find(y)\\n        if root_x != root_y:\\n            if self.rank[root_x] > self.rank[root_y]:\\n                self.root[root_y] = root_x\\n            elif self.rank[root_x] < self.rank[root_y]:\\n                self.root[root_x] = root_y\\n            else:\\n                self.root[root_y] = root_x\\n                self.rank[root_x] += 1\\n    \\n    def connected(self, x: int, y: int) -> bool:\\n        return self.find(x) == self.find(y)\\n\\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        n = len(s)\\n        uf = UnionFind(n)\\n        for x, y in pairs:\\n            uf.union(x, y)\\n        \\n        alias = defaultdict(list)\\n        for i in range(n):\\n            root = uf.find(i)\\n            alias[root].append(s[i])\\n        for i in alias:\\n            alias[i].sort(reverse=True)\\n                \\n        res = []\\n        for i in range(n):\\n            res.append(alias[uf.find(i)].pop())\\n        \\n        return \\'\\'.join(res)\\n```\n```\\nclass UnionFind:\\n    def __init__(self, size: int):\\n        self.root = [i for i in range(size)]\\n        self.rank = [1 for _ in range(size)]\\n        \\n    def find(self, x: int) -> int:\\n        if x == self.root[x]:\\n            return x\\n        \\n        self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n    \\n    def union(self, x: int, y: int) -> None:\\n        root_x, root_y = self.find(x), self.find(y)\\n        if root_x != root_y:\\n            if self.rank[root_x] > self.rank[root_y]:\\n                self.root[root_y] = root_x\\n            elif self.rank[root_x] < self.rank[root_y]:\\n                self.root[root_x] = root_y\\n            else:\\n                self.root[root_y] = root_x\\n                self.rank[root_x] += 1\\n    \\n    def connected(self, x: int, y: int) -> bool:\\n        return self.find(x) == self.find(y)\\n\\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        n = len(s)\\n        uf = UnionFind(n)\\n        for x, y in pairs:\\n            uf.union(x, y)\\n        \\n        alias = defaultdict(list)\\n        for i in range(n):\\n            root = uf.find(i)\\n            heappush(alias[root], s[i])\\n        \\n        res = []\\n        for i in range(n):\\n            res.append(heappop(alias[uf.find(i)]))\\n        \\n        return \\'\\'.join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 460319,
                "title": "java-dfs",
                "content": "```\\nclass Solution {\\n    public static void dfs(String s, HashMap<Integer, ArrayList<Integer>> map, boolean[] visited, ArrayList<Integer> list, int curr, ArrayList<Character> ch){\\n        if(visited[curr]) return;\\n        visited[curr] = true;\\n        list.add(curr);\\n        ch.add(s.charAt(curr));\\n        if(!map.containsKey(curr)) return;\\n        ArrayList<Integer> adj = map.get(curr);\\n        for(int i = 0; i < adj.size(); i++) dfs(s, map, visited, list, adj.get(i), ch);\\n        return;\\n    }\\n    \\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        int n = s.length();\\n        HashMap<Integer, ArrayList<Integer>> map = new HashMap<>();\\n        for(int i = 0; i < pairs.size(); i++){\\n            int s1 = pairs.get(i).get(0), s2 = pairs.get(i).get(1);\\n            if(!map.containsKey(s1)) map.put(s1, new ArrayList<>());\\n            if(!map.containsKey(s2)) map.put(s2, new ArrayList<>());\\n            map.get(s1).add(s2);\\n            map.get(s2).add(s1);\\n        }\\n        boolean[] visited = new boolean[n];\\n        char[] ans = new char[n];\\n        for(int i = 0; i < n; i++){\\n            if(!visited[i]){\\n                ArrayList<Integer> l1 = new ArrayList<>();\\n                ArrayList<Character> l2 = new ArrayList<>();\\n                dfs(s, map, visited, l1, i, l2);\\n                Collections.sort(l1);\\n                Collections.sort(l2);\\n                for(int t = 0; t < l1.size(); t++) ans[l1.get(t)] = l2.get(t);\\n            }\\n        }\\n        return new String(ans);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public static void dfs(String s, HashMap<Integer, ArrayList<Integer>> map, boolean[] visited, ArrayList<Integer> list, int curr, ArrayList<Character> ch){\\n        if(visited[curr]) return;\\n        visited[curr] = true;\\n        list.add(curr);\\n        ch.add(s.charAt(curr));\\n        if(!map.containsKey(curr)) return;\\n        ArrayList<Integer> adj = map.get(curr);\\n        for(int i = 0; i < adj.size(); i++) dfs(s, map, visited, list, adj.get(i), ch);\\n        return;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1990021,
                "title": "c-daily-leetcoding-challenge-april-day-27",
                "content": "* Sort the characters that belong to same set.\\n```\\nclass Solution {\\n    struct subset {\\n        int parent;\\n        int rank;\\n    };\\npublic:\\n    \\n    int find(struct subset subsets[], int i){\\n            \\n        if (subsets[i].parent != i)\\n            subsets[i].parent = find(subsets, subsets[i].parent);\\n\\n        return subsets[i].parent;\\n    }\\n\\n    \\n    void Union(struct subset subsets[], int xroot, int yroot){\\n\\n        \\n        if (subsets[xroot].rank < subsets[yroot].rank)\\n            subsets[xroot].parent = yroot;\\n        else if (subsets[xroot].rank > subsets[yroot].rank)\\n            subsets[yroot].parent = xroot;\\n        else {\\n            subsets[yroot].parent = xroot;\\n            subsets[xroot].rank++;\\n        }\\n    }\\n    \\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        \\n        int s_len = s.length();\\n        int n = pairs.size();\\n        string ans;\\n\\n        struct subset* subsets = (struct subset*)malloc(s_len * sizeof(struct subset));\\n        for (int v = 0; v < s_len; v++) {\\n            subsets[v].parent = v;\\n            subsets[v].rank = 0;\\n        }\\n        \\n        for (int e = 0; e < n; ++e) {\\n            \\n            int x = find(subsets, pairs[e][0]);\\n            int y = find(subsets, pairs[e][1]);\\n\\n            if (x !=y) Union(subsets, x, y);\\n        }\\n        \\n        vector<pair<string, int>> arr(s_len);\\n        \\n        for(int i = 0; i < s_len ; i++){\\n            arr[find(subsets, i)].first += s[i];\\n            arr[find(subsets, i)].second = 0;\\n        }\\n        \\n        for(int i = 0; i < s_len ; i++){\\n            sort(arr[i].first.begin(), arr[i].first.end());\\n        }\\n        \\n        for(int i = 0; i < s_len ; i++){\\n            ans += arr[subsets[i].parent].first[arr[subsets[i].parent].second];\\n            arr[subsets[i].parent].second++;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    struct subset {\\n        int parent;\\n        int rank;\\n    };\\npublic:\\n    \\n    int find(struct subset subsets[], int i){\\n            \\n        if (subsets[i].parent != i)\\n            subsets[i].parent = find(subsets, subsets[i].parent);\\n\\n        return subsets[i].parent;\\n    }\\n\\n    \\n    void Union(struct subset subsets[], int xroot, int yroot){\\n\\n        \\n        if (subsets[xroot].rank < subsets[yroot].rank)\\n            subsets[xroot].parent = yroot;\\n        else if (subsets[xroot].rank > subsets[yroot].rank)\\n            subsets[yroot].parent = xroot;\\n        else {\\n            subsets[yroot].parent = xroot;\\n            subsets[xroot].rank++;\\n        }\\n    }\\n    \\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        \\n        int s_len = s.length();\\n        int n = pairs.size();\\n        string ans;\\n\\n        struct subset* subsets = (struct subset*)malloc(s_len * sizeof(struct subset));\\n        for (int v = 0; v < s_len; v++) {\\n            subsets[v].parent = v;\\n            subsets[v].rank = 0;\\n        }\\n        \\n        for (int e = 0; e < n; ++e) {\\n            \\n            int x = find(subsets, pairs[e][0]);\\n            int y = find(subsets, pairs[e][1]);\\n\\n            if (x !=y) Union(subsets, x, y);\\n        }\\n        \\n        vector<pair<string, int>> arr(s_len);\\n        \\n        for(int i = 0; i < s_len ; i++){\\n            arr[find(subsets, i)].first += s[i];\\n            arr[find(subsets, i)].second = 0;\\n        }\\n        \\n        for(int i = 0; i < s_len ; i++){\\n            sort(arr[i].first.begin(), arr[i].first.end());\\n        }\\n        \\n        for(int i = 0; i < s_len ; i++){\\n            ans += arr[subsets[i].parent].first[arr[subsets[i].parent].second];\\n            arr[subsets[i].parent].second++;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1985192,
                "title": "java-easy-understanding",
                "content": "```\\nclass UF {\\n  public UF(int n) {\\n    id = new int[n];\\n    for (int i = 0; i < n; ++i)\\n      id[i] = i;\\n  }\\n\\n  public void union(int u, int v) {\\n    id[find(u)] = find(v);\\n  }\\n\\n  public int find(int u) {\\n    return id[u] == u ? u : (id[u] = find(id[u]));\\n  }\\n\\n  private int[] id;\\n}\\n\\nclass Solution {\\n  public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n    StringBuilder ans = new StringBuilder();\\n    UF uf = new UF(s.length());\\n    Map<Integer, Queue<Character>> map = new HashMap<>();\\n\\n    for (List<Integer> pair : pairs)\\n      uf.union(pair.get(0), pair.get(1));\\n\\n    for (int i = 0; i < s.length(); ++i)\\n      map.computeIfAbsent(uf.find(i), k -> new PriorityQueue<>()).offer(s.charAt(i));\\n\\n    for (int i = 0; i < s.length(); ++i)\\n      ans.append(map.get(uf.find(i)).poll());\\n\\n    return ans.toString();\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass UF {\\n  public UF(int n) {\\n    id = new int[n];\\n    for (int i = 0; i < n; ++i)\\n      id[i] = i;\\n  }\\n\\n  public void union(int u, int v) {\\n    id[find(u)] = find(v);\\n  }\\n\\n  public int find(int u) {\\n    return id[u] == u ? u : (id[u] = find(id[u]));\\n  }\\n\\n  private int[] id;\\n}\\n\\nclass Solution {\\n  public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n    StringBuilder ans = new StringBuilder();\\n    UF uf = new UF(s.length());\\n    Map<Integer, Queue<Character>> map = new HashMap<>();\\n\\n    for (List<Integer> pair : pairs)\\n      uf.union(pair.get(0), pair.get(1));\\n\\n    for (int i = 0; i < s.length(); ++i)\\n      map.computeIfAbsent(uf.find(i), k -> new PriorityQueue<>()).offer(s.charAt(i));\\n\\n    for (int i = 0; i < s.length(); ++i)\\n      ans.append(map.get(uf.find(i)).poll());\\n\\n    return ans.toString();\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1709491,
                "title": "easy-c-solution-optimized-union-find-explained",
                "content": "```\\nclass unionfind{        //most optimised way of implementing disjoint sets\\n    public: \\n    int count;\\n    vector <int> root;\\n    vector <int> rank;\\n    unionfind(int n){\\n        count = n;\\n        root = vector <int> (n);\\n        rank = vector <int> (n);\\n        \\n        for(int i=0; i<n; i++){\\n            root[i]=i;\\n            rank[i]=1;\\n        }\\n    }\\n    \\n    void unionset(int x, int y){        \\n        int rootx=find(x), rooty=find(y);\\n        if(rootx!=rooty){\\n            if(rank[rootx]>rank[rooty])\\n                root[rooty]=rootx;\\n            else if(rank[rooty]>rank[rootx])\\n                root[rootx]=rooty;\\n            else{\\n                root[rooty]=rootx;\\n                rank[rootx]++;\\n            }\\n            count--;\\n        }\\n    }\\n    \\n    int find(int x){\\n        if(x==root[x])\\n            return root[x];\\n        return root[x]=find(root[x]);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        int n = s.length();\\n        \\n        if(pairs.size()==0)          //if there are no edges at all, we simply return back the string\\n            return s;\\n        \\n        unionfind uf(n);             //to create n-sized arrays(root, rank)\\n        \\n        for(auto pair: pairs)        //make the union of elements\\n            uf.unionset(pair[0], pair[1]);\\n        \\n        map<int, string> m;\\n        for(int i=0; i<n; i++){      //adding the char one by one in map corresponding to root\\n            int root = uf.find(i);\\n            uf.root[i] = root;\\n            m[root] += s[i];\\n        }\\n        \\n        if(uf.count==1){             //if the whole graph is connected, simply return string after sorting\\n            sort(s.begin(), s.end());\\n            return s;\\n        }\\n        \\n        for(auto pairs:m){           //if whole graph is not completely connected, sort the char in disconnected graphs\\n            int i=pairs.first;\\n            string s=pairs.second;\\n            sort(s.begin(), s.end(), greater<char>());\\n            m[i]=s;\\n        }\\n        \\n        for(int i=0; i<n; i++){     //storing the back into the string\\n            int root=uf.find(i);\\n            s[i]=m[root].back();\\n            m[root].pop_back();\\n        }\\n        return s;                   //return the resultant string\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass unionfind{        //most optimised way of implementing disjoint sets\\n    public: \\n    int count;\\n    vector <int> root;\\n    vector <int> rank;\\n    unionfind(int n){\\n        count = n;\\n        root = vector <int> (n);\\n        rank = vector <int> (n);\\n        \\n        for(int i=0; i<n; i++){\\n            root[i]=i;\\n            rank[i]=1;\\n        }\\n    }\\n    \\n    void unionset(int x, int y){        \\n        int rootx=find(x), rooty=find(y);\\n        if(rootx!=rooty){\\n            if(rank[rootx]>rank[rooty])\\n                root[rooty]=rootx;\\n            else if(rank[rooty]>rank[rootx])\\n                root[rootx]=rooty;\\n            else{\\n                root[rooty]=rootx;\\n                rank[rootx]++;\\n            }\\n            count--;\\n        }\\n    }\\n    \\n    int find(int x){\\n        if(x==root[x])\\n            return root[x];\\n        return root[x]=find(root[x]);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        int n = s.length();\\n        \\n        if(pairs.size()==0)          //if there are no edges at all, we simply return back the string\\n            return s;\\n        \\n        unionfind uf(n);             //to create n-sized arrays(root, rank)\\n        \\n        for(auto pair: pairs)        //make the union of elements\\n            uf.unionset(pair[0], pair[1]);\\n        \\n        map<int, string> m;\\n        for(int i=0; i<n; i++){      //adding the char one by one in map corresponding to root\\n            int root = uf.find(i);\\n            uf.root[i] = root;\\n            m[root] += s[i];\\n        }\\n        \\n        if(uf.count==1){             //if the whole graph is connected, simply return string after sorting\\n            sort(s.begin(), s.end());\\n            return s;\\n        }\\n        \\n        for(auto pairs:m){           //if whole graph is not completely connected, sort the char in disconnected graphs\\n            int i=pairs.first;\\n            string s=pairs.second;\\n            sort(s.begin(), s.end(), greater<char>());\\n            m[i]=s;\\n        }\\n        \\n        for(int i=0; i<n; i++){     //storing the back into the string\\n            int root=uf.find(i);\\n            s[i]=m[root].back();\\n            m[root].pop_back();\\n        }\\n        return s;                   //return the resultant string\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1985208,
                "title": "simple-c-solution-using-dfs",
                "content": "Algorithm:\\n1. Make a graph using the pairs.\\n2. Then find out all the connected components by dfs.\\n3. For all components, store the positions and characters in an array during the dfs traversal.\\n4. Sort the position array and characters array.\\n5. Traverse through the position array and replace the character of each position from the character array.\\n\\nTime Complexity: O(nlogn)\\n\\n```\\nclass Solution {\\npublic:\\n    bool flag[100011];\\n    vector<int> vec[100001], pos;\\n    vector<char> allChars;\\n    string str;\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        int n = pairs.size();\\n        for(int i=0;i<n;i++)flag[i] = false;\\n        str = s;\\n        for(int i=0;i<n;i++){\\n            int u = pairs[i][0];\\n            int v = pairs[i][1];\\n            \\n            vec[u].push_back(v);\\n            vec[v].push_back(u);\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(!flag[i]){\\n                pos.clear();\\n                allChars.clear();\\n                dfs(i);\\n                \\n                sort(allChars.begin(), allChars.end());\\n                sort(pos.begin(), pos.end());\\n                \\n                for(int j=0;j<pos.size();j++){\\n                    str[ pos[j] ] = allChars[j];\\n                }\\n            }\\n        }\\n        \\n        return str;\\n    }\\n    \\n    void dfs(int nd){\\n        flag[nd] = true;\\n        allChars.push_back(str[nd]);\\n        pos.push_back(nd);\\n        \\n        for(auto v: vec[nd]){\\n            if(!flag[v]){\\n                dfs(v);\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool flag[100011];\\n    vector<int> vec[100001], pos;\\n    vector<char> allChars;\\n    string str;\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        int n = pairs.size();\\n        for(int i=0;i<n;i++)flag[i] = false;\\n        str = s;\\n        for(int i=0;i<n;i++){\\n            int u = pairs[i][0];\\n            int v = pairs[i][1];\\n            \\n            vec[u].push_back(v);\\n            vec[v].push_back(u);\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(!flag[i]){\\n                pos.clear();\\n                allChars.clear();\\n                dfs(i);\\n                \\n                sort(allChars.begin(), allChars.end());\\n                sort(pos.begin(), pos.end());\\n                \\n                for(int j=0;j<pos.size();j++){\\n                    str[ pos[j] ] = allChars[j];\\n                }\\n            }\\n        }\\n        \\n        return str;\\n    }\\n    \\n    void dfs(int nd){\\n        flag[nd] = true;\\n        allChars.push_back(str[nd]);\\n        pos.push_back(nd);\\n        \\n        for(auto v: vec[nd]){\\n            if(!flag[v]){\\n                dfs(v);\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 800257,
                "title": "c-dfs-solution-o-n-logn",
                "content": "Disclaimer : Not the best solution out there. (Best is Union Find)\\nStill here? Nice, let\\'s go.\\n- Make a graph of pairs of index which are interchangeable. For this simply make a biderectional graph from the pairs.\\n- Run dfs on each unvisited node and collect all the positions. Now, sort the string made my the indexes from those positions and reassign the string\\n- Once all the nodes are visited (`vis` array is all `false`), return the final string.\\n\\nTime complexity : `O(n logn)`\\n```\\nclass Solution {\\npublic:\\n    string ans;\\n    void dfs(int i, vector<int> &pos, vector<int> &vis, vector<vector<int>> &g) {   \\n        vis[i]++;\\n        pos.push_back(i);\\n        for(auto child: g[i]){\\n            if (!vis[child]) dfs(child, pos, vis, g);\\n        }\\n    }\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        int n = s.size();\\n        ans = s;\\n        vector<vector<int>> g(n);\\n        for(auto i: pairs) {\\n            g[i[0]].push_back(i[1]);\\n            g[i[1]].push_back(i[0]);\\n        }\\n        vector<int> vis(n, 0);\\n        for(int i=0; i<n; i++) {\\n            if (!vis[i]) {\\n                vector<int> pos;\\n                dfs(i, pos, vis, g);\\n                string tmp = \"\";\\n                for(auto c: pos) {\\n                    tmp += s[c];\\n                }\\n                sort(pos.begin(), pos.end());\\n                sort(tmp.begin(), tmp.end());\\n                for(int z = 0; z<pos.size(); z++) {\\n                    ans[pos[z]] = tmp[z];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string ans;\\n    void dfs(int i, vector<int> &pos, vector<int> &vis, vector<vector<int>> &g) {   \\n        vis[i]++;\\n        pos.push_back(i);\\n        for(auto child: g[i]){\\n            if (!vis[child]) dfs(child, pos, vis, g);\\n        }\\n    }\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        int n = s.size();\\n        ans = s;\\n        vector<vector<int>> g(n);\\n        for(auto i: pairs) {\\n            g[i[0]].push_back(i[1]);\\n            g[i[1]].push_back(i[0]);\\n        }\\n        vector<int> vis(n, 0);\\n        for(int i=0; i<n; i++) {\\n            if (!vis[i]) {\\n                vector<int> pos;\\n                dfs(i, pos, vis, g);\\n                string tmp = \"\";\\n                for(auto c: pos) {\\n                    tmp += s[c];\\n                }\\n                sort(pos.begin(), pos.end());\\n                sort(tmp.begin(), tmp.end());\\n                for(int z = 0; z<pos.size(); z++) {\\n                    ans[pos[z]] = tmp[z];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1985188,
                "title": "python-modified-disjoint-set-union-with-explanation",
                "content": "### Introduction\\n\\nGiven a string `s`, we need to find the minimum lexicographical arrangement of the characters in `s`, with the limitation that swaps in `s` are restricted to defined swaps between two indexes as per `pairs` (0-indexed).\\n\\nSince index pairs may overlap, it is important to know the full list of indexes that can swap among one another before we determine the minimum lexicographical arrangement. Hence, this problem can be broken down into two distinct parts:\\n\\n1. Determining the group(s) of indexes that can swap among one another.\\n2. Obtaining the minimum lexicographical arrangement of characters per group.\\n\\nEach group of indexes is distinct by definition; if two groups of indexes contained the same index, then all the indexes in both groups can swap among one another. Hence, we can say that each group of indexes is **a disjoint set**. Then, to merge two groups together (because they share an index), we will require a union operation between the disjoint sets. This algorithm is thus commonly referred to as **Disjoint Set Union (DSU), or Union-Find**.\\n\\n---\\n\\n### Part 1: Implementing DSU\\n\\nWe can start with a standard implementation of a weighted DSU. This data structure allows for union-find operations to be performed in O(logn) time, where `n` is the number of nodes in the DSU. For a full, detailed explanation of implementing the weighted DSU, I recommend [this HackerEarth article](https://www.hackerearth.com/practice/notes/disjoint-set-union-union-find/) which is beginner-friendly and easy to understand.\\n\\n```python\\nclass WeightedUnionFind:\\n    def __init__(self, n: int):\\n        self.parent = list(range(n))\\n        self.size = [1]*n\\n\\n    def _root(self, node: int) -> int:\\n        # Obtains the root node of the given node\\n        while self.parent[node] != node:\\n            self.parent[node] = self.parent[self.parent[node]]  # perform path compression\\n            node = self.parent[node]  # traverse up the tree\\n        return node\\n\\n    def find(self, node1: int, node2: int) -> bool:\\n        # Determines if node1 and node2 are present in the same disjoint set\\n        return self._root(node1) == self._root(node2)\\n\\n    def union(self, node1: int, node2: int) -> None:\\n        # Performs union operation for the disjoint sets containing node1 and node2 respectively\\n        root1, root2 = self._root(node1), self._root(node2)\\n        if root1 == root2:  # the two nodes are already in the same disjoint set\\n            return\\n        elif self.size[root1] < self.size[root2]:  # ensure that root1 is the larger tree\\n            root1, root2 = root2, root1\\n        self.parent[root2] = root1  # set root node of root2 to root1\\n        self.size[root1] += self.size[root2]  # increase size of root1 tree by size of root2 subtree\\n```\\n\\nThe problem with this implementation for this problem is that we still have no way of easily identifying each group of indexes. We could try to iterate through each index and find all the indexes that have the same root, but that will take too long.\\n\\n---\\n\\n### Part 2: Modifying DSU\\n\\nThe solution is to store the full list of indexes that is rooted in a given index, instead of simply storing the sizes of the tree. This way, we get the additional functionality of knowing\\n\\n1. which nodes are roots of the disjoint set(s) that exist, and\\n2. the full list of nodes in each disjoint set.\\n\\n```python\\nclass WeightedUnionFind:\\n    def __init__(self, n: int):\\n        self.parent = list(range(n))\\n        self.group = [set([i]) for i in range(n)]  # store full list of nodes in disjoint set\\n    \\n    def _root(self, node: int) -> int:\\n        while self.parent[node] != node:\\n            self.parent[node] = self.parent[self.parent[node]]\\n            node = self.parent[node]\\n        return node\\n    \\n    def find(self, node1: int, node2: int) -> bool:\\n        return self._root(node1) == self._root(node2)\\n    \\n    def union(self, node1: int, node2: int) -> None:\\n        root1, root2 = self._root(node1), self._root(node2)\\n        if len(self.group[root1]) < len(self.group[root2]):\\n            root1, root2 = root2, root1\\n        self.parent[root2] = root1\\n        self.group[root1] |= self.group[root2]  # add all nodes in root2 to root1\\n```\\n\\n---\\n\\n### Part 3: Determining minimum lexicographical arrangement\\n\\nFinally, we are ready to tackle this problem. By iterating through all the root nodes in our DSU class, we can perform the following sequence:\\n\\n1. Obtain all the nodes in the tree rooted by the given root node.\\n2. Obtain all the characters in `s` if its index is found in the obtained disjoint set.\\n3. Sort the obtained characters by ascending lexicographical order.\\n4. Insert the sorted characters in order of the indexes in the disjoint set.\\n\\nThe full code is as follows:\\n\\n```python\\nclass WeightedUnionFind:\\n    def __init__(self, n: int):\\n        self.parent = list(range(n))\\n        self.group = [set([i]) for i in range(n)]\\n    \\n    def _root(self, node: int) -> int:\\n        while self.parent[node] != node:\\n            self.parent[node] = self.parent[self.parent[node]]\\n            node = self.parent[node]\\n        return node\\n    \\n    def find(self, node1: int, node2: int) -> bool:\\n        return self._root(node1) == self._root(node2)\\n    \\n    def union(self, node1: int, node2: int) -> None:\\n        root1, root2 = self._root(node1), self._root(node2)\\n        if len(self.group[root1]) < len(self.group[root2]):\\n            root1, root2 = root2, root1\\n        self.parent[root2] = root1\\n        self.group[root1] |= self.group[root2]\\n\\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        uf = WeightedUnionFind((l := len(s)))\\n        for a, b in pairs:\\n            uf.union(a, b)\\n        res = [\\'\\']*l\\n        for root in [i for i, node in enumerate(uf.parent) if node == i]:\\n            for i, ch in zip(sorted(uf.group[root]), sorted(s[i] for i in uf.group[root])):\\n                res[i] = ch\\n        return \\'\\'.join(res)\\n```\\n\\n**TC: O(max(m, n)logn)**, where `m` is the number of `pairs` and `n` is the length of the given string `s`, due to the nested sorting / union-find algorithm. The TC of the union function may be worse than O(logn) if the set union operation `|=` is required to merge sets of large sizes (I think it should be O(n) worst case, in which case the overall TC is roughly O(n<sup>2</sup>), but it\\'s quite complicated).\\n**SC: O(n<sup>2</sup>)**; `uf.group` will have many duplicates if the graph is more connected than disjoint.\\n\\n---\\n\\nPlease upvote if this has helped you! Appreciate any comments as well :)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Union Find"
                ],
                "code": "```python\\nclass WeightedUnionFind:\\n    def __init__(self, n: int):\\n        self.parent = list(range(n))\\n        self.size = [1]*n\\n\\n    def _root(self, node: int) -> int:\\n        # Obtains the root node of the given node\\n        while self.parent[node] != node:\\n            self.parent[node] = self.parent[self.parent[node]]  # perform path compression\\n            node = self.parent[node]  # traverse up the tree\\n        return node\\n\\n    def find(self, node1: int, node2: int) -> bool:\\n        # Determines if node1 and node2 are present in the same disjoint set\\n        return self._root(node1) == self._root(node2)\\n\\n    def union(self, node1: int, node2: int) -> None:\\n        # Performs union operation for the disjoint sets containing node1 and node2 respectively\\n        root1, root2 = self._root(node1), self._root(node2)\\n        if root1 == root2:  # the two nodes are already in the same disjoint set\\n            return\\n        elif self.size[root1] < self.size[root2]:  # ensure that root1 is the larger tree\\n            root1, root2 = root2, root1\\n        self.parent[root2] = root1  # set root node of root2 to root1\\n        self.size[root1] += self.size[root2]  # increase size of root1 tree by size of root2 subtree\\n```\n```python\\nclass WeightedUnionFind:\\n    def __init__(self, n: int):\\n        self.parent = list(range(n))\\n        self.group = [set([i]) for i in range(n)]  # store full list of nodes in disjoint set\\n    \\n    def _root(self, node: int) -> int:\\n        while self.parent[node] != node:\\n            self.parent[node] = self.parent[self.parent[node]]\\n            node = self.parent[node]\\n        return node\\n    \\n    def find(self, node1: int, node2: int) -> bool:\\n        return self._root(node1) == self._root(node2)\\n    \\n    def union(self, node1: int, node2: int) -> None:\\n        root1, root2 = self._root(node1), self._root(node2)\\n        if len(self.group[root1]) < len(self.group[root2]):\\n            root1, root2 = root2, root1\\n        self.parent[root2] = root1\\n        self.group[root1] |= self.group[root2]  # add all nodes in root2 to root1\\n```\n```python\\nclass WeightedUnionFind:\\n    def __init__(self, n: int):\\n        self.parent = list(range(n))\\n        self.group = [set([i]) for i in range(n)]\\n    \\n    def _root(self, node: int) -> int:\\n        while self.parent[node] != node:\\n            self.parent[node] = self.parent[self.parent[node]]\\n            node = self.parent[node]\\n        return node\\n    \\n    def find(self, node1: int, node2: int) -> bool:\\n        return self._root(node1) == self._root(node2)\\n    \\n    def union(self, node1: int, node2: int) -> None:\\n        root1, root2 = self._root(node1), self._root(node2)\\n        if len(self.group[root1]) < len(self.group[root2]):\\n            root1, root2 = root2, root1\\n        self.parent[root2] = root1\\n        self.group[root1] |= self.group[root2]\\n\\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        uf = WeightedUnionFind((l := len(s)))\\n        for a, b in pairs:\\n            uf.union(a, b)\\n        res = [\\'\\']*l\\n        for root in [i for i, node in enumerate(uf.parent) if node == i]:\\n            for i, ch in zip(sorted(uf.group[root]), sorted(s[i] for i in uf.group[root])):\\n                res[i] = ch\\n        return \\'\\'.join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1606827,
                "title": "unionfind-solution-explained-with-diagrams",
                "content": "We can see that the swappable indices can be sorted so no need to do enless swapping\\n![image](https://assets.leetcode.com/users/images/9cf58ffb-f7f8-4684-a475-9286a987fe04_1638398851.56767.png)\\nNow the algorithm goes like this:\\n1. Create disjoint sets of the all swappable indices.\\n![image](https://assets.leetcode.com/users/images/d7a33288-e49a-4751-833a-90a9226510b6_1638398916.3190718.png)\\n\\n2. Create an array/list holding each set of swappable indices.\\n![image](https://assets.leetcode.com/users/images/bd61d453-bd8e-4294-bb91-999a6921a337_1638398944.285398.png)\\n\\n3. Create a char array(swapS) of size s.length where we will do the swapping.\\n4. For each set in the swappable indices set: \\n\\ta. Create a char array  with with a char in s corresponding to each index in the current    set of indices we are in\\n![image](https://assets.leetcode.com/users/images/8383fb7f-703e-44b9-a949-c2def221af49_1638398974.2066007.png)\\n\\n\\tb. After all char are in inserted in the array then sort the array\\n\\t![image](https://assets.leetcode.com/users/images/9f30374f-3620-483f-8704-0abee7f86894_1638399034.007516.png)\\n\\n\\tc. Now place each char in newS corresponding to each index.\\n![image](https://assets.leetcode.com/users/images/545d6be7-aff0-4c48-b859-59dbf0672bdd_1638399316.737393.png)\\n\\n\\t4. Return swapS char array transformed into a string.\\n![image](https://assets.leetcode.com/users/images/639c8bd8-a877-4f7a-8323-eb5e0f220e67_1638399339.8840125.png)\\n\\n\\n```\\nclass UnionFind{\\n    constructor(size){\\n        this.root = new Array(size);\\n        this.rank = new Array(size);\\n        for(let i = 0; i < size; i++){\\n            this.root[i] = i;\\n            this.rank[i] = 1;\\n        }\\n    }\\n    find(x){\\n        if(this.root[x] === x){\\n            return x;\\n        }else{\\n            let y = this.root[x];\\n            while(y !== this.root[y]){\\n                y = this.root[y];\\n            }\\n            this.root[x] = y;\\n            return this.root[x];\\n        }\\n    }\\n    union(x, y){\\n        let rootX = this.find(x);\\n        let rootY = this.find(y);\\n        if(rootX !== rootY){\\n            if(this.rank[rootY] < this.rank[rootX]){\\n                this.root[rootY] = rootX;\\n            }else if(this.rank[rootX] < this.rank[rootY]){\\n                this.root[rootX] = rootY;\\n            }else{\\n                this.root[rootY] = rootX;\\n                this.rank[rootX] += 1;\\n            }\\n        }\\n    }\\n}\\n\\n/**\\n *\\n */\\nfunction sortingFun(a, b){\\n    if(a > b){\\n        return 1;\\n    }else if(a < b){\\n        return -1;\\n    }else{\\n        return 0;\\n    }\\n}\\n\\n/**\\n * Let N be the length of string s.\\n * Time: O(N^2lgN)\\n * Space: O(3N) => O(N)\\n * @param {string} s\\n * @param {number[][]} pairs\\n * @return {string}\\n */\\nvar smallestStringWithSwaps = function(s, pairs) {\\n    // 1. Create disjoint sets of the all swappable indices.\\n    // T:O(N^2)\\n    let uf = new UnionFind(s.length);\\n    for(let [u, v] of pairs){\\n        uf.union(u,v);\\n    }\\n    \\n    // 2. Create an array of the swappable set of indices, with the index as the root number from the union find root array.\\n    // [list1,list2,...]\\n    // T: O(NlgN)\\n    let indexSwapSet = new Array(s.length);\\n    for(let i = 0; i < s.length; i++){\\n        if( i !== uf.root[i]){\\n            // Make sure the roots are compressed.\\n            uf.find(i);     // O(lgN)\\n        }\\n        let index = uf.root[i];\\n        if(indexSwapSet[index] === undefined){\\n            // If index location is not initialized.\\n            indexSwapSet[index] = [];\\n        }\\n        indexSwapSet[index].push(i);\\n    }\\n    \\n    // 3. Create a char array where it will be s modified with all the swapping in order to have the most lexicographically order we can get.\\n    // O(N^2lgN)\\n    let sSwap = new Array(s.length);\\n    for(let i = 0; i < s.length; i++){\\n        // Go through each set of swappable indices.\\n        if(indexSwapSet[i] !== undefined){\\n            // a. Create a char array with with a character in s corresponding to each index in the current set of indices we are in.\\n            let charSwapSet = [];\\n            for(let index of indexSwapSet[i]){\\n                charSwapSet.push(s[index]);\\n            }\\n            // b. Now sort the array.\\n            charSwapSet.sort(sortingFun);\\n            for(let j = 0; j < charSwapSet.length; j++){\\n                // c. Do the swap in our new char array.\\n                sSwap[indexSwapSet[i][j]] = charSwapSet[j]; \\n            }\\n        }\\n    }\\n    \\n    // Return char array transformed into a string.\\n    return sSwap.join(\\'\\');\\n};\\n```\\nEdit:\\nCorrected last two pictures",
                "solutionTags": [
                    "JavaScript",
                    "Union Find"
                ],
                "code": "```\\nclass UnionFind{\\n    constructor(size){\\n        this.root = new Array(size);\\n        this.rank = new Array(size);\\n        for(let i = 0; i < size; i++){\\n            this.root[i] = i;\\n            this.rank[i] = 1;\\n        }\\n    }\\n    find(x){\\n        if(this.root[x] === x){\\n            return x;\\n        }else{\\n            let y = this.root[x];\\n            while(y !== this.root[y]){\\n                y = this.root[y];\\n            }\\n            this.root[x] = y;\\n            return this.root[x];\\n        }\\n    }\\n    union(x, y){\\n        let rootX = this.find(x);\\n        let rootY = this.find(y);\\n        if(rootX !== rootY){\\n            if(this.rank[rootY] < this.rank[rootX]){\\n                this.root[rootY] = rootX;\\n            }else if(this.rank[rootX] < this.rank[rootY]){\\n                this.root[rootX] = rootY;\\n            }else{\\n                this.root[rootY] = rootX;\\n                this.rank[rootX] += 1;\\n            }\\n        }\\n    }\\n}\\n\\n/**\\n *\\n */\\nfunction sortingFun(a, b){\\n    if(a > b){\\n        return 1;\\n    }else if(a < b){\\n        return -1;\\n    }else{\\n        return 0;\\n    }\\n}\\n\\n/**\\n * Let N be the length of string s.\\n * Time: O(N^2lgN)\\n * Space: O(3N) => O(N)\\n * @param {string} s\\n * @param {number[][]} pairs\\n * @return {string}\\n */\\nvar smallestStringWithSwaps = function(s, pairs) {\\n    // 1. Create disjoint sets of the all swappable indices.\\n    // T:O(N^2)\\n    let uf = new UnionFind(s.length);\\n    for(let [u, v] of pairs){\\n        uf.union(u,v);\\n    }\\n    \\n    // 2. Create an array of the swappable set of indices, with the index as the root number from the union find root array.\\n    // [list1,list2,...]\\n    // T: O(NlgN)\\n    let indexSwapSet = new Array(s.length);\\n    for(let i = 0; i < s.length; i++){\\n        if( i !== uf.root[i]){\\n            // Make sure the roots are compressed.\\n            uf.find(i);     // O(lgN)\\n        }\\n        let index = uf.root[i];\\n        if(indexSwapSet[index] === undefined){\\n            // If index location is not initialized.\\n            indexSwapSet[index] = [];\\n        }\\n        indexSwapSet[index].push(i);\\n    }\\n    \\n    // 3. Create a char array where it will be s modified with all the swapping in order to have the most lexicographically order we can get.\\n    // O(N^2lgN)\\n    let sSwap = new Array(s.length);\\n    for(let i = 0; i < s.length; i++){\\n        // Go through each set of swappable indices.\\n        if(indexSwapSet[i] !== undefined){\\n            // a. Create a char array with with a character in s corresponding to each index in the current set of indices we are in.\\n            let charSwapSet = [];\\n            for(let index of indexSwapSet[i]){\\n                charSwapSet.push(s[index]);\\n            }\\n            // b. Now sort the array.\\n            charSwapSet.sort(sortingFun);\\n            for(let j = 0; j < charSwapSet.length; j++){\\n                // c. Do the swap in our new char array.\\n                sSwap[indexSwapSet[i][j]] = charSwapSet[j]; \\n            }\\n        }\\n    }\\n    \\n    // Return char array transformed into a string.\\n    return sSwap.join(\\'\\');\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1045966,
                "title": "javascript-simple-union-find-solution",
                "content": "```javascript\\nvar smallestStringWithSwaps = function(s, pairs) {\\n    const DS = [...Array(s.length)].map((_, i) => i);\\n    const group = new Map()\\n    const charMap = new Map();\\n    const result = [];\\n    \\n    function find(id) { \\n        if(id === DS[id]) return id;\\n        DS[id] = find(DS[id]);\\n        return DS[id];\\n    }\\n    \\n    for(let [u, v] of pairs) {\\n        const rootU = find(u);\\n        const rootV = find(v);\\n        DS[rootV] = rootU\\n    }\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        find(i)\\n        if(!charMap.has(s[i])) charMap.set(s[i], []);\\n        if(!group.has(DS[i])) group.set(DS[i], []);\\n        charMap.get(s[i]).push(i);\\n        group.get(DS[i]).push(i);\\n    }\\n    \\n    const charSorted = [...charMap.entries()].sort(([a], [b]) => a.charCodeAt() - b.charCodeAt());\\n    \\n    for(let [char, idxs] of charSorted) {\\n        for(let i of idxs) {\\n            const newIdx = group.get(DS[i]).shift();\\n            result[newIdx] = char;\\n        }\\n    }\\n    return result.join(\\'\\')\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Union Find"
                ],
                "code": "```javascript\\nvar smallestStringWithSwaps = function(s, pairs) {\\n    const DS = [...Array(s.length)].map((_, i) => i);\\n    const group = new Map()\\n    const charMap = new Map();\\n    const result = [];\\n    \\n    function find(id) { \\n        if(id === DS[id]) return id;\\n        DS[id] = find(DS[id]);\\n        return DS[id];\\n    }\\n    \\n    for(let [u, v] of pairs) {\\n        const rootU = find(u);\\n        const rootV = find(v);\\n        DS[rootV] = rootU\\n    }\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        find(i)\\n        if(!charMap.has(s[i])) charMap.set(s[i], []);\\n        if(!group.has(DS[i])) group.set(DS[i], []);\\n        charMap.get(s[i]).push(i);\\n        group.get(DS[i]).push(i);\\n    }\\n    \\n    const charSorted = [...charMap.entries()].sort(([a], [b]) => a.charCodeAt() - b.charCodeAt());\\n    \\n    for(let [char, idxs] of charSorted) {\\n        for(let i of idxs) {\\n            const newIdx = group.get(DS[i]).shift();\\n            result[newIdx] = char;\\n        }\\n    }\\n    return result.join(\\'\\')\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 570718,
                "title": "c-union-and-find-easy-understanding-code",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int find(int i,vector<int> &parent){\\n        if(parent[i]==-1) return i;\\n        return parent[i]=find(parent[i],parent);\\n    }\\n    \\n    void unio(int a,int b,vector<int> &parent){\\n        int xs=find(a,parent);\\n        int ys=find(b,parent);\\n        if(xs!=ys){\\n           parent[ys]=xs;\\n        }\\n    }\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        vector<int> parent(s.size(),-1);\\n        for(int i=0;i<pairs.size();i++){\\n            unio(pairs[i][0],pairs[i][1],parent);\\n        }\\n        \\n        unordered_map<int,vector<int> > mp;\\n        for(int i=0;i<parent.size();i++){\\n            mp[find(i,parent)].push_back(i);\\n        }\\n        \\n        for(auto m:mp){\\n            string st=\"\";\\n            for(auto v:m.second){\\n                st+=s[v];\\n            }\\n            sort(st.begin(),st.end());\\n            int j=0;\\n            for(auto i:m.second){\\n                s[i]=st[j++];\\n            }\\n        }\\n        return s;\\n        \\n    }\\n};\\n\\n//acdb\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int find(int i,vector<int> &parent){\\n        if(parent[i]==-1) return i;\\n        return parent[i]=find(parent[i],parent);\\n    }\\n    \\n    void unio(int a,int b,vector<int> &parent){\\n        int xs=find(a,parent);\\n        int ys=find(b,parent);\\n        if(xs!=ys){\\n           parent[ys]=xs;\\n        }\\n    }\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        vector<int> parent(s.size(),-1);\\n        for(int i=0;i<pairs.size();i++){\\n            unio(pairs[i][0],pairs[i][1],parent);\\n        }\\n        \\n        unordered_map<int,vector<int> > mp;\\n        for(int i=0;i<parent.size();i++){\\n            mp[find(i,parent)].push_back(i);\\n        }\\n        \\n        for(auto m:mp){\\n            string st=\"\";\\n            for(auto v:m.second){\\n                st+=s[v];\\n            }\\n            sort(st.begin(),st.end());\\n            int j=0;\\n            for(auto i:m.second){\\n                s[i]=st[j++];\\n            }\\n        }\\n        return s;\\n        \\n    }\\n};\\n\\n//acdb\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1986942,
                "title": "union-find-java",
                "content": "```\\nclass Solution {\\n    int[] parent;\\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        int n = s.length();\\n        parent = new int[n];\\n        StringBuilder sb = new StringBuilder(n);\\n        // initially consider all nodes as individual / separate nodes and to denote that we are having the same value\\n        // as the parent node\\n        for (int i = 0; i < n; ++i) {\\n            parent[i] = i;\\n        }\\n        // create a union b/w all the pairs using Conventional Disjoint method i.e having the immediate parent node as\\n        // the parent node instead of the root node\\n        for (List<Integer> pair : pairs) {\\n            union(pair.get(0), pair.get(1));\\n        }\\n        // Since, all the parent nodes draw down to the root node, we will be having a priority queue for each root\\n        // node. so that in each iteration, we will take the smallest lexicographic character from the PQ and append\\n        // it to the resultant string for that particular index\\n        Map<Integer, PriorityQueue<Character>> map = new HashMap<>();\\n        for (int i = 0; i < n; ++i) {\\n            int x = find(i);\\n            map.putIfAbsent(x, new PriorityQueue<>());\\n            map.get(x).offer(s.charAt(i));\\n        }\\n        // Now, finally after all the processing, for each index find the root index via the find method and poll the\\n        // corresponding character from it\\'s index and append it to the result\\n        for (int i = 0; i < n; ++i) {\\n            sb.append(map.get(find(i)).poll());\\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n    private int find(int x) {\\n        while (parent[x] != x) {\\n            x = parent[x];\\n        }\\n        return x;\\n    }\\n    \\n    private void union(int x, int y) {\\n        int xParent = find(x);\\n        int yParent = find(y);\\n        if (xParent < yParent) {\\n            parent[yParent] = xParent;\\n        } else {\\n            parent[xParent] = yParent;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    int[] parent;\\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        int n = s.length();\\n        parent = new int[n];\\n        StringBuilder sb = new StringBuilder(n);\\n        // initially consider all nodes as individual / separate nodes and to denote that we are having the same value\\n        // as the parent node\\n        for (int i = 0; i < n; ++i) {\\n            parent[i] = i;\\n        }\\n        // create a union b/w all the pairs using Conventional Disjoint method i.e having the immediate parent node as\\n        // the parent node instead of the root node\\n        for (List<Integer> pair : pairs) {\\n            union(pair.get(0), pair.get(1));\\n        }\\n        // Since, all the parent nodes draw down to the root node, we will be having a priority queue for each root\\n        // node. so that in each iteration, we will take the smallest lexicographic character from the PQ and append\\n        // it to the resultant string for that particular index\\n        Map<Integer, PriorityQueue<Character>> map = new HashMap<>();\\n        for (int i = 0; i < n; ++i) {\\n            int x = find(i);\\n            map.putIfAbsent(x, new PriorityQueue<>());\\n            map.get(x).offer(s.charAt(i));\\n        }\\n        // Now, finally after all the processing, for each index find the root index via the find method and poll the\\n        // corresponding character from it\\'s index and append it to the result\\n        for (int i = 0; i < n; ++i) {\\n            sb.append(map.get(find(i)).poll());\\n        }\\n        \\n        return sb.toString();\\n    }\\n    \\n    private int find(int x) {\\n        while (parent[x] != x) {\\n            x = parent[x];\\n        }\\n        return x;\\n    }\\n    \\n    private void union(int x, int y) {\\n        int xParent = find(x);\\n        int yParent = find(y);\\n        if (xParent < yParent) {\\n            parent[yParent] = xParent;\\n        } else {\\n            parent[xParent] = yParent;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 389005,
                "title": "java-dfs-solution",
                "content": "there are already a lot of solutions using Union Find.\\nI\\'ll write a DFS solution.\\n```\\nclass Solution {\\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        char[] array = s.toCharArray();\\n        boolean[] visited = new boolean[s.length()];\\n        List<Integer>[] graph = new List[s.length()];\\n        for(int i = 0 ; i < array.length ; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n        for(List<Integer> pair : pairs) {\\n            graph[pair.get(0)].add(pair.get(1));\\n            graph[pair.get(1)].add(pair.get(0));\\n        }\\n        for(int i = 0 ; i < array.length ; i++) {\\n            if(!visited[i]) {\\n                List<Integer> indexes = new ArrayList<>();\\n                List<Character> contents = new ArrayList<>();\\n                DFS(graph, array, indexes, contents, i, visited);\\n                Collections.sort(indexes);\\n                Collections.sort(contents);\\n                for(int j = 0 ; j < indexes.size() ; j++) {\\n                    array[indexes.get(j)] = contents.get(j);\\n                }\\n            }\\n        }\\n        return new String(array);\\n    }\\n    private void DFS(List<Integer>[] graph, char[] array, List<Integer> indexes, List<Character> contents, int start, boolean[] visited) {\\n        visited[start] = true;\\n        indexes.add(start);\\n        contents.add(array[start]);\\n        for(int child : graph[start]) {\\n            if(!visited[child]) {\\n                DFS(graph, array, indexes, contents, child, visited);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        char[] array = s.toCharArray();\\n        boolean[] visited = new boolean[s.length()];\\n        List<Integer>[] graph = new List[s.length()];\\n        for(int i = 0 ; i < array.length ; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n        for(List<Integer> pair : pairs) {\\n            graph[pair.get(0)].add(pair.get(1));\\n            graph[pair.get(1)].add(pair.get(0));\\n        }\\n        for(int i = 0 ; i < array.length ; i++) {\\n            if(!visited[i]) {\\n                List<Integer> indexes = new ArrayList<>();\\n                List<Character> contents = new ArrayList<>();\\n                DFS(graph, array, indexes, contents, i, visited);\\n                Collections.sort(indexes);\\n                Collections.sort(contents);\\n                for(int j = 0 ; j < indexes.size() ; j++) {\\n                    array[indexes.get(j)] = contents.get(j);\\n                }\\n            }\\n        }\\n        return new String(array);\\n    }\\n    private void DFS(List<Integer>[] graph, char[] array, List<Integer> indexes, List<Character> contents, int start, boolean[] visited) {\\n        visited[start] = true;\\n        indexes.add(start);\\n        contents.add(array[start]);\\n        for(int child : graph[start]) {\\n            if(!visited[child]) {\\n                DFS(graph, array, indexes, contents, child, visited);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1986936,
                "title": "java-c-python-javascript-kotlin-swift-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "***Hello it would be my pleasure to introduce myself Darian.***\\n\\n***Java***\\n```\\nclass Solution {\\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        int n = s.length();\\n        int[] parent = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }\\n        for (List<Integer> pair : pairs) {\\n            int left = getRoot(parent, pair.get(0));\\n            int right = getRoot(parent, pair.get(1));\\n            if (left != right) {\\n                parent[left] = right;\\n            }\\n        }\\n        \\n        Map<Integer, List<Integer>> groups = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            groups.computeIfAbsent(getRoot(parent, i), r -> new ArrayList<>()).add(i);\\n        }\\n        char[] res = s.toCharArray();\\n        for (List<Integer> group : groups.values()) {\\n\\n\\n            char[] chars = new char[group.size()];\\n            for (int i = 0; i < chars.length; i++) {\\n                chars[i] = s.charAt(group.get(i));\\n            }\\n            Arrays.sort(chars);\\n            for (int i = 0; i < chars.length; i++) {\\n                res[group.get(i)] = chars[i];\\n            }\\n            \\n        }\\n        return new String(res);\\n        \\n    }\\n```\\n\\n***JavaScript***\\n```\\nvar smallestStringWithSwaps = function(s, pairs) {\\nfunction DisjointSet(len) {\\nthis.par = [];\\nfor (let i = 0; i < len; ++i) {\\nthis.par[i] = i;\\n}\\n}\\nDisjointSet.prototype.find = function(u) {\\nreturn (this.par[u] = this.par[u] == u ? u : this.find(this.par[u]));\\n};\\n\\nDisjointSet.prototype.union = function(u, v) {\\nthis.par[this.find(u)] = this.find(v);\\n};\\n\\nconst ds = new DisjointSet(s.length);\\n\\npairs.forEach(p => ds.union(p[0], p[1]));\\n\\nconst _comp = (a, b) => (a == b ? 0 : a > b ? 1 : -1);\\n\\nconst arr = s.split(\"\");\\n\\nconst map = {};\\n\\nfor (let i = 0; i < s.length; ++i) {\\nconst p = ds.find(i);\\n(map[p] = map[p] || []).push(i);\\n}\\n\\nfor (const a of Object.values(map)) {\\nconst tmp = a.slice();\\na.sort((a, b) => _comp(s[a], s[b]));\\ntmp.forEach((t, idx) => (arr[t] = s[a[idx]]));\\n}\\n\\nreturn arr.join(\"\");\\n};\\n```\\n\\n***C++***\\n```\\nclass Solution {\\n    vector<int>parent; \\npublic:\\n    \\n    int findParent(int n){\\n        if(parent[n]==n){\\n            return n; \\n        }\\n        return parent[n] = findParent(parent[n]); \\n    }\\n    \\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        \\n        parent.resize(s.length());\\n        map<int , set<int>>obj;\\n        set<int>idx;\\n        string ans=s;\\n        \\n        \\n        for(int i=0; i<parent.size(); i++){\\n            parent[i]=i;\\n        }\\n        \\n        for(int i=0; i<pairs.size(); i++){\\n            int u = pairs[i][0];\\n            int v = pairs[i][1];\\n            int fx = findParent(u);\\n            int fy = findParent(v);\\n            \\n            if(fx!=fy){\\n                parent[fy]=fx; \\n            }\\n                 \\n        }\\n        for(int i=0; i<pairs.size(); i++){\\n            \\n            int u = pairs[i][0];\\n            int v = pairs[i][1];\\n            \\n            int fx = findParent(u);\\n            obj[fx].insert(u);\\n            obj[fx].insert(v);\\n              \\n        }\\n        \\n        for(auto it = obj.begin(); it!=obj.end(); it++){\\n            \\n            idx = it->second;\\n            vector<pair<char,int>>t; \\n            auto index=idx.begin(); \\n            \\n            for(index=idx.begin(); index!=idx.end(); index++){\\n                 \\n                 int pos = *index;\\n                 char ch = s[pos]; \\n                 t.push_back({ch,pos}); \\n            }\\n            \\n            sort(t.begin() , t.end()); \\n            index=idx.begin(); \\n            \\n            for(int i=0; i<t.size(); i++){ \\n                 \\n                ans[*index] = t[i].first;\\n                index++; \\n            } \\n        \\n        }\\n       \\n        return ans;\\n    }\\n};\\n```\\n\\n***Python***\\n```\\ndef smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        \\n        subsets = list(range(len(s)))\\n        \\n        def find(x):\\n            nonlocal subsets\\n            if x != subsets[x]:\\n                subsets[x] = find(subsets[x])\\n            return subsets[x]\\n        \\n        def union(x,y):\\n            nonlocal subsets\\n            s1 = find(x)\\n            s2 = find(y)\\n            subsets[s2] = s1\\n            \\n        for pair in pairs:\\n            union(pair[0],pair[1])\\n            \\n        components = defaultdict(list)\\n        alphabets = defaultdict(list)\\n        for i,v in enumerate(subsets):\\n\\t\\t\\tparent = find(v)\\n\\t\\t\\tcomponents[parent].append(i)\\n\\t\\t\\talphabets[parent].append(s[i])\\n        \\n# constructing the final output. Notice that the swaps can only affect the indexes in the connected component (subset). \\n        res = [None] * len(s)\\n        \\n        for cid in components.keys():\\n            indexes = components[cid]\\n            indexes.sort()\\n            chars = alphabets[cid]\\n            chars.sort()\\n            for i,j in zip(indexes,chars):\\n                res[i] = j\\n        \\n        return \\'\\'.join(res)\\n```\\n\\n***Kotlin***\\n```\\nclass Solution {\\n    fun smallestStringWithSwaps(s: String, pairs: List<List<Int>>): String {\\n        val lenS = s.length\\n        val uf = UnionFind(lenS)\\n        \\n        for(pair in pairs){\\n            uf.union(pair[0], pair[1])\\n        }\\n        \\n        val map = HashMap<Int, PriorityQueue<Char>>()\\n        for(idx in s.indices){\\n            val root = uf.find(idx)\\n            map.getOrPut(root){ PriorityQueue<Char>() }.add(s[idx])\\n        }\\n        \\n        val builder = StringBuilder()\\n        for(idx in s.indices){\\n            map[uf.find(idx)]?.let{\\n                builder.append(it.poll())\\n            }\\n        }\\n        return builder.toString()\\n    }\\n    \\n    private class UnionFind(isolated: Int) {\\n        private val roots = IntArray(isolated) { idx -> idx }\\n        private val ranks = IntArray(isolated) { 1 }\\n\\n        fun union(x: Int, y: Int) {\\n            val rootX = find(x)\\n            val rootY = find(y)\\n\\n            if (rootX == rootY) return\\n\\n            if (ranks[rootX] > ranks[rootY]) {\\n                roots[rootY] = rootX\\n                ++ranks[rootX]\\n            } else {\\n                roots[rootX] = rootY\\n                ++ranks[rootY]\\n            }\\n        }\\n\\n        fun find(x: Int): Int {\\n            if (roots[x] != x) {\\n                roots[x] = find(roots[x])\\n            }\\n\\n            return roots[x]\\n        }\\n    }\\n}\\n```\\n\\n***Swift***\\n```\\nclass Solution {\\n\\n    struct UnionFind {\\n        \\n        var parent: [Int]\\n        var rank: [Int]\\n        \\n        init(_ maxCount: Int) { \\n            parent = [Int](0..<maxCount)\\n            rank = [Int](repeating: 0, count: maxCount)\\n        }\\n        \\n        mutating func find(_ u: Int) -> Int {\\n            if parent[u] == u {\\n                return u\\n            }\\n            \\n            parent[u] = find(parent[u])\\n            return parent[u]\\n        }\\n        \\n        mutating func union(_ u: Int, _ v: Int) {\\n            let pu = find(u)\\n            let pv = find(v)\\n            \\n            if pu != pv {\\n                if rank[pu] > rank[pv] {\\n                    parent[pu] = parent[pv]\\n                } else {\\n                    parent[pv] = parent[pu]\\n                    rank[pu] += 1\\n                }\\n            }\\n        }\\n    }\\n    \\n    func smallestStringWithSwaps(_ s: String, _ pairs: [[Int]]) -> String {\\n        \\n        var uf = UnionFind(s.count)\\n        var group = [Int: Set<Int>]()\\n        \\n        for pair in pairs {\\n            let u = pair[0], v = pair[1]\\n            uf.union(u, v)\\n        }\\n        \\n        var chars = Array(s)\\n        var charsMap = [Int: [Character]]()\\n        var indexesMap = [Int: [Int]]()\\n        for i in 0..<chars.count {\\n            let root = uf.find(i)\\n            charsMap[root, default: [Character]()].append(chars[i])\\n            indexesMap[root, default: [Int]()].append(i)\\n        }\\n        \\n        for (key, value) in charsMap {\\n            var indice: [Int] = indexesMap[key] ?? []\\n            var sortedChars = value.sorted()\\n            for (idx, char) in zip(indice, sortedChars) {\\n                chars[idx] = char\\n            }\\n        }\\n        \\n        return String(chars)\\n    }\\n}\\n```\\n\\n***Consider upvote if useful! Hopefully it can be used in your advantage!***\\n***Take care brother, peace, love!***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        int n = s.length();\\n        int[] parent = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }\\n        for (List<Integer> pair : pairs) {\\n            int left = getRoot(parent, pair.get(0));\\n            int right = getRoot(parent, pair.get(1));\\n            if (left != right) {\\n                parent[left] = right;\\n            }\\n        }\\n        \\n        Map<Integer, List<Integer>> groups = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            groups.computeIfAbsent(getRoot(parent, i), r -> new ArrayList<>()).add(i);\\n        }\\n        char[] res = s.toCharArray();\\n        for (List<Integer> group : groups.values()) {\\n\\n\\n            char[] chars = new char[group.size()];\\n            for (int i = 0; i < chars.length; i++) {\\n                chars[i] = s.charAt(group.get(i));\\n            }\\n            Arrays.sort(chars);\\n            for (int i = 0; i < chars.length; i++) {\\n                res[group.get(i)] = chars[i];\\n            }\\n            \\n        }\\n        return new String(res);\\n        \\n    }\\n```\n```\\nvar smallestStringWithSwaps = function(s, pairs) {\\nfunction DisjointSet(len) {\\nthis.par = [];\\nfor (let i = 0; i < len; ++i) {\\nthis.par[i] = i;\\n}\\n}\\nDisjointSet.prototype.find = function(u) {\\nreturn (this.par[u] = this.par[u] == u ? u : this.find(this.par[u]));\\n};\\n\\nDisjointSet.prototype.union = function(u, v) {\\nthis.par[this.find(u)] = this.find(v);\\n};\\n\\nconst ds = new DisjointSet(s.length);\\n\\npairs.forEach(p => ds.union(p[0], p[1]));\\n\\nconst _comp = (a, b) => (a == b ? 0 : a > b ? 1 : -1);\\n\\nconst arr = s.split(\"\");\\n\\nconst map = {};\\n\\nfor (let i = 0; i < s.length; ++i) {\\nconst p = ds.find(i);\\n(map[p] = map[p] || []).push(i);\\n}\\n\\nfor (const a of Object.values(map)) {\\nconst tmp = a.slice();\\na.sort((a, b) => _comp(s[a], s[b]));\\ntmp.forEach((t, idx) => (arr[t] = s[a[idx]]));\\n}\\n\\nreturn arr.join(\"\");\\n};\\n```\n```\\nclass Solution {\\n    vector<int>parent; \\npublic:\\n    \\n    int findParent(int n){\\n        if(parent[n]==n){\\n            return n; \\n        }\\n        return parent[n] = findParent(parent[n]); \\n    }\\n    \\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        \\n        parent.resize(s.length());\\n        map<int , set<int>>obj;\\n        set<int>idx;\\n        string ans=s;\\n        \\n        \\n        for(int i=0; i<parent.size(); i++){\\n            parent[i]=i;\\n        }\\n        \\n        for(int i=0; i<pairs.size(); i++){\\n            int u = pairs[i][0];\\n            int v = pairs[i][1];\\n            int fx = findParent(u);\\n            int fy = findParent(v);\\n            \\n            if(fx!=fy){\\n                parent[fy]=fx; \\n            }\\n                 \\n        }\\n        for(int i=0; i<pairs.size(); i++){\\n            \\n            int u = pairs[i][0];\\n            int v = pairs[i][1];\\n            \\n            int fx = findParent(u);\\n            obj[fx].insert(u);\\n            obj[fx].insert(v);\\n              \\n        }\\n        \\n        for(auto it = obj.begin(); it!=obj.end(); it++){\\n            \\n            idx = it->second;\\n            vector<pair<char,int>>t; \\n            auto index=idx.begin(); \\n            \\n            for(index=idx.begin(); index!=idx.end(); index++){\\n                 \\n                 int pos = *index;\\n                 char ch = s[pos]; \\n                 t.push_back({ch,pos}); \\n            }\\n            \\n            sort(t.begin() , t.end()); \\n            index=idx.begin(); \\n            \\n            for(int i=0; i<t.size(); i++){ \\n                 \\n                ans[*index] = t[i].first;\\n                index++; \\n            } \\n        \\n        }\\n       \\n        return ans;\\n    }\\n};\\n```\n```\\ndef smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        \\n        subsets = list(range(len(s)))\\n        \\n        def find(x):\\n            nonlocal subsets\\n            if x != subsets[x]:\\n                subsets[x] = find(subsets[x])\\n            return subsets[x]\\n        \\n        def union(x,y):\\n            nonlocal subsets\\n            s1 = find(x)\\n            s2 = find(y)\\n            subsets[s2] = s1\\n            \\n        for pair in pairs:\\n            union(pair[0],pair[1])\\n            \\n        components = defaultdict(list)\\n        alphabets = defaultdict(list)\\n        for i,v in enumerate(subsets):\\n\\t\\t\\tparent = find(v)\\n\\t\\t\\tcomponents[parent].append(i)\\n\\t\\t\\talphabets[parent].append(s[i])\\n        \\n# constructing the final output. Notice that the swaps can only affect the indexes in the connected component (subset). \\n        res = [None] * len(s)\\n        \\n        for cid in components.keys():\\n            indexes = components[cid]\\n            indexes.sort()\\n            chars = alphabets[cid]\\n            chars.sort()\\n            for i,j in zip(indexes,chars):\\n                res[i] = j\\n        \\n        return \\'\\'.join(res)\\n```\n```\\nclass Solution {\\n    fun smallestStringWithSwaps(s: String, pairs: List<List<Int>>): String {\\n        val lenS = s.length\\n        val uf = UnionFind(lenS)\\n        \\n        for(pair in pairs){\\n            uf.union(pair[0], pair[1])\\n        }\\n        \\n        val map = HashMap<Int, PriorityQueue<Char>>()\\n        for(idx in s.indices){\\n            val root = uf.find(idx)\\n            map.getOrPut(root){ PriorityQueue<Char>() }.add(s[idx])\\n        }\\n        \\n        val builder = StringBuilder()\\n        for(idx in s.indices){\\n            map[uf.find(idx)]?.let{\\n                builder.append(it.poll())\\n            }\\n        }\\n        return builder.toString()\\n    }\\n    \\n    private class UnionFind(isolated: Int) {\\n        private val roots = IntArray(isolated) { idx -> idx }\\n        private val ranks = IntArray(isolated) { 1 }\\n\\n        fun union(x: Int, y: Int) {\\n            val rootX = find(x)\\n            val rootY = find(y)\\n\\n            if (rootX == rootY) return\\n\\n            if (ranks[rootX] > ranks[rootY]) {\\n                roots[rootY] = rootX\\n                ++ranks[rootX]\\n            } else {\\n                roots[rootX] = rootY\\n                ++ranks[rootY]\\n            }\\n        }\\n\\n        fun find(x: Int): Int {\\n            if (roots[x] != x) {\\n                roots[x] = find(roots[x])\\n            }\\n\\n            return roots[x]\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n\\n    struct UnionFind {\\n        \\n        var parent: [Int]\\n        var rank: [Int]\\n        \\n        init(_ maxCount: Int) { \\n            parent = [Int](0..<maxCount)\\n            rank = [Int](repeating: 0, count: maxCount)\\n        }\\n        \\n        mutating func find(_ u: Int) -> Int {\\n            if parent[u] == u {\\n                return u\\n            }\\n            \\n            parent[u] = find(parent[u])\\n            return parent[u]\\n        }\\n        \\n        mutating func union(_ u: Int, _ v: Int) {\\n            let pu = find(u)\\n            let pv = find(v)\\n            \\n            if pu != pv {\\n                if rank[pu] > rank[pv] {\\n                    parent[pu] = parent[pv]\\n                } else {\\n                    parent[pv] = parent[pu]\\n                    rank[pu] += 1\\n                }\\n            }\\n        }\\n    }\\n    \\n    func smallestStringWithSwaps(_ s: String, _ pairs: [[Int]]) -> String {\\n        \\n        var uf = UnionFind(s.count)\\n        var group = [Int: Set<Int>]()\\n        \\n        for pair in pairs {\\n            let u = pair[0], v = pair[1]\\n            uf.union(u, v)\\n        }\\n        \\n        var chars = Array(s)\\n        var charsMap = [Int: [Character]]()\\n        var indexesMap = [Int: [Int]]()\\n        for i in 0..<chars.count {\\n            let root = uf.find(i)\\n            charsMap[root, default: [Character]()].append(chars[i])\\n            indexesMap[root, default: [Int]()].append(i)\\n        }\\n        \\n        for (key, value) in charsMap {\\n            var indice: [Int] = indexesMap[key] ?? []\\n            var sortedChars = value.sorted()\\n            for (idx, char) in zip(indice, sortedChars) {\\n                chars[idx] = char\\n            }\\n        }\\n        \\n        return String(chars)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1729290,
                "title": "js-union-find-100",
                "content": "**Solution 1:**\\n\\n```\\nfunction smallestStringWithSwaps(s, pairs) {\\n    const unionFind = new UnionFind(s.length)\\n    pairs.forEach(([v1, v2]) => unionFind.union(v1, v2));\\n    \\n    const result = [];\\n    unionFind.disjointSets().forEach((idxs, root) => {\\n        const chars = idxs.map(idx => s[idx]);\\n        chars.sort();\\n        let i = 0;\\n        idxs.forEach(idx => {\\n            result[idx] = chars[i++];\\n        })\\n    })\\n    return result.join(\\'\\');\\n}\\n\\nclass UnionFind {\\n    constructor(n) {\\n        this.root = new Array(n).fill(null).map((x, idx) => idx);\\n        this.rank = new Array(n).fill(1);\\n        this.vertexCount = n;\\n    }\\n    find(v) {\\n        if(v === this.root[v]) {\\n            return v;\\n        }\\n        this.root[v] = this.find(this.root[v]);\\n        return this.root[v];\\n    }\\n    union(v1, v2) {\\n        const r1 = this.find(v1),\\n              r2 = this.find(v2);\\n        \\n        if(r1 === r2) {\\n            return;\\n        }\\n        if(this.rank[r1] > this.rank[r2]) {\\n            this.root[r2] = r1;\\n        } else if(this.rank[r1] < this.rank[r2]) {\\n            this.root[r1] = r2;\\n        } else {\\n            this.root[r2] = r1;\\n            this.rank[r1] += 1;\\n        }\\n    }\\n    disjointSets() {\\n        const map = new Map();\\n        for(let i = 0; i < this.vertexCount; ++i) {\\n            const root = this.find(i);\\n            const vtx = map.has(root) ? map.get(root) : [];\\n            vtx.push(i);\\n            map.set(root, vtx);\\n        }\\n        return map;\\n    }\\n}\\n```\\n\\n---\\n\\n**Solution 2:**\\n\\n```\\nfunction smallestStringWithSwaps(s, pairs) {\\n    const unionFind = new UnionFind(s.length)\\n    pairs.forEach(([v1, v2]) => unionFind.union(v1, v2));\\n    \\n    const result = [];\\n    unionFind.disjointSets().forEach((idxs, root) => {\\n        const alphas = new Array(26).fill(0);    // instead of using sort(), using bucket sort\\n        idxs.forEach(idx => {\\n            const aIdx = s.charCodeAt(idx) - 97;    // ASCII code of alphabet minus ASCII code of \\'a\\'\\n            ++alphas[aIdx];\\n        });\\n        let i = 0;\\n        idxs.forEach(idx => {\\n            while(!alphas[i]) {\\n                ++i;\\n            }\\n            --alphas[i];\\n            result[idx] = String.fromCharCode(i + 97);\\n        })\\n    })\\n    return result.join(\\'\\');\\n}\\n\\nclass UnionFind {\\n    constructor(n) {\\n        this.root = new Array(n).fill(null).map((x, idx) => idx);\\n        this.rank = new Array(n).fill(1);\\n        this.vertexCount = n;\\n    }\\n    find(v) {\\n        if(v === this.root[v]) {\\n            return v;\\n        }\\n        this.root[v] = this.find(this.root[v]);\\n        return this.root[v];\\n    }\\n    union(v1, v2) {\\n        const r1 = this.find(v1),\\n              r2 = this.find(v2);\\n        \\n        if(r1 === r2) {\\n            return;\\n        }\\n        if(this.rank[r1] > this.rank[r2]) {\\n            this.root[r2] = r1;\\n        } else if(this.rank[r1] < this.rank[r2]) {\\n            this.root[r1] = r2;\\n        } else {\\n            this.root[r2] = r1;\\n            this.rank[r1] += 1;\\n        }\\n    }\\n    disjointSets() {\\n        const map = new Map();\\n        for(let i = 0; i < this.vertexCount; ++i) {\\n            const root = this.find(i);\\n            const vtx = map.has(root) ? map.get(root) : [];\\n            vtx.push(i);\\n            map.set(root, vtx);\\n        }\\n        return map;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction smallestStringWithSwaps(s, pairs) {\\n    const unionFind = new UnionFind(s.length)\\n    pairs.forEach(([v1, v2]) => unionFind.union(v1, v2));\\n    \\n    const result = [];\\n    unionFind.disjointSets().forEach((idxs, root) => {\\n        const chars = idxs.map(idx => s[idx]);\\n        chars.sort();\\n        let i = 0;\\n        idxs.forEach(idx => {\\n            result[idx] = chars[i++];\\n        })\\n    })\\n    return result.join(\\'\\');\\n}\\n\\nclass UnionFind {\\n    constructor(n) {\\n        this.root = new Array(n).fill(null).map((x, idx) => idx);\\n        this.rank = new Array(n).fill(1);\\n        this.vertexCount = n;\\n    }\\n    find(v) {\\n        if(v === this.root[v]) {\\n            return v;\\n        }\\n        this.root[v] = this.find(this.root[v]);\\n        return this.root[v];\\n    }\\n    union(v1, v2) {\\n        const r1 = this.find(v1),\\n              r2 = this.find(v2);\\n        \\n        if(r1 === r2) {\\n            return;\\n        }\\n        if(this.rank[r1] > this.rank[r2]) {\\n            this.root[r2] = r1;\\n        } else if(this.rank[r1] < this.rank[r2]) {\\n            this.root[r1] = r2;\\n        } else {\\n            this.root[r2] = r1;\\n            this.rank[r1] += 1;\\n        }\\n    }\\n    disjointSets() {\\n        const map = new Map();\\n        for(let i = 0; i < this.vertexCount; ++i) {\\n            const root = this.find(i);\\n            const vtx = map.has(root) ? map.get(root) : [];\\n            vtx.push(i);\\n            map.set(root, vtx);\\n        }\\n        return map;\\n    }\\n}\\n```\n```\\nfunction smallestStringWithSwaps(s, pairs) {\\n    const unionFind = new UnionFind(s.length)\\n    pairs.forEach(([v1, v2]) => unionFind.union(v1, v2));\\n    \\n    const result = [];\\n    unionFind.disjointSets().forEach((idxs, root) => {\\n        const alphas = new Array(26).fill(0);    // instead of using sort(), using bucket sort\\n        idxs.forEach(idx => {\\n            const aIdx = s.charCodeAt(idx) - 97;    // ASCII code of alphabet minus ASCII code of \\'a\\'\\n            ++alphas[aIdx];\\n        });\\n        let i = 0;\\n        idxs.forEach(idx => {\\n            while(!alphas[i]) {\\n                ++i;\\n            }\\n            --alphas[i];\\n            result[idx] = String.fromCharCode(i + 97);\\n        })\\n    })\\n    return result.join(\\'\\');\\n}\\n\\nclass UnionFind {\\n    constructor(n) {\\n        this.root = new Array(n).fill(null).map((x, idx) => idx);\\n        this.rank = new Array(n).fill(1);\\n        this.vertexCount = n;\\n    }\\n    find(v) {\\n        if(v === this.root[v]) {\\n            return v;\\n        }\\n        this.root[v] = this.find(this.root[v]);\\n        return this.root[v];\\n    }\\n    union(v1, v2) {\\n        const r1 = this.find(v1),\\n              r2 = this.find(v2);\\n        \\n        if(r1 === r2) {\\n            return;\\n        }\\n        if(this.rank[r1] > this.rank[r2]) {\\n            this.root[r2] = r1;\\n        } else if(this.rank[r1] < this.rank[r2]) {\\n            this.root[r1] = r2;\\n        } else {\\n            this.root[r2] = r1;\\n            this.rank[r1] += 1;\\n        }\\n    }\\n    disjointSets() {\\n        const map = new Map();\\n        for(let i = 0; i < this.vertexCount; ++i) {\\n            const root = this.find(i);\\n            const vtx = map.has(root) ? map.get(root) : [];\\n            vtx.push(i);\\n            map.set(root, vtx);\\n        }\\n        return map;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 388924,
                "title": "c-union-find-algorithm-practice-in-2019",
                "content": "Sept. 23, 2019\\nI spent 30 minutes in weekly contest 155 on the algorithm first, and I continued to spend over an hour to complete the code on Sept. 23, 2019. I made a lot of errors, but I like the experience to solve the problem using union find algorithm.  My plan is to be able to solve it in less than 30 minutes in total in short future.\\n\\nHere are highlights.  \\n1. Understand union find algorithm, disjoint set, write findParent, union two APIs;\\n2. Do not mix parent[i] with findParent(int[] parent, int node), the latter one has path compression functionality. Do not call parent[i] directly, call findParent; \\n3. SortedSet is not applied, since same char can have multiple occurrences in one disjoint set;\\n4. Each disjoint set should be sorted first as a char array, and then push to Queue; \\n5. I ran into stack overflow bug, so I modified union function, replace parent[i] with findParent(int[] parent, int node);\\n6. Design variable disjointSets using Dictionary<int, List<char>>; SortedSet<char> is not working for duplicated chars in string test case, for example: \"abcmdem\", m has two occurrences. \\n7. Design sortedStrings using Dictionary<int, Queue<char>>; Queue is chosen since it is easy to iterate for each disjiont set. \\n\\nThe following code passes online judge, but I may have to review the code to simplify the code. \\n\\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Diagnostics;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace unionFind\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            RunTestcase1();\\n            //RunTestcase2(); \\n        }\\n\\n        public static void RunTestcase1()\\n        {\\n            var pairs = new List<IList<int>>(); \\n\\n            pairs.Add((new int[]{0, 3}).ToList()); \\n            pairs.Add((new int[]{1, 2}).ToList()); \\n\\n            var result = SmallestStringWithSwaps(\"dcab\", pairs); \\n            Debug.Assert(result.CompareTo(\"bacd\") == 0);\\n        }\\n\\n        public static void RunTestcase2()\\n        {\\n            var pairs = new List<IList<int>>();\\n\\n            pairs.Add((new int[] { 0, 3 }).ToList());\\n            pairs.Add((new int[] { 1, 2 }).ToList());\\n            pairs.Add((new int[] { 0, 2 }).ToList());\\n\\n            var result = SmallestStringWithSwaps(\"dcab\", pairs);\\n            Debug.Assert(result.CompareTo(\"abcd\") == 0);\\n        }\\n\\n        /// <summary>\\n        /// Leetcode 1202 - small string \\n        /// </summary>\\n        /// <param name=\"s\"></param>\\n        /// <param name=\"pairs\"></param>\\n        /// <returns></returns>\\n        public static string SmallestStringWithSwaps(string s, IList<IList<int>> pairs)\\n        {\\n            var length = s.Length;\\n            var parent = new int[length];\\n\\n            for (int i = 0; i < length; i++)\\n            {\\n                parent[i] = i;\\n            }\\n\\n            foreach (var pair in pairs)\\n            {\\n                var first = pair[0];\\n                var second = pair[1];\\n\\n                if (findParent(parent, first) != findParent(parent, second))\\n                {\\n                    // union two set; \\n                    union(parent, parent[first], parent[second]);\\n                }\\n            }\\n\\n            // allow duplicate char in string \\n            var disjointSets = new Dictionary<int, List<char>>();\\n\\n            for (int i = 0; i < length; i++)\\n            {\\n                var key = findParent(parent, i);\\n                if (!disjointSets.ContainsKey(key))\\n                {\\n                    disjointSets.Add(key, new List<char>());\\n                }\\n\\n                disjointSets[key].Add(s[i]); \\n            }\\n\\n            // sorting \\n            var sortedStrings = new Dictionary<int, Queue<char>>();\\n            foreach (var pair in disjointSets)\\n            {\\n                var list = pair.Value;\\n                var array = list.ToArray(); \\n                Array.Sort(array);\\n                var queue = new Queue<char>(); \\n                foreach(var item in array)\\n                    queue.Enqueue(item); \\n\\n                sortedStrings.Add(pair.Key, queue);\\n            }\\n\\n            var sb = new StringBuilder();\\n            for (int i = 0; i < length; i++)\\n            {\\n                var key = findParent(parent, i);\\n                var value = sortedStrings[key].Dequeue();\\n\\n                sb.Append(value);                \\n            }\\n\\n            return sb.ToString(); \\n        }\\n\\n        /// <summary>\\n        /// path compression\\n        /// </summary>\\n        /// <param name=\"parent\"></param>\\n        /// <param name=\"node\"></param>\\n        /// <returns></returns>\\n        private static int findParent(int[] parent, int node)\\n        {\\n            return node == parent[node] ? node : parent[node] = findParent(parent, parent[node]);\\n        }\\n\\n       /// <summary>\\n        /// Simplify API\\n        /// </summary>\\n        /// <param name=\"parent\"></param>\\n        /// <param name=\"first\"></param>\\n        /// <param name=\"second\"></param>\\n        private static void union(int[] parent, int first, int second)\\n        {\\n            var firstParent = findParent(parent, first);\\n            var secondParent = findParent(parent, second);\\n            if(firstParent == secondParent)\\n                return;\\n\\n            parent[firstParent] = secondParent;             \\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Diagnostics;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace unionFind\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            RunTestcase1();\\n            //RunTestcase2(); \\n        }\\n\\n        public static void RunTestcase1()\\n        {\\n            var pairs = new List<IList<int>>(); \\n\\n            pairs.Add((new int[]{0, 3}).ToList()); \\n            pairs.Add((new int[]{1, 2}).ToList()); \\n\\n            var result = SmallestStringWithSwaps(\"dcab\", pairs); \\n            Debug.Assert(result.CompareTo(\"bacd\") == 0);\\n        }\\n\\n        public static void RunTestcase2()\\n        {\\n            var pairs = new List<IList<int>>();\\n\\n            pairs.Add((new int[] { 0, 3 }).ToList());\\n            pairs.Add((new int[] { 1, 2 }).ToList());\\n            pairs.Add((new int[] { 0, 2 }).ToList());\\n\\n            var result = SmallestStringWithSwaps(\"dcab\", pairs);\\n            Debug.Assert(result.CompareTo(\"abcd\") == 0);\\n        }\\n\\n        /// <summary>\\n        /// Leetcode 1202 - small string \\n        /// </summary>\\n        /// <param name=\"s\"></param>\\n        /// <param name=\"pairs\"></param>\\n        /// <returns></returns>\\n        public static string SmallestStringWithSwaps(string s, IList<IList<int>> pairs)\\n        {\\n            var length = s.Length;\\n            var parent = new int[length];\\n\\n            for (int i = 0; i < length; i++)\\n            {\\n                parent[i] = i;\\n            }\\n\\n            foreach (var pair in pairs)\\n            {\\n                var first = pair[0];\\n                var second = pair[1];\\n\\n                if (findParent(parent, first) != findParent(parent, second))\\n                {\\n                    // union two set; \\n                    union(parent, parent[first], parent[second]);\\n                }\\n            }\\n\\n            // allow duplicate char in string \\n            var disjointSets = new Dictionary<int, List<char>>();\\n\\n            for (int i = 0; i < length; i++)\\n            {\\n                var key = findParent(parent, i);\\n                if (!disjointSets.ContainsKey(key))\\n                {\\n                    disjointSets.Add(key, new List<char>());\\n                }\\n\\n                disjointSets[key].Add(s[i]); \\n            }\\n\\n            // sorting \\n            var sortedStrings = new Dictionary<int, Queue<char>>();\\n            foreach (var pair in disjointSets)\\n            {\\n                var list = pair.Value;\\n                var array = list.ToArray(); \\n                Array.Sort(array);\\n                var queue = new Queue<char>(); \\n                foreach(var item in array)\\n                    queue.Enqueue(item); \\n\\n                sortedStrings.Add(pair.Key, queue);\\n            }\\n\\n            var sb = new StringBuilder();\\n            for (int i = 0; i < length; i++)\\n            {\\n                var key = findParent(parent, i);\\n                var value = sortedStrings[key].Dequeue();\\n\\n                sb.Append(value);                \\n            }\\n\\n            return sb.ToString(); \\n        }\\n\\n        /// <summary>\\n        /// path compression\\n        /// </summary>\\n        /// <param name=\"parent\"></param>\\n        /// <param name=\"node\"></param>\\n        /// <returns></returns>\\n        private static int findParent(int[] parent, int node)\\n        {\\n            return node == parent[node] ? node : parent[node] = findParent(parent, parent[node]);\\n        }\\n\\n       /// <summary>\\n        /// Simplify API\\n        /// </summary>\\n        /// <param name=\"parent\"></param>\\n        /// <param name=\"first\"></param>\\n        /// <param name=\"second\"></param>\\n        private static void union(int[] parent, int first, int second)\\n        {\\n            var firstParent = findParent(parent, first);\\n            var secondParent = findParent(parent, second);\\n            if(firstParent == secondParent)\\n                return;\\n\\n            parent[firstParent] = secondParent;             \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 387565,
                "title": "neat-python-union-find",
                "content": "```\\nclass Solution(object):\\n    def smallestStringWithSwaps(self, s, pairs):\\n        \"\"\"\\n        :type s: str\\n        :type pairs: List[List[int]]\\n        :rtype: str\\n        \"\"\"\\n        n=len(s)\\n        m=len(pairs)\\n        \\n        ## If string length is 1 or less, or if there are no swappable pairs, return original string\\n        if n<=1 or m==0: return s\\n        \\n        ## Parent array for storing group parent ids in union find\\n        ## For each node, traversing upward would lead to the group leader.\\n        ## All connected indices share the same group leader\\n        parent= [i for i in range(n) ] \\n        \\n        ## Returns the group leader index for the given index\\n        def find(i):\\n            pi = parent[i]\\n            while parent[pi] != pi :\\n                pi = parent[pi]\\n            parent[i] = pi\\n            return parent[i]\\n        \\n        ## Merges two indices into same group\\n        def union(i,j):\\n            pi=find(i)\\n            pj=find(j)\\n            if pi!=pj:\\n                parent[pj]=pi\\n        \\n        for index1,index2 in pairs:\\n            union(index1,index2)\\n\\n        ## Forming groups or connected components\\n        groups={}\\n        for index in range(n):\\n            leader = find(index)\\n            groups[leader] = groups.get(leader,[])\\n            groups[leader].append(s[index])\\n\\n        for leader in groups.keys():\\n            groups[leader].sort()\\n\\n        group_index={}\\n        result=\\'\\'\\n        for index in range(n):\\n            leader=find(index)\\n            group_index[leader]=group_index.get(leader,0)+1\\n            result+=groups[leader][group_index[leader]-1]\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def smallestStringWithSwaps(self, s, pairs):\\n        \"\"\"\\n        :type s: str\\n        :type pairs: List[List[int]]\\n        :rtype: str\\n        \"\"\"\\n        n=len(s)\\n        m=len(pairs)\\n        \\n        ## If string length is 1 or less, or if there are no swappable pairs, return original string\\n        if n<=1 or m==0: return s\\n        \\n        ## Parent array for storing group parent ids in union find\\n        ## For each node, traversing upward would lead to the group leader.\\n        ## All connected indices share the same group leader\\n        parent= [i for i in range(n) ] \\n        \\n        ## Returns the group leader index for the given index\\n        def find(i):\\n            pi = parent[i]\\n            while parent[pi] != pi :\\n                pi = parent[pi]\\n            parent[i] = pi\\n            return parent[i]\\n        \\n        ## Merges two indices into same group\\n        def union(i,j):\\n            pi=find(i)\\n            pj=find(j)\\n            if pi!=pj:\\n                parent[pj]=pi\\n        \\n        for index1,index2 in pairs:\\n            union(index1,index2)\\n\\n        ## Forming groups or connected components\\n        groups={}\\n        for index in range(n):\\n            leader = find(index)\\n            groups[leader] = groups.get(leader,[])\\n            groups[leader].append(s[index])\\n\\n        for leader in groups.keys():\\n            groups[leader].sort()\\n\\n        group_index={}\\n        result=\\'\\'\\n        for index in range(n):\\n            leader=find(index)\\n            group_index[leader]=group_index.get(leader,0)+1\\n            result+=groups[leader][group_index[leader]-1]\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1986190,
                "title": "disjoint-set-union-union-find-visualised-c-explained-with-comments",
                "content": "Suppose the swaps are `[[0, 1], [0, 2]]`. Then it is easy to see we can sort `a[0...2]` by something similar to bubble sort. In fact, we can assign `a[0...2]` to any permutation of `a[0...2]`. If we think of the swaps as edges connecting two nodes where each node `i` contain `s[i]`, then we can sort the characters in each connected component to make it lexicographically smallest. For example, if `s=\"acabe\"` and `swaps=[[0,3],[1,2],[1,4]]`, then the corresponding graph would be\\n![image](https://assets.leetcode.com/users/images/7c4acaa2-0ac1-4658-80c4-04abbeb2e0f5_1651053734.8236864.png)\\n\\nsorting each connected component yields\\n![image](https://assets.leetcode.com/users/images/750e7007-e0b9-4851-8cd5-03c168646029_1651054290.451362.png)\\n\\nWe can use Disjoint Set Union (DSU) to connect the nodes for each edge. Then add each character to the position\\'s representitive. Sorting each representitive\\'s list of characters by descending, then iterate the array again from the beginning, getting the last character in its representitive\\'s list (i.e. the smallest character available) and remove it from the list.\\n\\n```\\nclass Solution {\\n    \\npublic:\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        int n = s.size();\\n        vector<int> p(n); // parent array for DSU\\n        iota(p.begin(), p.end(), 0);\\n        function<int(int)> f = [&](int u) { return p[u] == u ? u : p[u] = f(p[u]); }; // find function for DSU\\n        for (auto i : pairs) {\\n            int u = i[0], v = i[1];\\n            u = f(u), v = f(v);\\n            p[u] = v; // connect the two nodes of current edge\\n        }\\n        vector<string> a(n); // list of characters of each representitive\\n        for (int i = 0; i < n; ++i) a[f(i)] += s[i];\\n        for (auto &i : a) sort(i.rbegin(), i.rend()); // sort descending for each representitive\\n        for (int i = 0; i < n; ++i) {\\n            s[i] = a[f(i)].back();\\n            a[f(i)].pop_back();\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    \\npublic:\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        int n = s.size();\\n        vector<int> p(n); // parent array for DSU\\n        iota(p.begin(), p.end(), 0);\\n        function<int(int)> f = [&](int u) { return p[u] == u ? u : p[u] = f(p[u]); }; // find function for DSU\\n        for (auto i : pairs) {\\n            int u = i[0], v = i[1];\\n            u = f(u), v = f(v);\\n            p[u] = v; // connect the two nodes of current edge\\n        }\\n        vector<string> a(n); // list of characters of each representitive\\n        for (int i = 0; i < n; ++i) a[f(i)] += s[i];\\n        for (auto &i : a) sort(i.rbegin(), i.rend()); // sort descending for each representitive\\n        for (int i = 0; i < n; ++i) {\\n            s[i] = a[f(i)].back();\\n            a[f(i)].pop_back();\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1986127,
                "title": "java-union-find-clean",
                "content": "```\\npublic String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        UnionFind unionFind = new UnionFind(s.length());\\n        pairs.forEach(pair -> unionFind.union(pair.get(0), pair.get(1)));\\n\\n        return createSmallestString(s, createComponents(s, unionFind), unionFind);\\n    }\\n\\n    private Map<Integer, PriorityQueue<Character>> createComponents(String s, UnionFind unionFind) {\\n        Map<Integer, PriorityQueue<Character>> components = new HashMap<>();\\n        for (int vertex = 0; vertex < s.length(); ++vertex) {\\n            int root = unionFind.find(vertex);\\n            components.putIfAbsent(root, new PriorityQueue<>());\\n            components.get(root).offer(s.charAt(vertex));\\n        }\\n        return components;\\n    }\\n\\n    private String createSmallestString(String s, Map<Integer, PriorityQueue<Character>> components, UnionFind unionFind) {\\n        StringBuilder smallest = new StringBuilder();\\n        for (int i = 0; i < s.length(); i++) {\\n            smallest.append(components.get(unionFind.find(i)).poll());\\n        }\\n        return smallest.toString();\\n    }\\n\\n    public static class UnionFind {\\n        private final int[] root;\\n\\n        public UnionFind(int count) {\\n            this.root = new int[count];\\n            for (int i = 0; i < count; ++i) {\\n                root[i] = i;\\n            }\\n        }\\n\\n        public int find(int node) {\\n            if (root[node] == node)\\n                return node;\\n            return root[node] = find(root[node]);\\n        }\\n\\n        public void union(int node1, int node2) {\\n            int root1 = find(node1);\\n            int root2 = find(node2);\\n            if (root1 >= root2)\\n                root[root2] = root1;\\n            else\\n                root[root1] = root2;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\npublic String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        UnionFind unionFind = new UnionFind(s.length());\\n        pairs.forEach(pair -> unionFind.union(pair.get(0), pair.get(1)));\\n\\n        return createSmallestString(s, createComponents(s, unionFind), unionFind);\\n    }\\n\\n    private Map<Integer, PriorityQueue<Character>> createComponents(String s, UnionFind unionFind) {\\n        Map<Integer, PriorityQueue<Character>> components = new HashMap<>();\\n        for (int vertex = 0; vertex < s.length(); ++vertex) {\\n            int root = unionFind.find(vertex);\\n            components.putIfAbsent(root, new PriorityQueue<>());\\n            components.get(root).offer(s.charAt(vertex));\\n        }\\n        return components;\\n    }\\n\\n    private String createSmallestString(String s, Map<Integer, PriorityQueue<Character>> components, UnionFind unionFind) {\\n        StringBuilder smallest = new StringBuilder();\\n        for (int i = 0; i < s.length(); i++) {\\n            smallest.append(components.get(unionFind.find(i)).poll());\\n        }\\n        return smallest.toString();\\n    }\\n\\n    public static class UnionFind {\\n        private final int[] root;\\n\\n        public UnionFind(int count) {\\n            this.root = new int[count];\\n            for (int i = 0; i < count; ++i) {\\n                root[i] = i;\\n            }\\n        }\\n\\n        public int find(int node) {\\n            if (root[node] == node)\\n                return node;\\n            return root[node] = find(root[node]);\\n        }\\n\\n        public void union(int node1, int node2) {\\n            int root1 = find(node1);\\n            int root2 = find(node2);\\n            if (root1 >= root2)\\n                root[root2] = root1;\\n            else\\n                root[root1] = root2;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1985633,
                "title": "c-union-find-priority-queue",
                "content": "The graph explore card has a section on Disjoint Set. It is fairly complicated to be honest. I went through it a while back and learned the basic algorithm, my template is below. But again, this is boilerplate and you are going to want to learn the algorithm before seeing my solution. \\n\\n```cs\\npublic class DSU {\\n\\tint[] root;\\n\\tint[] rank;\\n\\t\\n\\tpublic DSU(int n) {\\n\\t\\troot = new int[n];\\n\\t\\trank = new int[n];\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\troot[i] = i;\\n\\t\\t\\trank[i] = 1;\\n\\t\\t}\\n\\t}\\n\\t\\n\\tpublic int Find(int x) {\\n\\t\\tif (root[x] == x) {\\n\\t\\t\\treturn x;\\n\\t\\t}\\n\\t\\treturn root[x] = Find(root[x]);\\n\\t}\\n\\t\\n\\tpublic void Union(int x, int y) {\\n\\t\\tint rootX = Find(x);\\n\\t\\tint rootY = Find(y);\\n\\t\\tif (rootX == rootY) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif (rank[rootX] > rank[rootY]) {\\n\\t\\t\\troot[rootY] = rootX;\\n\\t\\t\\trank[rootX] += rank[rootY];\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\troot[rootX] = rootY;\\n\\t\\t\\trank[rootY] += rank[rootX];\\n\\t\\t}\\n\\t}\\n}\\n```\\n\\nBelow is my solution using DSU as a core component. The key insight being, that once if you can swap `A with B` and `B with C` then you can also swap `A with C`. You can actually arrange them in ***any*** order. Use this property to construct your connected components, all connected nodes get unioned. Then build the output string from left to right, find the connected component of the current character and pick the smallest unused characeter in the component. I used `PriorityQueue`s to store characters in sorted order within each connected component.\\n\\n```cs\\npublic string SmallestStringWithSwaps(string s, IList<IList<int>> pairs) {\\n\\tint n = s.Length;\\n\\tvar dsu = new DSU(n);\\n\\tforeach (var p in pairs) {\\n\\t\\tdsu.Union(p[0], p[1]);\\n\\t}\\n\\tvar pq = new PriorityQueue<char, char>[n];\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tint j = dsu.Find(i);\\n\\t\\tpq[j] ??= new PriorityQueue<char, char>();\\n\\t\\tpq[j].Enqueue(s[i], s[i]);\\n\\t}\\n\\tvar sb = new StringBuilder();\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tint j = dsu.Find(i);\\n\\t\\tsb.Append(pq[j].Dequeue());\\n\\t}\\n\\treturn sb.ToString();\\n}\\n```",
                "solutionTags": [
                    "Union Find",
                    "Heap (Priority Queue)"
                ],
                "code": "```cs\\npublic class DSU {\\n\\tint[] root;\\n\\tint[] rank;\\n\\t\\n\\tpublic DSU(int n) {\\n\\t\\troot = new int[n];\\n\\t\\trank = new int[n];\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\troot[i] = i;\\n\\t\\t\\trank[i] = 1;\\n\\t\\t}\\n\\t}\\n\\t\\n\\tpublic int Find(int x) {\\n\\t\\tif (root[x] == x) {\\n\\t\\t\\treturn x;\\n\\t\\t}\\n\\t\\treturn root[x] = Find(root[x]);\\n\\t}\\n\\t\\n\\tpublic void Union(int x, int y) {\\n\\t\\tint rootX = Find(x);\\n\\t\\tint rootY = Find(y);\\n\\t\\tif (rootX == rootY) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif (rank[rootX] > rank[rootY]) {\\n\\t\\t\\troot[rootY] = rootX;\\n\\t\\t\\trank[rootX] += rank[rootY];\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\troot[rootX] = rootY;\\n\\t\\t\\trank[rootY] += rank[rootX];\\n\\t\\t}\\n\\t}\\n}\\n```\n```cs\\npublic string SmallestStringWithSwaps(string s, IList<IList<int>> pairs) {\\n\\tint n = s.Length;\\n\\tvar dsu = new DSU(n);\\n\\tforeach (var p in pairs) {\\n\\t\\tdsu.Union(p[0], p[1]);\\n\\t}\\n\\tvar pq = new PriorityQueue<char, char>[n];\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tint j = dsu.Find(i);\\n\\t\\tpq[j] ??= new PriorityQueue<char, char>();\\n\\t\\tpq[j].Enqueue(s[i], s[i]);\\n\\t}\\n\\tvar sb = new StringBuilder();\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tint j = dsu.Find(i);\\n\\t\\tsb.Append(pq[j].Dequeue());\\n\\t}\\n\\treturn sb.ToString();\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1985482,
                "title": "o-n-time-o-n-space-python-counting-sort-variant",
                "content": "The first part of the solution is to identify the connected components in the graph formed by `pairs`.  This could be done by simple DFS. \\n\\nThen, we need to sort the characters in the original string, within the indices corresponding to each individual connected component. \\n\\nBut, instead of sorting indices naively, we can use a variation of a [counting sort](https://en.wikipedia.org/wiki/Counting_sort). \\n\\nThe idea is to traverse the indices, identifying which connected component each index belongs to. Each connected component is assigned a unique number (color). In the same loop, along with connected component identification, we gather all characters of the original string belonging to the indices of the connected component.\\n\\nAs the input charset is limited, we can use an array with the length of 26 for each connected component to store the counts of each character.\\n\\nHaving this data structure built (a map from cc_color -> array of char counts), we can iterate indices of the original string again. For each index we already know the color of the connected component it belongs to and we have the counts of the characters that comprise this connected component. So all that needs to be done is to pull the smallest character with non-zero count from the array (if traversing indices in the forward direction). Then decrease the count by one for this character and append this character to the result.\\n\\nThe overall time complexity is O(V + E). The space complexity is also O(V + E).\\n\\nHere is an example python code (not microoptimized):\\n\\n```python\\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        n = len(s)\\n        d = defaultdict(set)\\n        colors = [-1] * n  # connected component color for each index of `s`\\n        char_stack = []    # index is connected component color, value is array of length 26 \\n                           # counts of each character from `s` belonging to connected component\\n        \\n        for a,b in pairs: # building the adjacency lists\\n            d[a].add(b)\\n            d[b].add(a)\\n\\n        # finding a connected component and \\n        # collecting characters into counters\\n        def rec(i, color):\\n            if colors[i] != -1:\\n                return\\n            colors[i] = color\\n            char_stack[color][ord(s[i]) - ord(\\'a\\')] += 1\\n            for j in d[i]:\\n                rec(j, color)\\n\\n        # marking components with colors\\n        for i in range(n):\\n            if colors[i] == -1:\\n                char_stack.append([0] * 26)\\n                color = len(char_stack) - 1 \\n                rec(i, color)\\n\\n        # result (can be replaced by a stringbuilder/buffer)\\n        res = [None] * n\\n        \\n        # traversing indices in backward order\\n        # to efficiently manipulate the arrays with counts, see below\\n        for i in range(n)[::-1]:            \\n            cnts = char_stack[colors[i]]\\n            \\n            # minor optimization: remove the empty counters\\n            while cnts[-1] == 0:\\n                cnts.pop()\\n            \\n            # reduce the counter by one\\n            cnts[-1] -= 1\\n            \\n            # append the char from the previously non-empty counter to the result\\n            res[i] = chr(ord(\\'a\\') + len(cnts) - 1)\\n        \\n        return \\'\\'.join(res)\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        n = len(s)\\n        d = defaultdict(set)\\n        colors = [-1] * n  # connected component color for each index of `s`\\n        char_stack = []    # index is connected component color, value is array of length 26 \\n                           # counts of each character from `s` belonging to connected component\\n        \\n        for a,b in pairs: # building the adjacency lists\\n            d[a].add(b)\\n            d[b].add(a)\\n\\n        # finding a connected component and \\n        # collecting characters into counters\\n        def rec(i, color):\\n            if colors[i] != -1:\\n                return\\n            colors[i] = color\\n            char_stack[color][ord(s[i]) - ord(\\'a\\')] += 1\\n            for j in d[i]:\\n                rec(j, color)\\n\\n        # marking components with colors\\n        for i in range(n):\\n            if colors[i] == -1:\\n                char_stack.append([0] * 26)\\n                color = len(char_stack) - 1 \\n                rec(i, color)\\n\\n        # result (can be replaced by a stringbuilder/buffer)\\n        res = [None] * n\\n        \\n        # traversing indices in backward order\\n        # to efficiently manipulate the arrays with counts, see below\\n        for i in range(n)[::-1]:            \\n            cnts = char_stack[colors[i]]\\n            \\n            # minor optimization: remove the empty counters\\n            while cnts[-1] == 0:\\n                cnts.pop()\\n            \\n            # reduce the counter by one\\n            cnts[-1] -= 1\\n            \\n            # append the char from the previously non-empty counter to the result\\n            res[i] = chr(ord(\\'a\\') + len(cnts) - 1)\\n        \\n        return \\'\\'.join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1985467,
                "title": "short-c-code-union-find",
                "content": "class Solution {\\npublic:\\n    \\n    int findParent(int a,vector<int> &parent)\\n    {\\n        if(a == parent[a]) return a;\\n        \\n        return parent[a] = findParent(parent[a],parent);\\n    }\\n    \\n    string smallestStringWithSwaps(string str, vector<vector<int>>& pairs) {\\n        \\n        int n = str.size();\\n        vector<int> parent(n,0);\\n        \\n        for(int i = 0;i<n;i++){\\n            parent[i] = i;\\n        }\\n        \\n        for(auto x: pairs){\\n            int u = x[0];\\n            int v = x[1];\\n            \\n            int p1 = findParent(u,parent);\\n            int p2 = findParent(v,parent);\\n            \\n            if(p1!=p2)\\n                parent[p1] = p2;\\n        }\\n        \\n        vector<vector<int>> v(n);\\n        for(int i = 0;i<n;i++){\\n            int u = findParent(i,parent);\\n            \\n            v[u].push_back(i);\\n        }\\n      \\n        for(auto x: v){\\n            string ss;int j = 0;\\n            \\n            for(auto y : x){\\n                ss += str[y];\\n            }\\n            \\n            sort(ss.begin(),ss.end());\\n            \\n            for(auto y: x){\\n                str[y] = ss[j++];\\n            }\\n            \\n        }\\n        \\n        return str;\\n    \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int findParent(int a,vector<int> &parent)\\n    {\\n        if(a == parent[a]) return a;\\n        \\n        return parent[a] = findParent(parent[a],parent);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1985417,
                "title": "easy-python-solution-union-find-explanation-faster-than-94-67",
                "content": "Before all the code, let\\'s just understand what is disjoint set/union find data structure.\\nhttps://leetcode.com/explore/featured/card/graph/618/disjoint-set/3881/\\n<br />\\n\\n**Simple Union Find code with comment explanations**\\n> Runtime: 691 ms, faster than 94.67% of Python3 online submissions for Smallest String With Swaps.\\nMemory Usage: 50.4 MB, less than 93.45% of Python3 online submissions for Smallest String With Swaps.\\n\\n```python\\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        # Start of Union Find Data Structure\\n        p = list(range(len(s)))  # parent\\n        # each element in the pairs == node\\n        # used to store each node\\'s parent based on its index\\n        # eg. pairs = [[0,3],[1,2]], p = [0, 1, 1, 0]\\n        # element 3 in pairs == p index 3 == 0 (because parent node of 3 is 0)\\n\\n        def find(x):\\n            if x != p[x]:\\n                p[x] = find(p[x])\\n            return p[x]\\n\\n        def union(x, y):\\n            px = find(x)\\n            py = find(y)\\n            if px != py:\\n                p[py] = px\\n                \\n        # End of Union Find Data Structure\\n\\n        # Grouping\\n        for x, y in pairs:\\n            union(x, y)\\n\\n        dic = defaultdict(list)\\n        for idx, el in enumerate(p):\\n            dic[find(el)].append(idx)\\n        \\n        # eg. pairs = [[0,3],[1,2]], dic = {0: [0, 3], 1: [1, 2]}\\n\\n        # Sorting\\n        res = list(s)\\n        for key in dic.keys():\\n            idx_list = dic[key]\\n            char_list = [s[i] for i in idx_list]\\n            char_list.sort()\\n\\n            # eg. idx_list = [0, 3], char_list = [b, d]\\n            # for loop below, idx = [0, b], char = [3, d]\\n            for idx, char in zip(idx_list, char_list):\\n                res[idx] = char\\n\\n        return \"\".join(res)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Union Find"
                ],
                "code": "```python\\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        # Start of Union Find Data Structure\\n        p = list(range(len(s)))  # parent\\n        # each element in the pairs == node\\n        # used to store each node\\'s parent based on its index\\n        # eg. pairs = [[0,3],[1,2]], p = [0, 1, 1, 0]\\n        # element 3 in pairs == p index 3 == 0 (because parent node of 3 is 0)\\n\\n        def find(x):\\n            if x != p[x]:\\n                p[x] = find(p[x])\\n            return p[x]\\n\\n        def union(x, y):\\n            px = find(x)\\n            py = find(y)\\n            if px != py:\\n                p[py] = px\\n                \\n        # End of Union Find Data Structure\\n\\n        # Grouping\\n        for x, y in pairs:\\n            union(x, y)\\n\\n        dic = defaultdict(list)\\n        for idx, el in enumerate(p):\\n            dic[find(el)].append(idx)\\n        \\n        # eg. pairs = [[0,3],[1,2]], dic = {0: [0, 3], 1: [1, 2]}\\n\\n        # Sorting\\n        res = list(s)\\n        for key in dic.keys():\\n            idx_list = dic[key]\\n            char_list = [s[i] for i in idx_list]\\n            char_list.sort()\\n\\n            # eg. idx_list = [0, 3], char_list = [b, d]\\n            # for loop below, idx = [0, b], char = [3, d]\\n            for idx, char in zip(idx_list, char_list):\\n                res[idx] = char\\n\\n        return \"\".join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1985092,
                "title": "java-solution-99-faster",
                "content": "```\\nclass Solution {\\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        int n = s.length();\\n        int[] parent = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }\\n        for (List<Integer> pair : pairs) {\\n            int left = getRoot(parent, pair.get(0));\\n            int right = getRoot(parent, pair.get(1));\\n            if (left != right) {\\n                parent[left] = right;\\n            }\\n        }\\n        \\n        Map<Integer, List<Integer>> groups = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            groups.computeIfAbsent(getRoot(parent, i), r -> new ArrayList<>()).add(i);\\n        }\\n        char[] res = s.toCharArray();\\n        for (List<Integer> group : groups.values()) {\\n\\n\\n            char[] chars = new char[group.size()];\\n            for (int i = 0; i < chars.length; i++) {\\n                chars[i] = s.charAt(group.get(i));\\n            }\\n            Arrays.sort(chars);\\n            for (int i = 0; i < chars.length; i++) {\\n                res[group.get(i)] = chars[i];\\n            }\\n            \\n        }\\n        return new String(res);\\n        \\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        int n = s.length();\\n        int[] parent = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }\\n        for (List<Integer> pair : pairs) {\\n            int left = getRoot(parent, pair.get(0));\\n            int right = getRoot(parent, pair.get(1));\\n            if (left != right) {\\n                parent[left] = right;\\n            }\\n        }\\n        \\n        Map<Integer, List<Integer>> groups = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            groups.computeIfAbsent(getRoot(parent, i), r -> new ArrayList<>()).add(i);\\n        }\\n        char[] res = s.toCharArray();\\n        for (List<Integer> group : groups.values()) {\\n\\n\\n            char[] chars = new char[group.size()];\\n            for (int i = 0; i < chars.length; i++) {\\n                chars[i] = s.charAt(group.get(i));\\n            }\\n            Arrays.sort(chars);\\n            for (int i = 0; i < chars.length; i++) {\\n                res[group.get(i)] = chars[i];\\n            }\\n            \\n        }\\n        return new String(res);\\n        \\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1697240,
                "title": "python-3-union-find-clean-code-with-comments-and-example",
                "content": "At first, I didn\\'t know how to solve the problem, but after visualizing the problem as a graph it made sense.\\n1. You need to think about **pairs that are connected directly and indirectly**\\n2. **Connect** these pairs into  **components** using **union find** data structure.\\n3. **Add** **character** at index` i` into the component of root`find(i)`\\n4. **Sort** each component\\n5. Add the characters at index `i` with the **smallest character in that component**\\nExample:\\n```\\ns=\"zdcyxbwa\"\\npairs=[[0,3],[4,6],[3,4],[1,7],[2,5],[5,7]]\\n```\\nIf you used union find, you will have two components as in the following picture, sort each component and then take characters in a sorted order using the find method\\n![image](https://assets.leetcode.com/users/images/cce88742-44fb-4508-8d4f-be2749af5da3_1642428017.8461666.png)\\n\\n\\n\\n```\\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        class UnionFind:\\n            def __init__(self,size):\\n                self.root=list(range(size))\\n            def find(self,x):\\n                if self.root[x]==x:\\n                    return x\\n                self.root[x]=self.find(self.root[x])\\n                return self.root[x]\\n            def union(self,x,y):\\n                root_x=self.find(x)\\n                root_y=self.find(y)\\n                if root_x!=root_y:\\n                    self.root[root_x]=root_y\\n        union_find=UnionFind(len(s))\\n\\t\\t# Step 1&2: Connect pairs into components\\n        for pair in pairs:\\n            union_find.union(pair[0],pair[1])\\n        component=defaultdict(list)\\n\\t\\t#Step 3: Add character into it\\'s root component\\n        for i in range(len(s)):\\n            component[union_find.find(i)].append(s[i])\\n\\t\\t#Step 4:Sort each component\\n        for key in component:\\n            component[key].sort(reverse=True)\\n\\t\\t#Step 5:Take the smallest character from component find(i) into the i\\'th index\\n        return \"\".join([component[union_find.find(i)].pop() for i in range(len(s))])\\n```\\nThanks to @votrubac for the picture and the example\\n    Runtime: O(n log n)\\n    Memory: O(n)\\nIf you find it helpful, don\\'t forget to **Upvote**",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\ns=\"zdcyxbwa\"\\npairs=[[0,3],[4,6],[3,4],[1,7],[2,5],[5,7]]\\n```\n```\\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        class UnionFind:\\n            def __init__(self,size):\\n                self.root=list(range(size))\\n            def find(self,x):\\n                if self.root[x]==x:\\n                    return x\\n                self.root[x]=self.find(self.root[x])\\n                return self.root[x]\\n            def union(self,x,y):\\n                root_x=self.find(x)\\n                root_y=self.find(y)\\n                if root_x!=root_y:\\n                    self.root[root_x]=root_y\\n        union_find=UnionFind(len(s))\\n\\t\\t# Step 1&2: Connect pairs into components\\n        for pair in pairs:\\n            union_find.union(pair[0],pair[1])\\n        component=defaultdict(list)\\n\\t\\t#Step 3: Add character into it\\'s root component\\n        for i in range(len(s)):\\n            component[union_find.find(i)].append(s[i])\\n\\t\\t#Step 4:Sort each component\\n        for key in component:\\n            component[key].sort(reverse=True)\\n\\t\\t#Step 5:Take the smallest character from component find(i) into the i\\'th index\\n        return \"\".join([component[union_find.find(i)].pop() for i in range(len(s))])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1505022,
                "title": "java-45ms-intuition-explanation",
                "content": "**The main idea is : to get the lexicographically smallest string, smaller alphabets have to be assigned to smaller indices using the swap operations.**\\n    \\nFirst, we need to identify the group of elements, among which i can perform swap operations. \\n\\nLet\\'s say you are given, (1,0), (0,2), (4,2), (5,3) as pairs, get a pen and paper, and connect the indices that can be swaped using a semicircle like line and you will quickly observe, that **groups of connected components are being formed.** --> We could use Union Find.\\n    \\n   **Each index within a connected component can be swapped with every other another index due to unlimted amount of swap operations. [V.IMP]**\\n   \\n   Now you can notice, that if we take all characters contained in a component, sort them and then assign it to the \\n    indices contained in the component, we are essentially assigning lower alphabets to lower indices generating the answer.\\n    \\t\\n\\tNote: Since UF uses path compression, union, find are amortized constant time.\\n\\t\\n\\tn - string length\\n\\tm - number of pairs.\\n\\t\\n    Algo\\n    1. Create a general UF impl - O(n)\\n    2. Form connected components: iterate through the pairs, treating each pair as an edge, perform union of the 2 nodes connected by the edge. - O(m)\\n    3. Create a hashmap, storing mapping : component root -> priority queue of characters contained in the connected component represented by that root.\\n    - O(1)\\n    4. iterate through 0:n-1, here each node is essentially a index, so retrieve the character, find the root of node, \\n    add the character in the queue for that root. - O(nlogn)\\n    5. Now, again iterate through 0:n-1, retrieve the root of each node, use the root to retrieve queue, then remove the item from the queue and assign it to the current index. - O(nlogn)\\n    \\n    Total TC : n+m+nlogn+nlogn = n+m+2nlogn\\n    Total SC : O(n), all queues will have only n items, UF impl stores n items in its internal array.\\n```\\nclass Solution {\\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        int n = s.length();\\n        //Step1: Create UF\\n        UnionFind uf = new UnionFind(n);\\n        //Step2: create connected components\\n        for (List<Integer> edge : pairs) {\\n            uf.union(edge.get(0), edge.get(1));\\n        }\\n        //Step3 : Create map\\n        HashMap<Integer, PriorityQueue<Character>> componentMap = new HashMap<>();\\n        //Step4 : populate the map\\n        for (int i=0; i<n; i++) {\\n            int rootNode = uf.find(i);\\n            componentMap.putIfAbsent(rootNode, new PriorityQueue<>((ch1, ch2)->ch1-ch2));\\n            componentMap.get(rootNode).add(s.charAt(i));\\n        }\\n        //Step5 : construct the answer using the map\\n        StringBuilder sbr = new StringBuilder(\"\");\\n        for (int i=0; i<n; i++) {\\n            int rootNode = uf.find(i);\\n            sbr.append(componentMap.get(rootNode).remove());\\n        }\\n        return sbr.toString();\\n    }\\n    \\n    private static class UnionFind {\\n        private int numComponents;\\n        private int[] sz;\\n        private int[] root;\\n        \\n        UnionFind(int n) {\\n            root = new int[n];\\n            sz = new int[n];\\n            numComponents = n;\\n            for (int i=0; i<n; i++) {\\n                root[i] = i;\\n                sz[i] = 1;\\n            }\\n        }\\n        \\n        public int find(int node) {\\n            int pointer  = node;\\n            while (root[pointer] != pointer) {\\n                pointer = root[pointer];\\n            }\\n            int rootNode = pointer;\\n            pointer = node;\\n            while (pointer != rootNode) {\\n                int next = root[pointer];\\n                root[pointer] = rootNode;\\n                pointer = next;\\n            }\\n            return rootNode;\\n        }\\n        \\n        public void union(int node1, int node2) {\\n            int root1 = find(node1);\\n            int root2 = find(node2);\\n            \\n            if (root1 == root2) return;\\n            \\n            if (sz[root1] >= sz[root2]) {\\n                root[root2] = root1;\\n                sz[root1] = sz[root1] + sz[root2];\\n            } else {\\n                root[root1] = root2;\\n                sz[root2] = sz[root2] + sz[root1];\\n            }\\n            numComponents--;\\n        }\\n        \\n        public int getNumComponents() {\\n            return numComponents;\\n        }\\n    } \\n    \\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        int n = s.length();\\n        //Step1: Create UF\\n        UnionFind uf = new UnionFind(n);\\n        //Step2: create connected components\\n        for (List<Integer> edge : pairs) {\\n            uf.union(edge.get(0), edge.get(1));\\n        }\\n        //Step3 : Create map\\n        HashMap<Integer, PriorityQueue<Character>> componentMap = new HashMap<>();\\n        //Step4 : populate the map\\n        for (int i=0; i<n; i++) {\\n            int rootNode = uf.find(i);\\n            componentMap.putIfAbsent(rootNode, new PriorityQueue<>((ch1, ch2)->ch1-ch2));\\n            componentMap.get(rootNode).add(s.charAt(i));\\n        }\\n        //Step5 : construct the answer using the map\\n        StringBuilder sbr = new StringBuilder(\"\");\\n        for (int i=0; i<n; i++) {\\n            int rootNode = uf.find(i);\\n            sbr.append(componentMap.get(rootNode).remove());\\n        }\\n        return sbr.toString();\\n    }\\n    \\n    private static class UnionFind {\\n        private int numComponents;\\n        private int[] sz;\\n        private int[] root;\\n        \\n        UnionFind(int n) {\\n            root = new int[n];\\n            sz = new int[n];\\n            numComponents = n;\\n            for (int i=0; i<n; i++) {\\n                root[i] = i;\\n                sz[i] = 1;\\n            }\\n        }\\n        \\n        public int find(int node) {\\n            int pointer  = node;\\n            while (root[pointer] != pointer) {\\n                pointer = root[pointer];\\n            }\\n            int rootNode = pointer;\\n            pointer = node;\\n            while (pointer != rootNode) {\\n                int next = root[pointer];\\n                root[pointer] = rootNode;\\n                pointer = next;\\n            }\\n            return rootNode;\\n        }\\n        \\n        public void union(int node1, int node2) {\\n            int root1 = find(node1);\\n            int root2 = find(node2);\\n            \\n            if (root1 == root2) return;\\n            \\n            if (sz[root1] >= sz[root2]) {\\n                root[root2] = root1;\\n                sz[root1] = sz[root1] + sz[root2];\\n            } else {\\n                root[root1] = root2;\\n                sz[root2] = sz[root2] + sz[root1];\\n            }\\n            numComponents--;\\n        }\\n        \\n        public int getNumComponents() {\\n            return numComponents;\\n        }\\n    } \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1501837,
                "title": "clean-and-efficient-python3-solution-using-the-unionfind-paradigm",
                "content": "Key of this solution is the realization that if a collection of characters are connected, any permutation of those characters is possible from that so we take the lexicographically sorted one from those and move on. \\n\\n```\\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n\\n        num_nodes = len(s)\\n        self.uf = UnionFind(num_nodes)\\n        for i,j in pairs:\\n            self.uf.union(i,j)\\n        \\n        indexes_by_root = {}\\n        chars_by_root = {}\\n        for i in range(num_nodes):\\n            root = self.uf.find(i)\\n            if root not in indexes_by_root:\\n                indexes_by_root[root] = [i]\\n                chars_by_root[root] = [s[i]]\\n            else:\\n                indexes_by_root[root].append(i)\\n                chars_by_root[root].append(s[i])\\n        \\n        result = [None] * num_nodes\\n        for root in indexes_by_root:\\n            sorted_characters = sorted(chars_by_root[root])\\n            for index, slot in enumerate(indexes_by_root[root]):\\n                result[slot] = sorted_characters[index]\\n                \\n        result = \\'\\'.join(result)\\n        return result\\n\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n        self.rank = [1] * n\\n        \\n        return\\n    \\n    def find(self, x):\\n        if x == self.parent[x]:\\n            return x\\n        else:\\n            self.parent[x] = self.find(self.parent[x])\\n            return self.parent[x]\\n    \\n    def union(self, x, y):\\n        parent_x = self.find(x)\\n        parent_y = self.find(y)\\n        if parent_x != parent_y:\\n            if self.rank[parent_x]>=self.rank[parent_y]:\\n                self.parent[parent_y] = parent_x\\n                self.rank[parent_x] += self.rank[parent_y]\\n            else:\\n                self.parent[parent_x] = parent_y\\n                self.rank[parent_y] += self.rank[parent_x]\\n                \\n        return\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n\\n        num_nodes = len(s)\\n        self.uf = UnionFind(num_nodes)\\n        for i,j in pairs:\\n            self.uf.union(i,j)\\n        \\n        indexes_by_root = {}\\n        chars_by_root = {}\\n        for i in range(num_nodes):\\n            root = self.uf.find(i)\\n            if root not in indexes_by_root:\\n                indexes_by_root[root] = [i]\\n                chars_by_root[root] = [s[i]]\\n            else:\\n                indexes_by_root[root].append(i)\\n                chars_by_root[root].append(s[i])\\n        \\n        result = [None] * num_nodes\\n        for root in indexes_by_root:\\n            sorted_characters = sorted(chars_by_root[root])\\n            for index, slot in enumerate(indexes_by_root[root]):\\n                result[slot] = sorted_characters[index]\\n                \\n        result = \\'\\'.join(result)\\n        return result\\n\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n        self.rank = [1] * n\\n        \\n        return\\n    \\n    def find(self, x):\\n        if x == self.parent[x]:\\n            return x\\n        else:\\n            self.parent[x] = self.find(self.parent[x])\\n            return self.parent[x]\\n    \\n    def union(self, x, y):\\n        parent_x = self.find(x)\\n        parent_y = self.find(y)\\n        if parent_x != parent_y:\\n            if self.rank[parent_x]>=self.rank[parent_y]:\\n                self.parent[parent_y] = parent_x\\n                self.rank[parent_x] += self.rank[parent_y]\\n            else:\\n                self.parent[parent_x] = parent_y\\n                self.rank[parent_y] += self.rank[parent_x]\\n                \\n        return\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1462603,
                "title": "python-3-solutions-unionfind-dfs-bfs",
                "content": "**\\u2714\\uFE0F Solution 1: Union Find (Path compression & Union by Size)**\\n```python\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parent = [i for i in range(n)]\\n        self.size = [1] * n\\n        \\n    def find(self, u):\\n        if u != self.parent[u]:\\n            self.parent[u] = self.find(self.parent[u])  # Path compression\\n        return self.parent[u]\\n    \\n    def union(self, u, v):\\n        pu, pv = self.find(u), self.find(v)\\n        if pu == pv: return False\\n        if self.size[pu] < self.size[pv]:  # Make size[pu] > size[pv]\\n            pu, pv = pv, pu\\n            \\n        # Merge pv to pu\\n        self.size[pu] += self.size[pv]\\n        self.parent[pv] = pu\\n        return True\\n\\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        n = len(s)\\n        uf = UnionFind(n)\\n        for i, j in pairs:\\n            uf.union(i, j)\\n            \\n        groups = defaultdict(list)\\n        for i in range(n):\\n            p = uf.find(i)\\n            groups[p].append(s[i])\\n            \\n        for arr in groups.values():\\n            arr.sort(reverse=True)\\n            \\n        arr = [\\'.\\'] * n\\n        for i in range(n):\\n            p = uf.find(i)\\n            arr[i] = groups[p].pop()\\n        return \"\".join(arr)\\n```\\n**Complexity**\\n- Time: `O(N * \\u03B1(N) + NlogN)`, where `N <= 10^5` is length of `s` string.\\n   Explanation: Using both **path compression** and **union by size** ensures that the **amortized time** per **UnionFind** operation is only `\\u03B1(n)`, which is optimal, where `\\u03B1(n)` is the inverse Ackermann function. This function has a value `\\u03B1(n) < 5` for any value of n that can be written in this physical universe, so the disjoint-set operations take place in essentially constant time.\\nReference: https://en.wikipedia.org/wiki/Disjoint-set_data_structure or https://www.slideshare.net/WeiLi73/time-complexity-of-union-find-55858534 for more information.\\n- Space: `O(N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: DFS**\\n```python\\n# To do implementation\\n```\\n**Complexity**\\n- Time: `O(N)`\\n- Space: `O(N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 3: BFS**\\n```python\\n# To do implementation\\n```\\n**Complexity**\\n- Time: `O(N)`\\n- Space: `O(N)`",
                "solutionTags": [],
                "code": "```python\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parent = [i for i in range(n)]\\n        self.size = [1] * n\\n        \\n    def find(self, u):\\n        if u != self.parent[u]:\\n            self.parent[u] = self.find(self.parent[u])  # Path compression\\n        return self.parent[u]\\n    \\n    def union(self, u, v):\\n        pu, pv = self.find(u), self.find(v)\\n        if pu == pv: return False\\n        if self.size[pu] < self.size[pv]:  # Make size[pu] > size[pv]\\n            pu, pv = pv, pu\\n            \\n        # Merge pv to pu\\n        self.size[pu] += self.size[pv]\\n        self.parent[pv] = pu\\n        return True\\n\\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        n = len(s)\\n        uf = UnionFind(n)\\n        for i, j in pairs:\\n            uf.union(i, j)\\n            \\n        groups = defaultdict(list)\\n        for i in range(n):\\n            p = uf.find(i)\\n            groups[p].append(s[i])\\n            \\n        for arr in groups.values():\\n            arr.sort(reverse=True)\\n            \\n        arr = [\\'.\\'] * n\\n        for i in range(n):\\n            p = uf.find(i)\\n            arr[i] = groups[p].pop()\\n        return \"\".join(arr)\\n```\n```python\\n# To do implementation\\n```\n```python\\n# To do implementation\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1025846,
                "title": "python-simple-dfs-connected-component-faster-than-95",
                "content": "Note that given swap (1, 2) and (2, 3), you can generate any orders of 1, 2, and 3. Similar for any number of swap operations. The entire problem then reduces to figuring out the group of connected indices within time limit.\\n```\\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        n = len(s)        \\n        edges = [set() for _ in range(n)]         \\n        for a, b in pairs:\\n            edges[a].add(b)\\n            edges[b].add(a)\\n        \\n\\t\\t# find the groups of connected indices\\n        groups = []\\n        visited_roots = set()\\n        for root in range(n):\\n            if root not in visited_roots and len(edges[root]) > 0:\\n\\t\\t\\t    # start DFS for finding all the elements from this root\\n                group_indices = set([root])\\n                visited_roots.add(root)\\n                to_visit = [root]\\n                while len(to_visit) > 0:\\n                    i_next = to_visit.pop()\\n                    for c in edges[i_next]:\\n                        if c not in group_indices:\\n                            group_indices.add(c)\\n                            visited_roots.add(c)\\n                            to_visit.append(c)\\n                groups.append(group_indices)\\n\\n\\t\\t# output the sorted string within each group of indices\\n        out = list(s)\\n        for indices in groups:\\n            chars = sorted([s[i] for i in indices])\\n            indices = sorted(indices)\\n            for i, c in zip(indices, chars):\\n                out[i] = c\\n        \\n        return \\'\\'.join(out)     \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        n = len(s)        \\n        edges = [set() for _ in range(n)]         \\n        for a, b in pairs:\\n            edges[a].add(b)\\n            edges[b].add(a)\\n        \\n\\t\\t# find the groups of connected indices\\n        groups = []\\n        visited_roots = set()\\n        for root in range(n):\\n            if root not in visited_roots and len(edges[root]) > 0:\\n\\t\\t\\t    # start DFS for finding all the elements from this root\\n                group_indices = set([root])\\n                visited_roots.add(root)\\n                to_visit = [root]\\n                while len(to_visit) > 0:\\n                    i_next = to_visit.pop()\\n                    for c in edges[i_next]:\\n                        if c not in group_indices:\\n                            group_indices.add(c)\\n                            visited_roots.add(c)\\n                            to_visit.append(c)\\n                groups.append(group_indices)\\n\\n\\t\\t# output the sorted string within each group of indices\\n        out = list(s)\\n        for indices in groups:\\n            chars = sorted([s[i] for i in indices])\\n            indices = sorted(indices)\\n            for i, c in zip(indices, chars):\\n                out[i] = c\\n        \\n        return \\'\\'.join(out)     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 475888,
                "title": "c-union-find",
                "content": "\\tclass dsu{\\n\\t\\tpublic:\\n\\t\\tvector<int> arr;\\n\\t\\tdsu(int n):arr(n){\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tarr[i]=i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint find(int a){\\n\\t\\t\\tif(arr[a]!=a){\\n\\t\\t\\t\\tarr[a]=find(arr[a]);\\n\\t\\t\\t}\\n\\t\\t\\treturn arr[a];\\n\\t\\t}\\n\\t\\tvoid merge(int a, int b){\\n\\t\\t\\tint x=find(a);\\n\\t\\t\\tint y=find(b);\\n\\t\\t\\tarr[x]=y;\\n\\t\\t}\\n\\t};\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n\\t\\t\\tint n=s.size();\\n\\t\\t\\tdsu DSU(n);\\n\\t\\t\\tfor(auto v:pairs){\\n\\t\\t\\t\\tDSU.merge(v[0],v[1]);\\n\\t\\t\\t}\\n\\t\\t\\tunordered_map<int,vector<char>> m;\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tm[DSU.find(i)].push_back(s[i]);\\n\\t\\t\\t}\\n\\t\\t\\tfor(auto &v:m){\\n\\t\\t\\t\\tsort(v.second.rbegin(),v.second.rend());\\n\\t\\t\\t}\\n\\t\\t\\tstring ans;\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tans.push_back(m[DSU.find(i)].back());\\n\\t\\t\\t\\tm[DSU.find(i)].pop_back();\\n\\t\\t\\t}\\n\\t\\t\\treturn ans; \\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n\\t\\t\\tint n=s.size();\\n\\t\\t\\tdsu DSU(n);\\n\\t\\t\\tfor(auto v:pairs){\\n\\t\\t\\t\\tDSU.merge(v[0],v[1]);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 414014,
                "title": "c-solution",
                "content": "```\\npublic class Solution \\n{\\n    public string SmallestStringWithSwaps(string s, IList<IList<int>> pairs) \\n    {\\n        var parentMap = new Dictionary<int, int>();\\n        foreach(var pair in pairs)\\n            Union(parentMap, pair[0], pair[1]);\\n\\n        var map = new Dictionary<int, List<KeyValuePair<char,int>>>();\\n        for(int i = 0; i < s.Length; i++)\\n        {\\n            var parent = Find(parentMap, i);\\n            if(!map.ContainsKey(parent))\\n                map[parent] = new List<KeyValuePair<char,int>>();\\n            \\n            map[parent].Add(new KeyValuePair<char, int>(s[i], i));\\n        }\\n        \\n        char[] result = new char[s.Length];\\n        foreach(var list in map.Values)\\n        {\\n            var charArray = list.Select(x => x.Key).ToArray();\\n            var indexArray = list.Select(x => x.Value).ToArray();\\n            Array.Sort(charArray);\\n\\n            for(int i = 0; i < indexArray.Length; i++)\\n                result[indexArray[i]] = charArray[i];\\n        }\\n        \\n        return new String(result);\\n    }\\n    \\n    private void Union(Dictionary<int, int> parentMap, int x, int y)\\n    {\\n        int parent1 = Find(parentMap, x), parent2 = Find(parentMap, y);\\n            if(parent1 != parent2)\\n                parentMap[parent1] = parent2;\\n    }\\n    \\n    private int Find(Dictionary<int, int> parentMap, int num)\\n    {\\n        if(!parentMap.ContainsKey(num)) parentMap[num] = num;\\n        if(parentMap[num] != num) \\n            parentMap[num] = Find(parentMap, parentMap[num]);\\n        return  parentMap[num];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public string SmallestStringWithSwaps(string s, IList<IList<int>> pairs) \\n    {\\n        var parentMap = new Dictionary<int, int>();\\n        foreach(var pair in pairs)\\n            Union(parentMap, pair[0], pair[1]);\\n\\n        var map = new Dictionary<int, List<KeyValuePair<char,int>>>();\\n        for(int i = 0; i < s.Length; i++)\\n        {\\n            var parent = Find(parentMap, i);\\n            if(!map.ContainsKey(parent))\\n                map[parent] = new List<KeyValuePair<char,int>>();\\n            \\n            map[parent].Add(new KeyValuePair<char, int>(s[i], i));\\n        }\\n        \\n        char[] result = new char[s.Length];\\n        foreach(var list in map.Values)\\n        {\\n            var charArray = list.Select(x => x.Key).ToArray();\\n            var indexArray = list.Select(x => x.Value).ToArray();\\n            Array.Sort(charArray);\\n\\n            for(int i = 0; i < indexArray.Length; i++)\\n                result[indexArray[i]] = charArray[i];\\n        }\\n        \\n        return new String(result);\\n    }\\n    \\n    private void Union(Dictionary<int, int> parentMap, int x, int y)\\n    {\\n        int parent1 = Find(parentMap, x), parent2 = Find(parentMap, y);\\n            if(parent1 != parent2)\\n                parentMap[parent1] = parent2;\\n    }\\n    \\n    private int Find(Dictionary<int, int> parentMap, int num)\\n    {\\n        if(!parentMap.ContainsKey(num)) parentMap[num] = num;\\n        if(parentMap[num] != num) \\n            parentMap[num] = Find(parentMap, parentMap[num]);\\n        return  parentMap[num];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 387785,
                "title": "faster-than-100-concise-java-solution-connected-components",
                "content": "1. Please take a look at [LeetCode \\u2014 Number of Connected Components in an Undirected Graph](https://medium.com/@null00/leetcode-number-of-connected-components-in-an-undirected-graph-e071423f1aa6). You will get an idea of what connected components are. Strongly recommended.\\n2. After step 1. Then it should be easy to solve this problem.\\n   2.1. Get all connected components. There is a modification here, between line 21\\u201323, we set root[i] to the root value as soon as possible, this will save time when we do findRoot in line 8.\\n   2.2. Based on the root value of each character, create a HashMap which contains PriorityQueue.\\n   2.3. Pick the character from PriorityQueue.\\nhttps://medium.com/@null00/leetcode-smallest-string-with-swaps-b5ae88b01b47\\n\\n```\\npublic String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n    int n = s.length();\\n    int[] root = new int[n];\\n    for (int i = 0; i < n; ++i) root[i] = i;\\n    for (List<Integer> p : pairs) union(root, p.get(0), p.get(1));\\n    Map<Integer, PriorityQueue<Character>> map = new HashMap<Integer, PriorityQueue<Character>>();\\n    for (int i = 0; i < n; ++i) {\\n        int head = findRoot(root, i);\\n        root[i] = head;\\n        if (!map.containsKey(head)) map.put(head, new PriorityQueue<Character>());\\n        map.get(head).add(s.charAt(i));\\n    }\\n    \\n    StringBuilder sb = new StringBuilder();\\n    for (int i = 0; i < n; ++i) sb.append(map.get(root[i]).poll());\\n    return sb.toString();\\n}\\n\\nprivate int findRoot(int[] root, int i) {\\n    if (root[i] == i) return i;\\n    int r = findRoot(root, root[i]);\\n    root[i] = r;\\n    return r;\\n}\\n\\nprivate void union(int[] root, int src, int dst) {\\n    int srcRoot = findRoot(root, src);\\n    int dstRoot = findRoot(root, dst);\\n    if (srcRoot != dstRoot) root[srcRoot] = dstRoot;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n    int n = s.length();\\n    int[] root = new int[n];\\n    for (int i = 0; i < n; ++i) root[i] = i;\\n    for (List<Integer> p : pairs) union(root, p.get(0), p.get(1));\\n    Map<Integer, PriorityQueue<Character>> map = new HashMap<Integer, PriorityQueue<Character>>();\\n    for (int i = 0; i < n; ++i) {\\n        int head = findRoot(root, i);\\n        root[i] = head;\\n        if (!map.containsKey(head)) map.put(head, new PriorityQueue<Character>());\\n        map.get(head).add(s.charAt(i));\\n    }\\n    \\n    StringBuilder sb = new StringBuilder();\\n    for (int i = 0; i < n; ++i) sb.append(map.get(root[i]).poll());\\n    return sb.toString();\\n}\\n\\nprivate int findRoot(int[] root, int i) {\\n    if (root[i] == i) return i;\\n    int r = findRoot(root, root[i]);\\n    root[i] = r;\\n    return r;\\n}\\n\\nprivate void union(int[] root, int src, int dst) {\\n    int srcRoot = findRoot(root, src);\\n    int dstRoot = findRoot(root, dst);\\n    if (srcRoot != dstRoot) root[srcRoot] = dstRoot;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2517195,
                "title": "c-2-solutions-with-union-find-path-compressing-dfs-full-explanation",
                "content": "# Union Find Path Compression\\n```\\nclass Solution {\\npublic:\\n    //logic:\\n    //1. first we\\'ll try to make groups of indexes.. \\n    //2. then in each group sort according to corresponding chars\\n    //3. put those sorted chars in the corresponding locations for each group\\n    int find_parent(int node, vector<int>&parent){\\n        if(node == parent[node]) return node;\\n        return parent[node] = find_parent(parent[node], parent);  //path compressing\\n        //if 7->3->6... in this case we are setting 7->6.. in next if we need to find the parent of 7.. we\\'ll be able to do it in O(1) time.. \\n        //TC: O(4.alpha) ==== O(4) ==== O(1)\\n    }\\n    \\n    void make_union(int u, int v, vector<int>&parent, vector<int>&rank){\\n        //first we need to find the main parent of both the nodes\\n        int U = find_parent(u, parent), V = find_parent(v, parent);\\n        //here assume set means tree\\n        //now lets join based on their rank... based on rank because.. if a set is having less hight \\n\\t\\t//and if we join in that a set with higher height.. then the overall set height will be increased.... \\n        if(rank[U] < rank[V] ) parent[U] = V;  // joining the set u into the set v\\n        else if(rank[U] > rank[V] ) parent[V] = U;\\n        else{\\n            parent[U] = V;\\n            rank[V]++;\\n        }\\n    }\\n    \\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        int n = s.length();\\n        vector<int>parent(n), rank(n, 0);\\n        for(int i=0; i<n; i++) parent[i] = i;\\n        \\n        //lets group\\n        for(auto e:pairs){\\n            make_union(e[0], e[1], parent, rank);\\n        }\\n        \\n        //now since grouping is done.. lets sort\\n        unordered_map<int, priority_queue<int, vector<int>, greater<int>>>mp;\\n        for(int i=0; i<n; i++){\\n            //pushing the actual ascii value of the corresponding char\\n            mp[find_parent(i, parent)].push(s[i]);   ///we are interested the actual parents... so the groups will be disjoint... \\n\\t\\t\\t//map size is the total no of connected components\\n        }\\n        \\n        //now lets reconstruct\\n        //by for each index locate its parent and get the top of that gropu\\n        //and delete the top\\n        for(int i=0; i<n; i++){\\n\\t\\t//assigning the min char into the corresponding location\\n            s[i] = mp[parent[i]].top();\\n            mp[parent[i]].pop();\\n        }\\n        return s;\\n        \\n    }\\n};\\n```\\n\\n# DFS\\n```\\n    void dfs(int node, vector<vector<int>>&adj, vector<bool>&visited, vector<int>&idx, vector<char>&ltr, string&s){\\n        //mark as visited\\n        visited[node] = true;\\n        idx.push_back(node);\\n        ltr.push_back(s[node]);\\n        for(auto i:adj[node]){\\n            if(visited[i] == false) dfs(i, adj, visited, idx, ltr, s);\\n        }\\n    }\\n    \\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs){\\n        int n = s.length();\\n        vector<vector<int>>adj(n);\\n\\t\\t//making the adjacency list\\n        for(auto e:pairs){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        \\n        vector<bool>visited(n, false);\\n        for(int i=0; i<n; i++){\\n            if(visited[i] == false){\\n                vector<int>idx;\\n                vector<char>ltr;\\n                //make a connected component.. and record the indexes and corresponding chars in the s\\n                dfs(i, adj, visited, idx, ltr, s);\\n                sort(idx.begin(), idx.end());   //sorting the indexes in the group\\n                sort(ltr.begin(), ltr.end());  // sorting the chars in the group\\n                int k=0;\\n                for(auto i:idx) s[i] = ltr[k++];  // just assigning those sorted chars in the incresing order in those locations \\n            }\\n        }\\n        \\n        return s;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    //logic:\\n    //1. first we\\'ll try to make groups of indexes.. \\n    //2. then in each group sort according to corresponding chars\\n    //3. put those sorted chars in the corresponding locations for each group\\n    int find_parent(int node, vector<int>&parent){\\n        if(node == parent[node]) return node;\\n        return parent[node] = find_parent(parent[node], parent);  //path compressing\\n        //if 7->3->6... in this case we are setting 7->6.. in next if we need to find the parent of 7.. we\\'ll be able to do it in O(1) time.. \\n        //TC: O(4.alpha) ==== O(4) ==== O(1)\\n    }\\n    \\n    void make_union(int u, int v, vector<int>&parent, vector<int>&rank){\\n        //first we need to find the main parent of both the nodes\\n        int U = find_parent(u, parent), V = find_parent(v, parent);\\n        //here assume set means tree\\n        //now lets join based on their rank... based on rank because.. if a set is having less hight \\n\\t\\t//and if we join in that a set with higher height.. then the overall set height will be increased.... \\n        if(rank[U] < rank[V] ) parent[U] = V;  // joining the set u into the set v\\n        else if(rank[U] > rank[V] ) parent[V] = U;\\n        else{\\n            parent[U] = V;\\n            rank[V]++;\\n        }\\n    }\\n    \\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        int n = s.length();\\n        vector<int>parent(n), rank(n, 0);\\n        for(int i=0; i<n; i++) parent[i] = i;\\n        \\n        //lets group\\n        for(auto e:pairs){\\n            make_union(e[0], e[1], parent, rank);\\n        }\\n        \\n        //now since grouping is done.. lets sort\\n        unordered_map<int, priority_queue<int, vector<int>, greater<int>>>mp;\\n        for(int i=0; i<n; i++){\\n            //pushing the actual ascii value of the corresponding char\\n            mp[find_parent(i, parent)].push(s[i]);   ///we are interested the actual parents... so the groups will be disjoint... \\n\\t\\t\\t//map size is the total no of connected components\\n        }\\n        \\n        //now lets reconstruct\\n        //by for each index locate its parent and get the top of that gropu\\n        //and delete the top\\n        for(int i=0; i<n; i++){\\n\\t\\t//assigning the min char into the corresponding location\\n            s[i] = mp[parent[i]].top();\\n            mp[parent[i]].pop();\\n        }\\n        return s;\\n        \\n    }\\n};\\n```\n```\\n    void dfs(int node, vector<vector<int>>&adj, vector<bool>&visited, vector<int>&idx, vector<char>&ltr, string&s){\\n        //mark as visited\\n        visited[node] = true;\\n        idx.push_back(node);\\n        ltr.push_back(s[node]);\\n        for(auto i:adj[node]){\\n            if(visited[i] == false) dfs(i, adj, visited, idx, ltr, s);\\n        }\\n    }\\n    \\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs){\\n        int n = s.length();\\n        vector<vector<int>>adj(n);\\n\\t\\t//making the adjacency list\\n        for(auto e:pairs){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        \\n        vector<bool>visited(n, false);\\n        for(int i=0; i<n; i++){\\n            if(visited[i] == false){\\n                vector<int>idx;\\n                vector<char>ltr;\\n                //make a connected component.. and record the indexes and corresponding chars in the s\\n                dfs(i, adj, visited, idx, ltr, s);\\n                sort(idx.begin(), idx.end());   //sorting the indexes in the group\\n                sort(ltr.begin(), ltr.end());  // sorting the chars in the group\\n                int k=0;\\n                for(auto i:idx) s[i] = ltr[k++];  // just assigning those sorted chars in the incresing order in those locations \\n            }\\n        }\\n        \\n        return s;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2465392,
                "title": "c-simple-c-code-99-63-time",
                "content": "\\n# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\n    vector<int> parents;\\n    int find_set(int v)\\n    {\\n        if(v == parents[v])\\n            return v;\\n        return parents[v] = find_set(parents[v]);\\n    }\\n    void union_set(int a, int b)\\n    {\\n        a = find_set(a);\\n        b = find_set(b);\\n        if(a == b)\\n            return;\\n        parents[a] = b;\\n        return;\\n    }\\npublic:\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) \\n    {\\n        int n = s.size();\\n        for(int i = 0; i < n; i++)\\n            parents.push_back(i);\\n        for(vector<int> &v : pairs)\\n        { \\n            if(v[0] == v[1])\\n                continue;\\n            if(v[0] < v[1])\\n                union_set(v[0], v[1]);\\n            else\\n                union_set(v[1], v[0]);\\n        }\\n        //cout << parents[0] << \" \";\\n        vector<int> um[n+1];\\n        vector<string> st(n,\"\");\\n        for(int i = 0; i < n; i++)\\n        {\\n            int x = find_set(i);\\n            //cout << x << \" \";\\n            um[x].push_back(i);\\n            st[x].push_back(s[i]);\\n        }\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(st[i] == \"\")\\n                continue;\\n            sort(st[i].begin(), st[i].end());\\n            for(int j = 0; j < um[i].size(); j++)\\n                s[um[i][j]] = st[i][j];\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> parents;\\n    int find_set(int v)\\n    {\\n        if(v == parents[v])\\n            return v;\\n        return parents[v] = find_set(parents[v]);\\n    }\\n    void union_set(int a, int b)\\n    {\\n        a = find_set(a);\\n        b = find_set(b);\\n        if(a == b)\\n            return;\\n        parents[a] = b;\\n        return;\\n    }\\npublic:\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) \\n    {\\n        int n = s.size();\\n        for(int i = 0; i < n; i++)\\n            parents.push_back(i);\\n        for(vector<int> &v : pairs)\\n        { \\n            if(v[0] == v[1])\\n                continue;\\n            if(v[0] < v[1])\\n                union_set(v[0], v[1]);\\n            else\\n                union_set(v[1], v[0]);\\n        }\\n        //cout << parents[0] << \" \";\\n        vector<int> um[n+1];\\n        vector<string> st(n,\"\");\\n        for(int i = 0; i < n; i++)\\n        {\\n            int x = find_set(i);\\n            //cout << x << \" \";\\n            um[x].push_back(i);\\n            st[x].push_back(s[i]);\\n        }\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(st[i] == \"\")\\n                continue;\\n            sort(st[i].begin(), st[i].end());\\n            for(int j = 0; j < um[i].size(); j++)\\n                s[um[i][j]] = st[i][j];\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1987206,
                "title": "java-implementation-o-v-e-space-solution-nlogn-n-solution",
                "content": "\\n\\n```\\nclass Solution {\\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        Map<Integer,Set<Integer>> graph = new HashMap<>();\\n        \\n        for(int i=0;i<pairs.size();i++) {\\n            List<Integer> pair = pairs.get(i);\\n            Set<Integer>  set   = graph.getOrDefault(pair.get(0),new HashSet<>());\\n            set.add(pair.get(1));\\n            \\n            graph.put(pair.get(0),set);\\n            \\n            set   = graph.getOrDefault(pair.get(1),new HashSet<>());\\n            set.add(pair.get(0));\\n            \\n            graph.put(pair.get(1),set);\\n        \\n        }\\n        \\n        \\n        \\n        int[] visited = new int[s.length()];\\n        Arrays.fill(visited,-1);\\n\\n        \\n        StringBuffer output = new StringBuffer(s);\\n        for(int i=0;i<visited.length;i++) {\\n            if(visited[i]==-1) {\\n                Set<Integer> components = new HashSet<>();\\n                \\n                dfs(i,graph,visited,i,components);\\n\\n                List<Integer> sortedList = new ArrayList<>(components);\\n        \\n                Collections.sort(sortedList,(k,l)->{\\n                    if(s.charAt(k)==s.charAt(l))\\n                        return 0;\\n                    if(s.charAt(k)>s.charAt(l))\\n                        return 1;\\n                    else\\n                        return -1;\\n                });\\n                \\n                List<Integer> list = new ArrayList<>(components);\\n                Collections.sort(list);\\n                \\n                for(int l=0;l<list.size();l++) {\\n                    int newPosition= sortedList.get(l);\\n                    int oldPostion = list.get(l);\\n                    output.setCharAt(oldPostion,s.charAt(newPosition));\\n                }\\n            }\\n            \\n        }\\n\\n        return output.toString();\\n    }\\n    \\n    public void dfs(int i,Map<Integer,Set<Integer>> graph,int[] visited,int component,Set<Integer> components) {\\n        visited[i]=component;\\n        components.add(i);\\n        Set<Integer> neighbours = graph.getOrDefault(i,new HashSet<>());\\n        \\n        for(int neighbour:neighbours) {\\n            if(visited[neighbour]==-1) {\\n                dfs(neighbour,graph,visited,component,components);\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        Map<Integer,Set<Integer>> graph = new HashMap<>();\\n        \\n        for(int i=0;i<pairs.size();i++) {\\n            List<Integer> pair = pairs.get(i);\\n            Set<Integer>  set   = graph.getOrDefault(pair.get(0),new HashSet<>());\\n            set.add(pair.get(1));\\n            \\n            graph.put(pair.get(0),set);\\n            \\n            set   = graph.getOrDefault(pair.get(1),new HashSet<>());\\n            set.add(pair.get(0));\\n            \\n            graph.put(pair.get(1),set);\\n        \\n        }\\n        \\n        \\n        \\n        int[] visited = new int[s.length()];\\n        Arrays.fill(visited,-1);\\n\\n        \\n        StringBuffer output = new StringBuffer(s);\\n        for(int i=0;i<visited.length;i++) {\\n            if(visited[i]==-1) {\\n                Set<Integer> components = new HashSet<>();\\n                \\n                dfs(i,graph,visited,i,components);\\n\\n                List<Integer> sortedList = new ArrayList<>(components);\\n        \\n                Collections.sort(sortedList,(k,l)->{\\n                    if(s.charAt(k)==s.charAt(l))\\n                        return 0;\\n                    if(s.charAt(k)>s.charAt(l))\\n                        return 1;\\n                    else\\n                        return -1;\\n                });\\n                \\n                List<Integer> list = new ArrayList<>(components);\\n                Collections.sort(list);\\n                \\n                for(int l=0;l<list.size();l++) {\\n                    int newPosition= sortedList.get(l);\\n                    int oldPostion = list.get(l);\\n                    output.setCharAt(oldPostion,s.charAt(newPosition));\\n                }\\n            }\\n            \\n        }\\n\\n        return output.toString();\\n    }\\n    \\n    public void dfs(int i,Map<Integer,Set<Integer>> graph,int[] visited,int component,Set<Integer> components) {\\n        visited[i]=component;\\n        components.add(i);\\n        Set<Integer> neighbours = graph.getOrDefault(i,new HashSet<>());\\n        \\n        for(int neighbour:neighbours) {\\n            if(visited[neighbour]==-1) {\\n                dfs(neighbour,graph,visited,component,components);\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1986033,
                "title": "java-solution-connected-components-graph-solution",
                "content": "```\\nclass Solution {\\n    \\n    private void dfs(List<Integer>[] graph, int currVertex, String s, boolean[] visited, List<Character> chs, List<Integer> indexes) {\\n        if (visited[currVertex]) return;\\n       \\n        chs.add(s.charAt(currVertex));\\n        indexes.add(currVertex);\\n        \\n        visited[currVertex] = true;        \\n        \\n        for (int neighbor : graph[currVertex]) {\\n            dfs(graph, neighbor, s, visited, chs, indexes);\\n        }\\n    }\\n    \\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        int n = s.length();\\n        List<Integer>[] graph = new ArrayList[n];\\n\\n        for (int i=0; i < n; i++) {\\n            graph[i] = new ArrayList<>();\\n        }        \\n     \\n        // 0 -> [1]\\n        // 1 -> [0] \\n        \\n        boolean[] visited = new boolean[n];\\n        \\n        for (List<Integer> pair : pairs) {\\n            int u = pair.get(0);\\n            int v = pair.get(1);\\n            \\n            graph[u].add(v);\\n            graph[v].add(u);\\n        }\\n        \\n        char[] ans = new char[n];\\n        \\n        for (int i=0; i < n; i++) {\\n            if (!visited[i]) {\\n                List<Character> chs = new ArrayList<>();\\n                List<Integer> indexes = new ArrayList<>();\\n                \\n                dfs(graph, i, s, visited, chs, indexes);\\n                Collections.sort(chs); // [d c e] -> [c d e]\\n                Collections.sort(indexes); // [1 0 2] -> [0 1 2]\\n                \\n                for (int j=0; j < indexes.size(); j++) {\\n                    ans[indexes.get(j)] = chs.get(j);\\n                }\\n            }\\n        }\\n        \\n        \\n        return new String(ans);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private void dfs(List<Integer>[] graph, int currVertex, String s, boolean[] visited, List<Character> chs, List<Integer> indexes) {\\n        if (visited[currVertex]) return;\\n       \\n        chs.add(s.charAt(currVertex));\\n        indexes.add(currVertex);\\n        \\n        visited[currVertex] = true;        \\n        \\n        for (int neighbor : graph[currVertex]) {\\n            dfs(graph, neighbor, s, visited, chs, indexes);\\n        }\\n    }\\n    \\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        int n = s.length();\\n        List<Integer>[] graph = new ArrayList[n];\\n\\n        for (int i=0; i < n; i++) {\\n            graph[i] = new ArrayList<>();\\n        }        \\n     \\n        // 0 -> [1]\\n        // 1 -> [0] \\n        \\n        boolean[] visited = new boolean[n];\\n        \\n        for (List<Integer> pair : pairs) {\\n            int u = pair.get(0);\\n            int v = pair.get(1);\\n            \\n            graph[u].add(v);\\n            graph[v].add(u);\\n        }\\n        \\n        char[] ans = new char[n];\\n        \\n        for (int i=0; i < n; i++) {\\n            if (!visited[i]) {\\n                List<Character> chs = new ArrayList<>();\\n                List<Integer> indexes = new ArrayList<>();\\n                \\n                dfs(graph, i, s, visited, chs, indexes);\\n                Collections.sort(chs); // [d c e] -> [c d e]\\n                Collections.sort(indexes); // [1 0 2] -> [0 1 2]\\n                \\n                for (int j=0; j < indexes.size(); j++) {\\n                    ans[indexes.get(j)] = chs.get(j);\\n                }\\n            }\\n        }\\n        \\n        \\n        return new String(ans);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1985914,
                "title": "c-union-find-easy-to-understand-well-explained",
                "content": "* If you think clearly, you will notice that all the pairs we have form a set. \\nif ```(a,b) , (b,c) are in pairs then it means (a,c) can also be swaped``` (you can notice this using example also). \\nNow this means that (a,b,c) are connected to each other and hence are in a set. \\n\\n* So first create union and find functions to create and use sets (Disjoint set method).\\nUnion all the connected indices. \\n\\n* Now, think more, these same set characters can be sorted and \\nassigned to the values of the sorted indices which are connected \\nto each other, to solve the problem.\\n\\n* Hence create data structure to store the characters and the indices separately.\\nYou can now sort the characters vector but don\\'t need to sort indices vector \\nbecause iteraction will give you sorted indices only. \\nAnd after this you need to assign the sorted characters to the corresponding indices.\\n\\nBelow is the code implementation of the above idea. \\nWould like to get your comments and views on this. \\n**If you think this explanation helped you or you liked it, \\nthen do upvote it. Thanks, have a nice day.**\\n\\n```\\nclass Solution {\\n    unordered_map<int, int> m;\\npublic:\\n    void init_map(string s){\\n        for(int i = 0 ; i < s.size(); ++i){\\n            m[i] = i;\\n        }\\n    }\\n    \\n    int find(int a){\\n        if(m[a] == a) return a;\\n        return m[a] = find(m[a]);\\n    }\\n    \\n    void union_set(int a, int b){\\n        int x = find(m[a]);\\n        int y = find(m[b]);\\n        if ( x == y) return;\\n        m[x] = y;\\n    }\\n    \\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        init_map(s);\\n            \\n        for(int i = 0 ; i < pairs.size(); ++i){\\n            union_set(pairs[i][0], pairs[i][1]);\\n        }\\n        \\n        vector<vector<char>> chars(s.size()); \\n        vector<vector<int>> indexes(s.size());\\n\\t\\t\\n        for(int i = 0; i < s.size(); ++i){\\n            int r = find(m[i]);\\n            chars[r].push_back(s[i]);\\n            indexes[r].push_back(i);\\n        }\\n        \\n        for(int k = 0; k < s.size(); ++k){\\n            if(chars[k].size()){\\n                sort(chars[k].begin(),chars[k].end());\\n            }\\n            \\n            for(int len = 0; len < chars[k].size(); ++len){\\n                s[indexes[k][len]] = chars[k][len];\\n            }\\n        }        \\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find",
                    "Graph"
                ],
                "code": "```(a,b) , (b,c) are in pairs then it means (a,c) can also be swaped```\n```\\nclass Solution {\\n    unordered_map<int, int> m;\\npublic:\\n    void init_map(string s){\\n        for(int i = 0 ; i < s.size(); ++i){\\n            m[i] = i;\\n        }\\n    }\\n    \\n    int find(int a){\\n        if(m[a] == a) return a;\\n        return m[a] = find(m[a]);\\n    }\\n    \\n    void union_set(int a, int b){\\n        int x = find(m[a]);\\n        int y = find(m[b]);\\n        if ( x == y) return;\\n        m[x] = y;\\n    }\\n    \\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        init_map(s);\\n            \\n        for(int i = 0 ; i < pairs.size(); ++i){\\n            union_set(pairs[i][0], pairs[i][1]);\\n        }\\n        \\n        vector<vector<char>> chars(s.size()); \\n        vector<vector<int>> indexes(s.size());\\n\\t\\t\\n        for(int i = 0; i < s.size(); ++i){\\n            int r = find(m[i]);\\n            chars[r].push_back(s[i]);\\n            indexes[r].push_back(i);\\n        }\\n        \\n        for(int k = 0; k < s.size(); ++k){\\n            if(chars[k].size()){\\n                sort(chars[k].begin(),chars[k].end());\\n            }\\n            \\n            for(int len = 0; len < chars[k].size(); ++len){\\n                s[indexes[k][len]] = chars[k][len];\\n            }\\n        }        \\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1985597,
                "title": "c-bfs-detailed-explanation-easy-to-understand",
                "content": "->The most important part to understand in this question is, that you can make the smallest possible(lexicographically) string from the connected component, from connected component means string indexes as node.\\n->Find connected components , store chars and Indexes of connected component.\\n->Sort chars for smallest possible(lexicographically).\\n->Sort Indexes to find exact place to put chars.\\n->Replace chars in given string.\\n```\\nclass Solution {\\npublic:\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        int n=s.size();\\n        vector<vector<int>> graph(n);\\n        for(auto v : pairs)\\n        {\\n            graph[v[0]].push_back(v[1]);\\n            graph[v[1]].push_back(v[0]);\\n        }\\n        vector<bool> visited(n,false);\\n        queue<int> q;\\n        string ans=s;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!visited[i])\\n            {\\n                q.push(i);\\n                visited[i]=true;\\n            }\\n            vector<char> connectedChars;\\n            vector<int> connectedIndexes;\\n            while(!q.empty())\\n            {\\n                int index = q.front();\\n                q.pop();\\n                connectedChars.push_back(s[index]);\\n                connectedIndexes.push_back(index);\\n                for(auto v : graph[index])\\n                {\\n                    if(!visited[v])\\n                    {\\n                        q.push(v);\\n                        visited[v]=true;\\n                    }\\n                }\\n            }\\n            sort(connectedChars.begin(),connectedChars.end());\\n            sort(connectedIndexes.begin(),connectedIndexes.end());\\n            for(int j=0;j<connectedIndexes.size();j++)\\n                ans[connectedIndexes[j]]=connectedChars[j];\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease Upvote if u like :)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        int n=s.size();\\n        vector<vector<int>> graph(n);\\n        for(auto v : pairs)\\n        {\\n            graph[v[0]].push_back(v[1]);\\n            graph[v[1]].push_back(v[0]);\\n        }\\n        vector<bool> visited(n,false);\\n        queue<int> q;\\n        string ans=s;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!visited[i])\\n            {\\n                q.push(i);\\n                visited[i]=true;\\n            }\\n            vector<char> connectedChars;\\n            vector<int> connectedIndexes;\\n            while(!q.empty())\\n            {\\n                int index = q.front();\\n                q.pop();\\n                connectedChars.push_back(s[index]);\\n                connectedIndexes.push_back(index);\\n                for(auto v : graph[index])\\n                {\\n                    if(!visited[v])\\n                    {\\n                        q.push(v);\\n                        visited[v]=true;\\n                    }\\n                }\\n            }\\n            sort(connectedChars.begin(),connectedChars.end());\\n            sort(connectedIndexes.begin(),connectedIndexes.end());\\n            for(int j=0;j<connectedIndexes.size();j++)\\n                ans[connectedIndexes[j]]=connectedChars[j];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1985359,
                "title": "dsu-90-faster-solution-with-explaination",
                "content": "I think by now you have understood that if pairs are somthing like this (1,2), (2,3) and (3,4). Then 1, 2, 3, ans 4 can be interchanged with one another. so, we defined a union on the pairs which are forming a connected components. Now we sorted all the elements fo such pair and stored them into a map then we are picking one charachter from the component that the perticular index belongs to and incrementing the pointer while adding these charachter to our answer string.\\n\\n```\\nclass Solution {\\npublic:\\n    int par[100005];\\n    int find(int x){\\n        if(par[x] == x) return x;\\n        return par[x] = find(par[x]);\\n    }\\n    \\n    void unite(int x, int y){\\n        int a = find(x);\\n        int b = find(y);\\n        if(a > b) swap(a, b);\\n        par[b] = a;\\n    }\\n    \\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        for(int i = 0; i < s.size(); i++){\\n            par[i] = i;\\n        }\\n        string ans;\\n        for(int i = 0; i < pairs.size(); i++){\\n            unite(pairs[i][0], pairs[i][1]);\\n        }\\n        map<int, string> mp;\\n        for(int i = 0; i < s.size(); i++){\\n            mp[find(i)] += s[i];\\n        }\\n        unordered_map<int,int> pointers;\\n        for(auto &x: mp) sort(x.second.begin(), x.second.end());\\n        for(int i = 0; i < s.size(); i++){\\n            ans += mp[par[i]][pointers[par[i]]];\\n            pointers[par[i]]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int par[100005];\\n    int find(int x){\\n        if(par[x] == x) return x;\\n        return par[x] = find(par[x]);\\n    }\\n    \\n    void unite(int x, int y){\\n        int a = find(x);\\n        int b = find(y);\\n        if(a > b) swap(a, b);\\n        par[b] = a;\\n    }\\n    \\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        for(int i = 0; i < s.size(); i++){\\n            par[i] = i;\\n        }\\n        string ans;\\n        for(int i = 0; i < pairs.size(); i++){\\n            unite(pairs[i][0], pairs[i][1]);\\n        }\\n        map<int, string> mp;\\n        for(int i = 0; i < s.size(); i++){\\n            mp[find(i)] += s[i];\\n        }\\n        unordered_map<int,int> pointers;\\n        for(auto &x: mp) sort(x.second.begin(), x.second.end());\\n        for(int i = 0; i < s.size(); i++){\\n            ans += mp[par[i]][pointers[par[i]]];\\n            pointers[par[i]]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1985109,
                "title": "python-graph-dfs-easy",
                "content": "```\\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        n = len(s)\\n        G = [[] for _ in range(n)]\\n        for i,j in pairs:\\n            G[i].append(j)\\n            G[j].append(i)\\n        \\n        seen = [False]*n\\n        def dfs(i, indices):\\n            indices.append((i,s[i]))\\n            seen[i] = True\\n            for j in G[i]:\\n                if not seen[j]:\\n                    dfs(j, indices)\\n\\n        ans = [None]*n\\n        for i in range(n):\\n            if not seen[i]:\\n                indices = []\\n                dfs(i, indices)\\n                if not indices:\\n                    ans[i] = s[i]\\n                else:\\n                    K = sorted(indices, key=lambda x:x[1])\\n                    P = sorted(indices, key=lambda x:x[0])\\n                    for i in range(len(indices)):\\n                        ans[P[i][0]] = K[i][1]\\n                        \\n        return \"\".join(ans)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        n = len(s)\\n        G = [[] for _ in range(n)]\\n        for i,j in pairs:\\n            G[i].append(j)\\n            G[j].append(i)\\n        \\n        seen = [False]*n\\n        def dfs(i, indices):\\n            indices.append((i,s[i]))\\n            seen[i] = True\\n            for j in G[i]:\\n                if not seen[j]:\\n                    dfs(j, indices)\\n\\n        ans = [None]*n\\n        for i in range(n):\\n            if not seen[i]:\\n                indices = []\\n                dfs(i, indices)\\n                if not indices:\\n                    ans[i] = s[i]\\n                else:\\n                    K = sorted(indices, key=lambda x:x[1])\\n                    P = sorted(indices, key=lambda x:x[0])\\n                    for i in range(len(indices)):\\n                        ans[P[i][0]] = K[i][1]\\n                        \\n        return \"\".join(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1895079,
                "title": "c-map-and-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    class DSU{\\n        public:\\n        \\n        vector<int> par,size;\\n        \\n        DSU(int n){\\n            par.resize(n);\\n            size.resize(n);\\n            \\n            for(int i=0; i<n; i++){\\n                par[i]=i;\\n                size[i]=1;\\n            }\\n        }\\n        \\n        int find(int x){\\n            if(x != par[x]) par[x] = find(par[x]);\\n            \\n            return par[x];\\n        }\\n        \\n        bool merge(int x, int y){\\n            x= find(x);\\n            y= find(y);\\n            \\n            if(x == y) return 0;\\n            \\n            if(size[x]>=size[y]){\\n                par[y]=x;\\n                size[x]+=size[y];\\n            }\\n            else{\\n                par[x]=y;\\n                size[y]+=x;\\n            }\\n            \\n            return 1;\\n        }\\n    };\\n    \\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        \\n        int n = s.size();\\n         DSU dsu(n);\\n        \\n        for(auto& p: pairs){\\n            dsu.merge(p[0], p[1]);\\n        }\\n        \\n        unordered_map<int, priority_queue<char,vector<char>,greater<char>>> Map;\\n        \\n        for(int i=0; i<n; i++){\\n            int comp = dsu.find(i);\\n            Map[comp].push(s[i]);\\n        }\\n        \\n        string ans;\\n        for(int i=0; i<n; i++){\\n            ans.push_back(Map[dsu.find(i)].top());\\n            Map[dsu.find(i)].pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    class DSU{\\n        public:\\n        \\n        vector<int> par,size;\\n        \\n        DSU(int n){\\n            par.resize(n);\\n            size.resize(n);\\n            \\n            for(int i=0; i<n; i++){\\n                par[i]=i;\\n                size[i]=1;\\n            }\\n        }\\n        \\n        int find(int x){\\n            if(x != par[x]) par[x] = find(par[x]);\\n            \\n            return par[x];\\n        }\\n        \\n        bool merge(int x, int y){\\n            x= find(x);\\n            y= find(y);\\n            \\n            if(x == y) return 0;\\n            \\n            if(size[x]>=size[y]){\\n                par[y]=x;\\n                size[x]+=size[y];\\n            }\\n            else{\\n                par[x]=y;\\n                size[y]+=x;\\n            }\\n            \\n            return 1;\\n        }\\n    };\\n    \\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        \\n        int n = s.size();\\n         DSU dsu(n);\\n        \\n        for(auto& p: pairs){\\n            dsu.merge(p[0], p[1]);\\n        }\\n        \\n        unordered_map<int, priority_queue<char,vector<char>,greater<char>>> Map;\\n        \\n        for(int i=0; i<n; i++){\\n            int comp = dsu.find(i);\\n            Map[comp].push(s[i]);\\n        }\\n        \\n        string ans;\\n        for(int i=0; i<n; i++){\\n            ans.push_back(Map[dsu.find(i)].top());\\n            Map[dsu.find(i)].pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603598,
                "title": "javascript-optimized-disjoint-set-union-find-solution",
                "content": "![image](https://assets.leetcode.com/users/images/b2322978-8181-4114-9808-c77428661d33_1638246392.759219.png)\\n\\n\\nApproach, disjoint set\\nWe could use disjoint set since all pairs could be swap any number of times, that mean if we group them together, they could be arranged however we want.\\n\\nStep 1 -  iterate stirng to generate disjoint set\\nStep 2 - group all chars into sets by root\\nStep 3 - sort all sets\\' chars in alphabetic order\\nStep 4 - merge all sorted sets into a single string with its position accordingly\\n\\n```\\n/**\\n * @param {string} s\\n * @param {number[][]} pairs\\n * @return {string}\\n */\\nvar smallestStringWithSwaps = function(s, pairs) {\\n    const sLen = s.length;\\n\\n    // Step 1, generate disjoint set\\n    const ds = new DisjointSet(sLen); // Space O(n)\\n\\n    pairs.forEach((p) => { // Time O(n)\\n        const [x, y] = p;\\n        ds.union(x, y); // Time O(a(n)), amortized O(1)\\n    });\\n    \\n    // Step 2, group chars into a set by root\\n    const rootSets = {};\\n    for(let i = 0; i < sLen; i++) { // Time O(n)\\n        const set = ds.find(i); // Time O(a(n)), amortized O(1)\\n        const char = s[i];\\n        \\n        if(!rootSets[set]) {\\n            rootSets[set] = [];\\n        }\\n        rootSets[set].push(char);\\n    }\\n    \\n    // Step 3, sort chars within each set by alphabetic order\\n    Object.keys(rootSets).forEach((key) => { // Time O(n log n)\\n        const sortedChars = rootSets[key].sort();\\n        rootSets[key] = new Queue(sortedChars);\\n    });\\n    \\n    // Step 4, generate result stringby alphabetically sorted sets\\n    let sortedS = \\'\\'\\n    for(let i = 0; i < sLen; i++) { // Time O(n)\\n        const set = ds.find(i);\\n        const char = rootSets[set].dequeue();\\n        sortedS += char;\\n    }\\n\\n    return sortedS;\\n};\\n\\nclass DisjointSet {\\n    constructor(n) {\\n        this.parent = Array(n).fill().map((_, i) => i);\\n        this.rank = Array(n).fill(1);\\n    }\\n    \\n    // optimized with path compression\\n    find(x) { // Time O(a(n)), amortized O(1)\\n        if(x === this.parent[x]) {\\n            return this.parent[x];\\n        }\\n        \\n        this.parent[x] = this.find(this.parent[x]);\\n        return this.parent[x];\\n    }\\n    \\n    // optmized ranked union\\n    union(x, y) { // Time O(a(n)), amortized O(1)\\n        const pX = this.find(x);\\n        const pY = this.find(y);\\n        if(pX !== pY) {\\n            if(this.rank[pX] > this.rank[pY]) {\\n                this.parent[pY] = this.parent[pX];\\n            } else if(this.rank[pX] < this.rank[pY]) {\\n                this.parent[pX] = this.parent[pY];\\n            } else {\\n                this.parent[pY] = this.parent[pX];\\n                this.rank[pX] += 1;\\n            }\\n        }\\n    }\\n}\\n```\\n\\nExample Test Run\\n    Input: s = \"dcab\", pairs = [[0,3],[1,2]]\\n\\n    Step 1, generate disjoint set roots\\n        [0,1,2,3] => [0,1,2,0] => [0,1,1,0]\\n    Step 2, group characters by set\\n        {} => {0:[d]} => {0:[d], 1:[c]} => {0:[d], 1:[c,a]} => {0:[d,b], 1:[c,a]}\\n    Step3, sort characters within each set\\n        {0:[d,b], 1:[c,a]} => {0:[b,d],1:[a,c]}\\n    Step4, generate result string by set and its sorted chars\\n        \\'bacd\\'\\n\\nComplexity\\n    Time O(n * a(n) + n * a(n) + n log n + n) => O(n log n)\\n\\tSpace O(n)",
                "solutionTags": [
                    "JavaScript",
                    "Union Find"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {number[][]} pairs\\n * @return {string}\\n */\\nvar smallestStringWithSwaps = function(s, pairs) {\\n    const sLen = s.length;\\n\\n    // Step 1, generate disjoint set\\n    const ds = new DisjointSet(sLen); // Space O(n)\\n\\n    pairs.forEach((p) => { // Time O(n)\\n        const [x, y] = p;\\n        ds.union(x, y); // Time O(a(n)), amortized O(1)\\n    });\\n    \\n    // Step 2, group chars into a set by root\\n    const rootSets = {};\\n    for(let i = 0; i < sLen; i++) { // Time O(n)\\n        const set = ds.find(i); // Time O(a(n)), amortized O(1)\\n        const char = s[i];\\n        \\n        if(!rootSets[set]) {\\n            rootSets[set] = [];\\n        }\\n        rootSets[set].push(char);\\n    }\\n    \\n    // Step 3, sort chars within each set by alphabetic order\\n    Object.keys(rootSets).forEach((key) => { // Time O(n log n)\\n        const sortedChars = rootSets[key].sort();\\n        rootSets[key] = new Queue(sortedChars);\\n    });\\n    \\n    // Step 4, generate result stringby alphabetically sorted sets\\n    let sortedS = \\'\\'\\n    for(let i = 0; i < sLen; i++) { // Time O(n)\\n        const set = ds.find(i);\\n        const char = rootSets[set].dequeue();\\n        sortedS += char;\\n    }\\n\\n    return sortedS;\\n};\\n\\nclass DisjointSet {\\n    constructor(n) {\\n        this.parent = Array(n).fill().map((_, i) => i);\\n        this.rank = Array(n).fill(1);\\n    }\\n    \\n    // optimized with path compression\\n    find(x) { // Time O(a(n)), amortized O(1)\\n        if(x === this.parent[x]) {\\n            return this.parent[x];\\n        }\\n        \\n        this.parent[x] = this.find(this.parent[x]);\\n        return this.parent[x];\\n    }\\n    \\n    // optmized ranked union\\n    union(x, y) { // Time O(a(n)), amortized O(1)\\n        const pX = this.find(x);\\n        const pY = this.find(y);\\n        if(pX !== pY) {\\n            if(this.rank[pX] > this.rank[pY]) {\\n                this.parent[pY] = this.parent[pX];\\n            } else if(this.rank[pX] < this.rank[pY]) {\\n                this.parent[pX] = this.parent[pY];\\n            } else {\\n                this.parent[pY] = this.parent[pX];\\n                this.rank[pX] += 1;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1583619,
                "title": "java-union-find-99",
                "content": "```\\nclass Solution {\\n    int[] root;\\n    \\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        if (s == null || s.length() == 0) return s;\\n        int n = s.length();\\n        this.root = new int[n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            root[i] = i;\\n        }\\n        \\n        for (List<Integer> pair : pairs) {\\n            union(pair.get(0), pair.get(1));\\n        }\\n        \\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        \\n        for (int i = 0; i < n; i++) {\\n            int root = find(i);\\n            if (!map.containsKey(root)) {\\n                map.put(root, new ArrayList<>());\\n            }\\n            map.get(root).add(i);\\n        }\\n        \\n        char[] res = new char[n];\\n        \\n        for (Map.Entry<Integer, List<Integer>> entry : map.entrySet()) {\\n            List<Integer> list = entry.getValue();\\n            \\n            char[] chs = new char[list.size()];\\n            for (int i = 0; i < list.size(); i++) {\\n                chs[i] = s.charAt(list.get(i));\\n            }\\n            Arrays.sort(chs);\\n\\t\\t\\t// from my perspective, I need to sort it into ascending order\\n\\t\\t\\t// in order to set char in the right place\\n\\t\\t\\t// but actually I don\\'t need to do this.\\n\\t\\t\\t// my mistake or test case wrong? \\n            // Collections.sort(list);\\n        \\n            for (int i = 0; i < list.size(); i++) {\\n                res[list.get(i)] = chs[i];\\n            }\\n        }\\n        \\n        return String.valueOf(res);\\n    }\\n    \\n    private int find(int x) {\\n        if (x != root[x]) {\\n            root[x] = find(root[x]);\\n        }\\n        return root[x];\\n    }\\n    \\n    private void union(int x, int y) {\\n        int rootX = find(x);\\n        int rootY = find(y);\\n        \\n        if (rootX != rootY) {\\n            root[rootX] = rootY;\\n        }\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] root;\\n    \\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        if (s == null || s.length() == 0) return s;\\n        int n = s.length();\\n        this.root = new int[n];\\n        \\n        for (int i = 0; i < n; i++) {\\n            root[i] = i;\\n        }\\n        \\n        for (List<Integer> pair : pairs) {\\n            union(pair.get(0), pair.get(1));\\n        }\\n        \\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        \\n        for (int i = 0; i < n; i++) {\\n            int root = find(i);\\n            if (!map.containsKey(root)) {\\n                map.put(root, new ArrayList<>());\\n            }\\n            map.get(root).add(i);\\n        }\\n        \\n        char[] res = new char[n];\\n        \\n        for (Map.Entry<Integer, List<Integer>> entry : map.entrySet()) {\\n            List<Integer> list = entry.getValue();\\n            \\n            char[] chs = new char[list.size()];\\n            for (int i = 0; i < list.size(); i++) {\\n                chs[i] = s.charAt(list.get(i));\\n            }\\n            Arrays.sort(chs);\\n\\t\\t\\t// from my perspective, I need to sort it into ascending order\\n\\t\\t\\t// in order to set char in the right place\\n\\t\\t\\t// but actually I don\\'t need to do this.\\n\\t\\t\\t// my mistake or test case wrong? \\n            // Collections.sort(list);\\n        \\n            for (int i = 0; i < list.size(); i++) {\\n                res[list.get(i)] = chs[i];\\n            }\\n        }\\n        \\n        return String.valueOf(res);\\n    }\\n    \\n    private int find(int x) {\\n        if (x != root[x]) {\\n            root[x] = find(root[x]);\\n        }\\n        return root[x];\\n    }\\n    \\n    private void union(int x, int y) {\\n        int rootX = find(x);\\n        int rootY = find(y);\\n        \\n        if (rootX != rootY) {\\n            root[rootX] = rootY;\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1341189,
                "title": "c-union-find-solution-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        //the indices within one componenet will be swapped to any places\\n        //use union find to create disjoint sets\\n        \\n        int n=s.length();\\n        //every index is itself a parent\\n        \\n        vector<int> parent(n,-1);\\n        \\n        //union the pairs given in the pairs array\\n        for(int i=0;i<pairs.size();i++)\\n        {\\n            int p1=find(parent,pairs[i][0]);\\n            int p2=find(parent,pairs[i][1]);\\n            if(p1!=p2)\\n            {\\n                //union them\\n                parent[p2]=p1;\\n            }\\n        }\\n        \\n        \\n        vector<vector<int>> store(n);\\n        //now get the all characters that have same root and sort them\\n        for(int i=0;i<n;i++)\\n        {\\n            int p=find(parent,i);\\n            store[p].push_back(i);\\n        }\\n        \\n        for(auto ind:store)\\n        {\\n            //ss stores the sorted string\\n            string ss=\"\";\\n            for(auto i:ind)\\n            {\\n                //get the char at the indices and sort them and rearrange them\\n                ss.push_back(s[i]);\\n            }\\n            sort(ss.begin(),ss.end());\\n            //now replace the char in s with that of in ss in order\\n            int j=0;\\n            for(auto i:ind)\\n            {\\n                s[i]=ss[j++];\\n            }\\n        }\\n        \\n        return s;\\n        \\n    }\\n    \\n    //here we are using path compression\\n    //i.e., the parent of x will directly stores the root value\\n    int find(vector<int>& parent,int x)\\n    {\\n        return parent[x] < 0 ? x : parent[x]=find(parent,parent[x]); \\n    }\\n};\\n```\\n**Upvote if this helps you :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        //the indices within one componenet will be swapped to any places\\n        //use union find to create disjoint sets\\n        \\n        int n=s.length();\\n        //every index is itself a parent\\n        \\n        vector<int> parent(n,-1);\\n        \\n        //union the pairs given in the pairs array\\n        for(int i=0;i<pairs.size();i++)\\n        {\\n            int p1=find(parent,pairs[i][0]);\\n            int p2=find(parent,pairs[i][1]);\\n            if(p1!=p2)\\n            {\\n                //union them\\n                parent[p2]=p1;\\n            }\\n        }\\n        \\n        \\n        vector<vector<int>> store(n);\\n        //now get the all characters that have same root and sort them\\n        for(int i=0;i<n;i++)\\n        {\\n            int p=find(parent,i);\\n            store[p].push_back(i);\\n        }\\n        \\n        for(auto ind:store)\\n        {\\n            //ss stores the sorted string\\n            string ss=\"\";\\n            for(auto i:ind)\\n            {\\n                //get the char at the indices and sort them and rearrange them\\n                ss.push_back(s[i]);\\n            }\\n            sort(ss.begin(),ss.end());\\n            //now replace the char in s with that of in ss in order\\n            int j=0;\\n            for(auto i:ind)\\n            {\\n                s[i]=ss[j++];\\n            }\\n        }\\n        \\n        return s;\\n        \\n    }\\n    \\n    //here we are using path compression\\n    //i.e., the parent of x will directly stores the root value\\n    int find(vector<int>& parent,int x)\\n    {\\n        return parent[x] < 0 ? x : parent[x]=find(parent,parent[x]); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1149281,
                "title": "python3-union-find",
                "content": "\\n```\\nclass UnionFind:\\n    def __init__(self, n): \\n        self.parent = list(range(n))\\n        self.rank = [1]*n\\n    \\n    def find(self, p): \\n        if self.parent[p] != p: \\n            self.parent[p] = self.find(self.parent[p])\\n        return self.parent[p]\\n    \\n    def union(self, p, q):\\n        prt, qrt = self.find(p), self.find(q)\\n        if prt == qrt: return False # already connected \\n        if prt > qrt: prt, qrt = qrt, prt\\n        self.parent[prt] = qrt\\n        self.rank[qrt] += self.rank[prt]\\n        return True \\n    \\n\\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        s = list(s)\\n        \\n        uf = UnionFind(len(s))\\n        for u, v in pairs: \\n            uf.union(u, v)\\n        \\n        mp = {}\\n        for n in range(len(s)):\\n            mp.setdefault(uf.find(n), []).append(n)\\n        \\n        for v in mp.values(): \\n            vals = [s[vv] for vv in v]\\n            for vv, xx in zip(v, sorted(vals)):\\n                s[vv] = xx\\n        return \"\".join(s)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass UnionFind:\\n    def __init__(self, n): \\n        self.parent = list(range(n))\\n        self.rank = [1]*n\\n    \\n    def find(self, p): \\n        if self.parent[p] != p: \\n            self.parent[p] = self.find(self.parent[p])\\n        return self.parent[p]\\n    \\n    def union(self, p, q):\\n        prt, qrt = self.find(p), self.find(q)\\n        if prt == qrt: return False # already connected \\n        if prt > qrt: prt, qrt = qrt, prt\\n        self.parent[prt] = qrt\\n        self.rank[qrt] += self.rank[prt]\\n        return True \\n    \\n\\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        s = list(s)\\n        \\n        uf = UnionFind(len(s))\\n        for u, v in pairs: \\n            uf.union(u, v)\\n        \\n        mp = {}\\n        for n in range(len(s)):\\n            mp.setdefault(uf.find(n), []).append(n)\\n        \\n        for v in mp.values(): \\n            vals = [s[vv] for vv in v]\\n            for vv, xx in zip(v, sorted(vals)):\\n                s[vv] = xx\\n        return \"\".join(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1009725,
                "title": "easy-python",
                "content": "```\\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        def find(u):\\n            while u != parents[u]:\\n                parents[u] = parents[parents[u]]\\n                u = parents[u]\\n            return u\\n        \\n        # union-find data structure\\n        parents = [i for i in range(len(s))]\\n        for u,v in pairs:\\n            if find(u) != find(v):\\n                parents[find(v)] = find(u)\\n        \\n        # map for components, sorted nodes as well\\n        components_map = defaultdict(list)\\n        for i,a in enumerate(s):\\n            components_map[find(i)].append(a)\\n        \\n        # sort\\n        for v in components_map.values():\\n            v.sort(reverse=True) # cuz i will pop from right\\n        \\n        # assign\\n        sorted_string = []\\n        \\n        for i, a in enumerate(s):\\n            # find the root and get the smallest alphabet from that component\\n            x = components_map[find(i)].pop()\\n            sorted_string.append(x)\\n        \\n        return \"\".join(sorted_string)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        def find(u):\\n            while u != parents[u]:\\n                parents[u] = parents[parents[u]]\\n                u = parents[u]\\n            return u\\n        \\n        # union-find data structure\\n        parents = [i for i in range(len(s))]\\n        for u,v in pairs:\\n            if find(u) != find(v):\\n                parents[find(v)] = find(u)\\n        \\n        # map for components, sorted nodes as well\\n        components_map = defaultdict(list)\\n        for i,a in enumerate(s):\\n            components_map[find(i)].append(a)\\n        \\n        # sort\\n        for v in components_map.values():\\n            v.sort(reverse=True) # cuz i will pop from right\\n        \\n        # assign\\n        sorted_string = []\\n        \\n        for i, a in enumerate(s):\\n            # find the root and get the smallest alphabet from that component\\n            x = components_map[find(i)].pop()\\n            sorted_string.append(x)\\n        \\n        return \"\".join(sorted_string)",
                "codeTag": "Java"
            },
            {
                "id": 921351,
                "title": "python-easy-to-understand-solution",
                "content": "```\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        \\n        res_list = [\"\"]*len(s)\\n        adj_list = defaultdict(list)\\n        \\n\\t\\t#create an adjaceny matrix based on the pairs\\n        for u, v in pairs:\\n            adj_list[u].append(v)\\n            adj_list[v].append(u)\\n            \\n        seen = set()\\n        \\n        def dfs(node, connected_idx, connected_let):\\n            seen.add(node)\\n            connected_idx.append(node) #for each connected component maintain a list of the indexes\\n            connected_let.append(s[node]) #and the letters\\n            for node in adj_list[node]:\\n                if node not in seen:\\n                    dfs(node, connected_idx, connected_let)\\n        \\n        for i in range(len(s)):\\n            if i not in seen:\\n                connected_idx = []\\n                connected_let = []\\n                dfs(i, connected_idx, connected_let)\\n                connected_idx.sort() #sort the indexes\\n                connected_let.sort() #and the letters\\n                for a, b in zip(connected_idx, connected_let):\\n                    res_list[a] = b  #assign the sorted letters in that connected component to that index\\n                    \\n        return \"\".join(res_list)\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        \\n        res_list = [\"\"]*len(s)\\n        adj_list = defaultdict(list)\\n        \\n\\t\\t#create an adjaceny matrix based on the pairs\\n        for u, v in pairs:\\n            adj_list[u].append(v)\\n            adj_list[v].append(u)\\n            \\n        seen = set()\\n        \\n        def dfs(node, connected_idx, connected_let):\\n            seen.add(node)\\n            connected_idx.append(node) #for each connected component maintain a list of the indexes\\n            connected_let.append(s[node]) #and the letters\\n            for node in adj_list[node]:\\n                if node not in seen:\\n                    dfs(node, connected_idx, connected_let)\\n        \\n        for i in range(len(s)):\\n            if i not in seen:\\n                connected_idx = []\\n                connected_let = []\\n                dfs(i, connected_idx, connected_let)\\n                connected_idx.sort() #sort the indexes\\n                connected_let.sort() #and the letters\\n                for a, b in zip(connected_idx, connected_let):\\n                    res_list[a] = b  #assign the sorted letters in that connected component to that index\\n                    \\n        return \"\".join(res_list)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 668920,
                "title": "python-union-find-solution-with-detailed-explanation",
                "content": "This approach exploits the union-find data structure. \\n\\nThis is a great data structure if you need to keep track of the connectivity of elements in a graph-like structure\\nwhile avoiding the creation of cycles. You can quickly determine whether two elements are connected by the\\nsame sub-graph, or exist in two different subgraphs that have no connection.\\n\\nSee this link for an overview if you aren\\'t familiar with it: \\n--> https://www.hackerearth.com/practice/notes/disjoint-set-union-union-find/\\n\\nThe basic premise here is that the pair operations define how string characters \\ncan \\'flow\\' between different slots (i.e. positions within the string). Exhaustively \\ncombining and permuting the order of the pair operations would eventually produce \\neach unique end-state, but this is not computationally efficient. Instead we aim to find\\nwhich slots are connected by the pair operations. If slots are connected, then we can freely\\npermute characters between them, and return the lexiconographically-smallest permutation\\nfor each subset of conncted slots. \\n\\n**Union-Find Approach Overview:**\\n* Treat each character \\'slot\\' as a node. \\n* We want to find which nodes are connected (both directly and directly) by swap operations.\\n  If nodes are connected, then string characters will be allowed to flow between them. \\n* Connecting nodes A and B is done by a union(A, B) operation. We can think of these\\n  operations as constructing trees. Each connected subset of nodes will form a separate tree. \\n  Union between nodes on two different trees will result in those trees being connected together.\\n* We label each tree (or connected node subset) by a root node. The union(A,B) will connect A and B by\\n connecting their roots, and will do nothing if they already share the same root. \\n* To determine whether two nodes are connected, we look up and compare their roots. Nodes belonging to the same linked tree \\nwill have the same root. \\n* As a further optimization, we keep track of the size of each root (i.e. number of children), and \\n  connect the smaller root to the larger root. This helps produce a balanced tree which reduces\\n  the number of node traversals needed when looking up the root of a given node. \\n  \\n**Code:**\\n  ```\\n  class Solution:\\n    \\n    def __init__(self):\\n        self.parent = []  # tracks the current parent node of slot at index i\\n        self.size = [] # if index i is a root, tracks the current size of that tree\\n    \\n    def get_root(self, A):\\n        # roots, by definition, are their own parents, \\n        # so we have found a root R if self.parent[R] = R\\n        if self.parent[A] == A:\\n            return A\\n        self.parent[A] = self.get_root(self.parent[A])\\n        return self.parent[A]\\n        \\n    \\n    def union(self, A, B):\\n        # We only perform a union if nodes A and B aren\\'t already connected.\\n        # They are connected if they share the same root.\\n        root_A, root_B = self.get_root(A), self.get_root(B)\\n        if root_A != root_B:\\n            # We perform the union by connecting the smaller root to the larger root,\\n            # i.e. a \\'weighted union operation\\'; this ensures a balanced tree which\\n            # minimizes our traversals when we\\'re looking up the root.\\n            total_size = self.size[root_A] + self.size[root_A]\\n            if self.size[root_A] <= self.size[root_B]:\\n                self.parent[root_A] = root_B\\n                self.size[root_A] = total_size\\n            else:\\n                self.parent[root_B] = root_A\\n                self.size[root_B] = total_size\\n            \\n    \\n    def smallestStringWithSwaps(self, s, pairs):\\n        # initialize\\n        num_nodes = len(s)\\n        self.parent = [x for x in range(num_nodes)]\\n        self.size = [1 for x in range(num_nodes)]\\n        \\n        # construct the trees\\n        for A, B in pairs:\\n            self.union(A, B)\\n        \\n        # sort each string slot and character by root;\\n        # there is one unique root for each subset of \\n        # connected slots (i.e. nodes)\\n        slots_by_root = {}\\n        chars_by_root = {}\\n        for i in range(num_nodes):\\n            root = self.get_root(i)\\n            if root not in slots_by_root:\\n                slots_by_root[root] = [i]\\n                chars_by_root[root] = [s[i]]\\n            else:\\n                slots_by_root[root].append(i)\\n                chars_by_root[root].append(s[i])\\n                \\n        # for each root, sort its characters\\n        # lexicographically among its slots; we\\'ll\\n        # use a dummy result to make this easier\\n        result = [\\'\\' for x in range(num_nodes)]\\n        for root in slots_by_root:\\n            sorted_characters = sorted(chars_by_root[root])\\n            for index, slot in enumerate(slots_by_root[root]):\\n                result[slot] = sorted_characters[index]\\n        result = \\'\\'.join(result) # convert from list back to concatentated string\\n    \\n        return result\\n```",
                "solutionTags": [
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\n  class Solution:\\n    \\n    def __init__(self):\\n        self.parent = []  # tracks the current parent node of slot at index i\\n        self.size = [] # if index i is a root, tracks the current size of that tree\\n    \\n    def get_root(self, A):\\n        # roots, by definition, are their own parents, \\n        # so we have found a root R if self.parent[R] = R\\n        if self.parent[A] == A:\\n            return A\\n        self.parent[A] = self.get_root(self.parent[A])\\n        return self.parent[A]\\n        \\n    \\n    def union(self, A, B):\\n        # We only perform a union if nodes A and B aren\\'t already connected.\\n        # They are connected if they share the same root.\\n        root_A, root_B = self.get_root(A), self.get_root(B)\\n        if root_A != root_B:\\n            # We perform the union by connecting the smaller root to the larger root,\\n            # i.e. a \\'weighted union operation\\'; this ensures a balanced tree which\\n            # minimizes our traversals when we\\'re looking up the root.\\n            total_size = self.size[root_A] + self.size[root_A]\\n            if self.size[root_A] <= self.size[root_B]:\\n                self.parent[root_A] = root_B\\n                self.size[root_A] = total_size\\n            else:\\n                self.parent[root_B] = root_A\\n                self.size[root_B] = total_size\\n            \\n    \\n    def smallestStringWithSwaps(self, s, pairs):\\n        # initialize\\n        num_nodes = len(s)\\n        self.parent = [x for x in range(num_nodes)]\\n        self.size = [1 for x in range(num_nodes)]\\n        \\n        # construct the trees\\n        for A, B in pairs:\\n            self.union(A, B)\\n        \\n        # sort each string slot and character by root;\\n        # there is one unique root for each subset of \\n        # connected slots (i.e. nodes)\\n        slots_by_root = {}\\n        chars_by_root = {}\\n        for i in range(num_nodes):\\n            root = self.get_root(i)\\n            if root not in slots_by_root:\\n                slots_by_root[root] = [i]\\n                chars_by_root[root] = [s[i]]\\n            else:\\n                slots_by_root[root].append(i)\\n                chars_by_root[root].append(s[i])\\n                \\n        # for each root, sort its characters\\n        # lexicographically among its slots; we\\'ll\\n        # use a dummy result to make this easier\\n        result = [\\'\\' for x in range(num_nodes)]\\n        for root in slots_by_root:\\n            sorted_characters = sorted(chars_by_root[root])\\n            for index, slot in enumerate(slots_by_root[root]):\\n                result[slot] = sorted_characters[index]\\n        result = \\'\\'.join(result) # convert from list back to concatentated string\\n    \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 470991,
                "title": "python3-disjoint-sets",
                "content": "I am really happy to solve this problem after several attempts.\\nI did not know about Union-Find approach beforehand, just tried with what I thought without looking at hints or dicussions. I spent almost a day to solve it.\\nAny recommend on improving the code is absolutely appreciated.\\n\\n```python\\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        p = {}\\n\\n        def getP(i: int) -> int:\\n            if i not in p:\\n                return -1\\n            return i if p[i] == i else getP(p[i])\\n\\n        uf = {}\\n        index = 0\\n        for (x, y) in pairs:\\n            px = getP(x)\\n            py = getP(y)\\n            if px == -1 and py == -1:\\n                p[x] = min(x, y)\\n                p[y] = min(x, y)\\n                uf[min(x, y)] = pairs[index]\\n            elif px == -1:\\n                uf[py].append(x)\\n                p[x] = py\\n            elif py == -1:\\n                uf[px].append(y)\\n                p[y] = px\\n            elif px != py:\\n                p[px] = min(px, py)\\n                p[py] = min(px, py)\\n                uf[min(px, py)] += uf.pop(max(px, py))\\n            index += 1\\n        ans = list(s)\\n        for k in uf.keys():\\n            st = sorted(set(uf[k]))\\n            tmp = [s[i] for i in st]\\n            tmp.sort()\\n            idx = 0\\n            for i in st:\\n                ans[i] = tmp[idx]\\n                idx += 1\\n        return \\'\\'.join(ans)\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Union Find"
                ],
                "code": "```python\\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        p = {}\\n\\n        def getP(i: int) -> int:\\n            if i not in p:\\n                return -1\\n            return i if p[i] == i else getP(p[i])\\n\\n        uf = {}\\n        index = 0\\n        for (x, y) in pairs:\\n            px = getP(x)\\n            py = getP(y)\\n            if px == -1 and py == -1:\\n                p[x] = min(x, y)\\n                p[y] = min(x, y)\\n                uf[min(x, y)] = pairs[index]\\n            elif px == -1:\\n                uf[py].append(x)\\n                p[x] = py\\n            elif py == -1:\\n                uf[px].append(y)\\n                p[y] = px\\n            elif px != py:\\n                p[px] = min(px, py)\\n                p[py] = min(px, py)\\n                uf[min(px, py)] += uf.pop(max(px, py))\\n            index += 1\\n        ans = list(s)\\n        for k in uf.keys():\\n            st = sorted(set(uf[k]))\\n            tmp = [s[i] for i in st]\\n            tmp.sort()\\n            idx = 0\\n            for i in st:\\n                ans[i] = tmp[idx]\\n                idx += 1\\n        return \\'\\'.join(ans)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 387797,
                "title": "java-union-find-solution-with-explanation-and-inline-comments",
                "content": "Idea:\\n\\nwe can group the indexes which are associated via pairs together with `union-find`. The indexes with same id are in the same group. When constructing the result string from the first index, we pick the first letter in lexicographical order in the corresponding index group.\\n\\nThe union-find methods are classic and powerful. I strongly recommend to master union-find algorithm. Here are some good Union-Find problems to enhance your understanding:\\n[number-of-islands](https://leetcode.com/problems/number-of-islands/description/)\\n[regions-cut-by-slashes](https://leetcode.com/problems/regions-cut-by-slashes/description/)\\n[surrounded-regions](https://leetcode.com/problems/surrounded-regions/description/)\\n\\n\\n```\\nclass Solution {\\n    private int[] ids;  // ids[i] = the id of the string index i. The string indexes with same id are in the same group.\\n    private Map<Integer, int[]> idToGroup; // key: id, value: letters with frequency\\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        StringBuilder sb = new StringBuilder();\\n        \\n        this.ids = new int[s.length()];\\n        this.idToGroup = new HashMap<>();\\n\\t\\t\\n\\t\\t// initialization\\n        for (int i = 0; i < s.length(); i++) {\\n            this.ids[i] = i;\\n        }\\n        \\n        for (List<Integer> p : pairs) {\\n            union(p.get(0), p.get(1));\\n        }\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            int iId = find(i);\\n            if (!this.idToGroup.containsKey(iId)) {\\n                this.idToGroup.put(iId, new int[26]);\\n            }\\n            this.idToGroup.get(iId)[s.charAt(i) - \\'a\\']++;  // get the letter frequency\\n        }\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            int iId = find(i);\\n            int[] group = this.idToGroup.get(iId);\\n            for (int j = 0; j < group.length; j++) {\\n                if (group[j] > 0) { // pick the first letter in lexicographical order\\n                    sb.append((char)(\\'a\\' + j));\\n                    group[j]--; // update the frequency since the letter has been used and cannot be reused anymore\\n                    break;\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n    \\n\\t// classic find method\\n    private int find(int x) {\\n        if (this.ids[x] != x) {\\n            this.ids[x] = find(this.ids[x]); // path compression to improve efficiency\\n        }\\n        return this.ids[x];\\n    }\\n    \\n\\t// classic union method\\n    private void union(int x, int y) {\\n        int xId = find(x), yId = find(y);\\n        if (xId != yId) {\\n            this.ids[xId] = yId;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int[] ids;  // ids[i] = the id of the string index i. The string indexes with same id are in the same group.\\n    private Map<Integer, int[]> idToGroup; // key: id, value: letters with frequency\\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        StringBuilder sb = new StringBuilder();\\n        \\n        this.ids = new int[s.length()];\\n        this.idToGroup = new HashMap<>();\\n\\t\\t\\n\\t\\t// initialization\\n        for (int i = 0; i < s.length(); i++) {\\n            this.ids[i] = i;\\n        }\\n        \\n        for (List<Integer> p : pairs) {\\n            union(p.get(0), p.get(1));\\n        }\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            int iId = find(i);\\n            if (!this.idToGroup.containsKey(iId)) {\\n                this.idToGroup.put(iId, new int[26]);\\n            }\\n            this.idToGroup.get(iId)[s.charAt(i) - \\'a\\']++;  // get the letter frequency\\n        }\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            int iId = find(i);\\n            int[] group = this.idToGroup.get(iId);\\n            for (int j = 0; j < group.length; j++) {\\n                if (group[j] > 0) { // pick the first letter in lexicographical order\\n                    sb.append((char)(\\'a\\' + j));\\n                    group[j]--; // update the frequency since the letter has been used and cannot be reused anymore\\n                    break;\\n                }\\n            }\\n        }\\n        return sb.toString();\\n    }\\n    \\n\\t// classic find method\\n    private int find(int x) {\\n        if (this.ids[x] != x) {\\n            this.ids[x] = find(this.ids[x]); // path compression to improve efficiency\\n        }\\n        return this.ids[x];\\n    }\\n    \\n\\t// classic union method\\n    private void union(int x, int y) {\\n        int xId = find(x), yId = find(y);\\n        if (xId != yId) {\\n            this.ids[xId] = yId;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 387766,
                "title": "python-union-find-w-explanation-w-tldr",
                "content": "# TLDR:\\n\\nCollecting the swappable pairs to form mutually swappable groups using Union find algorithm. Then sort the characters in each group. Voila.\\n\\n# Observation:\\nFrom the given examples, we can observe that, if there exist overlapped elements in two pairs, these two pairs can form a mutually swappable group with three elements. And it is also true for bigger group.\\n\\nTo form a lexicographically smallest string, we need all the group in their lexicographically smallest order, which can be easily done with the build-in `sorted` function.\\n\\n> Therefore, our target is to collect the groups.\\n\\n# Code:\\n\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        if not pairs:\\n            return s\\n        \\n        class UnionFind:\\n            def __init__(self, n):\\n                self.n = n\\n                self.sz = [1] * n\\n                self.gp = list(range(n))\\n\\n            def find(self, x):\\n                xi = x\\n                if self.gp[x] != x:\\n                    xi = self.find(self.gp[x])\\n                    # path compression\\n                    self.gp[x] = xi\\n                return xi\\n\\n            def union(self, x, y):\\n                xi = self.find(x)\\n                yi = self.find(y)\\n                if xi != yi: \\n                    # tree balancing\\n                    p, c = (xi, yi) if self.sz[xi] > self.sz[yi] else (yi, xi)\\n                    self.gp[c] = p \\n                    self.sz[p] += self.sz[c]\\n\\n            def __repr__(self):\\n                return \"{}\\\\n{}\\\\n{}\".format(list(range(len(self.gp))), self.gp, self.sz)\\n        \\n            def getGroups(self):\\n                groups = defaultdict(list)\\n                for i in range(self.n):\\n                    groups[self.find(i)] += [i]\\n                return groups.values()\\n        \\n\\t\\t# Use union find to build up groups\\n        uf = UnionFind(len(s))\\n        for x, y in pairs:\\n            uf.union(x, y)\\n\\t\\t\\t\\n\\t\\t# Modify the string\\n        s = list(s)\\n        for g in uf.getGroups():\\n            for i, c in zip(sorted(g), sorted(s[i] for i in g)):\\n                s[i] = c\\n        return \\'\\'.join(s)\\n```\\n\\n# Union find quick review:\\nWe first build an array for each element to represent their belonging group (`self.gp`), and at the beginning, each element in their own group (`self.gp[i] == i`).\\n\\n## Union operation\\nFor `union`, we make an indirect addressing. We modify one element\\'s (`x`) group to the other element (`y`) (`self.gp[x] = y`), which is forming a tree containing `x` and `y` with `y` as root. And now, the `y` is the name of this group.\\n\\n\\n## Find operation\\nTo find out the group containing element `z`, we need to look up its group name. Since after several `union` operation, the value saved in `self.gp` may not be the root value of the group tree, so we need to get the root element with recursivly call the `find`.\\n\\n\\n## Balancing:\\nIf we `union` two group randomly, the resulting tree may be extremly skew (like a linked list), which will make the `find` operation costs more time. To avoid that, when we union two group (tree) containing elements `x` and `y`, we make the smaller one as the subtree of the bigger one.\\n\\n## Path compression:\\nWe can easily make the indirect addressing to direct one, with a lasy approach.\\nOnce we call the `find` operation and find out the current group name is not the root group name, we can modify it during the operation and almost cost nothing.\\n\\n\\n# Result:\\nRuntime: 824 ms, faster than 100.00% of Python3 online submissions for Smallest String With Swaps.\\nMemory Usage: 50.3 MB, less than 100.00% of Python3 online submissions for Smallest String With Swaps.\\n\\n## Reference:\\nhttps://www.cs.princeton.edu/~rs/AlgsDS07/01UnionFind.pdf\\nThis pdf from Princeton gives a clear explanation and illustration.\\n",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        if not pairs:\\n            return s\\n        \\n        class UnionFind:\\n            def __init__(self, n):\\n                self.n = n\\n                self.sz = [1] * n\\n                self.gp = list(range(n))\\n\\n            def find(self, x):\\n                xi = x\\n                if self.gp[x] != x:\\n                    xi = self.find(self.gp[x])\\n                    # path compression\\n                    self.gp[x] = xi\\n                return xi\\n\\n            def union(self, x, y):\\n                xi = self.find(x)\\n                yi = self.find(y)\\n                if xi != yi: \\n                    # tree balancing\\n                    p, c = (xi, yi) if self.sz[xi] > self.sz[yi] else (yi, xi)\\n                    self.gp[c] = p \\n                    self.sz[p] += self.sz[c]\\n\\n            def __repr__(self):\\n                return \"{}\\\\n{}\\\\n{}\".format(list(range(len(self.gp))), self.gp, self.sz)\\n        \\n            def getGroups(self):\\n                groups = defaultdict(list)\\n                for i in range(self.n):\\n                    groups[self.find(i)] += [i]\\n                return groups.values()\\n        \\n\\t\\t# Use union find to build up groups\\n        uf = UnionFind(len(s))\\n        for x, y in pairs:\\n            uf.union(x, y)\\n\\t\\t\\t\\n\\t\\t# Modify the string\\n        s = list(s)\\n        for g in uf.getGroups():\\n            for i, c in zip(sorted(g), sorted(s[i] for i in g)):\\n                s[i] = c\\n        return \\'\\'.join(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 387716,
                "title": "python-union-find-with-explanation-9-liner",
                "content": "If you memorize the Union Find data structure or you have coded it before, you can copy and paste it. The solution itself is 9 lines. Here is the structure you can memorize or just copy: \\n\\n```\\nclass UF(object):\\n    \\n    def __init__(self):\\n        self.parent = [i for i in range(100001)]\\n        self.rank = [0]*100001\\n        \\n    def find(self, x):\\n        if self.parent[x] == x: \\n            return x \\n        return self.find(self.parent[x])\\n    \\n    def union(self, x, y):\\n        setx, sety = self.find(x), self.find(y)\\n        if setx == sety: return False\\n        elif self.rank[setx] < self.rank[sety]:\\n            self.parent[setx] = sety\\n        elif self.rank[sety] < self.rank[setx]:\\n            self.parent[sety] = setx\\n        else: \\n            self.parent[sety] = setx\\n            self.rank[setx] += 1\\n        return True \\n```\\n\\nIntuition: Right away you can see that the pairs form a graph structure. If you create a visual, you are connecting nodes that are paired with each other until you are done. If you draw this on paper, you can see that you\\'ll have several unconnected graphs. This is what Union Find is perfect for. Anytime you see a question where you can see graphs that aren\\'t connected with each other, consider Union Find. You can usually solve Union Find with DFS/BFS as well, but Union Find is a little cleaner. \\n\\nFor Union Find solutions you usually need 2 hashmaps. 1 hashmap that tells you the nodes in each graph (since you have many unconnected graphs, you need to define these graphs. I just use a #. #1 graph, #2 graph, etc). The 2nd hashmap maps a node with its graph #. \\n\\nIn Union Find, there are 2 functions: 1). Union -- it unions nodes together in a graph. 2). Find -- it finds the parent of the node. The parent is one of the nodes in the graph, it doesn\\'t matter which node. \\n\\nFor more info on Union Find, you can lookup the ackermann function. The Union Find structure below is organized by Union By Rank. This means when you are unioning two unconnected graphs, you are taking the lower rank graph and adding it onto the higher rank graph (this is because the lower rank has fewer nodes, and adding it to the graph with more nodes is \"cheaper\" in terms of time). \\n\\n```\\nclass UF(object):\\n    \\n    def __init__(self):\\n        self.parent = [i for i in range(100001)]\\n        self.rank = [0]*100001\\n        \\n    def find(self, x):\\n        if self.parent[x] == x: \\n            return x \\n        return self.find(self.parent[x])\\n    \\n    def union(self, x, y):\\n        setx, sety = self.find(x), self.find(y)\\n        if setx == sety: return False\\n        elif self.rank[setx] < self.rank[sety]:\\n            self.parent[setx] = sety\\n        elif self.rank[sety] < self.rank[setx]:\\n            self.parent[sety] = setx\\n        else: \\n            self.parent[sety] = setx\\n            self.rank[setx] += 1\\n        return True \\n\\nclass Solution(object):\\n    def smallestStringWithSwaps(self, s, pairs):\\n        \"\"\"\\n        :type s: str\\n        :type pairs: List[List[int]]\\n        :rtype: str\\n        \"\"\"\\n        u, graph, groups, res = UF(), collections.defaultdict(int), collections.defaultdict(list), []\\n        for x, y in pairs: \\n            u.union(x, y)\\n        for i in range(len(s)):\\n            groups[u.find(i)].append(s[i])\\n            graph[i] = u.find(i)\\n        for k in groups.keys():\\n            groups[k] = collections.deque(sorted(groups[k]))\\n        return \"\".join([groups[graph[i]].popleft() for i in range(len(s))])        \\n```",
                "solutionTags": [],
                "code": "```\\nclass UF(object):\\n    \\n    def __init__(self):\\n        self.parent = [i for i in range(100001)]\\n        self.rank = [0]*100001\\n        \\n    def find(self, x):\\n        if self.parent[x] == x: \\n            return x \\n        return self.find(self.parent[x])\\n    \\n    def union(self, x, y):\\n        setx, sety = self.find(x), self.find(y)\\n        if setx == sety: return False\\n        elif self.rank[setx] < self.rank[sety]:\\n            self.parent[setx] = sety\\n        elif self.rank[sety] < self.rank[setx]:\\n            self.parent[sety] = setx\\n        else: \\n            self.parent[sety] = setx\\n            self.rank[setx] += 1\\n        return True \\n```\n```\\nclass UF(object):\\n    \\n    def __init__(self):\\n        self.parent = [i for i in range(100001)]\\n        self.rank = [0]*100001\\n        \\n    def find(self, x):\\n        if self.parent[x] == x: \\n            return x \\n        return self.find(self.parent[x])\\n    \\n    def union(self, x, y):\\n        setx, sety = self.find(x), self.find(y)\\n        if setx == sety: return False\\n        elif self.rank[setx] < self.rank[sety]:\\n            self.parent[setx] = sety\\n        elif self.rank[sety] < self.rank[setx]:\\n            self.parent[sety] = setx\\n        else: \\n            self.parent[sety] = setx\\n            self.rank[setx] += 1\\n        return True \\n\\nclass Solution(object):\\n    def smallestStringWithSwaps(self, s, pairs):\\n        \"\"\"\\n        :type s: str\\n        :type pairs: List[List[int]]\\n        :rtype: str\\n        \"\"\"\\n        u, graph, groups, res = UF(), collections.defaultdict(int), collections.defaultdict(list), []\\n        for x, y in pairs: \\n            u.union(x, y)\\n        for i in range(len(s)):\\n            groups[u.find(i)].append(s[i])\\n            graph[i] = u.find(i)\\n        for k in groups.keys():\\n            groups[k] = collections.deque(sorted(groups[k]))\\n        return \"\".join([groups[graph[i]].popleft() for i in range(len(s))])        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 387588,
                "title": "python-union-find-solution-with-detailed-explanation",
                "content": "The idea is group characters by their roots (all chars that are connected share the same root), then sort all substrings and re-assign sorted characters to the original string.\\n```\\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        # all nodes have itself as root\\n        root = [i for i in range(len(s))]\\n        def find(index):\\n            if root[index] == index:\\n                return index\\n            root[index] = find(root[index])\\n            return root[index]\\n        \\n        # perform union find\\n        for f, t in pairs:\\n            root[find(t)] = find(f)\\n        \\n        # group all characters by their root\\n        # key is root index, value are all indexes that rooted at that key\\n        cache = collections.defaultdict(list)\\n        for index, its_root in enumerate(root):\\n            its_root = find(its_root)\\n            cache[its_root].append(index)\\n            \\n        result = [\"\" for i in s]\\n        for key, val in cache.items():\\n            # get substring that rooted on the key, then sort it in lexicographical order\\n            substring = sorted([s[i] for i in val])\\n            val = sorted(val)\\n            # assign the sorted substring to the result based on the chars\\' original index\\n            for substring_index, original_index in enumerate(val):\\n                result[original_index] = substring[substring_index]\\n                \\n        return \"\".join(result)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        # all nodes have itself as root\\n        root = [i for i in range(len(s))]\\n        def find(index):\\n            if root[index] == index:\\n                return index\\n            root[index] = find(root[index])\\n            return root[index]\\n        \\n        # perform union find\\n        for f, t in pairs:\\n            root[find(t)] = find(f)\\n        \\n        # group all characters by their root\\n        # key is root index, value are all indexes that rooted at that key\\n        cache = collections.defaultdict(list)\\n        for index, its_root in enumerate(root):\\n            its_root = find(its_root)\\n            cache[its_root].append(index)\\n            \\n        result = [\"\" for i in s]\\n        for key, val in cache.items():\\n            # get substring that rooted on the key, then sort it in lexicographical order\\n            substring = sorted([s[i] for i in val])\\n            val = sorted(val)\\n            # assign the sorted substring to the result based on the chars\\' original index\\n            for substring_index, original_index in enumerate(val):\\n                result[original_index] = substring[substring_index]\\n                \\n        return \"\".join(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 387579,
                "title": "python-simple-dfs-connected-graph",
                "content": "\\n\\n\\n\\tclass Solution:\\n\\t\\tdef smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n\\t\\n\\t\\t\\t# build graph\\n\\t\\t\\tgraph = {}\\n\\t\\t\\tfor node in range(len(s)):\\n\\t\\t\\t\\tgraph[node] =[]\\n\\t\\t\\tfor u,v in pairs:\\n\\t\\t\\t\\tgraph[u].append(v)\\n\\t\\t\\t\\tgraph[v].append(u)\\n\\n\\t\\t\\tposition = {} # idx -> char \\n\\t\\t\\tfor node in range(len(s)):\\n\\t\\t\\t\\tif node not in position:\\n\\t\\t\\t\\t\\tidx = set()\\n\\t\\t\\t\\t\\tself.dfs(node, idx, graph) # get connected graph idx\\n\\t\\t\\t\\t\\tself.buildPos(s, idx, position) # map idx -> char by sort\\n\\n\\t\\t\\tres = \\'\\'\\n\\t\\t\\tfor node in range(len(s)):\\n\\t\\t\\t\\tres += position[node]\\n\\t\\t\\treturn res \\n\\n\\t\\tdef buildPos(self, s, idx, position):\\n\\t\\t\\tidx_list = list(idx)\\n\\t\\t\\tchar_list = []\\n\\t\\t\\tfor idx in idx_list:\\n\\t\\t\\t\\tchar_list.append(s[idx])\\n\\t\\t\\tidx_list.sort()\\n\\t\\t\\tchar_list.sort()\\n\\t\\t\\tfor i in range(len(idx_list)):\\n\\t\\t\\t\\tposition[idx_list[i]] = char_list[i]\\n\\n\\t\\tdef dfs(self, node, idx, graph):\\n\\t\\t\\tidx.add(node)\\n\\t\\t\\tfor nei in graph[node]:\\n\\t\\t\\t\\tif nei not in idx:\\n\\t\\t\\t\\t\\tself.dfs(nei, idx, graph)\\n    \\n    \\n    \\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "class Solution:\\n\\t\\tdef smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n\\t\\n\\t\\t\\t# build graph\\n\\t\\t\\tgraph = {}",
                "codeTag": "Java"
            },
            {
                "id": 3533544,
                "title": "easy-to-understand-dfs-code",
                "content": "# Intuition\\nWe are given index pairs whose elements can be swapped.\\nWe shall be sure that for any string with no cap on the number of swaps , if  swaps occur amongst the connected index then after some number of swaps we reach the lexographically smallest string .\\n$$ Example:\\nString : bacd , pairs [1,4],[2,4],[3,4]   \\n$$\\nas all the indices are connected to one another (part of a connected component) , this string can reach the lexographically smallest string using the swaps.\\nThe transformation of the above string through the swaps will be as follows:\\n- bacd\\n- bdca (2,4 swapped)\\n- adcb (1,4 swapped)\\n- abcd (2,3 index swapped) .\\nHence, we can be sure that for any connected indices we can reach the lexographically smallest string after some swaps.\\n\\n\\n# Approach\\n\\n1. Store the indices in the form of graph using the given pairs.\\n2. Find the connected components using Depth First Search.\\n3. Store the chracters and their indices in sorted order in respective vectors.\\n4. Fill the ans string by traversing the indices vector , and place the characters from the character array one by one.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int>a[100005];\\n    vector<int>res;\\n    vector<int>index;\\n    int vis[100001];\\n    string x;\\n    void dfs(int v){\\n            vis[v]=1;\\n            res.push_back(x[v]);\\n            index.push_back(v);\\n            for(auto u:a[v])\\n                {\\n                    if(!vis[u])\\n                    dfs(u);\\n                }\\n    }\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        n=s.size();\\n        string ans=s;\\n        x=s;\\n        for(auto u:pairs)\\n        {\\n           a[u[0]].push_back(u[1]);\\n           a[u[1]].push_back(u[0]);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!vis[i]){\\n            res.clear();\\n            index.clear();\\n            dfs(i);\\n            sort(res.begin(),res.end());\\n            sort(index.begin(),index.end());\\n            int runner=0,ct=0;\\n            while(runner!=index.size())\\n            {\\n                ans[index[runner++]]=res[ct++];\\n            }\\n            }\\n        }\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int>a[100005];\\n    vector<int>res;\\n    vector<int>index;\\n    int vis[100001];\\n    string x;\\n    void dfs(int v){\\n            vis[v]=1;\\n            res.push_back(x[v]);\\n            index.push_back(v);\\n            for(auto u:a[v])\\n                {\\n                    if(!vis[u])\\n                    dfs(u);\\n                }\\n    }\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        n=s.size();\\n        string ans=s;\\n        x=s;\\n        for(auto u:pairs)\\n        {\\n           a[u[0]].push_back(u[1]);\\n           a[u[1]].push_back(u[0]);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!vis[i]){\\n            res.clear();\\n            index.clear();\\n            dfs(i);\\n            sort(res.begin(),res.end());\\n            sort(index.begin(),index.end());\\n            int runner=0,ct=0;\\n            while(runner!=index.size())\\n            {\\n                ans[index[runner++]]=res[ct++];\\n            }\\n            }\\n        }\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3481384,
                "title": "java-beats-99-85-disjoint-set-and-optimised-string-recovery",
                "content": "# Intuition\\nSince we can swap the given indexes any amount of times, all the indexes that are swapable can be considered one component in a graph (like an isolated island). \\n\\n### Example\\n```Input []\\ns = \"dcab\", pairs = [[0,3],[1,2]]\\n\\n```\\n\\nSince index `0` and `3` can be swapped, `1` and `2` can be swapped both can be considered **components in graph** (or like islands). Using Disjoint set we can connect these pairs, and then go on to sort the characters in these components.\\n\\nFor the same example above we make components and sort characters:\\n\\n```Explaination []\\ns = [d, c, a, b]\\nComponent 1: [0, 3] => [d, b]\\nComponent 2: [1, 2] => [c, a]\\n\\nAfter sorting each component and joining back string\\nComponent 1: [0, 3] => [b, d]\\nComponent 2: [1, 2] => [a, c]\\ns = [b, a, c, d]\\n```\\n``` Output []\\ns = \"bacd\"\\n```\\n\\n## Optimising string building\\nFor storing all the characters belonging to a component we use 2D-Array to store Index vs character count: `aux[n][26]`\\n\\n### Steps\\n1. We use root of any index as indicator of which component it belongs to\\n2. Build the character count array for all the root indices\\n3. Iterate through each index and check for it\\'s root and fetch least available character and decrease it\\'s count\\n4. Use the newly fetched character array to return as string\\n\\n\\n# Complexity\\n\\n> We take `E == V` here as `N` here since both are limited to `10^5` individually\\n\\n- Time complexity:\\n1. For Union-Find we iterate through all pairs: $$O(N \\\\space . \\\\space \\\\alpha(N))$$\\n2. Build chracter count: $$O(N \\\\space . \\\\space \\\\alpha(N))$$\\n3. Rebuild string: $$O(N \\\\space . \\\\space \\\\alpha(N) . \\\\space 26)$$\\n\\n\\nTime complexity: $$O(N \\\\space . \\\\space \\\\alpha(N))$$\\n\\n- Space complexity:\\n1. Union-Find: $$O(N)$$\\n2. Auxillary array: $$O(26N)$$\\n\\nSpace complexity: $$O(N)$$\\n\\n# Code\\n```\\nclass Solution {\\n    private int[][] aux;\\n    private int[] array;\\n    private int[] size;\\n    \\n    \\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        int n = s.length();\\n        aux = new int[n][];\\n        array = new int[n];\\n        size = new int[n];\\n        for(int i = 0; i < n; i++) {\\n            array[i] = i;\\n            size[i] = 1;\\n        }\\n        char[] str = s.toCharArray();\\n        \\n        for(List<Integer> pair : pairs) {\\n            union(pair.get(0), pair.get(1));\\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            int root = root(i);\\n            if(aux[root] == null) aux[root] = new int[26];\\n            aux[root][str[i] - \\'a\\']++;\\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            int root = root(i);\\n            int index = 0;\\n            while(aux[root][index] == 0) index++;\\n            aux[root][index]--;\\n            str[i] = (char) (index + \\'a\\');\\n        }\\n        return new String(str);\\n    }\\n    \\n    private boolean connected(int p, int q) {\\n        return root(p) == root(q);\\n    }\\n    \\n    private int root(int node) {\\n        while(node != array[node]) {\\n            array[node] = array[array[node]]; // Path compression\\n            node = array[node];\\n        }\\n        return node;\\n    }\\n    \\n    private void union(int p, int q) {\\n        int rootP = root(p);\\n        int rootQ = root(q);\\n        \\n        if(rootP != rootQ) {\\n            // Union by rank\\n            if(size[rootP] > size[rootQ]) {\\n                array[rootP] = rootQ;\\n            } else if(size[rootP] < size[rootQ]) {\\n                array[rootQ] = rootP;\\n            } else {\\n                array[rootP] = rootQ;\\n                size[rootQ]++;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find",
                    "Bucket Sort"
                ],
                "code": "```Input []\\ns = \"dcab\", pairs = [[0,3],[1,2]]\\n\\n```\n```Explaination []\\ns = [d, c, a, b]\\nComponent 1: [0, 3] => [d, b]\\nComponent 2: [1, 2] => [c, a]\\n\\nAfter sorting each component and joining back string\\nComponent 1: [0, 3] => [b, d]\\nComponent 2: [1, 2] => [a, c]\\ns = [b, a, c, d]\\n```\n``` Output []\\ns = \"bacd\"\\n```\n```\\nclass Solution {\\n    private int[][] aux;\\n    private int[] array;\\n    private int[] size;\\n    \\n    \\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        int n = s.length();\\n        aux = new int[n][];\\n        array = new int[n];\\n        size = new int[n];\\n        for(int i = 0; i < n; i++) {\\n            array[i] = i;\\n            size[i] = 1;\\n        }\\n        char[] str = s.toCharArray();\\n        \\n        for(List<Integer> pair : pairs) {\\n            union(pair.get(0), pair.get(1));\\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            int root = root(i);\\n            if(aux[root] == null) aux[root] = new int[26];\\n            aux[root][str[i] - \\'a\\']++;\\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            int root = root(i);\\n            int index = 0;\\n            while(aux[root][index] == 0) index++;\\n            aux[root][index]--;\\n            str[i] = (char) (index + \\'a\\');\\n        }\\n        return new String(str);\\n    }\\n    \\n    private boolean connected(int p, int q) {\\n        return root(p) == root(q);\\n    }\\n    \\n    private int root(int node) {\\n        while(node != array[node]) {\\n            array[node] = array[array[node]]; // Path compression\\n            node = array[node];\\n        }\\n        return node;\\n    }\\n    \\n    private void union(int p, int q) {\\n        int rootP = root(p);\\n        int rootQ = root(q);\\n        \\n        if(rootP != rootQ) {\\n            // Union by rank\\n            if(size[rootP] > size[rootQ]) {\\n                array[rootP] = rootQ;\\n            } else if(size[rootP] < size[rootQ]) {\\n                array[rootQ] = rootP;\\n            } else {\\n                array[rootP] = rootQ;\\n                size[rootQ]++;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404312,
                "title": "clean-precise-super-easy-to-understand-using-multiset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea behind this solution is to use DFS to identify all the connected components in the graph of indices formed by the pairs given in the input. For each connected component, we add the characters at the corresponding indices to a multiset sorted in decreasing order of characters, and we also add the indices to another multiset sorted in decreasing order of their values. Once we have added all the characters and indices to the multiset, we update the string by assigning the smallest character in the multiset to the index with the smallest value in the other multiset. We repeat this process for all the connected components until all the indices are assigned a character.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create an adjacency list representation of the graph formed by the given pairs.\\n2. Initialize a visited array and two multisets, one for characters and one for indices.\\n3. For each index in the string, if it has not been visited yet, call the DFS function on it.\\n4. Inside the DFS function, add the character at the current index to the characters multiset and add the index to the indices multiset.\\n5. For each neighbor of the current index, call the DFS function recursively.\\n6. After the DFS function has finished processing all the indices in a connected component, update the string by assigning the smallest character in the characters multiset to the index with the smallest value in the indices multiset.\\n7. Repeat steps 4-6 until all the indices have been assigned a character.\\n8. Return the updated string.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the algorithm is O(NlogN) where N is the length of the input string s. This is because for each connected component, we add the characters and indices to two separate multisets, which takes O(NlogN) time. We do this for each connected component, so the total time complexity is O(NlogN).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the algorithm is O(N) where N is the length of the input string s. This is because we use an adjacency list to represent the graph, which takes O(N) space, and we also use two multisets of size N, which takes O(N) space. Additionally, we use a visited array of size N, which also takes O(N) space.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    multiset<int, greater<int>>vk; // for storing index\\n    multiset<char, greater<char>>ms; // for storing their character\\n    void dfs(int idx, vector<vector<int>>&adj, vector<int>&vis, string &s){\\n        if(vis[idx]==1) return;\\n        vis[idx]=1;\\n        ms.insert(s[idx]);\\n        vk.insert(idx);\\n        for(auto it:adj[idx]){\\n            dfs(it,adj,vis,s);\\n        }\\n        \\n    }\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        vector<vector<int>>adj(s.size());\\n        for(int i=0;i<pairs.size();i++){\\n            if(pairs[i][0]!=pairs[i][1]){\\n            adj[pairs[i][0]].push_back(pairs[i][1]);\\n            adj[pairs[i][1]].push_back(pairs[i][0]);\\n            }\\n        }\\n        vector<int>vis(s.size(),0);\\n**Bold**\\n        for(int i=0;i<s.size();i++){\\n            if(vis[i]==0){\\n                dfs(i,adj,vis,s);\\n                while(!ms.empty()){\\n                    s[*vk.begin()]=*ms.begin();\\n                     ms.erase(ms.begin());\\n                     vk.erase(vk.begin());\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    multiset<int, greater<int>>vk; // for storing index\\n    multiset<char, greater<char>>ms; // for storing their character\\n    void dfs(int idx, vector<vector<int>>&adj, vector<int>&vis, string &s){\\n        if(vis[idx]==1) return;\\n        vis[idx]=1;\\n        ms.insert(s[idx]);\\n        vk.insert(idx);\\n        for(auto it:adj[idx]){\\n            dfs(it,adj,vis,s);\\n        }\\n        \\n    }\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        vector<vector<int>>adj(s.size());\\n        for(int i=0;i<pairs.size();i++){\\n            if(pairs[i][0]!=pairs[i][1]){\\n            adj[pairs[i][0]].push_back(pairs[i][1]);\\n            adj[pairs[i][1]].push_back(pairs[i][0]);\\n            }\\n        }\\n        vector<int>vis(s.size(),0);\\n**Bold**\\n        for(int i=0;i<s.size();i++){\\n            if(vis[i]==0){\\n                dfs(i,adj,vis,s);\\n                while(!ms.empty()){\\n                    s[*vk.begin()]=*ms.begin();\\n                     ms.erase(ms.begin());\\n                     vk.erase(vk.begin());\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3378851,
                "title": "dsu-multiset-minheap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhere stepwise approach is as follows\\nwe need to make the lexicographically smallest substring \\n//the indexes which can be swapped directly or indirectly forms a connected component here \\n//we can form smallest string within a connected component only\\nstep1 grp all indexs that can be swapped directly or indirectly using dsu\\nstep2 intialise a map in which key is index of ultimate parent of each connected component and values is a mutlset with all chars at connected indices so it will store it in sorted order\\nhere we are taking multiset cause inside a connected component there can be many same instance of same character at diff indices\\n\\nstep3 iterate over the input string find ultimate parent of each index using findp (dsu) and store that char in multiset of that ultimate par in the map so  declared\\n\\n\\nstep4 iterate over the length of input string this time to make the lexicographically smallest string findp of the current index \\nsee its multiset in the map take the smallest char from there and fit it at the current index of the final answer also after fitting do delete that instance from the multiset of ultimate par of current index\\nfinally return the ans so formed\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<int,multiset<char>>mp;\\n\\n    int findp(int i,vector<int>&par){\\n        if(par[i]==i){\\n            return i;\\n        }\\n        return par[i]=findp(par[i],par);\\n    }\\n    void unionf(int a,int b,vector<int>&rank,vector<int>&par){\\n\\n        a=findp(a,par);\\n        b=findp(b,par);\\n        //dsu union i s of 2 types \\n        //union  by rank \\n        //and union by value\\n        //here we will be using union by rank\\n\\n        if(a!=b){\\n\\n            if(rank[a]<rank[b]){\\n                par[a]=b;\\n\\n\\n            }else if(rank[a]>rank[b]){\\n                par[b]=a;\\n\\n            }else{\\n                par[a]=b;\\n                rank[b]++;\\n            }\\n        }\\n    }\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n\\n\\n\\n        //how the inution will go about\\n\\n        int n=s.size();\\n        vector<int>rank(n,1);\\n        vector<int>par(n,0);\\n        for(int i=0;i<n;i++){\\n            rank[i]=1;\\n            par[i]=i;\\n        }\\n\\n        for(auto e:pairs){\\n            int a=e[0];\\n            int b=e[1];\\n            unionf(a,b,rank,par);\\n        }\\n\\n        //har index ke char ko apne  connected componenet ke ultimate parent ware multiset me daal donga\\n        for(int i=0;i<s.size();i++){\\n            int p=findp(i,par);\\n            mp[p].insert(s[i]);\\n        }\\n        //here we will be applying union find on indexs which are connected ie \\n        //which can be swapped will be part of the same connected component\\n\\n\\n        //now i will try making the lexicographically smallest substring \\n        //from the data struture that i have made\\n        string ans=\"\";\\n        for(int i=0;i<s.size();i++){\\n            int p=findp(i,par);\\n            char c=*mp[p].begin();\\n            mp[p].erase(mp[p].begin());\\n            ans+=c;\\n        }\\n        return ans;\\n\\n\\n\\n\\n\\n        //in this question we will be using the concept of dsu along wiht priority queue \\n\\n\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int,multiset<char>>mp;\\n\\n    int findp(int i,vector<int>&par){\\n        if(par[i]==i){\\n            return i;\\n        }\\n        return par[i]=findp(par[i],par);\\n    }\\n    void unionf(int a,int b,vector<int>&rank,vector<int>&par){\\n\\n        a=findp(a,par);\\n        b=findp(b,par);\\n        //dsu union i s of 2 types \\n        //union  by rank \\n        //and union by value\\n        //here we will be using union by rank\\n\\n        if(a!=b){\\n\\n            if(rank[a]<rank[b]){\\n                par[a]=b;\\n\\n\\n            }else if(rank[a]>rank[b]){\\n                par[b]=a;\\n\\n            }else{\\n                par[a]=b;\\n                rank[b]++;\\n            }\\n        }\\n    }\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n\\n\\n\\n        //how the inution will go about\\n\\n        int n=s.size();\\n        vector<int>rank(n,1);\\n        vector<int>par(n,0);\\n        for(int i=0;i<n;i++){\\n            rank[i]=1;\\n            par[i]=i;\\n        }\\n\\n        for(auto e:pairs){\\n            int a=e[0];\\n            int b=e[1];\\n            unionf(a,b,rank,par);\\n        }\\n\\n        //har index ke char ko apne  connected componenet ke ultimate parent ware multiset me daal donga\\n        for(int i=0;i<s.size();i++){\\n            int p=findp(i,par);\\n            mp[p].insert(s[i]);\\n        }\\n        //here we will be applying union find on indexs which are connected ie \\n        //which can be swapped will be part of the same connected component\\n\\n\\n        //now i will try making the lexicographically smallest substring \\n        //from the data struture that i have made\\n        string ans=\"\";\\n        for(int i=0;i<s.size();i++){\\n            int p=findp(i,par);\\n            char c=*mp[p].begin();\\n            mp[p].erase(mp[p].begin());\\n            ans+=c;\\n        }\\n        return ans;\\n\\n\\n\\n\\n\\n        //in this question we will be using the concept of dsu along wiht priority queue \\n\\n\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3179396,
                "title": "c-union-find-w-path-by-compression-and-union-by-rank-elegant-and-faster-code",
                "content": "This is the find function to find the parent which also update rank of the subtree\\nNote - See the function call for it (initialize each time , deep=0)\\n```\\n  int find(int ind,vector<int>&parent,vector<int>&rank,int &deep){\\n        if(ind==parent[ind]) return ind;\\n        parent[ind]=find(parent[ind],parent,rank,++deep);\\n        rank[ind]+=deep;\\n        return parent[ind];\\n    }\\n```\\nRest of the code\\n```\\n\\tstring smallestStringWithSwaps(string &s, vector<vector<int>>& pairs) {\\n        int n=s.size();\\n        vector<int>parent(n),rank(n,1);\\n        for(int i=0;i<n;i++) parent[i]=i;\\n        map<int,vector<int>>mp;\\n        int temp;\\n        for(auto &vec:pairs){\\n            int i=find(vec[0],parent,rank,temp=0),j=find(vec[1],parent,rank,temp=0);\\n            if(i!=j){\\n                if(rank[i]>rank[j]) parent[j]=i;\\n                else parent[i]=j;\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            mp[find(i,parent,rank,temp=0)].push_back(i);\\n        }\\n        for(auto &p:mp){\\n            vector<int>vec=p.second;\\n            string ss=\"\";\\n            for(auto &i:vec) ss+=s[i];\\n            sort(ss.begin(),ss.end());\\n            for(int i=0;i<vec.size();i++){\\n                s[vec[i]]=ss[i];\\n            }\\n        }\\n        return s;\\n    }\\n\\t",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\n  int find(int ind,vector<int>&parent,vector<int>&rank,int &deep){\\n        if(ind==parent[ind]) return ind;\\n        parent[ind]=find(parent[ind],parent,rank,++deep);\\n        rank[ind]+=deep;\\n        return parent[ind];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3140242,
                "title": "java-union-find-disjoint-set-union-with-explanation-thought-process",
                "content": "# Introduction\\nHi, this is my way of documenting my learning of DSA. Do point out if I made any mistakes and make suggestions to improve my code! Thanks for reading!\\n\\n# Intuition\\nSince we are given an unlimted number of swaps, it means that the swaps are reflexive and transitive. If (0,1) and (1,3) and (3, 2) is in the array, then the nodes [0,1,2,3] are all connected together. \\n\\nWe can think of the possible swaps as a path to other connected indexes of the same path. To keep track of the different unique paths, we can use the Union-Find data structure to quickly pinpoint the path group that each index belongs to. \\n\\nAfter grouping connected indexes in a path together, we can then sort the indexes based on alphabetical order in the group they belong to. \\n\\n# Approach\\n1. Implement the Union-Find data structure. For this question, we don\\'t have to care about the rank of each group. We simply merge connected indexes into one group.\\n\\n2. We iterate through the pairs of possible swap and pass them into the union function. At the end of the loop, each index of the string corresponds to the index of the array parent, and the value represents the group/path index.\\n\\n3. To sort the paths, we need to do a two pass to collect all the letters first before performing swaps. We initialise a hashmap to track the paths. Each path is identified by an index and consist of a PriorityQueue to sort out the added letters. We traverse through the string, for each letter, we find its path index, and add the current letter to the existing PriorityQueue. This ensures that we are able to smoothly allocate letters in the second pass. \\n\\n4. Once we collected all letters, sorted and placed them into their allocated paths, we proceed to swap them. We traverse the string again, and again, for each index, we find the path it belongs to. We go to the PriorityQueue that the path is responsible for, and grab the first and smallest letter in the queue. We then append it to the new resultant string. \\n\\n\\n# Complexity\\n- Time complexity: ***O((E+V)\\u22C5\\u03B1(V)+VlogV)***\\n\\n- Space complexity: ***O(V)***\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code \\n```\\nclass Solution {\\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        int n = s.length();\\n\\n        // 1. Initialise a union find object.\\n        UnionFind groups = new UnionFind(n);\\n\\n        // 2. Iterate swaps to find connected paths.\\n        for (List<Integer> pair: pairs) {\\n            int node1 = pair.get(0);\\n            int node2 = pair.get(1);\\n            groups.union(node1, node2);\\n        }\\n\\n        // 3. Collect sorted letters in each path \\n        Map<Integer, PriorityQueue<Character>> map = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            int parent = groups.find(i);\\n            map.putIfAbsent(parent, new PriorityQueue<>());\\n            map.get(parent).add(s.charAt(i));\\n        }\\n\\n        // 4. Get path and append smallest letter\\n        StringBuilder res = new StringBuilder();\\n        for (int i = 0; i < n; i++) {\\n            int parent = groups.find(i);\\n            Character a = map.get(parent).poll();\\n            res.append(a);\\n        }\\n        return res.toString();\\n    }\\n}\\n\\nclass UnionFind {\\n    int[] parent;\\n    public UnionFind(int n) {\\n        parent = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }\\n    }\\n    public int find(int x) {\\n        if (parent[x] != x) parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n\\n    public void union(int x, int y) {\\n        int rootX = find(x);\\n        int rootY = find(y);\\n        if (rootX != rootY) {\\n            if (rootX < rootY) {\\n                parent[rootY] = rootX;\\n            } else {\\n                parent[rootX] = rootY;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        int n = s.length();\\n\\n        // 1. Initialise a union find object.\\n        UnionFind groups = new UnionFind(n);\\n\\n        // 2. Iterate swaps to find connected paths.\\n        for (List<Integer> pair: pairs) {\\n            int node1 = pair.get(0);\\n            int node2 = pair.get(1);\\n            groups.union(node1, node2);\\n        }\\n\\n        // 3. Collect sorted letters in each path \\n        Map<Integer, PriorityQueue<Character>> map = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            int parent = groups.find(i);\\n            map.putIfAbsent(parent, new PriorityQueue<>());\\n            map.get(parent).add(s.charAt(i));\\n        }\\n\\n        // 4. Get path and append smallest letter\\n        StringBuilder res = new StringBuilder();\\n        for (int i = 0; i < n; i++) {\\n            int parent = groups.find(i);\\n            Character a = map.get(parent).poll();\\n            res.append(a);\\n        }\\n        return res.toString();\\n    }\\n}\\n\\nclass UnionFind {\\n    int[] parent;\\n    public UnionFind(int n) {\\n        parent = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            parent[i] = i;\\n        }\\n    }\\n    public int find(int x) {\\n        if (parent[x] != x) parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n\\n    public void union(int x, int y) {\\n        int rootX = find(x);\\n        int rootY = find(y);\\n        if (rootX != rootY) {\\n            if (rootX < rootY) {\\n                parent[rootY] = rootX;\\n            } else {\\n                parent[rootX] = rootY;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962982,
                "title": "c-dsu-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:O(N)\\n\\n- Space complexity:O(N)\\n\\n# Code\\n```\\nclass disjointset{\\n    public:\\n    vector<int>par;\\n    disjointset(int n){\\n        par.resize(n+1);\\n        for(int i=0; i<n; i++){\\n            par[i]=i;\\n        }\\n    }\\n    int findp(int u){\\n        if(u==par[u]){\\n            return u;\\n        }\\n        return par[u]=findp(par[u]);\\n    }\\n    void un(int u, int v){\\n        if(findp(u)==findp(v)){return;}\\n        par[findp(u)]=par[findp(v)];\\n    }\\n};\\nclass Solution {\\npublic:\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        map<int, vector<int>>m;\\n        disjointset d(s.size());\\n        for(auto it: pairs){\\n            d.un(it[0], it[1]);\\n        }\\n        for(int i=0; i<s.size(); i++){\\n            m[d.findp(i)].push_back(i);\\n        }\\n        for(auto it: m){\\n            vector<int>v=it.second;\\n            string ans=\"\";\\n            for(auto it1: v){\\n                ans+=s[it1];\\n            }\\n            sort(ans.begin(), ans.end());\\n            for(int i=0; i<ans.size(); i++){\\n                s[v[i]]=ans[i];\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Union Find"
                ],
                "code": "```\\nclass disjointset{\\n    public:\\n    vector<int>par;\\n    disjointset(int n){\\n        par.resize(n+1);\\n        for(int i=0; i<n; i++){\\n            par[i]=i;\\n        }\\n    }\\n    int findp(int u){\\n        if(u==par[u]){\\n            return u;\\n        }\\n        return par[u]=findp(par[u]);\\n    }\\n    void un(int u, int v){\\n        if(findp(u)==findp(v)){return;}\\n        par[findp(u)]=par[findp(v)];\\n    }\\n};\\nclass Solution {\\npublic:\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        map<int, vector<int>>m;\\n        disjointset d(s.size());\\n        for(auto it: pairs){\\n            d.un(it[0], it[1]);\\n        }\\n        for(int i=0; i<s.size(); i++){\\n            m[d.findp(i)].push_back(i);\\n        }\\n        for(auto it: m){\\n            vector<int>v=it.second;\\n            string ans=\"\";\\n            for(auto it1: v){\\n                ans+=s[it1];\\n            }\\n            sort(ans.begin(), ans.end());\\n            for(int i=0; i<ans.size(); i++){\\n                s[v[i]]=ans[i];\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779887,
                "title": "simple-dfs-c",
                "content": "```\\nclass Solution {\\n    void dfs(int node, vector<int> adj[], vector<int> &vis, string &s, vector<int> &idx, string &str) {\\n        vis[node] = 1;\\n        idx.push_back(node);\\n        str.push_back(s[node]);\\n        for(int ad : adj[node]) {\\n            if(!vis[ad]) dfs(ad, adj, vis, s, idx, str);\\n        }\\n    }\\npublic:\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        vector<int> adj[s.size()];\\n        for(auto e : pairs) adj[e[0]].push_back(e[1]), adj[e[1]].push_back(e[0]);\\n\\n        vector<int> vis(s.size(), 0);\\n        string ans = s;\\n        for(int i=0; i<s.size(); i++) {\\n            if(!vis[i]) {\\n                vector<int> idx;\\n                string str;\\n                dfs(i, adj, vis, s, idx, str);\\n                int p = 0;\\n                sort(idx.begin(), idx.end());\\n                sort(str.begin(), str.end());\\n                for(int j : idx) ans[j] = str[p++];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(int node, vector<int> adj[], vector<int> &vis, string &s, vector<int> &idx, string &str) {\\n        vis[node] = 1;\\n        idx.push_back(node);\\n        str.push_back(s[node]);\\n        for(int ad : adj[node]) {\\n            if(!vis[ad]) dfs(ad, adj, vis, s, idx, str);\\n        }\\n    }\\npublic:\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        vector<int> adj[s.size()];\\n        for(auto e : pairs) adj[e[0]].push_back(e[1]), adj[e[1]].push_back(e[0]);\\n\\n        vector<int> vis(s.size(), 0);\\n        string ans = s;\\n        for(int i=0; i<s.size(); i++) {\\n            if(!vis[i]) {\\n                vector<int> idx;\\n                string str;\\n                dfs(i, adj, vis, s, idx, str);\\n                int p = 0;\\n                sort(idx.begin(), idx.end());\\n                sort(str.begin(), str.end());\\n                for(int j : idx) ans[j] = str[p++];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2536514,
                "title": "c-union-find-map-with-multiset-easy-to-understand",
                "content": "Please do **Upvote** if you find this helpful !!\\n```\\nclass UnionFind{\\n    public : \\n    vector<int> par, sz;\\n    UnionFind(int n): par(n) , sz(n,1) {\\n        iota(par.begin(),par.end(),0);\\n    }\\n    int find(int x){\\n        if(par[x]==x) return x;\\n        return par[x] = find(par[x]);\\n    }\\n    \\n    bool Union(int x,int y){\\n        int xp = find(x);\\n        int yp = find(y);\\n        \\n        if(xp==yp) return false;\\n        \\n        if(sz[xp]>sz[yp]) {par[yp] = xp; sz[xp]+=sz[yp];}\\n        else {par[xp]=yp; sz[yp]+=sz[xp];}\\n        return true;\\n    }\\n};\\nclass Solution {\\npublic:\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n       string ans(s.size(),\\' \\'); \\n       UnionFind uf(s.size()+1);\\n       for(auto x:pairs)\\n           uf.Union(x[0],x[1]);\\n       unordered_map<int,multiset<char>> m;\\n       for(int i=0;i<s.size();i++){\\n           m[uf.find(i)].insert(s[i]);\\n       } \\n       for(int i=0;i<s.size();i++){\\n           auto it = m[uf.find(i)].begin();\\n           ans[i]=*it;\\n           m[uf.find(i)].erase(it);\\n       } \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass UnionFind{\\n    public : \\n    vector<int> par, sz;\\n    UnionFind(int n): par(n) , sz(n,1) {\\n        iota(par.begin(),par.end(),0);\\n    }\\n    int find(int x){\\n        if(par[x]==x) return x;\\n        return par[x] = find(par[x]);\\n    }\\n    \\n    bool Union(int x,int y){\\n        int xp = find(x);\\n        int yp = find(y);\\n        \\n        if(xp==yp) return false;\\n        \\n        if(sz[xp]>sz[yp]) {par[yp] = xp; sz[xp]+=sz[yp];}\\n        else {par[xp]=yp; sz[yp]+=sz[xp];}\\n        return true;\\n    }\\n};\\nclass Solution {\\npublic:\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n       string ans(s.size(),\\' \\'); \\n       UnionFind uf(s.size()+1);\\n       for(auto x:pairs)\\n           uf.Union(x[0],x[1]);\\n       unordered_map<int,multiset<char>> m;\\n       for(int i=0;i<s.size();i++){\\n           m[uf.find(i)].insert(s[i]);\\n       } \\n       for(int i=0;i<s.size();i++){\\n           auto it = m[uf.find(i)].begin();\\n           ans[i]=*it;\\n           m[uf.find(i)].erase(it);\\n       } \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2213365,
                "title": "python-union-find-solution",
                "content": "```\\nclass UnionFind():\\n    \"\"\"Union-Find\"\"\"\\n\\n    def __init__(self, size):\\n        self.root = [i for i in range(size)]\\n        self.rank = [1]*size\\n        \\n    def find(self, x):\\n        if x == self.root[x]:\\n            return x\\n        self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n\\n    def union(self, x, y):\\n        rootX = self.find(x)\\n        rootY = self.find(y)\\n        if rootX != rootY:\\n            if self.rank[rootX] >= self.rank[rootY]:\\n                self.root[rootY] = rootX\\n                self.rank[rootX] += self.rank[rootY]\\n            else:\\n                self.root[rootX] = rootY\\n                self.rank[rootY] += self.rank[rootX]\\n                \\n\\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        \"\"\"Union-Find\"\"\"\\n        \\n        N = len(s)\\n        \\n        uf = UnionFind(N)\\n        for edge in pairs:\\n            uf.union(*edge)\\n            \\n        connected_stacks = collections.defaultdict(list)  # hashmap\\n        for i in range(N):\\n            connected_stacks[uf.find(i)].append(s[i])\\n        \\n        for stack in connected_stacks.values():\\n            stack.sort(reverse=True)   # sort in reverse order to be able pop smallest from stack in O(1)\\n            \\n        new = \"\".join([connected_stacks[uf.find(i)].pop() for i in range(N)])\\n        \\n        return new\\n```",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nclass UnionFind():\\n    \"\"\"Union-Find\"\"\"\\n\\n    def __init__(self, size):\\n        self.root = [i for i in range(size)]\\n        self.rank = [1]*size\\n        \\n    def find(self, x):\\n        if x == self.root[x]:\\n            return x\\n        self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n\\n    def union(self, x, y):\\n        rootX = self.find(x)\\n        rootY = self.find(y)\\n        if rootX != rootY:\\n            if self.rank[rootX] >= self.rank[rootY]:\\n                self.root[rootY] = rootX\\n                self.rank[rootX] += self.rank[rootY]\\n            else:\\n                self.root[rootX] = rootY\\n                self.rank[rootY] += self.rank[rootX]\\n                \\n\\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        \"\"\"Union-Find\"\"\"\\n        \\n        N = len(s)\\n        \\n        uf = UnionFind(N)\\n        for edge in pairs:\\n            uf.union(*edge)\\n            \\n        connected_stacks = collections.defaultdict(list)  # hashmap\\n        for i in range(N):\\n            connected_stacks[uf.find(i)].append(s[i])\\n        \\n        for stack in connected_stacks.values():\\n            stack.sort(reverse=True)   # sort in reverse order to be able pop smallest from stack in O(1)\\n            \\n        new = \"\".join([connected_stacks[uf.find(i)].pop() for i in range(N)])\\n        \\n        return new\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1987549,
                "title": "python-dfs-simple-and-clean-solution",
                "content": "```\\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        def dfs(i):\\n            visited[i] = True\\n            component.append(i)\\n            for j in adj_list[i]:\\n                if not visited[j]:\\n                    dfs(j)\\n        n = len(s)\\n        adj_list = [[] for _ in range(n)]\\n        for i, j in pairs:\\n            adj_list[i].append(j)\\n            adj_list[j].append(i)\\n        \\n        visited = [False for _ in range(n)]\\n        lst = list(s)\\n        for i in range(n):\\n            if not visited[i]:\\n                component = []\\n                dfs(i)\\n                component.sort()\\n                chars = [lst[j] for j in component]\\n                chars.sort()\\n                for k in range(len(component)):\\n                    lst[component[k]] = chars[k]\\n        return \\'\\'.join(lst)\\n```\\n**I hope that you\\'ve found this useful.**\\n**In that case, please upvote. It motivates me to write more such posts\\uD83D\\uDE03**\\nComment below if you have any queries.",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        def dfs(i):\\n            visited[i] = True\\n            component.append(i)\\n            for j in adj_list[i]:\\n                if not visited[j]:\\n                    dfs(j)\\n        n = len(s)\\n        adj_list = [[] for _ in range(n)]\\n        for i, j in pairs:\\n            adj_list[i].append(j)\\n            adj_list[j].append(i)\\n        \\n        visited = [False for _ in range(n)]\\n        lst = list(s)\\n        for i in range(n):\\n            if not visited[i]:\\n                component = []\\n                dfs(i)\\n                component.sort()\\n                chars = [lst[j] for j in component]\\n                chars.sort()\\n                for k in range(len(component)):\\n                    lst[component[k]] = chars[k]\\n        return \\'\\'.join(lst)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1986854,
                "title": "java-union-find-code",
                "content": "```\\nclass Solution {\\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        \\n        int[] rel = new int[s.length()];\\n        char[] res= s.toCharArray();\\n        \\n        for(int i=0;i<rel.length;i++){\\n            rel[i]=i;\\n        }\\n        Union union = new Union();\\n        for(List<Integer> pair:pairs){\\n            union.union(rel,pair.get(0),pair.get(1));\\n        }\\n        \\n        Map<Integer,List<Integer>> map = new HashMap<>();\\n        for(int i=0;i<rel.length;i++){\\n            int parent = union.find(rel,i);\\n            List<Integer> l = map.getOrDefault(parent,new ArrayList<>());\\n            l.add(i);\\n            map.put(parent,l);\\n        }\\n        for(int key:map.keySet()){\\n            if(key>-1){\\n            List<Integer> index = map.get(key);\\n            List<Character> characters = new ArrayList<>();\\n            \\n            for(int k:index){\\n                characters.add(res[k]);\\n            }\\n            Collections.sort(characters);\\n            \\n            for(int i=0;i<index.size();i++){\\n                res[index.get(i)] = characters.get(i);\\n            }\\n                      }\\n        }\\n        return new String(res);\\n    }\\n    \\n    \\n    class Union{\\n        \\n        public void union(int[] rel,int a,int b){\\n            int roota = find(rel,a);\\n            int rootb = find(rel,b);\\n            if(roota!=rootb){\\n                rel[rootb] = roota;\\n            }\\n        }\\n        \\n        public int find(int[] rel,int a){\\n            while(rel[a]!=a){\\n                rel[a] = rel[rel[a]];\\n                a = rel[a];\\n            }\\n            return a;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        \\n        int[] rel = new int[s.length()];\\n        char[] res= s.toCharArray();\\n        \\n        for(int i=0;i<rel.length;i++){\\n            rel[i]=i;\\n        }\\n        Union union = new Union();\\n        for(List<Integer> pair:pairs){\\n            union.union(rel,pair.get(0),pair.get(1));\\n        }\\n        \\n        Map<Integer,List<Integer>> map = new HashMap<>();\\n        for(int i=0;i<rel.length;i++){\\n            int parent = union.find(rel,i);\\n            List<Integer> l = map.getOrDefault(parent,new ArrayList<>());\\n            l.add(i);\\n            map.put(parent,l);\\n        }\\n        for(int key:map.keySet()){\\n            if(key>-1){\\n            List<Integer> index = map.get(key);\\n            List<Character> characters = new ArrayList<>();\\n            \\n            for(int k:index){\\n                characters.add(res[k]);\\n            }\\n            Collections.sort(characters);\\n            \\n            for(int i=0;i<index.size();i++){\\n                res[index.get(i)] = characters.get(i);\\n            }\\n                      }\\n        }\\n        return new String(res);\\n    }\\n    \\n    \\n    class Union{\\n        \\n        public void union(int[] rel,int a,int b){\\n            int roota = find(rel,a);\\n            int rootb = find(rel,b);\\n            if(roota!=rootb){\\n                rel[rootb] = roota;\\n            }\\n        }\\n        \\n        public int find(int[] rel,int a){\\n            while(rel[a]!=a){\\n                rel[a] = rel[rel[a]];\\n                a = rel[a];\\n            }\\n            return a;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1986583,
                "title": "intuition-is-harder-solution-is-easy-c-connected-component-dfs",
                "content": "## Try using Graph in this question and then see this solution.\\n\\nPersonally this question was hard to get intuition, I tried different approaches but was not able to do it, then finnaly saw the hint given with the question and Then It was clear that what has to be done.\\n\\nThe main idea is that we are creating a **graph** with the given pairs and then finding the **components** out of it using dfs, now In any component the letters can be swaped[Try on Paper] with any other letter in that component. \\n\\nSo find each component and keep track of the indices and the string formed by the component and sort both of them, after that replace the string s with the sorted string at the indices from the components we got from dfs.\\n\\n\\n\\n**Learning:** Sometimes graph questions are trick to identify and we require practise to be good at it!\\n\\n**Learning:** Sometimes graph questions are trick to identify and we require practise to be good at it!\\n\\n**<u>Handsoff to the person who created this Question!!</u>**\\n\\n```cpp\\n// Simple DFS for the graph\\nvoid dfs(int i, vector<int>& visited, vector<int>& nodes, string& componentString, string& s, vector<vector<int>>& graph)\\n{\\n    // Storing the nodes and also the string of this component\\n\\tnodes.push_back(i);\\n\\tcomponentString += s[i];\\n\\tvisited[i] = 1;\\n\\n\\tfor (auto node : graph[i])\\n\\t{\\n\\t\\tif (!visited[node])\\n\\t\\t{\\n\\t\\t\\tdfs(node, visited, nodes, componentString, s, graph);\\n\\t\\t}\\n\\t}\\n}\\n\\nstring smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n\\t// Creating a Graph with the given pairs \\n\\tint n = s.size();\\n\\tvector<vector<int>> graph(n);\\n\\tfor (auto p : pairs)\\n\\t{\\n\\t\\tint u = p[0], v = p[1];\\n\\t\\tgraph[u].push_back(v);\\n\\t\\tgraph[v].push_back(u);\\n\\t}\\n\\n\\t// Finding the components for the given graph\\n\\tvector<int> visited(n, 0);\\n\\tfor (int i = 0; i < n; ++i)\\n\\t{\\n\\t\\tif (!visited[i])\\n\\t\\t{\\n\\t\\t\\tvector<int> nodes;\\n\\t\\t\\tstring componentString;\\n\\t\\t\\tdfs(i, visited, nodes, componentString, s, graph);\\n            \\n            // Sorting the nodes nad componentString to make the nodes accending and component string in lexicographically order\\n\\t\\t\\tsort(nodes.begin(), nodes.end());\\n\\t\\t\\tsort(componentString.begin(), componentString.end());\\n            \\n            // Replace the new lexicographically string of the component with the old string at the indices of the components\\n\\t\\t\\tfor (int k = 0; k < nodes.size(); ++k)\\n\\t\\t\\t{\\n\\t\\t\\t\\ts[nodes[k]] = componentString[k];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n    \\n    // Finally Return the answer\\n\\treturn s;\\n}\\n```\\n\\n### **If any doubt, feel free to comment!!**\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```cpp\\n// Simple DFS for the graph\\nvoid dfs(int i, vector<int>& visited, vector<int>& nodes, string& componentString, string& s, vector<vector<int>>& graph)\\n{\\n    // Storing the nodes and also the string of this component\\n\\tnodes.push_back(i);\\n\\tcomponentString += s[i];\\n\\tvisited[i] = 1;\\n\\n\\tfor (auto node : graph[i])\\n\\t{\\n\\t\\tif (!visited[node])\\n\\t\\t{\\n\\t\\t\\tdfs(node, visited, nodes, componentString, s, graph);\\n\\t\\t}\\n\\t}\\n}\\n\\nstring smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n\\t// Creating a Graph with the given pairs \\n\\tint n = s.size();\\n\\tvector<vector<int>> graph(n);\\n\\tfor (auto p : pairs)\\n\\t{\\n\\t\\tint u = p[0], v = p[1];\\n\\t\\tgraph[u].push_back(v);\\n\\t\\tgraph[v].push_back(u);\\n\\t}\\n\\n\\t// Finding the components for the given graph\\n\\tvector<int> visited(n, 0);\\n\\tfor (int i = 0; i < n; ++i)\\n\\t{\\n\\t\\tif (!visited[i])\\n\\t\\t{\\n\\t\\t\\tvector<int> nodes;\\n\\t\\t\\tstring componentString;\\n\\t\\t\\tdfs(i, visited, nodes, componentString, s, graph);\\n            \\n            // Sorting the nodes nad componentString to make the nodes accending and component string in lexicographically order\\n\\t\\t\\tsort(nodes.begin(), nodes.end());\\n\\t\\t\\tsort(componentString.begin(), componentString.end());\\n            \\n            // Replace the new lexicographically string of the component with the old string at the indices of the components\\n\\t\\t\\tfor (int k = 0; k < nodes.size(); ++k)\\n\\t\\t\\t{\\n\\t\\t\\t\\ts[nodes[k]] = componentString[k];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n    \\n    // Finally Return the answer\\n\\treturn s;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1986177,
                "title": "cpp-union-find-solution",
                "content": "```\\nstring S;\\n\\nbool cmp(int a, int b){\\n    return S[a] < S[b];\\n}\\nclass Solution {\\npublic:\\n    int dsu[100001];\\n    void change(int a, int b){\\n        if(dsu[a] == a){\\n            dsu[a] = b;\\n            return;\\n        }\\n        change(dsu[a], b);\\n    }\\n    \\n    int find(int a){\\n        if(dsu[a] == a) return a;\\n        return dsu[a] = find(dsu[a]);\\n    }\\n    \\n    int parent(int a){\\n        if(dsu[a] == a) return a;\\n        return parent(dsu[a]);\\n    }\\n    \\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        int n = s.size();\\n        for(int i=0;i<n;i++) dsu[i] = i;\\n        string ans = s;\\n        S = s;\\n        \\n        for(auto&it: pairs){\\n            int a = parent(it[0]);\\n            int b = parent(it[1]);\\n            if(a != b){\\n                change(it[0], min(a, b));\\n                change(it[1], min(a, b));\\n            }\\n        }\\n        \\n        for(int i=1;i<n;i++){\\n            dsu[i] = find(i);\\n        }\\n        \\n        vector<vector<int>> ch(n);\\n        \\n        for(int i=0;i<n;i++){\\n            ch[dsu[i]].push_back(i);\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(ch[i].size() != 0){\\n                vector<int> temp = ch[i];\\n                sort(ch[i].begin(), ch[i].end(), cmp);\\n                for(int j=0;j<temp.size();j++){\\n                    ans[temp[j]] = s[ch[i][j]];\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find"
                ],
                "code": "```\\nstring S;\\n\\nbool cmp(int a, int b){\\n    return S[a] < S[b];\\n}\\nclass Solution {\\npublic:\\n    int dsu[100001];\\n    void change(int a, int b){\\n        if(dsu[a] == a){\\n            dsu[a] = b;\\n            return;\\n        }\\n        change(dsu[a], b);\\n    }\\n    \\n    int find(int a){\\n        if(dsu[a] == a) return a;\\n        return dsu[a] = find(dsu[a]);\\n    }\\n    \\n    int parent(int a){\\n        if(dsu[a] == a) return a;\\n        return parent(dsu[a]);\\n    }\\n    \\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        int n = s.size();\\n        for(int i=0;i<n;i++) dsu[i] = i;\\n        string ans = s;\\n        S = s;\\n        \\n        for(auto&it: pairs){\\n            int a = parent(it[0]);\\n            int b = parent(it[1]);\\n            if(a != b){\\n                change(it[0], min(a, b));\\n                change(it[1], min(a, b));\\n            }\\n        }\\n        \\n        for(int i=1;i<n;i++){\\n            dsu[i] = find(i);\\n        }\\n        \\n        vector<vector<int>> ch(n);\\n        \\n        for(int i=0;i<n;i++){\\n            ch[dsu[i]].push_back(i);\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(ch[i].size() != 0){\\n                vector<int> temp = ch[i];\\n                sort(ch[i].begin(), ch[i].end(), cmp);\\n                for(int j=0;j<temp.size();j++){\\n                    ans[temp[j]] = s[ch[i][j]];\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1985905,
                "title": "2-approaches-must-learn-union-find-dfs-c",
                "content": "***Approach 1*** (DFS) \\n\\n**Idea**-Do dfs on the pairs (taking them as edges of a graph), sort all the characters seen in the dfs, and keep doing this untill you build the complelte string.\\n\\n**C++**\\n```\\nclass Solution {\\n    bool visited[100010] = {0};\\n    vector<int>adj[100010];\\n    void DFS(int v, string&s, vector<char> &ch, vector<int> &ind) {\\n        visited[v] = true;\\n        ind.push_back(v);\\n        ch.push_back(s[v]);\\n        \\n        for(int &neigh: adj[v]) {\\n            if(!visited[neigh]) \\n                DFS(neigh, s, ch, ind);\\n        }\\n    }\\npublic:\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        \\n        // Build adjacency list/Graph\\n        for(vector<int>&edge: pairs) {\\n            int source = edge[0], destination = edge[1];\\n            //Undirected edge\\n            adj[source].push_back(destination);\\n            adj[destination].push_back(source);\\n        }\\n        \\n        for(int vertex = 0; vertex<s.size(); vertex++) {\\n            if(!visited[vertex]) {\\n                vector<char> characters;\\n                vector<int> indices;\\n                \\n                DFS(vertex, s, characters, indices);\\n                \\n                // Sort both the vectors and build the part string\\n                sort(characters.begin(), characters.end());\\n                sort(indices.begin(), indices.end());\\n                \\n                for(int index = 0; index < indices.size(); index++) {\\n                    s[indices[index]] = characters[index];\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```\\n**Approach 2** ( Union find)\\n**Idea** - Since the characters with edges that can be swapped with each other can be seen as components of a graph, we can use union find to get the components, sort the characters and proceed as in the approach 1 and build the string for each component to get the complete string.\\n\\n**C++**\\n```\\nclass UnionFind {\\n    vector<int> parent;\\n    vector<int> rank;\\npublic:\\n    UnionFind(int size) {\\n        parent = vector<int>(size);\\n        rank = vector<int>(size);\\n        for(int i = 0; i<size; ++i)\\n            parent[i] = i;\\n    }\\n    \\n    int findParent(int node) {\\n        if(parent[node] == node) return node;\\n        return parent[node] = findParent(parent[node]);\\n    }\\n    \\n    void join(int u, int v) {\\n        int x = findParent(u), y = findParent(v);\\n        if(x == y) return;\\n        if(rank[x] < rank[y]) {\\n            parent[x] = y;\\n        }\\n        else if(rank[y] < rank[x]) {\\n            parent[y] = x;\\n        }\\n        else {\\n            parent[x] = y;\\n            rank[y]++;\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        UnionFind uf(s.size());\\n        \\n        for(vector<int>&edge: pairs) {\\n            int source = edge[0], destination = edge[1];\\n            // join the characters into a component\\n            uf.join(source, destination);\\n        }\\n        \\n        unordered_map<int, vector<int>> parentTocomponent;\\n        // Get the indexes of the characters of the same component\\n        for(int vertex = 0; vertex < s.size(); vertex++) {\\n            int par = uf.findParent(vertex);\\n            parentTocomponent[par].push_back(vertex);\\n        }\\n        \\n        string ans(s.size(), \\' \\');\\n        for(auto component: parentTocomponent) {\\n            vector<char> characters;\\n            for(int index: component.second) {\\n                characters.push_back(s[index]);\\n            }\\n            \\n            //Sort the characters\\n            sort(characters.begin(), characters.end());\\n            for(int i = 0; i<characters.size(); i++) {\\n                ans[component.second[i]] = characters[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    bool visited[100010] = {0};\\n    vector<int>adj[100010];\\n    void DFS(int v, string&s, vector<char> &ch, vector<int> &ind) {\\n        visited[v] = true;\\n        ind.push_back(v);\\n        ch.push_back(s[v]);\\n        \\n        for(int &neigh: adj[v]) {\\n            if(!visited[neigh]) \\n                DFS(neigh, s, ch, ind);\\n        }\\n    }\\npublic:\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        \\n        // Build adjacency list/Graph\\n        for(vector<int>&edge: pairs) {\\n            int source = edge[0], destination = edge[1];\\n            //Undirected edge\\n            adj[source].push_back(destination);\\n            adj[destination].push_back(source);\\n        }\\n        \\n        for(int vertex = 0; vertex<s.size(); vertex++) {\\n            if(!visited[vertex]) {\\n                vector<char> characters;\\n                vector<int> indices;\\n                \\n                DFS(vertex, s, characters, indices);\\n                \\n                // Sort both the vectors and build the part string\\n                sort(characters.begin(), characters.end());\\n                sort(indices.begin(), indices.end());\\n                \\n                for(int index = 0; index < indices.size(); index++) {\\n                    s[indices[index]] = characters[index];\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```\n```\\nclass UnionFind {\\n    vector<int> parent;\\n    vector<int> rank;\\npublic:\\n    UnionFind(int size) {\\n        parent = vector<int>(size);\\n        rank = vector<int>(size);\\n        for(int i = 0; i<size; ++i)\\n            parent[i] = i;\\n    }\\n    \\n    int findParent(int node) {\\n        if(parent[node] == node) return node;\\n        return parent[node] = findParent(parent[node]);\\n    }\\n    \\n    void join(int u, int v) {\\n        int x = findParent(u), y = findParent(v);\\n        if(x == y) return;\\n        if(rank[x] < rank[y]) {\\n            parent[x] = y;\\n        }\\n        else if(rank[y] < rank[x]) {\\n            parent[y] = x;\\n        }\\n        else {\\n            parent[x] = y;\\n            rank[y]++;\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        UnionFind uf(s.size());\\n        \\n        for(vector<int>&edge: pairs) {\\n            int source = edge[0], destination = edge[1];\\n            // join the characters into a component\\n            uf.join(source, destination);\\n        }\\n        \\n        unordered_map<int, vector<int>> parentTocomponent;\\n        // Get the indexes of the characters of the same component\\n        for(int vertex = 0; vertex < s.size(); vertex++) {\\n            int par = uf.findParent(vertex);\\n            parentTocomponent[par].push_back(vertex);\\n        }\\n        \\n        string ans(s.size(), \\' \\');\\n        for(auto component: parentTocomponent) {\\n            vector<char> characters;\\n            for(int index: component.second) {\\n                characters.push_back(s[index]);\\n            }\\n            \\n            //Sort the characters\\n            sort(characters.begin(), characters.end());\\n            for(int i = 0; i<characters.size(); i++) {\\n                ans[component.second[i]] = characters[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1985878,
                "title": "easy-dfs-fast-c",
                "content": "class Solution {\\npublic:\\n\\n    string ans;\\n    void dfs(int i, vector<int> &pos, vector<int> &vis, vector<vector<int>> &g) {   \\n        vis[i]++;\\n        pos.push_back(i);\\n        for(auto child: g[i]){\\n            if (!vis[child]) dfs(child, pos, vis, g);\\n        }\\n    }\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        int n = s.size();\\n        ans = s;\\n        vector<vector<int>> g(n);\\n        for(auto i: pairs) {\\n            g[i[0]].push_back(i[1]);\\n            g[i[1]].push_back(i[0]);\\n        }\\n        vector<int> vis(n, 0);\\n        for(int i=0; i<n; i++) {\\n            if (!vis[i]) {\\n                vector<int> pos;\\n                dfs(i, pos, vis, g);\\n                string tmp = \"\";\\n                for(auto c: pos) {\\n                    tmp += s[c];\\n                }\\n                sort(pos.begin(), pos.end());\\n                sort(tmp.begin(), tmp.end());\\n                for(int z = 0; z<pos.size(); z++) {\\n                    ans[pos[z]] = tmp[z];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n\\n    string ans;\\n    void dfs(int i, vector<int> &pos, vector<int> &vis, vector<vector<int>> &g) {   \\n        vis[i]++;\\n        pos.push_back(i);\\n        for(auto child: g[i]){\\n            if (!vis[child]) dfs(child, pos, vis, g);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1985848,
                "title": "scala-concise-solution-based-on-reusable-union-find-implementation",
                "content": "```\\n  def smallestStringWithSwaps(s: String, pairs: List[List[Int]]): String = {\\n    val uf = new UnionFind[Int]\\n    pairs.foreach(p => uf.union(p.head, p.last))\\n    \\n    val positionRelocations = s\\n      .indices\\n      .groupBy(uf.find)\\n      .values\\n      .flatMap(indexGroup => indexGroup.zip(indexGroup.sortBy(s)))\\n      .toMap\\n    \\n    s.indices.map(i => s(positionRelocations(i))).mkString\\n  }\\n```\\n\\nReusable UF w/ path compression & ranking:\\n```\\nimport scala.collection.mutable\\n\\nclass UnionFind[T] {\\n  private val ranks: mutable.Map[T, Int] = mutable.Map.empty.withDefaultValue(1)\\n  private val parents: mutable.Map[T, T] = mutable.Map.empty.withDefault(n => n)\\n\\n  def union(n1: T, n2: T): T = {\\n    val (p1, p2) = (find(n1), find(n2))\\n    if (p1 != p2) {\\n      val (lo, hi) = Option.when(ranks(p1) >= ranks(p2))((p2, p1)).getOrElse((p1, p2))\\n      ranks.update(hi, ranks(lo) + ranks(hi))\\n      parents.update(lo, hi)\\n    }\\n    parents(p1)\\n  }\\n\\n  def find(n: T): T = {\\n    if (parents(n) != n) parents.update(n, find(parents(n)))\\n    parents(n)\\n  }\\n\\n  def nodes(): Set[T] = parents.keySet.toSet\\n  def rank(n: T): Int = ranks(n)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n  def smallestStringWithSwaps(s: String, pairs: List[List[Int]]): String = {\\n    val uf = new UnionFind[Int]\\n    pairs.foreach(p => uf.union(p.head, p.last))\\n    \\n    val positionRelocations = s\\n      .indices\\n      .groupBy(uf.find)\\n      .values\\n      .flatMap(indexGroup => indexGroup.zip(indexGroup.sortBy(s)))\\n      .toMap\\n    \\n    s.indices.map(i => s(positionRelocations(i))).mkString\\n  }\\n```\n```\\nimport scala.collection.mutable\\n\\nclass UnionFind[T] {\\n  private val ranks: mutable.Map[T, Int] = mutable.Map.empty.withDefaultValue(1)\\n  private val parents: mutable.Map[T, T] = mutable.Map.empty.withDefault(n => n)\\n\\n  def union(n1: T, n2: T): T = {\\n    val (p1, p2) = (find(n1), find(n2))\\n    if (p1 != p2) {\\n      val (lo, hi) = Option.when(ranks(p1) >= ranks(p2))((p2, p1)).getOrElse((p1, p2))\\n      ranks.update(hi, ranks(lo) + ranks(hi))\\n      parents.update(lo, hi)\\n    }\\n    parents(p1)\\n  }\\n\\n  def find(n: T): T = {\\n    if (parents(n) != n) parents.update(n, find(parents(n)))\\n    parents(n)\\n  }\\n\\n  def nodes(): Set[T] = parents.keySet.toSet\\n  def rank(n: T): Int = ranks(n)\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1985703,
                "title": "c-with-explanation-on-sorting-can-solve-the-issue",
                "content": "Before going to Union find, first part is how I tackled this.\\n\\nFirst we want lexographical order with pairs given.\\n\\noriginally we can sort the string to get smallest one, since pairs are given we can\\'t do that directly.\\n\\nEach pair gives indices src, dst to swap. Actual solution is in ordering of applying these pairs and we can do as may times as possible.\\n\\nSince as many times as possible is given we can\\'t do permuatation of pairs and solve it.\\n\\nNow one observation is that if two pairs have a common index then ordering of them is importatnt.\\neg: [b,c,a] we have pairs[[0,1],[1,2]].   Here ordring is importnant, if we look at [0,1] its not useful for us, so we can ignore it(since b already less than c no need to swap) and we can apply [1,2] to get [b,a,c] but its not smallest possible. If we have applied [1,2] first the we would have got [a,b,c]\\n\\nSo if two pairs have common index then ordering among them is importatnt to get smallest string. if common index is not there they can be treated independently. As one cannot influence other. Eg: if we have [0,3], [1,2]. no matter how many times we apply [0,3] we can\\'t affect indices [1,2]\\n\\n**first Note**: pairs having common indices should be grouped together.\\n\\nAfter grouping them we can swap those elements in a group as many number of times as we want.\\nEg: lets say we have 1->2, 2->3 as nodes. we can;t swap 1,3 directly but we can swap 1->3 by doing these swaps (1->2, 2->3, 1->2) since we can do swaps as many times as needed. If we swap any indices then we can get sorted order(remember bubble sort, we do sort just by swapping only) of chars in same group.\\n\\n**second Note:** we can sort chars in same group to get smallest string possible with those chars.\\n\\nfor first part we can use disjoint union find.\\nfor second part we can store chars of smae group in a string and sort them and put them back in original string.\\n\\nNow go thorugh code to understand it.\\n\\nLet me know if anything not clear in comments.\\n\\n\\n```\\nclass DSU {\\n    vector<int> parents;\\n    vector<int> rank;\\n    int n;\\npublic:\\n    DSU(int n) {\\n        this->n = n;\\n        parents.resize(n);\\n        rank.resize(n, 0);\\n        for (int i = 0; i < n; ++i) {\\n            parents[i] = i;\\n        }\\n    }\\n    \\n    int find(int x) {\\n        if (parents[x] != x) {\\n            parents[x] = find(parents[x]);\\n        }\\n        return parents[x];\\n    }\\n    \\n    bool unionize(int a, int b) {\\n        int pa = find(a);\\n        int pb = find(b);\\n        \\n        if (pa==pb) return false;\\n        \\n        if (rank[pb] < rank[pa]) {\\n            parents[pb] = pa;\\n            rank[pa] += rank[pb];\\n        } else {\\n            parents[pa] = pb;\\n            rank[pb] += rank[pa];\\n        }\\n        return true;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        int n = s.length();\\n        \\n        vector<int> parents(n, 0);\\n        \\n        for (int i = 0; i < n; i++) {\\n            parents[i] = i;\\n        }\\n        \\n        DSU d(n);\\n        \\n        for (auto pair : pairs) {\\n            d.unionize(pair[0], pair[1]);\\n        }\\n        \\n        unordered_map<int,vector<int>> components;\\n        for (int i = 0; i < n; ++i) {\\n            components[d.find(i)].push_back(i);\\n        }\\n        \\n        for (auto comp : components) {\\n            string curstr=\"\";\\n            for (auto idx : comp.second) {\\n                curstr += s[idx];\\n            }\\n            \\n            sort(curstr.begin(), curstr.end());\\n            \\n            for (int i = 0; i < comp.second.size(); ++i) {\\n                s[comp.second[i]] = curstr[i];\\n            }\\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass DSU {\\n    vector<int> parents;\\n    vector<int> rank;\\n    int n;\\npublic:\\n    DSU(int n) {\\n        this->n = n;\\n        parents.resize(n);\\n        rank.resize(n, 0);\\n        for (int i = 0; i < n; ++i) {\\n            parents[i] = i;\\n        }\\n    }\\n    \\n    int find(int x) {\\n        if (parents[x] != x) {\\n            parents[x] = find(parents[x]);\\n        }\\n        return parents[x];\\n    }\\n    \\n    bool unionize(int a, int b) {\\n        int pa = find(a);\\n        int pb = find(b);\\n        \\n        if (pa==pb) return false;\\n        \\n        if (rank[pb] < rank[pa]) {\\n            parents[pb] = pa;\\n            rank[pa] += rank[pb];\\n        } else {\\n            parents[pa] = pb;\\n            rank[pb] += rank[pa];\\n        }\\n        return true;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        int n = s.length();\\n        \\n        vector<int> parents(n, 0);\\n        \\n        for (int i = 0; i < n; i++) {\\n            parents[i] = i;\\n        }\\n        \\n        DSU d(n);\\n        \\n        for (auto pair : pairs) {\\n            d.unionize(pair[0], pair[1]);\\n        }\\n        \\n        unordered_map<int,vector<int>> components;\\n        for (int i = 0; i < n; ++i) {\\n            components[d.find(i)].push_back(i);\\n        }\\n        \\n        for (auto comp : components) {\\n            string curstr=\"\";\\n            for (auto idx : comp.second) {\\n                curstr += s[idx];\\n            }\\n            \\n            sort(curstr.begin(), curstr.end());\\n            \\n            for (int i = 0; i < comp.second.size(); ++i) {\\n                s[comp.second[i]] = curstr[i];\\n            }\\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1985400,
                "title": "python-3-union-find-priority-queue-heap",
                "content": "```\\nclass UnionFind:\\n    def __init__(self, size: int):\\n        self.root = [i for i in range(size)]\\n        self.rank = [1 for _ in range(size)]\\n        \\n    def find(self, x: int) -> int:\\n        if x == self.root[x]:\\n            return x\\n        \\n        self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n    \\n    def union(self, x: int, y: int) -> None:\\n        root_x, root_y = self.find(x), self.find(y)\\n        if root_x != root_y:\\n            if self.rank[root_x] > self.rank[root_y]:\\n                self.root[root_y] = root_x\\n            elif self.rank[root_x] < self.rank[root_y]:\\n                self.root[root_x] = root_y\\n            else:\\n                self.root[root_y] = root_x\\n                self.rank[root_x] += 1\\n    \\n    def connected(self, x: int, y: int) -> bool:\\n        return self.find(x) == self.find(y)\\n\\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        n = len(s)\\n        uf = UnionFind(n)\\n        for x, y in pairs:\\n            uf.union(x, y)\\n        \\n        alias = defaultdict(list)\\n        for i in range(n):\\n            root = uf.find(i)\\n            heappush(alias[root], s[i])\\n        \\n        res = []\\n        for i in range(n):\\n            res.append(heappop(alias[uf.find(i)]))\\n        \\n        return \\'\\'.join(res)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Union Find",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass UnionFind:\\n    def __init__(self, size: int):\\n        self.root = [i for i in range(size)]\\n        self.rank = [1 for _ in range(size)]\\n        \\n    def find(self, x: int) -> int:\\n        if x == self.root[x]:\\n            return x\\n        \\n        self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n    \\n    def union(self, x: int, y: int) -> None:\\n        root_x, root_y = self.find(x), self.find(y)\\n        if root_x != root_y:\\n            if self.rank[root_x] > self.rank[root_y]:\\n                self.root[root_y] = root_x\\n            elif self.rank[root_x] < self.rank[root_y]:\\n                self.root[root_x] = root_y\\n            else:\\n                self.root[root_y] = root_x\\n                self.rank[root_x] += 1\\n    \\n    def connected(self, x: int, y: int) -> bool:\\n        return self.find(x) == self.find(y)\\n\\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        n = len(s)\\n        uf = UnionFind(n)\\n        for x, y in pairs:\\n            uf.union(x, y)\\n        \\n        alias = defaultdict(list)\\n        for i in range(n):\\n            root = uf.find(i)\\n            heappush(alias[root], s[i])\\n        \\n        res = []\\n        for i in range(n):\\n            res.append(heappop(alias[uf.find(i)]))\\n        \\n        return \\'\\'.join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1985347,
                "title": "python-98-27-dfs",
                "content": "```\\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        def dfs(idx, arr):\\n            arr.append(idx)\\n            visited[idx] = True\\n            for nei in graph[idx]:\\n                if not visited[nei]:\\n                    visited[nei] = True\\n                    dfs(nei, arr)\\n            \\n        graph = collections.defaultdict(list)\\n        for a, b in pairs:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n\\n        n = len(s)\\n        s_list = list(s)\\n        visited = [False] * n\\n        for idx in range(n):\\n            if not visited[idx]:\\n                arr = []\\n                dfs(idx, arr)\\n                arr.sort()\\n                letter = [s[i] for i in arr]\\n                letter.sort()\\n                for i in range(len(arr)):\\n                    s_list[arr[i]] = letter[i]\\n        return \\'\\'.join(s_list)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        def dfs(idx, arr):\\n            arr.append(idx)\\n            visited[idx] = True\\n            for nei in graph[idx]:\\n                if not visited[nei]:\\n                    visited[nei] = True\\n                    dfs(nei, arr)\\n            \\n        graph = collections.defaultdict(list)\\n        for a, b in pairs:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n\\n        n = len(s)\\n        s_list = list(s)\\n        visited = [False] * n\\n        for idx in range(n):\\n            if not visited[idx]:\\n                arr = []\\n                dfs(idx, arr)\\n                arr.sort()\\n                letter = [s[i] for i in arr]\\n                letter.sort()\\n                for i in range(len(arr)):\\n                    s_list[arr[i]] = letter[i]\\n        return \\'\\'.join(s_list)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1985334,
                "title": "c-disjoin-set-union-min-heap-explanation",
                "content": "All of letters that connect each other can swap, so we need to find all unions and sort those unions. After sorting we merge all sorted unions to the result.\\nMy code uses disjoin set to union graph and use min-heap to sort them.\\n```\\nint p[100000];\\nint N;\\n\\nclass Solution {\\npublic:\\n    \\n    int find(int x, int y) {\\n        if (p[x] == x and p[y] == y) {\\n            if (x < y) {\\n                p[y] = x;\\n                return x;\\n            } else {\\n                p[x] = y;\\n                return y;\\n            }\\n        } else {\\n            int newP = find(p[x], p[y]);\\n            p[x] = newP;\\n            p[y] = newP;\\n            return newP;\\n        }\\n    }\\n    \\n    int findParent(int x) {\\n        if (p[x] == x) return x;\\n        p[x] = findParent(p[x]);\\n        return p[x];\\n    }\\n    \\n    \\n    void unionFind(vector<vector<int>>& pairs) {\\n        for (int i = 0; i < pairs.size(); i++) {\\n            find(pairs[i][0], pairs[i][1]);\\n        }\\n        \\n        for (int i = 0; i < N; i++) {\\n            if (p[i] != i) findParent(i);\\n        }\\n    }\\n    \\n    \\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        N = s.size();\\n        for (int i = 0; i < N; i++) {\\n            p[i] = i;\\n        }\\n        // Step 1: Union Find\\n        unionFind(pairs);\\n        // Step 2: Using MinHeap to sort string.\\n        unordered_map<int, priority_queue<int, vector<int>, greater<int>>> vq;\\n        \\n        for (int i = 0; i < N; i++) {\\n            vq[p[i]].push(s[i]);\\n        }\\n        \\n        // Step 3: Merge all sorted min heaps to result.\\n        string res = \"\";\\n        for (int i = 0; i < N; i++) {\\n            res += vq[p[i]].top();\\n            vq[p[i]].pop();\\n        }\\n          \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nint p[100000];\\nint N;\\n\\nclass Solution {\\npublic:\\n    \\n    int find(int x, int y) {\\n        if (p[x] == x and p[y] == y) {\\n            if (x < y) {\\n                p[y] = x;\\n                return x;\\n            } else {\\n                p[x] = y;\\n                return y;\\n            }\\n        } else {\\n            int newP = find(p[x], p[y]);\\n            p[x] = newP;\\n            p[y] = newP;\\n            return newP;\\n        }\\n    }\\n    \\n    int findParent(int x) {\\n        if (p[x] == x) return x;\\n        p[x] = findParent(p[x]);\\n        return p[x];\\n    }\\n    \\n    \\n    void unionFind(vector<vector<int>>& pairs) {\\n        for (int i = 0; i < pairs.size(); i++) {\\n            find(pairs[i][0], pairs[i][1]);\\n        }\\n        \\n        for (int i = 0; i < N; i++) {\\n            if (p[i] != i) findParent(i);\\n        }\\n    }\\n    \\n    \\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        N = s.size();\\n        for (int i = 0; i < N; i++) {\\n            p[i] = i;\\n        }\\n        // Step 1: Union Find\\n        unionFind(pairs);\\n        // Step 2: Using MinHeap to sort string.\\n        unordered_map<int, priority_queue<int, vector<int>, greater<int>>> vq;\\n        \\n        for (int i = 0; i < N; i++) {\\n            vq[p[i]].push(s[i]);\\n        }\\n        \\n        // Step 3: Merge all sorted min heaps to result.\\n        string res = \"\";\\n        for (int i = 0; i < N; i++) {\\n            res += vq[p[i]].top();\\n            vq[p[i]].pop();\\n        }\\n          \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1985217,
                "title": "c-solution-union-find-method",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> parent;\\n    int find_set(int i)\\n    {\\n        if(parent[i] == i) return i;\\n        return parent[i] = find_set(parent[i]);\\n    }\\n\\n    void find_union(int x, int y){\\n        int a = find_set(x);\\n        int b = find_set(y);\\n        if(a != b){\\n           parent[b] = a;\\n        }\\n    }\\n\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n       int n = s.size();\\n       parent.resize(n);\\n       for(int i = 0; i<n; i++){\\n           parent[i] = i;\\n       }\\n\\n       for(auto it : pairs){\\n           int x = it[0], y = it[1];\\n           find_union(x, y);\\n       }\\n\\n       vector<vector<int>> edges(n);\\n       for(int i = 0; i<n; i++){\\n           edges[find_set(i)].push_back(i);\\n       }\\n\\n       for(auto it : edges){\\n           string str = \"\";\\n           for(auto n : it){\\n               str += s[n];\\n           }\\n           sort(str.begin(), str.end());\\n           for(int i = 0; i<it.size(); i++){\\n               s[it[i]] = str[i];\\n           }\\n       }\\n       return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> parent;\\n    int find_set(int i)\\n    {\\n        if(parent[i] == i) return i;\\n        return parent[i] = find_set(parent[i]);\\n    }\\n\\n    void find_union(int x, int y){\\n        int a = find_set(x);\\n        int b = find_set(y);\\n        if(a != b){\\n           parent[b] = a;\\n        }\\n    }\\n\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n       int n = s.size();\\n       parent.resize(n);\\n       for(int i = 0; i<n; i++){\\n           parent[i] = i;\\n       }\\n\\n       for(auto it : pairs){\\n           int x = it[0], y = it[1];\\n           find_union(x, y);\\n       }\\n\\n       vector<vector<int>> edges(n);\\n       for(int i = 0; i<n; i++){\\n           edges[find_set(i)].push_back(i);\\n       }\\n\\n       for(auto it : edges){\\n           string str = \"\";\\n           for(auto n : it){\\n               str += s[n];\\n           }\\n           sort(str.begin(), str.end());\\n           for(int i = 0; i<it.size(); i++){\\n               s[it[i]] = str[i];\\n           }\\n       }\\n       return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1820983,
                "title": "python-clean-solution-with-union-find",
                "content": "```\\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        def findSet(x):\\n            if x != p[x]:\\n                p[x]=findSet(p[x])\\n            return p[x]\\n        def union(x,y):\\n            return link(findSet(x), findSet(y))\\n        def link(x,y):\\n            if rank[x]>rank[y]:\\n                p[y]=x\\n            else:\\n                p[x]=y\\n                if rank[x] == rank[y]:\\n                    rank[y] += 1\\n        \\n        n = len(s)\\n        p=[x for x in range(n)]\\n        rank=[0]*n\\n        \\n        for x,y in pairs:\\n            if findSet(x) != findSet(y):\\n                union(x,y)\\n        sets = defaultdict(list)\\n        for x in range(n):\\n            sets[findSet(x)] += [x]\\n        \\n        res = [None]*n\\n        for rep in sets:\\n            indices = sets[rep]\\n            values = [s[x] for x in indices]\\n            start = 0\\n            values.sort()\\n            for ind in indices:\\n                res[ind] = values[start]\\n                start+=1\\n        ans = \"\".join(res)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        def findSet(x):\\n            if x != p[x]:\\n                p[x]=findSet(p[x])\\n            return p[x]\\n        def union(x,y):\\n            return link(findSet(x), findSet(y))\\n        def link(x,y):\\n            if rank[x]>rank[y]:\\n                p[y]=x\\n            else:\\n                p[x]=y\\n                if rank[x] == rank[y]:\\n                    rank[y] += 1\\n        \\n        n = len(s)\\n        p=[x for x in range(n)]\\n        rank=[0]*n\\n        \\n        for x,y in pairs:\\n            if findSet(x) != findSet(y):\\n                union(x,y)\\n        sets = defaultdict(list)\\n        for x in range(n):\\n            sets[findSet(x)] += [x]\\n        \\n        res = [None]*n\\n        for rep in sets:\\n            indices = sets[rep]\\n            values = [s[x] for x in indices]\\n            start = 0\\n            values.sort()\\n            for ind in indices:\\n                res[ind] = values[start]\\n                start+=1\\n        ans = \"\".join(res)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1790562,
                "title": "python3-unionfind-clear-code",
                "content": "```\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.root = [i for i in range(n)]\\n        self.rank = [0] * n\\n        \\n    def find(self, x):\\n        if x == self.root[x]:\\n            return x\\n\\n        self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n    \\n    def union(self, x, y):\\n        rootX = self.find(x)\\n        rootY = self.find(y)\\n        \\n        if rootX != rootY:\\n            if self.rank[rootX] < self.rank[rootY]:\\n                self.root[rootX] = rootY\\n            elif self.rank[rootX] > self.rank[rootY]:\\n                self.root[rootY] = rootX\\n            else:\\n                self.root[rootY] = rootX\\n                self.rank[rootX] += 1\\n    \\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        num_s = len(s)\\n        unionfind = UnionFind(num_s)\\n        for i, (x, y) in enumerate(pairs):\\n            unionfind.union(x, y)\\n\\n        from collections import defaultdict\\n        lexi = defaultdict(list)\\n        \\n        for i in range(num_s):\\n            unionfind.find(i)\\n            cur_root = unionfind.root[i]\\n            lexi[cur_root].append(s[i])\\n        \\n        for key, item in lexi.items():\\n            item.sort(reverse=True)\\n        \\n        ans = \"\"\\n        for i in range(num_s):\\n            cur_root = unionfind.root[i]\\n            ans += lexi[cur_root].pop()\\n            \\n        return ans      \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.root = [i for i in range(n)]\\n        self.rank = [0] * n\\n        \\n    def find(self, x):\\n        if x == self.root[x]:\\n            return x\\n\\n        self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n    \\n    def union(self, x, y):\\n        rootX = self.find(x)\\n        rootY = self.find(y)\\n        \\n        if rootX != rootY:\\n            if self.rank[rootX] < self.rank[rootY]:\\n                self.root[rootX] = rootY\\n            elif self.rank[rootX] > self.rank[rootY]:\\n                self.root[rootY] = rootX\\n            else:\\n                self.root[rootY] = rootX\\n                self.rank[rootX] += 1\\n    \\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        num_s = len(s)\\n        unionfind = UnionFind(num_s)\\n        for i, (x, y) in enumerate(pairs):\\n            unionfind.union(x, y)\\n\\n        from collections import defaultdict\\n        lexi = defaultdict(list)\\n        \\n        for i in range(num_s):\\n            unionfind.find(i)\\n            cur_root = unionfind.root[i]\\n            lexi[cur_root].append(s[i])\\n        \\n        for key, item in lexi.items():\\n            item.sort(reverse=True)\\n        \\n        ans = \"\"\\n        for i in range(num_s):\\n            cur_root = unionfind.root[i]\\n            ans += lexi[cur_root].pop()\\n            \\n        return ans      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1699604,
                "title": "java-concise-solution",
                "content": "```\\nclass Solution \\n{\\n    int[] par;\\n    public int findPar(int u){\\n        return par[u] = (par[u] == u) ? u : findPar(par[u]);\\n    }\\n    \\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) \\n    {\\n        StringBuilder sb = new StringBuilder();\\n        par  = new int[s.length()];\\n        for(int i = 0;i<par.length;i++) par[i] = i;\\n        for(List<Integer> ele : pairs)\\n        {\\n            int u = ele.get(0);\\n            int v = ele.get(1);\\n            int parU = findPar(u);\\n            int parV = findPar(v);\\n            if(parU != parV) par[parU] = parV;\\n        }\\n        \\n        HashMap<Integer,TreeMap<Character,Integer>> map = new HashMap<>();\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            int par = findPar(i);\\n            if(!map.containsKey(par)) map.put(par,new TreeMap<>());\\n            TreeMap<Character,Integer> set = map.get(par);\\n            set.put(s.charAt(i),set.getOrDefault(s.charAt(i),0)+1);\\n        }\\n        \\n        for(int i = 0;i<s.length();i++)\\n        {\\n            int par = findPar(i);\\n            TreeMap<Character,Integer> temp = map.get(par);\\n            char firstKey = temp.firstKey();\\n            sb.append(firstKey);\\n            temp.put(firstKey,temp.get(firstKey)-1);\\n            if(temp.get(firstKey) == 0) temp.remove(firstKey);\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution \\n{\\n    int[] par;\\n    public int findPar(int u){\\n        return par[u] = (par[u] == u) ? u : findPar(par[u]);\\n    }\\n    \\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) \\n    {\\n        StringBuilder sb = new StringBuilder();\\n        par  = new int[s.length()];\\n        for(int i = 0;i<par.length;i++) par[i] = i;\\n        for(List<Integer> ele : pairs)\\n        {\\n            int u = ele.get(0);\\n            int v = ele.get(1);\\n            int parU = findPar(u);\\n            int parV = findPar(v);\\n            if(parU != parV) par[parU] = parV;\\n        }\\n        \\n        HashMap<Integer,TreeMap<Character,Integer>> map = new HashMap<>();\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            int par = findPar(i);\\n            if(!map.containsKey(par)) map.put(par,new TreeMap<>());\\n            TreeMap<Character,Integer> set = map.get(par);\\n            set.put(s.charAt(i),set.getOrDefault(s.charAt(i),0)+1);\\n        }\\n        \\n        for(int i = 0;i<s.length();i++)\\n        {\\n            int par = findPar(i);\\n            TreeMap<Character,Integer> temp = map.get(par);\\n            char firstKey = temp.firstKey();\\n            sb.append(firstKey);\\n            temp.put(firstKey,temp.get(firstKey)-1);\\n            if(temp.get(firstKey) == 0) temp.remove(firstKey);\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1659577,
                "title": "swift-94-unionfind",
                "content": "```\\nclass Solution {\\n\\n    struct UnionFind {\\n        \\n        var parent: [Int]\\n        var rank: [Int]\\n        \\n        init(_ maxCount: Int) { \\n            parent = [Int](0..<maxCount)\\n            rank = [Int](repeating: 0, count: maxCount)\\n        }\\n        \\n        mutating func find(_ u: Int) -> Int {\\n            if parent[u] == u {\\n                return u\\n            }\\n            \\n            parent[u] = find(parent[u])\\n            return parent[u]\\n        }\\n        \\n        mutating func union(_ u: Int, _ v: Int) {\\n            let pu = find(u)\\n            let pv = find(v)\\n            \\n            if pu != pv {\\n                if rank[pu] > rank[pv] {\\n                    parent[pu] = parent[pv]\\n                } else {\\n                    parent[pv] = parent[pu]\\n                    rank[pu] += 1\\n                }\\n            }\\n        }\\n    }\\n    \\n    func smallestStringWithSwaps(_ s: String, _ pairs: [[Int]]) -> String {\\n        \\n        var uf = UnionFind(s.count)\\n        var group = [Int: Set<Int>]()\\n        \\n        for pair in pairs {\\n            let u = pair[0], v = pair[1]\\n            uf.union(u, v)\\n        }\\n        \\n        var chars = Array(s)\\n        var charsMap = [Int: [Character]]()\\n        var indexesMap = [Int: [Int]]()\\n        for i in 0..<chars.count {\\n            let root = uf.find(i)\\n            charsMap[root, default: [Character]()].append(chars[i])\\n            indexesMap[root, default: [Int]()].append(i)\\n        }\\n        \\n        for (key, value) in charsMap {\\n            var indice: [Int] = indexesMap[key] ?? []\\n            var sortedChars = value.sorted()\\n            for (idx, char) in zip(indice, sortedChars) {\\n                chars[idx] = char\\n            }\\n        }\\n        \\n        return String(chars)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n\\n    struct UnionFind {\\n        \\n        var parent: [Int]\\n        var rank: [Int]\\n        \\n        init(_ maxCount: Int) { \\n            parent = [Int](0..<maxCount)\\n            rank = [Int](repeating: 0, count: maxCount)\\n        }\\n        \\n        mutating func find(_ u: Int) -> Int {\\n            if parent[u] == u {\\n                return u\\n            }\\n            \\n            parent[u] = find(parent[u])\\n            return parent[u]\\n        }\\n        \\n        mutating func union(_ u: Int, _ v: Int) {\\n            let pu = find(u)\\n            let pv = find(v)\\n            \\n            if pu != pv {\\n                if rank[pu] > rank[pv] {\\n                    parent[pu] = parent[pv]\\n                } else {\\n                    parent[pv] = parent[pu]\\n                    rank[pu] += 1\\n                }\\n            }\\n        }\\n    }\\n    \\n    func smallestStringWithSwaps(_ s: String, _ pairs: [[Int]]) -> String {\\n        \\n        var uf = UnionFind(s.count)\\n        var group = [Int: Set<Int>]()\\n        \\n        for pair in pairs {\\n            let u = pair[0], v = pair[1]\\n            uf.union(u, v)\\n        }\\n        \\n        var chars = Array(s)\\n        var charsMap = [Int: [Character]]()\\n        var indexesMap = [Int: [Int]]()\\n        for i in 0..<chars.count {\\n            let root = uf.find(i)\\n            charsMap[root, default: [Character]()].append(chars[i])\\n            indexesMap[root, default: [Int]()].append(i)\\n        }\\n        \\n        for (key, value) in charsMap {\\n            var indice: [Int] = indexesMap[key] ?? []\\n            var sortedChars = value.sorted()\\n            for (idx, char) in zip(indice, sortedChars) {\\n                chars[idx] = char\\n            }\\n        }\\n        \\n        return String(chars)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1642747,
                "title": "easy-to-understand-python-solution-dsu-99-faster",
                "content": "```\\nclass DSU:\\n    def __init__(self, n):\\n        self.n = n\\n        self.par = [-1 for _ in range(n)]\\n        self.rank = [1 for _ in range(n)]\\n    \\n    def findPar(self, z):\\n        if self.par[z] == -1:\\n            return z\\n        self.par[z] = self.findPar(self.par[z])\\n        return self.par[z]\\n    \\n    def union(self, a, b):\\n        if self.rank[a] < self.rank[b]:\\n            a, b = b, a\\n        self.par[b] = a\\n        self.rank[a] += int(self.rank[a] == self.rank[b])\\n\\n\\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        n = len(s)\\n        dsu = DSU(n)\\n        for a, b in pairs:\\n            u = dsu.findPar(a)\\n            v = dsu.findPar(b)\\n            if u != v:\\n                dsu.union(u, v)\\n        \\n        groups = {}\\n        for i in range(n):\\n            z = dsu.findPar(i)\\n            if z not in groups:\\n                groups[z] = []\\n            groups[z].append(i)\\n        \\n        ans = [\"a\" for _ in range(n)]\\n        for group in groups.values():\\n            temp = [s[i] for i in group]\\n            temp.sort()\\n            for j in range(len(group)):\\n                ans[group[j]] = temp[j]\\n        \\n        return \"\".join(ans)\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\nclass DSU:\\n    def __init__(self, n):\\n        self.n = n\\n        self.par = [-1 for _ in range(n)]\\n        self.rank = [1 for _ in range(n)]\\n    \\n    def findPar(self, z):\\n        if self.par[z] == -1:\\n            return z\\n        self.par[z] = self.findPar(self.par[z])\\n        return self.par[z]\\n    \\n    def union(self, a, b):\\n        if self.rank[a] < self.rank[b]:\\n            a, b = b, a\\n        self.par[b] = a\\n        self.rank[a] += int(self.rank[a] == self.rank[b])\\n\\n\\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        n = len(s)\\n        dsu = DSU(n)\\n        for a, b in pairs:\\n            u = dsu.findPar(a)\\n            v = dsu.findPar(b)\\n            if u != v:\\n                dsu.union(u, v)\\n        \\n        groups = {}\\n        for i in range(n):\\n            z = dsu.findPar(i)\\n            if z not in groups:\\n                groups[z] = []\\n            groups[z].append(i)\\n        \\n        ans = [\"a\" for _ in range(n)]\\n        for group in groups.values():\\n            temp = [s[i] for i in group]\\n            temp.sort()\\n            for j in range(len(group)):\\n                ans[group[j]] = temp[j]\\n        \\n        return \"\".join(ans)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1615090,
                "title": "java-solution-using-union-find-and-hashmap",
                "content": "```\\nclass Solution {\\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        MyDSU myDSU = new MyDSU(s.length());\\n        HashMap<Integer,List<Character>> map = new HashMap<>();\\n        for(List<Integer> edge: pairs) {\\n            int src = edge.get(0);\\n            int des = edge.get(1);\\n            myDSU.union(src,des);\\n        }\\n        for (int i = 0; i < s.length(); i++) {\\n            int parent = myDSU.find(i);\\n            if(!map.containsKey(parent)) map.put(parent, new ArrayList<>());\\n            map.get(parent).add(s.charAt(i));\\n        }\\n        \\n        StringBuilder result = new StringBuilder();\\n        \\n        for (List<Character> characters : map.values()) {\\n            Collections.sort(characters, Collections.reverseOrder());\\n        }\\n        for (int i = 0; i < s.length(); i++) {\\n            List<Character> characters = map.get(myDSU.find(i));\\n            char currentMin = characters.remove(characters.size()-1);\\n            result.append(currentMin);\\n        }\\n        \\n        return result.toString();\\n        \\n    }\\n}\\n\\nclass MyDSU {\\n    \\n    int [] parent, rank;\\n    int component;\\n    public MyDSU(int size) {\\n        parent = new int [size];\\n        rank = new int [size];\\n        \\n        for(int i=0;i<size;i++) {\\n            parent[i]=i;\\n            rank[i]=0;\\n        }\\n        component = size;\\n    }\\n    \\n    public int find(int x) {\\n        if(x == parent[x]) return x;\\n        return parent[x] = find(parent[x]);\\n    }\\n    \\n    public boolean union(int x, int y) {\\n        int parentX = find(x);\\n        int parentY = find(y);\\n        \\n        if(parentX==parentY) return false;\\n        if(rank[parentX]>rank[parentY]) {\\n            parent[parentY]=parentX;\\n        } else if (rank[parentY]>rank[parentX]) {\\n            parent[parentX]=parentY;\\n        } else {\\n                parent[parentY]=parentX;\\n                rank[parentX]++;\\n        }\\n        component--;\\n        return true;\\n    }\\n    \\n    public int getComponent() {\\n        return component;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        MyDSU myDSU = new MyDSU(s.length());\\n        HashMap<Integer,List<Character>> map = new HashMap<>();\\n        for(List<Integer> edge: pairs) {\\n            int src = edge.get(0);\\n            int des = edge.get(1);\\n            myDSU.union(src,des);\\n        }\\n        for (int i = 0; i < s.length(); i++) {\\n            int parent = myDSU.find(i);\\n            if(!map.containsKey(parent)) map.put(parent, new ArrayList<>());\\n            map.get(parent).add(s.charAt(i));\\n        }\\n        \\n        StringBuilder result = new StringBuilder();\\n        \\n        for (List<Character> characters : map.values()) {\\n            Collections.sort(characters, Collections.reverseOrder());\\n        }\\n        for (int i = 0; i < s.length(); i++) {\\n            List<Character> characters = map.get(myDSU.find(i));\\n            char currentMin = characters.remove(characters.size()-1);\\n            result.append(currentMin);\\n        }\\n        \\n        return result.toString();\\n        \\n    }\\n}\\n\\nclass MyDSU {\\n    \\n    int [] parent, rank;\\n    int component;\\n    public MyDSU(int size) {\\n        parent = new int [size];\\n        rank = new int [size];\\n        \\n        for(int i=0;i<size;i++) {\\n            parent[i]=i;\\n            rank[i]=0;\\n        }\\n        component = size;\\n    }\\n    \\n    public int find(int x) {\\n        if(x == parent[x]) return x;\\n        return parent[x] = find(parent[x]);\\n    }\\n    \\n    public boolean union(int x, int y) {\\n        int parentX = find(x);\\n        int parentY = find(y);\\n        \\n        if(parentX==parentY) return false;\\n        if(rank[parentX]>rank[parentY]) {\\n            parent[parentY]=parentX;\\n        } else if (rank[parentY]>rank[parentX]) {\\n            parent[parentX]=parentY;\\n        } else {\\n                parent[parentY]=parentX;\\n                rank[parentX]++;\\n        }\\n        component--;\\n        return true;\\n    }\\n    \\n    public int getComponent() {\\n        return component;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1579835,
                "title": "java-solution-same-idea-but-without-union-find",
                "content": "```\\nclass Solution {\\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        List<List<Integer>> adj = new ArrayList<>();\\n        int n=s.length();\\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        for(List<Integer> l1 :pairs){\\n            int u = l1.get(0), v = l1.get(1);\\n            adj.get(u).add(v);\\n            adj.get(v).add(u);\\n        }\\n        \\n        char[] arr = s.toCharArray();\\n        boolean[] vis = new boolean[n];\\n        List<List<Integer>> cn = getConnectedComponents(adj,n);\\n        for(List<Integer> l1: cn){\\n            char[] temp = new char[l1.size()];\\n            for(int i=0;i<temp.length;i++){\\n                temp[i] = arr[l1.get(i)];\\n            }\\n            Arrays.sort(temp);\\n            Collections.sort(l1);\\n            for(int i=0;i<temp.length;i++){\\n                arr[l1.get(i)] = temp[i];\\n            }\\n        }\\n        \\n        return String.valueOf(arr);\\n    }\\n    \\n    public void dfs(List<List<Integer>> adj, int src, boolean[] vis, List<Integer> temp){\\n        \\n        temp.add(src);\\n        vis[src] = true;\\n        for(int i: adj.get(src)){\\n            if(!vis[i]){\\n                dfs(adj, i, vis,temp);\\n            }\\n        }\\n    }\\n    \\n    public List<List<Integer>> getConnectedComponents(List<List<Integer>> adj, int n){\\n        \\n        List<List<Integer>> ans = new ArrayList<>();\\n        \\n        boolean[] visited = new boolean[n];\\n        for(int i=0;i<n;i++){\\n            if(!visited[i]){\\n                List<Integer> temp = new ArrayList<>();\\n                dfs(adj,i,visited,temp);\\n                ans.add(temp);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        List<List<Integer>> adj = new ArrayList<>();\\n        int n=s.length();\\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        for(List<Integer> l1 :pairs){\\n            int u = l1.get(0), v = l1.get(1);\\n            adj.get(u).add(v);\\n            adj.get(v).add(u);\\n        }\\n        \\n        char[] arr = s.toCharArray();\\n        boolean[] vis = new boolean[n];\\n        List<List<Integer>> cn = getConnectedComponents(adj,n);\\n        for(List<Integer> l1: cn){\\n            char[] temp = new char[l1.size()];\\n            for(int i=0;i<temp.length;i++){\\n                temp[i] = arr[l1.get(i)];\\n            }\\n            Arrays.sort(temp);\\n            Collections.sort(l1);\\n            for(int i=0;i<temp.length;i++){\\n                arr[l1.get(i)] = temp[i];\\n            }\\n        }\\n        \\n        return String.valueOf(arr);\\n    }\\n    \\n    public void dfs(List<List<Integer>> adj, int src, boolean[] vis, List<Integer> temp){\\n        \\n        temp.add(src);\\n        vis[src] = true;\\n        for(int i: adj.get(src)){\\n            if(!vis[i]){\\n                dfs(adj, i, vis,temp);\\n            }\\n        }\\n    }\\n    \\n    public List<List<Integer>> getConnectedComponents(List<List<Integer>> adj, int n){\\n        \\n        List<List<Integer>> ans = new ArrayList<>();\\n        \\n        boolean[] visited = new boolean[n];\\n        for(int i=0;i<n;i++){\\n            if(!visited[i]){\\n                List<Integer> temp = new ArrayList<>();\\n                dfs(adj,i,visited,temp);\\n                ans.add(temp);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578050,
                "title": "java-union-find",
                "content": "```\\nclass Solution {\\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        int n = s.length();\\n        UnionFind uf = new UnionFind(n);\\n        \\n        for(List<Integer> pair:pairs){\\n            uf.union(pair.get(0),pair.get(1));\\n        }\\n        \\n        Map<Integer,Queue<Character>> map = new HashMap<>();\\n        for(int i=0;i<s.length();i++){\\n            char c = s.charAt(i);\\n            int p = uf.find(i);\\n            if(!map.containsKey(p))map.put(p,new PriorityQueue<>());\\n            map.get(p).offer(c);\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0;i<n;i++){\\n            int p = uf.find(i);\\n            char c = map.get(p).poll();\\n            sb.append(c);\\n        }\\n        return sb.toString();\\n    }\\n    \\n    class UnionFind{\\n        int[]parent;\\n        \\n        UnionFind(int n){\\n            parent = new int[n];\\n            for(int i=0;i<n;i++){\\n                parent[i] = i;\\n            }\\n        }\\n        \\n        boolean union(int n1, int n2){\\n            int p1 = find(n1);\\n            int p2 = find(n2);\\n            if(p1 == p2)return false;\\n            parent[p2] = p1;\\n            return true;\\n        }\\n        \\n        int find(int n){\\n            if(n==parent[n])return n;\\n            return parent[n]=find(parent[n]);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        int n = s.length();\\n        UnionFind uf = new UnionFind(n);\\n        \\n        for(List<Integer> pair:pairs){\\n            uf.union(pair.get(0),pair.get(1));\\n        }\\n        \\n        Map<Integer,Queue<Character>> map = new HashMap<>();\\n        for(int i=0;i<s.length();i++){\\n            char c = s.charAt(i);\\n            int p = uf.find(i);\\n            if(!map.containsKey(p))map.put(p,new PriorityQueue<>());\\n            map.get(p).offer(c);\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0;i<n;i++){\\n            int p = uf.find(i);\\n            char c = map.get(p).poll();\\n            sb.append(c);\\n        }\\n        return sb.toString();\\n    }\\n    \\n    class UnionFind{\\n        int[]parent;\\n        \\n        UnionFind(int n){\\n            parent = new int[n];\\n            for(int i=0;i<n;i++){\\n                parent[i] = i;\\n            }\\n        }\\n        \\n        boolean union(int n1, int n2){\\n            int p1 = find(n1);\\n            int p2 = find(n2);\\n            if(p1 == p2)return false;\\n            parent[p2] = p1;\\n            return true;\\n        }\\n        \\n        int find(int n){\\n            if(n==parent[n])return n;\\n            return parent[n]=find(parent[n]);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1569505,
                "title": "beats-94-java-union-find-solution-clean-and-concise-w-explanation",
                "content": "First consider if we have pairs [1,2],[2,3],[3,4], it means we can swap each pair of indices in set{1,2,3,4}, like we can swap 1,4 even if it is not shown as a pair.\\n\\nThe idea is grouping(union) a bunch of sets of indices that can swap with each other and sorting the characters within each set, and finally put them back together.\\n\\n```\\nclass Solution {\\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        int[] p = new int[s.length()];\\n\\t\\t// initialize parent map\\n        for (int i = 0; i < p.length; i++) {\\n            p[i] = i;\\n        }\\n\\t\\t// Union\\n        for (List<Integer> pair : pairs) {\\n            int p1 = find(pair.get(0), p);\\n            int p2 = find(pair.get(1), p);\\n            if (p1 != p2) p[p2] = p1;\\n        }\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n\\t\\t// Group each set of indices can swap together\\n        for (int i = 0; i < p.length; i++) {\\n            int pi = find(i, p);\\n            map.putIfAbsent(pi, new ArrayList<>());\\n            map.get(pi).add(i);\\n        }\\n        char[] chs = new char[s.length()];\\n        for (int key : map.keySet()) {\\n\\t\\t    // List of indices in that group\\n            List<Integer> value = map.get(key);\\n            List<Integer> list = new ArrayList<>(value);\\n\\t\\t\\t// sorting the indices based on character in input string\\n            Collections.sort(list, (o1, o2) -> (s.charAt(o1) - s.charAt(o2)));\\n            for (int i = 0; i < list.size(); i++) {\\n\\t\\t\\t// put value to each index\\n                chs[value.get(i)] = s.charAt(list.get(i));\\n            }\\n        }\\n\\t\\t// return new string\\n        return new String(chs);\\n        \\n    }\\n    \\n    private int find(int i, int[] p) {\\n        while (i != p[i]) {\\n            p[i] = p[p[i]];\\n            i = p[i];\\n        }\\n        return i;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        int[] p = new int[s.length()];\\n\\t\\t// initialize parent map\\n        for (int i = 0; i < p.length; i++) {\\n            p[i] = i;\\n        }\\n\\t\\t// Union\\n        for (List<Integer> pair : pairs) {\\n            int p1 = find(pair.get(0), p);\\n            int p2 = find(pair.get(1), p);\\n            if (p1 != p2) p[p2] = p1;\\n        }\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n\\t\\t// Group each set of indices can swap together\\n        for (int i = 0; i < p.length; i++) {\\n            int pi = find(i, p);\\n            map.putIfAbsent(pi, new ArrayList<>());\\n            map.get(pi).add(i);\\n        }\\n        char[] chs = new char[s.length()];\\n        for (int key : map.keySet()) {\\n\\t\\t    // List of indices in that group\\n            List<Integer> value = map.get(key);\\n            List<Integer> list = new ArrayList<>(value);\\n\\t\\t\\t// sorting the indices based on character in input string\\n            Collections.sort(list, (o1, o2) -> (s.charAt(o1) - s.charAt(o2)));\\n            for (int i = 0; i < list.size(); i++) {\\n\\t\\t\\t// put value to each index\\n                chs[value.get(i)] = s.charAt(list.get(i));\\n            }\\n        }\\n\\t\\t// return new string\\n        return new String(chs);\\n        \\n    }\\n    \\n    private int find(int i, int[] p) {\\n        while (i != p[i]) {\\n            p[i] = p[p[i]];\\n            i = p[i];\\n        }\\n        return i;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1551492,
                "title": "python-unionfind-and-dfs",
                "content": "```\\n# ==== UnionFind ====\\nclass UnionFind:\\n    def __init__(self, size):\\n        self.root = [i for i in range(size)]\\n\\n    def find(self, x):\\n        if self.root[x] != x:\\n            self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n    \\n    def union(self, x, y):\\n        rootX = self.find(x)\\n        rootY = self.find(y)\\n        if rootX != rootY:\\n            self.root[rootY] = rootX\\n        \\nclass Solution(object):\\n    def smallestStringWithSwaps(self, s, pairs):\\n        \"\"\"\\n        :type s: str\\n        :type pairs: List[List[int]]\\n        :rtype: str\\n        \"\"\"\\n        # construct the unionfind graph\\n        uf = UnionFind(len(s))\\n        for x, y in pairs:\\n            uf.union(x, y)\\n        \\n        # a dictionary to store indexes of unique sub graphs\\n        # key is root, value is list of connected nodes\\n        indexes = collections.defaultdict(list)\\n        for i, ind in enumerate(uf.root):\\n            root = uf.find(ind)\\n            indexes[root].append(i)\\n        \\n        result = list(s) \\n        # for each root, sort the connected nodes\\' indexes and chars, then output by pairs\\n        for root in indexes.keys():\\n            sub_index = indexes[root]\\n            sub_alpha = [s[i] for i in sub_index]\\n            sub_index.sort()\\n            sub_alpha.sort()\\n            for i, a in zip(sub_index, sub_alpha):\\n                result[i] = a\\n                \\n        return \\'\\'.join(result)\\n```\\n\\t\\t\\n```\\n# ==== DFS ====\\n# similiar idea as UnionFind, we construct a dict to store the pairs, where key is each node and value is list of connected nodes\\n# then starting from the first node, dfs will traverse and store the list of connected nodes, then place the char into result string with respect of corresponding index. \\n\\nclass Solution(object):\\n    def smallestStringWithSwaps(self, s, pairs):\\n        \"\"\"\\n        :type s: str\\n        :type pairs: List[List[int]]\\n        :rtype: str\\n        \"\"\"\\n        graph = collections.defaultdict(list)\\n        for x, y in pairs:\\n            graph[x].append(y)\\n            graph[y].append(x)\\n        \\n        seen = set()\\n        \\n        def dfs(node, subgraph):\\n            if node not in seen:\\n                seen.add(node)\\n                subgraph.append(node)\\n                for i in graph[node]:\\n                    dfs(i, subgraph)\\n        \\n        # when we loop through each node, we create an empty sub_graph of that node and connected node by calling dfs()\\n        # dfs() will track all seen node to make sure the sub_graph do not have duplicates with other sub_graphs\\n        # then we just need to sort and swap chars in the sub_graphs\\n        res = list(s)\\n        for node in graph.keys():\\n            \\n            if len(seen) == len(res):\\n                return \\'\\'.join(res)\\n            \\n            sub_graph = []\\n            dfs(node, sub_graph)\\n            \\n            if len(sub_graph) != 0:\\n                \\n                sub_graph = sorted(list(set(sub_graph)))\\n                sub_char = sorted([s[i] for i in sub_graph])\\n                \\n\\n                for x, y in zip(sub_graph, sub_char):\\n                    res[x] = y\\n            \\n        return \\'\\'.join(res)\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\n# ==== UnionFind ====\\nclass UnionFind:\\n    def __init__(self, size):\\n        self.root = [i for i in range(size)]\\n\\n    def find(self, x):\\n        if self.root[x] != x:\\n            self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n    \\n    def union(self, x, y):\\n        rootX = self.find(x)\\n        rootY = self.find(y)\\n        if rootX != rootY:\\n            self.root[rootY] = rootX\\n        \\nclass Solution(object):\\n    def smallestStringWithSwaps(self, s, pairs):\\n        \"\"\"\\n        :type s: str\\n        :type pairs: List[List[int]]\\n        :rtype: str\\n        \"\"\"\\n        # construct the unionfind graph\\n        uf = UnionFind(len(s))\\n        for x, y in pairs:\\n            uf.union(x, y)\\n        \\n        # a dictionary to store indexes of unique sub graphs\\n        # key is root, value is list of connected nodes\\n        indexes = collections.defaultdict(list)\\n        for i, ind in enumerate(uf.root):\\n            root = uf.find(ind)\\n            indexes[root].append(i)\\n        \\n        result = list(s) \\n        # for each root, sort the connected nodes\\' indexes and chars, then output by pairs\\n        for root in indexes.keys():\\n            sub_index = indexes[root]\\n            sub_alpha = [s[i] for i in sub_index]\\n            sub_index.sort()\\n            sub_alpha.sort()\\n            for i, a in zip(sub_index, sub_alpha):\\n                result[i] = a\\n                \\n        return \\'\\'.join(result)\\n```\n```\\n# ==== DFS ====\\n# similiar idea as UnionFind, we construct a dict to store the pairs, where key is each node and value is list of connected nodes\\n# then starting from the first node, dfs will traverse and store the list of connected nodes, then place the char into result string with respect of corresponding index. \\n\\nclass Solution(object):\\n    def smallestStringWithSwaps(self, s, pairs):\\n        \"\"\"\\n        :type s: str\\n        :type pairs: List[List[int]]\\n        :rtype: str\\n        \"\"\"\\n        graph = collections.defaultdict(list)\\n        for x, y in pairs:\\n            graph[x].append(y)\\n            graph[y].append(x)\\n        \\n        seen = set()\\n        \\n        def dfs(node, subgraph):\\n            if node not in seen:\\n                seen.add(node)\\n                subgraph.append(node)\\n                for i in graph[node]:\\n                    dfs(i, subgraph)\\n        \\n        # when we loop through each node, we create an empty sub_graph of that node and connected node by calling dfs()\\n        # dfs() will track all seen node to make sure the sub_graph do not have duplicates with other sub_graphs\\n        # then we just need to sort and swap chars in the sub_graphs\\n        res = list(s)\\n        for node in graph.keys():\\n            \\n            if len(seen) == len(res):\\n                return \\'\\'.join(res)\\n            \\n            sub_graph = []\\n            dfs(node, sub_graph)\\n            \\n            if len(sub_graph) != 0:\\n                \\n                sub_graph = sorted(list(set(sub_graph)))\\n                sub_char = sorted([s[i] for i in sub_graph])\\n                \\n\\n                for x, y in zip(sub_graph, sub_char):\\n                    res[x] = y\\n            \\n        return \\'\\'.join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1488511,
                "title": "java-readable-union-find",
                "content": "```\\nclass Solution {\\n    \\n    int rank[];\\n    int root[];\\n    \\n    \\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        if(pairs.size() == 0){ \\n            return s;\\n        }\\n        \\n        rank = new int[s.length()];        \\n        root = new int[s.length()];\\n        \\n        Arrays.fill(rank,1);\\n        \\n        for(int i=0; i< root.length; i++){\\n            root[i] = i;\\n        }\\n        \\n        for(int i=0; i < pairs.size(); i++){\\n            union(pairs.get(i).get(0), pairs.get(i).get(1));   \\n        }\\n        \\n        Map<Integer, PriorityQueue<Character>> map = new HashMap<>();\\n        for (int i = 0; i < s.length(); ++i){\\n            int p = find(i);\\n            map.putIfAbsent(p, new PriorityQueue<>());\\n            map.get(p).offer(s.charAt(i));\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < s.length(); ++i){\\n            int p = find(i);\\n            sb.append(map.get(p).poll());\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public int find(int x){ \\n        if(root[x] == x) return root[x];\\n        else return root[x] = find(root[x]);\\n    }\\n    \\n    public void union(int x, int y){\\n        int rootx = find(x);\\n        int rooty = find(y);\\n        \\n        if(rootx!=rooty){\\n            if(rank[rootx] > rank[rooty]){\\n                root[rootx] = rooty;                \\n            } else if(rank[rootx] < rank[rooty]){ \\n                root[rooty] = rootx;\\n            } else {\\n                root[rootx] = rooty;\\n                rank[rooty]++;\\n            }   \\n        }\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    int rank[];\\n    int root[];\\n    \\n    \\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        if(pairs.size() == 0){ \\n            return s;\\n        }\\n        \\n        rank = new int[s.length()];        \\n        root = new int[s.length()];\\n        \\n        Arrays.fill(rank,1);\\n        \\n        for(int i=0; i< root.length; i++){\\n            root[i] = i;\\n        }\\n        \\n        for(int i=0; i < pairs.size(); i++){\\n            union(pairs.get(i).get(0), pairs.get(i).get(1));   \\n        }\\n        \\n        Map<Integer, PriorityQueue<Character>> map = new HashMap<>();\\n        for (int i = 0; i < s.length(); ++i){\\n            int p = find(i);\\n            map.putIfAbsent(p, new PriorityQueue<>());\\n            map.get(p).offer(s.charAt(i));\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < s.length(); ++i){\\n            int p = find(i);\\n            sb.append(map.get(p).poll());\\n        }\\n        return sb.toString();\\n    }\\n    \\n    public int find(int x){ \\n        if(root[x] == x) return root[x];\\n        else return root[x] = find(root[x]);\\n    }\\n    \\n    public void union(int x, int y){\\n        int rootx = find(x);\\n        int rooty = find(y);\\n        \\n        if(rootx!=rooty){\\n            if(rank[rootx] > rank[rooty]){\\n                root[rootx] = rooty;                \\n            } else if(rank[rootx] < rank[rooty]){ \\n                root[rooty] = rootx;\\n            } else {\\n                root[rootx] = rooty;\\n                rank[rooty]++;\\n            }   \\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1486596,
                "title": "java-compact-solution-using-dsu-and-java-streams",
                "content": "The relationship between indices can be modelled as a graph, where interconnected pairs of indices form components.\\nWe create a priority queue associated with every component in the graph. Then, each character is added to the corresponding priority queue. \\n\\nBy doing this, we can obtain the characters belonging to each component in sorted order.\\n\\n```java\\nclass Solution {\\n    \\n    int[] parent, rank;\\n    int N;\\n    \\n    int find(int x) {\\n        if (parent[x] != x)\\n            parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n    \\n    boolean union(int a, int b) {\\n        int pa = find(a), pb = find(b);\\n        if (pa == pb)\\n            return false;\\n        else {\\n            int ra = rank[pa], rb = rank[pb];\\n            if (ra > rb)\\n                parent[pb] = pa;\\n            else if (rb > ra)\\n                parent[pa] = pb;\\n            else {\\n                parent[pb] = pa;\\n                rank[pa]++;\\n            }\\n            return true;\\n        }\\n    }\\n    \\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        N = s.length();\\n        parent = new int[N];\\n        List<PriorityQueue<Character>> list = new ArrayList<>(N);\\n        StringBuilder buffer = new StringBuilder(N);\\n        rank = new int[N];\\n        \\n        for (int i = 0; i < N; ++i) {\\n            parent[i] = i;\\n            list.add(new PriorityQueue<>());\\n        }\\n        \\n        //Perform union for each pair.\\n        pairs.forEach(pair -> union(pair.get(0), pair.get(1)));\\n        \\n        //Add each character to the priority queue associated with its component.\\n        IntStream.range(0, N).forEach(index -> list.get(find(index)).add(s.charAt(index)));\\n        \\n        //Build the result, by removing chars from the corresponding priority queue.\\n        IntStream.range(0, N).forEachOrdered(index -> buffer.append(list.get(find(index)).remove()));\\n        \\n        return buffer.toString();\\n    }\\n}\\n```\\n\\n**Time Complexity**\\n\\n`O(NlogN)`. Worst-case, all indices are part of the same component. So we will essentially be popping off from the same priority queue.\\n\\n**Space Complexity**\\n\\n`O(N)`.",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```java\\nclass Solution {\\n    \\n    int[] parent, rank;\\n    int N;\\n    \\n    int find(int x) {\\n        if (parent[x] != x)\\n            parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n    \\n    boolean union(int a, int b) {\\n        int pa = find(a), pb = find(b);\\n        if (pa == pb)\\n            return false;\\n        else {\\n            int ra = rank[pa], rb = rank[pb];\\n            if (ra > rb)\\n                parent[pb] = pa;\\n            else if (rb > ra)\\n                parent[pa] = pb;\\n            else {\\n                parent[pb] = pa;\\n                rank[pa]++;\\n            }\\n            return true;\\n        }\\n    }\\n    \\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        N = s.length();\\n        parent = new int[N];\\n        List<PriorityQueue<Character>> list = new ArrayList<>(N);\\n        StringBuilder buffer = new StringBuilder(N);\\n        rank = new int[N];\\n        \\n        for (int i = 0; i < N; ++i) {\\n            parent[i] = i;\\n            list.add(new PriorityQueue<>());\\n        }\\n        \\n        //Perform union for each pair.\\n        pairs.forEach(pair -> union(pair.get(0), pair.get(1)));\\n        \\n        //Add each character to the priority queue associated with its component.\\n        IntStream.range(0, N).forEach(index -> list.get(find(index)).add(s.charAt(index)));\\n        \\n        //Build the result, by removing chars from the corresponding priority queue.\\n        IntStream.range(0, N).forEachOrdered(index -> buffer.append(list.get(find(index)).remove()));\\n        \\n        return buffer.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1434743,
                "title": "c-union-find-explained-solution",
                "content": "So, we are allowed to perform swap operation from the given pair any numbers of time this means that if pairs are : [0, 1] and [1, 2] then we can also interchange 0, 2 by multiple swap. This leads to us Union Find solution. We will union every pair and form groups, the characters in group will be placed at indices of group in non-decreasing form.\\n\\n```\\nclass DSU {\\n    vector<int> root, rank;\\n    public:\\n    DSU(int size) {\\n        root = vector<int>(size);\\n        rank = vector<int>(size, 1);\\n        for(int i = 0;i < size; i++)\\n            root[i] = i;\\n    }\\n    int find(int x) {\\n        if(x == root[x])\\n            return x;\\n        return root[x] = find(root[x]);\\n    }\\n    void unionSet(int x, int y) {\\n        int rootX = find(x);\\n        int rootY = find(y);\\n        if(rootX != rootY) {\\n            if(rank[rootX] > rank[rootY])\\n                root[rootY] = rootX;\\n            else if(rank[rootX] < rank[rootY])\\n                root[rootX] = rootY;\\n            else {\\n                root[rootY] = rootX;\\n                rank[rootX] += 1;\\n            }\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        int n = s.size();\\n        DSU ds(n);\\n        for(auto pair : pairs) {\\n            ds.unionSet(pair[0], pair[1]);\\n        }\\n        vector<vector<int>> sets(n); // for seperating groups\\n        for(int i = 0;i < n; i++) {\\n            int rootI = ds.find(i);\\n            sets[rootI].push_back(i);\\n        }\\n        for(auto set : sets) {\\n            string setStr = \"\";\\n            for(auto itr : set) {\\n                setStr.push_back(s[itr]); //pushing characters of group in string\\n            }\\n            sort(setStr.begin(), setStr.end()); //sorting set characters to get smallest string\\n            int idx = 0;\\n            for(auto itr : set) {\\n                s[itr] = setStr[idx]; //now placing this set characters to orginal string to corresponding indices\\n                idx += 1;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass DSU {\\n    vector<int> root, rank;\\n    public:\\n    DSU(int size) {\\n        root = vector<int>(size);\\n        rank = vector<int>(size, 1);\\n        for(int i = 0;i < size; i++)\\n            root[i] = i;\\n    }\\n    int find(int x) {\\n        if(x == root[x])\\n            return x;\\n        return root[x] = find(root[x]);\\n    }\\n    void unionSet(int x, int y) {\\n        int rootX = find(x);\\n        int rootY = find(y);\\n        if(rootX != rootY) {\\n            if(rank[rootX] > rank[rootY])\\n                root[rootY] = rootX;\\n            else if(rank[rootX] < rank[rootY])\\n                root[rootX] = rootY;\\n            else {\\n                root[rootY] = rootX;\\n                rank[rootX] += 1;\\n            }\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        int n = s.size();\\n        DSU ds(n);\\n        for(auto pair : pairs) {\\n            ds.unionSet(pair[0], pair[1]);\\n        }\\n        vector<vector<int>> sets(n); // for seperating groups\\n        for(int i = 0;i < n; i++) {\\n            int rootI = ds.find(i);\\n            sets[rootI].push_back(i);\\n        }\\n        for(auto set : sets) {\\n            string setStr = \"\";\\n            for(auto itr : set) {\\n                setStr.push_back(s[itr]); //pushing characters of group in string\\n            }\\n            sort(setStr.begin(), setStr.end()); //sorting set characters to get smallest string\\n            int idx = 0;\\n            for(auto itr : set) {\\n                s[itr] = setStr[idx]; //now placing this set characters to orginal string to corresponding indices\\n                idx += 1;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1415522,
                "title": "java-easy-union-find",
                "content": "```\\nclass Solution {\\n    int par[];\\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n       par = new int[s.length()];\\n       for(int i = 0; i < s.length();i++){\\n          par[i] = i;\\n       }\\n      \\n      for(List<Integer> pair : pairs){\\n        //Do union for the given pairs\\n           int x = (pair.get(0)) ;\\n           int y = (pair.get(1)) ;\\n           union(x,y);\\n        \\n      }\\n      Map<Integer,PriorityQueue<Character>> mp = new HashMap<>();\\n      \\n      for(int i = 0; i < s.length(); i++){\\n          int leader = find(i);\\n        //With respect to leader of every character maintain a pq(as we want to make smallest string)\\n          mp.putIfAbsent(leader,new PriorityQueue<>());\\n          mp.get(leader).add(s.charAt(i));\\n      }\\n     \\n      StringBuilder sb = new StringBuilder();\\n      for(int i = 0 ; i < s.length() ; i++){\\n          int leader = find(i);\\n        //Append the lowest character wrt to each char\\'s leader\\n          char c = mp.get(leader).poll();\\n          sb.append(c);\\n      }\\n       \\n        return sb.toString();\\n    }\\n    void union(int x,int y){\\n      int lx = find(x);\\n      int ly = find(y);\\n      \\n      if(lx != ly){\\n        par[lx] = ly;\\n      }\\n    }\\n    int find(int x){\\n        if(par[x] == x){\\n           return x;\\n        }\\n      int temp = find(par[x]);\\n      par[x] = temp;\\n      return temp;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int par[];\\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n       par = new int[s.length()];\\n       for(int i = 0; i < s.length();i++){\\n          par[i] = i;\\n       }\\n      \\n      for(List<Integer> pair : pairs){\\n        //Do union for the given pairs\\n           int x = (pair.get(0)) ;\\n           int y = (pair.get(1)) ;\\n           union(x,y);\\n        \\n      }\\n      Map<Integer,PriorityQueue<Character>> mp = new HashMap<>();\\n      \\n      for(int i = 0; i < s.length(); i++){\\n          int leader = find(i);\\n        //With respect to leader of every character maintain a pq(as we want to make smallest string)\\n          mp.putIfAbsent(leader,new PriorityQueue<>());\\n          mp.get(leader).add(s.charAt(i));\\n      }\\n     \\n      StringBuilder sb = new StringBuilder();\\n      for(int i = 0 ; i < s.length() ; i++){\\n          int leader = find(i);\\n        //Append the lowest character wrt to each char\\'s leader\\n          char c = mp.get(leader).poll();\\n          sb.append(c);\\n      }\\n       \\n        return sb.toString();\\n    }\\n    void union(int x,int y){\\n      int lx = find(x);\\n      int ly = find(y);\\n      \\n      if(lx != ly){\\n        par[lx] = ly;\\n      }\\n    }\\n    int find(int x){\\n        if(par[x] == x){\\n           return x;\\n        }\\n      int temp = find(par[x]);\\n      par[x] = temp;\\n      return temp;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1293203,
                "title": "easy-to-understand-c-solution-using-union-find",
                "content": "\\n\\tclass DSU{\\n\\tpublic:\\n    void init(int n){\\n        for(int i=0;i<n;i++){\\n            parent.push_back(i);\\n            sizes.push_back(1);\\n        }\\n    }\\n    int getParent(int a){\\n        while(a!=parent[a]){\\n            parent[a]=parent[parent[a]];\\n            a=parent[a];\\n        }\\n        return a;\\n    }\\n    void doUnion(int a, int b){\\n        a=getParent(a);\\n        b=getParent(b);\\n        if(a==b)return;\\n        if(sizes[a]<sizes[b]){\\n            parent[a]=b;\\n            sizes[b]+=sizes[a];\\n        }\\n        else{\\n            parent[b]=a;\\n            sizes[a]+=sizes[b];\\n        }\\n    }\\n\\tprivate:\\n\\t\\tvector<int> parent;\\n\\t\\tvector<int> sizes;\\n\\t};\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n\\t\\t\\tDSU dsu;\\n\\t\\t\\tint n=s.size();\\n\\t\\t\\tdsu.init(n);\\n\\t\\t\\tvector<char> m[n];\\n\\t\\t\\tfor(int i=0;i<pairs.size();i++){\\n\\t\\t\\t\\tint a=pairs[i][0];\\n\\t\\t\\t\\tint b=pairs[i][1];\\n\\t\\t\\t\\tdsu.doUnion(a, b);\\n\\t\\t\\t}\\n\\n        for(int i=0;i<n;i++){\\n            int p=dsu.getParent(i);\\n           // cout<<p<<endl;\\n            m[p].push_back(s[i]);\\n        }\\n        for(int i=0;i<n;i++){\\n            if(m[i].size()>0)\\n            sort(m[i].begin(), m[i].end(), greater<char>());\\n        }\\n        for(int i=0;i<s.size();i++){\\n            int p=dsu.getParent(i);\\n            s[i]=m[p].back();\\n            m[p].pop_back();\\n        }\\n        return s;\\n    }\\n};",
                "solutionTags": [
                    "Union Find",
                    "Graph"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n\\t\\t\\tDSU dsu;\\n\\t\\t\\tint n=s.size();\\n\\t\\t\\tdsu.init(n);\\n\\t\\t\\tvector<char> m[n];\\n\\t\\t\\tfor(int i=0;i<pairs.size();i++){\\n\\t\\t\\t\\tint a=pairs[i][0];\\n\\t\\t\\t\\tint b=pairs[i][1];\\n\\t\\t\\t\\tdsu.doUnion(a, b);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1286832,
                "title": "python-union-find-97-runtime-70-memory",
                "content": "```\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        \\n        subsets = list(range(len(s)))\\n        \\n        def find(x):\\n            nonlocal subsets\\n            if x != subsets[x]:\\n                subsets[x] = find(subsets[x])\\n            return subsets[x]\\n        \\n        def union(x,y):\\n            nonlocal subsets\\n            s1 = find(x)\\n            s2 = find(y)\\n            subsets[s2] = s1\\n            \\n        for pair in pairs:\\n            union(pair[0],pair[1])\\n            \\n        components = defaultdict(list)\\n        alphabets = defaultdict(list)\\n        for i,v in enumerate(subsets):\\n\\t\\t\\tparent = find(v)\\n\\t\\t\\tcomponents[parent].append(i)\\n\\t\\t\\talphabets[parent].append(s[i])\\n        \\n# constructing the final output. Notice that the swaps can only affect the indexes in the connected component (subset). \\n        res = [None] * len(s)\\n        \\n        for cid in components.keys():\\n            indexes = components[cid]\\n            indexes.sort()\\n            chars = alphabets[cid]\\n            chars.sort()\\n            for i,j in zip(indexes,chars):\\n                res[i] = j\\n        \\n        return \\'\\'.join(res)\\n```\\n\\nI believe this should be a hard question given the complexity around handling the contents of the subsets after populating the DSU",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        \\n        subsets = list(range(len(s)))\\n        \\n        def find(x):\\n            nonlocal subsets\\n            if x != subsets[x]:\\n                subsets[x] = find(subsets[x])\\n            return subsets[x]\\n        \\n        def union(x,y):\\n            nonlocal subsets\\n            s1 = find(x)\\n            s2 = find(y)\\n            subsets[s2] = s1\\n            \\n        for pair in pairs:\\n            union(pair[0],pair[1])\\n            \\n        components = defaultdict(list)\\n        alphabets = defaultdict(list)\\n        for i,v in enumerate(subsets):\\n\\t\\t\\tparent = find(v)\\n\\t\\t\\tcomponents[parent].append(i)\\n\\t\\t\\talphabets[parent].append(s[i])\\n        \\n# constructing the final output. Notice that the swaps can only affect the indexes in the connected component (subset). \\n        res = [None] * len(s)\\n        \\n        for cid in components.keys():\\n            indexes = components[cid]\\n            indexes.sort()\\n            chars = alphabets[cid]\\n            chars.sort()\\n            for i,j in zip(indexes,chars):\\n                res[i] = j\\n        \\n        return \\'\\'.join(res)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1261505,
                "title": "union-find-by-rank-and-path-compression-using-priority-queue-c",
                "content": "The question states that any number of swaps are possible, and we need to find the lexicographically smallest string. \\nSuppose we have 2 pairs [x,y] and [y,z] -then, we can swap characters between any two positions among x, y and z, i.e., our swap zone is [x, y. z]. In other words, we may think of swap indices as vertices and a pair as an edge between the two vertices. Thus, the problem is simply reduced to a union find problem, where the lowest index in the union gets the least character among the union members. In order to extract the minimum character among the union members, we use a priority queue<char>\\n\\nHere is the code\\n```\\nclass Solution {\\npublic:\\n    vector<int> parent;\\n    vector<int> rank;\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        \\n        int n = s.size();\\n        \\n        for(int i = 0; i < n ; i++){\\n            parent.push_back(i);\\n            rank.push_back(0);\\n        }\\n    \\n        for(auto e : pairs)\\n            uni(e[0] , e[1]);\\n        \\n        \\n        map<int,priority_queue<char, vector<char>,greater<char>>> options;\\n        for(int i = 0 ; i < n; i++){\\n            int x = find(i);\\n            options[x].push(s[i]);\\n        }\\n        \\n        string res = \"\";\\n        int x;\\n        for(int i = 0 ; i < n ; i++){\\n            x = parent[i];\\n            res += options[x].top();\\n            options[x].pop();\\n        }\\n      \\n        return res;\\n    }\\n    int find(int x){\\n        if(parent[x]!=x)\\n            parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n    \\n    void uni(int x, int y){\\n        x = find(x), y = find(y);\\n        if(x != y)\\n        {\\n            if(rank[x]>= rank[y])\\n            {\\n            parent[y] = x;\\n            rank[x] += 1 + rank[y];\\n            }\\n           else{\\n           parent[x] = y;\\n            rank[y] += 1 + rank[x];\\n           }\\n        }\\n    }\\n        \\n};\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> parent;\\n    vector<int> rank;\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        \\n        int n = s.size();\\n        \\n        for(int i = 0; i < n ; i++){\\n            parent.push_back(i);\\n            rank.push_back(0);\\n        }\\n    \\n        for(auto e : pairs)\\n            uni(e[0] , e[1]);\\n        \\n        \\n        map<int,priority_queue<char, vector<char>,greater<char>>> options;\\n        for(int i = 0 ; i < n; i++){\\n            int x = find(i);\\n            options[x].push(s[i]);\\n        }\\n        \\n        string res = \"\";\\n        int x;\\n        for(int i = 0 ; i < n ; i++){\\n            x = parent[i];\\n            res += options[x].top();\\n            options[x].pop();\\n        }\\n      \\n        return res;\\n    }\\n    int find(int x){\\n        if(parent[x]!=x)\\n            parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n    \\n    void uni(int x, int y){\\n        x = find(x), y = find(y);\\n        if(x != y)\\n        {\\n            if(rank[x]>= rank[y])\\n            {\\n            parent[y] = x;\\n            rank[x] += 1 + rank[y];\\n            }\\n           else{\\n           parent[x] = y;\\n            rank[y] += 1 + rank[x];\\n           }\\n        }\\n    }\\n        \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1227707,
                "title": "c-solution-100-faster-o-n-union-find-o-n-map-counter",
                "content": "Firstly, union-find to build parent[n].\\nThen, count each set of letter [a, z] to root: \"maps[root]->cnt[26]\".\\nFinally, copy \"maps[root]->cnt[26]\" to corresponding root set orderly.\\n\\n```\\ntypedef struct map_ {\\n\\tint idx;\\n\\tint cnt[26];\\n} map_st;\\n\\nint get_root (int *parent, int a) {\\n\\tif (parent[a] != a) parent[a] = get_root(parent, parent[a]);\\n\\treturn parent[a];\\n}\\n\\nvoid union_find (int *parent, int a, int b) {\\n\\tparent[get_root(parent, a)] = get_root(parent, b);\\n}\\n\\nchar * smallestStringWithSwaps (char * s, int** pairs, int pairsSize, int* pairsColSize) {\\n\\tint      i, root, len = strlen(s);\\n\\tint     *parent = calloc(len, sizeof(int));\\n\\tmap_st **maps = calloc(len, sizeof(map_st *));\\n\\n\\tfor (i = 0; i < len; i++) {\\n\\t\\tparent[i] = i;\\n\\t}\\n\\n\\tfor (i = 0; i < pairsSize; i++) {\\n\\t\\tunion_find(parent, pairs[i][0], pairs[i][1]);\\n\\t}\\n\\n\\tfor (i = 0; i < len; i++) {\\n\\t\\troot = get_root(parent, i);\\n\\t\\tif (maps[root] == NULL) {\\n\\t\\t\\tmaps[root] = calloc(1, sizeof(map_st));\\n\\t\\t}\\n\\t\\tmaps[root]->cnt[s[i]-\\'a\\']++;\\n\\t}\\n\\n\\tfor (i = 0; i < len; i++) {\\n\\t\\troot = get_root(parent, i);\\n\\t\\twhile (maps[root]->cnt[maps[root]->idx] == 0) maps[root]->idx++;\\n\\t\\ts[i] = \\'a\\' + maps[root]->idx;\\n\\t\\tmaps[root]->cnt[maps[root]->idx]--;\\n\\t}\\n\\n\\tfor (i = 0; i < len; i++) {\\n\\t\\tif (maps[i]) free(maps[i]);\\n\\t}\\n\\n\\tfree(maps);\\n\\tfree(parent);\\n\\treturn s;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef struct map_ {\\n\\tint idx;\\n\\tint cnt[26];\\n} map_st;\\n\\nint get_root (int *parent, int a) {\\n\\tif (parent[a] != a) parent[a] = get_root(parent, parent[a]);\\n\\treturn parent[a];\\n}\\n\\nvoid union_find (int *parent, int a, int b) {\\n\\tparent[get_root(parent, a)] = get_root(parent, b);\\n}\\n\\nchar * smallestStringWithSwaps (char * s, int** pairs, int pairsSize, int* pairsColSize) {\\n\\tint      i, root, len = strlen(s);\\n\\tint     *parent = calloc(len, sizeof(int));\\n\\tmap_st **maps = calloc(len, sizeof(map_st *));\\n\\n\\tfor (i = 0; i < len; i++) {\\n\\t\\tparent[i] = i;\\n\\t}\\n\\n\\tfor (i = 0; i < pairsSize; i++) {\\n\\t\\tunion_find(parent, pairs[i][0], pairs[i][1]);\\n\\t}\\n\\n\\tfor (i = 0; i < len; i++) {\\n\\t\\troot = get_root(parent, i);\\n\\t\\tif (maps[root] == NULL) {\\n\\t\\t\\tmaps[root] = calloc(1, sizeof(map_st));\\n\\t\\t}\\n\\t\\tmaps[root]->cnt[s[i]-\\'a\\']++;\\n\\t}\\n\\n\\tfor (i = 0; i < len; i++) {\\n\\t\\troot = get_root(parent, i);\\n\\t\\twhile (maps[root]->cnt[maps[root]->idx] == 0) maps[root]->idx++;\\n\\t\\ts[i] = \\'a\\' + maps[root]->idx;\\n\\t\\tmaps[root]->cnt[maps[root]->idx]--;\\n\\t}\\n\\n\\tfor (i = 0; i < len; i++) {\\n\\t\\tif (maps[i]) free(maps[i]);\\n\\t}\\n\\n\\tfree(maps);\\n\\tfree(parent);\\n\\treturn s;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1211742,
                "title": "c-solution-using-disjoint-set",
                "content": "```\\nclass dSet {\\n    vector<int> s;\\n    public:\\n    dSet(int n) {\\n        s.resize(n);\\n        for(int i = 0; i < n; i++) {\\n            s[i] = i;\\n        }\\n    }\\n    int find(int v) {\\n        if(s[v] == v) {\\n            return v;\\n        }\\n        return s[v] = find(s[v]);\\n    }\\n    void Union(int a, int b) {\\n        int x = find(a);\\n        int y = find(b);\\n        if(x != y) {\\n            s[x] = y;\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        int n = s.size();\\n        vector<vector<char>> d(n);\\n        dSet st(n);\\n        for(vector<int>& p : pairs) {\\n            st.Union(p[0], p[1]);\\n        }\\n        for(int i = 0; i < n; i++) {\\n            int pos = st.find(i);\\n            d[pos].push_back(s[i]);\\n        }\\n        for(int i = 0; i < n; i++) {\\n            sort(d[i].rbegin(), d[i].rend());\\n        }\\n        for(int i = 0; i < n; i++) {\\n            int pos = st.find(i);\\n            s[i] = d[pos].back();\\n            d[pos].pop_back();\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass dSet {\\n    vector<int> s;\\n    public:\\n    dSet(int n) {\\n        s.resize(n);\\n        for(int i = 0; i < n; i++) {\\n            s[i] = i;\\n        }\\n    }\\n    int find(int v) {\\n        if(s[v] == v) {\\n            return v;\\n        }\\n        return s[v] = find(s[v]);\\n    }\\n    void Union(int a, int b) {\\n        int x = find(a);\\n        int y = find(b);\\n        if(x != y) {\\n            s[x] = y;\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        int n = s.size();\\n        vector<vector<char>> d(n);\\n        dSet st(n);\\n        for(vector<int>& p : pairs) {\\n            st.Union(p[0], p[1]);\\n        }\\n        for(int i = 0; i < n; i++) {\\n            int pos = st.find(i);\\n            d[pos].push_back(s[i]);\\n        }\\n        for(int i = 0; i < n; i++) {\\n            sort(d[i].rbegin(), d[i].rend());\\n        }\\n        for(int i = 0; i < n; i++) {\\n            int pos = st.find(i);\\n            s[i] = d[pos].back();\\n            d[pos].pop_back();\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 905410,
                "title": "this-should-be-a-hard-problem-dsu-without-path-compression",
                "content": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        if not pairs:\\n            return s\\n\\n        parent = [-1] * len(s)\\n        \\n        def getgroup(node):\\n            if parent[node] == -1:\\n                return node\\n            return getgroup(parent[node])\\n    \\n        def union(a, b):\\n            nonlocal group\\n            ag = getgroup(a)\\n            bg = getgroup(b)\\n            \\n            if ag == bg:\\n                return ag\\n            \\n            if ag < bg:\\n                parent[bg] = ag\\n                group[ag] |= group[bg]\\n                return ag\\n            else:\\n                parent[ag]  = bg\\n                group[bg] |= group[ag]\\n                return bg\\n        \\n        \\n        group = defaultdict(set)\\n        \\n        for i, j in pairs:\\n            g = union(i, j)\\n            group[g].add((s[i], i))\\n            group[g].add((s[j], j))\\n            \\n        \\n        for k, lst in group.items():\\n            group[k] = sorted(lst, reverse=True)\\n            \\n        a = [\\'\\'] * len(s)\\n        for i in range(len(s)):\\n            g = group[getgroup(i)]\\n            a[i] = g.pop()[0] if g else s[i]\\n        \\n        return \\'\\'.join(a)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        if not pairs:\\n            return s\\n\\n        parent = [-1] * len(s)\\n        \\n        def getgroup(node):\\n            if parent[node] == -1:\\n                return node\\n            return getgroup(parent[node])\\n    \\n        def union(a, b):\\n            nonlocal group\\n            ag = getgroup(a)\\n            bg = getgroup(b)\\n            \\n            if ag == bg:\\n                return ag\\n            \\n            if ag < bg:\\n                parent[bg] = ag\\n                group[ag] |= group[bg]\\n                return ag\\n            else:\\n                parent[ag]  = bg\\n                group[bg] |= group[ag]\\n                return bg\\n        \\n        \\n        group = defaultdict(set)\\n        \\n        for i, j in pairs:\\n            g = union(i, j)\\n            group[g].add((s[i], i))\\n            group[g].add((s[j], j))\\n            \\n        \\n        for k, lst in group.items():\\n            group[k] = sorted(lst, reverse=True)\\n            \\n        a = [\\'\\'] * len(s)\\n        for i in range(len(s)):\\n            g = group[getgroup(i)]\\n            a[i] = g.pop()[0] if g else s[i]\\n        \\n        return \\'\\'.join(a)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 837773,
                "title": "java-union-and-find-solution",
                "content": "Here is my java solution\\n```\\nclass Solution {\\n    int find(int node, int[] parent) {\\n        while(parent[node]>=0 && parent[node]!=node)\\n            node=parent[node];\\n        return node;\\n    }\\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        int[] parent=new int[s.length()];\\n        Arrays.fill(parent, -1);\\n        for(int i=0; i<pairs.size(); i++) {\\n            int u=pairs.get(i).get(0);\\n            int v=pairs.get(i).get(1);\\n            u=find(u, parent);\\n            v=find(v, parent);\\n            if(u!=v) {\\n                if(parent[u]>parent[v]) {\\n                    parent[v]+=parent[u];\\n                    parent[u]=v;\\n                }\\n                else{\\n                    parent[u]+=parent[v];\\n                    parent[v]=u;\\n                }\\n            }\\n        }\\n        \\n        Map<Integer, PriorityQueue<Character>> map=new HashMap<Integer, PriorityQueue<Character>>();\\n        for(int i=0; i<parent.length; i++) {\\n            if(parent[i]<0)\\n                map.put(i, new PriorityQueue<Character>());\\n        }\\n        \\n        PriorityQueue<Character> pq;\\n        for(int i=0; i<parent.length; i++) {\\n            int u=find(i, parent);\\n            parent[i]=u;\\n            pq=map.get(u);\\n            pq.offer(s.charAt(i));\\n        }\\n        \\n        StringBuilder st=new StringBuilder();\\n        for(int i=0; i<parent.length; i++) {\\n            int u=parent[i];\\n            pq=map.get(u);\\n            st.append(pq.poll());\\n        }\\n        \\n        return st.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    int find(int node, int[] parent) {\\n        while(parent[node]>=0 && parent[node]!=node)\\n            node=parent[node];\\n        return node;\\n    }\\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        int[] parent=new int[s.length()];\\n        Arrays.fill(parent, -1);\\n        for(int i=0; i<pairs.size(); i++) {\\n            int u=pairs.get(i).get(0);\\n            int v=pairs.get(i).get(1);\\n            u=find(u, parent);\\n            v=find(v, parent);\\n            if(u!=v) {\\n                if(parent[u]>parent[v]) {\\n                    parent[v]+=parent[u];\\n                    parent[u]=v;\\n                }\\n                else{\\n                    parent[u]+=parent[v];\\n                    parent[v]=u;\\n                }\\n            }\\n        }\\n        \\n        Map<Integer, PriorityQueue<Character>> map=new HashMap<Integer, PriorityQueue<Character>>();\\n        for(int i=0; i<parent.length; i++) {\\n            if(parent[i]<0)\\n                map.put(i, new PriorityQueue<Character>());\\n        }\\n        \\n        PriorityQueue<Character> pq;\\n        for(int i=0; i<parent.length; i++) {\\n            int u=find(i, parent);\\n            parent[i]=u;\\n            pq=map.get(u);\\n            pq.offer(s.charAt(i));\\n        }\\n        \\n        StringBuilder st=new StringBuilder();\\n        for(int i=0; i<parent.length; i++) {\\n            int u=parent[i];\\n            pq=map.get(u);\\n            st.append(pq.poll());\\n        }\\n        \\n        return st.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 696693,
                "title": "c-dsu-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int find(int x , vector<int>&parent) // find function\\n    {\\n        if(x == parent[x])\\n            return x;\\n        else\\n            return parent[x] = find(parent[x], parent); // path compression\\n    }\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        int n = s.size(), m = pairs.size();\\n        vector<int>parent(n+1),size(n+1,1);\\n        for(int i = 0 ; i < n ; i++)\\n            parent[i]=i;\\n        \\n        for(int i = 0 ; i < m ; i++) // Traverse all pairs and make components/ groups/ sets.\\n        {\\n            int a = find(pairs[i][0],parent);\\n            int b = find(pairs[i][1],parent);\\n            if(a != b)\\n            {\\n                if(size[a] < size[b]) // Union by size/rank\\n                    swap(a,b);\\n                parent[b] = a;\\n                size[a] += size[b];\\n            }\\n        }\\n        unordered_map<int,vector<int>>mp; // make a map to store all indexes of a root index.\\n        for(int i = 0 ; i < n ; i++)\\n            mp[find(i,parent)].push_back(i);\\n\\t\\t\\t /*\\n\\t\\t\\t Traverse all stored indexes and form a substrings by collecting the characters at the \\n\\t\\t\\t indexes, and since it is mentioned that we can swap the pairs any number of times,\\n\\t\\t\\t thus all characters in a component can be sorted. Thus, sort them and modify the\\n\\t\\t\\t original string.\\n\\t\\t\\t*/\\n\\t\\tfor(auto x : mp)\\n\\t\\t{\\n            string str = \"\"; int j = 0 ;\\n            for(auto i : x.second)\\n                str += s[i];\\n            sort(str.begin(), str.end());\\n            for(auto i : x.second)\\n                s[i] = str[j++];\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(int x , vector<int>&parent) // find function\\n    {\\n        if(x == parent[x])\\n            return x;\\n        else\\n            return parent[x] = find(parent[x], parent); // path compression\\n    }\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        int n = s.size(), m = pairs.size();\\n        vector<int>parent(n+1),size(n+1,1);\\n        for(int i = 0 ; i < n ; i++)\\n            parent[i]=i;\\n        \\n        for(int i = 0 ; i < m ; i++) // Traverse all pairs and make components/ groups/ sets.\\n        {\\n            int a = find(pairs[i][0],parent);\\n            int b = find(pairs[i][1],parent);\\n            if(a != b)\\n            {\\n                if(size[a] < size[b]) // Union by size/rank\\n                    swap(a,b);\\n                parent[b] = a;\\n                size[a] += size[b];\\n            }\\n        }\\n        unordered_map<int,vector<int>>mp; // make a map to store all indexes of a root index.\\n        for(int i = 0 ; i < n ; i++)\\n            mp[find(i,parent)].push_back(i);\\n\\t\\t\\t /*\\n\\t\\t\\t Traverse all stored indexes and form a substrings by collecting the characters at the \\n\\t\\t\\t indexes, and since it is mentioned that we can swap the pairs any number of times,\\n\\t\\t\\t thus all characters in a component can be sorted. Thus, sort them and modify the\\n\\t\\t\\t original string.\\n\\t\\t\\t*/\\n\\t\\tfor(auto x : mp)\\n\\t\\t{\\n            string str = \"\"; int j = 0 ;\\n            for(auto i : x.second)\\n                str += s[i];\\n            sort(str.begin(), str.end());\\n            for(auto i : x.second)\\n                s[i] = str[j++];\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 662967,
                "title": "concise-java-union-find-with-priorityqueue",
                "content": "Same idea as posted on https://leetcode.com/problems/smallest-string-with-swaps/discuss/387524/Short-Python-Union-find-solution-w-Explanation. Just offering an efficient and concise Java implementation.\\n\\n```\\nclass Solution {\\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        int[] parent = new int[s.length()];\\n        for (int i = 0; i < parent.length; i++) parent[i] = i;\\n        \\n        for (List<Integer> p: pairs) {\\n            parent[find(p.get(1), parent)] = find(p.get(0), parent);\\n        }\\n        \\n        Map<Integer, Queue<Character>> map = new HashMap<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            map.computeIfAbsent(find(i, parent), k -> new PriorityQueue<>()).offer(s.charAt(i)); \\n        }\\n        \\n        StringBuilder res = new StringBuilder();\\n        for (int i = 0; i < parent.length; i++) {\\n            res.append(map.get(parent[i]).poll());\\n        }\\n        return res.toString();\\n        \\n    }\\n    \\n    private int find(int i, int[] parent) {\\n        if (parent[i] != i) {\\n            parent[i] = find(parent[i], parent);\\n        }\\n        return parent[i];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        int[] parent = new int[s.length()];\\n        for (int i = 0; i < parent.length; i++) parent[i] = i;\\n        \\n        for (List<Integer> p: pairs) {\\n            parent[find(p.get(1), parent)] = find(p.get(0), parent);\\n        }\\n        \\n        Map<Integer, Queue<Character>> map = new HashMap<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            map.computeIfAbsent(find(i, parent), k -> new PriorityQueue<>()).offer(s.charAt(i)); \\n        }\\n        \\n        StringBuilder res = new StringBuilder();\\n        for (int i = 0; i < parent.length; i++) {\\n            res.append(map.get(parent[i]).poll());\\n        }\\n        return res.toString();\\n        \\n    }\\n    \\n    private int find(int i, int[] parent) {\\n        if (parent[i] != i) {\\n            parent[i] = find(parent[i], parent);\\n        }\\n        return parent[i];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 501557,
                "title": "swift-union-find-o-nlogn",
                "content": "```\\nclass Solution {\\n    func smallestStringWithSwaps(_ s: String, _ pairs: [[Int]]) -> String {\\n        let count = s.count\\n        let s = Array(s)\\n        var dsu = DSU(count)\\n        for i in pairs {\\n            dsu.union(i[0], i[1])\\n        }\\n        var dict = [Int: [Int]]()\\n        for i in 0..<count {\\n            let key = dsu.find(i)\\n            dict[key, default: []].append(i)\\n        }\\n        \\n        var res = s\\n\\n        for (key, value) in dict {\\n            let sortedChar = value.map { s[$0] }.sorted()\\n            for (i, j) in zip(value, sortedChar) {\\n                res[i] = j\\n            }\\n        }\\n\\n        return String(res)\\n    }\\n}\\n\\nstruct DSU {\\n    var parent: [Int]\\n    var rank: [Int]\\n    var size: Int {\\n        return rank.max() ?? 0\\n    }\\n    \\n    init(_ n: Int) {\\n        self.parent = Array(0..<n)\\n        self.rank = Array(repeating: 1, count: n)\\n         parent = [Int](0..<n)\\n         rank = [Int](repeating: 0, count: n)\\n    }\\n    \\n    mutating func find(_ a: Int) -> Int {\\n        if a == parent[a] {\\n            return a\\n        }\\n        parent[a] = find(parent[a])\\n        return parent[a]\\n    }\\n    \\n    mutating func union(_ a: Int, _ b: Int) -> Bool {\\n        var i = find(a)\\n        var j = find(b)\\n        if i != j {\\n            if rank[i] < rank[j] {\\n                var temp = i\\n                i = j\\n                j = temp\\n            }\\n            \\n            parent[j] = parent[i]\\n            rank[j] += rank[i]\\n            rank[i] = rank[j]\\n            return true\\n        }\\n        \\n        return false\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func smallestStringWithSwaps(_ s: String, _ pairs: [[Int]]) -> String {\\n        let count = s.count\\n        let s = Array(s)\\n        var dsu = DSU(count)\\n        for i in pairs {\\n            dsu.union(i[0], i[1])\\n        }\\n        var dict = [Int: [Int]]()\\n        for i in 0..<count {\\n            let key = dsu.find(i)\\n            dict[key, default: []].append(i)\\n        }\\n        \\n        var res = s\\n\\n        for (key, value) in dict {\\n            let sortedChar = value.map { s[$0] }.sorted()\\n            for (i, j) in zip(value, sortedChar) {\\n                res[i] = j\\n            }\\n        }\\n\\n        return String(res)\\n    }\\n}\\n\\nstruct DSU {\\n    var parent: [Int]\\n    var rank: [Int]\\n    var size: Int {\\n        return rank.max() ?? 0\\n    }\\n    \\n    init(_ n: Int) {\\n        self.parent = Array(0..<n)\\n        self.rank = Array(repeating: 1, count: n)\\n         parent = [Int](0..<n)\\n         rank = [Int](repeating: 0, count: n)\\n    }\\n    \\n    mutating func find(_ a: Int) -> Int {\\n        if a == parent[a] {\\n            return a\\n        }\\n        parent[a] = find(parent[a])\\n        return parent[a]\\n    }\\n    \\n    mutating func union(_ a: Int, _ b: Int) -> Bool {\\n        var i = find(a)\\n        var j = find(b)\\n        if i != j {\\n            if rank[i] < rank[j] {\\n                var temp = i\\n                i = j\\n                j = temp\\n            }\\n            \\n            parent[j] = parent[i]\\n            rank[j] += rank[i]\\n            rank[i] = rank[j]\\n            return true\\n        }\\n        \\n        return false\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 458504,
                "title": "simple-java-solution-unionfind-priorityqueue",
                "content": "```\\nclass Solution {\\n    private int[] parent;\\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        int n = s.length();\\n        parent = new int[n];\\n        \\n        for(int i = 0; i < n; i++) parent[i] = i;\\n        \\n        for(List<Integer> p : pairs) uf(p.get(0), p.get(1));\\n        \\n        Map<Integer, PriorityQueue<Character>> map = new HashMap<>();\\n        for(int i = 0; i < s.length(); i++) {\\n            int root = find(i);\\n            map.putIfAbsent(root, new PriorityQueue<Character>());\\n            map.get(root).offer(s.charAt(i));\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < n; i++) {\\n            sb.append(map.get(find(i)).poll());\\n        }\\n        return sb.toString();\\n    }\\n    \\n    private int find(int a) {\\n        return parent[a] = parent[a] == a ? a : find(parent[a]);\\n    }\\n    \\n    private void uf(int a, int b) {\\n        int pa = find(a);\\n        int pb = find(b);\\n        if(pa != pb) {\\n            parent[pa] = pb;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int[] parent;\\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        int n = s.length();\\n        parent = new int[n];\\n        \\n        for(int i = 0; i < n; i++) parent[i] = i;\\n        \\n        for(List<Integer> p : pairs) uf(p.get(0), p.get(1));\\n        \\n        Map<Integer, PriorityQueue<Character>> map = new HashMap<>();\\n        for(int i = 0; i < s.length(); i++) {\\n            int root = find(i);\\n            map.putIfAbsent(root, new PriorityQueue<Character>());\\n            map.get(root).offer(s.charAt(i));\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < n; i++) {\\n            sb.append(map.get(find(i)).poll());\\n        }\\n        return sb.toString();\\n    }\\n    \\n    private int find(int a) {\\n        return parent[a] = parent[a] == a ? a : find(parent[a]);\\n    }\\n    \\n    private void uf(int a, int b) {\\n        int pa = find(a);\\n        int pb = find(b);\\n        if(pa != pb) {\\n            parent[pa] = pb;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 387529,
                "title": "python-union-find-solution",
                "content": "```\\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        n = len(s)\\n        memo = [i for i in range(n)]\\n        \\n        def find(x):\\n            if x != memo[x]:\\n                memo[x] = find(memo[x])\\n            return memo[x]\\n        \\n        def union(x,y):\\n            rx, ry = find(x), find(y)\\n            if rx != ry:\\n                memo[rx] = ry\\n                \\n        for i,j in pairs:\\n            union(i,j)\\n        \\n        group = collections.defaultdict(list)\\n        for i in range(n):\\n            group[find(i)] += s[i],\\n        \\n        for j in group.values():\\n            j.sort()\\n            \\n        si = collections.Counter()\\n        ans = [\"\" for _ in range(n)]\\n        for i in range(n):\\n            ans[i] = group[find(i)][si[find(i)]]\\n            si[find(i)] += 1\\n        return \"\".join(ans)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        n = len(s)\\n        memo = [i for i in range(n)]\\n        \\n        def find(x):\\n            if x != memo[x]:\\n                memo[x] = find(memo[x])\\n            return memo[x]\\n        \\n        def union(x,y):\\n            rx, ry = find(x), find(y)\\n            if rx != ry:\\n                memo[rx] = ry\\n                \\n        for i,j in pairs:\\n            union(i,j)\\n        \\n        group = collections.defaultdict(list)\\n        for i in range(n):\\n            group[find(i)] += s[i],\\n        \\n        for j in group.values():\\n            j.sort()\\n            \\n        si = collections.Counter()\\n        ans = [\"\" for _ in range(n)]\\n        for i in range(n):\\n            ans[i] = group[find(i)][si[find(i)]]\\n            si[find(i)] += 1\\n        return \"\".join(ans)",
                "codeTag": "Java"
            },
            {
                "id": 3372239,
                "title": "ez-soluion-dsu",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nusing ll = long long;\\nclass DSU{\\n    public:\\n    vector<int> rank;\\n    vector<int> parent;\\n    int n;\\n    DSU(int n){\\n        this->n=n;\\n        rank=vector<int>(n,1);\\n        parent=vector<int>(n,0);\\n        iota(parent.begin(),parent.end(),0);\\n        \\n    }\\n    ll find(ll a){\\n        if(parent[a]==a) return a;\\n        else return parent[a]=find(parent[a]);\\n    }\\n    void unionF(ll a , ll b ){\\n        ll pa = find(a);\\n        ll pb = find(b);\\n        if(pa==pb) return ;\\n        if(rank[pa]>rank[pb]){\\n            swap(pa,pb);\\n        }\\n        parent[pa]=pb;\\n        if (rank[pa] == rank[pb])\\n            rank[pb]++;\\n \\xA0\\xA0\\xA0}\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\n\\n};\\nclass Solution {\\npublic:\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& p) {\\n        DSU ds(s.size());\\n        for(auto i:p){\\n            ds.unionF(i[0],i[1]);\\n        }\\n        // priority_queue<char, vector<char>, greater<char> >\\n        map<int,priority_queue<char, vector<char>, greater<char>>> pq;\\n        for(int i=0;i<s.size();i++){\\n            pq[ds.find(i)].push(s[i]);\\n            // cout<<ds.find(i)<<\"->\"<<s[i]<<\"  \";\\n        }\\n        // cout<<endl;\\n\\n\\n        for(int i=0;i<s.size();i++){\\n            int par=ds.find(i);\\n            s[i]=pq[par].top();\\n            // cout<<pq[par].top()<<\"->\"<<par<<\"  \"<<i<<\"  \";\\n            pq[par].pop();\\n        }\\n        return s;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nusing ll = long long;\\nclass DSU{\\n    public:\\n    vector<int> rank;\\n    vector<int> parent;\\n    int n;\\n    DSU(int n){\\n        this->n=n;\\n        rank=vector<int>(n,1);\\n        parent=vector<int>(n,0);\\n        iota(parent.begin(),parent.end(),0);\\n        \\n    }\\n    ll find(ll a){\\n        if(parent[a]==a) return a;\\n        else return parent[a]=find(parent[a]);\\n    }\\n    void unionF(ll a , ll b ){\\n        ll pa = find(a);\\n        ll pb = find(b);\\n        if(pa==pb) return ;\\n        if(rank[pa]>rank[pb]){\\n            swap(pa,pb);\\n        }\\n        parent[pa]=pb;\\n        if (rank[pa] == rank[pb])\\n            rank[pb]++;\\n \\xA0\\xA0\\xA0}\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\n\\n};\\nclass Solution {\\npublic:\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& p) {\\n        DSU ds(s.size());\\n        for(auto i:p){\\n            ds.unionF(i[0],i[1]);\\n        }\\n        // priority_queue<char, vector<char>, greater<char> >\\n        map<int,priority_queue<char, vector<char>, greater<char>>> pq;\\n        for(int i=0;i<s.size();i++){\\n            pq[ds.find(i)].push(s[i]);\\n            // cout<<ds.find(i)<<\"->\"<<s[i]<<\"  \";\\n        }\\n        // cout<<endl;\\n\\n\\n        for(int i=0;i<s.size();i++){\\n            int par=ds.find(i);\\n            s[i]=pq[par].top();\\n            // cout<<pq[par].top()<<\"->\"<<par<<\"  \"<<i<<\"  \";\\n            pq[par].pop();\\n        }\\n        return s;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3372237,
                "title": "simple-approach-c-dsu-multiset",
                "content": "\\n```\\nusing ll = long long;\\nclass DSU{\\n    public:\\n    vector<int> rank;\\n    vector<int> parent;\\n    int n;\\n    DSU(int n){\\n        this->n=n;\\n        rank=vector<int>(n,1);\\n        parent=vector<int>(n,0);\\n        iota(parent.begin(),parent.end(),0);\\n        \\n    }\\n    ll find(ll a){\\n        if(parent[a]==a) return a;\\n        else return parent[a]=find(parent[a]);\\n    }\\n    void unionF(ll a , ll b ){\\n        ll pa = find(a);\\n        ll pb = find(b);\\n        if(pa==pb) return ;\\n        if(rank[pa]>rank[pb]){\\n            swap(pa,pb);\\n        }\\n        parent[pa]=pb;\\n        if (rank[pa] == rank[pb])\\n            rank[pb]++;\\n    }\\n       \\n\\n};\\nclass Solution {\\npublic:\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n       DSU ds(s.size());\\n       for(auto it:pairs){\\n           ds.unionF(it[0],it[1]);\\n       }\\n       map<int,multiset<char>> mp;\\n       for(int i=0;i<s.size();i++){\\n           mp[ds.find(i)].insert(s[i]);\\n       }\\n       for(int i=0;i<s.size();i++){\\n           auto it=mp[ds.find(i)].begin();\\n           s[i]=*it;\\n            // cout<<*it<<\"  \";\\n           mp[ds.find(i)].erase(it);\\n           \\n       }\\n       return s;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nusing ll = long long;\\nclass DSU{\\n    public:\\n    vector<int> rank;\\n    vector<int> parent;\\n    int n;\\n    DSU(int n){\\n        this->n=n;\\n        rank=vector<int>(n,1);\\n        parent=vector<int>(n,0);\\n        iota(parent.begin(),parent.end(),0);\\n        \\n    }\\n    ll find(ll a){\\n        if(parent[a]==a) return a;\\n        else return parent[a]=find(parent[a]);\\n    }\\n    void unionF(ll a , ll b ){\\n        ll pa = find(a);\\n        ll pb = find(b);\\n        if(pa==pb) return ;\\n        if(rank[pa]>rank[pb]){\\n            swap(pa,pb);\\n        }\\n        parent[pa]=pb;\\n        if (rank[pa] == rank[pb])\\n            rank[pb]++;\\n    }\\n       \\n\\n};\\nclass Solution {\\npublic:\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n       DSU ds(s.size());\\n       for(auto it:pairs){\\n           ds.unionF(it[0],it[1]);\\n       }\\n       map<int,multiset<char>> mp;\\n       for(int i=0;i<s.size();i++){\\n           mp[ds.find(i)].insert(s[i]);\\n       }\\n       for(int i=0;i<s.size();i++){\\n           auto it=mp[ds.find(i)].begin();\\n           s[i]=*it;\\n            // cout<<*it<<\"  \";\\n           mp[ds.find(i)].erase(it);\\n           \\n       }\\n       return s;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3062811,
                "title": "concise-go-disjoint-set-solution",
                "content": "\\n\\n# Code\\n```\\nfunc smallestStringWithSwaps(s string, pairs [][]int) string {\\n  \\n  roots := make([]int, len(s))\\n  for i := range roots {\\n    roots[i] = i\\n  }\\n  \\n  var find func(x int) int\\n  find = func(x int) int {\\n    if x == roots[x] {\\n      return x\\n    }\\n    roots[x] = find(roots[x])\\n    return roots[x]\\n  }\\n  \\n  union := func(x, y int) {\\n    roots[find(x)] = find(y)\\n  }\\n  \\n  for _, pair := range pairs {\\n    union(pair[0], pair[1])\\n  }\\n  \\n  m := make(map[int][]byte)\\n  for i := range s {\\n    m[find(i)] = append(m[find(i)], s[i])\\n  }\\n  \\n  for _, v := range m {\\n    sort.Slice(v, func(i, j int) bool {\\n      return v[i] < v[j]\\n    })\\n  }\\n  \\n  sb := strings.Builder{}\\n  for i := range s {\\n    v := m[find(i)]\\n    sb.WriteByte(v[0])\\n    m[find(i)] = v[1:]\\n  }\\n  \\n  return sb.String()\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Union Find"
                ],
                "code": "```\\nfunc smallestStringWithSwaps(s string, pairs [][]int) string {\\n  \\n  roots := make([]int, len(s))\\n  for i := range roots {\\n    roots[i] = i\\n  }\\n  \\n  var find func(x int) int\\n  find = func(x int) int {\\n    if x == roots[x] {\\n      return x\\n    }\\n    roots[x] = find(roots[x])\\n    return roots[x]\\n  }\\n  \\n  union := func(x, y int) {\\n    roots[find(x)] = find(y)\\n  }\\n  \\n  for _, pair := range pairs {\\n    union(pair[0], pair[1])\\n  }\\n  \\n  m := make(map[int][]byte)\\n  for i := range s {\\n    m[find(i)] = append(m[find(i)], s[i])\\n  }\\n  \\n  for _, v := range m {\\n    sort.Slice(v, func(i, j int) bool {\\n      return v[i] < v[j]\\n    })\\n  }\\n  \\n  sb := strings.Builder{}\\n  for i := range s {\\n    v := m[find(i)]\\n    sb.WriteByte(v[0])\\n    m[find(i)] = v[1:]\\n  }\\n  \\n  return sb.String()\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2747088,
                "title": "union-find-python",
                "content": "```\\nclass DSU:\\n    def __init__(self, N):\\n        self.parent = [i for i in range(N)]\\n        self.size = [1 for _ in range(N)]\\n        self.components = N\\n        \\n    def find(self, x):\\n        if x != self.parent[x]:\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n    \\n    def union(self, a, b):\\n        ua = self.find(a)\\n        ub = self.find(b)\\n        if ua == ub:\\n            return False\\n        \\n        if self.size[ua] < self.size[ub]:\\n            ua, ub = ub, ua\\n        self.parent[ub] = ua\\n        self.size[ua] += self.size[ub]\\n        self.size[ub] = self.size[ua]\\n        self.components -= 1        \\n        return True\\n\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        N = len(s)\\n        uf = DSU(N)\\n        for u, v in pairs:\\n            uf.union(u, v)\\n            \\n        lookup = defaultdict(SortedList)\\n        for i, node in enumerate(uf.parent):\\n            lookup[uf.find(node)].add(s[i])\\n        \\n        ans = []\\n        for i in range(N):\\n            ans.append(lookup[uf.find(i)].pop(0))\\n        return \\'\\'.join(ans)\\n    # Time: O((M + N) * \\u03B1(N) + N * log(N)) where M is the length of pairs and N the length of s\\n    # Space: O(N)\\n```",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nclass DSU:\\n    def __init__(self, N):\\n        self.parent = [i for i in range(N)]\\n        self.size = [1 for _ in range(N)]\\n        self.components = N\\n        \\n    def find(self, x):\\n        if x != self.parent[x]:\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n    \\n    def union(self, a, b):\\n        ua = self.find(a)\\n        ub = self.find(b)\\n        if ua == ub:\\n            return False\\n        \\n        if self.size[ua] < self.size[ub]:\\n            ua, ub = ub, ua\\n        self.parent[ub] = ua\\n        self.size[ua] += self.size[ub]\\n        self.size[ub] = self.size[ua]\\n        self.components -= 1        \\n        return True\\n\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        N = len(s)\\n        uf = DSU(N)\\n        for u, v in pairs:\\n            uf.union(u, v)\\n            \\n        lookup = defaultdict(SortedList)\\n        for i, node in enumerate(uf.parent):\\n            lookup[uf.find(node)].add(s[i])\\n        \\n        ans = []\\n        for i in range(N):\\n            ans.append(lookup[uf.find(i)].pop(0))\\n        return \\'\\'.join(ans)\\n    # Time: O((M + N) * \\u03B1(N) + N * log(N)) where M is the length of pairs and N the length of s\\n    # Space: O(N)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2710529,
                "title": "python-concise-union-find-solution-easily-understandable",
                "content": "```\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        n = len(s)\\n        parent = [x for x in range(n)]\\n        \\n        def find(x):\\n            if x == parent[x]: return x\\n            parent[x] = find(parent[x])\\n            return parent[x]\\n        \\n        def union(a,b):\\n            x, y = find(a), find(b)\\n            if x == y: return\\n            else: parent[y] = x\\n        \\n        for a,b in pairs:\\n            union(a,b)\\n            \\n        groups = defaultdict(list)\\n        for i in range(n):\\n            groups[find(i)].append(s[i])\\n        \\n        for key in groups.keys():\\n            groups[key] = deque(sorted(groups[key]))\\n        \\n        ans = \"\"\\n        for i in range(n):\\n            g = find(i)\\n            char = groups[g].popleft()\\n            ans += char\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        n = len(s)\\n        parent = [x for x in range(n)]\\n        \\n        def find(x):\\n            if x == parent[x]: return x\\n            parent[x] = find(parent[x])\\n            return parent[x]\\n        \\n        def union(a,b):\\n            x, y = find(a), find(b)\\n            if x == y: return\\n            else: parent[y] = x\\n        \\n        for a,b in pairs:\\n            union(a,b)\\n            \\n        groups = defaultdict(list)\\n        for i in range(n):\\n            groups[find(i)].append(s[i])\\n        \\n        for key in groups.keys():\\n            groups[key] = deque(sorted(groups[key]))\\n        \\n        ans = \"\"\\n        for i in range(n):\\n            g = find(i)\\n            char = groups[g].popleft()\\n            ans += char\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2609230,
                "title": "98-space-beats-c-union-find-simple-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    void makeset(int &v,vector<int> &p,vector<int> &s){\\n        p[v] = v;\\n        s[v] = 1;\\n    }\\n    int find1(int &v,vector<int> &p){\\n        if(p[v] == v)return v;\\n        return p[v] = find1(p[v],p);\\n    }\\n    void union1(int &u,int &v,vector<int> &p,vector<int> &s){\\n        int a = find1(u,p);\\n        int b = find1(v,p);\\n        if(a!=b){\\n            if(s[a]<s[b])\\n                swap(a,b);\\n            p[b] = a;\\n            s[a] += s[b];\\n            // cout<<u<<\" \"<<p[a]<<\" \"<<s[a]<<endl;;\\n            // cout<<v<<\" \"<<p[b]<<\" \"<<s[b]<<endl;;\\n        }\\n    }\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        int n = s.length(),i;\\n        vector<int> p(n);\\n        vector<int> sz(n);\\n        for(i = 0; i < n; i++){\\n            makeset(i,p,sz);\\n        }\\n        for(auto &i: pairs){\\n            union1(i[0],i[1],p,sz);\\n        }\\n        for(auto &i: p){\\n            i = find1(i,p);\\n        }\\n        // for(auto &i: p)cout<<i<<\" \";\\n        // cout<<endl;\\n        unordered_map<int,vector<char>> mp;\\n        for(i = 0; i < n; i++){\\n            mp[p[i]].push_back(s[i]);\\n        }\\n        for(auto &i: mp){\\n            sort(i.second.begin(),i.second.end());\\n            // cout<<i.first<<\" \";\\n            // for(auto &j: i.second){\\n            //     cout<<j<<\" \";\\n            // }cout<<endl;\\n            }\\n        for(i = 0; i < n; i++){\\n            s[i] = *mp[p[i]].begin();\\n            mp[p[i]].erase(mp[p[i]].begin());\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void makeset(int &v,vector<int> &p,vector<int> &s){\\n        p[v] = v;\\n        s[v] = 1;\\n    }\\n    int find1(int &v,vector<int> &p){\\n        if(p[v] == v)return v;\\n        return p[v] = find1(p[v],p);\\n    }\\n    void union1(int &u,int &v,vector<int> &p,vector<int> &s){\\n        int a = find1(u,p);\\n        int b = find1(v,p);\\n        if(a!=b){\\n            if(s[a]<s[b])\\n                swap(a,b);\\n            p[b] = a;\\n            s[a] += s[b];\\n            // cout<<u<<\" \"<<p[a]<<\" \"<<s[a]<<endl;;\\n            // cout<<v<<\" \"<<p[b]<<\" \"<<s[b]<<endl;;\\n        }\\n    }\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        int n = s.length(),i;\\n        vector<int> p(n);\\n        vector<int> sz(n);\\n        for(i = 0; i < n; i++){\\n            makeset(i,p,sz);\\n        }\\n        for(auto &i: pairs){\\n            union1(i[0],i[1],p,sz);\\n        }\\n        for(auto &i: p){\\n            i = find1(i,p);\\n        }\\n        // for(auto &i: p)cout<<i<<\" \";\\n        // cout<<endl;\\n        unordered_map<int,vector<char>> mp;\\n        for(i = 0; i < n; i++){\\n            mp[p[i]].push_back(s[i]);\\n        }\\n        for(auto &i: mp){\\n            sort(i.second.begin(),i.second.end());\\n            // cout<<i.first<<\" \";\\n            // for(auto &j: i.second){\\n            //     cout<<j<<\" \";\\n            // }cout<<endl;\\n            }\\n        for(i = 0; i < n; i++){\\n            s[i] = *mp[p[i]].begin();\\n            mp[p[i]].erase(mp[p[i]].begin());\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2606086,
                "title": "go-golang-unionfind",
                "content": "```\\nfunc smallestStringWithSwaps(s string, pairs [][]int) string {\\n\\n\\tuf := NewUnionFind(len(s))\\n\\tfor _, pair := range pairs {\\n\\t\\tuf.Union(pair[0], pair[1])\\n\\t}\\n\\n\\tgroups := make(map[int][]byte)\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tgroups[uf.Find(i)] = append(groups[uf.Find(i)], s[i])\\n\\t}\\n\\n\\tfor _, group := range groups {\\n\\t\\tsort.Slice(group, func(i, j int) bool {\\n\\t\\t\\treturn group[i] < group[j]\\n\\t\\t})\\n\\t}\\n\\n\\tans := make([]byte, len(s))\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tans[i] = groups[uf.Find(i)][0]\\n\\t\\tgroups[uf.Find(i)] = groups[uf.Find(i)][1:]\\n\\t}\\n\\treturn string(ans)\\n}\\n\\ntype UnionFind struct {\\n\\tparent []int\\n\\tcount  int\\n}\\n\\nfunc NewUnionFind(n int) *UnionFind {\\n\\tparent := make([]int, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tparent[i] = i\\n\\t}\\n\\treturn &UnionFind{parent, n}\\n}\\n\\nfunc (uf *UnionFind) Find(x int) int {\\n\\tif uf.parent[x] != x {\\n\\t\\tuf.parent[x] = uf.Find(uf.parent[x])\\n\\t}\\n\\treturn uf.parent[x]\\n}\\n\\nfunc (uf *UnionFind) Union(x, y int) {\\n\\trootX, rootY := uf.Find(x), uf.Find(y)\\n\\tif rootX == rootY {\\n\\t\\treturn\\n\\t}\\n\\tuf.parent[rootX] = rootY\\n\\tuf.count--\\n}\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nfunc smallestStringWithSwaps(s string, pairs [][]int) string {\\n\\n\\tuf := NewUnionFind(len(s))\\n\\tfor _, pair := range pairs {\\n\\t\\tuf.Union(pair[0], pair[1])\\n\\t}\\n\\n\\tgroups := make(map[int][]byte)\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tgroups[uf.Find(i)] = append(groups[uf.Find(i)], s[i])\\n\\t}\\n\\n\\tfor _, group := range groups {\\n\\t\\tsort.Slice(group, func(i, j int) bool {\\n\\t\\t\\treturn group[i] < group[j]\\n\\t\\t})\\n\\t}\\n\\n\\tans := make([]byte, len(s))\\n\\tfor i := 0; i < len(s); i++ {\\n\\t\\tans[i] = groups[uf.Find(i)][0]\\n\\t\\tgroups[uf.Find(i)] = groups[uf.Find(i)][1:]\\n\\t}\\n\\treturn string(ans)\\n}\\n\\ntype UnionFind struct {\\n\\tparent []int\\n\\tcount  int\\n}\\n\\nfunc NewUnionFind(n int) *UnionFind {\\n\\tparent := make([]int, n)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tparent[i] = i\\n\\t}\\n\\treturn &UnionFind{parent, n}\\n}\\n\\nfunc (uf *UnionFind) Find(x int) int {\\n\\tif uf.parent[x] != x {\\n\\t\\tuf.parent[x] = uf.Find(uf.parent[x])\\n\\t}\\n\\treturn uf.parent[x]\\n}\\n\\nfunc (uf *UnionFind) Union(x, y int) {\\n\\trootX, rootY := uf.Find(x), uf.Find(y)\\n\\tif rootX == rootY {\\n\\t\\treturn\\n\\t}\\n\\tuf.parent[rootX] = rootY\\n\\tuf.count--\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2518345,
                "title": "union-by-rank-max-heap",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>parent;\\n    vector<int>ranks;\\n    void uni(int a,int b){\\n        int first=find(a);\\n        int sec=find(b);\\n      //  cout<<first<<\" \"<<sec<<endl;\\n        if(first==sec){\\n            return;\\n        }\\n        if(ranks[first]<ranks[sec]){\\n            parent[first]=sec;\\n        }\\n        else if(ranks[first]>ranks[sec]){\\n            parent[sec]=first;\\n        }\\n        else if(ranks[first]==ranks[sec]){\\n            ranks[first]++;\\n            parent[sec]=first;\\n        }\\n        return;\\n    }\\n    int find(int x){\\n        if(parent[x]==-1){\\n            return x;\\n        }\\n        return find(parent[x]);\\n    }\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        parent.resize(100002,-1);\\n        ranks.resize(100002,0);\\n        for(int i=0;i<pairs.size();i++){\\n            uni(pairs[i][0],pairs[i][1]);\\n        }\\n          unordered_map<int,priority_queue <char>>mp;\\n        for(int i=0;i<s.length();i++){\\n           int x=find(i);\\n         //   cout<<x<<endl;\\n            mp[x].push(s[i]);\\n        }\\n        for(int i=s.length()-1;i>=0;i--){\\n            int x=find(i);\\n            s[i]=mp[x].top();\\n            mp[x].pop();\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>parent;\\n    vector<int>ranks;\\n    void uni(int a,int b){\\n        int first=find(a);\\n        int sec=find(b);\\n      //  cout<<first<<\" \"<<sec<<endl;\\n        if(first==sec){\\n            return;\\n        }\\n        if(ranks[first]<ranks[sec]){\\n            parent[first]=sec;\\n        }\\n        else if(ranks[first]>ranks[sec]){\\n            parent[sec]=first;\\n        }\\n        else if(ranks[first]==ranks[sec]){\\n            ranks[first]++;\\n            parent[sec]=first;\\n        }\\n        return;\\n    }\\n    int find(int x){\\n        if(parent[x]==-1){\\n            return x;\\n        }\\n        return find(parent[x]);\\n    }\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        parent.resize(100002,-1);\\n        ranks.resize(100002,0);\\n        for(int i=0;i<pairs.size();i++){\\n            uni(pairs[i][0],pairs[i][1]);\\n        }\\n          unordered_map<int,priority_queue <char>>mp;\\n        for(int i=0;i<s.length();i++){\\n           int x=find(i);\\n         //   cout<<x<<endl;\\n            mp[x].push(s[i]);\\n        }\\n        for(int i=s.length()-1;i>=0;i--){\\n            int x=find(i);\\n            s[i]=mp[x].top();\\n            mp[x].pop();\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2508840,
                "title": "java-dfs-union-find",
                "content": "Approach1 : DFS\\n\\n1. Get Characters and indices of connected components\\n2. Sort both chars and indices\\n3. Add sorted chars in result at sorted indices\\n```\\nclass Solution {\\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        int n = s.length();\\n        List<Integer>[] adjList = new ArrayList[n];\\n        for (List<Integer> edge : pairs) {\\n            if (adjList[edge.get(0)] == null) adjList[edge.get(0)] = new ArrayList<>();\\n            if (adjList[edge.get(1)] == null) adjList[edge.get(1)] = new ArrayList<>();\\n            adjList[edge.get(0)].add(edge.get(1));\\n            adjList[edge.get(1)].add(edge.get(0));\\n        }\\n\\n        char[] result = new char[n];\\n        boolean[] visited = new boolean[n];\\n        for (int v = 0; v < n; v++) {\\n            List<Character> chars = new ArrayList<>();\\n            List<Integer> indices = new ArrayList<>();\\n\\n            // Apply DFS to get chars and indices of component\\n            dfs(v, adjList, s, chars, indices, visited);\\n\\n            Collections.sort(chars);\\n            Collections.sort(indices);\\n            for (int i = 0; i < chars.size(); i++)\\n                result[indices.get(i)] = chars.get(i);\\n        }\\n        return new String(result);\\n    }\\n\\n    private void dfs(int v, List<Integer>[] adjList, String s, List<Character> chars, List<Integer> indices, boolean[] visited) {\\n        if (visited[v]) return;\\n        visited[v] = true;\\n        chars.add(s.charAt(v));\\n        indices.add(v);\\n        if (adjList[v] != null) {\\n            for (int neighbour : adjList[v])\\n                dfs(neighbour, adjList, s, chars, indices, visited);\\n        }\\n    }\\n}\\n```\\n\\n#\\nApproach2 : Union Find\\n```\\nclass Solution {\\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        int n = s.length();\\n        UnionFind uf = new UnionFind(n);\\n        for (List<Integer> edge : pairs)\\n            uf.union(edge.get(0), edge.get(1));\\n\\n        Map<Integer, List<Integer>> rootToChildernMap = new HashMap<>();\\n        for (int v = 0; v < n; v++) {\\n            int root = uf.find(v);\\n            rootToChildernMap.putIfAbsent(root, new ArrayList<>());\\n            rootToChildernMap.get(root).add(v);\\n        }\\n\\n        char[] result = new char[n];\\n        for (List<Integer> indices : rootToChildernMap.values()) {\\n            List<Character> chars = new ArrayList<>();\\n            for (int idx : indices) chars.add(s.charAt(idx));\\n            Collections.sort(chars);\\n            for (int i = 0; i < chars.size(); i++)\\n                result[indices.get(i)] = chars.get(i);\\n        }\\n        return new String(result);\\n    }\\n\\n    static class UnionFind {\\n        int[] parent, rank;\\n\\n        public UnionFind(int size) {\\n            parent = new int[size];\\n            rank = new int[size];\\n            for (int i = 0; i < size; i++) parent[i] = i;\\n        }\\n\\n        private int find(int x) {\\n            if (parent[x] != x) parent[x] = find(parent[x]);\\n            return parent[x];\\n        }\\n\\n        public boolean union(int a, int b) {\\n            int p1 = find(a), p2 = find(b);\\n            if (p1 == p2) return false;\\n            if (rank[p1] > rank[p2]) parent[p2] = p1;\\n            else if (rank[p2] > rank[p1]) parent[p1] = p2;\\n            else {\\n                parent[p2] = p1;\\n                rank[p1]++;\\n            }\\n            return true;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        int n = s.length();\\n        List<Integer>[] adjList = new ArrayList[n];\\n        for (List<Integer> edge : pairs) {\\n            if (adjList[edge.get(0)] == null) adjList[edge.get(0)] = new ArrayList<>();\\n            if (adjList[edge.get(1)] == null) adjList[edge.get(1)] = new ArrayList<>();\\n            adjList[edge.get(0)].add(edge.get(1));\\n            adjList[edge.get(1)].add(edge.get(0));\\n        }\\n\\n        char[] result = new char[n];\\n        boolean[] visited = new boolean[n];\\n        for (int v = 0; v < n; v++) {\\n            List<Character> chars = new ArrayList<>();\\n            List<Integer> indices = new ArrayList<>();\\n\\n            // Apply DFS to get chars and indices of component\\n            dfs(v, adjList, s, chars, indices, visited);\\n\\n            Collections.sort(chars);\\n            Collections.sort(indices);\\n            for (int i = 0; i < chars.size(); i++)\\n                result[indices.get(i)] = chars.get(i);\\n        }\\n        return new String(result);\\n    }\\n\\n    private void dfs(int v, List<Integer>[] adjList, String s, List<Character> chars, List<Integer> indices, boolean[] visited) {\\n        if (visited[v]) return;\\n        visited[v] = true;\\n        chars.add(s.charAt(v));\\n        indices.add(v);\\n        if (adjList[v] != null) {\\n            for (int neighbour : adjList[v])\\n                dfs(neighbour, adjList, s, chars, indices, visited);\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        int n = s.length();\\n        UnionFind uf = new UnionFind(n);\\n        for (List<Integer> edge : pairs)\\n            uf.union(edge.get(0), edge.get(1));\\n\\n        Map<Integer, List<Integer>> rootToChildernMap = new HashMap<>();\\n        for (int v = 0; v < n; v++) {\\n            int root = uf.find(v);\\n            rootToChildernMap.putIfAbsent(root, new ArrayList<>());\\n            rootToChildernMap.get(root).add(v);\\n        }\\n\\n        char[] result = new char[n];\\n        for (List<Integer> indices : rootToChildernMap.values()) {\\n            List<Character> chars = new ArrayList<>();\\n            for (int idx : indices) chars.add(s.charAt(idx));\\n            Collections.sort(chars);\\n            for (int i = 0; i < chars.size(); i++)\\n                result[indices.get(i)] = chars.get(i);\\n        }\\n        return new String(result);\\n    }\\n\\n    static class UnionFind {\\n        int[] parent, rank;\\n\\n        public UnionFind(int size) {\\n            parent = new int[size];\\n            rank = new int[size];\\n            for (int i = 0; i < size; i++) parent[i] = i;\\n        }\\n\\n        private int find(int x) {\\n            if (parent[x] != x) parent[x] = find(parent[x]);\\n            return parent[x];\\n        }\\n\\n        public boolean union(int a, int b) {\\n            int p1 = find(a), p2 = find(b);\\n            if (p1 == p2) return false;\\n            if (rank[p1] > rank[p2]) parent[p2] = p1;\\n            else if (rank[p2] > rank[p1]) parent[p1] = p2;\\n            else {\\n                parent[p2] = p1;\\n                rank[p1]++;\\n            }\\n            return true;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2429152,
                "title": "c-union-find-clean-solution",
                "content": "```\\nclass UnionFind {\\npublic:\\n    vector<int> parent;\\n    vector<int> rank;\\n    \\n    UnionFind(int n){\\n        parent = vector<int>(n);\\n        rank = vector<int>(n);\\n        \\n        for(int i=0; i<n; i++){\\n            parent[i] = i; // parent of each node will be itself initially\\n            rank[i] = 0; // rank will be 0 for all nodes initially\\n        }\\n    }\\n    \\n    // finds the parent of given node u\\n    int Find(int u) {\\n        if(u == parent[u]){\\n            return u;\\n        }\\n        return u = Find(parent[u]);\\n    }\\n    \\n    // merges two sets into one, u and v belong to the corresponding sets\\n    void Union(int u, int v) {\\n        // find the parents of u and v\\n        u = Find(u);\\n        v = Find(v);\\n        \\n        // if u and v does not belong to the same set\\n        if(u != v){\\n            if(rank[u] < rank[v]){\\n                swap(u, v);\\n            }\\n            \\n            // attach lower rank tree to higher rank tree\\n            parent[v] = u;\\n            \\n            if(rank[u] == rank[v]){\\n                rank[u]++;\\n            }\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        // create an UnionFind data structure with size same as size of the string\\n        UnionFind UF = UnionFind(s.size());\\n        \\n        // iterate over the pairs and create the connected components\\n        for(vector<int>& it : pairs) {\\n            UF.Union(it[0], it[1]);\\n        }\\n        \\n        // retrieve the individual components from the UnionFind data structure\\n        unordered_map<int,vector<pair<int,char>>> components;\\n        \\n        for(int i=0; i<s.size(); i++){\\n            components[UF.Find(i)].push_back({i,s[i]});\\n        }\\n        \\n        // string of size s.size() for holding the result\\n        string result = string(s.size(), \\'x\\');\\n        \\n        // sort the characters present in each component\\n        for(pair<int,vector<pair<int,char>>> it : components){\\n            vector<pair<int,char>> component = it.second;\\n            \\n            vector<int> inds;\\n            vector<char> chars;\\n            \\n            for(pair<int,char> it : component){\\n                inds.push_back(it.first);\\n                chars.push_back(it.second);\\n            }\\n            \\n            // sort the characters in ascending order\\n            sort(chars.begin(), chars.end());\\n                \\n            // assign the characters to the corresponding indices after sorting\\n            for(int i=0; i<inds.size(); i++){\\n                result[inds[i]] = chars[i];\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Hash Table",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass UnionFind {\\npublic:\\n    vector<int> parent;\\n    vector<int> rank;\\n    \\n    UnionFind(int n){\\n        parent = vector<int>(n);\\n        rank = vector<int>(n);\\n        \\n        for(int i=0; i<n; i++){\\n            parent[i] = i; // parent of each node will be itself initially\\n            rank[i] = 0; // rank will be 0 for all nodes initially\\n        }\\n    }\\n    \\n    // finds the parent of given node u\\n    int Find(int u) {\\n        if(u == parent[u]){\\n            return u;\\n        }\\n        return u = Find(parent[u]);\\n    }\\n    \\n    // merges two sets into one, u and v belong to the corresponding sets\\n    void Union(int u, int v) {\\n        // find the parents of u and v\\n        u = Find(u);\\n        v = Find(v);\\n        \\n        // if u and v does not belong to the same set\\n        if(u != v){\\n            if(rank[u] < rank[v]){\\n                swap(u, v);\\n            }\\n            \\n            // attach lower rank tree to higher rank tree\\n            parent[v] = u;\\n            \\n            if(rank[u] == rank[v]){\\n                rank[u]++;\\n            }\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        // create an UnionFind data structure with size same as size of the string\\n        UnionFind UF = UnionFind(s.size());\\n        \\n        // iterate over the pairs and create the connected components\\n        for(vector<int>& it : pairs) {\\n            UF.Union(it[0], it[1]);\\n        }\\n        \\n        // retrieve the individual components from the UnionFind data structure\\n        unordered_map<int,vector<pair<int,char>>> components;\\n        \\n        for(int i=0; i<s.size(); i++){\\n            components[UF.Find(i)].push_back({i,s[i]});\\n        }\\n        \\n        // string of size s.size() for holding the result\\n        string result = string(s.size(), \\'x\\');\\n        \\n        // sort the characters present in each component\\n        for(pair<int,vector<pair<int,char>>> it : components){\\n            vector<pair<int,char>> component = it.second;\\n            \\n            vector<int> inds;\\n            vector<char> chars;\\n            \\n            for(pair<int,char> it : component){\\n                inds.push_back(it.first);\\n                chars.push_back(it.second);\\n            }\\n            \\n            // sort the characters in ascending order\\n            sort(chars.begin(), chars.end());\\n                \\n            // assign the characters to the corresponding indices after sorting\\n            for(int i=0; i<inds.size(); i++){\\n                result[inds[i]] = chars[i];\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2378166,
                "title": "python-union-find-easy",
                "content": "```\\ndef smallestStringWithSwaps(self, s: str, pairs) -> str:\\n        def find(node,parent):\\n            if parent[node]==node:\\n                return node\\n            temp=find(parent[node],parent)\\n            parent[node]=temp\\n            return temp\\n        def union(x,y):\\n            px=find(x,parent)\\n            py=find(y,parent)\\n            if px!=py:\\n                if rank[px]>rank[py]:\\n                    parent[py]=px\\n                    rank[px]+=1\\n                elif rank[py]>rank[px]:\\n                    parent[px]=py\\n                    rank[py]+=1\\n                else:\\n                    parent[px]=py\\n                    rank[py]+=1\\n                \\n        parent=[0]*len(s)\\n        rank=[0]*len(s)\\n        for i in range(len(s)):\\n            parent[i]=i\\n            rank[i]=1\\n            \\n        for i,j in pairs:\\n            union(i,j)\\n            \\n        d=defaultdict(list)   \\n        for i in range(len(s)):\\n            p_idx=find(i,parent)\\n            d[p_idx].append(s[i])\\n        # print(d)\\n        for i in range(len(s)):\\n            d[i].sort()\\n        # print(d)\\n        ans=[0]*len(s)\\n        for i in range(len(s)):\\n            p_idx=find(i,parent)\\n            ans[i]=d[p_idx].pop(0)\\n        # print(ans)\\n        return \"\".join(ans)\\n```",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\ndef smallestStringWithSwaps(self, s: str, pairs) -> str:\\n        def find(node,parent):\\n            if parent[node]==node:\\n                return node\\n            temp=find(parent[node],parent)\\n            parent[node]=temp\\n            return temp\\n        def union(x,y):\\n            px=find(x,parent)\\n            py=find(y,parent)\\n            if px!=py:\\n                if rank[px]>rank[py]:\\n                    parent[py]=px\\n                    rank[px]+=1\\n                elif rank[py]>rank[px]:\\n                    parent[px]=py\\n                    rank[py]+=1\\n                else:\\n                    parent[px]=py\\n                    rank[py]+=1\\n                \\n        parent=[0]*len(s)\\n        rank=[0]*len(s)\\n        for i in range(len(s)):\\n            parent[i]=i\\n            rank[i]=1\\n            \\n        for i,j in pairs:\\n            union(i,j)\\n            \\n        d=defaultdict(list)   \\n        for i in range(len(s)):\\n            p_idx=find(i,parent)\\n            d[p_idx].append(s[i])\\n        # print(d)\\n        for i in range(len(s)):\\n            d[i].sort()\\n        # print(d)\\n        ans=[0]*len(s)\\n        for i in range(len(s)):\\n            p_idx=find(i,parent)\\n            ans[i]=d[p_idx].pop(0)\\n        # print(ans)\\n        return \"\".join(ans)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2308250,
                "title": "python-dfs-graph-based-sol-explained-easy",
                "content": "# EXPLANATION\\nThe idea is very simple : \\nfind connected components in the string and sort the components \\nseperately\\n\\nWe find the components using pairs \\n\\nSay index = [1 ,3 , 5 , 7]  are a component\\nso  we sort the values  ( s[1] , s[3] ,s[5] , s[7] ) and put them at 1,3,5,7 index respectively\\n# CODE\\n\\n```\\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        n = len(s)\\n        visited = [False]*n\\n        canGo = defaultdict(list)\\n        mainList = []\\n        \\n        for i,j in pairs:\\n            canGo[i].append(j)\\n            canGo[j].append(i)\\n        \\n        def dfs(node,path):\\n            visited[node] = True\\n            path.append(node)\\n            for adj in canGo[node]:\\n                if visited[adj] == False:\\n                    dfs(adj,path)\\n        \\n        for i in range(n):\\n            if visited[i] == True: continue\\n            path = []\\n            dfs(i,path)\\n            mainList.append(path)\\n\\n        for lst in mainList:\\n            lst.sort()\\n            tmp = [s[i] for i in lst]\\n            tmp.sort()\\n            for i in range(len(lst)):\\n                s = s[:lst[i]]  + tmp[i] + s[lst[i]+1:]\\n        return s\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        n = len(s)\\n        visited = [False]*n\\n        canGo = defaultdict(list)\\n        mainList = []\\n        \\n        for i,j in pairs:\\n            canGo[i].append(j)\\n            canGo[j].append(i)\\n        \\n        def dfs(node,path):\\n            visited[node] = True\\n            path.append(node)\\n            for adj in canGo[node]:\\n                if visited[adj] == False:\\n                    dfs(adj,path)\\n        \\n        for i in range(n):\\n            if visited[i] == True: continue\\n            path = []\\n            dfs(i,path)\\n            mainList.append(path)\\n\\n        for lst in mainList:\\n            lst.sort()\\n            tmp = [s[i] for i in lst]\\n            tmp.sort()\\n            for i in range(len(lst)):\\n                s = s[:lst[i]]  + tmp[i] + s[lst[i]+1:]\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2272687,
                "title": "c-easy-solution-dfs",
                "content": "```\\nclass Solution {\\nprivate:\\n\\tvector<int> adj[100001];\\n\\tbool vis[100001];\\n\\tvoid dfs(int vertex, vector<int> &indices, string &chars, string &s) {\\n\\t\\tvis[vertex] = true;\\n\\t\\tindices.push_back(vertex);\\n\\t\\tchars+=s[vertex];\\n\\t\\tfor (auto &e : adj[vertex]) {\\n\\t\\t\\tif (!vis[e]) dfs(e, indices, chars, s);\\n\\t\\t}\\n\\t}\\npublic:\\n\\tstring smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n\\t\\tint n = s.size();\\n\\t\\tfor (auto &e : pairs) {\\n\\t\\t\\tadj[e[0]].push_back(e[1]);\\n\\t\\t\\tadj[e[1]].push_back(e[0]);\\n\\t\\t}\\n\\t\\tvector <int> indices;\\n\\t\\tstring chars;\\n\\t\\tfor (int i = 0; i < n; ++i) {\\n\\t\\t\\tif (!vis[i]) {\\n\\t\\t\\t\\tchars = \"\";\\n\\t\\t\\t\\tindices.clear();\\n\\t\\t\\t\\tdfs(i, indices, chars, s);\\n\\t\\t\\t\\tsort(indices.begin(), indices.end());\\n\\t\\t\\t\\tsort(chars.begin(), chars.end());\\n\\t\\t\\t\\tfor (int i = 0; i < indices.size(); ++i) {\\n\\t\\t\\t\\t\\ts[indices[i]] = chars[i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn s;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n\\tvector<int> adj[100001];\\n\\tbool vis[100001];\\n\\tvoid dfs(int vertex, vector<int> &indices, string &chars, string &s) {\\n\\t\\tvis[vertex] = true;\\n\\t\\tindices.push_back(vertex);\\n\\t\\tchars+=s[vertex];\\n\\t\\tfor (auto &e : adj[vertex]) {\\n\\t\\t\\tif (!vis[e]) dfs(e, indices, chars, s);\\n\\t\\t}\\n\\t}\\npublic:\\n\\tstring smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n\\t\\tint n = s.size();\\n\\t\\tfor (auto &e : pairs) {\\n\\t\\t\\tadj[e[0]].push_back(e[1]);\\n\\t\\t\\tadj[e[1]].push_back(e[0]);\\n\\t\\t}\\n\\t\\tvector <int> indices;\\n\\t\\tstring chars;\\n\\t\\tfor (int i = 0; i < n; ++i) {\\n\\t\\t\\tif (!vis[i]) {\\n\\t\\t\\t\\tchars = \"\";\\n\\t\\t\\t\\tindices.clear();\\n\\t\\t\\t\\tdfs(i, indices, chars, s);\\n\\t\\t\\t\\tsort(indices.begin(), indices.end());\\n\\t\\t\\t\\tsort(chars.begin(), chars.end());\\n\\t\\t\\t\\tfor (int i = 0; i < indices.size(); ++i) {\\n\\t\\t\\t\\t\\ts[indices[i]] = chars[i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn s;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2267876,
                "title": "c-union-find",
                "content": "```\\nclass Solution {\\npublic:\\n    int find(int i, vector<int>& parent){\\n        if(parent[i]==-1 || parent[i]==i){\\n            return parent[i] = i;\\n        }\\n        return parent[i] = find(parent[i],parent);\\n    }\\n    \\n    void unionn(int i, int j, vector<int>& parent, vector<int>& rank){\\n        int x = find(i,parent);\\n        int y = find(j,parent);\\n        if(x == y) return;\\n        if(rank[x] > rank[y]){\\n            parent[y] = x; \\n        }else if(rank[x] < rank[y]){\\n            parent[x] = y;\\n        }else{\\n            parent[x] = y;\\n            rank[y]++;\\n        }\\n    }\\n    \\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        int n = s.size();\\n        vector<int> parent(n,-1);\\n        vector<int> rank(n,1);\\n        for(auto it:pairs){\\n            int u = it[0];\\n            int v = it[1];\\n            unionn(u,v,parent,rank);\\n        }\\n        for(int i=0; i<n; i++){\\n            find(i,parent);\\n        }\\n\\n        unordered_map<int,vector<int>> mp;\\n        for(int i=0; i<n; i++){\\n            mp[parent[i]].push_back(i);\\n        }\\n        string res = s;\\n        for(auto it:mp){\\n            vector<int> v = it.second;\\n            vector<char> ds;\\n            for(auto x:v){\\n                ds.push_back(s[x]);\\n            }\\n            sort(ds.begin(),ds.end());\\n            for(int i=0; i<v.size(); i++){\\n                res[v[i]] = ds[i];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(int i, vector<int>& parent){\\n        if(parent[i]==-1 || parent[i]==i){\\n            return parent[i] = i;\\n        }\\n        return parent[i] = find(parent[i],parent);\\n    }\\n    \\n    void unionn(int i, int j, vector<int>& parent, vector<int>& rank){\\n        int x = find(i,parent);\\n        int y = find(j,parent);\\n        if(x == y) return;\\n        if(rank[x] > rank[y]){\\n            parent[y] = x; \\n        }else if(rank[x] < rank[y]){\\n            parent[x] = y;\\n        }else{\\n            parent[x] = y;\\n            rank[y]++;\\n        }\\n    }\\n    \\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        int n = s.size();\\n        vector<int> parent(n,-1);\\n        vector<int> rank(n,1);\\n        for(auto it:pairs){\\n            int u = it[0];\\n            int v = it[1];\\n            unionn(u,v,parent,rank);\\n        }\\n        for(int i=0; i<n; i++){\\n            find(i,parent);\\n        }\\n\\n        unordered_map<int,vector<int>> mp;\\n        for(int i=0; i<n; i++){\\n            mp[parent[i]].push_back(i);\\n        }\\n        string res = s;\\n        for(auto it:mp){\\n            vector<int> v = it.second;\\n            vector<char> ds;\\n            for(auto x:v){\\n                ds.push_back(s[x]);\\n            }\\n            sort(ds.begin(),ds.end());\\n            for(int i=0; i<v.size(); i++){\\n                res[v[i]] = ds[i];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2229327,
                "title": "c-priority-queue-union-find-dfs-bfs-three-methods",
                "content": "**UF Constructor: O(N) || Uninon Set: O(E * \\\\alpha(N)) || Construct Unordered Set Priority Queue: O(N * \\\\alpha(N)) || Get Min Char: O(NlgN)**\\n\\n```\\nclass UnionFind {\\npublic:\\n    UnionFind(int sz) : root(sz), rank(sz) {\\n        for (int i = 0; i < sz; i++) {\\n            root[i] = i;\\n            rank[i] = 1;\\n        }\\n    }\\n\\n    int find(int x) {\\n        if (x == root[x]) {\\n            return x;\\n        }\\n        return root[x] = find(root[x]);\\n    }\\n\\n    void unionSet(int x, int y) {\\n        int rootX = find(x);\\n        int rootY = find(y);\\n        if (rootX != rootY) {\\n            if (rank[rootX] > rank[rootY]) {\\n                root[rootY] = rootX;\\n            } else if (rank[rootX] < rank[rootY]) {\\n                root[rootX] = rootY;\\n            } else {\\n                root[rootY] = rootX;\\n                rank[rootX] += 1;\\n            }\\n        }\\n    }\\n\\n    bool connected(int x, int y) {\\n        return find(x) == find(y);\\n    }\\n\\nprivate:\\n    vector<int> root;\\n    vector<int> rank;\\n};\\n\\nclass Solution {\\npublic:\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        UnionFind uf(s.size());\\n        for(auto& it: pairs) uf.unionSet(it[0], it[1]);\\n        unordered_map<int, priority_queue<int, vector<int>, greater<int>>> check;\\n        for(int i = 0; i < s.size(); ++ i){\\n            check[uf.find(i)].push(s[i]);\\n        }\\n        \\n        string ans = \"\";\\n        for(int i = 0; i < s.size(); ++ i){\\n            ans += check[uf.find(i)].top();\\n            check[uf.find(i)].pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**DFS + PQ**\\n```\\npublic:\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        store = s;\\n        vector<bool> col(s.size(), false);\\n        vector<vector<int>> adj(s.size(), vector<int>());\\n        for(auto& it: pairs){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        \\n        for(int i = 0; i < s.size(); ++ i){\\n            if(!col[i]){\\n                dfs(adj, col, i);\\n                while(!check_index.empty()){\\n                    s[check_index.top()] = check_char.top();\\n                    check_index.pop();\\n                    check_char.pop();\\n                }\\n            }\\n           \\n        }\\n        \\n        return s;\\n    }\\n    \\n    void dfs(vector<vector<int>>& adj, vector<bool>& col, int curr){\\n        col[curr] = true;\\n        check_index.push(curr);\\n        check_char.push(store[curr]);\\n        \\n        for(auto& it: adj[curr]){\\n            if(!col[it]){\\n                dfs(adj, col, it);\\n            }\\n        }\\n        \\n    }\\n    \\n    priority_queue<int, vector<int>, greater<int>> check_index;\\n    priority_queue<char, vector<char>, greater<char>> check_char;\\n    string store = \"\";\\n```\\n\\n**BFS**\\n```\\nclass Solution {\\npublic:\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        store = s;\\n        vector<bool> col(s.size(), false);\\n        vector<vector<int>> adj(s.size(), vector<int>());\\n        for(auto& it: pairs){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        \\n        for(int i = 0; i < s.size(); ++ i){\\n            if(!col[i]){\\n                col[i] = true;\\n                check_index.push(i);\\n                check_char.push(store[i]);\\n                bfs(adj, col, i);\\n                \\n                while(!check_index.empty()){\\n                    s[check_index.top()] = check_char.top();\\n                    check_index.pop();\\n                    check_char.pop();\\n                }\\n            }\\n           \\n        }\\n        \\n        return s;\\n    }\\n    \\n    void bfs(vector<vector<int>>& adj, vector<bool>& col, int curr){\\n        queue<int> q;\\n        q.push(curr);\\n        \\n        while(!q.empty()){\\n            int start = q.front();\\n            q.pop();\\n            \\n            for(auto& it: adj[start]){\\n                if(!col[it]){\\n                    col[it] = true;\\n                    check_index.push(it);\\n                    check_char.push(store[it]);\\n                    q.push(it);\\n                }\\n            } \\n        }\\n    }\\n    \\n    priority_queue<int, vector<int>, greater<int>> check_index;\\n    priority_queue<char, vector<char>, greater<char>> check_char;\\n    string store = \"\";\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Union Find",
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass UnionFind {\\npublic:\\n    UnionFind(int sz) : root(sz), rank(sz) {\\n        for (int i = 0; i < sz; i++) {\\n            root[i] = i;\\n            rank[i] = 1;\\n        }\\n    }\\n\\n    int find(int x) {\\n        if (x == root[x]) {\\n            return x;\\n        }\\n        return root[x] = find(root[x]);\\n    }\\n\\n    void unionSet(int x, int y) {\\n        int rootX = find(x);\\n        int rootY = find(y);\\n        if (rootX != rootY) {\\n            if (rank[rootX] > rank[rootY]) {\\n                root[rootY] = rootX;\\n            } else if (rank[rootX] < rank[rootY]) {\\n                root[rootX] = rootY;\\n            } else {\\n                root[rootY] = rootX;\\n                rank[rootX] += 1;\\n            }\\n        }\\n    }\\n\\n    bool connected(int x, int y) {\\n        return find(x) == find(y);\\n    }\\n\\nprivate:\\n    vector<int> root;\\n    vector<int> rank;\\n};\\n\\nclass Solution {\\npublic:\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        UnionFind uf(s.size());\\n        for(auto& it: pairs) uf.unionSet(it[0], it[1]);\\n        unordered_map<int, priority_queue<int, vector<int>, greater<int>>> check;\\n        for(int i = 0; i < s.size(); ++ i){\\n            check[uf.find(i)].push(s[i]);\\n        }\\n        \\n        string ans = \"\";\\n        for(int i = 0; i < s.size(); ++ i){\\n            ans += check[uf.find(i)].top();\\n            check[uf.find(i)].pop();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\npublic:\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        store = s;\\n        vector<bool> col(s.size(), false);\\n        vector<vector<int>> adj(s.size(), vector<int>());\\n        for(auto& it: pairs){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        \\n        for(int i = 0; i < s.size(); ++ i){\\n            if(!col[i]){\\n                dfs(adj, col, i);\\n                while(!check_index.empty()){\\n                    s[check_index.top()] = check_char.top();\\n                    check_index.pop();\\n                    check_char.pop();\\n                }\\n            }\\n           \\n        }\\n        \\n        return s;\\n    }\\n    \\n    void dfs(vector<vector<int>>& adj, vector<bool>& col, int curr){\\n        col[curr] = true;\\n        check_index.push(curr);\\n        check_char.push(store[curr]);\\n        \\n        for(auto& it: adj[curr]){\\n            if(!col[it]){\\n                dfs(adj, col, it);\\n            }\\n        }\\n        \\n    }\\n    \\n    priority_queue<int, vector<int>, greater<int>> check_index;\\n    priority_queue<char, vector<char>, greater<char>> check_char;\\n    string store = \"\";\\n```\n```\\nclass Solution {\\npublic:\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        store = s;\\n        vector<bool> col(s.size(), false);\\n        vector<vector<int>> adj(s.size(), vector<int>());\\n        for(auto& it: pairs){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        \\n        for(int i = 0; i < s.size(); ++ i){\\n            if(!col[i]){\\n                col[i] = true;\\n                check_index.push(i);\\n                check_char.push(store[i]);\\n                bfs(adj, col, i);\\n                \\n                while(!check_index.empty()){\\n                    s[check_index.top()] = check_char.top();\\n                    check_index.pop();\\n                    check_char.pop();\\n                }\\n            }\\n           \\n        }\\n        \\n        return s;\\n    }\\n    \\n    void bfs(vector<vector<int>>& adj, vector<bool>& col, int curr){\\n        queue<int> q;\\n        q.push(curr);\\n        \\n        while(!q.empty()){\\n            int start = q.front();\\n            q.pop();\\n            \\n            for(auto& it: adj[start]){\\n                if(!col[it]){\\n                    col[it] = true;\\n                    check_index.push(it);\\n                    check_char.push(store[it]);\\n                    q.push(it);\\n                }\\n            } \\n        }\\n    }\\n    \\n    priority_queue<int, vector<int>, greater<int>> check_index;\\n    priority_queue<char, vector<char>, greater<char>> check_char;\\n    string store = \"\";\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2143648,
                "title": "c-disjoint-set-union-find",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> parent;\\n    vector<vector<int>> adj;\\n    int find(int node) {\\n        if(parent[node] < 0) {\\n            return node;\\n        }\\n        return parent[node] = find(parent[node]);\\n    }\\n    void join(int u, int v) {\\n        int pu = find(u), pv = find(v);\\n        if(pv != pu) {\\n            parent[pu] = pv;\\n        }\\n    }\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        int n = s.length();\\n        parent.resize(n, -1);\\n        adj.resize(n);\\n        for(auto p: pairs) {\\n            int u = p[0], v = p[1];\\n            join(u, v);\\n        }\\n        for(int i=0; i<n; i++) {\\n            adj[find(i)].push_back(i);\\n        }\\n        for(auto nei: adj) {\\n            string t = \"\";\\n            for(auto idx: nei) {\\n                t += s[idx];\\n            }\\n            sort(begin(t), end(t));\\n            for(int i=0; i<nei.size(); i++) {\\n                s[nei[i]] = t[i];\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> parent;\\n    vector<vector<int>> adj;\\n    int find(int node) {\\n        if(parent[node] < 0) {\\n            return node;\\n        }\\n        return parent[node] = find(parent[node]);\\n    }\\n    void join(int u, int v) {\\n        int pu = find(u), pv = find(v);\\n        if(pv != pu) {\\n            parent[pu] = pv;\\n        }\\n    }\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        int n = s.length();\\n        parent.resize(n, -1);\\n        adj.resize(n);\\n        for(auto p: pairs) {\\n            int u = p[0], v = p[1];\\n            join(u, v);\\n        }\\n        for(int i=0; i<n; i++) {\\n            adj[find(i)].push_back(i);\\n        }\\n        for(auto nei: adj) {\\n            string t = \"\";\\n            for(auto idx: nei) {\\n                t += s[idx];\\n            }\\n            sort(begin(t), end(t));\\n            for(int i=0; i<nei.size(); i++) {\\n                s[nei[i]] = t[i];\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2118285,
                "title": "python-not-the-fastest-solution-but-easy-to-understand-bfs",
                "content": "```\\nfrom queue import Queue\\nclass Solution:\\n    \"\"\"\\n    approach: \\n    we can tackle this problem using bfs based approach\\n    The idea is to createa directed graph first and then get all the connected \\n    components.\\n    \"\"\"\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        # create a graph first of all\\n        hash_map = {}\\n        graph_map = {i: set() for i in range(len(s))}\\n        for pair in pairs:\\n            graph_map[pair[1]].add(pair[0])\\n            graph_map[pair[0]].add(pair[1])\\n        \\n        def bfs(index):\\n            res = []\\n            while not queue.empty():\\n                idx = queue.get()\\n                res.append(idx)\\n                for pos in graph_map[idx]:\\n                    if pos not in visited:\\n                        queue.put(pos)\\n                        visited.add(pos)\\n            res.sort()\\n            return res\\n                \\n        queue = Queue()\\n        visited = set()\\n        for i in range(len(s)):\\n            if i not in visited:\\n                queue.put(i)\\n                visited.add(i)\\n                component = bfs(i)\\n                letters = [s[j] for j in component]\\n                letters.sort()\\n                for index, letter in zip(component, letters):\\n                    hash_map[index] = letter\\n                    \\n        # print(hash_map)\\n        result = \"\"\\n        for i in range(len(s)):\\n            result+=hash_map[i]\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom queue import Queue\\nclass Solution:\\n    \"\"\"\\n    approach: \\n    we can tackle this problem using bfs based approach\\n    The idea is to createa directed graph first and then get all the connected \\n    components.\\n    \"\"\"\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        # create a graph first of all\\n        hash_map = {}\\n        graph_map = {i: set() for i in range(len(s))}\\n        for pair in pairs:\\n            graph_map[pair[1]].add(pair[0])\\n            graph_map[pair[0]].add(pair[1])\\n        \\n        def bfs(index):\\n            res = []\\n            while not queue.empty():\\n                idx = queue.get()\\n                res.append(idx)\\n                for pos in graph_map[idx]:\\n                    if pos not in visited:\\n                        queue.put(pos)\\n                        visited.add(pos)\\n            res.sort()\\n            return res\\n                \\n        queue = Queue()\\n        visited = set()\\n        for i in range(len(s)):\\n            if i not in visited:\\n                queue.put(i)\\n                visited.add(i)\\n                component = bfs(i)\\n                letters = [s[j] for j in component]\\n                letters.sort()\\n                for index, letter in zip(component, letters):\\n                    hash_map[index] = letter\\n                    \\n        # print(hash_map)\\n        result = \"\"\\n        for i in range(len(s)):\\n            result+=hash_map[i]\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2035928,
                "title": "java-union-find-tc-o-nlog-n-sc-o-v-20-ms-faster-than-99-57",
                "content": "```\\nclass Solution {\\n    // customized union find\\n    // the count stands for how many nodes for that root\\n    class UnionFind {\\n        public int[] root;\\n        private int[] rank;\\n        public int[] count;\\n        // TC O(n), SC O(n)\\n        public UnionFind(int n) {\\n            this.root = new int[n];\\n            this.rank = new int[n];\\n            this.count = new int[n];\\n            Arrays.fill(root, -1);\\n            Arrays.fill(rank, 1);\\n            Arrays.fill(count, 1);\\n        }\\n        // TC O(a(n)), average O(1)\\n        public int find(int a) {\\n            if (root[a] == -1) return a;\\n            return root[a] = find(root[a]);\\n        }\\n        // TC O(a(n)), average O(1)\\n        public void union(int a, int b) {\\n            // find root of a and b\\n            int rootA = find(a);\\n            int rootB = find(b);\\n            if (rootA != rootB) {\\n                if (rank[rootA] > rank[rootB]) {\\n                    root[rootB] = rootA;\\n                    count[rootA] += count[rootB];\\n                } else if (rank[rootA] < rank[rootB]) {\\n                    root[rootA] = rootB;\\n                    count[rootB] += count[rootA];\\n                } else {\\n                    root[rootB] = rootA;\\n                    rank[rootA]++;\\n                    count[rootA] += count[rootB];\\n                }\\n            }\\n        }\\n    }\\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        char[] arr = s.toCharArray();\\n        int n = arr.length;\\n        // initialize union find, TC O(V), SC O(V)\\n        UnionFind unionFind = new UnionFind(n);\\n        for (List<Integer> pair: pairs) {\\n            unionFind.union(pair.get(0), pair.get(1));\\n        }\\n        // create char[] mappings based on unionFind result\\n        // SC O(V)\\n        char[][] map = new char[n][];\\n        int[] counters = new int[n];\\n        \\n        // fill map from char array\\n        // TC O(V)\\n        for (int i = 0; i < n; i++) {\\n            int root = unionFind.find(i);\\n            if (map[root] == null) {\\n                map[root] = new char[unionFind.count[root]];\\n            }\\n            map[root][counters[root]++] = arr[i];\\n        }\\n        // fill array from map\\n        // TC O(V)\\n        counters = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            int root = unionFind.find(i);\\n            if (counters[root] == 0) {\\n                // we need to sort the array\\n\\t\\t\\t\\t// O(nlog(n))\\n                Arrays.sort(map[root]);                \\n            }\\n            arr[i] = map[root][counters[root]++];\\n        }\\n        return new String(arr);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    // customized union find\\n    // the count stands for how many nodes for that root\\n    class UnionFind {\\n        public int[] root;\\n        private int[] rank;\\n        public int[] count;\\n        // TC O(n), SC O(n)\\n        public UnionFind(int n) {\\n            this.root = new int[n];\\n            this.rank = new int[n];\\n            this.count = new int[n];\\n            Arrays.fill(root, -1);\\n            Arrays.fill(rank, 1);\\n            Arrays.fill(count, 1);\\n        }\\n        // TC O(a(n)), average O(1)\\n        public int find(int a) {\\n            if (root[a] == -1) return a;\\n            return root[a] = find(root[a]);\\n        }\\n        // TC O(a(n)), average O(1)\\n        public void union(int a, int b) {\\n            // find root of a and b\\n            int rootA = find(a);\\n            int rootB = find(b);\\n            if (rootA != rootB) {\\n                if (rank[rootA] > rank[rootB]) {\\n                    root[rootB] = rootA;\\n                    count[rootA] += count[rootB];\\n                } else if (rank[rootA] < rank[rootB]) {\\n                    root[rootA] = rootB;\\n                    count[rootB] += count[rootA];\\n                } else {\\n                    root[rootB] = rootA;\\n                    rank[rootA]++;\\n                    count[rootA] += count[rootB];\\n                }\\n            }\\n        }\\n    }\\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        char[] arr = s.toCharArray();\\n        int n = arr.length;\\n        // initialize union find, TC O(V), SC O(V)\\n        UnionFind unionFind = new UnionFind(n);\\n        for (List<Integer> pair: pairs) {\\n            unionFind.union(pair.get(0), pair.get(1));\\n        }\\n        // create char[] mappings based on unionFind result\\n        // SC O(V)\\n        char[][] map = new char[n][];\\n        int[] counters = new int[n];\\n        \\n        // fill map from char array\\n        // TC O(V)\\n        for (int i = 0; i < n; i++) {\\n            int root = unionFind.find(i);\\n            if (map[root] == null) {\\n                map[root] = new char[unionFind.count[root]];\\n            }\\n            map[root][counters[root]++] = arr[i];\\n        }\\n        // fill array from map\\n        // TC O(V)\\n        counters = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            int root = unionFind.find(i);\\n            if (counters[root] == 0) {\\n                // we need to sort the array\\n\\t\\t\\t\\t// O(nlog(n))\\n                Arrays.sort(map[root]);                \\n            }\\n            arr[i] = map[root][counters[root]++];\\n        }\\n        return new String(arr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2005070,
                "title": "c-simple-union-find-single-hash-map-beats-98",
                "content": "## Observation\\n1. We can see the swap pair as connected nodes, thus by union-find, we can find out several groups of nodes.\\n2. Following, sort these groups respectively, and place these characters back to the String with their indexes.\\n3. And we are done.\\n### C++ implementation as below:\\n```\\nclass Solution {\\npublic:\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        int n = s.size();\\n        vector<int> parent(n, -1);\\n        for(int i=0; i<n; i++) {\\n            parent[i] = i;\\n        }\\n\\t\\t\\n\\t\\t// Initializing & grouping\\n        for(auto& x : pairs) {\\n            int p1 = findParent(parent, x[0]);\\n            int p2 = findParent(parent, x[1]);\\n            if (p1 != p2) {\\n                if (p1 < p2)\\n                    parent[p2] = p1;\\n                else\\n                    parent[p1] = p2;\\n            }\\n        }\\n\\t\\t\\n\\t\\t// Further grouping\\n        unordered_map<int, vector<char>> valmap;\\n        for(int i=0; i<n; i++) {\\n            int p = findParent(parent, i);\\n            valmap[p].push_back(s[i]);\\n        }\\n        \\n\\t\\t// Sort each group respectively\\n        for(auto& x : valmap)\\n            sort(x.second.begin(), x.second.end(), greater<int>()); // decreasing, since the vector has only pop_back()\\n        \\n\\t\\t// Generating our solution\\n\\t\\tstring res = \"\";\\n        for(int i=0; i<n; i++) {\\n            int p = findParent(parent, i);\\n            res += valmap[p].back();\\n            valmap[p].pop_back();\\n        }\\n        return res;\\n    }\\n\\t\\n\\t// Union & Find with path compression\\n    int findParent(vector<int>& parent, int x) {\\n        return x == parent[x] ? x : parent[x] = findParent(parent, parent[x]);\\n    }\\n};\\n```\\nTime complexity: O(nlogn)\\nSpace complexity: O(n)\\n\\nIf you find this helpful, please upvote, thank you~",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        int n = s.size();\\n        vector<int> parent(n, -1);\\n        for(int i=0; i<n; i++) {\\n            parent[i] = i;\\n        }\\n\\t\\t\\n\\t\\t// Initializing & grouping\\n        for(auto& x : pairs) {\\n            int p1 = findParent(parent, x[0]);\\n            int p2 = findParent(parent, x[1]);\\n            if (p1 != p2) {\\n                if (p1 < p2)\\n                    parent[p2] = p1;\\n                else\\n                    parent[p1] = p2;\\n            }\\n        }\\n\\t\\t\\n\\t\\t// Further grouping\\n        unordered_map<int, vector<char>> valmap;\\n        for(int i=0; i<n; i++) {\\n            int p = findParent(parent, i);\\n            valmap[p].push_back(s[i]);\\n        }\\n        \\n\\t\\t// Sort each group respectively\\n        for(auto& x : valmap)\\n            sort(x.second.begin(), x.second.end(), greater<int>()); // decreasing, since the vector has only pop_back()\\n        \\n\\t\\t// Generating our solution\\n\\t\\tstring res = \"\";\\n        for(int i=0; i<n; i++) {\\n            int p = findParent(parent, i);\\n            res += valmap[p].back();\\n            valmap[p].pop_back();\\n        }\\n        return res;\\n    }\\n\\t\\n\\t// Union & Find with path compression\\n    int findParent(vector<int>& parent, int x) {\\n        return x == parent[x] ? x : parent[x] = findParent(parent, parent[x]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1989028,
                "title": "c-union-find",
                "content": "```\\nstruct DSU\\n{\\n    int connected;\\n    vector<int> par, sz;\\n    void init(int n) \\n    {\\n        par = sz = vector<int> (n + 1, 0);\\n        for(int i = 1; i <= n; i++)\\n            par[i] = i, sz[i] = 1;\\n        connected = n;\\n    }\\n    int getPar(int u)\\n    {\\n        while(u != par[u])\\n        {\\n            par[u] = par[par[u]];\\n            u = par[u];\\n        }\\n        return u;\\n    }\\n    void unite(int u, int v)\\n    {\\n        int par1 = getPar(u), par2 = getPar(v);\\n\\n        if(par1 == par2)\\n            return;\\n          connected--;\\n        if(sz[par1] > sz[par2])\\n            swap(par1, par2);\\n        sz[par2] += sz[par1];\\n        sz[par1] = 0;\\n        par[par1] = par[par2];\\n    }\\n};\\nclass Solution {\\npublic:\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        int n=s.size();\\n        DSU d; // Disjoint set union declaration\\n        d.init(n); //initialization \\n        for(auto i:pairs)\\n        {\\n            d.unite(i[0],i[1]); // uniting edges\\n        }\\n        vector<int>adj[n+1];\\n        for(int i=0;i<s.size();i++)\\n        {\\n            int x=d.getPar(i); // accumulation positions with same parents\\n            adj[x].emplace_back(i);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(adj[i].size()==0)\\n                continue;\\n            sort(adj[i].begin(),adj[i].end());// sorting all the positions\\n            string k=\"\";\\n            for(auto j:adj[i])\\n            {\\n                k+=s[j];\\n            }\\n            sort(k.begin(),k.end()); // sorting all the characters\\n            for(int j=0;j<k.size();j++)\\n            {\\n                s[adj[i][j]]=k[j];   // distributing the characters in lexicographical increasing order\\n            }\\n        }\\n        return s;\\n       \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct DSU\\n{\\n    int connected;\\n    vector<int> par, sz;\\n    void init(int n) \\n    {\\n        par = sz = vector<int> (n + 1, 0);\\n        for(int i = 1; i <= n; i++)\\n            par[i] = i, sz[i] = 1;\\n        connected = n;\\n    }\\n    int getPar(int u)\\n    {\\n        while(u != par[u])\\n        {\\n            par[u] = par[par[u]];\\n            u = par[u];\\n        }\\n        return u;\\n    }\\n    void unite(int u, int v)\\n    {\\n        int par1 = getPar(u), par2 = getPar(v);\\n\\n        if(par1 == par2)\\n            return;\\n          connected--;\\n        if(sz[par1] > sz[par2])\\n            swap(par1, par2);\\n        sz[par2] += sz[par1];\\n        sz[par1] = 0;\\n        par[par1] = par[par2];\\n    }\\n};\\nclass Solution {\\npublic:\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        int n=s.size();\\n        DSU d; // Disjoint set union declaration\\n        d.init(n); //initialization \\n        for(auto i:pairs)\\n        {\\n            d.unite(i[0],i[1]); // uniting edges\\n        }\\n        vector<int>adj[n+1];\\n        for(int i=0;i<s.size();i++)\\n        {\\n            int x=d.getPar(i); // accumulation positions with same parents\\n            adj[x].emplace_back(i);\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(adj[i].size()==0)\\n                continue;\\n            sort(adj[i].begin(),adj[i].end());// sorting all the positions\\n            string k=\"\";\\n            for(auto j:adj[i])\\n            {\\n                k+=s[j];\\n            }\\n            sort(k.begin(),k.end()); // sorting all the characters\\n            for(int j=0;j<k.size();j++)\\n            {\\n                s[adj[i][j]]=k[j];   // distributing the characters in lexicographical increasing order\\n            }\\n        }\\n        return s;\\n       \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1987690,
                "title": "java-14-ms-beats-100-and-74-7-mb-beats-100-w-detailed-explanatory-comments",
                "content": "Runtime: 14 ms, faster than 100.00% of Java online submissions for Smallest String With Swaps.\\nMemory Usage: 74.7 MB, less than 100.00% of Java online submissions for Smallest String With Swaps.\\n\\n```\\n//Based on: https://leetcode.com/problems/smallest-string-with-swaps/discuss/388257/C%2B%2B-with-picture-union-find\\n\\nclass Solution {    \\n    public int[] parent;\\n    //Initialized to the length of the given string and filled with -1s.\\n    //parent[i] is either the index i\\'s parent (if parent[i] >= 0) or else\\n    // (if parent[i] < 0) i is its own parent and i\\'s set contains - parent[i] elements\\n    \\n    //i and j belong to the same set if and only if find(i) == find(j)\\n\\t//In any set, there will always exist EXACTLY 1 element p such that parent[p] < 0.\\n\\t//Also, parent[i] < 0 if and only if i == find(i)\\n    public int find(int i) { //Always returns a value that is >= 0 and < parent.length()\\n        if (parent[i] < 0)\\n            return i;\\n        else\\n            return parent[i] = find(parent[i]);\\n    }\\n    \\n    public String smallestStringWithSwaps(String s_string, List<List<Integer>> pairs) {\\n        int length = s_string.length();\\n        char[] s = s_string.toCharArray();\\n        \\n        //Step 1:\\n        parent = new int[length];\\n        Arrays.fill(parent, -1);\\n        //if parent[i] == -1 then i is (currently) in its own (singleton) set and otherwise,\\n        //if parent[i] != -1 then i is in a set containing at least two elements\\n        //if parent[i] <= -1 then\\n        // (1) - parent[i] == size of the set that i belongs to\\n        // (2) i == find(j) for any index j that belongs to i\\'s set\\n        //if parent[i] >= 0 then \\n        // (1) i != parent[i]\\n        // (2) i and parent[i] belong to the same set, so\\n        // (3) find(i) == find(parent[i])\\n        \\n        for (final var p : pairs) {\\n            int i = find(p.get(0)), j = find(p.get(1));\\n            //i == find(i) and j == find(j) so\\n            //-parent[i] == size of i\\'s set and -parent[j] == size of j\\'s set\\n            if (i != j) {\\n                if (- parent[i] < - parent[j]) {\\n                    int temp = i;\\n                    i = j;\\n                    j = temp;\\n                }\\n                //j\\'s set is smaller than i\\'s set\\n                //so merge j\\'s set into i\\'s set by making i become the parent of j\\n                parent[i] += parent[j]; //new size of i\\'s set is (- parent[i]) + (- parent[j])\\n                parent[j] = i; //j\\'s parent is now i\\n            }\\n        }\\n        \\n        //Step 2:\\n        //Having constructed the disjoint sets of indices, the next step is to\\n        // transform each set into an increasing array of integers.\\n        \\n        int num_arrays_to_allocate = length;\\n        while (parent[num_arrays_to_allocate - 1] >= 0) --num_arrays_to_allocate; //Optional line\\n        \\n        int[][] index_sets = new int[num_arrays_to_allocate][];\\n        int[] num_elements_added_to_array = new int[num_arrays_to_allocate];\\n        Arrays.fill(num_elements_added_to_array, 0);\\n        \\n        for (int i = 0; i < length; ++i) {\\n            int p = find(i);\\n            if (index_sets[p] == null) {\\n                int size_of_set = - parent[p];\\n                //The next if() statement is optional and can be removed.\\n                if (size_of_set == 1) //then s[p] should be left alone\\n                    continue ; //so don\\'t even bother allocating an array of size 1\\n                index_sets[p] = new int[size_of_set];\\n            }\\n            int next_empty_index = num_elements_added_to_array[p]++;\\n            index_sets[p][next_empty_index] = i;\\n        }\\n\\t\\t//Assuming index_sets[p] != null, then the indices stored in index_sets[p]\\n\\t\\t// are in strictly increasing order. That is,\\n\\t\\t// index_sets[p][0] < index_sets[p][1] < index_sets[p][2] < ...\\n        \\n        //Step 3:\\n        //For every set, sort the following set of chars \\n        // s[index_sets[p][0]], s[index_sets[p][1]], s[index_sets[p][2]], ....\\n        // where p denote the index of this set\\'s the \"maximal\" parent (so p == find(p) holds)\\n        \\n        for (int p = 0; p < num_arrays_to_allocate; ++p) {\\n            int size_of_set;\\n            if (index_sets[p] == null)\\n                continue;\\n            //p == find(p) and parent[p] < 0 so p is the (maximal) parent of a set of size - parent[p]\\n            int[] index_set = index_sets[p];\\n            size_of_set = index_set.length; //size_of_set == - parent[p]\\n\\n            //OPTIONAL: Study this if you want help understanding the for() loops below.\\n            //The next if() statement is entirely optional and can be removed because it \\n            // is essentially just the code below the if() (starting at the line char[] char_array)\\n            // \"expanded\" for the special case where size_of_set == 2.\\n            //In this special case, at most all you need to do is swap two characters.\\n            if (size_of_set == 2) {\\n                //Then you just have to make sure s[index_set[0]] and s[index_set[1]] are in order\\n                // where index_set[0] < index_set[1]\\n                char c0 = s[index_set[0]], c1 = s[index_set[1]];\\n                if (c0 > c1) { //If out of order then swap the two characters\\n                    s[index_set[0]] = c1;\\n                    s[index_set[1]] = c0;\\n                }\\n                continue;\\n            }\\n            \\n            char[] char_array = new char[size_of_set];\\n            for (int k = 0; k < size_of_set; ++k)\\n                char_array[k] = s[index_set[k]];\\n            Arrays.sort(char_array);\\n            for (int k = 0; k < size_of_set; ++k)\\n                s[index_set[k]] = char_array[k];\\n        }\\n        \\n        return new String(s);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array",
                    "Sorting"
                ],
                "code": "```\\n//Based on: https://leetcode.com/problems/smallest-string-with-swaps/discuss/388257/C%2B%2B-with-picture-union-find\\n\\nclass Solution {    \\n    public int[] parent;\\n    //Initialized to the length of the given string and filled with -1s.\\n    //parent[i] is either the index i\\'s parent (if parent[i] >= 0) or else\\n    // (if parent[i] < 0) i is its own parent and i\\'s set contains - parent[i] elements\\n    \\n    //i and j belong to the same set if and only if find(i) == find(j)\\n\\t//In any set, there will always exist EXACTLY 1 element p such that parent[p] < 0.\\n\\t//Also, parent[i] < 0 if and only if i == find(i)\\n    public int find(int i) { //Always returns a value that is >= 0 and < parent.length()\\n        if (parent[i] < 0)\\n            return i;\\n        else\\n            return parent[i] = find(parent[i]);\\n    }\\n    \\n    public String smallestStringWithSwaps(String s_string, List<List<Integer>> pairs) {\\n        int length = s_string.length();\\n        char[] s = s_string.toCharArray();\\n        \\n        //Step 1:\\n        parent = new int[length];\\n        Arrays.fill(parent, -1);\\n        //if parent[i] == -1 then i is (currently) in its own (singleton) set and otherwise,\\n        //if parent[i] != -1 then i is in a set containing at least two elements\\n        //if parent[i] <= -1 then\\n        // (1) - parent[i] == size of the set that i belongs to\\n        // (2) i == find(j) for any index j that belongs to i\\'s set\\n        //if parent[i] >= 0 then \\n        // (1) i != parent[i]\\n        // (2) i and parent[i] belong to the same set, so\\n        // (3) find(i) == find(parent[i])\\n        \\n        for (final var p : pairs) {\\n            int i = find(p.get(0)), j = find(p.get(1));\\n            //i == find(i) and j == find(j) so\\n            //-parent[i] == size of i\\'s set and -parent[j] == size of j\\'s set\\n            if (i != j) {\\n                if (- parent[i] < - parent[j]) {\\n                    int temp = i;\\n                    i = j;\\n                    j = temp;\\n                }\\n                //j\\'s set is smaller than i\\'s set\\n                //so merge j\\'s set into i\\'s set by making i become the parent of j\\n                parent[i] += parent[j]; //new size of i\\'s set is (- parent[i]) + (- parent[j])\\n                parent[j] = i; //j\\'s parent is now i\\n            }\\n        }\\n        \\n        //Step 2:\\n        //Having constructed the disjoint sets of indices, the next step is to\\n        // transform each set into an increasing array of integers.\\n        \\n        int num_arrays_to_allocate = length;\\n        while (parent[num_arrays_to_allocate - 1] >= 0) --num_arrays_to_allocate; //Optional line\\n        \\n        int[][] index_sets = new int[num_arrays_to_allocate][];\\n        int[] num_elements_added_to_array = new int[num_arrays_to_allocate];\\n        Arrays.fill(num_elements_added_to_array, 0);\\n        \\n        for (int i = 0; i < length; ++i) {\\n            int p = find(i);\\n            if (index_sets[p] == null) {\\n                int size_of_set = - parent[p];\\n                //The next if() statement is optional and can be removed.\\n                if (size_of_set == 1) //then s[p] should be left alone\\n                    continue ; //so don\\'t even bother allocating an array of size 1\\n                index_sets[p] = new int[size_of_set];\\n            }\\n            int next_empty_index = num_elements_added_to_array[p]++;\\n            index_sets[p][next_empty_index] = i;\\n        }\\n\\t\\t//Assuming index_sets[p] != null, then the indices stored in index_sets[p]\\n\\t\\t// are in strictly increasing order. That is,\\n\\t\\t// index_sets[p][0] < index_sets[p][1] < index_sets[p][2] < ...\\n        \\n        //Step 3:\\n        //For every set, sort the following set of chars \\n        // s[index_sets[p][0]], s[index_sets[p][1]], s[index_sets[p][2]], ....\\n        // where p denote the index of this set\\'s the \"maximal\" parent (so p == find(p) holds)\\n        \\n        for (int p = 0; p < num_arrays_to_allocate; ++p) {\\n            int size_of_set;\\n            if (index_sets[p] == null)\\n                continue;\\n            //p == find(p) and parent[p] < 0 so p is the (maximal) parent of a set of size - parent[p]\\n            int[] index_set = index_sets[p];\\n            size_of_set = index_set.length; //size_of_set == - parent[p]\\n\\n            //OPTIONAL: Study this if you want help understanding the for() loops below.\\n            //The next if() statement is entirely optional and can be removed because it \\n            // is essentially just the code below the if() (starting at the line char[] char_array)\\n            // \"expanded\" for the special case where size_of_set == 2.\\n            //In this special case, at most all you need to do is swap two characters.\\n            if (size_of_set == 2) {\\n                //Then you just have to make sure s[index_set[0]] and s[index_set[1]] are in order\\n                // where index_set[0] < index_set[1]\\n                char c0 = s[index_set[0]], c1 = s[index_set[1]];\\n                if (c0 > c1) { //If out of order then swap the two characters\\n                    s[index_set[0]] = c1;\\n                    s[index_set[1]] = c0;\\n                }\\n                continue;\\n            }\\n            \\n            char[] char_array = new char[size_of_set];\\n            for (int k = 0; k < size_of_set; ++k)\\n                char_array[k] = s[index_set[k]];\\n            Arrays.sort(char_array);\\n            for (int k = 0; k < size_of_set; ++k)\\n                s[index_set[k]] = char_array[k];\\n        }\\n        \\n        return new String(s);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1987581,
                "title": "kotlin-bfs",
                "content": "Since the other kotlin solutions all appear to be union find, I guess I\\'ll share this:\\n```\\nclass Solution {\\n    fun smallestStringWithSwaps(s: String, pairs: List<List<Int>>): String {\\n        val connectedGroups = buildConnectedGroups(pairs)\\n\\n        val result = s.toCharArray()\\n        connectedGroups.forEach { set ->\\n            val minHeap = PriorityQueue<Char>()\\n            set.forEach { index ->\\n                minHeap.add(s[index])\\n            }\\n            set.sorted().forEach { index ->\\n                result[index] = minHeap.remove()\\n            }\\n        }\\n\\n        return String(result)\\n    }\\n\\n    fun buildConnectedGroups(pairs: List<List<Int>>): Set<Set<Int>> {\\n        val connectedGroups = mutableSetOf<Set<Int>>()\\n        val map = mutableMapOf<Int, Node>()\\n\\n        pairs.forEach { pair ->\\n            var node = map.getOrDefault(pair[0], Node(pair[0]))\\n            node.neighbors.add(pair[1])\\n            map[pair[0]] = node\\n\\n            node = map.getOrDefault(pair[1], Node(pair[1]))\\n            node.neighbors.add(pair[0])\\n            map[pair[1]] = node\\n        }\\n\\n        // BFS\\n        val allVisited = mutableSetOf<Int>()\\n        map.values.forEach { node ->\\n            if (!allVisited.contains(node.data)) {\\n                val group = mutableSetOf<Int>()\\n                val queue: Queue<Node> = LinkedList()\\n\\n                queue.add(node)\\n                allVisited.add(node.data)\\n\\n                while (queue.isNotEmpty()) {\\n                    val current = queue.remove()\\n                    group.add(current.data)\\n                    current.neighbors.forEach { neighbor ->\\n                        if (!allVisited.contains(neighbor)) {\\n                            queue.add(map[neighbor])\\n                            allVisited.add(neighbor)\\n                        }\\n                    }\\n                }\\n                connectedGroups.add(group)\\n            }\\n        }\\n\\n        return connectedGroups\\n    }\\n\\n    class Node(var data: Int, val neighbors: MutableList<Int> = mutableListOf())\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    fun smallestStringWithSwaps(s: String, pairs: List<List<Int>>): String {\\n        val connectedGroups = buildConnectedGroups(pairs)\\n\\n        val result = s.toCharArray()\\n        connectedGroups.forEach { set ->\\n            val minHeap = PriorityQueue<Char>()\\n            set.forEach { index ->\\n                minHeap.add(s[index])\\n            }\\n            set.sorted().forEach { index ->\\n                result[index] = minHeap.remove()\\n            }\\n        }\\n\\n        return String(result)\\n    }\\n\\n    fun buildConnectedGroups(pairs: List<List<Int>>): Set<Set<Int>> {\\n        val connectedGroups = mutableSetOf<Set<Int>>()\\n        val map = mutableMapOf<Int, Node>()\\n\\n        pairs.forEach { pair ->\\n            var node = map.getOrDefault(pair[0], Node(pair[0]))\\n            node.neighbors.add(pair[1])\\n            map[pair[0]] = node\\n\\n            node = map.getOrDefault(pair[1], Node(pair[1]))\\n            node.neighbors.add(pair[0])\\n            map[pair[1]] = node\\n        }\\n\\n        // BFS\\n        val allVisited = mutableSetOf<Int>()\\n        map.values.forEach { node ->\\n            if (!allVisited.contains(node.data)) {\\n                val group = mutableSetOf<Int>()\\n                val queue: Queue<Node> = LinkedList()\\n\\n                queue.add(node)\\n                allVisited.add(node.data)\\n\\n                while (queue.isNotEmpty()) {\\n                    val current = queue.remove()\\n                    group.add(current.data)\\n                    current.neighbors.forEach { neighbor ->\\n                        if (!allVisited.contains(neighbor)) {\\n                            queue.add(map[neighbor])\\n                            allVisited.add(neighbor)\\n                        }\\n                    }\\n                }\\n                connectedGroups.add(group)\\n            }\\n        }\\n\\n        return connectedGroups\\n    }\\n\\n    class Node(var data: Int, val neighbors: MutableList<Int> = mutableListOf())\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1987457,
                "title": "c-with-unionfind",
                "content": "\\tclass UnionFind {\\n\\t\\tprivate int[] root;\\n\\t\\tprivate int[] rank;\\n\\n\\t\\tpublic UnionFind(int size) {\\n\\t\\t\\troot = new int[size];\\n\\t\\t\\trank = new int[size];\\n\\t\\t\\tfor (int i = 0; i < size; i++) {\\n\\t\\t\\t\\troot[i] = i;\\n\\t\\t\\t\\trank[i] = 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tpublic int Find(int vertex) {\\n\\t\\t\\tif (vertex == root[vertex]) {\\n\\t\\t\\t\\treturn vertex;\\n\\t\\t\\t}\\n\\t\\t\\treturn root[vertex] = Find(root[vertex]);\\n\\t\\t}\\n\\t\\tpublic void Union(int vertex1, int vertex2) {\\n\\t\\t\\tint root1 = Find(vertex1);\\n\\t\\t\\tint root2 = Find(vertex2);\\n\\t\\t\\tif (root1 != root2) {\\n\\t\\t\\t\\tif (rank[root1] >= rank[root2]) {\\n\\t\\t\\t\\t\\troot[root2] = root1;\\n\\t\\t\\t\\t\\trank[root1] += rank[root2];\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\troot[root1] = root2;\\n\\t\\t\\t\\t\\trank[root2] += rank[root2];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n    \\n    \\n\\tpublic class Solution {      \\n\\t\\tpublic string SmallestStringWithSwaps(string s, IList<IList<int>> pairs) {\\n\\t\\t\\t//Do the unionFind to identify the connected swapable letters\\n\\t\\t\\tUnionFind uf = new UnionFind(s.Length);\\n\\t\\t\\tforeach(List<int> pair in pairs){\\n\\t\\t\\t\\tuf.Union(pair[0],pair[1]);\\n\\t\\t\\t}\\n\\n\\t\\t\\tDictionary<int,List<char>> letterGroups = new Dictionary<int,List<char>>();\\n\\t\\t\\t//Group the swapable letters based on root\\n\\t\\t\\tfor(int i=0;i<s.Length;i++){\\n\\t\\t\\t\\tint key = uf.Find(i);\\n\\t\\t\\t\\tif(!letterGroups.ContainsKey(key)){\\n\\t\\t\\t\\t\\tletterGroups[key]=new List<char>();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tletterGroups[key].Add(s[i]);\\n\\t\\t\\t}\\n\\n\\t\\t\\t//Sort the swapable letters within each group\\n\\t\\t\\tforeach(int key in letterGroups.Keys){\\n\\t\\t\\t\\tletterGroups[key].Sort();\\n\\t\\t\\t}\\n\\n\\t\\t\\t//Iterate through the string and remove the smallest letter from its corresponding root group\\n\\t\\t\\tchar[] smallestString = new char[s.Length];\\n\\t\\t\\tfor(int i=0;i<s.Length;i++){\\n\\t\\t\\t\\tint key = uf.Find(i);\\n\\t\\t\\t\\tsmallestString[i] = letterGroups[key][0];\\n\\t\\t\\t\\tletterGroups[key].RemoveAt(0);\\n\\t\\t\\t}\\n\\t\\t\\treturn new String(smallestString);\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {      \\n\\t\\tpublic string SmallestStringWithSwaps(string s, IList<IList<int>> pairs) {\\n\\t\\t\\t//Do the unionFind to identify the connected swapable letters\\n\\t\\t\\tUnionFind uf = new UnionFind(s.Length);\\n\\t\\t\\tforeach(List<int> pair in pairs){\\n\\t\\t\\t\\tuf.Union(pair[0],pair[1]);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1987426,
                "title": "c-union-find-with-rank-method-and-path-compression",
                "content": "```\\nclass Solution {\\npublic:\\n    #define debug(x) cout<<#x<<\":\"<<x<<endl;\\n    vector<int> parent;\\n    vector<int> rank;\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        int n = s.size();\\n        parent.resize(n,-1);\\n        rank.resize(n,-1);\\n        Union(s,pairs);\\n        unordered_map<int,priority_queue<char,vector<char>, greater<char>>> umap;\\n        for(int i = 0;i<n;i++){\\n            int parentId = Find(i);\\n            umap[parentId].push(s[i]);\\n        }\\n        for(int i=0;i<n;i++){\\n            int parentId = Find(i);\\n            char ch = umap[parentId].top();umap[parentId].pop();\\n            s[i] = ch; \\n        }\\n        return s;\\n    }\\n    \\n    void Union(string& s,vector<vector<int>>& pairs){\\n        for(auto& edge:pairs){\\n            int srcParent = Find(edge[0]);\\n            int destParent = Find(edge[1]);\\n            if(rank[srcParent] > rank[destParent]){\\n                parent[destParent] = srcParent;\\n            }else if(rank[destParent] > rank[srcParent]){\\n                parent[srcParent] = destParent;\\n            }else{\\n                parent[srcParent] = destParent;\\n                rank[srcParent]++;\\n            }\\n        }\\n    }\\n    \\n    int Find(int id){\\n        if(parent[id] == -1) return parent[id] = id;\\n        int src = id;\\n        while(id != parent[id] && parent[id] != -1) id = parent[id];\\n        return parent[src] = id;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define debug(x) cout<<#x<<\":\"<<x<<endl;\\n    vector<int> parent;\\n    vector<int> rank;\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        int n = s.size();\\n        parent.resize(n,-1);\\n        rank.resize(n,-1);\\n        Union(s,pairs);\\n        unordered_map<int,priority_queue<char,vector<char>, greater<char>>> umap;\\n        for(int i = 0;i<n;i++){\\n            int parentId = Find(i);\\n            umap[parentId].push(s[i]);\\n        }\\n        for(int i=0;i<n;i++){\\n            int parentId = Find(i);\\n            char ch = umap[parentId].top();umap[parentId].pop();\\n            s[i] = ch; \\n        }\\n        return s;\\n    }\\n    \\n    void Union(string& s,vector<vector<int>>& pairs){\\n        for(auto& edge:pairs){\\n            int srcParent = Find(edge[0]);\\n            int destParent = Find(edge[1]);\\n            if(rank[srcParent] > rank[destParent]){\\n                parent[destParent] = srcParent;\\n            }else if(rank[destParent] > rank[srcParent]){\\n                parent[srcParent] = destParent;\\n            }else{\\n                parent[srcParent] = destParent;\\n                rank[srcParent]++;\\n            }\\n        }\\n    }\\n    \\n    int Find(int id){\\n        if(parent[id] == -1) return parent[id] = id;\\n        int src = id;\\n        while(id != parent[id] && parent[id] != -1) id = parent[id];\\n        return parent[src] = id;\\n    }\\n    \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1987335,
                "title": "c-union-find-solution-with-comments",
                "content": "```\\nclass Solution {\\nprivate:\\n    // Find the group of an element\\n    int f(vector<int>& p, int e) {\\n        if(p[e] == e) return e;\\n         else { \\n            p[e] = f(p, p[e]);\\n            return p[e];\\n        }\\n    }\\n\\n    // Union two groups\\n    void u(vector<int>& p, int e1, int e2) {\\n        int r1 = f(p, e1);\\n        int r2 = f(p, e2);\\n\\n        if(r1 == r2) return;\\n\\n        p[r2] = r1;\\n    }\\n\\npublic:\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        int n = s.size();\\n        vector<int> p(n);\\n        \\n        for(int i = 0; i < n; i ++) p[i] = i; // Initialize parent array for union find\\n        \\n        for(vector<int>& x : pairs) u(p, x[0], x[1]); // Union all pairs\\n        \\n        vector<vector<char>> g(n);\\n\\n        for(int i = 0; i < n; i ++) {\\n            g[f(p, i)].push_back(s[i]); // Seperate characters by group\\n        }\\n        \\n        for(int i = 0; i < n; i ++) sort(g[i].begin(), g[i].end()); // Sort each group\\n        \\n        vector<int> in(n);\\n        vector<char> ans;\\n        \\n        for(int i = 0; i < n; i ++) {\\n            int c = f(p, i);\\n            ans.push_back(g[c][in[c] ++]); // Add each group back into answer\\n        }\\n        \\n        return string(ans.begin(), ans.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    // Find the group of an element\\n    int f(vector<int>& p, int e) {\\n        if(p[e] == e) return e;\\n         else { \\n            p[e] = f(p, p[e]);\\n            return p[e];\\n        }\\n    }\\n\\n    // Union two groups\\n    void u(vector<int>& p, int e1, int e2) {\\n        int r1 = f(p, e1);\\n        int r2 = f(p, e2);\\n\\n        if(r1 == r2) return;\\n\\n        p[r2] = r1;\\n    }\\n\\npublic:\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        int n = s.size();\\n        vector<int> p(n);\\n        \\n        for(int i = 0; i < n; i ++) p[i] = i; // Initialize parent array for union find\\n        \\n        for(vector<int>& x : pairs) u(p, x[0], x[1]); // Union all pairs\\n        \\n        vector<vector<char>> g(n);\\n\\n        for(int i = 0; i < n; i ++) {\\n            g[f(p, i)].push_back(s[i]); // Seperate characters by group\\n        }\\n        \\n        for(int i = 0; i < n; i ++) sort(g[i].begin(), g[i].end()); // Sort each group\\n        \\n        vector<int> in(n);\\n        vector<char> ans;\\n        \\n        for(int i = 0; i < n; i ++) {\\n            int c = f(p, i);\\n            ans.push_back(g[c][in[c] ++]); // Add each group back into answer\\n        }\\n        \\n        return string(ans.begin(), ans.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1987274,
                "title": "easy-solution-union-find-java",
                "content": "```\\nclass Solution {\\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        HashMap<Integer, PriorityQueue<Character>> map = new HashMap<>();\\n\\t\\tchar[] ch = s.toCharArray();\\n\\t\\tUnionFind uf = new UnionFind(ch.length);\\n\\t\\tfor(List<Integer> pair : pairs){\\n\\t\\t\\tuf.union(pair.get(0), pair.get(1));\\n\\t\\t}\\n\\t\\tfor(int i = 0; i < ch.length; i++) {\\n\\t\\t\\tint parent = uf.find(i);\\n\\t\\t\\tPriorityQueue<Character> pq = map.getOrDefault(parent, new PriorityQueue<Character>());\\n\\t\\t\\tpq.offer(ch[i]);\\n\\t\\t\\tmap.putIfAbsent(parent, pq);\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor(int i = 0; i < ch.length; i++) {\\n\\t\\t\\tint parent  = uf.find(i);\\n\\t\\t\\tch[i] = map.get(parent).poll();\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn new String(ch);\\n    }\\n    private class UnionFind {\\n        int[] parent;\\n        public UnionFind(int n) {\\n            parent = new int[n];\\n            for(int i = 0; i < n; i++) {\\n                parent[i] = i;\\n            }\\n        }\\n\\n        public int find(int i) {\\n            if(parent[i] == i) {\\n                return parent[i];\\n            }\\n\\n            parent[i] = find(parent[i]);\\n            return parent[i];\\n        }\\n\\n        public void union(int i, int j) {\\n            int find1 = find(i);\\n            int find2 = find(j);\\n            if(find1 != find2) {\\n                parent[find2] = find1;\\n            }\\n        }\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public String smallestStringWithSwaps(String s, List<List<Integer>> pairs) {\\n        HashMap<Integer, PriorityQueue<Character>> map = new HashMap<>();\\n\\t\\tchar[] ch = s.toCharArray();\\n\\t\\tUnionFind uf = new UnionFind(ch.length);\\n\\t\\tfor(List<Integer> pair : pairs){\\n\\t\\t\\tuf.union(pair.get(0), pair.get(1));\\n\\t\\t}\\n\\t\\tfor(int i = 0; i < ch.length; i++) {\\n\\t\\t\\tint parent = uf.find(i);\\n\\t\\t\\tPriorityQueue<Character> pq = map.getOrDefault(parent, new PriorityQueue<Character>());\\n\\t\\t\\tpq.offer(ch[i]);\\n\\t\\t\\tmap.putIfAbsent(parent, pq);\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor(int i = 0; i < ch.length; i++) {\\n\\t\\t\\tint parent  = uf.find(i);\\n\\t\\t\\tch[i] = map.get(parent).poll();\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn new String(ch);\\n    }\\n    private class UnionFind {\\n        int[] parent;\\n        public UnionFind(int n) {\\n            parent = new int[n];\\n            for(int i = 0; i < n; i++) {\\n                parent[i] = i;\\n            }\\n        }\\n\\n        public int find(int i) {\\n            if(parent[i] == i) {\\n                return parent[i];\\n            }\\n\\n            parent[i] = find(parent[i]);\\n            return parent[i];\\n        }\\n\\n        public void union(int i, int j) {\\n            int find1 = find(i);\\n            int find2 = find(j);\\n            if(find1 != find2) {\\n                parent[find2] = find1;\\n            }\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1987264,
                "title": "easy-dfs-sorting-constructive-naive",
                "content": "very easy naive approach as follows:\\n\\nfirstly i make adjacency list namely v,\\nnow i find dfs for each number between 0to n-1;\\nstore the dfs into vector, put the temperary string according to dfs vector.\\nsort each time and check the minimum one.\\ni used the visited vector for the repeated calls in dfs.\\n\\nif you get that please upvote.\\n```\\nclass Solution {\\npublic:\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        int n= s.size();\\n        vector<vector<int>>v(n);\\n        for(auto it : pairs){\\n            v[it[0]].push_back(it[1]);\\n            v[it[1]].push_back(it[0]);\\n        }\\n        \\n        // for(int i=0 ; i<n ; i++){\\n        //     cout<<i<<\" : \";\\n        //     for(auto it : v[i]){\\n        //         cout<<it<<\" , \";\\n        //     }\\n        //     cout<<\" \\\\n\";\\n        // }\\n        \\n       \\n             vector<int>vis(n, 0);\\n            for(int j=0 ; j<n ; j++){\\n                 \\n                vector<int> temp;\\n                if(!vis[j]){\\n                    dfs(j,temp, vis,v);\\n                }\\n                string ans=s;\\n                string k;\\n                for(auto it : temp){\\n                    \\n                   k.push_back(s[it]);\\n                }\\n                sort(k.begin(), k.end());\\n                int m=0;\\n                sort(temp.begin(), temp.end());\\n                for(auto it : temp){\\n                    \\n                    ans[it]= k[m++];\\n                }\\n//                 // cout<<ans<<endl;\\n                s=min(s,ans);\\n                // for(auto it : temp)cout<<it<<\" , \";\\n                // cout<<\"\\\\n\";\\n            }\\n        \\n        return s;\\n    }\\n    void dfs(int i,vector<int>&temp, vector<int>&vis, vector<vector<int>>&v ){\\n        vis[i]=1;\\n        temp.push_back(i);\\n        for(auto it : v[i]){\\n            if(!vis[it]){\\n            dfs(it, temp,vis,v);\\n                }\\n        }\\n        \\n    }\\n};",
                "solutionTags": [
                    "Depth-First Search",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        int n= s.size();\\n        vector<vector<int>>v(n);\\n        for(auto it : pairs){\\n            v[it[0]].push_back(it[1]);\\n            v[it[1]].push_back(it[0]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1987169,
                "title": "python3-solution-with-using-union-find",
                "content": "```\\nclass UnionFind:\\n    def __init__(self, size):\\n        self.root = [i for i in range(size)]\\n        self.rank = [1] * size\\n        \\n    def find(self, x):\\n        if x == self.root[x]:\\n            return x\\n        \\n        self.root[x] = self.find(self.root[x])\\n        \\n        return self.root[x]\\n    \\n    def union(self, x, y):\\n        root_x = self.find(x)\\n        root_y = self.find(y)\\n        \\n        if root_x != root_y:\\n            if self.rank[root_x] < self.rank[root_y]:\\n                self.root[root_x] = root_y\\n            elif self.rank[root_x] > self.rank[root_y]:\\n                self.root[root_y] = root_x\\n            else:\\n                self.root[root_y] = root_x\\n                self.rank[root_x] += 1\\n\\n    def is_connected(self, x, y):\\n        return self.find(x) == self.find(y)\\n    \\n    \\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        len_s = len(s)\\n        uf = UnionFind(len_s)\\n        \\n        # iterate over the edges\\n        for pair in pairs:\\n            uf.union(pair[0], pair[1]) # pair[0] - source, pair[1] - dest\\n        \\n        root2v = collections.defaultdict(list)\\n        # root to all v in set\\n        for v in range(len(s)):\\n            root = uf.find(v)\\n            root2v[root].append(v)\\n          \\n        res = [\\'\\'] * len_s\\n        \\n        for root in root2v:\\n            # vs - single set of v\\n            vs = root2v[root]\\n            \\n            chars = []\\n            \\n            # fill chars as s[v]\\n            for v in vs:\\n                chars.append(s[v])\\n            chars.sort()\\n            \\n            \"\"\"\\n            [0, 3] -> [c, a] (we have set 0(root)->3)\\n            chars = [c,a]\\n            chars.sort = [a,c]\\n            res[0] = a\\n            res[3] = c\\n            repeat for all disjoint set\\n            \"\"\"\\n            for idx, v in enumerate(vs):\\n                res[v] = chars[idx]\\n        \\n        return \\'\\'.join(res)\\n```",
                "solutionTags": [
                    "Python",
                    "Union Find",
                    "Graph"
                ],
                "code": "```\\nclass UnionFind:\\n    def __init__(self, size):\\n        self.root = [i for i in range(size)]\\n        self.rank = [1] * size\\n        \\n    def find(self, x):\\n        if x == self.root[x]:\\n            return x\\n        \\n        self.root[x] = self.find(self.root[x])\\n        \\n        return self.root[x]\\n    \\n    def union(self, x, y):\\n        root_x = self.find(x)\\n        root_y = self.find(y)\\n        \\n        if root_x != root_y:\\n            if self.rank[root_x] < self.rank[root_y]:\\n                self.root[root_x] = root_y\\n            elif self.rank[root_x] > self.rank[root_y]:\\n                self.root[root_y] = root_x\\n            else:\\n                self.root[root_y] = root_x\\n                self.rank[root_x] += 1\\n\\n    def is_connected(self, x, y):\\n        return self.find(x) == self.find(y)\\n    \\n    \\nclass Solution:\\n    def smallestStringWithSwaps(self, s: str, pairs: List[List[int]]) -> str:\\n        len_s = len(s)\\n        uf = UnionFind(len_s)\\n        \\n        # iterate over the edges\\n        for pair in pairs:\\n            uf.union(pair[0], pair[1]) # pair[0] - source, pair[1] - dest\\n        \\n        root2v = collections.defaultdict(list)\\n        # root to all v in set\\n        for v in range(len(s)):\\n            root = uf.find(v)\\n            root2v[root].append(v)\\n          \\n        res = [\\'\\'] * len_s\\n        \\n        for root in root2v:\\n            # vs - single set of v\\n            vs = root2v[root]\\n            \\n            chars = []\\n            \\n            # fill chars as s[v]\\n            for v in vs:\\n                chars.append(s[v])\\n            chars.sort()\\n            \\n            \"\"\"\\n            [0, 3] -> [c, a] (we have set 0(root)->3)\\n            chars = [c,a]\\n            chars.sort = [a,c]\\n            res[0] = a\\n            res[3] = c\\n            repeat for all disjoint set\\n            \"\"\"\\n            for idx, v in enumerate(vs):\\n                res[v] = chars[idx]\\n        \\n        return \\'\\'.join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1987128,
                "title": "golang-shortest-simple-to-understand",
                "content": "```\\nimport \"sort\"\\n\\nfunc smallestStringWithSwaps(s string, pairs [][]int) string {\\n    p := make([]int, len(s))\\n    for i := 0; i < len(s); i++ {\\n        p[i] = i\\n    }\\n    \\n    var find func(x int) int\\n    find = func(x int) int {\\n        if p[x] != x {\\n            p[x] = find(p[x])\\n        }\\n        return p[x]\\n    }\\n    \\n    var union func(x, y int)\\n    union = func(x, y int) {\\n        px := find(x)\\n        py := find(y)\\n        p[py] = px\\n    }\\n    \\n    for _, pair := range pairs {\\n        union(pair[0], pair[1])\\n    }\\n    \\n    dict := make(map[int][]byte)\\n    for i, v := range p {\\n        pi := find(v)\\n        dict[pi] = append(dict[pi], s[i])\\n    }\\n    \\n    for i := range dict {\\n        sort.Slice(dict[i], func(a int, b int) bool {\\n            return dict[i][a] < dict[i][b]\\n        })\\n    }\\n    \\n    res := make([]byte, 0, len(s))\\n    for _, v := range p {\\n        pi := find(v)\\n        res = append(res, dict[pi][0])\\n        dict[pi] = dict[pi][1:]\\n    }\\n    \\n    return string(res)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nimport \"sort\"\\n\\nfunc smallestStringWithSwaps(s string, pairs [][]int) string {\\n    p := make([]int, len(s))\\n    for i := 0; i < len(s); i++ {\\n        p[i] = i\\n    }\\n    \\n    var find func(x int) int\\n    find = func(x int) int {\\n        if p[x] != x {\\n            p[x] = find(p[x])\\n        }\\n        return p[x]\\n    }\\n    \\n    var union func(x, y int)\\n    union = func(x, y int) {\\n        px := find(x)\\n        py := find(y)\\n        p[py] = px\\n    }\\n    \\n    for _, pair := range pairs {\\n        union(pair[0], pair[1])\\n    }\\n    \\n    dict := make(map[int][]byte)\\n    for i, v := range p {\\n        pi := find(v)\\n        dict[pi] = append(dict[pi], s[i])\\n    }\\n    \\n    for i := range dict {\\n        sort.Slice(dict[i], func(a int, b int) bool {\\n            return dict[i][a] < dict[i][b]\\n        })\\n    }\\n    \\n    res := make([]byte, 0, len(s))\\n    for _, v := range p {\\n        pi := find(v)\\n        res = append(res, dict[pi][0])\\n        dict[pi] = dict[pi][1:]\\n    }\\n    \\n    return string(res)\\n}\\n```",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 1568292,
                "content": [
                    {
                        "username": "jaedongtensor",
                        "content": "Most solutions just assume that the chars in connected components could be arranged in any order. By intuition, I think it is correct. But could anyone explain why it is always true? Is there any topic in graph theory talking about this problem? \\n"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "I\\'m getting memory limit exeeded for last test case can anyone help me fix this\\n"
                    },
                    {
                        "username": "diksha_iitian",
                        "content": "i am also getting "
                    },
                    {
                        "username": "dpacifico",
                        "content": "Is this medium for who? John von Neumann? :) Nice problem though..."
                    },
                    {
                        "username": "jd2050",
                        "content": "This is \"Medium\"?? No way"
                    },
                    {
                        "username": "aditya92",
                        "content": "How can we identify that this is a graph problem ?\\nI am not able to get the intuition behind it "
                    },
                    {
                        "username": "adam_y_w",
                        "content": "think it this way, to be able to reorder the chars you need to first know what chats are in the same group therefore can be reshuffled. The way to find the groups become typical disjoint sets question, which is a graph question "
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "IMO, in this particular case it's seen that we could have up to 10^5 pairs for swaps. It's wise to expect that it's insane to use brute force for it, and we probably need to cut down the number of swaps, so DSU comes into mind. "
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "I read somewhere here that if you find that there\\'s any transitive relation in problem, than dsu might be of some use. That advice has helped me a lot to identify dsu problems."
                    },
                    {
                        "username": "ferdinand069",
                        "content": "can anyone tell which implementation is better dfs or union find ?"
                    },
                    {
                        "username": "TKR_6",
                        "content": "Nothing is better than the other , it depends on your implementation skills. For me DFS is easy to implement."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/smallest-string-with-swaps/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Depth-First Search (DFS)\n\n  \n**Approach 2:** Disjoint Set Union (DSU)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kartikey101",
                        "content": "If you\\'re getting TLE with union find try using path compression."
                    },
                    {
                        "username": "user5418EK",
                        "content": "ERROR IN THIS??\\nRUNTIME IS COMING AT TEST CASE 30/36\\n\\nclass Solution {\\npublic:\\nchar find(int ch,unordered_map<int,int>&map){\\n     if(ch==map[ch]){\\n         return ch;\\n     }\\n     return find(map[ch],map);\\n }\\n void  my_union(int a,int b,unordered_map<int,int>&map){\\n    a=find(a,map);\\n    b=find(b,map);\\n    map[a]=b;\\n \\n\\n }\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        unordered_map<int,int>map;\\n        string ans;\\n        for(int i=0;i<s.size();i++){\\n            map[i]=i;\\n        }\\n        for(int i=0;i<pairs.size();i++){\\n          int x=pairs[i][0];\\n          int y=pairs[i][1];\\n          my_union(x,y,map);\\n        }\\n         unordered_map<int,priority_queue <char, vector<char>, greater<char>>>map1;\\n        for(int i=0;i<s.size();i++){\\n           int x=find(i,map);\\n          \\n           map1[x].push(s[i]);\\n        }\\n         \\n        for(int i=0;i<s.size();i++){\\n             int x=find(i,map);\\n             char a=map1[x].top();\\n             map1[x].pop();\\n             ans+=a;\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "prikarshglory",
                        "content": "Use path compression \\n"
                    }
                ]
            },
            {
                "id": 1941130,
                "content": [
                    {
                        "username": "jaedongtensor",
                        "content": "Most solutions just assume that the chars in connected components could be arranged in any order. By intuition, I think it is correct. But could anyone explain why it is always true? Is there any topic in graph theory talking about this problem? \\n"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "I\\'m getting memory limit exeeded for last test case can anyone help me fix this\\n"
                    },
                    {
                        "username": "diksha_iitian",
                        "content": "i am also getting "
                    },
                    {
                        "username": "dpacifico",
                        "content": "Is this medium for who? John von Neumann? :) Nice problem though..."
                    },
                    {
                        "username": "jd2050",
                        "content": "This is \"Medium\"?? No way"
                    },
                    {
                        "username": "aditya92",
                        "content": "How can we identify that this is a graph problem ?\\nI am not able to get the intuition behind it "
                    },
                    {
                        "username": "adam_y_w",
                        "content": "think it this way, to be able to reorder the chars you need to first know what chats are in the same group therefore can be reshuffled. The way to find the groups become typical disjoint sets question, which is a graph question "
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "IMO, in this particular case it's seen that we could have up to 10^5 pairs for swaps. It's wise to expect that it's insane to use brute force for it, and we probably need to cut down the number of swaps, so DSU comes into mind. "
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "I read somewhere here that if you find that there\\'s any transitive relation in problem, than dsu might be of some use. That advice has helped me a lot to identify dsu problems."
                    },
                    {
                        "username": "ferdinand069",
                        "content": "can anyone tell which implementation is better dfs or union find ?"
                    },
                    {
                        "username": "TKR_6",
                        "content": "Nothing is better than the other , it depends on your implementation skills. For me DFS is easy to implement."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/smallest-string-with-swaps/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Depth-First Search (DFS)\n\n  \n**Approach 2:** Disjoint Set Union (DSU)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kartikey101",
                        "content": "If you\\'re getting TLE with union find try using path compression."
                    },
                    {
                        "username": "user5418EK",
                        "content": "ERROR IN THIS??\\nRUNTIME IS COMING AT TEST CASE 30/36\\n\\nclass Solution {\\npublic:\\nchar find(int ch,unordered_map<int,int>&map){\\n     if(ch==map[ch]){\\n         return ch;\\n     }\\n     return find(map[ch],map);\\n }\\n void  my_union(int a,int b,unordered_map<int,int>&map){\\n    a=find(a,map);\\n    b=find(b,map);\\n    map[a]=b;\\n \\n\\n }\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        unordered_map<int,int>map;\\n        string ans;\\n        for(int i=0;i<s.size();i++){\\n            map[i]=i;\\n        }\\n        for(int i=0;i<pairs.size();i++){\\n          int x=pairs[i][0];\\n          int y=pairs[i][1];\\n          my_union(x,y,map);\\n        }\\n         unordered_map<int,priority_queue <char, vector<char>, greater<char>>>map1;\\n        for(int i=0;i<s.size();i++){\\n           int x=find(i,map);\\n          \\n           map1[x].push(s[i]);\\n        }\\n         \\n        for(int i=0;i<s.size();i++){\\n             int x=find(i,map);\\n             char a=map1[x].top();\\n             map1[x].pop();\\n             ans+=a;\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "prikarshglory",
                        "content": "Use path compression \\n"
                    }
                ]
            },
            {
                "id": 1926394,
                "content": [
                    {
                        "username": "jaedongtensor",
                        "content": "Most solutions just assume that the chars in connected components could be arranged in any order. By intuition, I think it is correct. But could anyone explain why it is always true? Is there any topic in graph theory talking about this problem? \\n"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "I\\'m getting memory limit exeeded for last test case can anyone help me fix this\\n"
                    },
                    {
                        "username": "diksha_iitian",
                        "content": "i am also getting "
                    },
                    {
                        "username": "dpacifico",
                        "content": "Is this medium for who? John von Neumann? :) Nice problem though..."
                    },
                    {
                        "username": "jd2050",
                        "content": "This is \"Medium\"?? No way"
                    },
                    {
                        "username": "aditya92",
                        "content": "How can we identify that this is a graph problem ?\\nI am not able to get the intuition behind it "
                    },
                    {
                        "username": "adam_y_w",
                        "content": "think it this way, to be able to reorder the chars you need to first know what chats are in the same group therefore can be reshuffled. The way to find the groups become typical disjoint sets question, which is a graph question "
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "IMO, in this particular case it's seen that we could have up to 10^5 pairs for swaps. It's wise to expect that it's insane to use brute force for it, and we probably need to cut down the number of swaps, so DSU comes into mind. "
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "I read somewhere here that if you find that there\\'s any transitive relation in problem, than dsu might be of some use. That advice has helped me a lot to identify dsu problems."
                    },
                    {
                        "username": "ferdinand069",
                        "content": "can anyone tell which implementation is better dfs or union find ?"
                    },
                    {
                        "username": "TKR_6",
                        "content": "Nothing is better than the other , it depends on your implementation skills. For me DFS is easy to implement."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/smallest-string-with-swaps/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Depth-First Search (DFS)\n\n  \n**Approach 2:** Disjoint Set Union (DSU)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kartikey101",
                        "content": "If you\\'re getting TLE with union find try using path compression."
                    },
                    {
                        "username": "user5418EK",
                        "content": "ERROR IN THIS??\\nRUNTIME IS COMING AT TEST CASE 30/36\\n\\nclass Solution {\\npublic:\\nchar find(int ch,unordered_map<int,int>&map){\\n     if(ch==map[ch]){\\n         return ch;\\n     }\\n     return find(map[ch],map);\\n }\\n void  my_union(int a,int b,unordered_map<int,int>&map){\\n    a=find(a,map);\\n    b=find(b,map);\\n    map[a]=b;\\n \\n\\n }\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        unordered_map<int,int>map;\\n        string ans;\\n        for(int i=0;i<s.size();i++){\\n            map[i]=i;\\n        }\\n        for(int i=0;i<pairs.size();i++){\\n          int x=pairs[i][0];\\n          int y=pairs[i][1];\\n          my_union(x,y,map);\\n        }\\n         unordered_map<int,priority_queue <char, vector<char>, greater<char>>>map1;\\n        for(int i=0;i<s.size();i++){\\n           int x=find(i,map);\\n          \\n           map1[x].push(s[i]);\\n        }\\n         \\n        for(int i=0;i<s.size();i++){\\n             int x=find(i,map);\\n             char a=map1[x].top();\\n             map1[x].pop();\\n             ans+=a;\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "prikarshglory",
                        "content": "Use path compression \\n"
                    }
                ]
            },
            {
                "id": 1781311,
                "content": [
                    {
                        "username": "jaedongtensor",
                        "content": "Most solutions just assume that the chars in connected components could be arranged in any order. By intuition, I think it is correct. But could anyone explain why it is always true? Is there any topic in graph theory talking about this problem? \\n"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "I\\'m getting memory limit exeeded for last test case can anyone help me fix this\\n"
                    },
                    {
                        "username": "diksha_iitian",
                        "content": "i am also getting "
                    },
                    {
                        "username": "dpacifico",
                        "content": "Is this medium for who? John von Neumann? :) Nice problem though..."
                    },
                    {
                        "username": "jd2050",
                        "content": "This is \"Medium\"?? No way"
                    },
                    {
                        "username": "aditya92",
                        "content": "How can we identify that this is a graph problem ?\\nI am not able to get the intuition behind it "
                    },
                    {
                        "username": "adam_y_w",
                        "content": "think it this way, to be able to reorder the chars you need to first know what chats are in the same group therefore can be reshuffled. The way to find the groups become typical disjoint sets question, which is a graph question "
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "IMO, in this particular case it's seen that we could have up to 10^5 pairs for swaps. It's wise to expect that it's insane to use brute force for it, and we probably need to cut down the number of swaps, so DSU comes into mind. "
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "I read somewhere here that if you find that there\\'s any transitive relation in problem, than dsu might be of some use. That advice has helped me a lot to identify dsu problems."
                    },
                    {
                        "username": "ferdinand069",
                        "content": "can anyone tell which implementation is better dfs or union find ?"
                    },
                    {
                        "username": "TKR_6",
                        "content": "Nothing is better than the other , it depends on your implementation skills. For me DFS is easy to implement."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/smallest-string-with-swaps/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Depth-First Search (DFS)\n\n  \n**Approach 2:** Disjoint Set Union (DSU)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kartikey101",
                        "content": "If you\\'re getting TLE with union find try using path compression."
                    },
                    {
                        "username": "user5418EK",
                        "content": "ERROR IN THIS??\\nRUNTIME IS COMING AT TEST CASE 30/36\\n\\nclass Solution {\\npublic:\\nchar find(int ch,unordered_map<int,int>&map){\\n     if(ch==map[ch]){\\n         return ch;\\n     }\\n     return find(map[ch],map);\\n }\\n void  my_union(int a,int b,unordered_map<int,int>&map){\\n    a=find(a,map);\\n    b=find(b,map);\\n    map[a]=b;\\n \\n\\n }\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        unordered_map<int,int>map;\\n        string ans;\\n        for(int i=0;i<s.size();i++){\\n            map[i]=i;\\n        }\\n        for(int i=0;i<pairs.size();i++){\\n          int x=pairs[i][0];\\n          int y=pairs[i][1];\\n          my_union(x,y,map);\\n        }\\n         unordered_map<int,priority_queue <char, vector<char>, greater<char>>>map1;\\n        for(int i=0;i<s.size();i++){\\n           int x=find(i,map);\\n          \\n           map1[x].push(s[i]);\\n        }\\n         \\n        for(int i=0;i<s.size();i++){\\n             int x=find(i,map);\\n             char a=map1[x].top();\\n             map1[x].pop();\\n             ans+=a;\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "prikarshglory",
                        "content": "Use path compression \\n"
                    }
                ]
            },
            {
                "id": 1746736,
                "content": [
                    {
                        "username": "jaedongtensor",
                        "content": "Most solutions just assume that the chars in connected components could be arranged in any order. By intuition, I think it is correct. But could anyone explain why it is always true? Is there any topic in graph theory talking about this problem? \\n"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "I\\'m getting memory limit exeeded for last test case can anyone help me fix this\\n"
                    },
                    {
                        "username": "diksha_iitian",
                        "content": "i am also getting "
                    },
                    {
                        "username": "dpacifico",
                        "content": "Is this medium for who? John von Neumann? :) Nice problem though..."
                    },
                    {
                        "username": "jd2050",
                        "content": "This is \"Medium\"?? No way"
                    },
                    {
                        "username": "aditya92",
                        "content": "How can we identify that this is a graph problem ?\\nI am not able to get the intuition behind it "
                    },
                    {
                        "username": "adam_y_w",
                        "content": "think it this way, to be able to reorder the chars you need to first know what chats are in the same group therefore can be reshuffled. The way to find the groups become typical disjoint sets question, which is a graph question "
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "IMO, in this particular case it's seen that we could have up to 10^5 pairs for swaps. It's wise to expect that it's insane to use brute force for it, and we probably need to cut down the number of swaps, so DSU comes into mind. "
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "I read somewhere here that if you find that there\\'s any transitive relation in problem, than dsu might be of some use. That advice has helped me a lot to identify dsu problems."
                    },
                    {
                        "username": "ferdinand069",
                        "content": "can anyone tell which implementation is better dfs or union find ?"
                    },
                    {
                        "username": "TKR_6",
                        "content": "Nothing is better than the other , it depends on your implementation skills. For me DFS is easy to implement."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/smallest-string-with-swaps/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Depth-First Search (DFS)\n\n  \n**Approach 2:** Disjoint Set Union (DSU)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kartikey101",
                        "content": "If you\\'re getting TLE with union find try using path compression."
                    },
                    {
                        "username": "user5418EK",
                        "content": "ERROR IN THIS??\\nRUNTIME IS COMING AT TEST CASE 30/36\\n\\nclass Solution {\\npublic:\\nchar find(int ch,unordered_map<int,int>&map){\\n     if(ch==map[ch]){\\n         return ch;\\n     }\\n     return find(map[ch],map);\\n }\\n void  my_union(int a,int b,unordered_map<int,int>&map){\\n    a=find(a,map);\\n    b=find(b,map);\\n    map[a]=b;\\n \\n\\n }\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        unordered_map<int,int>map;\\n        string ans;\\n        for(int i=0;i<s.size();i++){\\n            map[i]=i;\\n        }\\n        for(int i=0;i<pairs.size();i++){\\n          int x=pairs[i][0];\\n          int y=pairs[i][1];\\n          my_union(x,y,map);\\n        }\\n         unordered_map<int,priority_queue <char, vector<char>, greater<char>>>map1;\\n        for(int i=0;i<s.size();i++){\\n           int x=find(i,map);\\n          \\n           map1[x].push(s[i]);\\n        }\\n         \\n        for(int i=0;i<s.size();i++){\\n             int x=find(i,map);\\n             char a=map1[x].top();\\n             map1[x].pop();\\n             ans+=a;\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "prikarshglory",
                        "content": "Use path compression \\n"
                    }
                ]
            },
            {
                "id": 1573065,
                "content": [
                    {
                        "username": "jaedongtensor",
                        "content": "Most solutions just assume that the chars in connected components could be arranged in any order. By intuition, I think it is correct. But could anyone explain why it is always true? Is there any topic in graph theory talking about this problem? \\n"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "I\\'m getting memory limit exeeded for last test case can anyone help me fix this\\n"
                    },
                    {
                        "username": "diksha_iitian",
                        "content": "i am also getting "
                    },
                    {
                        "username": "dpacifico",
                        "content": "Is this medium for who? John von Neumann? :) Nice problem though..."
                    },
                    {
                        "username": "jd2050",
                        "content": "This is \"Medium\"?? No way"
                    },
                    {
                        "username": "aditya92",
                        "content": "How can we identify that this is a graph problem ?\\nI am not able to get the intuition behind it "
                    },
                    {
                        "username": "adam_y_w",
                        "content": "think it this way, to be able to reorder the chars you need to first know what chats are in the same group therefore can be reshuffled. The way to find the groups become typical disjoint sets question, which is a graph question "
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "IMO, in this particular case it's seen that we could have up to 10^5 pairs for swaps. It's wise to expect that it's insane to use brute force for it, and we probably need to cut down the number of swaps, so DSU comes into mind. "
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "I read somewhere here that if you find that there\\'s any transitive relation in problem, than dsu might be of some use. That advice has helped me a lot to identify dsu problems."
                    },
                    {
                        "username": "ferdinand069",
                        "content": "can anyone tell which implementation is better dfs or union find ?"
                    },
                    {
                        "username": "TKR_6",
                        "content": "Nothing is better than the other , it depends on your implementation skills. For me DFS is easy to implement."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/smallest-string-with-swaps/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Depth-First Search (DFS)\n\n  \n**Approach 2:** Disjoint Set Union (DSU)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kartikey101",
                        "content": "If you\\'re getting TLE with union find try using path compression."
                    },
                    {
                        "username": "user5418EK",
                        "content": "ERROR IN THIS??\\nRUNTIME IS COMING AT TEST CASE 30/36\\n\\nclass Solution {\\npublic:\\nchar find(int ch,unordered_map<int,int>&map){\\n     if(ch==map[ch]){\\n         return ch;\\n     }\\n     return find(map[ch],map);\\n }\\n void  my_union(int a,int b,unordered_map<int,int>&map){\\n    a=find(a,map);\\n    b=find(b,map);\\n    map[a]=b;\\n \\n\\n }\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        unordered_map<int,int>map;\\n        string ans;\\n        for(int i=0;i<s.size();i++){\\n            map[i]=i;\\n        }\\n        for(int i=0;i<pairs.size();i++){\\n          int x=pairs[i][0];\\n          int y=pairs[i][1];\\n          my_union(x,y,map);\\n        }\\n         unordered_map<int,priority_queue <char, vector<char>, greater<char>>>map1;\\n        for(int i=0;i<s.size();i++){\\n           int x=find(i,map);\\n          \\n           map1[x].push(s[i]);\\n        }\\n         \\n        for(int i=0;i<s.size();i++){\\n             int x=find(i,map);\\n             char a=map1[x].top();\\n             map1[x].pop();\\n             ans+=a;\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "prikarshglory",
                        "content": "Use path compression \\n"
                    }
                ]
            },
            {
                "id": 1567128,
                "content": [
                    {
                        "username": "jaedongtensor",
                        "content": "Most solutions just assume that the chars in connected components could be arranged in any order. By intuition, I think it is correct. But could anyone explain why it is always true? Is there any topic in graph theory talking about this problem? \\n"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "I\\'m getting memory limit exeeded for last test case can anyone help me fix this\\n"
                    },
                    {
                        "username": "diksha_iitian",
                        "content": "i am also getting "
                    },
                    {
                        "username": "dpacifico",
                        "content": "Is this medium for who? John von Neumann? :) Nice problem though..."
                    },
                    {
                        "username": "jd2050",
                        "content": "This is \"Medium\"?? No way"
                    },
                    {
                        "username": "aditya92",
                        "content": "How can we identify that this is a graph problem ?\\nI am not able to get the intuition behind it "
                    },
                    {
                        "username": "adam_y_w",
                        "content": "think it this way, to be able to reorder the chars you need to first know what chats are in the same group therefore can be reshuffled. The way to find the groups become typical disjoint sets question, which is a graph question "
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "IMO, in this particular case it's seen that we could have up to 10^5 pairs for swaps. It's wise to expect that it's insane to use brute force for it, and we probably need to cut down the number of swaps, so DSU comes into mind. "
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "I read somewhere here that if you find that there\\'s any transitive relation in problem, than dsu might be of some use. That advice has helped me a lot to identify dsu problems."
                    },
                    {
                        "username": "ferdinand069",
                        "content": "can anyone tell which implementation is better dfs or union find ?"
                    },
                    {
                        "username": "TKR_6",
                        "content": "Nothing is better than the other , it depends on your implementation skills. For me DFS is easy to implement."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/smallest-string-with-swaps/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Depth-First Search (DFS)\n\n  \n**Approach 2:** Disjoint Set Union (DSU)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kartikey101",
                        "content": "If you\\'re getting TLE with union find try using path compression."
                    },
                    {
                        "username": "user5418EK",
                        "content": "ERROR IN THIS??\\nRUNTIME IS COMING AT TEST CASE 30/36\\n\\nclass Solution {\\npublic:\\nchar find(int ch,unordered_map<int,int>&map){\\n     if(ch==map[ch]){\\n         return ch;\\n     }\\n     return find(map[ch],map);\\n }\\n void  my_union(int a,int b,unordered_map<int,int>&map){\\n    a=find(a,map);\\n    b=find(b,map);\\n    map[a]=b;\\n \\n\\n }\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        unordered_map<int,int>map;\\n        string ans;\\n        for(int i=0;i<s.size();i++){\\n            map[i]=i;\\n        }\\n        for(int i=0;i<pairs.size();i++){\\n          int x=pairs[i][0];\\n          int y=pairs[i][1];\\n          my_union(x,y,map);\\n        }\\n         unordered_map<int,priority_queue <char, vector<char>, greater<char>>>map1;\\n        for(int i=0;i<s.size();i++){\\n           int x=find(i,map);\\n          \\n           map1[x].push(s[i]);\\n        }\\n         \\n        for(int i=0;i<s.size();i++){\\n             int x=find(i,map);\\n             char a=map1[x].top();\\n             map1[x].pop();\\n             ans+=a;\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "prikarshglory",
                        "content": "Use path compression \\n"
                    }
                ]
            },
            {
                "id": 2017965,
                "content": [
                    {
                        "username": "jaedongtensor",
                        "content": "Most solutions just assume that the chars in connected components could be arranged in any order. By intuition, I think it is correct. But could anyone explain why it is always true? Is there any topic in graph theory talking about this problem? \\n"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "I\\'m getting memory limit exeeded for last test case can anyone help me fix this\\n"
                    },
                    {
                        "username": "diksha_iitian",
                        "content": "i am also getting "
                    },
                    {
                        "username": "dpacifico",
                        "content": "Is this medium for who? John von Neumann? :) Nice problem though..."
                    },
                    {
                        "username": "jd2050",
                        "content": "This is \"Medium\"?? No way"
                    },
                    {
                        "username": "aditya92",
                        "content": "How can we identify that this is a graph problem ?\\nI am not able to get the intuition behind it "
                    },
                    {
                        "username": "adam_y_w",
                        "content": "think it this way, to be able to reorder the chars you need to first know what chats are in the same group therefore can be reshuffled. The way to find the groups become typical disjoint sets question, which is a graph question "
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "IMO, in this particular case it's seen that we could have up to 10^5 pairs for swaps. It's wise to expect that it's insane to use brute force for it, and we probably need to cut down the number of swaps, so DSU comes into mind. "
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "I read somewhere here that if you find that there\\'s any transitive relation in problem, than dsu might be of some use. That advice has helped me a lot to identify dsu problems."
                    },
                    {
                        "username": "ferdinand069",
                        "content": "can anyone tell which implementation is better dfs or union find ?"
                    },
                    {
                        "username": "TKR_6",
                        "content": "Nothing is better than the other , it depends on your implementation skills. For me DFS is easy to implement."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/smallest-string-with-swaps/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Depth-First Search (DFS)\n\n  \n**Approach 2:** Disjoint Set Union (DSU)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kartikey101",
                        "content": "If you\\'re getting TLE with union find try using path compression."
                    },
                    {
                        "username": "user5418EK",
                        "content": "ERROR IN THIS??\\nRUNTIME IS COMING AT TEST CASE 30/36\\n\\nclass Solution {\\npublic:\\nchar find(int ch,unordered_map<int,int>&map){\\n     if(ch==map[ch]){\\n         return ch;\\n     }\\n     return find(map[ch],map);\\n }\\n void  my_union(int a,int b,unordered_map<int,int>&map){\\n    a=find(a,map);\\n    b=find(b,map);\\n    map[a]=b;\\n \\n\\n }\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        unordered_map<int,int>map;\\n        string ans;\\n        for(int i=0;i<s.size();i++){\\n            map[i]=i;\\n        }\\n        for(int i=0;i<pairs.size();i++){\\n          int x=pairs[i][0];\\n          int y=pairs[i][1];\\n          my_union(x,y,map);\\n        }\\n         unordered_map<int,priority_queue <char, vector<char>, greater<char>>>map1;\\n        for(int i=0;i<s.size();i++){\\n           int x=find(i,map);\\n          \\n           map1[x].push(s[i]);\\n        }\\n         \\n        for(int i=0;i<s.size();i++){\\n             int x=find(i,map);\\n             char a=map1[x].top();\\n             map1[x].pop();\\n             ans+=a;\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "prikarshglory",
                        "content": "Use path compression \\n"
                    }
                ]
            },
            {
                "id": 1761411,
                "content": [
                    {
                        "username": "jaedongtensor",
                        "content": "Most solutions just assume that the chars in connected components could be arranged in any order. By intuition, I think it is correct. But could anyone explain why it is always true? Is there any topic in graph theory talking about this problem? \\n"
                    },
                    {
                        "username": "Saiteja6",
                        "content": "I\\'m getting memory limit exeeded for last test case can anyone help me fix this\\n"
                    },
                    {
                        "username": "diksha_iitian",
                        "content": "i am also getting "
                    },
                    {
                        "username": "dpacifico",
                        "content": "Is this medium for who? John von Neumann? :) Nice problem though..."
                    },
                    {
                        "username": "jd2050",
                        "content": "This is \"Medium\"?? No way"
                    },
                    {
                        "username": "aditya92",
                        "content": "How can we identify that this is a graph problem ?\\nI am not able to get the intuition behind it "
                    },
                    {
                        "username": "adam_y_w",
                        "content": "think it this way, to be able to reorder the chars you need to first know what chats are in the same group therefore can be reshuffled. The way to find the groups become typical disjoint sets question, which is a graph question "
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "IMO, in this particular case it's seen that we could have up to 10^5 pairs for swaps. It's wise to expect that it's insane to use brute force for it, and we probably need to cut down the number of swaps, so DSU comes into mind. "
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "I read somewhere here that if you find that there\\'s any transitive relation in problem, than dsu might be of some use. That advice has helped me a lot to identify dsu problems."
                    },
                    {
                        "username": "ferdinand069",
                        "content": "can anyone tell which implementation is better dfs or union find ?"
                    },
                    {
                        "username": "TKR_6",
                        "content": "Nothing is better than the other , it depends on your implementation skills. For me DFS is easy to implement."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/smallest-string-with-swaps/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Depth-First Search (DFS)\n\n  \n**Approach 2:** Disjoint Set Union (DSU)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "kartikey101",
                        "content": "If you\\'re getting TLE with union find try using path compression."
                    },
                    {
                        "username": "user5418EK",
                        "content": "ERROR IN THIS??\\nRUNTIME IS COMING AT TEST CASE 30/36\\n\\nclass Solution {\\npublic:\\nchar find(int ch,unordered_map<int,int>&map){\\n     if(ch==map[ch]){\\n         return ch;\\n     }\\n     return find(map[ch],map);\\n }\\n void  my_union(int a,int b,unordered_map<int,int>&map){\\n    a=find(a,map);\\n    b=find(b,map);\\n    map[a]=b;\\n \\n\\n }\\n    string smallestStringWithSwaps(string s, vector<vector<int>>& pairs) {\\n        unordered_map<int,int>map;\\n        string ans;\\n        for(int i=0;i<s.size();i++){\\n            map[i]=i;\\n        }\\n        for(int i=0;i<pairs.size();i++){\\n          int x=pairs[i][0];\\n          int y=pairs[i][1];\\n          my_union(x,y,map);\\n        }\\n         unordered_map<int,priority_queue <char, vector<char>, greater<char>>>map1;\\n        for(int i=0;i<s.size();i++){\\n           int x=find(i,map);\\n          \\n           map1[x].push(s[i]);\\n        }\\n         \\n        for(int i=0;i<s.size();i++){\\n             int x=find(i,map);\\n             char a=map1[x].top();\\n             map1[x].pop();\\n             ans+=a;\\n        }\\n\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "prikarshglory",
                        "content": "Use path compression \\n"
                    }
                ]
            }
        ]
    }
]