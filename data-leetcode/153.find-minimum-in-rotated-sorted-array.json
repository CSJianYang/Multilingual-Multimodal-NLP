[
    {
        "title": "Maximum Subarray",
        "question_content": "Given an integer array nums, find the subarray with the largest sum, and return its sum.\n&nbsp;\nExample 1:\n\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\n\nExample 2:\n\nInput: nums = [1]\nOutput: 1\nExplanation: The subarray [1] has the largest sum 1.\n\nExample 3:\n\nInput: nums = [5,4,-1,7,8]\nOutput: 23\nExplanation: The subarray [5,4,-1,7,8] has the largest sum 23.\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\t-104 <= nums[i] <= 104\n\n&nbsp;\nFollow up: If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.",
        "solutions": [
            {
                "id": 20193,
                "title": "dp-solution-some-thoughts",
                "content": "Analysis of this problem:\\n Apparently, this is a optimization problem, which can be usually solved by DP. So when it comes to DP, the first thing for us to figure out is the format of the sub problem(or the state of each sub problem).  The format of the sub problem can be helpful when we are trying to come up with the recursive relation. \\n\\nAt first, I think the sub problem should look like: `maxSubArray(int A[], int i, int j)`, which means the maxSubArray for A[i: j]. In this way, our goal is to figure out what `maxSubArray(A, 0, A.length - 1)` is. However, if we define the format of the sub problem in this way, it's hard to find the connection from the sub problem to the original problem(at least for me). In other words, I can't find a way to divided the original problem into the sub problems and use the solutions of the sub problems to somehow create the solution of the original one. \\n\\nSo I change the format of the sub problem into something like: `maxSubArray(int A[], int i)`, which means the maxSubArray for A[0:i ] which must has A[i] as the end element. Note that now the sub problem's format is less flexible and less powerful than the previous one because there's a limitation that A[i] should be contained in that sequence and we have to keep track of each solution of the sub problem to update the global optimal value. However, now the connect between the sub problem & the original one becomes clearer:\\n \\n\\n    maxSubArray(A, i) = maxSubArray(A, i - 1) > 0 ? maxSubArray(A, i - 1) : 0 + A[i]; \\n\\nAnd here's the code\\n\\n    public int maxSubArray(int[] A) {\\n            int n = A.length;\\n            int[] dp = new int[n];//dp[i] means the maximum subarray ending with A[i];\\n            dp[0] = A[0];\\n            int max = dp[0];\\n            \\n            for(int i = 1; i < n; i++){\\n                dp[i] = A[i] + (dp[i - 1] > 0 ? dp[i - 1] : 0);\\n                max = Math.max(max, dp[i]);\\n            }\\n            \\n            return max;\\n    }",
                "solutionTags": [],
                "code": "Analysis of this problem:\\n Apparently, this is a optimization problem, which can be usually solved by DP. So when it comes to DP, the first thing for us to figure out is the format of the sub problem(or the state of each sub problem).  The format of the sub problem can be helpful when we are trying to come up with the recursive relation. \\n\\nAt first, I think the sub problem should look like: `maxSubArray(int A[], int i, int j)`, which means the maxSubArray for A[i: j]. In this way, our goal is to figure out what `maxSubArray(A, 0, A.length - 1)` is. However, if we define the format of the sub problem in this way, it's hard to find the connection from the sub problem to the original problem(at least for me). In other words, I can't find a way to divided the original problem into the sub problems and use the solutions of the sub problems to somehow create the solution of the original one. \\n\\nSo I change the format of the sub problem into something like: `maxSubArray(int A[], int i)`, which means the maxSubArray for A[0:i ] which must has A[i] as the end element. Note that now the sub problem's format is less flexible and less powerful than the previous one because there's a limitation that A[i] should be contained in that sequence and we have to keep track of each solution of the sub problem to update the global optimal value. However, now the connect between the sub problem & the original one becomes clearer:\\n \\n\\n    maxSubArray(A, i) = maxSubArray(A, i - 1) > 0 ? maxSubArray(A, i - 1) : 0 + A[i]; \\n\\nAnd here's the code\\n\\n    public int maxSubArray(int[] A) {\\n            int n = A.length;\\n            int[] dp = new int[n];//dp[i] means the maximum subarray ending with A[i];\\n            dp[0] = A[0];\\n            int max = dp[0];\\n            \\n            for(int i = 1; i < n; i++){\\n                dp[i] = A[i] + (dp[i - 1] > 0 ? dp[i - 1] : 0);\\n                max = Math.max(max, dp[i]);\\n            }\\n            \\n            return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1595195,
                "title": "c-python-7-simple-solutions-w-explanation-brute-force-dp-kadane-divide-conquer",
                "content": "We are given an array `nums` and we need to return the maximum sum of a subarray in `nums`.\\n\\n---\\n\\n\\u274C ***Solution - I (Brute-Force) [TLE]***\\n\\nWe can start with brute-force by trying out every possible sub-array in `nums` and choosing the one with maximum sum.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int n = size(nums), ans = INT_MIN;\\n        for(int i = 0; i < n; i++) \\n            for(int j = i, curSum = 0; j < n ; j++) \\n                curSum += nums[j],\\n                ans = max(ans, curSum);        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums):\\n        ans = -inf\\n        for i in range(len(nums)):\\n            cur_sum = 0\\n            for j in range(i, len(nums)):\\n                cur_sum += nums[j]\\n                ans = max(ans, cur_sum)\\n        return ans\\n```\\n\\n\\n***Time Complexity :*** <code>O(N<sup>2</sup>)</code>, where  `N` is the number of elements in `nums`. There are `N*(N+1)/2` total sub-arrays and trying out each one takes time of <code>O(N<sup>2</sup>)</code>\\n***Space Complexity :*** `O(1)`\\n\\n---\\n\\n\\u274C ***Solution - II (Recursive) [TLE]***\\n\\nAnother way to consider every subarray and return the one that has maximum sum is using recursive approach. Here we can state the approach as -\\n* At each index `i`, we can either pick that element or not pick it.\\n* If we pick current element, then all future element must also be picked since our array needs to be contiguous.\\n* If we had picked any elements till now, we can either end further recursion at any time by returning sum formed till now or we can choose current element and recurse further. This denotes two choices of either choosing the subarray formed from 1st picked element till now or expanding the subarray by choosing current element respectively.\\n\\nIn the code below, we will use `mustPick` to denote whether we must compulsorily pick current element. When `mustPick` is true, we must either return `0` or pick current element and recurse further. If `pickCur` is false, we have both choices of not picking current element and moving on to next element, or picking the current one.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {    \\n        return solve(nums, 0, false);\\n    }\\n    int solve(vector<int>& A, int i, bool mustPick) {\\n\\t\\t// our subarray must contain atleast 1 element. If mustPick is false at end means no element is picked and this is not valid case\\n        if(i >= size(A)) return mustPick ? 0 : -1e5;       \\n        if(mustPick)\\n            return max(0, A[i] + solve(A, i+1, true));                  // either stop here or choose current element and recurse\\n        return max(solve(A, i+1, false), A[i] + solve(A, i+1, true));   // try both choosing current element or not choosing\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums):\\n        def solve(i, must_pick):\\n            if i >= len(nums): return 0 if must_pick else -inf\\n            return max(nums[i] + solve(i+1, True), 0 if must_pick else solve(i+1, False))\\n        return solve(0, False)\\n```\\n\\n***Time Complexity :*** <code>O(N<sup>2</sup>)</code>, we are basically considering every subarray sum and choosing maximum of it. \\n***Space Complexity :*** `O(N)`, for recursive space\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Dynamic Programming - Memoization)***\\n\\nWe can observe a lot of repeated calculations if we draw out the recursive tree for above solution -\\n\\n```python\\n                                                f(0, False)                       \\uD83D\\uDD3D => repeated calculations\\n\\t\\t\\t\\t\\t                          /             \\\\ \\n                       \\t\\t       f(1, False)              f(1, True)\\n\\t\\t\\t                      /          \\\\       \\uD83D\\uDD3D          \\\\      \\uD83D\\uDD3D\\n\\t\\t\\t                 f(2, False)      f(2, True)           f(2, True)\\n\\t\\t\\t\\t\\t\\t\\t/            \\\\  \\uD83D\\uDD3D       \\\\   \\uD83D\\uDD3D           \\\\  \\uD83D\\uDD3D\\n\\t\\t\\t\\t\\t\\tf(3, False)   f(3,True)     f(3, True)           f(3, True)\\n\\t\\t\\t\\t\\t\\t/        \\\\            \\\\           \\\\                  \\\\\\n\\t\\t\\t\\t      ...        ...          ...         ...                ...\\n```\\n\\nThese redundant calculations can be eliminated if we store the results for a given state and reuse them later whenever required rather than recalculating them over and over again. \\n\\nThus, we can use memoization technique here to make our solution more efficient. Here, we use a `dp` array where `dp[mustPick][i]` denotes the maximum sum subarray starting from `i` and `mustPick` denotes wheter the current element must be picked compulsorily or not.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {    \\n        vector<vector<int>> dp(2, vector<int>(size(nums), -1));\\n        return solve(nums, 0, false, dp);\\n    }\\n    int solve(vector<int>& A, int i, bool mustPick, vector<vector<int>>& dp) {\\n        if(i >= size(A)) return mustPick ? 0 : -1e5;\\n        if(dp[mustPick][i] != -1) return dp[mustPick][i];\\n        if(mustPick)\\n            return dp[mustPick][i] = max(0, A[i] + solve(A, i+1, true, dp));\\n        return dp[mustPick][i] = max(solve(A, i+1, false, dp), A[i] + solve(A, i+1, true, dp));\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums):\\n        @cache\\n        def solve(i, must_pick):\\n            if i >= len(nums): return 0 if must_pick else -inf\\n            return max(nums[i] + solve(i+1, True), 0 if must_pick else solve(i+1, False))\\n        return solve(0, False)\\n```\\n\\n***Time Complexity :*** <code>O(N)</code>, we are calculating each state of the `dp` just once and memoizing the result. Thus, we are calculating results for `2*N` states and returning them directly in future recursive calls.\\n***Space Complexity :*** `O(N)`, for recursive space\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - IV (Dynamic Programming - Tabulation)***\\n\\nWe can employ similar logic in iterative version as well. Here, we again use `dp` array and use bottom-up approach. Here `dp[1][i]` denotes maximum subarray sum ending at `i` (including `nums[i]`) and `dp[0][i]` denotes maximum subarray sum upto `i` (may or may not include `nums[i]`). \\n\\nAt each index, we update `dp[1][i]` as max between either only choosing current element - `nums[i]` or extending from previous subarray and choosing current element as well - `dp[1][i-1] + nums[i]`\\nSimilarly, `dp[0][1]` can be updated as max between maximum sum subarray found till last index - `dp[0][i-1]` or max subarray sum found ending at current index `dp[1][i]`.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        vector<vector<int>> dp(2, vector<int>(size(nums)));\\n        dp[0][0] = dp[1][0] = nums[0];\\n        for(int i = 1; i < size(nums); i++) {\\n            dp[1][i] = max(nums[i], nums[i] + dp[1][i-1]);\\n            dp[0][i] = max(dp[0][i-1], dp[1][i]);\\n        }\\n        return dp[0].back();\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums):\\n        dp = [[0]*len(nums) for i in range(2)]\\n        dp[0][0], dp[1][0] = nums[0], nums[0]\\n        for i in range(1, len(nums)):\\n            dp[1][i] = max(nums[i], nums[i] + dp[1][i-1])\\n            dp[0][i] = max(dp[0][i-1], dp[1][i])\\n        return dp[0][-1]\\n```\\n\\nWe can actually do away with just 1 row as well. We denoted `dp[1][i]` as the maximum subarray sum ending at `i`. We can just store that row and calculate the overall maximum subarray sum at the end by choosing the maximum of all max subarray sum ending at `i`.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        vector<int> dp(nums);\\n        for(int i = 1; i < size(nums); i++) \\n            dp[i] = max(nums[i], nums[i] + dp[i-1]);        \\n        return *max_element(begin(dp), end(dp));\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums):\\n        dp = [*nums]\\n        for i in range(1, len(nums)):\\n            dp[i] = max(nums[i], nums[i] + dp[i-1])\\n        return max(dp)\\n```\\n\\n***Time Complexity :*** <code>O(N)</code>, we are just iterating over the `nums` array once to compute the `dp` array and once more over the `dp` at the end to find maximum subarray sum. Thus overall time complexity is `O(N) + O(N) = O(N)`\\n***Space Complexity :*** `O(N)`, for maintaining `dp`.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - V (Kadane\\'s Algorithm)***\\n\\nWe can observe that in the previous approach, `dp[i]` only depended on `dp[i-1]`. So do we really need to maintain the whole `dp` array of `N` elements? One might see the last line of previous solution and say that we needed all elements of `dp` at the end to find the maximum sum subarray. But we can simply optimize that by storing the max at each iteration instead of separately calculating it at the end.\\n\\nThus, we only need to maintain `curMax` which is the maximum subarray sum ending at `i` and `maxTillNow` which is the maximum sum we have seen till now. And this way of solving this problem is what we popularly know as **Kadane\\'s Algorithm**\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int curMax = 0, maxTillNow = INT_MIN;\\n        for(auto c : nums)\\n            curMax = max(c, curMax + c),\\n            maxTillNow = max(maxTillNow, curMax);\\n        return maxTillNow;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums):\\n        cur_max, max_till_now = 0, -inf\\n        for c in nums:\\n            cur_max = max(c, cur_max + c)\\n            max_till_now = max(max_till_now, cur_max)\\n        return max_till_now\\n```\\n\\n***Time Complexity :*** <code>O(N)</code>, for iterating over `nums` once\\n***Space Complexity :*** `O(1)`, only constant extra space is being used.\\n\\n*PS:* I have tried running `Solution - IV` and this solution multiple times and this solution, despite being `O(1)` shows higher memory usage(`28.8 MB` on average vs `28 MB` used by solution - IV) by LC consistently. If anyone can figure out the reason behind this, I will be happy to hear it out :)\\n\\n---\\n\\n\\n\\u2714\\uFE0F ***Solution - VI (Divide & Conquer)***\\n\\nWe can solve this using divide and conquer strategy. This is the follow-up question asked in this question. This involves modelling the problem by observing that the maximum subarray sum is such that it lies somewhere -\\n\\n* entirely in the left-half of array `[L, mid-1]`, OR\\n* entirely in the right-half of array `[mid+1, R]`, OR\\n* in array consisting of mid element along with some part of left-half and some part of right-half such that these form contiguous subarray - <code>[L\\', R\\'] = [L\\', mid-1] + [mid] + [mid+1,R\\']</code>, where `L\\' >= L` and `R\\' <= R`\\n\\nWith the above observation, we can recursively divide the array into sub-problems on the left and right halves and then combine these results on the way back up to find the maximum subarray sum.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        return maxSubArray(nums, 0, size(nums)-1);\\n    }\\n    int maxSubArray(vector<int>& A, int L, int R){\\n        if(L > R) return INT_MIN;\\n        int mid = (L + R) / 2, leftSum = 0, rightSum = 0;\\n        // leftSum = max subarray sum in [L, mid-1] and starting from mid-1\\n        for(int i = mid-1, curSum = 0; i >= L; i--)\\n            curSum += A[i],\\n            leftSum=max(leftSum, curSum);\\n        // rightSum = max subarray sum in [mid+1, R] and starting from mid+1\\n        for(int i = mid+1, curSum = 0; i <= R; i++)\\n            curSum += A[i],\\n            rightSum = max(rightSum, curSum);        \\n\\t\\t// return max of 3 cases \\n        return max({ maxSubArray(A, L, mid-1), maxSubArray(A, mid+1, R), leftSum + A[mid] + rightSum });\\n    }\\t\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums):\\n        def maxSubArray(A, L, R):\\n            if L > R: return -inf\\n            mid, left_sum, right_sum, cur_sum = (L + R) // 2, 0, 0, 0\\n            for i in range(mid-1, L-1, -1):\\n                left_sum = max(left_sum, cur_sum := cur_sum + A[i])\\n            cur_sum = 0\\n            for i in range(mid+1, R+1):\\n                right_sum = max(right_sum, cur_sum := cur_sum + A[i])\\n            return max(maxSubArray(A, L, mid-1), maxSubArray(A, mid+1, R), left_sum + A[mid] + right_sum)\\n        return maxSubArray(nums, 0, len(nums)-1)\\n```\\n\\n***Time Complexity :*** <code>O(NlogN)</code>, the recurrence relation can be written as `T(N) = 2T(N/2) + O(N)` since we are recurring for left and right half (`2T(N/2)`) and also calculating maximal subarray including mid element which takes `O(N)` to calculate. Solving this recurrence using master theorem, we can get the time complexity as `O(NlogN)`\\n***Space Complexity :*** `O(logN)`, required by recursive stack\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - VII (Optimized Divide & Conquer)***\\n\\nWe can further optimize the previous solution. The `O(N)` term in the recurrence relation of previous solution was due to computation of max sum subarray involving `nums[mid]` in each recursion. \\n\\nBut we can reduce that term to `O(1)` if we precompute it. This can be done by precomputing two arrays `pre` and `suf` where `pre[i]` will denote maximum sum subarray ending at `i` and `suf[i]` denotes the maximum subarray starting at `i`. `pre` is similar to `dp` array that we computed in dynamic programming solutions and `suf` can be calculated in similar way, just by starting iteration from the end.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> pre, suf;\\n    int maxSubArray(vector<int>& nums) {\\n        pre = suf = nums;\\n        for(int i = 1; i < size(nums); i++)  pre[i] += max(0, pre[i-1]);\\n        for(int i = size(nums)-2; ~i; i--)   suf[i] += max(0, suf[i+1]);\\n        return maxSubArray(nums, 0, size(nums)-1);\\n    }\\n    int maxSubArray(vector<int>& A, int L, int R){\\n        if(L == R) return A[L];\\n        int mid = (L + R) / 2;\\n        return max({ maxSubArray(A, L, mid), maxSubArray(A, mid+1, R), pre[mid] + suf[mid+1] });\\n    }\\t\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums):\\n        pre, suf = [*nums], [*nums]\\n        for i in range(1, len(nums)):       pre[i] += max(0, pre[i-1])\\n        for i in range(len(nums)-2,-1,-1):  suf[i] += max(0, suf[i+1])\\n        def maxSubArray(A, L, R):\\n            if L == R: return A[L]\\n            mid = (L + R) // 2\\n            return max(maxSubArray(A, L, mid), maxSubArray(A, mid+1, R), pre[mid] + suf[mid+1])\\n        return maxSubArray(nums, 0, len(nums)-1)\\n```\\n\\n***Time Complexity :*** <code>O(N)</code>, the recurrence relation can be written as `T(N) = 2T(N/2) + O(1)` since we are recurring for left and right half (`2T(N/2)`) and calculating maximal subarray including mid element in `O(1)`. Solving this recurrence using master theorem, we can get the time complexity as `O(N)`\\n***Space Complexity :*** `O(N)`, required by `suf` and `pre`.\\n\\n---\\n\\n\\uD83D\\uDCA1  **Note:**\\n* The above divide and conquer solution works in `O(N)` but is **once you have calculated `pre` and `suf`, does it even make sense to go into divide and conquer approach?** I dont think divide and conquer approach after calculating `pre` & `suf`is useful, unless you Really want to solve it using **\\u275DDivde and Conquer\\u275E only**. You can instead do the following (which is similar to dp)- \\n\\n\\t```cpp\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxSubArray(vector<int>& nums) {\\n\\t\\t\\tvector<int> pre = nums;\\n\\t\\t\\tfor(int i = 1; i < size(nums); i++) pre[i] += max(0, pre[i-1]);\\n\\t\\t\\treturn *max_element(begin(pre), end(pre));\\n\\t\\t}\\n\\t};\\n\\t```\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int n = size(nums), ans = INT_MIN;\\n        for(int i = 0; i < n; i++) \\n            for(int j = i, curSum = 0; j < n ; j++) \\n                curSum += nums[j],\\n                ans = max(ans, curSum);        \\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def maxSubArray(self, nums):\\n        ans = -inf\\n        for i in range(len(nums)):\\n            cur_sum = 0\\n            for j in range(i, len(nums)):\\n                cur_sum += nums[j]\\n                ans = max(ans, cur_sum)\\n        return ans\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {    \\n        return solve(nums, 0, false);\\n    }\\n    int solve(vector<int>& A, int i, bool mustPick) {\\n\\t\\t// our subarray must contain atleast 1 element. If mustPick is false at end means no element is picked and this is not valid case\\n        if(i >= size(A)) return mustPick ? 0 : -1e5;       \\n        if(mustPick)\\n            return max(0, A[i] + solve(A, i+1, true));                  // either stop here or choose current element and recurse\\n        return max(solve(A, i+1, false), A[i] + solve(A, i+1, true));   // try both choosing current element or not choosing\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def maxSubArray(self, nums):\\n        def solve(i, must_pick):\\n            if i >= len(nums): return 0 if must_pick else -inf\\n            return max(nums[i] + solve(i+1, True), 0 if must_pick else solve(i+1, False))\\n        return solve(0, False)\\n```\n```python\\n                                                f(0, False)                       \\uD83D\\uDD3D => repeated calculations\\n\\t\\t\\t\\t\\t                          /             \\\\ \\n                       \\t\\t       f(1, False)              f(1, True)\\n\\t\\t\\t                      /          \\\\       \\uD83D\\uDD3D          \\\\      \\uD83D\\uDD3D\\n\\t\\t\\t                 f(2, False)      f(2, True)           f(2, True)\\n\\t\\t\\t\\t\\t\\t\\t/            \\\\  \\uD83D\\uDD3D       \\\\   \\uD83D\\uDD3D           \\\\  \\uD83D\\uDD3D\\n\\t\\t\\t\\t\\t\\tf(3, False)   f(3,True)     f(3, True)           f(3, True)\\n\\t\\t\\t\\t\\t\\t/        \\\\            \\\\           \\\\                  \\\\\\n\\t\\t\\t\\t      ...        ...          ...         ...                ...\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {    \\n        vector<vector<int>> dp(2, vector<int>(size(nums), -1));\\n        return solve(nums, 0, false, dp);\\n    }\\n    int solve(vector<int>& A, int i, bool mustPick, vector<vector<int>>& dp) {\\n        if(i >= size(A)) return mustPick ? 0 : -1e5;\\n        if(dp[mustPick][i] != -1) return dp[mustPick][i];\\n        if(mustPick)\\n            return dp[mustPick][i] = max(0, A[i] + solve(A, i+1, true, dp));\\n        return dp[mustPick][i] = max(solve(A, i+1, false, dp), A[i] + solve(A, i+1, true, dp));\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def maxSubArray(self, nums):\\n        @cache\\n        def solve(i, must_pick):\\n            if i >= len(nums): return 0 if must_pick else -inf\\n            return max(nums[i] + solve(i+1, True), 0 if must_pick else solve(i+1, False))\\n        return solve(0, False)\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        vector<vector<int>> dp(2, vector<int>(size(nums)));\\n        dp[0][0] = dp[1][0] = nums[0];\\n        for(int i = 1; i < size(nums); i++) {\\n            dp[1][i] = max(nums[i], nums[i] + dp[1][i-1]);\\n            dp[0][i] = max(dp[0][i-1], dp[1][i]);\\n        }\\n        return dp[0].back();\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def maxSubArray(self, nums):\\n        dp = [[0]*len(nums) for i in range(2)]\\n        dp[0][0], dp[1][0] = nums[0], nums[0]\\n        for i in range(1, len(nums)):\\n            dp[1][i] = max(nums[i], nums[i] + dp[1][i-1])\\n            dp[0][i] = max(dp[0][i-1], dp[1][i])\\n        return dp[0][-1]\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        vector<int> dp(nums);\\n        for(int i = 1; i < size(nums); i++) \\n            dp[i] = max(nums[i], nums[i] + dp[i-1]);        \\n        return *max_element(begin(dp), end(dp));\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def maxSubArray(self, nums):\\n        dp = [*nums]\\n        for i in range(1, len(nums)):\\n            dp[i] = max(nums[i], nums[i] + dp[i-1])\\n        return max(dp)\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int curMax = 0, maxTillNow = INT_MIN;\\n        for(auto c : nums)\\n            curMax = max(c, curMax + c),\\n            maxTillNow = max(maxTillNow, curMax);\\n        return maxTillNow;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def maxSubArray(self, nums):\\n        cur_max, max_till_now = 0, -inf\\n        for c in nums:\\n            cur_max = max(c, cur_max + c)\\n            max_till_now = max(max_till_now, cur_max)\\n        return max_till_now\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        return maxSubArray(nums, 0, size(nums)-1);\\n    }\\n    int maxSubArray(vector<int>& A, int L, int R){\\n        if(L > R) return INT_MIN;\\n        int mid = (L + R) / 2, leftSum = 0, rightSum = 0;\\n        // leftSum = max subarray sum in [L, mid-1] and starting from mid-1\\n        for(int i = mid-1, curSum = 0; i >= L; i--)\\n            curSum += A[i],\\n            leftSum=max(leftSum, curSum);\\n        // rightSum = max subarray sum in [mid+1, R] and starting from mid+1\\n        for(int i = mid+1, curSum = 0; i <= R; i++)\\n            curSum += A[i],\\n            rightSum = max(rightSum, curSum);        \\n\\t\\t// return max of 3 cases \\n        return max({ maxSubArray(A, L, mid-1), maxSubArray(A, mid+1, R), leftSum + A[mid] + rightSum });\\n    }\\t\\n};\\n```\n```python\\nclass Solution:\\n    def maxSubArray(self, nums):\\n        def maxSubArray(A, L, R):\\n            if L > R: return -inf\\n            mid, left_sum, right_sum, cur_sum = (L + R) // 2, 0, 0, 0\\n            for i in range(mid-1, L-1, -1):\\n                left_sum = max(left_sum, cur_sum := cur_sum + A[i])\\n            cur_sum = 0\\n            for i in range(mid+1, R+1):\\n                right_sum = max(right_sum, cur_sum := cur_sum + A[i])\\n            return max(maxSubArray(A, L, mid-1), maxSubArray(A, mid+1, R), left_sum + A[mid] + right_sum)\\n        return maxSubArray(nums, 0, len(nums)-1)\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> pre, suf;\\n    int maxSubArray(vector<int>& nums) {\\n        pre = suf = nums;\\n        for(int i = 1; i < size(nums); i++)  pre[i] += max(0, pre[i-1]);\\n        for(int i = size(nums)-2; ~i; i--)   suf[i] += max(0, suf[i+1]);\\n        return maxSubArray(nums, 0, size(nums)-1);\\n    }\\n    int maxSubArray(vector<int>& A, int L, int R){\\n        if(L == R) return A[L];\\n        int mid = (L + R) / 2;\\n        return max({ maxSubArray(A, L, mid), maxSubArray(A, mid+1, R), pre[mid] + suf[mid+1] });\\n    }\\t\\n};\\n```\n```python\\nclass Solution:\\n    def maxSubArray(self, nums):\\n        pre, suf = [*nums], [*nums]\\n        for i in range(1, len(nums)):       pre[i] += max(0, pre[i-1])\\n        for i in range(len(nums)-2,-1,-1):  suf[i] += max(0, suf[i+1])\\n        def maxSubArray(A, L, R):\\n            if L == R: return A[L]\\n            mid = (L + R) // 2\\n            return max(maxSubArray(A, L, mid), maxSubArray(A, mid+1, R), pre[mid] + suf[mid+1])\\n        return maxSubArray(nums, 0, len(nums)-1)\\n```\n```cpp\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxSubArray(vector<int>& nums) {\\n\\t\\t\\tvector<int> pre = nums;\\n\\t\\t\\tfor(int i = 1; i < size(nums); i++) pre[i] += max(0, pre[i-1]);\\n\\t\\t\\treturn *max_element(begin(pre), end(pre));\\n\\t\\t}\\n\\t};\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 20211,
                "title": "accepted-o-n-solution-in-java",
                "content": "this problem was discussed by Jon Bentley (Sep. 1984 Vol. 27 No. 9 Communications of the ACM P885)\\n\\nthe paragraph below was copied from his paper (with a little modifications)\\n\\nalgorithm that operates on arrays: it starts at the left end (element A[1]) and scans through to the right end (element A[n]), keeping track of the maximum sum subvector seen so far. The maximum is initially A[0]. Suppose we've solved the problem for A[1 .. i - 1]; how can we extend that to A[1 .. i]? The maximum \\nsum in the first I elements is either the maximum sum in the first i - 1 elements (which we'll call MaxSoFar), or it is that of a subvector that ends in position i (which we'll call MaxEndingHere).  \\n\\nMaxEndingHere is either A[i] plus the previous MaxEndingHere, or just A[i], whichever is larger.\\n\\n    public static int maxSubArray(int[] A) {\\n        int maxSoFar=A[0], maxEndingHere=A[0];\\n        for (int i=1;i<A.length;++i){\\n        \\tmaxEndingHere= Math.max(maxEndingHere+A[i],A[i]);\\n        \\tmaxSoFar=Math.max(maxSoFar, maxEndingHere);\\t\\n        }\\n        return maxSoFar;\\n    }",
                "solutionTags": [],
                "code": "this problem was discussed by Jon Bentley (Sep. 1984 Vol. 27 No. 9 Communications of the ACM P885)\\n\\nthe paragraph below was copied from his paper (with a little modifications)\\n\\nalgorithm that operates on arrays: it starts at the left end (element A[1]) and scans through to the right end (element A[n]), keeping track of the maximum sum subvector seen so far. The maximum is initially A[0]. Suppose we've solved the problem for A[1 .. i - 1]; how can we extend that to A[1 .. i]? The maximum \\nsum in the first I elements is either the maximum sum in the first i - 1 elements (which we'll call MaxSoFar), or it is that of a subvector that ends in position i (which we'll call MaxEndingHere).  \\n\\nMaxEndingHere is either A[i] plus the previous MaxEndingHere, or just A[i], whichever is larger.\\n\\n    public static int maxSubArray(int[] A) {\\n        int maxSoFar=A[0], maxEndingHere=A[0];\\n        for (int i=1;i<A.length;++i){\\n        \\tmaxEndingHere= Math.max(maxEndingHere+A[i],A[i]);\\n        \\tmaxSoFar=Math.max(maxSoFar, maxEndingHere);\\t\\n        }\\n        return maxSoFar;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 20396,
                "title": "easy-python-way",
                "content": "    for i in range(1, len(nums)):\\n            if nums[i-1] > 0:\\n                nums[i] += nums[i-1]\\n        return max(nums)",
                "solutionTags": [],
                "code": "    for i in range(1, len(nums)):\\n            if nums[i-1] > 0:\\n                nums[i] += nums[i-1]\\n        return max(nums)",
                "codeTag": "Unknown"
            },
            {
                "id": 1595097,
                "title": "java-kadane-s-algorithm-explanation-using-image",
                "content": "**Intution:** Start traversing your array keep each element in the sum and every time keep the max of currSum and prevSum.\\n**But the catch here is that if at any point sum becomes negative then no point keeping it because 0 is obviously greater than negative, so just make your sum 0.**\\n\\n![image](https://assets.leetcode.com/users/images/2715e7ab-8fad-4f5f-ace9-cfe83acba68f_1637809592.7767313.jpeg)\\n\\nNow here in this question you can see that you can also be asked some more things like :\\n* Length of the max subarray\\n* Elements of the max subarray\\n* Start and End index of max subarray\\n  ##### This is very important concept from interview point so try to get the ans of above mentioned point and have confidence on this algorithm.\\n\\n**CODE :**\\n```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int n = nums.length;\\n        int max = Integer.MIN_VALUE, sum = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            sum += nums[i];\\n            max = Math.max(sum,max);\\n            \\n            if(sum<0) sum = 0;\\n        }\\n        \\n        return max;\\n    }\\n}\\n```\\nP.S. : I see a lots of comments saying this algorithm will not work if all the elements are negative....plz analyze it carefully...this is working for every case. \\n**if(sum<0) sum = 0;** -> this line is doing some magic. Dry run the algorithm carefully and u will get the answer. \\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int n = nums.length;\\n        int max = Integer.MIN_VALUE, sum = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            sum += nums[i];\\n            max = Math.max(sum,max);\\n            \\n            if(sum<0) sum = 0;\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20194,
                "title": "a-python-solution",
                "content": "    class Solution:\\n        # @param A, a list of integers\\n        # @return an integer\\n        # 6:57\\n        def maxSubArray(self, A):\\n            if not A:\\n                return 0\\n    \\n            curSum = maxSum = A[0]\\n            for num in A[1:]:\\n                curSum = max(num, curSum + num)\\n                maxSum = max(maxSum, curSum)\\n    \\n            return maxSum",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        # @param A, a list of integers\\n        # @return an integer\\n        # 6:57\\n        def maxSubArray(self, A):\\n            if not A:\\n                return 0\\n    \\n            curSum = maxSum = A[0]\\n            for num in A[1:]:\\n                curSum = max(num, curSum + num)\\n                maxSum = max(maxSum, curSum)\\n    \\n            return maxSum",
                "codeTag": "Java"
            },
            {
                "id": 20452,
                "title": "c-dp-and-divide-and-conquer",
                "content": "**Dynamic Programming**\\n\\nThere is a nice introduction to the DP algorithm in this [Wikipedia article](https://en.wikipedia.org/wiki/Maximum_subarray_problem). The idea is to maintain a running maximum `smax` and a current summation `sum`. When we visit each `num` in `nums`, add `num` to `sum`, then update `smax` if necessary or reset `sum` to `0` if it becomes negative.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int sum = 0, smax = INT_MIN;\\n        for (int num : nums) {\\n            sum += num;\\n            smax = max(smax, sum);\\n            if (sum < 0) {\\n                sum = 0;\\n            }\\n        }\\n        return smax;\\n    }\\n};\\n```\\n\\n**Divide and Conquer**\\n\\nThe Divide-and-Conquer algorithm breaks `nums` into two halves and find the maximum subarray sum in them recursively. Well, the most tricky part is to handle the case that the maximum subarray spans the two halves. For this case, we use a linear algorithm: starting from the middle element and move to both ends (left and right ends), record the maximum sum we have seen. In this case, the maximum sum is finally equal to the middle element plus the maximum sum of moving leftwards and the maximum sum of moving rightwards.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        return maxSubArray(nums, 0, nums.size() - 1);\\n    }\\nprivate:\\n    int maxSubArray(vector<int>& nums, int l, int r) {\\n        if (l > r) {\\n            return INT_MIN;\\n        }\\n        int m = l + (r - l) / 2, ml = 0, mr = 0;\\n        int lmax = maxSubArray(nums, l, m - 1);\\n        int rmax = maxSubArray(nums, m + 1, r);\\n        for (int i = m - 1, sum = 0; i >= l; i--) {\\n            sum += nums[i];\\n            ml = max(sum, ml);\\n        }\\n        for (int i = m + 1, sum = 0; i <= r; i++) {\\n            sum += nums[i];\\n            mr = max(sum, mr);\\n        }\\n        return max(max(lmax, rmax), ml + mr + nums[m]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Divide and Conquer",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int sum = 0, smax = INT_MIN;\\n        for (int num : nums) {\\n            sum += num;\\n            smax = max(smax, sum);\\n            if (sum < 0) {\\n                sum = 0;\\n            }\\n        }\\n        return smax;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        return maxSubArray(nums, 0, nums.size() - 1);\\n    }\\nprivate:\\n    int maxSubArray(vector<int>& nums, int l, int r) {\\n        if (l > r) {\\n            return INT_MIN;\\n        }\\n        int m = l + (r - l) / 2, ml = 0, mr = 0;\\n        int lmax = maxSubArray(nums, l, m - 1);\\n        int rmax = maxSubArray(nums, m + 1, r);\\n        for (int i = m - 1, sum = 0; i >= l; i--) {\\n            sum += nums[i];\\n            ml = max(sum, ml);\\n        }\\n        for (int i = m + 1, sum = 0; i <= r; i++) {\\n            sum += nums[i];\\n            mr = max(sum, mr);\\n        }\\n        return max(max(lmax, rmax), ml + mr + nums[m]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1470547,
                "title": "c-easy-clean-solution-fastest-0ms-all-methods-follow-ups-detailed-explanation",
                "content": "#### Idea:\\n\\nInitialise: **currMaxSum** and **globalMaxSum** as nums[0] since, for i = 0, we only have 1 choice i.e to include it into the maxSum SubArray.\\n\\nFor any index i [ 1 <= i <= n [:= nums.size()] - 1 ], we have **two choices** for maxSum SubArray: \\n1. It expands itself by including nums[i] (or ith index).\\n2. It discards itself and starts fresh from nums[i] (or ith index).\\n\\nAt each step, we choose **max** of above two choices for ith index and update our currMaxSum.\\nAt each step, we **update** globalMaxSum to store the global maxSum SubArray.\\n\\n##### Method1: Recursive [T(n) = O(n) and S(n) = O(n) [recursion stack space]]\\n\\n```\\nclass Solution {\\npublic:\\n\\tint globalMaxSum;\\n\\tint maxSubArray(vector<int> &nums, int n) {\\n\\t\\tif (n == 1) return nums[0];\\n\\t\\tint currMaxSum = max(nums[n - 1], maxSubArray(nums, n - 1) + nums[n - 1]);\\n\\t\\tglobalMaxSum = max(globalMaxSum, currMaxSum);\\n\\t\\treturn currMaxSum;\\n\\t}\\n    int maxSubArray(vector<int> &nums) {\\n        globalMaxSum = nums[0];\\n\\t\\tmaxSubArray(nums, nums.size());\\n        return globalMaxSum;\\n    }\\n};\\n```\\n\\n##### Method2: Iterative [T(n) = O(n) and S(n) = O(1)]\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int> &nums) {\\n        int globalMaxSum = nums[0], currMaxSum = nums[0];\\n        for (int ind = 1; ind < nums.size(); ind++) {\\n            currMaxSum = max(currMaxSum + nums[ind], nums[ind]);\\n            globalMaxSum = max(globalMaxSum, currMaxSum);\\n        }\\n        return globalMaxSum;\\n    }\\n};\\n```\\n\\n#### Follow Up Question:\\n\\nWhat if we need to find the length OR print the maxSum SubArray? Note that there can be many such SubArrays, So, we want to print the subArray with maxLength. If more than 1 subArray exist with maxLength then we can print anyone of them.\\n\\n##### Idea:\\n\\nUse three variables: **currStart**, **globalStart** and **globalEnd** for storing starting index of **currMaxSum** SubArray, starting and ending index of **globalMaxSum** SubArray **respectively**. Note that there is no need to store ending index of **currMaxSum** SubArray as it can be maintained using current index.\\n\\nThe idea is to update currStart whenever we prefer choice 2 (detail mentioned above at starting of the post) and update globalStart and globalEnd whenver we update globalMaxSum. Doing this will give us starting and ending index of anyone of the possible subArrays with globalMaxSum.\\nNow, to find the maxLen maxSum (=globalMaxSum) SubArray, we can update globalStart and globalEnd whenever we find a potential candidate for the maxLen i.e whenver we have: `globalMaxSum = currMaxSum` such that this candidate have larger length than the current candidate i.e: `globalLen < currLen => globalEnd - globalStart + 1 < currEnd - currStart + 1 => globalEnd - globalStart < ind - currStart`\\nThis is a very useful trick that can be used/ applied in many such similar problems.\\n\\n```\\n// Use below utility function to print the subArray\\nvoid printSubArray(vector<int> &nums, int low, int high) {\\n\\tfor (int ind = low; ind <= high; ind++)\\n\\t\\tcout << nums[ind] << \" \";\\n\\tcout << \"\\\\n\";\\n}\\n```\\n\\n##### Method1: Recursive [T(n) = O(n) and S(n) = O(n) [recursion stack space]]\\n\\n```\\nclass Solution {\\npublic:\\n\\tint globalMaxSum, globalStart = 0, globalEnd = 0, currStart = 0;\\n\\tint maxSubArray(vector<int> &nums, int n) {\\n\\t\\tif (n == 1) return nums[0];\\n\\t\\tint currMaxSum = maxSubArray(nums, n - 1);\\n\\t\\tif (currMaxSum < 0)    // same as: currMaxSum + nums[n - 1] < nums[n - 1]\\n\\t\\t\\tcurrMaxSum = nums[n - 1], currStart = n - 1;\\n\\t\\telse currMaxSum += nums[n - 1];\\n\\t\\t// use only below if cond. to find anyone of all subArrays with globalMaxSum\\n\\t\\tif (globalMaxSum < currMaxSum)\\n\\t\\t\\tglobalMaxSum = currMaxSum, globalStart = currStart, globalEnd = n - 1;\\n\\t\\t// use below to find anyone of all maxLen subArrays with globalMaxSum\\n\\t\\telse if (globalMaxSum == currMaxSum and globalEnd - globalStart < (n - 1) - currStart)\\n\\t\\t\\tglobalStart = currStart, globalEnd = n - 1;\\n\\t\\treturn currMaxSum;\\n\\t}\\n    void printMaxSubArray(vector<int> &nums) {\\n        globalMaxSum = nums[0];\\n\\t\\tmaxSubArray(nums, nums.size());\\n\\t\\tcout << \"Following SubArray has maxSum: \" << globalMaxSum;\\n\\t\\tcout << \" and has length: \" << globalEnd - globalStart + 1 << \" :\\\\n\";\\n\\t\\tprintSubArray(nums, globalStart, globalEnd);\\n\\t\\t\\n    }\\n};\\n```\\n\\n##### Method2: Iterative [T(n) = O(n) and S(n) = O(1)]\\n\\n```\\nclass Solution {\\npublic:\\n    void maxSubArray(vector<int> &nums) {\\n        int globalMaxSum = nums[0], currMaxSum = nums[0];\\n\\t\\tint globalStart = 0, globalEnd = 0, currStart = 0;\\n        for (int ind = 1; ind < nums.size(); ind++) {\\n            if (currMaxSum < 0)    // same as: currMaxSum + nums[ind] < nums[ind]\\n\\t\\t\\t\\tcurrMaxSum = nums[ind], currStart = ind;\\n\\t\\t\\telse currMaxSum += nums[ind];\\n\\t\\t\\t// use only below if cond. to find anyone of all subArrays with globalMaxSum\\n\\t\\t\\tif (globalMaxSum < currMaxSum)\\n\\t\\t\\t\\tglobalMaxSum = currMaxSum, globalStart = currStart, globalEnd = ind;\\n\\t\\t\\t// use below to find anyone of all maxLen subArrays with globalMaxSum\\n\\t\\t\\telse if (globalMaxSum == currMaxSum and globalEnd - globalStart < ind - currStart)\\n\\t\\t\\t\\tglobalStart = currStart, globalEnd = ind;\\n        }\\n\\t\\tcout << \"Following SubArray has maxSum: \" << globalMaxSum;\\n\\t\\tcout << \" and has length: \" << globalEnd - globalStart + 1 << \" :\\\\n\";\\n\\t\\tprintSubArray(nums, globalStart, globalEnd);\\n    }\\n};\\n```\\n\\n#### Important Points:\\n\\nThis solution is inspired by Kadane\\'s Algorithm (Google for more info). We can also use this concept to find min/ max sum/ product subarray [obviously with some added intuition/ tweaks :)].\\n\\nSimilar problems on Leetcode are:\\n1. [918. Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/)\\n2. [152. Maximum Product Subarray](https://leetcode.com/problems/maximum-product-subarray/)\\n3. [1567. Maximum Length of Subarray With Positive Product](https://leetcode.com/problems/maximum-length-of-subarray-with-positive-product/)\\n\\n**NOTE:**\\n*If you find this post helpful then please **upvote**. It keeps me **motivated** to post such helpful solutions. Thanks!*\\n\\n**PS:**\\nI have also written a post on all C++ (15+) sorting algorithms in a cleaner way [here](https://leetcode.com/problems/sort-an-array/discuss/1401412/C%2B%2B-Clean-Code-Solution-or-Fastest-or-All-(15%2B)-Sorting-Methods-or-Detailed) on leetcode.\\n*Do check it out/ bookmark (and upvote :)) to revise those concepts for the interview. Thanks!*",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tint globalMaxSum;\\n\\tint maxSubArray(vector<int> &nums, int n) {\\n\\t\\tif (n == 1) return nums[0];\\n\\t\\tint currMaxSum = max(nums[n - 1], maxSubArray(nums, n - 1) + nums[n - 1]);\\n\\t\\tglobalMaxSum = max(globalMaxSum, currMaxSum);\\n\\t\\treturn currMaxSum;\\n\\t}\\n    int maxSubArray(vector<int> &nums) {\\n        globalMaxSum = nums[0];\\n\\t\\tmaxSubArray(nums, nums.size());\\n        return globalMaxSum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int> &nums) {\\n        int globalMaxSum = nums[0], currMaxSum = nums[0];\\n        for (int ind = 1; ind < nums.size(); ind++) {\\n            currMaxSum = max(currMaxSum + nums[ind], nums[ind]);\\n            globalMaxSum = max(globalMaxSum, currMaxSum);\\n        }\\n        return globalMaxSum;\\n    }\\n};\\n```\n```\\n// Use below utility function to print the subArray\\nvoid printSubArray(vector<int> &nums, int low, int high) {\\n\\tfor (int ind = low; ind <= high; ind++)\\n\\t\\tcout << nums[ind] << \" \";\\n\\tcout << \"\\\\n\";\\n}\\n```\n```\\nclass Solution {\\npublic:\\n\\tint globalMaxSum, globalStart = 0, globalEnd = 0, currStart = 0;\\n\\tint maxSubArray(vector<int> &nums, int n) {\\n\\t\\tif (n == 1) return nums[0];\\n\\t\\tint currMaxSum = maxSubArray(nums, n - 1);\\n\\t\\tif (currMaxSum < 0)    // same as: currMaxSum + nums[n - 1] < nums[n - 1]\\n\\t\\t\\tcurrMaxSum = nums[n - 1], currStart = n - 1;\\n\\t\\telse currMaxSum += nums[n - 1];\\n\\t\\t// use only below if cond. to find anyone of all subArrays with globalMaxSum\\n\\t\\tif (globalMaxSum < currMaxSum)\\n\\t\\t\\tglobalMaxSum = currMaxSum, globalStart = currStart, globalEnd = n - 1;\\n\\t\\t// use below to find anyone of all maxLen subArrays with globalMaxSum\\n\\t\\telse if (globalMaxSum == currMaxSum and globalEnd - globalStart < (n - 1) - currStart)\\n\\t\\t\\tglobalStart = currStart, globalEnd = n - 1;\\n\\t\\treturn currMaxSum;\\n\\t}\\n    void printMaxSubArray(vector<int> &nums) {\\n        globalMaxSum = nums[0];\\n\\t\\tmaxSubArray(nums, nums.size());\\n\\t\\tcout << \"Following SubArray has maxSum: \" << globalMaxSum;\\n\\t\\tcout << \" and has length: \" << globalEnd - globalStart + 1 << \" :\\\\n\";\\n\\t\\tprintSubArray(nums, globalStart, globalEnd);\\n\\t\\t\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void maxSubArray(vector<int> &nums) {\\n        int globalMaxSum = nums[0], currMaxSum = nums[0];\\n\\t\\tint globalStart = 0, globalEnd = 0, currStart = 0;\\n        for (int ind = 1; ind < nums.size(); ind++) {\\n            if (currMaxSum < 0)    // same as: currMaxSum + nums[ind] < nums[ind]\\n\\t\\t\\t\\tcurrMaxSum = nums[ind], currStart = ind;\\n\\t\\t\\telse currMaxSum += nums[ind];\\n\\t\\t\\t// use only below if cond. to find anyone of all subArrays with globalMaxSum\\n\\t\\t\\tif (globalMaxSum < currMaxSum)\\n\\t\\t\\t\\tglobalMaxSum = currMaxSum, globalStart = currStart, globalEnd = ind;\\n\\t\\t\\t// use below to find anyone of all maxLen subArrays with globalMaxSum\\n\\t\\t\\telse if (globalMaxSum == currMaxSum and globalEnd - globalStart < ind - currStart)\\n\\t\\t\\t\\tglobalStart = currStart, globalEnd = ind;\\n        }\\n\\t\\tcout << \"Following SubArray has maxSum: \" << globalMaxSum;\\n\\t\\tcout << \" and has length: \" << globalEnd - globalStart + 1 << \" :\\\\n\";\\n\\t\\tprintSubArray(nums, globalStart, globalEnd);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 20210,
                "title": "o-n-java-solution",
                "content": "The catch here is that we have to take care of negative value.\\nThe solution does 1 iteration with constant space and no DP.\\n\\n    public class Solution {\\n    public int maxSubArray(int[] A) {\\n        int max = Integer.MIN_VALUE, sum = 0;\\n        for (int i = 0; i < A.length; i++) {\\n            if (sum < 0) \\n                sum = A[i];\\n            else \\n                sum += A[i];\\n            if (sum > max)\\n                max = sum;\\n        }\\n        return max;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxSubArray(int[] A) {\\n        int max = Integer.MIN_VALUE, sum = 0;\\n        for (int i = 0; i < A.length; i++) {\\n            if (sum < 0) \\n                sum = A[i];\\n            else \\n                sum += A[i];\\n            if (sum > max)\\n                max = sum;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1595186,
                "title": "java-kadane-divide-and-conquer-dp",
                "content": "\\n\\n> ### Approch 1: Divide and Conquer Approch\\n\\n*Split our array into two halves*\\n**case1:** maxSum subaaray occur in left half , \\n**case2:**  maxSum subarray occur in right half\\n**case3:** maxSum subaaray lies about middle of array \\n\\nWe use here divide and conquer approch here , split array into two halves about middle \\ntake anwer from left , right , and subArray about middle.\\nLet assume recusion will give us answer for left and right part , how do we calculate maxsum subarray about mid :\\n **[-2,1,-3,4,-1,2,1,-5,4]**\\n i = 0  , j =  8\\n mid =  (0+8)/2 =  4\\n **step 1) Caluate maxSum (maximum positive sum) from mid to left**\\n   \\n```\\n     int sum = 0,leftMaxSUM = Integer.MIN_VALUE;\\n\\tfor(int l =  mid;l>=i;l--){\\n\\t\\tsum+=nums[l];\\n\\t\\tif(sum>leftMaxSUM ){\\n\\t\\t\\tleftMaxSUM =  sum;\\n\\t\\t}                                    \\n\\t}\\n```\\n **step 2) calculate maxSum(maximum positive sum ) from mid+1 to right side** \\n \\n ```\\nint rightMaxSUM = Integer.MIN_VALUE; \\nsum = 0;    // reset sum to 0\\n        for (int l = mid + 1; l <=j; l++)\\n        {\\n            sum += nums[l];\\n            if (sum > rightMaxSUM ) {\\n                rightMaxSUM = sum;\\n            }\\n        }\\n \\n```\\n`   int midSum = leftMaxSUM+rightMaxSUM   `\\n\\n\\n**Let code it**\\n **---- divide and conquer approch -------------------**\\n \\n```\\npublic int maxSubArray(int[] nums) {\\n    \\n        return helper(nums,0,nums.length-1);\\n    }\\n    \\n    public int helper(int nums[],int i,int j){\\n\\n        if(i==j){\\n            return nums[i];\\n        }\\n                          \\n        int mid  =  (i+j)/2;\\n        int sum = 0,leftMaxSUM = Integer.MIN_VALUE;\\n        \\n        for(int l =  mid;l>=i;l--){\\n            sum+=nums[l];\\n            if(sum>leftMaxSUM){\\n                leftMaxSUM =  sum;\\n            }                                    \\n        }\\n        \\n     int rightMaxSUM = Integer.MIN_VALUE;\\n        sum = 0;    // reset sum to 0\\n        for (int l = mid + 1; l <=j; l++)\\n        {\\n            sum += nums[l];\\n            if (sum > rightMaxSUM ) {\\n                rightMaxSUM = sum;\\n            }\\n        }\\n        \\n       int maxLeftRight = Math.max(helper(nums, i, mid),\\n                                    helper(nums, mid + 1, j ));\\n        return Math.max(maxLeftRight, leftMaxSUM + rightMaxSUM );\\n        \\n        \\n    \\n    }\\n```\\n \\n ---\\n \\n > ### Approch 2 : Dynamic Programming\\n \\n Take one varibale as a global maximum , say   max (To keep track maximum value)\\n **dp[i] means max sum subarray ending at index i**\\n  **If sum till i-1 is is usefull ,  then take it other wise take current cell as sum till i**\\n \\n   \\n ```\\npublic int maxSubArray(int[] nums) {\\n\\tint storage []=  new int[nums.length];\\n    int max  =  nums[0];\\n    storage[0 ] =  nums[0];\\n    for( int i=1;i<nums.length ;i++  ){\\n        storage[i] =  Math.max( storage[i-1]+nums[i] ,  nums[i]);\\n        if(storage[i]>max){\\n            max=  storage[i];\\n        }\\n    }\\n    return max;    \\n      }\\n```\\n \\n \\n\\n \\n ---\\n \\n \\n \\n> ###  Approch 3 : Kadane Algorithm (Best Approch) -  O(n) time Complexity \\n\\n\\n\\n \\n \\n * if overall sum become negative then it is better to take reinitialize sum to **zero** , beacuse may be possible later we have positive sum , but if we move with negative sum then it only decrease our positive sum , so it better to **reinitialize sum to 0 means start new subarray from next index** , \\n \\n ```\\n\\n   public int maxSubArray(int[] nums) {\\n        int sum = 0;\\n        int maxSum = Integer.MIN_VALUE;\\n        for(int  i =0;i<nums.length;i++){\\n            sum+=nums[i];\\n            maxSum =  Math.max(maxSum,sum);\\n            if(sum<0){\\n                sum = 0;\\n            }\\n        }\\n            return maxSum;\\n        \\n    }\\n```\\n\\n\\nIf found usefull then **upvote it **\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer",
                    "Dynamic Programming"
                ],
                "code": "```\\n     int sum = 0,leftMaxSUM = Integer.MIN_VALUE;\\n\\tfor(int l =  mid;l>=i;l--){\\n\\t\\tsum+=nums[l];\\n\\t\\tif(sum>leftMaxSUM ){\\n\\t\\t\\tleftMaxSUM =  sum;\\n\\t\\t}                                    \\n\\t}\\n```\n```\\nint rightMaxSUM = Integer.MIN_VALUE; \\nsum = 0;    // reset sum to 0\\n        for (int l = mid + 1; l <=j; l++)\\n        {\\n            sum += nums[l];\\n            if (sum > rightMaxSUM ) {\\n                rightMaxSUM = sum;\\n            }\\n        }\\n \\n```\n```\\npublic int maxSubArray(int[] nums) {\\n    \\n        return helper(nums,0,nums.length-1);\\n    }\\n    \\n    public int helper(int nums[],int i,int j){\\n\\n        if(i==j){\\n            return nums[i];\\n        }\\n                          \\n        int mid  =  (i+j)/2;\\n        int sum = 0,leftMaxSUM = Integer.MIN_VALUE;\\n        \\n        for(int l =  mid;l>=i;l--){\\n            sum+=nums[l];\\n            if(sum>leftMaxSUM){\\n                leftMaxSUM =  sum;\\n            }                                    \\n        }\\n        \\n     int rightMaxSUM = Integer.MIN_VALUE;\\n        sum = 0;    // reset sum to 0\\n        for (int l = mid + 1; l <=j; l++)\\n        {\\n            sum += nums[l];\\n            if (sum > rightMaxSUM ) {\\n                rightMaxSUM = sum;\\n            }\\n        }\\n        \\n       int maxLeftRight = Math.max(helper(nums, i, mid),\\n                                    helper(nums, mid + 1, j ));\\n        return Math.max(maxLeftRight, leftMaxSUM + rightMaxSUM );\\n        \\n        \\n    \\n    }\\n```\n```\\npublic int maxSubArray(int[] nums) {\\n\\tint storage []=  new int[nums.length];\\n    int max  =  nums[0];\\n    storage[0 ] =  nums[0];\\n    for( int i=1;i<nums.length ;i++  ){\\n        storage[i] =  Math.max( storage[i-1]+nums[i] ,  nums[i]);\\n        if(storage[i]>max){\\n            max=  storage[i];\\n        }\\n    }\\n    return max;    \\n      }\\n```\n```\\n\\n   public int maxSubArray(int[] nums) {\\n        int sum = 0;\\n        int maxSum = Integer.MIN_VALUE;\\n        for(int  i =0;i<nums.length;i++){\\n            sum+=nums[i];\\n            maxSum =  Math.max(maxSum,sum);\\n            if(sum<0){\\n                sum = 0;\\n            }\\n        }\\n            return maxSum;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3666304,
                "title": "beats-100-c-java-python-beginner-friendly",
                "content": "# Intuition\\nThe Intuition behind the code is to find the maximum sum of a contiguous subarray within the given array `nums`. It does this by scanning through the array and keeping track of the current sum of the subarray. Whenever the current sum becomes greater than the maximum sum encountered so far, it updates the maximum sum. If the current sum becomes negative, it resets the sum to 0 and starts a new subarray. By the end of the loop, the code returns the maximum sum found.\\n\\n# Approach:\\n\\n1. We start by initializing two variables: `maxSum` and `currentSum`.\\n   - `maxSum` represents the maximum sum encountered so far and is initially set to the minimum possible integer value to ensure that any valid subarray sum will be greater than it.\\n   - `currentSum` represents the current sum of the subarray being considered and is initially set to 0.\\n2. We iterate through the `nums` array using a for loop, starting from the first element and going up to the last element.\\n3. For each element in the array, we add it to the current sum `currentSum`. This calculates the sum of the subarray ending at the current element.\\n4. Next, we check if the current sum `currentSum` is greater than the current maximum sum `maxSum`.\\n   - If it is, we update `maxSum` with the new value of `currentSum`. This means we have found a new maximum subarray sum.\\n5. If the current sum `currentSum` becomes negative, it indicates that including the current element in the subarray would reduce the overall sum. In such cases, we reset `currentSum` to 0. This effectively discards the current subarray and allows us to start a fresh subarray from the next element.\\n6. We repeat steps 3 to 5 for each element in the array.\\n7. After iterating through the entire array, the variable `maxSum` will contain the maximum subarray sum encountered.\\n8. Finally, we return the value of `maxSum` as the result, representing the maximum sum of a contiguous subarray within the given array `nums`.\\n\\n# Code\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int maxSum = INT_MIN;\\n        int currentSum = 0;\\n        \\n        for (int i = 0; i < nums.size(); i++) {\\n            currentSum += nums[i];\\n            \\n            if (currentSum > maxSum) {\\n                maxSum = currentSum;\\n            }\\n            \\n            if (currentSum < 0) {\\n                currentSum = 0;\\n            }\\n        }\\n        \\n        return maxSum;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int maxSum = Integer.MIN_VALUE;\\n        int currentSum = 0;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            currentSum += nums[i];\\n            \\n            if (currentSum > maxSum) {\\n                maxSum = currentSum;\\n            }\\n            \\n            if (currentSum < 0) {\\n                currentSum = 0;\\n            }\\n        }\\n        \\n        return maxSum;\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        maxSum = float(\\'-inf\\')\\n        currentSum = 0\\n        \\n        for num in nums:\\n            currentSum += num\\n            \\n            if currentSum > maxSum:\\n                maxSum = currentSum\\n            \\n            if currentSum < 0:\\n                currentSum = 0\\n        \\n        return maxSum\\n```\\n\\n# clean code\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int maxSum = nums[0];\\n        int currentSum = nums[0];\\n\\n        for (int i = 1; i < nums.size(); i++) {\\n            currentSum = max(nums[i], currentSum + nums[i]);\\n            maxSum = max(maxSum, currentSum);\\n        }\\n\\n        return maxSum;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int maxSum = nums[0];\\n        int currentSum = nums[0];\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            currentSum = Math.max(nums[i], currentSum + nums[i]);\\n            maxSum = Math.max(maxSum, currentSum);\\n        }\\n\\n        return maxSum;\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        maxSum = nums[0]\\n        currentSum = nums[0]\\n\\n        for num in nums[1:]:\\n            currentSum = max(num, currentSum + num)\\n            maxSum = max(maxSum, currentSum)\\n\\n        return maxSum\\n```\\n\\n![CUTE_CAT.png](https://assets.leetcode.com/users/images/188f09ad-b402-49a2-88cc-daae4c8acbf2_1687364129.8941426.png)\\n\\n**If you are a beginner solve these problems which makes concepts clear for future coding:**\\n1. [Two Sum](https://leetcode.com/problems/two-sum/solutions/3619262/3-method-s-c-java-python-beginner-friendly/)\\n2. [Roman to Integer](https://leetcode.com/problems/roman-to-integer/solutions/3651672/best-method-c-java-python-beginner-friendly/)\\n3. [Palindrome Number](https://leetcode.com/problems/palindrome-number/solutions/3651712/2-method-s-c-java-python-beginner-friendly/)\\n4. [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/solutions/3666304/beats-100-c-java-python-beginner-friendly/)\\n5. [Remove Element](https://leetcode.com/problems/remove-element/solutions/3670940/best-100-c-java-python-beginner-friendly/)\\n6. [Contains Duplicate](https://leetcode.com/problems/contains-duplicate/solutions/3672475/4-method-s-c-java-python-beginner-friendly/)\\n7. [Add Two Numbers](https://leetcode.com/problems/add-two-numbers/solutions/3675747/beats-100-c-java-python-beginner-friendly/)\\n8. [Majority Element](https://leetcode.com/problems/majority-element/solutions/3676530/3-methods-beats-100-c-java-python-beginner-friendly/)\\n9. [Remove Duplicates from Sorted Array](https://leetcode.com/problems/remove-duplicates-from-sorted-array/solutions/3676877/best-method-100-c-java-python-beginner-friendly/)\\n10. **Practice them in a row for better understanding and please Upvote for more questions.**\\n\\n\\n\\n**If you found my solution helpful, I would greatly appreciate your upvote, as it would motivate me to continue sharing more solutions.**\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int maxSum = INT_MIN;\\n        int currentSum = 0;\\n        \\n        for (int i = 0; i < nums.size(); i++) {\\n            currentSum += nums[i];\\n            \\n            if (currentSum > maxSum) {\\n                maxSum = currentSum;\\n            }\\n            \\n            if (currentSum < 0) {\\n                currentSum = 0;\\n            }\\n        }\\n        \\n        return maxSum;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int maxSum = Integer.MIN_VALUE;\\n        int currentSum = 0;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            currentSum += nums[i];\\n            \\n            if (currentSum > maxSum) {\\n                maxSum = currentSum;\\n            }\\n            \\n            if (currentSum < 0) {\\n                currentSum = 0;\\n            }\\n        }\\n        \\n        return maxSum;\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        maxSum = float(\\'-inf\\')\\n        currentSum = 0\\n        \\n        for num in nums:\\n            currentSum += num\\n            \\n            if currentSum > maxSum:\\n                maxSum = currentSum\\n            \\n            if currentSum < 0:\\n                currentSum = 0\\n        \\n        return maxSum\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int maxSum = nums[0];\\n        int currentSum = nums[0];\\n\\n        for (int i = 1; i < nums.size(); i++) {\\n            currentSum = max(nums[i], currentSum + nums[i]);\\n            maxSum = max(maxSum, currentSum);\\n        }\\n\\n        return maxSum;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int maxSum = nums[0];\\n        int currentSum = nums[0];\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            currentSum = Math.max(nums[i], currentSum + nums[i]);\\n            maxSum = Math.max(maxSum, currentSum);\\n        }\\n\\n        return maxSum;\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        maxSum = nums[0]\\n        currentSum = nums[0]\\n\\n        for num in nums[1:]:\\n            currentSum = max(num, currentSum + num)\\n            maxSum = max(maxSum, currentSum)\\n\\n        return maxSum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20189,
                "title": "simplest-and-fastest-o-n-c-solution",
                "content": "Idea is very simple. Basically, keep adding each integer to the sequence until the sum drops below 0. \\nIf sum is negative, then should reset the sequence.\\n\\n    class Solution {\\n    public:\\n        int maxSubArray(int A[], int n) {\\n            int ans=A[0],i,j,sum=0;\\n            for(i=0;i<n;i++){\\n                sum+=A[i];\\n                ans=max(sum,ans);\\n                sum=max(sum,0);\\n            }\\n            return ans;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maxSubArray(int A[], int n) {\\n            int ans=A[0],i,j,sum=0;\\n            for(i=0;i<n;i++){\\n                sum+=A[i];\\n                ans=max(sum,ans);\\n                sum=max(sum,0);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 20200,
                "title": "share-my-solutions-both-greedy-and-divide-and-conquer",
                "content": "**greedy:**\\n\\n    class Solution {\\n    public:\\n        int maxSubArray(int A[], int n) {\\n            int sum = 0, min = 0, res = A[0];\\n            for(int i = 0; i < n; i++) {\\n                sum += A[i];\\n                if(sum - min > res) res = sum - min;\\n                if(sum < min) min = sum;\\n            }\\n            return res;\\n        }\\n    };\\n\\nThe idea is to find the largest difference between the sums when you summing up the array from left to right. The largest difference corresponds to the sub-array with largest sum. I worked it out independently although It is very  close to lucastan's solution https://oj.leetcode.com/discuss/11288/simple-o-n-c-solution-no-dp-no-divide-and-conquer\\n\\n**divide and conquer:**\\n\\n    struct val {\\n        int l, m, r, s;\\n        val(int l, int m, int r, int s):l(l), m(m), r(r), s(s){}\\n    };\\n    \\n    class Solution {\\n    public:\\n        val dac(int A[], int n) {\\n            if(n == 1) return val(A[0], A[0], A[0], A[0]);\\n            val v1 = dac(A, n / 2), v2 = dac(A + n / 2, n - n / 2);\\n            int l, m, r, s;\\n            l = max(v1.l, v1.s + v2.l);\\n            m = max(v1.r + v2.l, max(v1.m, v2.m));\\n            r = max(v2.r, v1.r + v2.s);\\n            s = v1.s + v2.s;\\n            return val(l, m, r, s);\\n        }\\n        int maxSubArray(int A[], int n) {\\n            val v = dac(A, n);\\n            return v.m;\\n        }\\n    };\\n\\nthe idea is: for each sub array we calculate 4 values in O(1) time based on the return values of its two halves. The meaning of the values:\\n\\n - l: the sum of the sub array with largest sum starting from the  first\\n   element\\n - m: the sum of the sub array with largest sum\\n - r: the sum of the sub array with largest sum ending at the  last\\n   element\\n - s: the sum of the whole array\\n\\nthe recursive relation is clear in the code.",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maxSubArray(int A[], int n) {\\n            int sum = 0, min = 0, res = A[0];\\n            for(int i = 0; i < n; i++) {\\n                sum += A[i];\\n                if(sum - min > res) res = sum - min;\\n                if(sum < min) min = sum;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 898915,
                "title": "python-easy-solution-with-explanation-two-approaches-dp-with-and-without-table",
                "content": "####         At each index, keep track of the maximum sum using DP table , till that point\\n* ####             Save the maximum between [cur_value, max_so_far+cur_value]\\n* ####             Finally,  return the maximum out of the table\\n#### time O(n)\\n#### space O(n)\\n\\n```\\ndef maxSubArray(self, nums):\\n\\t\\tdp = [0]*len(nums)\\n        for i,num in enumerate(nums):            \\n            dp[i] = max(dp[i-1] + num, num)\\n        return max(dp)\\n```\\n#### To save space, implementation without using DP table \\n####         At each index, keep track of the maximum sum using variable (max_sum_until_i, and max_sum_sofar)\\n* ####             max_until_i = max (max_until_i, max_until_i+cur_value)\\n* ####             max_sum_sofar = max(max_until_i, max_sum_sofar,cur_value)\\n* #### Finally,  return the max_sum_sofar\\n#### time O(n)\\n#### space O(1)\\n```\\ndef maxSubArray(self, nums):\\n        max_sum_until_i = max_sum= nums[0]\\n        for i, num in enumerate(nums[1:],start=1):\\n            max_sum_until_i = max(max_sum_until_i+num, num)\\n            max_sum = max(max_sum,max_sum_until_i,max_sum)\\n        return max_sum\\n```\\n#### I hope you\\'ve found this helpful\\n##### Please upvote and encourage me to on my quest to document all leetcode problems\\uD83D\\uDE03\\n##### PS: Search for Abeni tag in the discussion, if I have solved it, You will find a detial explanation there\\uD83D\\uDE38",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef maxSubArray(self, nums):\\n\\t\\tdp = [0]*len(nums)\\n        for i,num in enumerate(nums):            \\n            dp[i] = max(dp[i-1] + num, num)\\n        return max(dp)\\n```\n```\\ndef maxSubArray(self, nums):\\n        max_sum_until_i = max_sum= nums[0]\\n        for i, num in enumerate(nums[1:],start=1):\\n            max_sum_until_i = max(max_sum_until_i+num, num)\\n            max_sum = max(max_sum,max_sum_until_i,max_sum)\\n        return max_sum\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2401258,
                "title": "very-easy-100-fully-explained-java-c-python-javascript-c-python3",
                "content": "# **Java Solution (Dynamic Programming Approach):**\\nRuntime: 1 ms, faster than 89.13% of Java online submissions for Maximum Subarray.\\n```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        // Initialize currMaxSum & take first element of array from which we start to do sum...\\n        int maxSum = nums[0];\\n        // Initialize the current sum of our subarray as nums[0]...\\n        int currSum = nums[0];\\n        // Traverse all the element through the loop...\\n        for (int i = 1; i < nums.length; i++) {\\n            // Do sum of elements contigous with curr sum...\\n            // Compare it with array element to get maximum result...\\n            currSum = Math.max(currSum + nums[i], nums[i]);\\n            // Compare current sum and max sum.\\n            maxSum = Math.max(maxSum, currSum);\\n        }\\n        return maxSum;      // return the contiguous subarray which has the largest sum...\\n    }\\n}\\n```\\n\\n# **C++ Solution (Kadane\\u2019s approach):**\\n```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        // Initialize maxSum as an integer that cannot store any value below the limit...\\n        int maxSum = INT_MIN;\\n        // Initialize maxSum...\\n        int maxSumSoFar = 0;\\n        // Traverse all the element through the loop...\\n        for(int i = 0; i < nums.size(); i++){\\n            // Keep adding the current value...\\n            maxSumSoFar += nums[i];\\n            // Update maxSum to maxSum and maxSumSoFar...\\n            if(maxSum < maxSumSoFar){\\n                maxSum = maxSumSoFar;\\n            }\\n            // if maxSumSoFar is less than 0 then update it to 0...\\n            if(maxSumSoFar < 0){\\n                maxSumSoFar = 0;\\n            }\\n        }\\n        return maxSum;      // Return the contiguous subarray which has the largest sum...\\n    }\\n};\\n```\\n\\n# **Python Solution (Dynamic Programming Approach):**\\nRuntime: 585 ms, faster than 95.18% of Python online submissions for Maximum Subarray.\\nMemory Usage: 25.3 MB, less than 97.76% of Python online submissions for Maximum Subarray.\\n```\\nclass Solution(object):\\n    def maxSubArray(self, nums):\\n        # Create an array...\\n        arr = []\\n        arr.append(nums[0])\\n        # Initialize the max sum...\\n        maxSum = arr[0]\\n        # Traverse all the element through the loop...\\n        for i in range(1, len(nums)):\\n            # arr[i] represents the largest sum of all subarrays ending with index i...\\n            # then its value should be the larger one between nums[i]...\\n            # arr[i-1] + nums[i] (largest sum plus current number with using prefix)...\\n            # calculate arr[0], arr[1]\\u2026, arr[n] while comparing each one with current largest sum...\\n            arr.append(max(arr[i-1] + nums[i], nums[i]))\\n            # if arr[i] > maxSum then maxSum = arr[i].\\n            if arr[i] > maxSum:\\n                maxSum = arr[i]\\n        return maxSum       # Return the contiguous subarray which has the largest sum...\\n```\\n                    \\n# **JavaScript Solution (Dynamic Programming Approach):**\\nRuntime: 103 ms, faster than 75.34% of JavaScript online submissions for Maximum Subarray.\\n```\\nvar maxSubArray = function(nums) {\\n    // Initialize the max sum...\\n    let maxSum = nums[0];\\n    // Traverse all the element through the loop...\\n    for (let i = 1; i < nums.length; i++) {\\n        // nums[i] represents the largest sum of all subarrays ending with index i...\\n        // then its value should be the larger one between nums[i]...\\n        // nums[i-1] + nums[i] (largest sum plus current number with using prefix)...\\n        // calculate nums[0], nums[1]\\u2026, nums[n] while comparing each one with current largest sum...\\n        nums[i] = Math.max(0, nums[i - 1]) + nums[i];\\n        // if nums[i] > maxSum then maxSum = nums[i]...\\n        if (nums[i] > maxSum)\\n            maxSum = nums[i];\\n    }\\n    return maxSum;      // return the contiguous subarray which has the largest sum...\\n};\\n```\\n\\n# **C Language (Kadane\\u2019s approach):**\\n```\\nint maxSubArray(int* nums, int numsSize){\\n    // Initialize maxSum as an integer that cannot store any value below the limit...\\n    int maxSum = nums[0];\\n    // Initialize maxSum...\\n    int maxSumSoFar = 0;\\n    // Traverse all the element through the loop...\\n    for(int i = 0; i < numsSize; i++){\\n        // Keep adding the current value...\\n        maxSumSoFar += nums[i];\\n        // Update maxSum to maxSum and maxSumSoFar...\\n        if(maxSum < maxSumSoFar){\\n            maxSum = maxSumSoFar;\\n        }\\n        // if maxSumSoFar is less than 0 then update it to 0...\\n        if(maxSumSoFar < 0){\\n            maxSumSoFar = 0;\\n        }\\n    }\\n    return maxSum;      // Return the contiguous subarray which has the largest sum...\\n}\\n```\\n\\n# **Python3 Solution (Dynamic Programming Approach):**\\n```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        # Create an array...\\n        arr = []\\n        arr.append(nums[0])\\n        # Initialize the max sum...\\n        maxSum = arr[0]\\n        for i in range(1, len(nums)):\\n            # arr[i] represents the largest sum of all subarrays ending with index i...\\n            # then its value should be the larger one between nums[i]...\\n            # arr[i-1] + nums[i] (largest sum plus current number with using prefix)...\\n            # calculate arr[0], arr[1]\\u2026, arr[n] while comparing each one with current largest sum...\\n            arr.append(max(arr[i-1] + nums[i], nums[i]))\\n            # if arr[i] > maxSum then maxSum = arr[i].\\n            if arr[i] > maxSum:\\n                maxSum = arr[i]\\n        return maxSum       # Return the contiguous subarray which has the largest sum...\\n```\\n**I am working hard for you guys...\\nPlease upvote if you find any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        // Initialize currMaxSum & take first element of array from which we start to do sum...\\n        int maxSum = nums[0];\\n        // Initialize the current sum of our subarray as nums[0]...\\n        int currSum = nums[0];\\n        // Traverse all the element through the loop...\\n        for (int i = 1; i < nums.length; i++) {\\n            // Do sum of elements contigous with curr sum...\\n            // Compare it with array element to get maximum result...\\n            currSum = Math.max(currSum + nums[i], nums[i]);\\n            // Compare current sum and max sum.\\n            maxSum = Math.max(maxSum, currSum);\\n        }\\n        return maxSum;      // return the contiguous subarray which has the largest sum...\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        // Initialize maxSum as an integer that cannot store any value below the limit...\\n        int maxSum = INT_MIN;\\n        // Initialize maxSum...\\n        int maxSumSoFar = 0;\\n        // Traverse all the element through the loop...\\n        for(int i = 0; i < nums.size(); i++){\\n            // Keep adding the current value...\\n            maxSumSoFar += nums[i];\\n            // Update maxSum to maxSum and maxSumSoFar...\\n            if(maxSum < maxSumSoFar){\\n                maxSum = maxSumSoFar;\\n            }\\n            // if maxSumSoFar is less than 0 then update it to 0...\\n            if(maxSumSoFar < 0){\\n                maxSumSoFar = 0;\\n            }\\n        }\\n        return maxSum;      // Return the contiguous subarray which has the largest sum...\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def maxSubArray(self, nums):\\n        # Create an array...\\n        arr = []\\n        arr.append(nums[0])\\n        # Initialize the max sum...\\n        maxSum = arr[0]\\n        # Traverse all the element through the loop...\\n        for i in range(1, len(nums)):\\n            # arr[i] represents the largest sum of all subarrays ending with index i...\\n            # then its value should be the larger one between nums[i]...\\n            # arr[i-1] + nums[i] (largest sum plus current number with using prefix)...\\n            # calculate arr[0], arr[1]\\u2026, arr[n] while comparing each one with current largest sum...\\n            arr.append(max(arr[i-1] + nums[i], nums[i]))\\n            # if arr[i] > maxSum then maxSum = arr[i].\\n            if arr[i] > maxSum:\\n                maxSum = arr[i]\\n        return maxSum       # Return the contiguous subarray which has the largest sum...\\n```\n```\\nvar maxSubArray = function(nums) {\\n    // Initialize the max sum...\\n    let maxSum = nums[0];\\n    // Traverse all the element through the loop...\\n    for (let i = 1; i < nums.length; i++) {\\n        // nums[i] represents the largest sum of all subarrays ending with index i...\\n        // then its value should be the larger one between nums[i]...\\n        // nums[i-1] + nums[i] (largest sum plus current number with using prefix)...\\n        // calculate nums[0], nums[1]\\u2026, nums[n] while comparing each one with current largest sum...\\n        nums[i] = Math.max(0, nums[i - 1]) + nums[i];\\n        // if nums[i] > maxSum then maxSum = nums[i]...\\n        if (nums[i] > maxSum)\\n            maxSum = nums[i];\\n    }\\n    return maxSum;      // return the contiguous subarray which has the largest sum...\\n};\\n```\n```\\nint maxSubArray(int* nums, int numsSize){\\n    // Initialize maxSum as an integer that cannot store any value below the limit...\\n    int maxSum = nums[0];\\n    // Initialize maxSum...\\n    int maxSumSoFar = 0;\\n    // Traverse all the element through the loop...\\n    for(int i = 0; i < numsSize; i++){\\n        // Keep adding the current value...\\n        maxSumSoFar += nums[i];\\n        // Update maxSum to maxSum and maxSumSoFar...\\n        if(maxSum < maxSumSoFar){\\n            maxSum = maxSumSoFar;\\n        }\\n        // if maxSumSoFar is less than 0 then update it to 0...\\n        if(maxSumSoFar < 0){\\n            maxSumSoFar = 0;\\n        }\\n    }\\n    return maxSum;      // Return the contiguous subarray which has the largest sum...\\n}\\n```\n```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        # Create an array...\\n        arr = []\\n        arr.append(nums[0])\\n        # Initialize the max sum...\\n        maxSum = arr[0]\\n        for i in range(1, len(nums)):\\n            # arr[i] represents the largest sum of all subarrays ending with index i...\\n            # then its value should be the larger one between nums[i]...\\n            # arr[i-1] + nums[i] (largest sum plus current number with using prefix)...\\n            # calculate arr[0], arr[1]\\u2026, arr[n] while comparing each one with current largest sum...\\n            arr.append(max(arr[i-1] + nums[i], nums[i]))\\n            # if arr[i] > maxSum then maxSum = arr[i].\\n            if arr[i] > maxSum:\\n                maxSum = arr[i]\\n        return maxSum       # Return the contiguous subarray which has the largest sum...\\n```",
                "codeTag": "Java"
            },
            {
                "id": 785522,
                "title": "python-3-91-63-faster-single-pass-algo-explanation-added",
                "content": "**Suggestions to make it better are always welcomed.**\\n\\nMy approaches to solve this problem evolved like this:\\n**1. Approach 1:** Using 2 for loops\\n   Starting from index i, start adding the numbers and record the maximum sum with all the next elements.\\n   Doing this for every i element (n-i) times will cause time complexity to become O(n^2).\\n   \\n**2. Approach 2**: Let\\'s create another list that can store the maximum of total or nums[i]. Here total = (previous num + nums[i]).\\n   Then to find the maximum of all the sums, we\\'ll have to traverse the list and return the maximum. This was O(n) time and O(n) space.\\n   \\n**3. Approach 3:** In above approach, we stored maximum total until nums[i] and then found the maximum subarray total in the end. We aren\\'t doing anything good with the new list because in the end we are traversing the list to find the maximum total. So, eliminate creating new list and start tracking the new sum and maximum number. This becomes O(n) time and O(1) space\\n\\n```\\ndef maxSubArray(self, nums: List[int]) -> int:        \\n\\tnewNum = maxTotal = nums[0]        \\n\\t\\n\\tfor i in range(1, len(nums)):\\n\\t\\tnewNum = max(nums[i], nums[i] + newNum)\\n\\t\\tmaxTotal = max(newNum, maxTotal)\\n\\n\\treturn maxTotal\\t\\n```\\n\\n**If above solution was helpful, please upvote it for it to reach others**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\ndef maxSubArray(self, nums: List[int]) -> int:        \\n\\tnewNum = maxTotal = nums[0]        \\n\\t\\n\\tfor i in range(1, len(nums)):\\n\\t\\tnewNum = max(nums[i], nums[i] + newNum)\\n\\t\\tmaxTotal = max(newNum, maxTotal)\\n\\n\\treturn maxTotal\\t\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 199163,
                "title": "python-o-n-divide-and-conquer-solution-with-explanations",
                "content": "```python\\nclass Solution:\\n    def maxSubArray(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        def divide_and_conquer(nums, i, j):\\n            if i == j-1:\\n                return nums[i],nums[i],nums[i],nums[i]\\n            \\n            # we will compute :\\n            # a which is max contiguous sum in nums[i:j] including the first value\\n            # m which is max contiguous sum in nums[i:j] anywhere \\n            # b which is max contiguous sum in nums[i:j] including the last value\\n            # s which is the sum of all values in nums[i:j]\\n                \\n            # compute middle index to divide array in two halves\\n            i_mid = i+(j-i)//2\\n            \\n            # compute a, m, b, s for left half\\n            a1, m1, b1, s1 = divide_and_conquer(nums, i, i_mid)\\n            \\n            # compute a, m, b, s for right half\\n            a2, m2, b2, s2 = divide_and_conquer(nums, i_mid, j)\\n            \\n            # combine a, m, b, s values from left and right halves to form a, m, b, s for whole array (bottom up)\\n            a = max(a1, s1+a2)\\n            b = max(b2, s2+b1)\\n            m = max(m1,m2,b1+a2)\\n            s = s1+s2\\n            return a,m,b,s\\n                  \\n        _,m,_,_ = divide_and_conquer(nums, 0, len(nums))\\n        return m\\n```\\nEach call to divide_and_conquer takes O(1) time and there are O(N) calls thus global time complexity is O(N).",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxSubArray(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        def divide_and_conquer(nums, i, j):\\n            if i == j-1:\\n                return nums[i],nums[i],nums[i],nums[i]\\n            \\n            # we will compute :\\n            # a which is max contiguous sum in nums[i:j] including the first value\\n            # m which is max contiguous sum in nums[i:j] anywhere \\n            # b which is max contiguous sum in nums[i:j] including the last value\\n            # s which is the sum of all values in nums[i:j]\\n                \\n            # compute middle index to divide array in two halves\\n            i_mid = i+(j-i)//2\\n            \\n            # compute a, m, b, s for left half\\n            a1, m1, b1, s1 = divide_and_conquer(nums, i, i_mid)\\n            \\n            # compute a, m, b, s for right half\\n            a2, m2, b2, s2 = divide_and_conquer(nums, i_mid, j)\\n            \\n            # combine a, m, b, s values from left and right halves to form a, m, b, s for whole array (bottom up)\\n            a = max(a1, s1+a2)\\n            b = max(b2, s2+b1)\\n            m = max(m1,m2,b1+a2)\\n            s = s1+s2\\n            return a,m,b,s\\n                  \\n        _,m,_,_ = divide_and_conquer(nums, 0, len(nums))\\n        return m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3227063,
                "title": "kadane-s-algo-o-n-time-and-o-1-space-easiest-beginner-friendly-sol",
                "content": "**NOTE - PLEASE READ INTUITION AND APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Intuition of this Problem:\\nWe can solve this problem using **Kadane\\'s Algorithm**\\n\\n**LETS DRY RUN THIS CODE WITH ONE EXAPMPLE :**\\n\\nSuppose we have the following input vector: **[-2, 1, -3, 4, -1, 2, 1, -5, 4].**\\n\\nWe initialize the maximumSum = INT_MIN (-2147483648) and currSumSubarray = 0.\\n\\nWe loop through the input vector and perform the following operations:\\n\\nAt the first iteration, currSumSubarray becomes -2 and since it is less than 0, we set it to 0. maximumSum remains at INT_MIN.\\n\\nAt the second iteration, currSumSubarray becomes 1, which is greater than 0, so we keep it as it is. We update maximumSum to 1.\\n\\nAt the third iteration, currSumSubarray becomes -2, which is less than 0, so we set it to 0. maximumSum remains at 1.\\n\\nAt the fourth iteration, currSumSubarray becomes 4, which is greater than 0, so we keep it as it is. We update maximumSum to 4.\\n\\nAt the fifth iteration, currSumSubarray becomes 3, which is greater than 0, so we keep it as it is. maximumSum remains at 4.\\n\\nAt the sixth iteration, currSumSubarray becomes 5, which is greater than 0, so we keep it as it is. We update maximumSum to 5.\\n\\nAt the seventh iteration, currSumSubarray becomes 6, which is greater than 0, so we keep it as it is. We update maximumSum to 6.\\n\\nAt the eighth iteration, currSumSubarray becomes 1, which is greater than 0, so we keep it as it is. maximumSum remains at 6.\\n\\nAt the ninth iteration, currSumSubarray becomes 5, which is greater than 0, so we keep it as it is. maximumSum remains at 6.\\n\\nAfter iterating through the input vector, we return maximumSum which is equal to 6. Therefore, the maximum sum subarray of the given input vector is [4, -1, 2, 1], and the sum of this subarray is 6.\\n\\n\\n\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach for this Problem:\\n1. Initialize two variables, maximumSum and currSumSubarray to the minimum integer value (INT_MIN) and 0, respectively.\\n2. Loop through the array from index 0 to n-1, where n is the size of the array.\\n3. In each iteration, add the current element of the array to the currSumSubarray variable.\\n4. Take the maximum between maximumSum and currSumSubarray and store it in the maximumSum variable.\\n5. Take the maximum between currSumSubarray and 0 and store it in currSumSubarray. This is done because if the currSumSubarray becomes negative, it means that we should start a new subarray, so we reset currSumSubarray to 0.\\n6. After the loop ends, return the maximumSum variable, which contains the maximum sum of a subarray.\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Code:\\n```C++ []\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int n = nums.size();\\n        //maximumSum will calculate our ans and currSumSubarray will calculate maximum sum subarray till ith position \\n        int maximumSum = INT_MIN, currSumSubarray = 0;\\n        for (int i = 0; i < n; i++) {\\n            currSumSubarray += nums[i]; \\n            maximumSum = max(maximumSum, currSumSubarray);\\n            //here we are taking max with 0 bcz if currSumSubarray = -1 or any negative value then it again starts with currSumSubarray = 0\\n            currSumSubarray = max(currSumSubarray, 0);\\n        } \\n        return maximumSum;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int n = nums.length;\\n        int maximumSum = Integer.MIN_VALUE, currSumSubarray = 0;\\n        for (int i = 0; i < n; i++) {\\n            currSumSubarray += nums[i]; \\n            maximumSum = Math.max(maximumSum, currSumSubarray);\\n            currSumSubarray = Math.max(currSumSubarray, 0);\\n        } \\n        return maximumSum;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        maximumSum, currSumSubarray = float(\\'-inf\\'), 0\\n        for i in range(n):\\n            currSumSubarray += nums[i]\\n            maximumSum = max(maximumSum, currSumSubarray)\\n            currSumSubarray = max(currSumSubarray, 0)\\n        return maximumSum\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity: **O(n)**, where n is the size of the input array. The algorithm has to loop through the array only once.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**, since the algorithm is using only a constant amount of extra space regardless of the input size.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int n = nums.size();\\n        //maximumSum will calculate our ans and currSumSubarray will calculate maximum sum subarray till ith position \\n        int maximumSum = INT_MIN, currSumSubarray = 0;\\n        for (int i = 0; i < n; i++) {\\n            currSumSubarray += nums[i]; \\n            maximumSum = max(maximumSum, currSumSubarray);\\n            //here we are taking max with 0 bcz if currSumSubarray = -1 or any negative value then it again starts with currSumSubarray = 0\\n            currSumSubarray = max(currSumSubarray, 0);\\n        } \\n        return maximumSum;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int n = nums.length;\\n        int maximumSum = Integer.MIN_VALUE, currSumSubarray = 0;\\n        for (int i = 0; i < n; i++) {\\n            currSumSubarray += nums[i]; \\n            maximumSum = Math.max(maximumSum, currSumSubarray);\\n            currSumSubarray = Math.max(currSumSubarray, 0);\\n        } \\n        return maximumSum;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        maximumSum, currSumSubarray = float(\\'-inf\\'), 0\\n        for i in range(n):\\n            currSumSubarray += nums[i]\\n            maximumSum = max(maximumSum, currSumSubarray)\\n            currSumSubarray = max(currSumSubarray, 0)\\n        return maximumSum\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 405559,
                "title": "easy-understand-java-solutions-with-explanations-b-f-divide-and-conquer-dp",
                "content": "Reference: [LeetCode](https://leetcode.com/problems/maximum-subarray/)\\nDifficulty: <span class=\"green\">Easy</span>\\n\\n## Problem\\n\\n> Given an integer array `nums`, find the contiguous subarray (**containing at least one number**) which has the largest sum and return its sum.\\n\\n\\n**Example:** \\n\\n```java\\nInput: [-5]\\nOutput: -5\\n\\nInput: [-2,1,-3,4,-1,2,1,-5,4]\\nOutput: 6\\nExplanation: [4,-1,2,1] has the largest sum = 6.\\n```\\n\\n**Follow up:** If you have figured out the `O(N)` solution, try coding another solution using the divide and conquer approach, which is more subtle.\\n\\n\\n\\n\\n## Analysis\\n\\n### Most Stupid Solution\\n\\nFor each element, we construct all possible subarrays starting from this element. Totally there are at most `N^2` subarrays. Also, calculating the sum of each subarray takes `O(N)`.\\n\\n```java\\npublic int maxSubArray(int[] nums) {\\n  int n = nums.length;\\n  int maxSum = Integer.MIN_VALUE;\\n  for (int i = 0; i < n; ++i) {\\n    for (int j = i; j < n; ++j) {\\n      int sum = 0;\\n      for (int k = i; k <= j; ++k) {\\n        sum += nums.get(k);\\n      }\\n      maxSum = Math.max(maxSum, sum);\\n    }\\n  }\\n  return maxSum;\\n}\\n```\\n\\n**Time:** `O(N^3)`\\n**Space:** `O(1)`\\n\\n\\n\\n### Brute-Force\\n\\nWhy did you calculate the sum separately?\\n\\n**Note:** In the inner loop, start from `i + 1`. Don\\'t initialize `sum` as `0` and start from `i`.\\n\\n```java\\npublic int maxSubArray(int[] nums) {\\n  int n = nums.length;\\n  int maxSum = Integer.MIN_VALUE; // can\\'t be 0\\n  for (int i = 0; i < n; ++i) { // starts at i\\n    int sum = nums[i];\\n    maxSum = Math.max(maxSum, sum);\\n    for (int j = i + 1; j < n; ++j) { // starts from the next element\\n      sum += nums[j];\\n      maxSum = Math.max(maxSum, sum);\\n    }\\n  }\\n  return maxSum;\\n}\\n```\\n\\n**Time:** `O(N^2)`\\n**Space:** `O(1)`\\n\\n\\n\\n### Divide and Conquer\\n\\nDivide-and-conquer consider 3 cases:\\n\\n- **Case 1:** Subarray in the left half -> `leftSum`\\n- **Case 2:** Subarray in the right half -> `rightSum`\\n- **Case 3:** Subarray crosses the middle -> `crossSum`\\n\\nWe need to compare three max values: `leftSum`, `rightSum`, and `crossSum`. By constructing the `crossSum`, we propagate from the right-end of the left subarray `[lo, mid]` and from the left-end of the right subarray `[mid + 1, hi]`. In each direction, we are continuously updating the maximum sum.\\n\\n```java\\n// Example\\nindex: 0  1  2  3  4  5  6\\n      -5  7  3 -1  1  2  3\\n               mid\\nFor the left half, we go through from -1 to -5. The maximum sum is (-1) + 3 + 7 = 9.\\nIt can\\'t be 3 + 7 = 10, because -1 must be included (crossing).\\n```\\n\\n**BTW, Index lo/hi/mid Caveat:** (skip it. Just my person notes~)\\n\\nWrite the condition as `if (lo == hi)` (stops at one element) or `if (lo >= hi)` (stops at `0` element). Why?\\n\\nWrite the subproblem as `[lo, mid]` and `[mid + 1, hi]`, which is not like binary search (`hi = mid - 1` and `lo = mid + 1`).\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/vtoj4.jpg)\\n\\n```java\\npublic int maxSubArray(int[] nums) {\\n  int n = nums.length;\\n  return maxSubArray(nums, 0, n - 1);\\n}\\n\\nprivate int maxSubArray(int[] nums, int lo, int hi) {\\n  if (lo == hi) { // base case: one number\\n    return nums[lo];\\n  }\\n  // divide\\n  int mid = lo + (hi - lo) / 2;\\n  // conquer\\n  int leftSum = maxSubArray(nums, lo, mid);\\n  int rightSum = maxSubArray(nums, mid + 1, hi);\\n  // combine\\n  int crossSum = crossSum(nums, lo, hi);\\n  return Math.max(crossSum, Math.max(leftSum, rightSum));\\n}\\n\\n// invariant: lo < hi (left part and right part both have at least 1 element\\nprivate int crossSum(int[] nums, int lo, int hi) {\\n  int mid = lo + (hi - lo) / 2;\\n  // left\\n  int leftSum = 0, leftMax = Integer.MIN_VALUE; // the invariant means that leftMax and rightMax will be updated\\n  for (int i = mid; i >= lo; --i) {\\n    leftSum += nums[i];\\n    leftMax = Math.max(leftMax, leftSum);\\n  }\\n  // right\\n  int rightSum = 0, rightMax = Integer.MIN_VALUE;\\n  for (int i = mid + 1; i <= hi; ++i) {\\n    rightSum += nums[i];\\n    rightMax = Math.max(rightMax, rightSum);\\n  }\\n  return leftMax + rightMax;\\n}\\n```\\n\\nAnother version, initialize sums and max values as the first element.\\n\\n```java\\nprivate int crossSum(int[] nums, int lo, int hi, int mid) {\\n  // left\\n  int leftSum = nums[mid]; // okay because 0 <= lo <= mid < hi <= n - 1\\n  int leftMax = leftSum;\\n  for (int i = mid - 1; i >= lo; --i) {\\n    leftSum += nums[i];\\n    leftMax = Math.max(leftMax, leftSum);\\n  }\\n  // right\\n  int rightSum = nums[mid + 1]; // lo < hi is guaranteed\\n  int rightMax = rightSum;\\n  for (int i = mid + 2; i <= hi; ++i) {\\n    rightSum += nums[i];\\n    rightMax = Math.max(rightMax, rightSum);\\n  }\\n  return leftMax + rightMax;\\n}\\n```\\n\\n**Time:** `O(N\\\\log{N})` since `T(N) = 2T(N/2) + O(N)`.\\n**Space:** `O(\\\\log{N})`\\n\\n\\n\\n### DP\\n\\nSuppose we know the maximum subarray ending at `i` (inclusive). We denote `SUM(i)` as the maximum sum of a subarray ending at index `i` and denote `OPT(i)` as the maximum sum in the subarray `[0, i]`. Our final result is `OPT(n - 1)`. (notice the difference since it is very trivial)\\n\\nFor an element `nums[i]`, we have two choices: Appending it to a previous subarray `SUM(i - 1)` or start a new subarray from itself. Then we can write the recurrence for `SUM(i)` and `OPT(i)` as follows:\\n\\n`SUM(i)` = max(`SUM(i - 1) + nums[i]`, `nums[i]`)\\n`OPT(i)` = max(`OPT(i - 1)`, `SUM(i)`).\\n\\nNote: `OPT` is updated when a larger `SUM[i]` is discovered.\\n\\nThe initial values are `SUM(0) = nums[0]` and `OPT(0) = nums[0]`. We can do it in one pass. So here is the code:\\n\\n```java\\npublic int maxSubArray(int[] nums) {\\n  int n = nums.length;\\n  int[] SUM = new int[n];\\n  int[] OPT = new int[n];\\n  SUM[0] = nums[0]; // init\\n  OPT[0] = nums[0];\\n  for (int i = 1; i < n; ++i) {\\n    SUM[i] = Math.max(SUM[i - 1] + nums[i], nums[i]);\\n    OPT[i] = Math.max(OPT[i - 1], SUM[i]);\\n  }\\n  return OPT[n - 1];\\n}\\n```\\n\\nSince `SUM(i)` and `OPT(i)` could be calculated by the previous values, we don\\'t need arrays of size `n` to store all information. Here is the code that reduces the space complexity:\\n\\n```java\\npublic int maxSubArray(int[] nums) {\\n  int n = nums.length;\\n  int SUM = nums[0];\\n  int OPT = nums[0];\\n  for (int i = 1; i < n; ++i) {\\n    SUM = Math.max(SUM + nums[i], nums[i]);\\n    OPT = Math.max(OPT, SUM);\\n  }\\n  return OPT;\\n}\\n```\\n\\n**Time:** `O(N)`\\n**Space:** `O(1)`\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer",
                    "Dynamic Programming"
                ],
                "code": "```java\\nInput: [-5]\\nOutput: -5\\n\\nInput: [-2,1,-3,4,-1,2,1,-5,4]\\nOutput: 6\\nExplanation: [4,-1,2,1] has the largest sum = 6.\\n```\n```java\\npublic int maxSubArray(int[] nums) {\\n  int n = nums.length;\\n  int maxSum = Integer.MIN_VALUE;\\n  for (int i = 0; i < n; ++i) {\\n    for (int j = i; j < n; ++j) {\\n      int sum = 0;\\n      for (int k = i; k <= j; ++k) {\\n        sum += nums.get(k);\\n      }\\n      maxSum = Math.max(maxSum, sum);\\n    }\\n  }\\n  return maxSum;\\n}\\n```\n```java\\npublic int maxSubArray(int[] nums) {\\n  int n = nums.length;\\n  int maxSum = Integer.MIN_VALUE; // can\\'t be 0\\n  for (int i = 0; i < n; ++i) { // starts at i\\n    int sum = nums[i];\\n    maxSum = Math.max(maxSum, sum);\\n    for (int j = i + 1; j < n; ++j) { // starts from the next element\\n      sum += nums[j];\\n      maxSum = Math.max(maxSum, sum);\\n    }\\n  }\\n  return maxSum;\\n}\\n```\n```java\\n// Example\\nindex: 0  1  2  3  4  5  6\\n      -5  7  3 -1  1  2  3\\n               mid\\nFor the left half, we go through from -1 to -5. The maximum sum is (-1) + 3 + 7 = 9.\\nIt can\\'t be 3 + 7 = 10, because -1 must be included (crossing).\\n```\n```java\\npublic int maxSubArray(int[] nums) {\\n  int n = nums.length;\\n  return maxSubArray(nums, 0, n - 1);\\n}\\n\\nprivate int maxSubArray(int[] nums, int lo, int hi) {\\n  if (lo == hi) { // base case: one number\\n    return nums[lo];\\n  }\\n  // divide\\n  int mid = lo + (hi - lo) / 2;\\n  // conquer\\n  int leftSum = maxSubArray(nums, lo, mid);\\n  int rightSum = maxSubArray(nums, mid + 1, hi);\\n  // combine\\n  int crossSum = crossSum(nums, lo, hi);\\n  return Math.max(crossSum, Math.max(leftSum, rightSum));\\n}\\n\\n// invariant: lo < hi (left part and right part both have at least 1 element\\nprivate int crossSum(int[] nums, int lo, int hi) {\\n  int mid = lo + (hi - lo) / 2;\\n  // left\\n  int leftSum = 0, leftMax = Integer.MIN_VALUE; // the invariant means that leftMax and rightMax will be updated\\n  for (int i = mid; i >= lo; --i) {\\n    leftSum += nums[i];\\n    leftMax = Math.max(leftMax, leftSum);\\n  }\\n  // right\\n  int rightSum = 0, rightMax = Integer.MIN_VALUE;\\n  for (int i = mid + 1; i <= hi; ++i) {\\n    rightSum += nums[i];\\n    rightMax = Math.max(rightMax, rightSum);\\n  }\\n  return leftMax + rightMax;\\n}\\n```\n```java\\nprivate int crossSum(int[] nums, int lo, int hi, int mid) {\\n  // left\\n  int leftSum = nums[mid]; // okay because 0 <= lo <= mid < hi <= n - 1\\n  int leftMax = leftSum;\\n  for (int i = mid - 1; i >= lo; --i) {\\n    leftSum += nums[i];\\n    leftMax = Math.max(leftMax, leftSum);\\n  }\\n  // right\\n  int rightSum = nums[mid + 1]; // lo < hi is guaranteed\\n  int rightMax = rightSum;\\n  for (int i = mid + 2; i <= hi; ++i) {\\n    rightSum += nums[i];\\n    rightMax = Math.max(rightMax, rightSum);\\n  }\\n  return leftMax + rightMax;\\n}\\n```\n```java\\npublic int maxSubArray(int[] nums) {\\n  int n = nums.length;\\n  int[] SUM = new int[n];\\n  int[] OPT = new int[n];\\n  SUM[0] = nums[0]; // init\\n  OPT[0] = nums[0];\\n  for (int i = 1; i < n; ++i) {\\n    SUM[i] = Math.max(SUM[i - 1] + nums[i], nums[i]);\\n    OPT[i] = Math.max(OPT[i - 1], SUM[i]);\\n  }\\n  return OPT[n - 1];\\n}\\n```\n```java\\npublic int maxSubArray(int[] nums) {\\n  int n = nums.length;\\n  int SUM = nums[0];\\n  int OPT = nums[0];\\n  for (int i = 1; i < n; ++i) {\\n    SUM = Math.max(SUM + nums[i], nums[i]);\\n    OPT = Math.max(OPT, SUM);\\n  }\\n  return OPT;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3336498,
                "title": "simple-java-1ms-beats-100-easy-to-understand-look-at-once",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# ***simple sliding window approach***\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n# ***simple sliding window approach***\\n# Complexity\\n# ***- Time complexity: O(n)***\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# ***- Space complexity: O(1)***\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum = 0 , maxi = Integer.MIN_VALUE;;\\n        int i = 0 , j = 0;\\n        while(j<nums.length){\\n           \\n            if(sum < 0 && nums[j] >= sum){\\n                sum = 0;\\n                i = j;\\n            }\\n             sum += nums[j];\\n            maxi = Math.max(maxi , sum);\\n            j++;\\n        }\\n        return maxi;\\n    }\\n}\\n```\\n**If this solution helped you, give it an up-vote to help others**![download.jfif](https://assets.leetcode.com/users/images/ebeb56c7-dcb5-4061-8db1-be85a2c2dce8_1679675105.9124558.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum = 0 , maxi = Integer.MIN_VALUE;;\\n        int i = 0 , j = 0;\\n        while(j<nums.length){\\n           \\n            if(sum < 0 && nums[j] >= sum){\\n                sum = 0;\\n                i = j;\\n            }\\n             sum += nums[j];\\n            maxi = Math.max(maxi , sum);\\n            j++;\\n        }\\n        return maxi;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1411166,
                "title": "c-brute-force-to-optimal-3-solutions-easy-to-understand",
                "content": "**Approach 1 - TC: O(n3) TLE** \\nRun three loops,  get all possible subarrays in two loops and their sum in another loop, then return the maximum of them.\\n         \\n**Approach 2- TC: O(n2)**\\nIf we optimise the above approach, we can get sum of all possible subarrays in two loops only, then return the maximum so far.\\n```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int max_sum = INT_MIN;\\n        \\n        for(int i=0; i<nums.size(); i++){\\n            int curr_sum = 0;\\n            for(int j=i; j<nums.size(); j++){\\n                curr_sum += nums[j];\\n                //cout<<curr_sum<<endl;\\n                max_sum = max(max_sum, curr_sum);\\n            }\\n        }\\n    return max_sum;\\n    }\\n};\\n```\\n\\n**Approach 3 Kadane Algorithm - TC: O(n)**\\nUsing this approach we can get the maximum sum of subarray in just O(n) time complexity.\\n```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int MAX = INT_MIN;\\n        int sum = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            sum += nums[i];\\n            MAX = max(sum, MAX);\\n            if(sum < 0) sum = 0;\\n        }\\n        return MAX;\\n    }\\n};\\n```\\n\\nThanks, upvote if you liked it. Comment down below if you have any doubts or suggestions.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int max_sum = INT_MIN;\\n        \\n        for(int i=0; i<nums.size(); i++){\\n            int curr_sum = 0;\\n            for(int j=i; j<nums.size(); j++){\\n                curr_sum += nums[j];\\n                //cout<<curr_sum<<endl;\\n                max_sum = max(max_sum, curr_sum);\\n            }\\n        }\\n    return max_sum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int MAX = INT_MIN;\\n        int sum = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            sum += nums[i];\\n            MAX = max(sum, MAX);\\n            if(sum < 0) sum = 0;\\n        }\\n        return MAX;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 20471,
                "title": "javascript-solution",
                "content": "    function maxSubArray(A) {\\n      var prev = 0;\\n      var max = -Number.MAX_VALUE;\\n    \\n      for (var i = 0; i < A.length; i++) {\\n        prev = Math.max(prev + A[i], A[i]);\\n        max = Math.max(max, prev);\\n      }\\n      return max;\\n    }",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    function maxSubArray(A) {\\n      var prev = 0;\\n      var max = -Number.MAX_VALUE;\\n    \\n      for (var i = 0; i < A.length; i++) {\\n        prev = Math.max(prev + A[i], A[i]);\\n        max = Math.max(max, prev);\\n      }\\n      return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3169660,
                "title": "best-c-4-solution-dp-divide-and-conquer-kadane-s-algorithm-brute-force-optimize",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question using Multiple Approaches.\\n\\n1. Solved using Array(Two Nested Loops). Brute Force Approach.\\n2. Solved using Array + Divide and Conquer.\\n3. Solved using Dynamic Programming Approach(tabulation).\\n4. Solved using Kadane\\u2019s Algorithm. Optimized Approach.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the All the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)\\n\\n**IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.**\\n\\n```\\n/*\\n\\n    Time Complexity : O(N^2), Where N is the size of the array. Here total number of iterations are : N*(N\\u20131)/2.\\n\\n    Space complexity : O(1), Constant space.\\n\\n    Solved using Array(Two Nested Loop). Brute Force Approach.\\n\\n    Note : This will give TLE.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int n = nums.size();\\n        int maximumSumSubarray = INT_MIN;\\n        for(int i=0; i<n; i++){\\n            int currSum = 0;\\n            for(int j=i; j<n; j++){\\n                currSum += nums[j];\\n                if(currSum > maximumSumSubarray){\\n                    maximumSumSubarray = currSum;\\n                }\\n            }\\n        }\\n        return maximumSumSubarray;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(NlogN), One linear scans of length N and Each recursive call to performs two recursive\\n    calls on subslices of size N/2. Therefore, the time complexity of the divide & conquer approach can be\\n    represented by the following recurrence relation: T(N)=2T(N/2)+N. Where N is the size of the Array(nums).\\n\\n    Space Complexity : O(logN), Recursion Stack Space. \\n\\n    Solved using Array + Divide and Conquer.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\nprivate:\\n    int maxSubArray(vector<int>& nums, int low, int high){\\n        if(low == high){\\n            return nums[low];\\n        }\\n        int leftMaxSumSubarray = INT_MIN, rightMaxSumSubarray = INT_MIN;\\n\\n        int mid = (low + high) >> 1;\\n        int currSum = 0;\\n        for(int i=mid; i>=low; i--){\\n            currSum += nums[i];\\n            leftMaxSumSubarray = max(leftMaxSumSubarray, currSum);\\n        }\\n\\n        currSum = 0;\\n        for(int i=mid+1; i<=high; i++){\\n            currSum += nums[i];\\n            rightMaxSumSubarray = max(rightMaxSumSubarray, currSum);\\n        }\\n\\n        int maxSumSubarray =  leftMaxSumSubarray +  rightMaxSumSubarray;\\n        int leftAnsSum = maxSubArray(nums, low, mid);\\n        int rightAnsSum = maxSubArray(nums, mid+1, high);\\n\\n        return max(maxSumSubarray, max(leftAnsSum, rightAnsSum));\\n    }\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        return maxSubArray(nums, 0, nums.size()-1);\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N). Where N is the size of the Array(nums).\\n    Space Complexity : O(N), Array(dp) space.\\n\\n    Solved using Dynamic Programming Approach(tabulation).\\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int n = nums.size();\\n        int dp[n];\\n        dp[0] = nums[0];\\n        int maximumSumSubarray = nums[0];\\n        for(int i=1; i<n; i++){\\n            dp[i] = nums[i] + (dp[i-1] > 0 ? dp[i-1] : 0);\\n            maximumSumSubarray = max(maximumSumSubarray, dp[i]);\\n        }\\n        return maximumSumSubarray;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), Since we traversed the array(nums) only ones. Where N is the size of the nums.\\n\\n    Space Complexity : O(1), Constant space.\\n\\n    Solved using Kadane\\u2019s Algorithm.\\n\\n*/\\n\\n\\n/***************************************** Approach 4 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int n = nums.size();\\n        int currSum = 0, maximumSumSubarray = INT_MIN;\\n        for(auto num : nums){\\n            currSum += num;\\n            if(currSum > maximumSumSubarray){\\n                maximumSumSubarray = currSum;\\n            }\\n            if(currSum < 0){\\n                currSum = 0;\\n            }\\n        }\\n        return maximumSumSubarray;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Divide and Conquer",
                    "Dynamic Programming"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N^2), Where N is the size of the array. Here total number of iterations are : N*(N\\u20131)/2.\\n\\n    Space complexity : O(1), Constant space.\\n\\n    Solved using Array(Two Nested Loop). Brute Force Approach.\\n\\n    Note : This will give TLE.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int n = nums.size();\\n        int maximumSumSubarray = INT_MIN;\\n        for(int i=0; i<n; i++){\\n            int currSum = 0;\\n            for(int j=i; j<n; j++){\\n                currSum += nums[j];\\n                if(currSum > maximumSumSubarray){\\n                    maximumSumSubarray = currSum;\\n                }\\n            }\\n        }\\n        return maximumSumSubarray;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(NlogN), One linear scans of length N and Each recursive call to performs two recursive\\n    calls on subslices of size N/2. Therefore, the time complexity of the divide & conquer approach can be\\n    represented by the following recurrence relation: T(N)=2T(N/2)+N. Where N is the size of the Array(nums).\\n\\n    Space Complexity : O(logN), Recursion Stack Space. \\n\\n    Solved using Array + Divide and Conquer.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\nprivate:\\n    int maxSubArray(vector<int>& nums, int low, int high){\\n        if(low == high){\\n            return nums[low];\\n        }\\n        int leftMaxSumSubarray = INT_MIN, rightMaxSumSubarray = INT_MIN;\\n\\n        int mid = (low + high) >> 1;\\n        int currSum = 0;\\n        for(int i=mid; i>=low; i--){\\n            currSum += nums[i];\\n            leftMaxSumSubarray = max(leftMaxSumSubarray, currSum);\\n        }\\n\\n        currSum = 0;\\n        for(int i=mid+1; i<=high; i++){\\n            currSum += nums[i];\\n            rightMaxSumSubarray = max(rightMaxSumSubarray, currSum);\\n        }\\n\\n        int maxSumSubarray =  leftMaxSumSubarray +  rightMaxSumSubarray;\\n        int leftAnsSum = maxSubArray(nums, low, mid);\\n        int rightAnsSum = maxSubArray(nums, mid+1, high);\\n\\n        return max(maxSumSubarray, max(leftAnsSum, rightAnsSum));\\n    }\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        return maxSubArray(nums, 0, nums.size()-1);\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N). Where N is the size of the Array(nums).\\n    Space Complexity : O(N), Array(dp) space.\\n\\n    Solved using Dynamic Programming Approach(tabulation).\\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int n = nums.size();\\n        int dp[n];\\n        dp[0] = nums[0];\\n        int maximumSumSubarray = nums[0];\\n        for(int i=1; i<n; i++){\\n            dp[i] = nums[i] + (dp[i-1] > 0 ? dp[i-1] : 0);\\n            maximumSumSubarray = max(maximumSumSubarray, dp[i]);\\n        }\\n        return maximumSumSubarray;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), Since we traversed the array(nums) only ones. Where N is the size of the nums.\\n\\n    Space Complexity : O(1), Constant space.\\n\\n    Solved using Kadane\\u2019s Algorithm.\\n\\n*/\\n\\n\\n/***************************************** Approach 4 *****************************************/\\n\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int n = nums.size();\\n        int currSum = 0, maximumSumSubarray = INT_MIN;\\n        for(auto num : nums){\\n            currSum += num;\\n            if(currSum > maximumSumSubarray){\\n                maximumSumSubarray = currSum;\\n            }\\n            if(currSum < 0){\\n                currSum = 0;\\n            }\\n        }\\n        return maximumSumSubarray;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 364839,
                "title": "divide-conquer-commented-explanation-and-big-o-js",
                "content": "It took me a while to understand the divide and conquer approach because the solutions I was seeing didn\\'t have much explanation, rarely had code comments, and had cryptic variable names. I\\'ve added extensive comments below and more descriptive variable names. Let me know of any improvements to the explanations!\\n\\nTime complexity seems to be O(n * log(n)) based on case 2 of the Master Theorem: T(n) = a T(n/b) + f(n). Plus, it follows the pattern of merge sort, which can be analyzed in the same way and is O(n * log(n)). Resources for understanding the Master Theorem:\\nhttps://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)\\nhttps://www.youtube.com/watch?v=6CX7s7JnXs0\\n```\\nvar maxSubArray = function(nums) {\\n\\t// Return the results of the recursive function\\n    return findMaxSumInArr(nums);\\n    \\n\\t// Recursive function that will divide and conquer to find the maximum sum from a subarray of the array provided as a parameter\\n    function findMaxSumInArr(arr){\\n        // BASE CASES: \\n        // if there is only one arr item, then you can simply return that value\\n        if (arr.length === 1){\\n            return arr[0];\\n        }\\n\\t\\t\\n        /* if there isn\\'t an arr item, then return -Infinity (we need a valid number for the calculations below. \\n\\t\\tSince JS can only store numbers > -Infinity, -Infinity will never be the max) */\\n        if (arr.length === 0){\\n            return -Infinity;\\n        }\\n        \\n\\t\\t// Declare zero-indexed length and midpoint\\n        let length = arr.length - 1;\\n        let mid = Math.floor( length/2 );\\n        \\n        // DIVIDE: Recursively find max sum in the left and right sub arrays\\n        let lMaxSumInSubArr = findMaxSumInArr( arr.slice(0, mid) );\\n        let rMaxSumInSubArr = findMaxSumInArr( arr.slice(mid + 1, length + 1) );\\n        \\n        /* MERGE: The divide step gave use the max sum on the left and right side, but we still need to account\\n\\t\\tfor the possibility of a contiguous array that goes from left to right through the midpoint */\\n\\t\\t\\n        // Declare variables to record the maximum contiguous sums for each side\\n        let lMaxContiguousSum = 0,\\n            rMaxContiguousSum = 0;\\n        \\n        // On the left side, find sum of contiguous array and keep an updated record of the maximum\\n        /* (NOTE: in order to account for contiguous arrays that traverse the midpoint, start the search from\\n\\t\\tthe midpoint - 1 index and traverse leftwards towards index 0. This directionality guarantees that\\n\\t\\ta contiguous array traversing the midpoint will be able to add the midpoint itself and the right side\\'s\\n\\t\\tcontiguous arr [this is exactly what is checked in the final return statement below]) */\\n        for (let i = mid - 1, currContiguousSum = 0; i >= 0; i--){\\n            currContiguousSum += arr[i];\\n            lMaxContiguousSum = Math.max(lMaxContiguousSum, currContiguousSum);\\n        }\\n       \\n        // On the left side, find sum of contiguous array and keep an updated record of the maximum\\n        /* (NOTE: in accordance with the last note, to account for sub arrays that traverse the midpoint, \\n\\t\\tstart the search from the midpoint + 1 index and traverse rightwards */\\n        for (let i = mid + 1, currContiguousSum = 0; i <= length; i++){\\n            currContiguousSum += arr[i];\\n            rMaxContiguousSum = Math.max(rMaxContiguousSum, currContiguousSum);\\n        }\\n        \\n        /* RETURN the max sum from the current array: either from the left side, right side, or a contiguous\\n\\t\\tsub arrary traversing from left to right through the midpoint */\\n        return Math.max(\\n            // The maximum sum from a contiguous subarray that traverses the midpoint\\n            lMaxContiguousSum + arr[mid] + rMaxContiguousSum, \\n            // The max sum from each side (whether it was a single value or a contiguous sum) \\n            lMaxSumInSubArr, \\n            rMaxSumInSubArr  \\n        );\\n    }\\n}\\n```\\n\\nExtra Notes:\\n- For the divide step, slicing the array made the most sense to me, but you could also keep the original array unaltered and simply update left and right bounds (this would necessitate changing code throughout the function, like the initial base cases would have to check for ```left === right``` and `left > right` respectively)",
                "solutionTags": [
                    "JavaScript",
                    "Divide and Conquer",
                    "Recursion"
                ],
                "code": "```\\nvar maxSubArray = function(nums) {\\n\\t// Return the results of the recursive function\\n    return findMaxSumInArr(nums);\\n    \\n\\t// Recursive function that will divide and conquer to find the maximum sum from a subarray of the array provided as a parameter\\n    function findMaxSumInArr(arr){\\n        // BASE CASES: \\n        // if there is only one arr item, then you can simply return that value\\n        if (arr.length === 1){\\n            return arr[0];\\n        }\\n\\t\\t\\n        /* if there isn\\'t an arr item, then return -Infinity (we need a valid number for the calculations below. \\n\\t\\tSince JS can only store numbers > -Infinity, -Infinity will never be the max) */\\n        if (arr.length === 0){\\n            return -Infinity;\\n        }\\n        \\n\\t\\t// Declare zero-indexed length and midpoint\\n        let length = arr.length - 1;\\n        let mid = Math.floor( length/2 );\\n        \\n        // DIVIDE: Recursively find max sum in the left and right sub arrays\\n        let lMaxSumInSubArr = findMaxSumInArr( arr.slice(0, mid) );\\n        let rMaxSumInSubArr = findMaxSumInArr( arr.slice(mid + 1, length + 1) );\\n        \\n        /* MERGE: The divide step gave use the max sum on the left and right side, but we still need to account\\n\\t\\tfor the possibility of a contiguous array that goes from left to right through the midpoint */\\n\\t\\t\\n        // Declare variables to record the maximum contiguous sums for each side\\n        let lMaxContiguousSum = 0,\\n            rMaxContiguousSum = 0;\\n        \\n        // On the left side, find sum of contiguous array and keep an updated record of the maximum\\n        /* (NOTE: in order to account for contiguous arrays that traverse the midpoint, start the search from\\n\\t\\tthe midpoint - 1 index and traverse leftwards towards index 0. This directionality guarantees that\\n\\t\\ta contiguous array traversing the midpoint will be able to add the midpoint itself and the right side\\'s\\n\\t\\tcontiguous arr [this is exactly what is checked in the final return statement below]) */\\n        for (let i = mid - 1, currContiguousSum = 0; i >= 0; i--){\\n            currContiguousSum += arr[i];\\n            lMaxContiguousSum = Math.max(lMaxContiguousSum, currContiguousSum);\\n        }\\n       \\n        // On the left side, find sum of contiguous array and keep an updated record of the maximum\\n        /* (NOTE: in accordance with the last note, to account for sub arrays that traverse the midpoint, \\n\\t\\tstart the search from the midpoint + 1 index and traverse rightwards */\\n        for (let i = mid + 1, currContiguousSum = 0; i <= length; i++){\\n            currContiguousSum += arr[i];\\n            rMaxContiguousSum = Math.max(rMaxContiguousSum, currContiguousSum);\\n        }\\n        \\n        /* RETURN the max sum from the current array: either from the left side, right side, or a contiguous\\n\\t\\tsub arrary traversing from left to right through the midpoint */\\n        return Math.max(\\n            // The maximum sum from a contiguous subarray that traverses the midpoint\\n            lMaxContiguousSum + arr[mid] + rMaxContiguousSum, \\n            // The max sum from each side (whether it was a single value or a contiguous sum) \\n            lMaxSumInSubArr, \\n            rMaxSumInSubArr  \\n        );\\n    }\\n}\\n```\n```left === right```",
                "codeTag": "Unknown"
            },
            {
                "id": 20225,
                "title": "my-divide-and-conquer-solution-in-java-under-instruction-of-clrs-o-nlogn",
                "content": "    public class Solution {//divdie and conquer\\n        public int maxSubArray(int[] nums) {\\n            return Subarray(nums, 0 ,nums.length -1 );\\n        }\\n        public int Subarray(int[] A,int left, int right){\\n            if(left == right){return A[left];}\\n            int mid = left + (right - left) / 2;\\n            int leftSum = Subarray(A,left,mid);// left part \\n            int rightSum = Subarray(A,mid+1,right);//right part\\n            int crossSum = crossSubarray(A,left,right);// cross part\\n            if(leftSum >= rightSum && leftSum >= crossSum){// left part is max\\n                return leftSum;\\n            }\\n            if(rightSum >= leftSum && rightSum >= crossSum){// right part is max\\n                return rightSum;\\n            }\\n            return crossSum; // cross part is max\\n        }\\n        public int crossSubarray(int[] A,int left,int right){\\n            int leftSum = Integer.MIN_VALUE;\\n            int rightSum = Integer.MIN_VALUE;\\n            int sum = 0;\\n            int mid = left + (right - left) / 2;\\n            for(int i = mid; i >= left ; i--){\\n                sum = sum + A[i];\\n                if(leftSum < sum){\\n                    leftSum = sum;\\n                }\\n            }\\n            sum = 0;\\n            for(int j = mid + 1; j <= right; j++){\\n                sum = sum + A[j];\\n                if(rightSum < sum){\\n                    rightSum = sum;\\n                }\\n            }\\n            return leftSum + rightSum;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer"
                ],
                "code": "class Solution {//divdie and conquer\\n        public int maxSubArray(int[] nums) {\\n            return Subarray(nums, 0 ,nums.length -1 );\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 20442,
                "title": "my-concise-o-n-dp-java-solution",
                "content": "**Explanation**\\n\\nAlthough there're some other simplified solutions, but DP solution can make the original thought for this problem clearer. In this solution, dp[i] means the largest sum among the subarrays whose last element is A[i].\\n\\n**Solution1. DP Solution - O(n) time, O(n) space**\\n   \\n\\n    public int maxSubArray(int[] A) {\\n    \\tint dp[] = new int[A.length]; int max = A[0]; dp[0] = A[0]; \\n    \\tfor (int i = 1; i < A.length; i++) {\\t\\t\\t\\n    \\t\\tdp[i] = Math.max(dp[i-1] + A[i] ,A[i]);\\n    \\t\\tmax = Math.max(max, dp[i]);\\n    \\t}\\n    \\treturn max;\\n    }\\n\\n**Solution2. Simplified DP Solution - O(n) time, O(1) space** *- Special thanks for TWiStErRob's smart comment*\\n\\nThe basic idea is to check previous sum, reset it to 0 if it's less than 0.\\n\\n    public int maxSubArray(int[] A) {\\n        int res = Integer.MIN_VALUE, sum = 0;\\n        for (int i = 0; i < A.length; i++) {\\n            sum = Math.max(sum, 0) + A[i];\\n            res = Math.max(res, sum);\\n        }\\n        return res;\\n    }  \\n\\n\\n**Solution3. Pre-Sum Array Solution - O(n) time, O(n) space**\\n\\nThe basic idea is to use pre-sum array, max =  Math.max(max, sum[i] - minSum). (minSum is the minimum sum before A[i])\\n\\n    public int maxSubArray(int[] A) {\\n    \\tif (A == null || A.length == 0) return 0;\\n    \\tint max = A[0], minSum = Integer.MAX_VALUE;\\n    \\tint sum[] = new int[A.length];\\n    \\tsum[0] = A[0];\\t\\n    \\tfor (int i = 1; i < A.length; i++) {\\n    \\t\\tsum[i] = sum[i-1] + A[i];\\n    \\t\\tminSum = Math.min(0, Math.min(minSum, sum[i-1]));\\n    \\t\\tmax = Math.max(max, sum[i] - minSum); \\n    \\t}\\n    \\treturn max;\\n    }",
                "solutionTags": [],
                "code": "**Explanation**\\n\\nAlthough there're some other simplified solutions, but DP solution can make the original thought for this problem clearer. In this solution, dp[i] means the largest sum among the subarrays whose last element is A[i].\\n\\n**Solution1. DP Solution - O(n) time, O(n) space**\\n   \\n\\n    public int maxSubArray(int[] A) {\\n    \\tint dp[] = new int[A.length]; int max = A[0]; dp[0] = A[0]; \\n    \\tfor (int i = 1; i < A.length; i++) {\\t\\t\\t\\n    \\t\\tdp[i] = Math.max(dp[i-1] + A[i] ,A[i]);\\n    \\t\\tmax = Math.max(max, dp[i]);\\n    \\t}\\n    \\treturn max;\\n    }\\n\\n**Solution2. Simplified DP Solution - O(n) time, O(1) space** *- Special thanks for TWiStErRob's smart comment*\\n\\nThe basic idea is to check previous sum, reset it to 0 if it's less than 0.\\n\\n    public int maxSubArray(int[] A) {\\n        int res = Integer.MIN_VALUE, sum = 0;\\n        for (int i = 0; i < A.length; i++) {\\n            sum = Math.max(sum, 0) + A[i];\\n            res = Math.max(res, sum);\\n        }\\n        return res;\\n    }  \\n\\n\\n**Solution3. Pre-Sum Array Solution - O(n) time, O(n) space**\\n\\nThe basic idea is to use pre-sum array, max =  Math.max(max, sum[i] - minSum). (minSum is the minimum sum before A[i])\\n\\n    public int maxSubArray(int[] A) {\\n    \\tif (A == null || A.length == 0) return 0;\\n    \\tint max = A[0], minSum = Integer.MAX_VALUE;\\n    \\tint sum[] = new int[A.length];\\n    \\tsum[0] = A[0];\\t\\n    \\tfor (int i = 1; i < A.length; i++) {\\n    \\t\\tsum[i] = sum[i-1] + A[i];\\n    \\t\\tminSum = Math.min(0, Math.min(minSum, sum[i-1]));\\n    \\t\\tmax = Math.max(max, sum[i] - minSum); \\n    \\t}\\n    \\treturn max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 139218,
                "title": "javascript-very-clear-and-short-dp-solution",
                "content": "```\\nvar maxSubArray = function(nums) {\\n    for (let i = 1; i < nums.length; i++){\\n        nums[i] = Math.max(nums[i], nums[i] + nums[i - 1]);\\n    }\\n    return Math.max(...nums);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar maxSubArray = function(nums) {\\n    for (let i = 1; i < nums.length; i++){\\n        nums[i] = Math.max(nums[i], nums[i] + nums[i - 1]);\\n    }\\n    return Math.max(...nums);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 20360,
                "title": "c-an-clear-o-n-divide-and-conquer-solution-with-comments",
                "content": "For each subarray, calculate four attributes: \\n\\n    mx (largest sum of this subarray), \\n    lmx(largest sum starting from the left most element), \\n    rmx(largest sum ending with the right most element), \\n    sum(the sum of the total subarray). \\nThe recurrence is: T(n) = 2T(n / 2) + O(1). So the running time of this algorithm is O(n).\\n\\n    class Solution {\\n    public:\\n        void maxSubArray(vector<int>& nums, int l, int r, int& mx, int& lmx, int& rmx, int& sum) {\\n            if (l == r) {\\n                mx = lmx = rmx = sum = nums[l];\\n            }\\n            else {\\n                int m = (l + r) / 2;\\n                int mx1, lmx1, rmx1, sum1;\\n                int mx2, lmx2, rmx2, sum2;\\n                maxSubArray(nums, l, m, mx1, lmx1, rmx1, sum1);\\n                maxSubArray(nums, m + 1, r, mx2, lmx2, rmx2, sum2);\\n                mx = max(max(mx1, mx2), rmx1 + lmx2);\\n                lmx = max(lmx1, sum1 + lmx2);\\n                rmx = max(rmx2, sum2 + rmx1);\\n                sum = sum1 + sum2;\\n            }\\n        }\\n        int maxSubArray(vector<int>& nums) {\\n            if (nums.size() == 0) {\\n                return 0;\\n            }\\n            int mx, lmx, rmx, sum;\\n            maxSubArray(nums, 0, nums.size() - 1, mx, lmx, rmx, sum);\\n            return mx;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Divide and Conquer"
                ],
                "code": "class Solution {\\n    public:\\n        void maxSubArray(vector<int>& nums, int l, int r, int& mx, int& lmx, int& rmx, int& sum) {\\n            if (l == r) {\\n                mx = lmx = rmx = sum = nums[l];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 20481,
                "title": "java-o-n-time-o-1-space-5-lines-of-code",
                "content": "    public int maxSubArray(int[] nums) {\\n        int currMax=nums[0],max=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            currMax=Math.max(currMax+nums[i],nums[i]);\\n            max=Math.max(max,currMax);\\n        }\\n        return max;\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "    public int maxSubArray(int[] nums) {\\n        int currMax=nums[0],max=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            currMax=Math.max(currMax+nums[i],nums[i]);\\n            max=Math.max(max,currMax);\\n        }\\n        return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 562928,
                "title": "javascript-kadane-s-algorithm-implementation-w-explanation",
                "content": "if you had difficulties with this problem, just like me, then I hope it will be useful to you\\n\\n1. set initials\\n1.1 first value in the array. It doesn\\u2019t matter to us whether `max` is positive or negative.\\n1.2 we need an intermediate `current` positive value, because a negative value does not interest us, since -2 is always more than -5 and it means `0 + -2 > -5`.\\n2. At this point we\\'ve covered first value in the array, that\\'s why we will move through array starting from the `1` index.\\n3. `current += nums[i]` means that every time we take a new value, we will sum it with the past `current` value. This will help us discard lower values in the next step.\\n4. `max = Math.max(max, current)` means that we choose only the highest value (previous `max` or new `current`).\\n5. `current = Math.max(current, 0)` means that if the value was negative, then we throw it away and set zero as default. Why? Because it makes no sense to summarize the negative values, they simply do not interest us. The previous step is enough to compare negative values. There we will choose the minimum negative value (if it is the case i.e     `[-10, -3, -5, -2, -6]` will return only `-2` because it is the highest value from the negative ones.\\n\\n```javascript\\nconst maxSubArray = nums => {\\n    let max = nums[0];\\n    let current = Math.max(max, 0);\\n    \\n    for (let i = 1; i < nums.length; i += 1) {\\n        current += nums[i];\\n        max = Math.max(max, current);\\n        current = Math.max(current, 0);\\n    }\\n    \\n    return max;\\n};\\n```\\n\\nHappy coding :)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nconst maxSubArray = nums => {\\n    let max = nums[0];\\n    let current = Math.max(max, 0);\\n    \\n    for (let i = 1; i < nums.length; i += 1) {\\n        current += nums[i];\\n        max = Math.max(max, current);\\n        current = Math.max(current, 0);\\n    }\\n    \\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 164670,
                "title": "javascript-solution-comparisons",
                "content": "So I was implementing a dynamic appraoch, and I though it would be good practice to implement a the different solutions that I could think of and analyze the Big O of each of them.\\n\\n### O(n\\xB2) Time - O(1) Space - Naive approach\\n##### 320ms on my connection\\n```Javascript\\nvar maxSubArray = function(nums) {\\n  let max = nums[0];\\n\\n  for (let i = 0; i < nums.length; i += 1) {\\n    let currentMax = nums[i];\\n    for (let j = i + 1; j <nums.length; j += 1) {\\n      currentMax = Math.max(currentMax + nums[j], nums[j]);\\n      max = Math.max(currentMax, max);\\n    }\\n  }\\n  \\n  return max;\\n};\\n```\\n\\nWhat is going on here is that we check from the start of number at i, and then add each sequential number at j. Each iteration will check to see what the ```currentMax``` is, either ```nums[j]``` or ```nums[j] + currentMax```, and them compare the ```max``` to the ```currentMax```. This will run for every number and thus we have a time quadratic time complexity with a constant space complexity. This is passing, however, there should be more tests that should get filter out this solution. O(n\\xB2) should be avoided if there is a better solution.\\n\\n### O(n) Time - O(n) Space - Dynamic Hashing\\n##### 88ms on my connection\\n```Javascript\\nvar maxSubArray = function(nums) {\\n  const hash = { 0: nums[0]}\\n  let max = nums[0];\\n\\n  for (let i = 1; i < nums.length; i += 1) {\\n    hash[i] = Math.max(hash[i - 1] + nums[i], nums[i]);\\n    max = Math.max(hash[i], max);\\n  }\\n  \\n  return max;\\n};\\n```\\n\\nFor this solution we are utilizing a hash to keep track of the max for the previous number. What we calculate the maximum based on the previous maximum and the current value. The **KEY** point here is that we are looking for the largest **SEQUENTIAL** max.\\n\\nExample, take this array of four numbers:\\n```Javascript\\nconst nums = [1, -10, 5, 6];\\n```\\nThe maximum value that you can get from a subarray from index 0 to 0 (```nums[0]```) is the value itself. When we look at the next value, the maximum value you can get would either be the previous value plus the current value or the current value itself. So what we do is create a hash to keep track of the maxes at each index:\\n```Javascript\\n// Key : Value => index : max at that index\\nconst hash = {\\n  0: 1 // nums[0] since there was no previous max\\n  1: -9 // hash[0] + nums[1] > nums[1] => 1 + -10 > -10\\n  2: 5 // hash[1] + nums[2] < nums[2] => -9 + 5 < 5\\n  3: 11 // hash[2] + nums[3] > nums[3] => 5 + 6 > 6\\n}\\n```\\nThis may seem strange since we are not technically checking at every single possibility, but the pattern allows us to come to this solution. Whe have a O(n) time solution with a O(n) space complexity. However, it is far faster than the previous solution. We can, however, improve this even more to utilize constant space.\\n\\n### O(n) Time - O(1) Space - No Hashing!\\n##### 60ms on my connection\\n```Javascript\\nvar maxSubArray = function(nums) {\\n  let currentMax = nums[0];\\n  let max = nums[0];\\n\\n  for (let i = 1; i < nums.length; i += 1) {\\n    currentMax = Math.max(currentMax + nums[i], nums[i]);\\n    max = Math.max(currentMax, max);\\n  }\\n  \\n  return max;\\n};\\n```\\n\\nIf you\\'ve noticed, we only needed to worry about the previous max value at each index of the array, so we don\\'t need to keep track of every max at each instance for this function. By just storing the previous maximum for each element, we can check the ```currentMax``` like we have been in the previous examples and set the ```max``` accordingly. This solution retain the O(n) time complexity, but removes the necessity for keeping track of every element we come across.",
                "solutionTags": [],
                "code": "```Javascript\\nvar maxSubArray = function(nums) {\\n  let max = nums[0];\\n\\n  for (let i = 0; i < nums.length; i += 1) {\\n    let currentMax = nums[i];\\n    for (let j = i + 1; j <nums.length; j += 1) {\\n      currentMax = Math.max(currentMax + nums[j], nums[j]);\\n      max = Math.max(currentMax, max);\\n    }\\n  }\\n  \\n  return max;\\n};\\n```\n```currentMax```\n```nums[j]```\n```nums[j] + currentMax```\n```max```\n```currentMax```\n```Javascript\\nvar maxSubArray = function(nums) {\\n  const hash = { 0: nums[0]}\\n  let max = nums[0];\\n\\n  for (let i = 1; i < nums.length; i += 1) {\\n    hash[i] = Math.max(hash[i - 1] + nums[i], nums[i]);\\n    max = Math.max(hash[i], max);\\n  }\\n  \\n  return max;\\n};\\n```\n```Javascript\\nconst nums = [1, -10, 5, 6];\\n```\n```nums[0]```\n```Javascript\\n// Key : Value => index : max at that index\\nconst hash = {\\n  0: 1 // nums[0] since there was no previous max\\n  1: -9 // hash[0] + nums[1] > nums[1] => 1 + -10 > -10\\n  2: 5 // hash[1] + nums[2] < nums[2] => -9 + 5 < 5\\n  3: 11 // hash[2] + nums[3] > nums[3] => 5 + 6 > 6\\n}\\n```\n```Javascript\\nvar maxSubArray = function(nums) {\\n  let currentMax = nums[0];\\n  let max = nums[0];\\n\\n  for (let i = 1; i < nums.length; i += 1) {\\n    currentMax = Math.max(currentMax + nums[i], nums[i]);\\n    max = Math.max(currentMax, max);\\n  }\\n  \\n  return max;\\n};\\n```\n```currentMax```\n```max```",
                "codeTag": "Unknown"
            },
            {
                "id": 118509,
                "title": "c-kadane-s-algorithm",
                "content": "The following solution uses the an algorithm called **`Kadane\\'s Algorithm`**.\\n\\nTo know more about this algorithm, check this video from CS Dojo: \\nhttps://www.youtube.com/watch?v=86CQq3pKSUw\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        \\n        int currentSum =nums[0], totalSum = nums[0];\\n        \\n        for(int i=1; i<nums.size(); i++) {\\n            \\n            //Current max sum is either the current element OR current element + Previous Maximum subarray)\\n            currentSum = max(nums[i], currentSum+nums[i]); \\n            \\n            //If the current maximum array sum is greater than the global total. Update it\\n            totalSum = max(totalSum, currentSum);\\n    }\\n        return totalSum;\\n    }\\n};\\n```\\n\\n\\nI would like to thank [@kadoyan](https://leetcode.com/problems/maximum-subarray/discuss/110801/Kadane\\'s-Algorithm-in-Javascript-O(n)/117997?page=1) for his Solution.\\n\\n\\nMethod 2 : Coding Ninja Method\\n```\\nint maxSubArray(vector<int>& nums) {\\n        \\n        int currentSum = 0, totalSum = INT_MIN;\\n        \\n        for(int i=0; i<nums.size(); i++) {\\n            \\n            //Sum till this point ======= Current Sum till this point + this element\\n            currentSum = currentSum + nums[i]; \\n            \\n            //If the current maximum array sum is greater than the global total. Update it\\n            totalSum = max(totalSum, currentSum);\\n            \\n            //If you get current as less thn 0 then its no point in carrying forward. Make it 0\\n            currentSum = max(0,currentSum);\\n    }\\n        return totalSum;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        \\n        int currentSum =nums[0], totalSum = nums[0];\\n        \\n        for(int i=1; i<nums.size(); i++) {\\n            \\n            //Current max sum is either the current element OR current element + Previous Maximum subarray)\\n            currentSum = max(nums[i], currentSum+nums[i]); \\n            \\n            //If the current maximum array sum is greater than the global total. Update it\\n            totalSum = max(totalSum, currentSum);\\n    }\\n        return totalSum;\\n    }\\n};\\n```\n```\\nint maxSubArray(vector<int>& nums) {\\n        \\n        int currentSum = 0, totalSum = INT_MIN;\\n        \\n        for(int i=0; i<nums.size(); i++) {\\n            \\n            //Sum till this point ======= Current Sum till this point + this element\\n            currentSum = currentSum + nums[i]; \\n            \\n            //If the current maximum array sum is greater than the global total. Update it\\n            totalSum = max(totalSum, currentSum);\\n            \\n            //If you get current as less thn 0 then its no point in carrying forward. Make it 0\\n            currentSum = max(0,currentSum);\\n    }\\n        return totalSum;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 369797,
                "title": "kadane-s-algorithm-with-detailed-explanation-and-example-python",
                "content": "Can be solved using **Kadane\\'s algorithm** in linear time and without using additional space. The main ideas are:\\n* Use the input vector `nums` to store the candidate subarrays sum (i.e. the greatest contiguous sum so far).\\n* Ignore cumulative negatives, as they don\\'t contribute positively to the sum.\\n\\n**Example:**\\nGiven `nums = [-2, 1, -3, 4]`. \\nCompare all elements with the cumulative sum stored in the previous index. \\n1. Since `-2 < 0`, value `-2` doesn\\'t contribute to the sum. Thus, ignore it and proceed to the next index.\\n2. Since `1 > 0`,  value `1` does contribute. Hence, compute `-3+1 = -2` and store it in index `2`.\\n3. The result vector is so far: `[-2, 1, -2, 4]`. Last element to evaluate is `4`.\\n4. Since `-2 < 0`, `-2` does not contribute positively to the sum. Thus, ignore it.\\n5. Having checked all elements, the final result vector is: `[-2, 1, -2, 4]`. \\n6. The maximum subarray is `max(num)=4`.\\n\\n```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        for i in range(1, len(nums)):\\n            if nums[i - 1] > 0: \\n                nums[i] += nums[i - 1]\\n        return max(nums\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        for i in range(1, len(nums)):\\n            if nums[i - 1] > 0: \\n                nums[i] += nums[i - 1]\\n        return max(nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 378937,
                "title": "python-dynamic-programming-solution",
                "content": "For the dynamic programming approach, this is O(n). Let\\'s think about the example [2, -1, 3, -2]. In the base case, [2] is the smallest subarray possible (starting from index 0). Its maximum subarray sum is the sole element itself, 2. The next subproblem is [2, 1]. You could either have [2, -1] (sum=1) or [-1] (sum=-1). Since the sum for the former is greater, we store 1 as the maximum subarray sum. Just by going through this example, we\\'ve discovered the recurrence relation! You could either start a new subarray for a maximum sum at index i, or you could tack on the element at index i to the previous subproblem. So, the relation here is as shown on line 4 below. Draw out an example if you can\\'t figure it out! \\n```\\ndef maxSubArray(self, nums: List[int]) -> int:\\n        dp = [0]*len(nums)\\n        dp[0] = nums[0]\\n        for i in range(1, len(nums)):\\n            dp[i] = max(dp[i-1]+nums[i], nums[i])\\n        return max(dp)\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef maxSubArray(self, nums: List[int]) -> int:\\n        dp = [0]*len(nums)\\n        dp[0] = nums[0]\\n        for i in range(1, len(nums)):\\n            dp[i] = max(dp[i-1]+nums[i], nums[i])\\n        return max(dp)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 20406,
                "title": "accepted-as-best-in-c",
                "content": "    int maxSubArray(int* nums, int size)\\n    {\\n        int sum = 0;\\n        int max = INT_MIN;\\n        for(int i = 0; i < size; i++)\\n        {\\n            if(sum >= 0)\\n                sum += nums[i];\\n            else\\n                sum = nums[i];\\n            if(sum > max)\\n                max = sum;\\n        }\\n        return max;\\n    }",
                "solutionTags": [],
                "code": "    int maxSubArray(int* nums, int size)\\n    {\\n        int sum = 0;\\n        int max = INT_MIN;\\n        for(int i = 0; i < size; i++)\\n        {\\n            if(sum >= 0)\\n                sum += nums[i];\\n            else\\n                sum = nums[i];\\n            if(sum > max)\\n                max = sum;\\n        }\\n        return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1320621,
                "title": "swift-maximum-subarray-test-cases",
                "content": "```swift\\nclass Solution {\\n    func maxSubArray(_ nums: [Int]) -> Int {\\n        var curSum = nums[0], maxSum = nums[0]\\n        for i in 1..<nums.count {\\n            curSum = max(nums[i], curSum + nums[i])\\n            maxSum = max(maxSum, curSum)\\n        }\\n        return maxSum\\n    }\\n}\\n```\\n\\n```swift\\nimport XCTest\\n\\n// Executed 3 tests, with 0 failures (0 unexpected) in 0.007 (0.009) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test1() {\\n        let res = s.maxSubArray([-2,1,-3,4,-1,2,1,-5,4])\\n        XCTAssertEqual(res, 6)\\n    }\\n    func test2() {\\n        let res = s.maxSubArray([1])\\n        XCTAssertEqual(res, 1)\\n    }\\n    func test3() {\\n        let res = s.maxSubArray([5,4,-1,7,8])\\n        XCTAssertEqual(res, 23)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func maxSubArray(_ nums: [Int]) -> Int {\\n        var curSum = nums[0], maxSum = nums[0]\\n        for i in 1..<nums.count {\\n            curSum = max(nums[i], curSum + nums[i])\\n            maxSum = max(maxSum, curSum)\\n        }\\n        return maxSum\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n// Executed 3 tests, with 0 failures (0 unexpected) in 0.007 (0.009) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test1() {\\n        let res = s.maxSubArray([-2,1,-3,4,-1,2,1,-5,4])\\n        XCTAssertEqual(res, 6)\\n    }\\n    func test2() {\\n        let res = s.maxSubArray([1])\\n        XCTAssertEqual(res, 1)\\n    }\\n    func test3() {\\n        let res = s.maxSubArray([5,4,-1,7,8])\\n        XCTAssertEqual(res, 23)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992938,
                "title": "simple-java-1ms-beats-100-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to find the maximum sum of the sub-array. That means we have to **avoid negative numbers** as much as possible.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can use **Kadane\\'s Algorithm** to optimize the code. See the steps below:\\n\\n    1. Create two variables to store current and maximum sub-array sum.\\n    2. Initialize both the variable with nums[0], i.e., 1st element.\\n    3. Iterate from index 1 to n-1.\\n    4. Keep increasing the current sub-array sum.\\n    5. If, at any point, curSum is negative, reset it to 0.\\n    6. If, at any point, curSum is greater than maxSum then update maxSum.\\nFinally, return the maxSum.\\nFollow the code below to understand the solution.\\n\\n           **If this solution helped you, give it an up-vote to help others**\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n\\n\\n//      We will need two variables. One will store current sub-array sum.\\n//      Other will store maximum sub-array sum.\\n\\n        int curSum = nums[0];\\n        int maxSum = nums[0];   // consider 1st element to be greatest sub-array.\\n\\n        for(int i = 1; i < nums.length; i++){\\n\\n            // If the cur sub-array sum is negative then reset is to 0.\\n            if(curSum < 0)\\n            {\\n                curSum = 0;\\n            }\\n\\n            // Iterate over the array and calculate sub-array sum.\\n            curSum += nums[i];\\n\\n            // maxSum will be greater of curSum and maxSum.\\n            maxSum = Math.max(maxSum, curSum);\\n\\n        }\\n\\n        // finally, return the maxSum.\\n        return maxSum;\\n\\n    }\\n}\\n```\\n**What if there are only negative numbers?**\\n\\na.----->> if(curSum < 0)\\n{\\ncurSum = 0;\\n}\\n\\nb.---->> curSum += nums[i];\\n\\nc.----->> maxSum = Math.max(maxSum, curSum);\\n\\n1. Initially, the max sub-array sum is nums[0] i.e., the first element. Let\\'s say nums[0] is -2.\\n2. If the curSum is negative, then it is rest to 0. (step a)\\nThat means in the step b, curSum = nums [ i ]. (equal to single element) lets say it is -1.\\n3. In step c, we store the maximum of maxSum and curSum in maxSum. (max of -1 and -2 is -1).\\n4. So, if there are only negative numbers. The greatest negative number will be stored in maxSum.",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n\\n\\n//      We will need two variables. One will store current sub-array sum.\\n//      Other will store maximum sub-array sum.\\n\\n        int curSum = nums[0];\\n        int maxSum = nums[0];   // consider 1st element to be greatest sub-array.\\n\\n        for(int i = 1; i < nums.length; i++){\\n\\n            // If the cur sub-array sum is negative then reset is to 0.\\n            if(curSum < 0)\\n            {\\n                curSum = 0;\\n            }\\n\\n            // Iterate over the array and calculate sub-array sum.\\n            curSum += nums[i];\\n\\n            // maxSum will be greater of curSum and maxSum.\\n            maxSum = Math.max(maxSum, curSum);\\n\\n        }\\n\\n        // finally, return the maxSum.\\n        return maxSum;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1028920,
                "title": "divide-and-conquer",
                "content": "```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        return findMaxSum(nums, 0, nums.length-1);     \\n    }\\n    \\n    private int findMaxSum(int[] nums, int s, int e){\\n        if(s==e) return nums[s];\\n        \\n        int mid = s + (e-s)/2;\\n        \\n        int leftMax = findMaxSum(nums, s, mid);\\n        int rightMax = findMaxSum(nums, mid+1, e);\\n        int arrMax = findMaxCrossSum(nums, s, mid, e);\\n      \\n        \\n        return Math.max(leftMax, Math.max(rightMax, arrMax));\\n    }\\n    \\n    private int findMaxCrossSum(int []nums, int s, int m, int e){\\n\\n        int lSum=0, lMax=Integer.MIN_VALUE;\\n\\t\\t\\n        for(int i=m; i>=s; i--){\\n            lSum+=nums[i];\\n            lMax = Math.max(lMax, lSum);        \\n        }\\n        \\n        int rSum=0, rMax=Integer.MIN_VALUE;\\n\\t\\t\\n        for(int i=m+1; i<=e; i++){\\n            rSum+=nums[i];\\n            rMax = Math.max(rMax, rSum);\\n        }\\n        \\n        return lMax+rMax;\\n    }\\n}\\n```\\n\\nReference: https://www.youtube.com/watch?v=yBCzO0FpsVc&list=LL&index=6",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        return findMaxSum(nums, 0, nums.length-1);     \\n    }\\n    \\n    private int findMaxSum(int[] nums, int s, int e){\\n        if(s==e) return nums[s];\\n        \\n        int mid = s + (e-s)/2;\\n        \\n        int leftMax = findMaxSum(nums, s, mid);\\n        int rightMax = findMaxSum(nums, mid+1, e);\\n        int arrMax = findMaxCrossSum(nums, s, mid, e);\\n      \\n        \\n        return Math.max(leftMax, Math.max(rightMax, arrMax));\\n    }\\n    \\n    private int findMaxCrossSum(int []nums, int s, int m, int e){\\n\\n        int lSum=0, lMax=Integer.MIN_VALUE;\\n\\t\\t\\n        for(int i=m; i>=s; i--){\\n            lSum+=nums[i];\\n            lMax = Math.max(lMax, lSum);        \\n        }\\n        \\n        int rSum=0, rMax=Integer.MIN_VALUE;\\n\\t\\t\\n        for(int i=m+1; i<=e; i++){\\n            rSum+=nums[i];\\n            rMax = Math.max(rMax, rSum);\\n        }\\n        \\n        return lMax+rMax;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1457517,
                "title": "dynamic-programming-approach-python-o-n",
                "content": "**Note: If you find this post useful, please upvote for my motivation to continue with more of these, thank you <3**\\n\\n# Idea:\\n* **Suppose there is a max sum of a subarray starting from position i+1 (we can call it val[i+1]). At position i, we want to get the max sum of subarray starting from i, the top-down question will be: Should we add val[i+1] to nums[i]?**\\n```\\nval[i] = max(nums[i], nums[i] + val[i+1])\\n#Where val[i] is the max sum of the subarray that starts from i (must include nums[i])\\n```\\n# Steps:\\n1. * By traversing the whole nums array in a reversed order, we get the val array which contain the result somewhere in it. \\n2. * Now we just need to traverse that val array again and get that max value.\\n\\n\\n# Code:\\n**In my code, because once I traverse an element in the nums, I won\\'t reuse that element anymore, therefore I don\\'t have to create the \"val\" array, instead I just set the \"val\" value to the existing nums array, just for memory saving.**\\n```\\nINF = -10**5\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        for i in range(len(nums)-2, -1, -1):\\n            nums[i] = max(nums[i], nums[i] + nums[i+1])\\n        result = INF\\n        for i in range(len(nums)):\\n            result = max(result, nums[i])\\n        return result\\n```\\nThe above code is to let you understand the idea thoroughly, another compressed solution (with same idea) will be:\\n\\n```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        result = nums[-1]\\n        for i in range(len(nums)-2, -1, -1):\\n            nums[i] = max(nums[i], nums[i] + nums[i+1])\\n            result = max(result, nums[i])\\n        return result\\n```\\n\\n# Complexity Analysis:\\n* Time complexity: O(2n) -> O(n)\\n* Space complexity: O(1) - (Because I didn\\'t initiate any array)\\n\\n**Note: If you find this post useful, please upvote for my motivation to continue with more of these, thank you <3**\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nval[i] = max(nums[i], nums[i] + val[i+1])\\n#Where val[i] is the max sum of the subarray that starts from i (must include nums[i])\\n```\n```\\nINF = -10**5\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        for i in range(len(nums)-2, -1, -1):\\n            nums[i] = max(nums[i], nums[i] + nums[i+1])\\n        result = INF\\n        for i in range(len(nums)):\\n            result = max(result, nums[i])\\n        return result\\n```\n```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        result = nums[-1]\\n        for i in range(len(nums)-2, -1, -1):\\n            nums[i] = max(nums[i], nums[i] + nums[i+1])\\n            result = max(result, nums[i])\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 380007,
                "title": "javascript-beats-99-super-simple",
                "content": "```javascript\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxSubArray = function(nums) {\\n  for (let i = 1; i < nums.length; i++) {\\n    nums[i] = Math.max(nums[i], nums[i] + nums[i - 1]);\\n  }\\n  return Math.max(...nums)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxSubArray = function(nums) {\\n  for (let i = 1; i < nums.length; i++) {\\n    nums[i] = Math.max(nums[i], nums[i] + nums[i - 1]);\\n  }\\n  return Math.max(...nums)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1136682,
                "title": "javascript-divide-and-conquer-with-bonus-pictures",
                "content": "I understood the O(n) kadane\\'s algorithm fine, but had trouble wrapping my head around the divide and conquer approach. I drew out what was happening which helped me understand it and wanted to share.\\n\\nThe first part, the divide, looks a lot like diagrams of merge sort. We keep splitting the array into left and right until we get to our base case, a single item.\\n\\n![image](https://assets.leetcode.com/users/images/76451586-0084-462a-b242-75185e1bc868_1617247482.9558964.png)\\n\\nNow for conquering on the way up. At each division, we check is the max array in the left side or the right side? The special case is that the max array exists across the left and right side, so for each division we check from the middle out to find the crossing max sum.\\n\\nAn example of each case.\\n\\n[1,-1] -> left side has max\\n[-5, 2] -> right side has max\\n[1,2] -> the max exists \"crossing\" both sides\\n\\nAnd from the problems example, green show where the max array was found and the small text box shows when it was right, left or crossing.\\n\\n![image](https://assets.leetcode.com/users/images/edcb42d7-951c-4b17-a5dd-1bb09f77c48e_1617247490.616707.png)\\n\\nAnd now pictures to code...\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxSubArray = function(nums) {\\n    return findMax(nums, 0, nums.length - 1)\\n};\\n\\nvar findMax = function (nums, l, r) {\\n    if (l == r) {\\n        //Base case, return num here\\n        return nums[l]\\n    }\\n    \\n    let mid = Math.floor((l + r)/2)\\n    let leftSum = findMax(nums, l, mid) //Recursively check left side for max sum\\n    let rightSum = findMax(nums, mid+1, r) //recursively check right side for max sum\\n    const crossingSum = findCrossingSum(nums, l, mid, r) //Find max sum that includes left and right side\\n    return Math.max (crossingSum, leftSum, rightSum) //return whichever is largest\\n}\\n\\nvar findCrossingSum = function(nums, l, mid, r) { \\n    //A crossing sum exists on the left side and right side\\n    // so if we count mid as on the left side, the crossing sum MUST\\n    // include nums[mid] and nums[mid+1]. From these starting points we search for the max sum\\n    let sum=0\\n    let maxLSum = -Infinity\\n    for(let i = mid; i >= l; i--) {\\n        sum += nums[i]\\n        maxLSum = Math.max(maxLSum, sum)\\n    }\\n    sum =0\\n    let maxRSum = -Infinity\\n    for (let i = mid + 1; i <= r; i++) {\\n        sum += nums[i]\\n        maxRSum = Math.max(maxRSum, sum)\\n    }\\n    \\n    return maxRSum + maxLSum\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Divide and Conquer"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxSubArray = function(nums) {\\n    return findMax(nums, 0, nums.length - 1)\\n};\\n\\nvar findMax = function (nums, l, r) {\\n    if (l == r) {\\n        //Base case, return num here\\n        return nums[l]\\n    }\\n    \\n    let mid = Math.floor((l + r)/2)\\n    let leftSum = findMax(nums, l, mid) //Recursively check left side for max sum\\n    let rightSum = findMax(nums, mid+1, r) //recursively check right side for max sum\\n    const crossingSum = findCrossingSum(nums, l, mid, r) //Find max sum that includes left and right side\\n    return Math.max (crossingSum, leftSum, rightSum) //return whichever is largest\\n}\\n\\nvar findCrossingSum = function(nums, l, mid, r) { \\n    //A crossing sum exists on the left side and right side\\n    // so if we count mid as on the left side, the crossing sum MUST\\n    // include nums[mid] and nums[mid+1]. From these starting points we search for the max sum\\n    let sum=0\\n    let maxLSum = -Infinity\\n    for(let i = mid; i >= l; i--) {\\n        sum += nums[i]\\n        maxLSum = Math.max(maxLSum, sum)\\n    }\\n    sum =0\\n    let maxRSum = -Infinity\\n    for (let i = mid + 1; i <= r; i++) {\\n        sum += nums[i]\\n        maxRSum = Math.max(maxRSum, sum)\\n    }\\n    \\n    return maxRSum + maxLSum\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 799981,
                "title": "say-goodbye-to-kadane-hello-to-intuitive-o-n-prefix-sum-solution-java",
                "content": "Why wrap your head around complicated kadane logic?\\n\\nWhenever you see finding subarrays that meet a certain criteria, prefix sums should be the first thing that jump to your head.\\n\\nHow does prefix sums work? \\nYou just keep a running sum of the array.\\nYou subtract previous runningsums from the current running sum to get your desired sub array.\\n\\nSo to get the maximum subarray at any given point, you subtract the minimum running sum from the current running sum.\\n\\n```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int min = 0;\\n        \\n        int runningSum = 0;\\n        \\n        int max = nums[0];\\n        for (int num: nums) {\\n            runningSum += num;\\n            max = Math.max(max, runningSum - min);\\n            min = Math.min(runningSum, min);\\n        }\\n        return max;\\n    }\\n}\\n```\\n\\nI also have an prefix sum explanation for the Maximum product subarray\\nhttps://leetcode.com/problems/maximum-product-subarray/discuss/843820/Say-goodbye-to-Kadane-hello-to-intuitive-O(n)-prefix-sum-solution-Java",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int min = 0;\\n        \\n        int runningSum = 0;\\n        \\n        int max = nums[0];\\n        for (int num: nums) {\\n            runningSum += num;\\n            max = Math.max(max, runningSum - min);\\n            min = Math.min(runningSum, min);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1465258,
                "title": "cpp-easy-and-simple-with-explanation-0-ms-faster-than-100-of-c",
                "content": "Hey guyz kindly refer **Kadane\\u2019s Algorithm** for easier understanding (else skip to code \\uD83D\\uDE03):\\n\\n##### The idea of Kadane\\u2019s algorithm is to look for all positive contiguous segments of the array (maxendinghere is used for this). And keep track of maximum sum contiguous segment among all positive segments (maxsofar is used for this). Each time we get a positive-sum compare it with maxsofar and update maxsofar if it is greater than maxsofar .\\n\\nInitialize:\\n    max_so_far = INT_MIN\\n    max_ending_here = 0\\n\\nLoop for each element of the array\\n  (a) max_ending_here = max_ending_here + a[i]\\n  (b) if(max_so_far < max_ending_here)\\n            max_so_far = max_ending_here\\n  (c) if(max_ending_here < 0)\\n            max_ending_here = 0\\nreturn max_so_far\\n\\n\\n\\n\\n***CODE With Kadane\\u2019s Algorithm :***\\n```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int max_sum=INT_MIN, curr_sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            curr_sum+=nums[i];\\n            if(curr_sum>max_sum)\\n                max_sum=curr_sum;\\n        \\n            if(curr_sum<0)\\n                curr_sum=0;\\n        }\\n        return max_sum;\\n    }\\n};\\n```\\n***CODE With 0ms time :***\\n```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n                  \\n        int cs=nums[0], ms=nums[0];\\n        for(int i=1; i<nums.size();i++)\\n        {\\n            cs = max(nums[i], cs+nums[i]);\\n            ms=max(cs, ms);\\n        }\\n        return ms;\\n    }\\n};\\n```\\nIf any doubts feel free to ask :)\\nPlz Upvote if it helped you \\uD83D\\uDE0A ..\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int max_sum=INT_MIN, curr_sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            curr_sum+=nums[i];\\n            if(curr_sum>max_sum)\\n                max_sum=curr_sum;\\n        \\n            if(curr_sum<0)\\n                curr_sum=0;\\n        }\\n        return max_sum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n                  \\n        int cs=nums[0], ms=nums[0];\\n        for(int i=1; i<nums.size();i++)\\n        {\\n            cs = max(nums[i], cs+nums[i]);\\n            ms=max(cs, ms);\\n        }\\n        return ms;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 252058,
                "title": "c-solution",
                "content": "Runtime: 112 ms, faster than 81.41% of C# online submissions for Maximum Subarray.\\nMemory Usage: 23.2 MB, less than 68.87% of C# online submissions for Maximum Subarray.\\n\\nMy solution:\\n\\n```\\npublic int MaxSubArray(int[] nums) {\\n\\tint sum = 0;\\n\\tint maxSum = nums[0];\\n\\n\\tfor (int i=0; i<nums.Length; i++) {\\n\\t\\tsum += nums[i];\\n\\t\\tif (nums[i] > sum) {\\n\\t\\t\\tsum = nums[i];\\n\\t\\t}\\n\\t\\tif (sum > maxSum) { \\n\\t\\t\\tmaxSum = sum; \\n\\t\\t}\\n\\t}\\n\\treturn maxSum;\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic int MaxSubArray(int[] nums) {\\n\\tint sum = 0;\\n\\tint maxSum = nums[0];\\n\\n\\tfor (int i=0; i<nums.Length; i++) {\\n\\t\\tsum += nums[i];\\n\\t\\tif (nums[i] > sum) {\\n\\t\\t\\tsum = nums[i];\\n\\t\\t}\\n\\t\\tif (sum > maxSum) { \\n\\t\\t\\tmaxSum = sum; \\n\\t\\t}\\n\\t}\\n\\treturn maxSum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 503255,
                "title": "dp-thought-process-from-top-down-to-optimized-bottom-up",
                "content": "This approach was inspired by [this](https://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems.) post where the OP talks about how to approach the problem in DP way. Sure, there are many other ways to solve this problem, but I find DP to be a lot more straight forward to come up with answers and optimize from there.\\n\\n**Step 1**. Figure out recurrence relation\\nWith each index denoted by ``i``, you have two options to determine the maximum sum:\\na) stop counting the running sum and start over with current index\\nb) keep on counting the running sum\\nThose two options ^ are determined based on the current running sum. Thus, we can denote the recurrence relation as:\\n``maxSum(i) = Math.max(nums[i], nums[i] + maxSum(nums, i + 1))``\\nUsing the formula above, we can now move on to next step.\\n\\n**Step 2**. Top-down approach (Recursive)\\nNow that we found out the recurrence relations, we just need to find out the base case (a place to stop recursing). This case, it would return 0 when the index gets out of index.\\n```java\\nint max;\\npublic int maxSubArray(int[] nums) {\\n\\tif (nums.length == 0) {\\n\\t\\treturn 0;\\n\\t}\\n\\tmax = nums[0];\\n\\tmaxSum(nums, 0);\\n\\treturn max;\\n}\\npublic int maxSum(int[] nums, int i) {\\n\\tif (i == nums.length) {\\n\\t\\treturn 0;\\n\\t}\\n\\tint res = Math.max(nums[i], nums[i] + maxSum(nums, i + 1));\\n\\tmax = Math.max(max, res);\\n\\treturn res;\\n}\\n```\\nWhile this would work for most cases, it could be done better.\\n\\n**Step 3**. Top-down approach with memoization (Still recursive)\\nThis step should be pretty trivial. Now we add some memory so that we do not try to compute subproblems that has already been solved.\\n```java\\nint max;\\nInteger[] memo;\\n\\npublic int maxSubArray(int[] nums) {\\n\\tif (nums.length == 0) {\\n\\t\\treturn 0;\\n\\t}\\n\\tmax = nums[0];\\n\\tmemo = new Integer[nums.length];\\n\\tmaxSum(nums, 0);\\n\\treturn max;\\n}\\n\\npublic int maxSum(int[] nums, int i) {\\n\\tif (i == nums.length) {\\n\\t\\treturn 0;\\n\\t}\\n\\tif (memo[i] != null) {\\n\\t\\treturn memo[i];\\n\\t}\\n\\tint res = Math.max(nums[i], nums[i] + maxSum(nums, i + 1));\\n\\tmax = Math.max(max, res);\\n\\tmemo[i] = res;\\n\\treturn res;\\n}\\n```\\n\\n**Step 4**. Bottom-up approach (Iteration)\\nLooking at pattern above, now we can try to convert it into iteration. Time and space complexity should still be the same as step 3, but now we do not have to rely on recursion stack to solve the problem. (Also gets rid of pesky global variables)\\n```java\\npublic int maxSubArray(int[] nums) {\\n\\tif (nums.length == 0) {\\n\\t\\treturn 0;\\n\\t}\\n\\tint[] dp = new int[nums.length];\\n\\tdp[0] = nums[0];\\n\\tint max = nums[0];\\n\\tfor (int i = 1; i < nums.length; i++) {\\n\\t\\tdp[i] = Math.max(nums[i], nums[i] + dp[i - 1]);\\n\\t\\tmax = Math.max(max, dp[i]);\\n\\t}\\n\\treturn max;\\n}\\n```\\n**Step 5**. Bottom-up approach with space optimized (Iteration)\\nWhile converting it into bottom up, we notice that we are only concerned with the previous maximum element. Thus, we can simply replace an array with one variable to make the space constant!\\n```java\\npublic int maxSubArray(int[] nums) {\\n\\tif (nums.length == 0) {\\n\\t\\treturn 0;\\n\\t}\\n\\tint prev = nums[0];\\n\\tint max = nums[0];\\n\\tfor (int i = 1; i < nums.length; i++) {\\n\\t\\tint localMax = Math.max(nums[i], nums[i] + prev);\\n\\t\\tmax = Math.max(max, localMax);\\n\\t\\tprev = localMax;\\n\\t}\\n\\treturn max;\\n}\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```java\\nint max;\\npublic int maxSubArray(int[] nums) {\\n\\tif (nums.length == 0) {\\n\\t\\treturn 0;\\n\\t}\\n\\tmax = nums[0];\\n\\tmaxSum(nums, 0);\\n\\treturn max;\\n}\\npublic int maxSum(int[] nums, int i) {\\n\\tif (i == nums.length) {\\n\\t\\treturn 0;\\n\\t}\\n\\tint res = Math.max(nums[i], nums[i] + maxSum(nums, i + 1));\\n\\tmax = Math.max(max, res);\\n\\treturn res;\\n}\\n```\n```java\\nint max;\\nInteger[] memo;\\n\\npublic int maxSubArray(int[] nums) {\\n\\tif (nums.length == 0) {\\n\\t\\treturn 0;\\n\\t}\\n\\tmax = nums[0];\\n\\tmemo = new Integer[nums.length];\\n\\tmaxSum(nums, 0);\\n\\treturn max;\\n}\\n\\npublic int maxSum(int[] nums, int i) {\\n\\tif (i == nums.length) {\\n\\t\\treturn 0;\\n\\t}\\n\\tif (memo[i] != null) {\\n\\t\\treturn memo[i];\\n\\t}\\n\\tint res = Math.max(nums[i], nums[i] + maxSum(nums, i + 1));\\n\\tmax = Math.max(max, res);\\n\\tmemo[i] = res;\\n\\treturn res;\\n}\\n```\n```java\\npublic int maxSubArray(int[] nums) {\\n\\tif (nums.length == 0) {\\n\\t\\treturn 0;\\n\\t}\\n\\tint[] dp = new int[nums.length];\\n\\tdp[0] = nums[0];\\n\\tint max = nums[0];\\n\\tfor (int i = 1; i < nums.length; i++) {\\n\\t\\tdp[i] = Math.max(nums[i], nums[i] + dp[i - 1]);\\n\\t\\tmax = Math.max(max, dp[i]);\\n\\t}\\n\\treturn max;\\n}\\n```\n```java\\npublic int maxSubArray(int[] nums) {\\n\\tif (nums.length == 0) {\\n\\t\\treturn 0;\\n\\t}\\n\\tint prev = nums[0];\\n\\tint max = nums[0];\\n\\tfor (int i = 1; i < nums.length; i++) {\\n\\t\\tint localMax = Math.max(nums[i], nums[i] + prev);\\n\\t\\tmax = Math.max(max, localMax);\\n\\t\\tprev = localMax;\\n\\t}\\n\\treturn max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 561904,
                "title": "easiest-java-solution-o-n-2-lines-in-1-loop",
                "content": "This code is fairly simple:\\n```\\nint max = Integer.MIN_VALUE, sum = 0;\\nfor(int i = 0; i < nums.length; i++){\\n    sum += nums[i];\\n    if(sum > max)\\n        max = sum;\\n    if(sum < 0)\\n        sum = 0;\\n}\\nreturn max;\\n```\\nThe reasoning behind this is fairly straight forward. \\nThe first line of the loop is increasing our sum. \\nThe first `if-statement` is checking to see if it\\'s the best we\\'ve found so far\\nThe second `if-statement` is checking if the sum is less than 0. If it is, it\\'s better to discard whatever we have so far, and start fresh from 0. A negative number + `x` will always be less than `x`. \\n\\nThese can be shortened further if you wish to be like so:\\n```\\nint max = Integer.MIN_VALUE, sum = 0;\\nfor(int i = 0; i < nums.length; i++){\\n    sum += nums[i];\\n    max = Math.max(sum, max);\\n    sum = Math.max(sum, 0);\\n}\\nreturn max;\\n```\\nLastly, here\\'s a java tip:\\nThe return value of an assignment operation is the value that was assigned. This allows for some more shortening of the code to the following:\\n```\\nint max = Integer.MIN_VALUE, sum = 0;\\nfor(int i = 0; i < nums.length; i++){\\n        max = Math.max(sum+=nums[i], max);\\n        sum = Math.max(sum, 0);\\n}\\nreturn max;\\n```\\n`sum += nums[i]` is usually a line all by itself, but because it\\'s an assignment operation, it also has a return value that is equal to the value assigned. This allows you to both assign a value AND use the value immediately. \\nFor example:\\n`(i=1)==1` -> always true because `1 == 1`\\n`(sum = sum + nums[i]) > nums[i]` is true only if `sum` was non-negative beforehand. \\nThe += operation is shorthand for something like the line directly above where something is added to a variable and then stored back in that same variable.",
                "solutionTags": [],
                "code": "```\\nint max = Integer.MIN_VALUE, sum = 0;\\nfor(int i = 0; i < nums.length; i++){\\n    sum += nums[i];\\n    if(sum > max)\\n        max = sum;\\n    if(sum < 0)\\n        sum = 0;\\n}\\nreturn max;\\n```\n```\\nint max = Integer.MIN_VALUE, sum = 0;\\nfor(int i = 0; i < nums.length; i++){\\n    sum += nums[i];\\n    max = Math.max(sum, max);\\n    sum = Math.max(sum, 0);\\n}\\nreturn max;\\n```\n```\\nint max = Integer.MIN_VALUE, sum = 0;\\nfor(int i = 0; i < nums.length; i++){\\n        max = Math.max(sum+=nums[i], max);\\n        sum = Math.max(sum, 0);\\n}\\nreturn max;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1553058,
                "title": "53-maximum-subarray-java-solution",
                "content": "```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum = 0;\\n        int max = nums[0];\\n        for(int i=0; i<nums.length; i++){\\n            sum += nums[i];\\n            if(sum > max){\\n                max = sum;\\n            }\\n            if(sum < 0){\\n                sum = 0;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\\n\\nIf it helped, please UPVOTE. Happy Coding and keep up the good work.\\nFeel free to give your suggestions or correct me in the comments.\\nThanks for reading.\\uD83D\\uDE43",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum = 0;\\n        int max = nums[0];\\n        for(int i=0; i<nums.length; i++){\\n            sum += nums[i];\\n            if(sum > max){\\n                max = sum;\\n            }\\n            if(sum < 0){\\n                sum = 0;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 562046,
                "title": "simple-5-lines-o-n-solution-in-c-using-kadane-s-algorithm",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int max_sum=nums[0], sum=nums[0];\\n        for(int i=1; i<nums.size(); i++) {\\n            sum = max(nums[i], sum+nums[i]);\\n            if(sum>max_sum) {\\n                max_sum=sum;\\n            }\\n        }\\n        \\n        return max_sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int max_sum=nums[0], sum=nums[0];\\n        for(int i=1; i<nums.size(); i++) {\\n            sum = max(nums[i], sum+nums[i]);\\n            if(sum>max_sum) {\\n                max_sum=sum;\\n            }\\n        }\\n        \\n        return max_sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20294,
                "title": "evolve-from-brute-force-to-optimal-a-review-of-all-solutions",
                "content": "1. O(n^2), try all subarrays\\n```\\n    int maxSubArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int ma=INT_MIN;\\n        for(int i=0;i<n;i++) {\\n            int s=0;\\n            for(int j=i;j<n;j++) {\\n                s+=nums[j];\\n                ma = max(ma, s);\\n            }    \\n        }\\n        return ma;\\n    }\\n```\\n2. O(nlogn) Naive divide and conquer. the max subarray is the max of the left, right, and the one that spans the boundary.\\n```\\n    int maxSubArray(vector<int>& nums) {\\n        return maxSubArray(0,nums.size()-1,nums);\\n    }\\n    int maxSubArray(int l, int r, vector<int>& nums) {\\n        if(l==r) return nums[l];\\n        int mid= (l+r)/2;\\n        int ms=maxSubArray(l,mid,nums);\\n        ms=max(ms,maxSubArray(mid+1,r,nums));\\n        int pre=0, ml=INT_MIN;\\n        for(int i=mid;i>=l;i--) {\\n            pre+=nums[i];\\n            ml=max(ml,pre);\\n        }\\n        pre=0;\\n        int mr=INT_MIN;\\n        for(int i=mid+1;i<=r;i++) {\\n            pre+=nums[i];\\n            mr=max(mr,pre);\\n        }\\n        return max(ms,ml+mr);\\n    }\\n```\\n3. O(n) recursion. For sub array/string problems, it is natrual to enumerate all sub arrays/strings first as in #1 and then optimize it. However, there seems no obvious way to improve over #1. In this case, we can try enumerate all start positions. \\n```\\n\\tint max=Integer.MIN_VALUE;\\n    public int maxSubArray(int[] nums) {\\n        maxSubArray(0,nums);\\n        return max;\\n    }\\n    private int maxSubArray(int i, int[] nums) {\\n        if(i==nums.length) return 0;\\n        int nxt=maxSubArray(i+1,nums), sum=nxt>0?nxt+nums[i]:nums[i];\\n        max=Math.max(max,sum);\\n        return sum;\\n    }\\n```\\n4. O(n), dp, as in #3, the tricky part is we are not creating recursive formular to solve max subarray directly. The recursive relation solves max subarray starting at i but the max subarray can be computed along the way. f(i)=max(nums[i], nums[i] + f(i+1))\\n* java\\n```\\n\\tpublic int maxSubArray(int[] nums) {\\n        int max=Integer.MIN_VALUE, pre=0;\\n        for(int num:nums) {\\n            pre = pre>0?pre+num:num;\\n            max = Math.max(max, pre);\\n        }\\n        return max;\\n    }\\n```\\n* c++\\n```\\n    int maxSubArray(vector<int>& nums) {\\n        int pre =0, ma=INT_MIN;\\n        for(int i=0;i<nums.size();i++) {\\n            pre = pre>0? pre+nums[i]:nums[i];\\n            ma= max(ma,pre);\\n        }\\n        return ma;\\n    }\\n```\\n5. O(n) divide and conquer, the max subarray starting and ending at the boundary can be computed at the leaves and passed up. Idea is from [@wyattliu ](https://discuss.leetcode.com/topic/25396/c-an-clear-o-n-divide-and-conquer-solution-with-comments)\\n```\\n    int maxSubArray(vector<int>& nums) {\\n        int ml, mr, sum;\\n        return maxSubArray(0,nums.size()-1, ml, mr, sum, nums);\\n    }\\n    int maxSubArray(int l, int r, int& ml, int& mr, int& sum, vector<int>& nums) {\\n        if(l==r) return ml = mr = sum = nums[l];\\n        int mid= (l+r)/2, lml, lmr, lsum, rml, rmr, rsum;\\n        int ms=maxSubArray(l,mid,lml,lmr,lsum,nums);\\n        ms=max(ms,maxSubArray(mid+1,r,rml,rmr,rsum,nums));\\n        ml = max(lml, lsum+rml);\\n        mr = max(rmr, rsum+lmr);\\n        sum = lsum+rsum;\\n        return max(ms,lmr+rml);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int maxSubArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int ma=INT_MIN;\\n        for(int i=0;i<n;i++) {\\n            int s=0;\\n            for(int j=i;j<n;j++) {\\n                s+=nums[j];\\n                ma = max(ma, s);\\n            }    \\n        }\\n        return ma;\\n    }\\n```\n```\\n    int maxSubArray(vector<int>& nums) {\\n        return maxSubArray(0,nums.size()-1,nums);\\n    }\\n    int maxSubArray(int l, int r, vector<int>& nums) {\\n        if(l==r) return nums[l];\\n        int mid= (l+r)/2;\\n        int ms=maxSubArray(l,mid,nums);\\n        ms=max(ms,maxSubArray(mid+1,r,nums));\\n        int pre=0, ml=INT_MIN;\\n        for(int i=mid;i>=l;i--) {\\n            pre+=nums[i];\\n            ml=max(ml,pre);\\n        }\\n        pre=0;\\n        int mr=INT_MIN;\\n        for(int i=mid+1;i<=r;i++) {\\n            pre+=nums[i];\\n            mr=max(mr,pre);\\n        }\\n        return max(ms,ml+mr);\\n    }\\n```\n```\\n\\tint max=Integer.MIN_VALUE;\\n    public int maxSubArray(int[] nums) {\\n        maxSubArray(0,nums);\\n        return max;\\n    }\\n    private int maxSubArray(int i, int[] nums) {\\n        if(i==nums.length) return 0;\\n        int nxt=maxSubArray(i+1,nums), sum=nxt>0?nxt+nums[i]:nums[i];\\n        max=Math.max(max,sum);\\n        return sum;\\n    }\\n```\n```\\n\\tpublic int maxSubArray(int[] nums) {\\n        int max=Integer.MIN_VALUE, pre=0;\\n        for(int num:nums) {\\n            pre = pre>0?pre+num:num;\\n            max = Math.max(max, pre);\\n        }\\n        return max;\\n    }\\n```\n```\\n    int maxSubArray(vector<int>& nums) {\\n        int pre =0, ma=INT_MIN;\\n        for(int i=0;i<nums.size();i++) {\\n            pre = pre>0? pre+nums[i]:nums[i];\\n            ma= max(ma,pre);\\n        }\\n        return ma;\\n    }\\n```\n```\\n    int maxSubArray(vector<int>& nums) {\\n        int ml, mr, sum;\\n        return maxSubArray(0,nums.size()-1, ml, mr, sum, nums);\\n    }\\n    int maxSubArray(int l, int r, int& ml, int& mr, int& sum, vector<int>& nums) {\\n        if(l==r) return ml = mr = sum = nums[l];\\n        int mid= (l+r)/2, lml, lmr, lsum, rml, rmr, rsum;\\n        int ms=maxSubArray(l,mid,lml,lmr,lsum,nums);\\n        ms=max(ms,maxSubArray(mid+1,r,rml,rmr,rsum,nums));\\n        ml = max(lml, lsum+rml);\\n        mr = max(rmr, rsum+lmr);\\n        sum = lsum+rsum;\\n        return max(ms,lmr+rml);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1779660,
                "title": "python-simple-python-solution-using-kadane-algorithm",
                "content": "# If It is Useful to Understand Please Upvote Me \\uD83D\\uDE4F\\uD83D\\uDE4F\\n\\tclass Solution:\\n\\t\\tdef maxSubArray(self, nums: List[int]) -> int:\\n\\n\\t\\t\\tmax_sum = -1000000000000000\\n\\n\\t\\t\\tcurrent_sum = 0\\n\\n\\t\\t\\tfor num in nums:\\n\\t\\t\\t\\tcurrent_sum = current_sum + num\\n\\n\\t\\t\\t\\tmax_sum = max(max_sum , current_sum)\\n\\n\\t\\t\\t\\tif current_sum < 0:\\n\\n\\t\\t\\t\\t\\tcurrent_sum = 0\\n\\n\\t\\t\\treturn max_sum\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "# If It is Useful to Understand Please Upvote Me \\uD83D\\uDE4F\\uD83D\\uDE4F\\n\\tclass Solution:\\n\\t\\tdef maxSubArray(self, nums: List[int]) -> int:\\n\\n\\t\\t\\tmax_sum = -1000000000000000\\n\\n\\t\\t\\tcurrent_sum = 0\\n\\n\\t\\t\\tfor num in nums:\\n\\t\\t\\t\\tcurrent_sum = current_sum + num\\n\\n\\t\\t\\t\\tmax_sum = max(max_sum , current_sum)\\n\\n\\t\\t\\t\\tif current_sum < 0:\\n\\n\\t\\t\\t\\t\\tcurrent_sum = 0\\n\\n\\t\\t\\treturn max_sum\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 185856,
                "title": "explanation-of-the-o-n-solution-in-python",
                "content": "The O(n) solution to this problem is a reduction algorithm that uses a key observation:\n\n**If the first *n* elements of an array have a negative sum, those elements either contain the optimal subarray or are not part of the optimal solution.**\n\nConsider a list: \n\n**[-5, 3, 2, -10, 4, 8, 1]**\n\nIt is intuitive that the sum of the array equals the *value of the first element* plus the *sum of all the other elements*. Since the value of the first element is negative, it can only detract from the total sum, so we can safely \"discard\" the first element:\n\n**[3, 2, -10, 4, 8 1]**\n\nHowever, to generalize this to deal with positive numbers, we have to \"reduce\" the array. We can do this by reducing the first *n* elements to the sum of the first *n* elements, then discarding the first element when it becomes negative.\n\nHere's what that looks like:\n1. **[3, 2, -10, 4, 8 1] -- sum = array[0] -> 3, max sum -> 3**\n2. **[5, -10, 4, 8 1] -- sum += array[1] -> 5, max sum -> 5**\n3. **[-5, 4, 8 1] -- sum += array[2] -> -5, max_sum -> 5** \n\nSince the \"first element\" is now negative, we can safely discard it and start anew. This means resetting the value of sum to be 0.\n\n4. **[4, 8 1] -- sum = array[0] -> 4, max sum -> 5**\n5. **[12, 1] -- sum += array[1] -> 12, max sum -> 12**\n6. **[13] -- sum += array[2] -> 13, max sum -> 13**\n\nIn the implementation, we don't delete elements of the list--rather, we just move our pointer forward, forget about the previous element, and use the current sum as the \"first\" element.\n\nCode:\n```\nclass Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        max_sum, cur_sum = max(nums), 0\n        for num in nums:\n            cur_sum += num\n            max_sum = max(max_sum, cur_sum)\n            if cur_sum < 0:\n                cur_sum = 0\n        return max_sum",
                "solutionTags": [],
                "code": "The O(n) solution to this problem is a reduction algorithm that uses a key observation:\n1. **[3, 2, -10, 4, 8 1] -- sum = array[0] -> 3, max sum -> 3**\n2. **[5, -10, 4, 8 1] -- sum += array[1] -> 5, max sum -> 5**\n3. **[-5, 4, 8 1] -- sum += array[2] -> -5, max_sum -> 5** \n4. **[4, 8 1] -- sum = array[0] -> 4, max sum -> 5**\n5. **[12, 1] -- sum += array[1] -> 12, max sum -> 12**\n6. **[13] -- sum += array[2] -> 13, max sum -> 13**\nclass Solution(object):\n    def maxSubArray(self, nums):\n        max_sum, cur_sum = max(nums), 0\n            cur_sum += num\n            max_sum = max(max_sum, cur_sum)\n                cur_sum = 0",
                "codeTag": "Java"
            },
            {
                "id": 1227240,
                "title": "c-very-easy-code-100-faster",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector <int>& nums) {\\n        int sum=nums[0],maxi=nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n             sum=std::max(nums[i],sum+nums[i]);\\n           maxi=std::max(maxi,sum);\\n        }\\n        return maxi;\\n    }\\n};\\n\\n```\\n\\n\\n![image](https://assets.leetcode.com/users/images/cf27bf5e-d004-4e64-a76e-c7ed6d522292_1621838771.333952.png)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector <int>& nums) {\\n        int sum=nums[0],maxi=nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n             sum=std::max(nums[i],sum+nums[i]);\\n           maxi=std::max(maxi,sum);\\n        }\\n        return maxi;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1880966,
                "title": "python3-kadane-s-algorithm-explained",
                "content": "```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n\\t\\n        local_max = -pow(10, 4)         # as per provided constraints\\n        global_max = -pow(10, 4)        # as per provided constraints\\n        \\n        for i in range(len(nums)):\\n            local_max = max(nums[i], nums[i] + local_max)\\n            if local_max > global_max:\\n                global_max = local_max\\n        \\n        return global_max\\n            \\n```\\n\\nFirst, let us check why we are preferring **Kadane\\'s algorithm** over **Divide and Conquer** :\\n\\n\\t\\t\\t\\t\\t\\tApproach                      Time Complexity         Space Complexity\\n\\t---------------------------------------------------------------------------------------------\\n\\t   Kadane\\'s Algorithm (Dynamic Programming)            O(n)                     O(1)\\n\\t   Divide and Conquer                                  O(n)                     O(n)\\n\\nKadane\\u2019s algorithm is able to find the maximum sum of a contiguous subarray in an array with a **Time Complexity of O(n)** and **Space Complexity of O(1)** unlike Divide and Conquer.\\n\\nAn important property of **Dynamic Programming** is that **results of past computations are remembered** and used to build the optimal solution i.e. remembering the results of sub-problems (memoization).\\n\\nKadane\\'s algorithm originates from the same property, thus it can be considered as Dynamic Programming.\\n\\nKadane\\'s algorithm: **local_maximum at index i is the maximum of arr[i] and the sum of arr[i] and local_maximum at index i-1.**\\n        \\n        local_maximum[i] = max(arr[i], arr[i] + local_maximum[i-1])\\n\\n**This Problem :**\\n\\nNormally, we can find all possible subarrays by placing i at each element, and iterating j over all other elements while calculating and comparing the values of sum of the subarrays.\\n\\nInspired from Kadane\\'s algorithm, instead of the above approach we can place i at each element, calculate maximum value of sum upto that element and store it in local_maximum; so that when we move i to the next element, we already have the maximum sum that is possible until that element, now the current/next possible maximum sum can either be one of:\\n\\t\\t**1)** sum of the current ith element and previously existing value of local_maximum\\n\\t\\t**2)** only the value of current ith element\\n        whichever is **greater**.\\n\\nTherefore, everytime **local_maximum = max(arr[i], arr[i] + local_maximum)**, and **global_maximum = local_maximum when current local_maximum is greater than exisiting global_maximum**.\\n\\nWe see that arr[i], i.e. the current ith element is always included while calculating the local_maximum, this is because we cannot skip one element and add the later subarray with the earlier local_maximum subarray (even if it would give us a greater value of sum) as that will not form a contiguous subarray (which is our aim here).\\n\\n**Upvote** if the solution and explanation were **helpful** :)\\n\\nReferences :\\n1. https://medium.com/@rsinghal757/kadanes-algorithm-dynamic-programming-how-and-why-does-it-work-3fd8849ed73d",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n\\t\\n        local_max = -pow(10, 4)         # as per provided constraints\\n        global_max = -pow(10, 4)        # as per provided constraints\\n        \\n        for i in range(len(nums)):\\n            local_max = max(nums[i], nums[i] + local_max)\\n            if local_max > global_max:\\n                global_max = local_max\\n        \\n        return global_max\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 462212,
                "title": "c-sliding-window",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxSubArray(vector<int>& nums) {\\n\\t\\t\\tif(nums.size()==0) return 0;\\n\\t\\t\\tint n=nums.size();\\n\\t\\t\\tint cur=0;\\n\\t\\t\\tint res=INT_MIN;\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\n\\t\\t\\t\\tcur+=nums[i];\\n\\t\\t\\t\\tif(cur<nums[i]){\\n\\t\\t\\t\\t\\tcur=nums[i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tres=max(cur,res);\\n\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint maxSubArray(vector<int>& nums) {\\n\\t\\t\\tif(nums.size()==0) return 0;\\n\\t\\t\\tint n=nums.size();\\n\\t\\t\\tint cur=0;\\n\\t\\t\\tint res=INT_MIN;\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\n\\t\\t\\t\\tcur+=nums[i];\\n\\t\\t\\t\\tif(cur<nums[i]){\\n\\t\\t\\t\\t\\tcur=nums[i];\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1680930,
                "title": "python-simple-solution-o-n-time-explained",
                "content": "**Approach**\\n\\tHere, we can obviously generate all the subarrays of nums and find the maximum array like that. However, that will give us O(n^2) which is not what we are looking for in this case. We want to do this in one pass which leads us to the current solution. The goal is to iterate the list and, for every element, we want to see if it is more advantageous to keep the current contiguous line going, or if it is better to start a new contiguous line at the current element. Finally, by keeping track of the largest sum thus far, we will reach our final answer.\\n**Code Breakdown**\\n\\tWe can initialize both the currSum and maxSum to the first element because that will be the first contiguous line. Then, as we are iterating, we will update the currSum to be the maximum between currVal and currVal + currSum. This tells us if it is more adventagous to start a new line at the current element or continue with the previous line. As an example, with [4,-5,10] as nums and 10 as currVal, we want to start a new line starting at 10 rather than continuing the previous subarray [4,-5]. This is because the subarray [4,-5,10] is smaller than the subarray [10].\\n\\tFinally, we can track the maxSum which is the max of the currSum and maxSum so far.\\n**Big O Breakdown**\\nThis is O(n) because we are only looking at each element in the list one time, and every calculation in the list is O(1).\\n\\nLeave a like if it helped! Let me know if you have any questions/things to add!\\n```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        currSum = maxSum = nums[0]\\n        for i in range(1,len(nums)):\\n            currVal = nums[i]\\n            currSum = max(currVal, currSum + currVal)\\n            maxSum = max(currSum, maxSum)\\n        return maxSum\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        currSum = maxSum = nums[0]\\n        for i in range(1,len(nums)):\\n            currVal = nums[i]\\n            currSum = max(currVal, currSum + currVal)\\n            maxSum = max(currSum, maxSum)\\n        return maxSum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20388,
                "title": "share-my-3-lines-python-solution",
                "content": "    class Solution(object):\\n        def maxSubArray(self, nums):\\n            \"\"\"\\n            :type nums: List[int]\\n            :rtype: int\\n            \"\"\"\\n            for i in xrange(1,len(nums)):\\n                    nums[i] = max(nums[i - 1] + nums[i], nums[i])\\n            return max(nums)",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "    class Solution(object):\\n        def maxSubArray(self, nums):\\n            \"\"\"\\n            :type nums: List[int]\\n            :rtype: int\\n            \"\"\"\\n            for i in xrange(1,len(nums)):\\n                    nums[i] = max(nums[i - 1] + nums[i], nums[i])\\n            return max(nums)",
                "codeTag": "Java"
            },
            {
                "id": 1890617,
                "title": "100-fastest-typescript-solution",
                "content": "```\\nfunction maxSubArray(nums: number[]): number {\\n  let local = 0\\n  let global = -Infinity\\n\\n  for (const num of nums) {\\n    local = Math.max(num, local + num)\\n    if (local > global) { global = local }\\n  }\\n\\n  return global\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction maxSubArray(nums: number[]): number {\\n  let local = 0\\n  let global = -Infinity\\n\\n  for (const num of nums) {\\n    local = Math.max(num, local + num)\\n    if (local > global) { global = local }\\n  }\\n\\n  return global\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 981146,
                "title": "java-approach-recursive-dp-kadane-divide-and-conquer",
                "content": "**Recursive**\\n* Base case: if `nums[index]` reached the end then `maxSoFar` will be the `nums[index]`\\n* recursive case: compare the current `nums[index]` with the sum of  current `nums[index]` from recursion output of the next `index+1`\\n* compute `maxOverall` and return at the end\\n```\\nclass Solution {\\n\\t private int maxOverall = Integer.MIN_VALUE;\\n     protected int recurse(int[] nums, int index){\\n         int maxSoFar = 0;\\n         if (index == nums.length-1)\\n             maxSoFar = nums[index];\\n         else\\n             maxSoFar = Math.max(nums[index], nums[index] + recurse(nums, index+1));\\n         maxOverall = Math.max(maxOverall, maxSoFar);\\n         return maxSoFar;\\n     }\\n    \\n     public int maxSubArray(int[] nums) {\\n         recurse(nums, 0);\\n         return maxOverall;\\n       }\\n}\\n```\\n**Bottom Up - DP**\\n* just converting the logic to `dp` array with recurrence of `maxSoFar = max(nums[i], nums[i] + dp[i-1])`\\n```\\nclass Solution {\\n public int maxSubArray(int[] nums) {\\n        int length = nums.length;\\n        int[] dp = new int[length];\\n        dp[0] = nums[0];\\n        int maxOverall = dp[0];\\n        for (int i=1;i<length;i++){\\n            dp[i] = Math.max(nums[i], dp[i-1] + nums[i]);\\n            maxOverall = Math.max(maxOverall, dp[i]);\\n        }\\n        return maxOverall;\\n    }\\n}\\n```\\n**Kadane**\\n```\\nclass Solution {\\npublic int maxSubArray(int[] nums) {\\n         int max = nums[0];\\n         int maxOverall = nums[0];\\n          for (int i=1;i<nums.length;i++){\\n              max = Math.max(nums[i], max + nums[i]);\\n              maxOverall = Math.max(maxOverall, max);\\n          }\\n         return maxOverall;\\n    }\\n}\\n```\\n**Divide and Conquer**\\n```\\nprotected int helper(int[] nums, int start, int mid , int end){\\n        int lSum = Integer.MIN_VALUE;\\n        int rSum = Integer.MIN_VALUE;\\n        \\n        int sum = 0;\\n        for (int i=mid;i>=start;i--){\\n            sum += nums[i];\\n            lSum = Math.max(sum , lSum);\\n        }\\n            \\n        sum = 0;\\n        for (int i=mid+1;i<=end;i++){\\n            sum += nums[i];\\n            rSum = Math.max(sum, rSum);\\n        }\\n            \\n        return lSum + rSum;\\n        \\n    }\\n    protected int helper(int[] nums, int start, int end){\\n        if (start == end)\\n            return nums[start];\\n        int mid = start + (end - start ) / 2 ;\\n        int left = helper(nums, start, mid);\\n        int right = helper(nums, mid+1, end);\\n        int both = helper(nums, start, mid , end);\\n        return Math.max(left, Math.max(right, both));\\n        \\n    }\\n    public int maxSubArray(int[] nums) {\\n        return helper(nums, 0, nums.length - 1);    \\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n\\t private int maxOverall = Integer.MIN_VALUE;\\n     protected int recurse(int[] nums, int index){\\n         int maxSoFar = 0;\\n         if (index == nums.length-1)\\n             maxSoFar = nums[index];\\n         else\\n             maxSoFar = Math.max(nums[index], nums[index] + recurse(nums, index+1));\\n         maxOverall = Math.max(maxOverall, maxSoFar);\\n         return maxSoFar;\\n     }\\n    \\n     public int maxSubArray(int[] nums) {\\n         recurse(nums, 0);\\n         return maxOverall;\\n       }\\n}\\n```\n```\\nclass Solution {\\n public int maxSubArray(int[] nums) {\\n        int length = nums.length;\\n        int[] dp = new int[length];\\n        dp[0] = nums[0];\\n        int maxOverall = dp[0];\\n        for (int i=1;i<length;i++){\\n            dp[i] = Math.max(nums[i], dp[i-1] + nums[i]);\\n            maxOverall = Math.max(maxOverall, dp[i]);\\n        }\\n        return maxOverall;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic int maxSubArray(int[] nums) {\\n         int max = nums[0];\\n         int maxOverall = nums[0];\\n          for (int i=1;i<nums.length;i++){\\n              max = Math.max(nums[i], max + nums[i]);\\n              maxOverall = Math.max(maxOverall, max);\\n          }\\n         return maxOverall;\\n    }\\n}\\n```\n```\\nprotected int helper(int[] nums, int start, int mid , int end){\\n        int lSum = Integer.MIN_VALUE;\\n        int rSum = Integer.MIN_VALUE;\\n        \\n        int sum = 0;\\n        for (int i=mid;i>=start;i--){\\n            sum += nums[i];\\n            lSum = Math.max(sum , lSum);\\n        }\\n            \\n        sum = 0;\\n        for (int i=mid+1;i<=end;i++){\\n            sum += nums[i];\\n            rSum = Math.max(sum, rSum);\\n        }\\n            \\n        return lSum + rSum;\\n        \\n    }\\n    protected int helper(int[] nums, int start, int end){\\n        if (start == end)\\n            return nums[start];\\n        int mid = start + (end - start ) / 2 ;\\n        int left = helper(nums, start, mid);\\n        int right = helper(nums, mid+1, end);\\n        int both = helper(nums, start, mid , end);\\n        return Math.max(left, Math.max(right, both));\\n        \\n    }\\n    public int maxSubArray(int[] nums) {\\n        return helper(nums, 0, nums.length - 1);    \\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20472,
                "title": "kadane-s-algo-5-line-algo",
                "content": "class Solution \\n{\\n public:\\n\\n    int maxSubArray(vector<int>& nums) {\\n        int sum=nums[0],lgsum=nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            sum=max(nums[i],sum+nums[i]);\\n            lgsum=max(lgsum,sum);\\n        }\\n        return lgsum;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution \\n{\\n public:\\n\\n    int maxSubArray(vector<int>& nums) {\\n        int sum=nums[0],lgsum=nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            sum=max(nums[i],sum+nums[i]);\\n            lgsum=max(lgsum,sum);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1595497,
                "title": "python-2-solutions-explained",
                "content": "#### Solution 1\\nWe can easily do it with DP in `O(n)` time. Define by `dp[i]` maximum sum ending with element with index `i`. Then we have two options: either continue subarray or take single element. \\n\\n#### Complexity\\nTime and space is `O(n)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums):\\n        dp = [0]*len(nums)\\n        dp[0] = nums[0]\\n        for i in range(1, len(nums)):\\n            dp[i] = max(nums[i], nums[i] + dp[i-1])\\n        return max(dp)\\n```\\n\\n#### Solution 2 \\nAlso there is divide and conquer solution where we split array into two parts.\\n\\n#### Complexity\\nIt is `O(n log n)` for time and `O(n)` for space.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums):\\n        def helper(beg, end):\\n            if beg + 1 == end: return nums[beg]\\n            mid = (beg + end)//2\\n            sum_1 = helper(beg, mid)\\n            sum_2 = helper(mid, end)\\n            right = max(accumulate(nums[beg:mid][::-1]))\\n            left  = max(accumulate(nums[mid:end]))\\n            return max(sum_1, sum_2, left + right)\\n\\n        return helper(0, len(nums))\\n``` \\n\\nIf you have any questoins, feel free to ask. If you like the solution and explanation, please **upvote!**",
                "solutionTags": [
                    "Divide and Conquer",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def maxSubArray(self, nums):\\n        dp = [0]*len(nums)\\n        dp[0] = nums[0]\\n        for i in range(1, len(nums)):\\n            dp[i] = max(nums[i], nums[i] + dp[i-1])\\n        return max(dp)\\n```\n```python\\nclass Solution:\\n    def maxSubArray(self, nums):\\n        def helper(beg, end):\\n            if beg + 1 == end: return nums[beg]\\n            mid = (beg + end)//2\\n            sum_1 = helper(beg, mid)\\n            sum_2 = helper(mid, end)\\n            right = max(accumulate(nums[beg:mid][::-1]))\\n            left  = max(accumulate(nums[mid:end]))\\n            return max(sum_1, sum_2, left + right)\\n\\n        return helper(0, len(nums))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563106,
                "title": "python-simple-and-short-solution",
                "content": "**Python :**\\n\\n```\\ndef maxSubArray(self, nums: List[int]) -> int:\\n\\tcurrent_max = nums[0]\\n\\tmax_sum = nums[0]\\n\\n\\tfor i in nums[1:]:\\n\\t\\tcurrent_max = max(i, current_max + i)\\n\\t\\tmax_sum = max(max_sum, current_max)\\n\\n\\treturn max_sum\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef maxSubArray(self, nums: List[int]) -> int:\\n\\tcurrent_max = nums[0]\\n\\tmax_sum = nums[0]\\n\\n\\tfor i in nums[1:]:\\n\\t\\tcurrent_max = max(i, current_max + i)\\n\\t\\tmax_sum = max(max_sum, current_max)\\n\\n\\treturn max_sum\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 764810,
                "title": "from-brute-force-to-dp-to-kadane-s-alogrithm",
                "content": "\\nIn computer science, maximum subarray problem is the task to find a contiguous subarray with the largest sum. This problem was proposed by Uif Grenander in 1977. In 1984, Jay Kadane designed an O(n) algorithm to solve the problem. We call the algorithm \"Kadane\\'s algorithm\".\\n\\n## Brute-force approach\\nWe can use brute-force to calculate sum of all possible subarray, and then get the maximum sum. Time complexity of brute-force solution will be O(n^3).\\n```\\npublic class Solution {\\n    public int MaxSubArray(int[] nums) {\\n        \\n        if(nums == null || nums.Length == 0)\\n            return 0;\\n        \\n        int maxSum = nums[0];\\n        \\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            for(int j = i; j < nums.Length; j++)\\n            {\\n                int currSum = 0;\\n                \\n                for(int k = i; k <= j; k++)\\n                {\\n                    currSum += nums[k];\\n                }\\n                \\n                maxSum = Math.Max(maxSum, currSum);\\n            }\\n        }\\n        \\n        return maxSum;\\n    }\\n}\\n```\\n\\nThe brute-force solution can be improved to O(n^2) time complexity by using a variable to store the running sum at all possible positions.\\n```\\npublic class Solution {\\n    public int MaxSubArray(int[] nums) {\\n        \\n        if(nums == null || nums.Length == 0)\\n            return 0;\\n        \\n        int maxSum = nums[0];\\n        \\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            int currSum = 0;\\n                \\n            for(int j = i; j < nums.Length; j++)\\n            {\\n                currSum += nums[j];\\n                maxSum = Math.Max(maxSum, currSum);\\n            }\\n        }\\n        \\n        return maxSum;\\n    }\\n}\\n```\\n\\n## Dynamic Programming approach\\nInstead of using each index as the starting position of subarray in the brute-force approach, DP approach uses each index as the ending point, so that when calculating sum of the next subarray, the algorithm can take advantage of the previous calculations. The formula is: sum[i] = sum[i-1] + nums[i]. This DP approach will improve the time complexity to O(n) and has O(n) space complexity.\\n\\n```\\npublic class Solution {\\n    public int MaxSubArray(int[] nums) {\\n        \\n        if(nums == null || nums.Length == 0)\\n            return 0;\\n        \\n        int[] dp = new int[nums.Length];\\n        dp[0] = nums[0];\\n        \\n        for(int i = 1; i < nums.Length; i++)\\n        {\\n            dp[i] = Math.Max(dp[i - 1] + nums[i], nums[i]);\\n        }\\n        \\n        return dp.Max();        \\n    }\\n}\\n```\\n\\n## Kadane\\'s algorithm\\nKadane\\'s algorithm is implemented on top of the DP approach. It uses a local variable to track maximum sum of all subarray. This can improve the space complexity to O(1).\\n```\\npublic class Solution {\\n    public int MaxSubArray(int[] nums) {\\n        \\n        if(nums == null || nums.Length == 0)\\n            return 0;\\n        \\n        int maxSumSoFar = nums[0], maxSumEndingHere = nums[0];\\n        \\n        for(int i = 1; i < nums.Length; i++)\\n        {\\n            maxSumEndingHere = Math.Max(maxSumEndingHere + nums[i], nums[i]);\\n            maxSumSoFar = Math.Max(maxSumSoFar, maxSumEndingHere);\\n        }\\n        \\n        return maxSumSoFar;        \\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MaxSubArray(int[] nums) {\\n        \\n        if(nums == null || nums.Length == 0)\\n            return 0;\\n        \\n        int maxSum = nums[0];\\n        \\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            for(int j = i; j < nums.Length; j++)\\n            {\\n                int currSum = 0;\\n                \\n                for(int k = i; k <= j; k++)\\n                {\\n                    currSum += nums[k];\\n                }\\n                \\n                maxSum = Math.Max(maxSum, currSum);\\n            }\\n        }\\n        \\n        return maxSum;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int MaxSubArray(int[] nums) {\\n        \\n        if(nums == null || nums.Length == 0)\\n            return 0;\\n        \\n        int maxSum = nums[0];\\n        \\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            int currSum = 0;\\n                \\n            for(int j = i; j < nums.Length; j++)\\n            {\\n                currSum += nums[j];\\n                maxSum = Math.Max(maxSum, currSum);\\n            }\\n        }\\n        \\n        return maxSum;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int MaxSubArray(int[] nums) {\\n        \\n        if(nums == null || nums.Length == 0)\\n            return 0;\\n        \\n        int[] dp = new int[nums.Length];\\n        dp[0] = nums[0];\\n        \\n        for(int i = 1; i < nums.Length; i++)\\n        {\\n            dp[i] = Math.Max(dp[i - 1] + nums[i], nums[i]);\\n        }\\n        \\n        return dp.Max();        \\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int MaxSubArray(int[] nums) {\\n        \\n        if(nums == null || nums.Length == 0)\\n            return 0;\\n        \\n        int maxSumSoFar = nums[0], maxSumEndingHere = nums[0];\\n        \\n        for(int i = 1; i < nums.Length; i++)\\n        {\\n            maxSumEndingHere = Math.Max(maxSumEndingHere + nums[i], nums[i]);\\n            maxSumSoFar = Math.Max(maxSumSoFar, maxSumEndingHere);\\n        }\\n        \\n        return maxSumSoFar;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2193128,
                "title": "c-solution-beats-100-optimized-tc-o-n-kadane-s-algorithm",
                "content": "**PLEASE UPVOTE IF YOU FIND MY APPROACH HELPFUL, MEANS A LOT \\uD83D\\uDE0A**\\n\\n**Explanation:**\\n\\n* Set maximum to the minimum number (INT_MIN) because there may be a array filled with only negative elements, therefore we want to take the maximum value out of the elements present.\\n\\n* Initialize sum = 0.\\n\\n* Traverse through the array and add the current element to the sum.\\n\\n* If the sum is greater then the maximum sum, assign the new sum to the maximum.\\n\\n* If the current sum is less than zero - reset the sum to 0.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int sum = 0;\\n        int maximum = INT_MIN;\\n        \\n//         for(int i=0; i<nums.size();i++)\\n//         {\\n//             sum += nums[i];\\n            \\n//             if(maximum<sum)\\n//                 maximum = sum;\\n            \\n//             if(sum<0)\\n//                 sum=0;\\n//         }\\n        \\n        // Using iterator for traversal ( iterator is always faster )\\n        for(auto i : nums)\\n        {\\n            sum += i;\\n            \\n            maximum = max(maximum,sum);\\n            \\n            if(sum<0)\\n                sum = 0;\\n        }\\n        \\n        return maximum;\\n    }\\n};\\n```\\n\\nTC -> `O(n)`\\nSc -> `O(1)`",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int sum = 0;\\n        int maximum = INT_MIN;\\n        \\n//         for(int i=0; i<nums.size();i++)\\n//         {\\n//             sum += nums[i];\\n            \\n//             if(maximum<sum)\\n//                 maximum = sum;\\n            \\n//             if(sum<0)\\n//                 sum=0;\\n//         }\\n        \\n        // Using iterator for traversal ( iterator is always faster )\\n        for(auto i : nums)\\n        {\\n            sum += i;\\n            \\n            maximum = max(maximum,sum);\\n            \\n            if(sum<0)\\n                sum = 0;\\n        }\\n        \\n        return maximum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1520747,
                "title": "java-tc-o-n-sc-o-1-kadane-s-algorithm-optimal-dp-solution",
                "content": "```java\\n/**\\n * Kadane\\'s Algorithm.\\n *\\n * Time Complexity: O(N)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of the input array.\\n */\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        if (nums == null) {\\n            throw new IllegalArgumentException(\"Input array is null\");\\n        }\\n\\n        int maxEndingHere = nums[0];\\n        int maxSoFar = nums[0];\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            /**\\n             * maxEndingHere + nums[i] --> Adding the current number to previous SubArray\\n             * nums[i] -> Starting a new SubArray with just this element. This will be max in case above value is negative or zero\\n             *\\n             * maxSubArray(A, i) = maxSubArray(A, i - 1) > 0 ? maxSubArray(A, i - 1) : 0 + A[i];\\n             */\\n            maxEndingHere = Math.max(maxEndingHere + nums[i], nums[i]);\\n            maxSoFar = Math.max(maxSoFar, maxEndingHere);\\n        }\\n\\n        return maxSoFar;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```java\\n/**\\n * Kadane\\'s Algorithm.\\n *\\n * Time Complexity: O(N)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of the input array.\\n */\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        if (nums == null) {\\n            throw new IllegalArgumentException(\"Input array is null\");\\n        }\\n\\n        int maxEndingHere = nums[0];\\n        int maxSoFar = nums[0];\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            /**\\n             * maxEndingHere + nums[i] --> Adding the current number to previous SubArray\\n             * nums[i] -> Starting a new SubArray with just this element. This will be max in case above value is negative or zero\\n             *\\n             * maxSubArray(A, i) = maxSubArray(A, i - 1) > 0 ? maxSubArray(A, i - 1) : 0 + A[i];\\n             */\\n            maxEndingHere = Math.max(maxEndingHere + nums[i], nums[i]);\\n            maxSoFar = Math.max(maxSoFar, maxEndingHere);\\n        }\\n\\n        return maxSoFar;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1353578,
                "title": "java-solution-3-optimal-approaches",
                "content": "**Approach 1:  using Kadane\\'s algorithm\\nBig O analysis - O(N) Time | O(1) Space**\\n```\\npublic int maxSubArray(int[] nums) {\\n\\n\\tint maxsum = Integer.MIN_VALUE;\\n\\tint currsum = 0;\\n\\n\\tfor (int n : nums) {\\n\\n\\t\\tcurrsum += n;\\n\\t\\tmaxsum = Math.max(currsum, maxsum);\\n\\n\\t\\tif (currsum < 0)\\n\\t\\t\\tcurrsum = 0;\\n\\t}\\n\\n\\treturn maxsum;        \\n}\\n```\\n\\n**Approach 2: using Dynamic Programming \\nComplexity analysis - O(N) Time | O(N) Space**\\n```\\npublic int maxSubArray(int[] nums) {\\n\\n\\tint[] dp = new int[nums.length];\\n\\tdp[0] = nums[0];\\n\\n\\tint maxsum = nums[0];\\n\\n\\tfor (int i = 1; i < nums.length; i++) {\\n\\n\\t\\tdp[i] = Math.max(nums[i], nums[i] + dp[i-1]);\\n\\n\\t\\tmaxsum = Math.max(maxsum, dp[i]);\\n\\t}\\n\\n\\treturn maxsum;\\n}   \\n```\\n**Approach 3: using divide and conquer**\\n```\\nprivate int[] numsArr; // global reference\\n\\npublic int maxSubArray(int[] nums) {\\n\\tnumsArr = nums;\\n\\treturn findMaxSubarray(0, numsArr.length - 1);\\n}\\n\\n// helper recusive method\\nprivate int findMaxSubarray(int left, int right) {\\n\\n\\tif (left > right)\\n\\t\\treturn Integer.MIN_VALUE;\\n\\n\\tint mid = left + (right - left) / 2;\\n\\tint currSum = 0;\\n\\tint leftMaxSum = 0, rightMaxSum = 0;\\n\\n\\t// finding max subarray sum in left half\\n\\tfor (int i = mid - 1; i >= left; i--) {\\n\\t\\tcurrSum += numsArr[i];\\n\\t\\tleftMaxSum = Math.max(leftMaxSum, currSum);\\n\\t}\\n\\n\\t// finding in right half\\n\\tcurrSum = 0;\\n\\tfor (int i = mid + 1; i <= right; i++) {\\n\\t\\tcurrSum += numsArr[i];\\n\\t\\trightMaxSum = Math.max(rightMaxSum, currSum);\\n\\t}\\n\\n\\t// considering middle element also\\n\\tint combinedSum = numsArr[mid] + leftMaxSum + rightMaxSum;\\n\\n\\tint leftHalfSum = findMaxSubarray(left, mid - 1);\\n\\tint rightHalfSum = findMaxSubarray(mid + 1, right);\\n\\n\\tint result = Math.max(combinedSum, Math.max(leftHalfSum, rightHalfSum));\\n\\n\\treturn result;\\n\\t}    \\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic int maxSubArray(int[] nums) {\\n\\n\\tint maxsum = Integer.MIN_VALUE;\\n\\tint currsum = 0;\\n\\n\\tfor (int n : nums) {\\n\\n\\t\\tcurrsum += n;\\n\\t\\tmaxsum = Math.max(currsum, maxsum);\\n\\n\\t\\tif (currsum < 0)\\n\\t\\t\\tcurrsum = 0;\\n\\t}\\n\\n\\treturn maxsum;        \\n}\\n```\n```\\npublic int maxSubArray(int[] nums) {\\n\\n\\tint[] dp = new int[nums.length];\\n\\tdp[0] = nums[0];\\n\\n\\tint maxsum = nums[0];\\n\\n\\tfor (int i = 1; i < nums.length; i++) {\\n\\n\\t\\tdp[i] = Math.max(nums[i], nums[i] + dp[i-1]);\\n\\n\\t\\tmaxsum = Math.max(maxsum, dp[i]);\\n\\t}\\n\\n\\treturn maxsum;\\n}   \\n```\n```\\nprivate int[] numsArr; // global reference\\n\\npublic int maxSubArray(int[] nums) {\\n\\tnumsArr = nums;\\n\\treturn findMaxSubarray(0, numsArr.length - 1);\\n}\\n\\n// helper recusive method\\nprivate int findMaxSubarray(int left, int right) {\\n\\n\\tif (left > right)\\n\\t\\treturn Integer.MIN_VALUE;\\n\\n\\tint mid = left + (right - left) / 2;\\n\\tint currSum = 0;\\n\\tint leftMaxSum = 0, rightMaxSum = 0;\\n\\n\\t// finding max subarray sum in left half\\n\\tfor (int i = mid - 1; i >= left; i--) {\\n\\t\\tcurrSum += numsArr[i];\\n\\t\\tleftMaxSum = Math.max(leftMaxSum, currSum);\\n\\t}\\n\\n\\t// finding in right half\\n\\tcurrSum = 0;\\n\\tfor (int i = mid + 1; i <= right; i++) {\\n\\t\\tcurrSum += numsArr[i];\\n\\t\\trightMaxSum = Math.max(rightMaxSum, currSum);\\n\\t}\\n\\n\\t// considering middle element also\\n\\tint combinedSum = numsArr[mid] + leftMaxSum + rightMaxSum;\\n\\n\\tint leftHalfSum = findMaxSubarray(left, mid - 1);\\n\\tint rightHalfSum = findMaxSubarray(mid + 1, right);\\n\\n\\tint result = Math.max(combinedSum, Math.max(leftHalfSum, rightHalfSum));\\n\\n\\treturn result;\\n\\t}    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 366137,
                "title": "python3-dynamic-programming",
                "content": "* dp[i] represents the largest sum at index i.\\n* There are two possible stage of dp[i]:\\n\\t1. add nums[i] to previous stage: dp[i] = nums[i] +dp[i-1]\\n\\t2. don\\'t add to precious stage, we have a fresh start of the subarray: nums[i]: dp[i] = nums[i]\\n```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        dp = [0]*len(nums)\\n        dp[0] = nums[0]\\n        \"\"\"\\n        dp[1] = max(dp[0]+nums[1],nums[1])\\n        dp[2] = max(dp[1]+nums[2],nums[2])\\n        \"\"\"\\n        for i in range(1,len(nums)):\\n            dp[i] = max(dp[i-1] +nums[i],nums[i])\\n        return max(dp)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        dp = [0]*len(nums)\\n        dp[0] = nums[0]\\n        \"\"\"\\n        dp[1] = max(dp[0]+nums[1],nums[1])\\n        dp[2] = max(dp[1]+nums[2],nums[2])\\n        \"\"\"\\n        for i in range(1,len(nums)):\\n            dp[i] = max(dp[i-1] +nums[i],nums[i])\\n        return max(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 293318,
                "title": "c-concise-o-n-time-o-1-space-solution",
                "content": "```\\npublic class Solution {\\n    public int MaxSubArray(int[] nums) {\\n        for (int i = 1; i < nums.Length; i++)\\n            if (nums[i - 1] + nums[i] > nums[i])\\n                nums[i] += nums[i - 1];\\n        return nums.Max();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MaxSubArray(int[] nums) {\\n        for (int i = 1; i < nums.Length; i++)\\n            if (nums[i - 1] + nums[i] > nums[i])\\n                nums[i] += nums[i - 1];\\n        return nums.Max();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 293206,
                "title": "python-one-liner-using-itertools-beating-99-70",
                "content": "```\\nfrom itertools import accumulate\\n\\ndef maxSubArray(self, nums: List[int]) -> int:\\n    return max(accumulate(nums, lambda x, y: max(y, x+y) ))\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom itertools import accumulate\\n\\ndef maxSubArray(self, nums: List[int]) -> int:\\n    return max(accumulate(nums, lambda x, y: max(y, x+y) ))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 20495,
                "title": "divide-conquer-easy-to-understand",
                "content": "    class Solution:\\n        # @param {integer[]} nums\\n        # @return {integer}\\n         \\n    \\n         def maxSubArrayHelper(self,nums, l, r):\\n            if l > r:\\n                return -2147483647\\n            m = (l+r) / 2\\n            \\n            leftMax = sumNum = 0\\n            for i in range(m - 1, l - 1, -1):\\n                sumNum += nums[i]\\n                leftMax = max(leftMax, sumNum)\\n            \\n            rightMax = sumNum = 0\\n            for i in range(m + 1, r + 1):\\n                sumNum += nums[i]\\n                rightMax = max(rightMax, sumNum)\\n                \\n            leftAns = self.maxSubArrayHelper(nums, l, m - 1)\\n            rightAns = self.maxSubArrayHelper(nums, m + 1, r)\\n                \\n            return max(leftMax + nums[m] + rightMax, max(leftAns, rightAns))\\n            \\n         def maxSubArray(self, nums):\\n            return self.maxSubArrayHelper(nums, 0, len(nums) - 1)",
                "solutionTags": [
                    "Python",
                    "Divide and Conquer"
                ],
                "code": "class Solution:\\n        # @param {integer[]}",
                "codeTag": "Java"
            },
            {
                "id": 20505,
                "title": "3-4-lines-ruby-and-c",
                "content": "Walk straight over the input array. Let `best` hold the best sum found overall and `curr` hold the best sum ending with the current element. For the latter, we can either use the current element alone (that's `n`) or also use the best sum ending with the previous element (that's `curr+n`, with the previous value of `curr`).\\n\\n**Ruby:**\\n\\n    def max_sub_array(nums)\\n        best, curr = nums[0], 0\\n        nums.each { |n| best = [best, curr = [n, curr+n].max].max }\\n        best\\n    end\\n\\n**C++:**\\n\\n    int maxSubArray(vector<int>& nums) {\\n        int best = nums[0], curr = 0;\\n        for (int n : nums)\\n            best = max(best, curr = max(n, curr+n));\\n        return best;\\n    }",
                "solutionTags": [
                    "C++",
                    "Ruby"
                ],
                "code": "Walk straight over the input array. Let `best` hold the best sum found overall and `curr` hold the best sum ending with the current element. For the latter, we can either use the current element alone (that's `n`) or also use the best sum ending with the previous element (that's `curr+n`, with the previous value of `curr`).\\n\\n**Ruby:**\\n\\n    def max_sub_array(nums)\\n        best, curr = nums[0], 0\\n        nums.each { |n| best = [best, curr = [n, curr+n].max].max }\\n        best\\n    end\\n\\n**C++:**\\n\\n    int maxSubArray(vector<int>& nums) {\\n        int best = nums[0], curr = 0;\\n        for (int n : nums)\\n            best = max(best, curr = max(n, curr+n));\\n        return best;\\n    }",
                "codeTag": "Python3"
            },
            {
                "id": 2175671,
                "title": "c-easy-fast-kadane-s-algorithm-solution",
                "content": "***PLEASE UPVOTE IF YOU FIND MY APPROACH HELPFUL <3\\nHAPPY CODING!***\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums){\\n        int max=INT_MIN;\\n        int n=0;\\n        for(int i=0;i<nums.size();i++){\\n            n+=nums[i];\\n            if(max<n){\\n                max=n;\\n            }\\n            if(n<0){\\n                n=0;\\n            }\\n        }\\n        return max;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums){\\n        int max=INT_MIN;\\n        int n=0;\\n        for(int i=0;i<nums.size();i++){\\n            n+=nums[i];\\n            if(max<n){\\n                max=n;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1912517,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func maxSubArray(_ nums: [Int]) -> Int {\\n        var max = nums[0]\\n        var sum = 0\\n        var i = 0\\n        \\n        while i < nums.count {\\n            let num = nums[i]\\n            sum += num\\n            \\n            if sum > 0 {\\n                max = max > sum ? max : sum\\n            } else {\\n                max = max > num ? max : num\\n                sum = 0\\n            }\\n            \\n            i += 1\\n        }\\n        \\n        return max\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maxSubArray(_ nums: [Int]) -> Int {\\n        var max = nums[0]\\n        var sum = 0\\n        var i = 0\\n        \\n        while i < nums.count {\\n            let num = nums[i]\\n            sum += num\\n            \\n            if sum > 0 {\\n                max = max > sum ? max : sum\\n            } else {\\n                max = max > num ? max : num\\n                sum = 0\\n            }\\n            \\n            i += 1\\n        }\\n        \\n        return max\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952353,
                "title": "divide-and-conquer-explanation-c",
                "content": "### Approach 1: - Divide and Conquer\\n\\n```\\nclass Solution {\\nprivate:\\n\\tint maxSubArrayHelper(vector<int>& nums, int left, int right) {\\n\\t\\tif (left > right)\\n\\t\\t\\treturn INT_MIN;\\n\\n\\t\\tint mid = left + (right - left) / 2;\\n\\n\\t\\tint maxLeft = maxSubArrayHelper(nums, left, mid - 1);\\n\\t\\tint maxRight = maxSubArrayHelper(nums, mid + 1, right);\\n\\n\\t\\tint maxLeftSum = 0, maxRightSum = 0;\\n\\t\\t//use any indication, large mininmum won\\'t burst some cases\\n\\n\\t\\tfor (int i = mid - 1, sum = 0; i >= left; i--) {\\n\\t\\t\\tsum += nums[i];\\n\\t\\t\\tmaxLeftSum = max(maxLeftSum, sum);\\n\\t\\t}\\n\\n\\t\\tfor (int i = mid + 1, sum = 0; i <= right; i++) {\\n\\t\\t\\tsum += nums[i];\\n\\t\\t\\tmaxRightSum = max(maxRightSum, sum);\\n\\t\\t}\\n\\n\\t\\tint maxSubarrays = max(maxLeft, maxRight);\\n\\t\\tint currSubarray =  nums[mid] + maxLeftSum + maxRightSum;\\n\\n\\t\\treturn max(maxSubarrays, currSubarray);\\n\\t}\\npublic:\\n\\tint maxSubArray(vector<int>& nums) {\\n\\t\\treturn maxSubArrayHelper(nums, 0, nums.size() - 1);\\n\\t}\\n};\\n```\\n***If anything from here helps you, UpVote this so others can also get something from this...***",
                "solutionTags": [
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n\\tint maxSubArrayHelper(vector<int>& nums, int left, int right) {\\n\\t\\tif (left > right)\\n\\t\\t\\treturn INT_MIN;\\n\\n\\t\\tint mid = left + (right - left) / 2;\\n\\n\\t\\tint maxLeft = maxSubArrayHelper(nums, left, mid - 1);\\n\\t\\tint maxRight = maxSubArrayHelper(nums, mid + 1, right);\\n\\n\\t\\tint maxLeftSum = 0, maxRightSum = 0;\\n\\t\\t//use any indication, large mininmum won\\'t burst some cases\\n\\n\\t\\tfor (int i = mid - 1, sum = 0; i >= left; i--) {\\n\\t\\t\\tsum += nums[i];\\n\\t\\t\\tmaxLeftSum = max(maxLeftSum, sum);\\n\\t\\t}\\n\\n\\t\\tfor (int i = mid + 1, sum = 0; i <= right; i++) {\\n\\t\\t\\tsum += nums[i];\\n\\t\\t\\tmaxRightSum = max(maxRightSum, sum);\\n\\t\\t}\\n\\n\\t\\tint maxSubarrays = max(maxLeft, maxRight);\\n\\t\\tint currSubarray =  nums[mid] + maxLeftSum + maxRightSum;\\n\\n\\t\\treturn max(maxSubarrays, currSubarray);\\n\\t}\\npublic:\\n\\tint maxSubArray(vector<int>& nums) {\\n\\t\\treturn maxSubArrayHelper(nums, 0, nums.size() - 1);\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20446,
                "title": "2-lines-python-solution",
                "content": "    class Solution(object):\\n    def maxSubArray(self, nums):\\n        for i in xrange(1,len(nums)):nums[i]=max(nums[i], nums[i]+nums[i-1])\\n        return max(nums)",
                "solutionTags": [],
                "code": "    class Solution(object):\\n    def maxSubArray(self, nums):\\n        for i in xrange(1,len(nums)):nums[i]=max(nums[i], nums[i]+nums[i-1])\\n        return max(nums)",
                "codeTag": "Java"
            },
            {
                "id": 3520775,
                "title": "c-java-python-javascript-kadane-s-algorithm-easy-to-understand",
                "content": "# Intuition:\\nThe problem asks for finding the maximum sum of a subarray within the given array. To solve this, we can use a technique called Kadane\\'s algorithm.\\n\\n# Approach:\\n1. Initialize two variables, \"max\" and \"meh,\" to keep track of the maximum sum found so far and the sum of the current subarray, respectively. Set \"max\" to the smallest possible integer value (INT_MIN) and \"meh\" to 0.\\n2. Iterate through the input array \"nums\" from left to right.\\n3. Add the current element to \"meh\" to extend the current subarray.\\n4. If \"meh\" is greater than \"max,\" update \"max\" with the value of \"meh\" since we have found a new maximum subarray sum.\\n5. If \"meh\" becomes negative (indicating that the current subarray has a negative sum), reset \"meh\" to 0, as any negative sum would only decrease the sum of any future subarrays.\\n6. After iterating through the entire array, return the value of \"max,\" which represents the maximum subarray sum.\\n\\n# Complexity:\\n- The time complexity of this solution is O(n), where n is the size of the input array \"nums.\" We iterate through the array once.\\n- The space complexity is O(1) since we only use a constant amount of additional space to store the variables \"max\" and \"meh.\"\\n\\n---\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        // meh \\u2013 max sum ending at ith index\\n        int max = INT_MIN, meh = 0;\\n        for (int i=0; i<nums.size(); i++) {\\n            meh = meh + nums[i];\\n            if (meh > max) {\\n                max = meh;\\n            }\\n            if (meh < 0) {\\n                meh = 0;\\n            }\\n        }\\n        return max;\\n    }\\n};\\n```\\n\\n---\\n# Java\\n```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int max = Integer.MIN_VALUE;\\n        int meh = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            meh = meh + nums[i];\\n            if (meh > max) {\\n                max = meh;\\n            }\\n            if (meh < 0) {\\n                meh = 0;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\\n\\n---\\n# Python\\n```\\nclass Solution(object):\\n    def maxSubArray(self, nums):\\n        max_sum = float(\\'-inf\\')\\n        meh = 0\\n        for num in nums:\\n            meh = meh + num\\n            if meh > max_sum:\\n                max_sum = meh\\n            if meh < 0:\\n                meh = 0\\n        return max_sum\\n```\\n\\n---\\n# JavaScript\\n```\\nvar maxSubArray = function(nums) {\\n    let max = -Infinity;\\n    let meh = 0;\\n    for (let i = 0; i < nums.length; i++) {\\n        meh += nums[i];\\n        if (meh > max) {\\n            max = meh;\\n        }\\n        if (meh < 0) {\\n            meh = 0;\\n        }\\n    }\\n    return max;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        // meh \\u2013 max sum ending at ith index\\n        int max = INT_MIN, meh = 0;\\n        for (int i=0; i<nums.size(); i++) {\\n            meh = meh + nums[i];\\n            if (meh > max) {\\n                max = meh;\\n            }\\n            if (meh < 0) {\\n                meh = 0;\\n            }\\n        }\\n        return max;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int max = Integer.MIN_VALUE;\\n        int meh = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            meh = meh + nums[i];\\n            if (meh > max) {\\n                max = meh;\\n            }\\n            if (meh < 0) {\\n                meh = 0;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def maxSubArray(self, nums):\\n        max_sum = float(\\'-inf\\')\\n        meh = 0\\n        for num in nums:\\n            meh = meh + num\\n            if meh > max_sum:\\n                max_sum = meh\\n            if meh < 0:\\n                meh = 0\\n        return max_sum\\n```\n```\\nvar maxSubArray = function(nums) {\\n    let max = -Infinity;\\n    let meh = 0;\\n    for (let i = 0; i < nums.length; i++) {\\n        meh += nums[i];\\n        if (meh > max) {\\n            max = meh;\\n        }\\n        if (meh < 0) {\\n            meh = 0;\\n        }\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1594975,
                "title": "c-divide-and-conquer-kadane-s-algo-concise-solution",
                "content": "**Most intuitive :: KADANE\\'s Algorithm  ---->>>\\n   The idea of Kadane\\u2019s algorithm is to look for all positive contiguous segments of the array (sum is used for this). And keep track of maximum sum contiguous segment among all positive segments (ans is used for this). Each time we get a positive-sum compare it with ans and update ans if it is greater than ans so far .And update sum with 0 if it becomes negative at some point because we won\\'t use that negative part in any upcoming subarrays !!\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int ans = INT_MIN;\\n        int sum = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            sum += nums[i];\\n            ans = max(sum, ans);\\n            if(sum < 0) sum = 0;\\n        }\\n        return ans;\\n    }\\n};\\nTime complexity O(n)\\n```\\n\\n\\n    \\n####     **The follow up :: Divide and conquer  ---->>>\\nThis is one of those situations where the solution with higher Time complexity is more complex to come up with ...\\nIf we divide the the original problem into two equal parts: [0, n) -> [0, mid) & [mid, n), so the longest subarray must be in either [0, mid) or [mid, n) -- recursive to solve, but notice that it could also be cross from the two(i...mid...j), and actually it is the trivial case, which we would just add from mid to 0 and from mid to n and keep the two temp max and then add them together -- time complexity would not beyond O(n). Then, what we need to do is to choose the global biggest one from the above three.\\nT(n) reprensent the time of the original problem, we divide it into two equal parts 2*T(n/2), and O(n) for the cross case. So we could get T(n) = 2*T(n/2) + O(n) = (2^log(n))*T(1) + O(n)*log(n) = O(n*log(n)).\\n```\\nclass Solution {\\nprivate:\\n\\tint helper(vector<int>& nums, int left, int right) {\\n\\t\\tif (left > right)\\n\\t\\t\\treturn INT_MIN;\\n\\n\\t\\tint mid = left + (right - left) / 2;\\n\\n\\t\\tint maxLeft_ans = helper(nums, left, mid - 1);\\n\\t\\tint maxRight_ans = helper(nums, mid + 1, right);\\n\\n\\t\\tint maxLeftSum = 0, maxRightSum = 0;\\n\\n\\t\\tfor (int i = mid - 1, sum = 0; i >= left; i--) {\\n\\t\\t\\tsum += nums[i];\\n\\t\\t\\tmaxLeftSum = max(maxLeftSum, sum);\\n\\t\\t}\\n\\n\\t\\tfor (int i = mid + 1, sum = 0; i <= right; i++) {\\n\\t\\t\\tsum += nums[i];\\n\\t\\t\\tmaxRightSum = max(maxRightSum, sum);\\n\\t\\t}\\n\\n\\t\\tint maxSubarrays = max(maxLeft_ans, maxRight_ans);\\n\\t\\tint currSubarray =  nums[mid] + maxLeftSum + maxRightSum;\\n\\n\\t\\treturn max(maxSubarrays, currSubarray);\\n\\t}\\npublic:\\n\\tint maxSubArray(vector<int>& nums) {\\n\\t\\treturn helper(nums, 0, nums.size() - 1);\\n\\t}\\n};\\n\\n\\nTime compexity is O(n*log(n)) for T(n) = 2*T(n/2) + O(n)",
                "solutionTags": [
                    "C",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int ans = INT_MIN;\\n        int sum = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            sum += nums[i];\\n            ans = max(sum, ans);\\n            if(sum < 0) sum = 0;\\n        }\\n        return ans;\\n    }\\n};\\nTime complexity O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1108980,
                "title": "thought-process-and-o-n-java-solution",
                "content": "\\nLets understand logic through analogy. \\n1. if our ancestor have some property for us we say that they are my ancestor and we take that happily.\\n2. if they have some loan then we say we are self made no relation with them..\\n\\njokes apart the key thing is if previous subarray have positive sum we will be part of that else we will start subarray from us. and maintain the overall maximum(maximum till now) and current maximum(including me whats the maximum).\\n\\n**Time : O(N) and Space :O(1)**\\n```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int omax=nums[0];  // omax: overall maximum\\n        int cmax=nums[0]; //  cmax: current maximum\\n        \\n        for(int i=1;i<nums.length;i++){\\n            cmax=Math.max(nums[i],nums[i] + cmax);\\n            \\n            omax=Math.max(cmax,omax);\\n        }\\n        return omax;\\n    }\\n}\\n```\\nPlease **Upvote** if found it helpful :)\\nSimilar Question :[Maximum Product Subarray](https://leetcode.com/problems/maximum-product-subarray/)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int omax=nums[0];  // omax: overall maximum\\n        int cmax=nums[0]; //  cmax: current maximum\\n        \\n        for(int i=1;i<nums.length;i++){\\n            cmax=Math.max(nums[i],nums[i] + cmax);\\n            \\n            omax=Math.max(cmax,omax);\\n        }\\n        return omax;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 290007,
                "title": "go-4-ms-100-00-easy-code",
                "content": "```\\nfunc maxSubArray(nums []int) int {\\n\\tmax, sum := nums[0],nums[0]\\n\\tfor _, v := range nums[1:] {\\n\\t\\tif sum < 0 {\\n\\t\\t\\tsum = v\\n\\t\\t} else {\\n\\t\\t\\tsum += v\\n\\t\\t}\\n\\t\\tif max < sum {\\n\\t\\t\\tmax = sum\\n\\t\\t}\\n\\t}\\n\\treturn max\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maxSubArray(nums []int) int {\\n\\tmax, sum := nums[0],nums[0]\\n\\tfor _, v := range nums[1:] {\\n\\t\\tif sum < 0 {\\n\\t\\t\\tsum = v\\n\\t\\t} else {\\n\\t\\t\\tsum += v\\n\\t\\t}\\n\\t\\tif max < sum {\\n\\t\\t\\tmax = sum\\n\\t\\t}\\n\\t}\\n\\treturn max\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 20487,
                "title": "python-solutions-dp-o-n-space-o-1-space",
                "content": "        \\n    # DP, O(n) space\\n    def maxSubArray(self, nums):\\n        if not nums:\\n            return None\\n        dp = [0] * len(nums)\\n        res = dp[0] = nums[0]\\n        for i in xrange(1, len(nums)):\\n            dp[i] = max(dp[i-1]+nums[i], nums[i])\\n            res = max(res, dp[i])\\n        return res\\n        \\n    # DP, constant space\\n    def maxSubArray2(self, nums):\\n        if not nums:\\n            return None\\n        loc = glo= nums[0]\\n        for i in xrange(1, len(nums)):\\n            loc = max(loc+nums[i], nums[i])\\n            glo = max(loc, glo)\\n        return glo",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "        \\n    # DP, O(n) space\\n    def maxSubArray(self, nums):\\n        if not nums:\\n            return None\\n        dp = [0] * len(nums)\\n        res = dp[0] = nums[0]\\n        for i in xrange(1, len(nums)):\\n            dp[i] = max(dp[i-1]+nums[i], nums[i])\\n            res = max(res, dp[i])\\n        return res\\n        \\n    # DP, constant space\\n    def maxSubArray2(self, nums):\\n        if not nums:\\n            return None\\n        loc = glo= nums[0]\\n        for i in xrange(1, len(nums)):\\n            loc = max(loc+nums[i], nums[i])\\n            glo = max(loc, glo)\\n        return glo",
                "codeTag": "Python3"
            },
            {
                "id": 20509,
                "title": "o-n-time-o-1-space-dp-solution-java",
                "content": "Base case: 1 element, return nums[0]\\n\\nOther cases: \\n\\n- If dp[i-1] < 0, dp[i] = nums[i]\\n\\n- if dp[i-1] >0, dp[i] = nums[i] + dp[i-1]\\n\\nthen pick the max sum. \\n\\nWe only need dp[i-1], so i use prev to record it, the space complexity is reduced to O(1). \\n\\n    public int maxSubArray(int[] nums) {\\n        if (nums.length == 0){\\n            return 0;\\n        }\\n\\n        int prev = nums[0];\\n        int cur = nums[0];\\n        int max = nums[0];\\n        \\n        for (int i = 1; i < nums.length; i++){\\n            if (prev > 0){\\n                cur = prev + nums[i];\\n            }else{\\n                cur = nums[i];\\n            }\\n            max = Math.max(max, cur);\\n            prev = cur; \\n        }\\n        \\n        return max;\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "Base case: 1 element, return nums[0]\\n\\nOther cases: \\n\\n- If dp[i-1] < 0, dp[i] = nums[i]\\n\\n- if dp[i-1] >0, dp[i] = nums[i] + dp[i-1]\\n\\nthen pick the max sum. \\n\\nWe only need dp[i-1], so i use prev to record it, the space complexity is reduced to O(1). \\n\\n    public int maxSubArray(int[] nums) {\\n        if (nums.length == 0){\\n            return 0;\\n        }\\n\\n        int prev = nums[0];\\n        int cur = nums[0];\\n        int max = nums[0];\\n        \\n        for (int i = 1; i < nums.length; i++){\\n            if (prev > 0){\\n                cur = prev + nums[i];\\n            }else{\\n                cur = nums[i];\\n            }\\n            max = Math.max(max, cur);\\n            prev = cur; \\n        }\\n        \\n        return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 964113,
                "title": "my-simple-python-solution",
                "content": "```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        for i in range(1,len(nums)):\\n            nums[i]=max(nums[i-1]+nums[i],nums[i])\\n        return max(nums)\\n```\\n\\n```\\nRuntime: 88 ms, faster than 7.10% of Python3 online submissions for Maximum Subarray.\\nMemory Usage: 15.1 MB, less than 5.01% of Python3 online submissions for Maximum Subarray.\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        for i in range(1,len(nums)):\\n            nums[i]=max(nums[i-1]+nums[i],nums[i])\\n        return max(nums)\\n```\n```\\nRuntime: 88 ms, faster than 7.10% of Python3 online submissions for Maximum Subarray.\\nMemory Usage: 15.1 MB, less than 5.01% of Python3 online submissions for Maximum Subarray.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 898149,
                "title": "javascript-solution-with-explanation",
                "content": "Runtime: 88 ms\\nMemory Usage: 39.2 MB\\n\\n```\\nvar maxSubArray = function(nums) {\\n\\t//Declare a variable for our current overall maximum sum\\n    let maxSum = nums[0];\\n\\t//Declare a temporary sum for comparison\\n    let tempSum = nums[0];\\n\\t//Iterate over nums starting at nums[1] since we set our initial sums to nums[0]\\n    for (let i = 1; i < nums.length; i++) {\\n\\t\\t//The temporary sum is either the current number if the prior tempSum was negative for example\\n\\t\\t//Or it is the sum of tempSum and the new sum if that figure is larger \\n        tempSum = Math.max(nums[i], tempSum + nums[i]);\\n\\t\\t//Every time we have a new tempSum we want to compare it to our running maxSum \\n        maxSum = Math.max(tempSum, maxSum);\\n    };\\n\\t//return the max sum\\n  return maxSum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxSubArray = function(nums) {\\n\\t//Declare a variable for our current overall maximum sum\\n    let maxSum = nums[0];\\n\\t//Declare a temporary sum for comparison\\n    let tempSum = nums[0];\\n\\t//Iterate over nums starting at nums[1] since we set our initial sums to nums[0]\\n    for (let i = 1; i < nums.length; i++) {\\n\\t\\t//The temporary sum is either the current number if the prior tempSum was negative for example\\n\\t\\t//Or it is the sum of tempSum and the new sum if that figure is larger \\n        tempSum = Math.max(nums[i], tempSum + nums[i]);\\n\\t\\t//Every time we have a new tempSum we want to compare it to our running maxSum \\n        maxSum = Math.max(tempSum, maxSum);\\n    };\\n\\t//return the max sum\\n  return maxSum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 236505,
                "title": "simple-c-solution-o-n",
                "content": "**Solution 1**\\n```\\nint maxSubArray(int* nums, int numsSize)\\n{\\n    int i, max, tmp;\\n    \\n    for (i = 0, tmp = 0, max = nums[0]; i < numsSize; i++) {\\n        tmp += nums[i];\\n\\n        if (tmp > max)\\n            max = tmp;\\n        \\n        if (tmp < 0)\\n            tmp = 0;\\n    }\\n\\n    return max;\\n}\\n```\\n**Solution 2 - Divide and Conquer**\\n```\\nstatic int midCrossMax(int* arr, int size)\\n{\\n    int lmax, rmax, tmp, i, m = (size / 2) - 1;\\n    \\n    for (i = m, tmp = 0, lmax = arr[m]; i >= 0; i--) {\\n        tmp += arr[i];\\n        lmax = tmp > lmax ? tmp : lmax;\\n    }\\n    \\n    for (i = m + 1, tmp = 0, rmax = arr[m + 1]; i < size; i++) {\\n        tmp += arr[i];\\n        rmax = tmp > rmax ? tmp : rmax;\\n    }\\n\\n    return lmax + rmax;\\n}\\n\\nint maxSubArray(int* nums, int numsSize)\\n{\\n    int m = numsSize / 2;\\n    int max, l, r, c;\\n    \\n    if (numsSize == 1)\\n        return *nums;\\n    \\n    l = maxSubArray(nums, m);\\n    r = maxSubArray(nums + m, numsSize - m);\\n    c = midCrossMax(nums, numsSize);\\n    \\n    max = l > r ? l : r;\\n    max = max > c ? max : c;\\n\\n    return max;\\n    \\n}\\n```",
                "solutionTags": [
                    "C",
                    "Divide and Conquer"
                ],
                "code": "```\\nint maxSubArray(int* nums, int numsSize)\\n{\\n    int i, max, tmp;\\n    \\n    for (i = 0, tmp = 0, max = nums[0]; i < numsSize; i++) {\\n        tmp += nums[i];\\n\\n        if (tmp > max)\\n            max = tmp;\\n        \\n        if (tmp < 0)\\n            tmp = 0;\\n    }\\n\\n    return max;\\n}\\n```\n```\\nstatic int midCrossMax(int* arr, int size)\\n{\\n    int lmax, rmax, tmp, i, m = (size / 2) - 1;\\n    \\n    for (i = m, tmp = 0, lmax = arr[m]; i >= 0; i--) {\\n        tmp += arr[i];\\n        lmax = tmp > lmax ? tmp : lmax;\\n    }\\n    \\n    for (i = m + 1, tmp = 0, rmax = arr[m + 1]; i < size; i++) {\\n        tmp += arr[i];\\n        rmax = tmp > rmax ? tmp : rmax;\\n    }\\n\\n    return lmax + rmax;\\n}\\n\\nint maxSubArray(int* nums, int numsSize)\\n{\\n    int m = numsSize / 2;\\n    int max, l, r, c;\\n    \\n    if (numsSize == 1)\\n        return *nums;\\n    \\n    l = maxSubArray(nums, m);\\n    r = maxSubArray(nums + m, numsSize - m);\\n    c = midCrossMax(nums, numsSize);\\n    \\n    max = l > r ? l : r;\\n    max = max > c ? max : c;\\n\\n    return max;\\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1820428,
                "title": "99-faster-python3-easy-dp-solution-in-5-lines-using-kadane-s-algorithm-o-n",
                "content": "[This is a classic problem of theoretical computer science](https://en.wikipedia.org/wiki/Maximum_subarray_problem)\\n\\nBecause the *maximum subarray problem* is essentially  an **optimization problem** we can thus break it up into smaller problems\\nand return the best result of the said smaller problems..\\nSince we are breaking it up into smaller subarrays anyway we can **eliminate/ignore** subarrays that are *guaranteed* to not provide the optimal solution.\\nThe question we have to contend with now is *What criterea for elimination allows us to reduce the problem space efficiently?*\\n**[010]** Well it becomes a lot easier to establish this critereon if we have a starting point to compare subsequent subarrays to, since our function will not know much about the input array without analyzing it first lets just use the subarray of just the first index to start with and take its value as both our initial maximum value and our initial current value.\\n**[020]** Now that we have both a current subarray and a \\'maximum\\' to compare to lets consider some conditions\\n**[030]** If the sum of the current subarray is negative we can just toss that whole subarray out and start over with the new subbaray being the next index. because that whole subarray is a net drain on the optimal solution we are trying to build\\n**[035]** if the sum of the current subarray is non-negative add the next index to it, even if we lose some value with this addition we\\'re only keeping track of the highest valued subarray & the current subarray. As long as this subarray we\\'re currently keeping track of is a net positive it might be included in the maximum\\n**[040]** If this new current\\'s sum is greater than the \\'maximum\\'s make it the new maximum\\n**[050]** repeat from [020] until we have visited all items in nums\\n\\nNow that we have an algorithm lets see it in action with the example of one of the testcases:\\n```[-2,1,-3,4,-1,2,1,-5,4]```\\nInitially we\\'ll start with the leftmost value **-2**:\\n```\\nmax = -2, current sum = -2\\nmaximum subarray:\\n[-2]\\ncurrent subarray:\\n[-2]\\nremainder:\\n[1,-3,4,-1,2,1,-5,4]\\n```\\nsince **-2** is negative it\\'ll be a net drain on the optimal solution so we\\'ll just ignore it going forward and start a new\\nsubarray on the next value **1** which happens to be greater than -2\\n```\\nmax = 1, current sum= 1\\nmaximum subarray:\\n[1]\\ncurrent subarray:\\n[1]\\nremainder:\\n[-3,4,-1,2,1,-5,4]\\n```\\nadding the next value of **-3** brings us down a value of **-2**\\nmeaning the subarray is a net negative now and we\\'ll just discard it going forward\\n```\\nmax = 1, current sum=  -2\\nmaximum subarray:\\n[1]\\ncurrent subarray:\\n[1, -3]\\nremainder:\\n[4,-1,2,1,-5,4]\\n```\\nThe next value of **4** is greater than our previous maximum so we\\'ll just continue on from there\\n```\\nmax = 4, current sum=  4\\nmaximum subarray:\\n[4]\\ncurrent subarray:\\n[4]\\nremainder:\\n[-1,2,1,-5,4]\\n```\\nAdding the next value of **-1** doesnt produce a new maximum so we wont replace the old mximum but since it doesnt make the current a net negative we\\'ll keep working with it\\n```\\nmax = 4, current sum=  3\\nmaximum subarray:\\n[4]\\ncurrent subarray:\\n[4, -1]\\nremainder:\\n[2,1,-5,4]\\n```\\nAha! Adding this next value of **2** produces a new maximum of **5**\\n```\\nmax = 5, current sum=  5\\nmaximum subarray:\\n[4, -1, 2]\\ncurrent subarray:\\n[4, -1, 2]\\nremainder:\\n[1,-5,4]\\n```\\nIterating again brings us to a max of **6**\\n```\\nmax = 6, current sum= 6\\nmaximum subarray:\\n[4, -1, 2, 1]\\ncurrent subarray:\\n[4, -1, 2, 1]\\nremainder:\\n[-5,4]\\n```\\nPerforming the remaining iterations doesnt produce a new max \\n```\\nmax = 6, current sum= 1\\nmaximum subarray:\\n[4, -1, 2, 1]\\ncurrent subarray:\\n[4, -1, 2, 1,-5]\\nremainder:\\n[4]\\n```\\n```\\nmax = 6, current sum= 5\\nmaximum subarray:\\n[4, -1, 2, 1]\\ncurrent subarray:\\n[4, -1, 2, 1,-5,4]\\nremainder:\\n[]\\n```\\nThis will leave us with a maximum subarray sum of 6 so we return that.\\n\\nNow that we have an algorithm that works lets implement it in python:\\n```\\ndef maxSubArray(self, nums: List[int]) -> int:\\n        maxsum = cursum = nums[0]\\n    \\n        for n in range(1,len(nums)):\\n            if cursum < 0: cursum = 0\\n            cursum += nums[n]\\n            if cursum > maxsum: maxsum = cursum\\n        \\n        return maxsum\\n```\\nThis solution provides a time complexity of ```T(n)=O(n)``` and a space complexity of ```S(n) = O(1)```  (ignoring the memory allocation of passing ```nums``` to the function by value.)\\nThis particular implentation gives a best runtime of 648ms  (99.83th percentile) and a best memory use of 27.7mb (97.42th percentile) \\nTheres many different ways to implement kadane\\'s algorithm (leftwise comparison to maximum) in python but as long as it mostly matches the optimal implementation (only keeping track of the current and max sum, iterating over nums instead of generating a new list to iterate over, etc.)  the particulars of any given implementation will be optimized out when compiled to bytecode. You should be more concerned with writing code for clarity and being idiomatic in the language of your choice instead of making micro-optimizations.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```[-2,1,-3,4,-1,2,1,-5,4]```\n```\\nmax = -2, current sum = -2\\nmaximum subarray:\\n[-2]\\ncurrent subarray:\\n[-2]\\nremainder:\\n[1,-3,4,-1,2,1,-5,4]\\n```\n```\\nmax = 1, current sum= 1\\nmaximum subarray:\\n[1]\\ncurrent subarray:\\n[1]\\nremainder:\\n[-3,4,-1,2,1,-5,4]\\n```\n```\\nmax = 1, current sum=  -2\\nmaximum subarray:\\n[1]\\ncurrent subarray:\\n[1, -3]\\nremainder:\\n[4,-1,2,1,-5,4]\\n```\n```\\nmax = 4, current sum=  4\\nmaximum subarray:\\n[4]\\ncurrent subarray:\\n[4]\\nremainder:\\n[-1,2,1,-5,4]\\n```\n```\\nmax = 4, current sum=  3\\nmaximum subarray:\\n[4]\\ncurrent subarray:\\n[4, -1]\\nremainder:\\n[2,1,-5,4]\\n```\n```\\nmax = 5, current sum=  5\\nmaximum subarray:\\n[4, -1, 2]\\ncurrent subarray:\\n[4, -1, 2]\\nremainder:\\n[1,-5,4]\\n```\n```\\nmax = 6, current sum= 6\\nmaximum subarray:\\n[4, -1, 2, 1]\\ncurrent subarray:\\n[4, -1, 2, 1]\\nremainder:\\n[-5,4]\\n```\n```\\nmax = 6, current sum= 1\\nmaximum subarray:\\n[4, -1, 2, 1]\\ncurrent subarray:\\n[4, -1, 2, 1,-5]\\nremainder:\\n[4]\\n```\n```\\nmax = 6, current sum= 5\\nmaximum subarray:\\n[4, -1, 2, 1]\\ncurrent subarray:\\n[4, -1, 2, 1,-5,4]\\nremainder:\\n[]\\n```\n```\\ndef maxSubArray(self, nums: List[int]) -> int:\\n        maxsum = cursum = nums[0]\\n    \\n        for n in range(1,len(nums)):\\n            if cursum < 0: cursum = 0\\n            cursum += nums[n]\\n            if cursum > maxsum: maxsum = cursum\\n        \\n        return maxsum\\n```\n```T(n)=O(n)```\n```S(n) = O(1)```\n```nums```",
                "codeTag": "Python3"
            },
            {
                "id": 561639,
                "title": "simplest-o-n-time-java-solution-beats-100",
                "content": "```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        if(nums.length == 0)\\n            return Integer.MIN_VALUE;\\n        \\n        int currentWindowSum = nums[0];\\n        int largestSum = nums[0];\\n        for(int i=1; i<nums.length ; i++){\\n            //start a new window , if starting is a better option than extending\\n            currentWindowSum = Math.max(currentWindowSum+nums[i],nums[i]);\\n            largestSum = Math.max(largestSum,currentWindowSum);\\n        }\\n        return largestSum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        if(nums.length == 0)\\n            return Integer.MIN_VALUE;\\n        \\n        int currentWindowSum = nums[0];\\n        int largestSum = nums[0];\\n        for(int i=1; i<nums.length ; i++){\\n            //start a new window , if starting is a better option than extending\\n            currentWindowSum = Math.max(currentWindowSum+nums[i],nums[i]);\\n            largestSum = Math.max(largestSum,currentWindowSum);\\n        }\\n        return largestSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 399490,
                "title": "beat-94-76-python-users-no-dp-kadane-algorithm",
                "content": "\\tclass Solution(object):\\n\\t\\tdef maxSubArray(self, nums):\\n\\t\\t\\tfor i in range(1, len(nums)):\\n\\t\\t\\t\\tif nums[i - 1] > 0: \\n\\t\\t\\t\\t\\tnums[i] += nums[i - 1]\\n\\t\\t\\treturn max(nums)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution(object):\\n\\t\\tdef maxSubArray(self, nums):\\n\\t\\t\\tfor i in range(1, len(nums)):\\n\\t\\t\\t\\tif nums[i - 1] > 0: \\n\\t\\t\\t\\t\\tnums[i] += nums[i - 1]\\n\\t\\t\\treturn max(nums)",
                "codeTag": "Java"
            },
            {
                "id": 182866,
                "title": "javascript",
                "content": "```\nvar maxSubArray = function(nums) {\n    if(nums.length == 0) return 0;\n    let result = Number.MIN_SAFE_INTEGER;\n    let sum = 0;\n    for(let i = 0; i < nums.length; i++) {\n        sum += nums[i];\n        result = Math.max(sum, result);\n        sum = sum < 0 ? 0 : sum;\n    }\n    return result;\n};\n```",
                "solutionTags": [],
                "code": "```\nvar maxSubArray = function(nums) {\n    if(nums.length == 0) return 0;\n    let result = Number.MIN_SAFE_INTEGER;\n    let sum = 0;\n    for(let i = 0; i < nums.length; i++) {\n        sum += nums[i];\n        result = Math.max(sum, result);\n        sum = sum < 0 ? 0 : sum;\n    }\n    return result;\n};\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 163139,
                "title": "solution-with-divide-and-conquer-as-well-as-normal-iterative-both-acccepted",
                "content": "straight forward approach is commented, the solution is typical implementation of the maximum suarray algorithm for divide and conquer . \\nTo solve it using divide and conquer, think about three possibilities, either the left sub array is having maximum sum, or the right sub array is having the maximum sum. Or the middle element is there in the Sum. so with left subarray and right subarray, problem can be broken down to a recursive call. The crossing subarray , the one with the middle element needs to be solved as a base case, and it is easy to solve as we already know from where to start, you just start from the middle and traverse towards left, till you get an increase in total sum, so keep track of two sums , similarly do this for right side, and return the sum. \\n```\\nclass Solution {\\n    int getCrossSum(vector<int> &nums,int low,int high)\\n    {\\n        if(low >=high)\\n            return nums[low];\\n        int mid = low+high;\\n        mid =mid/2;\\n        int sum = nums[mid];\\n        int tsum=sum;\\n        for(int i = mid-1;i>=low;i--)\\n        {\\n            tsum+=nums[i];\\n            if(sum<tsum)\\n                sum=tsum;\\n        }\\n        tsum=sum;\\n        for(int i = mid+1; i<=high; i++)\\n        {\\n            tsum+=nums[i];\\n            if(sum<tsum)\\n                sum=tsum;\\n        }\\n        return sum;\\n    }\\n    int maxSum(vector<int> &nums,int low, int high) {\\n        if(low>=high)\\n            return nums[low];\\n        int mid = low+high;\\n        mid = mid/2;\\n        int crossSum = getCrossSum(nums,low,high);\\n        int leftSum = maxSum(nums,low,mid);\\n        int rightSum = maxSum(nums,mid+1,high);\\n        if(leftSum> rightSum && leftSum> crossSum)\\n            return leftSum; \\n        if(rightSum> crossSum)\\n            return rightSum;\\n        return crossSum;\\n    }\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        return maxSum(nums,0,nums.size()-1);\\n    }\\n    /*int maxSubArray(vector<int>& nums) {\\n        if(nums.empty())\\n            return 0; \\n        int cur = 0,res=nums[0]; \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            cur = max(nums[i],cur+=nums[i]);\\n            res = max(cur,res);\\n        }\\n        return res;\\n    }*/\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    int getCrossSum(vector<int> &nums,int low,int high)\\n    {\\n        if(low >=high)\\n            return nums[low];\\n        int mid = low+high;\\n        mid =mid/2;\\n        int sum = nums[mid];\\n        int tsum=sum;\\n        for(int i = mid-1;i>=low;i--)\\n        {\\n            tsum+=nums[i];\\n            if(sum<tsum)\\n                sum=tsum;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 20283,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution with discussion** https://discuss.leetcode.com/topic/80136/python-solution-with-detailed-explanation\\n\\n**Maximum Subarray** https://leetcode.com/problems/maximum-subarray/\\n\\n**Dynamic Programming **\\n```\\nclass Solution(object):\\n    def maxSubArray(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        max_so_far, curr_sum = -2**31, 0\\n        for i in range(len(nums)):\\n            if curr_sum+nums[i] < 0:\\n                curr_sum, max_so_far = 0, max(max_so_far, nums[i])\\n            else:\\n                curr_sum, max_so_far = curr_sum + nums[i], max(max_so_far, curr_sum + nums[i])\\n        return max_so_far\\n\\n```\\n\\n```\\nclass Solution(object):\\n    def maxSubArray(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        max_so_far, curr_sum = max(nums), 0\\n        for i in range(len(nums)):\\n            if curr_sum+nums[i] < 0:\\n                curr_sum = 0\\n            else:\\n                curr_sum, max_so_far = curr_sum + nums[i], max(max_so_far, curr_sum + nums[i])\\n        return max_so_far\\n```\\n\\n**Divide and Conquer**\\n* Divide and Conquer solution, the solution can lie entirely in left or in right or span in between.\\n* When it spans in between, we can use principle of optimality. The middle sum can be broken into sum from middle-1 towards left, and sum from middle+1 towards an index <= high. Lets call these sums as lmax and rmax. \\n* Now the maximum middle sum must be max(lmax,0)+max(rmax,0)+nums[mid]. \\n* Why? We have to include nums[mid]. Now the left sum or right sum will only be included if the sum is positive. \\n\\n```\\nclass Solution(object):\\n    def maxSubArray(self, nums):\\n        return self.helper(nums, 0, len(nums)-1)\\n    \\n    def helper(self, nums, low, high):\\n        if low > high:\\n            return 0\\n        if low == high:\\n            return nums[low]\\n        mid = low + (high-low)//2\\n        x_left = self.helper(nums, low, mid)\\n        x_right = self.helper(nums, mid+1, high)\\n        lmax, rmax = float('-inf'), float('-inf')\\n        lsum, rsum = 0,0\\n        for i in range(mid-1, low-1, -1): ### Important Insight in NlgN solutions\\n            lsum = lsum + nums[i]\\n            lmax = max(lmax, lsum)\\n        for i in range(mid+1, high+1, 1):\\n            rsum = rsum + nums[i]\\n            rmax = max(rmax, rsum)\\n        return max(x_left, x_right, max(0,lmax)+max(0,rmax)+nums[mid])        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxSubArray(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        max_so_far, curr_sum = -2**31, 0\\n        for i in range(len(nums)):\\n            if curr_sum+nums[i] < 0:\\n                curr_sum, max_so_far = 0, max(max_so_far, nums[i])\\n            else:\\n                curr_sum, max_so_far = curr_sum + nums[i], max(max_so_far, curr_sum + nums[i])\\n        return max_so_far\\n\\n```\n```\\nclass Solution(object):\\n    def maxSubArray(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        max_so_far, curr_sum = max(nums), 0\\n        for i in range(len(nums)):\\n            if curr_sum+nums[i] < 0:\\n                curr_sum = 0\\n            else:\\n                curr_sum, max_so_far = curr_sum + nums[i], max(max_so_far, curr_sum + nums[i])\\n        return max_so_far\\n```\n```\\nclass Solution(object):\\n    def maxSubArray(self, nums):\\n        return self.helper(nums, 0, len(nums)-1)\\n    \\n    def helper(self, nums, low, high):\\n        if low > high:\\n            return 0\\n        if low == high:\\n            return nums[low]\\n        mid = low + (high-low)//2\\n        x_left = self.helper(nums, low, mid)\\n        x_right = self.helper(nums, mid+1, high)\\n        lmax, rmax = float('-inf'), float('-inf')\\n        lsum, rsum = 0,0\\n        for i in range(mid-1, low-1, -1): ### Important Insight in NlgN solutions\\n            lsum = lsum + nums[i]\\n            lmax = max(lmax, lsum)\\n        for i in range(mid+1, high+1, 1):\\n            rsum = rsum + nums[i]\\n            rmax = max(rmax, rsum)\\n        return max(x_left, x_right, max(0,lmax)+max(0,rmax)+nums[mid])        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2764848,
                "title": "easy-to-understand-all-approaches-covered-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int current_sum=0;\\n        int maximum_sum=INT_MIN;\\n        int n=nums.size(); //size\\n\\n// ---------------------------1st Approach------------------------\\n// Brute Force...\\n// it\\'ll give TLE... \\n// reason, Time complexity is greater than req.\\n// time O(n^2) ; Space O(1)\\n    // for (int i = 0; i <= n - 1; i++) \\n    // {\\n    //     int current_sum = 0;\\n    //     for (int j = i; j <= n - 1; j++) \\n    //     {\\n    //     current_sum += nums[j];\\n    //         if (current_sum > maximum_sum) \\n    //         {\\n    //             maximum_sum = current_sum;\\n    //         }\\n    //     }\\n    // }\\n    // return maximum_sum;\\n\\n\\n// ---------------------------2nd Approach------------------------\\n// This algorithmn is also popularly known as,\\n// ***\"Kadan\\'s Algo\"***\\n// time O(n)\\n// space O(1)\\n        for(int i=0; i<n; i++)\\n        {\\n            current_sum += nums[i];\\n            maximum_sum = max(maximum_sum,current_sum);\\n\\n            if(current_sum<0) \\n                current_sum=0;\\n        }\\n\\n        return maximum_sum;\\n    }\\n};\\n```\\nCoded By Harsh Pandey\\nPlease Upvote if it Helped... Thank You...\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int current_sum=0;\\n        int maximum_sum=INT_MIN;\\n        int n=nums.size(); //size\\n\\n// ---------------------------1st Approach------------------------\\n// Brute Force...\\n// it\\'ll give TLE... \\n// reason, Time complexity is greater than req.\\n// time O(n^2) ; Space O(1)\\n    // for (int i = 0; i <= n - 1; i++) \\n    // {\\n    //     int current_sum = 0;\\n    //     for (int j = i; j <= n - 1; j++) \\n    //     {\\n    //     current_sum += nums[j];\\n    //         if (current_sum > maximum_sum) \\n    //         {\\n    //             maximum_sum = current_sum;\\n    //         }\\n    //     }\\n    // }\\n    // return maximum_sum;\\n\\n\\n// ---------------------------2nd Approach------------------------\\n// This algorithmn is also popularly known as,\\n// ***\"Kadan\\'s Algo\"***\\n// time O(n)\\n// space O(1)\\n        for(int i=0; i<n; i++)\\n        {\\n            current_sum += nums[i];\\n            maximum_sum = max(maximum_sum,current_sum);\\n\\n            if(current_sum<0) \\n                current_sum=0;\\n        }\\n\\n        return maximum_sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1770357,
                "title": "c-easy-kadane-s-algorithm",
                "content": "\\'\\'\\'   \\n**PLEASE DO UPVOTE IF YOU UNDERSTAND.**\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\n    \\n\\t/*------KADANE\\'s ALGORITHM-------*/\\n    \\n    int maxSubArray(vector<int>& nums) {\\n        \\n        int ans=INT_MIN;\\n        \\n        int sum=0;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            \\n            sum+=nums[i];\\n            \\n            if(nums[i]>sum) sum=nums[i];\\n            \\n            ans=max(sum,ans);\\n        }\\n        \\n        return ans;\\n    }\\n\\t};\\n\\t**PLEASE DO UPVOTE IF YOU UNDERSTAND.**\\n\\'\\'\\'",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\n    \\n\\t/*------KADANE\\'s ALGORITHM-------*/\\n    \\n    int maxSubArray(vector<int>& nums) {\\n        \\n        int ans=INT_MIN;\\n        \\n        int sum=0;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            \\n            sum+=nums[i];\\n            \\n            if(nums[i]>sum) sum=nums[i];\\n            \\n            ans=max(sum,ans);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1609650,
                "title": "easy-solution-in-c",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistakes please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int ans= nums[0];\\n        int n= nums.size();\\n        int sum=0;\\n        for(int i=0; i<n; i++){\\n            sum += nums[i];\\n            ans = max(ans, sum);\\n            \\n            if(sum<0)\\n                sum=0;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n---\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int ans= nums[0];\\n        int n= nums.size();\\n        int sum=0;\\n        for(int i=0; i<n; i++){\\n            sum += nums[i];\\n            ans = max(ans, sum);\\n            \\n            if(sum<0)\\n                sum=0;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1533366,
                "title": "python-soultion-easy-to-understand",
                "content": "The idea for this question is that negative numbers do not help us with the sum so if we see a negative number we want to ignore them. \\n```\\n def maxSubArray(nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        currentSum = nums[0] #setting current sum to be the first element\\n        maxSum = nums[0] #same thing for maxSum\\n        for i in range(1,len(nums)):\\n            if currentSum < 0:  #if currentsum is negative then that means ignore all the prev elements\\n                currentSum = nums[i]\\n            else:\\n                currentSum += nums[i] #if not add the current element to the currentSum\\n                    \\n            maxSum = max(currentSum, maxSum) #compare currentSum to maxSum. \\n            \\n        return maxSum    \\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\n def maxSubArray(nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        currentSum = nums[0] #setting current sum to be the first element\\n        maxSum = nums[0] #same thing for maxSum\\n        for i in range(1,len(nums)):\\n            if currentSum < 0:  #if currentsum is negative then that means ignore all the prev elements\\n                currentSum = nums[i]\\n            else:\\n                currentSum += nums[i] #if not add the current element to the currentSum\\n                    \\n            maxSum = max(currentSum, maxSum) #compare currentSum to maxSum. \\n            \\n        return maxSum    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 561756,
                "title": "python-o-n-solution-44ms-beats-95",
                "content": "```\\nclass Solution(object):\\n    def maxSubArray(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        windowSum = nums[0]\\n        maxSum = nums[0]\\n        \\n        for i in range(1,len(nums)):\\n            windowSum = max(windowSum+nums[i], nums[i])\\n            maxSum = max(windowSum, maxSum)\\n        return maxSum\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxSubArray(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        windowSum = nums[0]\\n        maxSum = nums[0]\\n        \\n        for i in range(1,len(nums)):\\n            windowSum = max(windowSum+nums[i], nums[i])\\n            maxSum = max(windowSum, maxSum)\\n        return maxSum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 423761,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxSubArray = function(nums) {\\n    let max = -Infinity;\\n    let currentMax = 0;\\n    \\n    for(let i = 0; i < nums.length; i++) {\\n        currentMax = Math.max(nums[i], currentMax + nums[i]);\\n        max = Math.max(currentMax, max);               \\n    }\\n    \\n    return max;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxSubArray = function(nums) {\\n    let max = -Infinity;\\n    let currentMax = 0;\\n    \\n    for(let i = 0; i < nums.length; i++) {\\n        currentMax = Math.max(nums[i], currentMax + nums[i]);\\n        max = Math.max(currentMax, max);               \\n    }\\n    \\n    return max;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 254481,
                "title": "javascript-3-solutions-aggregate-kadane-s-algorithm-divide-and-conquer",
                "content": "**Aggregate**\\n```\\nvar maxSubArray = function(nums) {\\n    let maxSum = nums[0], val = 0\\n    nums.forEach(num => {\\n        maxSum = Math.max(maxSum, val += num)\\n        val = Math.max(val, 0)\\n    })\\n    return maxSum\\n}\\n```\\n\\n**Kadane\\'s Algorithm(DP)**\\n```\\nvar maxSubArray = function(nums) {\\n    let maxSoFar = nums[0]\\n    for(let i = 1, maxEndHere = nums[0]; i < nums.length; ++i) {\\n        maxEndHere = Math.max(nums[i], maxEndHere + nums[i])\\n        maxSoFar = Math.max(maxSoFar, maxEndHere)\\n    }\\n    return maxSoFar\\n}\\n```\\n\\n**Divide and Conquer**\\n```\\nconst maxSub = (nums, left, right) => {\\n    if(left === right)\\n        return nums[left]\\n    else if(left > right)\\n        return Number.NEGATIVE_INFINITY\\n    \\n    let mid = Math.floor((left + right) / 2)\\n    let lmax = maxSub(nums, left, mid - 1)\\n    let rmax = maxSub(nums, mid + 1, right)\\n    \\n    let leftExtendMaxSum = rightExtendMaxSum = 0\\n    for(let i = mid - 1, tempTotal = 0; i >= left; --i)\\n        leftExtendMaxSum = Math.max(tempTotal += nums[i], leftExtendMaxSum)\\n\\n    for(let i = mid + 1, tempTotal = 0; i <= right; ++i)\\n        rightExtendMaxSum = Math.max(tempTotal += nums[i], rightExtendMaxSum)\\n\\n    return Math.max(leftExtendMaxSum + nums[mid] + rightExtendMaxSum, lmax, rmax)\\n}\\n\\nvar maxSubArray = nums =>\\n    maxSub(nums, 0, nums.length - 1)\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Divide and Conquer",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar maxSubArray = function(nums) {\\n    let maxSum = nums[0], val = 0\\n    nums.forEach(num => {\\n        maxSum = Math.max(maxSum, val += num)\\n        val = Math.max(val, 0)\\n    })\\n    return maxSum\\n}\\n```\n```\\nvar maxSubArray = function(nums) {\\n    let maxSoFar = nums[0]\\n    for(let i = 1, maxEndHere = nums[0]; i < nums.length; ++i) {\\n        maxEndHere = Math.max(nums[i], maxEndHere + nums[i])\\n        maxSoFar = Math.max(maxSoFar, maxEndHere)\\n    }\\n    return maxSoFar\\n}\\n```\n```\\nconst maxSub = (nums, left, right) => {\\n    if(left === right)\\n        return nums[left]\\n    else if(left > right)\\n        return Number.NEGATIVE_INFINITY\\n    \\n    let mid = Math.floor((left + right) / 2)\\n    let lmax = maxSub(nums, left, mid - 1)\\n    let rmax = maxSub(nums, mid + 1, right)\\n    \\n    let leftExtendMaxSum = rightExtendMaxSum = 0\\n    for(let i = mid - 1, tempTotal = 0; i >= left; --i)\\n        leftExtendMaxSum = Math.max(tempTotal += nums[i], leftExtendMaxSum)\\n\\n    for(let i = mid + 1, tempTotal = 0; i <= right; ++i)\\n        rightExtendMaxSum = Math.max(tempTotal += nums[i], rightExtendMaxSum)\\n\\n    return Math.max(leftExtendMaxSum + nums[mid] + rightExtendMaxSum, lmax, rmax)\\n}\\n\\nvar maxSubArray = nums =>\\n    maxSub(nums, 0, nums.length - 1)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 20369,
                "title": "java-6-line-dp-soulution",
                "content": "```\\npublic class Solution {\\n    public int maxSubArray(int[] nums) {\\n        int maxSum = nums[0], length = nums.length;\\n        for(int i = 1; i<length; i++) {\\n        \\tif(nums[i-1]>0) nums[i] = nums[i-1]+nums[i];\\n        \\tif(maxSum<nums[i]) maxSum = nums[i];\\n        }\\n        return maxSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic class Solution {\\n    public int maxSubArray(int[] nums) {\\n        int maxSum = nums[0], length = nums.length;\\n        for(int i = 1; i<length; i++) {\\n        \\tif(nums[i-1]>0) nums[i] = nums[i-1]+nums[i];\\n        \\tif(maxSum<nums[i]) maxSum = nums[i];\\n        }\\n        return maxSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 20485,
                "title": "simple-c-dp-8ms",
                "content": "Just do DP, use curMax to calculate the maximum sum ending at nums[i], so the recurisve equation is \\ncurMax at i+1 = max(0, curMax) + nums[i+1] \\n\\n    class Solution {\\n    public:\\n        int maxSubArray(vector<int>& nums) {\\n            int curMax = 0, res = INT_MIN, i;\\n            for(auto x:nums)\\n            {\\n                curMax = curMax>0? (curMax + x):x ;\\n                if(curMax > res ) res = curMax;\\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int maxSubArray(vector<int>& nums) {\\n            int curMax = 0, res = INT_MIN, i;\\n            for(auto x:nums)\\n            {\\n                curMax = curMax>0? (curMax + x):x ;\\n                if(curMax > res ) res = curMax;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3596596,
                "title": "3-approaches-brute-to-optimised-kadane-s-algorithm",
                "content": "# **Approach 1:**\\n\\n# **Intuition**\\n\\nThe first intuition is to generate all subarrays and then compute sum of all subarrays.\\n\\n# **Approach**\\n\\nIterate i ->0 to n and j -> i to n and then k -> i(start) to j (end) to generate all subarray and compute sum inside k loop.\\n\\n# **Complexity**\\n\\n- Time complexity:\\n\\n```\\nO(n^3)\\n```\\n\\n- Space complexity:\\n\\n```\\nO(1)\\n```\\n\\n# **Code**\\n\\n```cpp\\n class Solution {\\n    public:\\n        int maxSubArray(vector<int>& nums) {\\n            int sum=0,maxSum=INT_MIN;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n\\n            for(int j=i;j<nums.size();j++)\\n            {\\n                sum=0;\\n                for(int k=i;k<=j;k++)\\n                {\\n                    sum+=nums[k];\\n                }\\n                maxSum=max(maxSum,sum);\\n            }\\n        }\\n        return maxSum;\\n        }\\n    };\\n```\\n\\n# **Approach 2:**\\n\\n# **Intuition**\\n\\nThe intuition is to maintain to pointers to mark the start and end and compute sum of numbers in the range.\\n\\n# **Approach**\\n\\nIterate i ->0 to n and j -> i to n  to generate all subarray and compute sum inside loop.\\n\\n# **Complexity**\\n\\n- Time complexity:\\n\\n```\\nO(n^2)\\n```\\n\\n- Space complexity:\\n\\n```\\nO(1)\\n```\\n\\n# **Code**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int sum=0,maxSum=INT_MIN;\\n     for(int i=0;i<nums.size();i++)\\n     {\\n         sum=0;\\n         for(int j=i;j<nums.size();j++)\\n         {\\n             sum+=nums[j];\\n             maxSum=max(maxSum,sum);\\n         }\\n     }\\n     return maxSum;\\n    }\\n};\\n```\\n\\n# **Approach 3:**\\n\\n# **Intuition**\\n\\nUsing Kadane\\'s Algorithm.\\n\\n# **Approach**\\n\\nRun a loop from i -> 1 to n. Our motivate is to ignore sum if negative and start with a new subarray. Keep on adding values to sum variable maintain a maximum variable to store the maximum seen so far. If sum exceeds max then store sum in max. If sum is negative then set sum to 0 because we do not need negative sum and the sum needs to be continous as subarray is specified in the question so for starting the sum for a new subarray we need to set the sum to 0.\\n\\n# **Complexity**\\n\\n- Time complexity:\\n\\n```\\nO(n)\\n```\\n\\n- Space complexity:\\n\\n```\\nO(1)\\n```\\n\\n# **Code**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int sum=0,max=nums[0];\\n     for(int i=0;i<nums.size();i++)\\n     {\\n         sum+=nums[i];\\n         if(sum>max)\\n            max=sum;\\n        if(sum<0)\\n            sum=0;\\n     }   \\n     return max;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nO(n^3)\\n```\n```\\nO(1)\\n```\n```cpp\\n class Solution {\\n    public:\\n        int maxSubArray(vector<int>& nums) {\\n            int sum=0,maxSum=INT_MIN;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n\\n            for(int j=i;j<nums.size();j++)\\n            {\\n                sum=0;\\n                for(int k=i;k<=j;k++)\\n                {\\n                    sum+=nums[k];\\n                }\\n                maxSum=max(maxSum,sum);\\n            }\\n        }\\n        return maxSum;\\n        }\\n    };\\n```\n```\\nO(n^2)\\n```\n```\\nO(1)\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int sum=0,maxSum=INT_MIN;\\n     for(int i=0;i<nums.size();i++)\\n     {\\n         sum=0;\\n         for(int j=i;j<nums.size();j++)\\n         {\\n             sum+=nums[j];\\n             maxSum=max(maxSum,sum);\\n         }\\n     }\\n     return maxSum;\\n    }\\n};\\n```\n```\\nO(n)\\n```\n```\\nO(1)\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int sum=0,max=nums[0];\\n     for(int i=0;i<nums.size();i++)\\n     {\\n         sum+=nums[i];\\n         if(sum>max)\\n            max=sum;\\n        if(sum<0)\\n            sum=0;\\n     }   \\n     return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115907,
                "title": "javascript-fast-very-easy-to-understand-solution-with-video-explanation",
                "content": "If you like my video and explanation, Subscribe please!!! Thank you!!\\n\\nhttps://youtu.be/kMSVhfhX2YQ\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxSubArray = function(nums) {\\n    \\n    for(let i =1; i<nums.length;i++){\\n        nums[i] = Math.max(nums[i],nums[i]+nums[i-1])\\n    }\\n    return Math.max(...nums)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxSubArray = function(nums) {\\n    \\n    for(let i =1; i<nums.length;i++){\\n        nums[i] = Math.max(nums[i],nums[i]+nums[i-1])\\n    }\\n    return Math.max(...nums)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1680489,
                "title": "javascript-solution-with-explanation-o-n-time-complexity",
                "content": "By brute force, the time complexity will be O(n^2). In this we will check all posible subarrays and find out their sums.\\n\\nBetter solution :\\nWhenever we need to find out maximum or minimum of anything, we can try dynamic programming way as the solution. \\nThe key part in DP is to find out the sub-problem. \\nConsider the max sum till the index previous to the index under consideration. There are 2 ways to move ahead. \\n1. add the current index element to the max sum till the previous index. \\n2. only consider this new element \\n\\nWhichever is the bigger of above two, we will consider that.\\n\\nHere time complexity will be  O(n).\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxSubArray = function(nums) {\\n    let maxSum = nums[0];   \\n\\tlet sum = nums[0];\\n\\tfor(let i=1; i< nums.length; i++){   // start with 2nd element.\\n\\t\\tsum = Math.max(nums[i], nums[i]+sum);\\n\\t\\tif(sum > maxSum) maxSum = sum;\\n\\t}\\n\\treturn maxSum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxSubArray = function(nums) {\\n    let maxSum = nums[0];   \\n\\tlet sum = nums[0];\\n\\tfor(let i=1; i< nums.length; i++){   // start with 2nd element.\\n\\t\\tsum = Math.max(nums[i], nums[i]+sum);\\n\\t\\tif(sum > maxSum) maxSum = sum;\\n\\t}\\n\\treturn maxSum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1435684,
                "title": "java-step-by-step-optimization-explained",
                "content": "Inefficient solution.\\n\\ntime: O(n^3), space: O(1)\\nLet\\'s do better :(\\n```java\\npublic int solution1(int[] nums) {\\n\\tint max = 0;\\n\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\tfor (int j = i; j < nums.length; j++) {\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tfor (int k = i; k <= j; k++) {\\n\\t\\t\\t\\tsum += nums[k];\\n\\t\\t\\t}\\n\\t\\t\\tmax = Math.max(max, sum);\\n\\t\\t}\\n\\t}\\n\\treturn max;\\n}\\n```\\n</br>\\n\\nRealize that the third loop repeats work. On each subsequent iteration of j, it is simply readding everything it did in the previous iteration except it just adds the next nums value. An example is [2,-1,3]. It first sums the subarray [2], then [2,-1], [2,-1,3]... We can simply store the previous results in an array (memoization) and add the new nums value with the previous cumulative sum. This removes the third loop.\\n\\ntime: O(n^2), space: O(n)\\nWe can still do better :|\\n```\\npublic int solution2(int[] nums) {\\n\\tint max = 0;\\n\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\tint memo[] = new int[nums.length + 1 - i];\\n\\t\\tmemo[0] = nums[i];\\n\\t\\tmax = Math.max(max, memo[0]);\\n\\t\\tfor (int j = 1; j < memo.length - 1; j++) {\\n\\t\\t\\tmemo[j] = memo[j - 1] + nums[i + j];\\n\\t\\t\\tmax = Math.max(max, memo[j]);\\n\\t\\t}\\n\\t}\\n\\treturn max;\\n}\\n```\\n</br>\\n\\nWe can make memo smaller cause we don\\'t need all the previous results, just the most recent previous. A very typical memoization optimization technique.\\n\\ntime: O(n^2), space: O(1)\\nConstant space :)\\n```java\\npublic int solution3(int[] nums) {\\n\\tint max = 0;\\n\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\tint memo = nums[i];\\n\\t\\tmax = Math.max(max, nums[i]);\\n\\t\\tfor (int j = 1; j < nums.length - i; j++) {\\n\\t\\t\\tmemo = memo + nums[i + j]; // currVal = prevVal + currNum\\n\\t\\t\\tmax = Math.max(max, memo);\\n\\t\\t}\\n\\t}\\n\\treturn max;\\n}\\n```\\n</br>\\n\\nThis one is difficult. Notice that the results won\\'t change for the above if we change memo update to the following: `memo = Math.max(nums[i + j], memo + nums[i + j]);` We then realize the second loop is unnecesary. We notice that we don\\'t actually need to compare every cumulative sum all the way from i + j. We just need to know the current valid one at i. Let me explain. \\nOur memo is currently storing the cumulative sum. Our objective is to find the max cumulative sum possible in our array. On every step in this array, we know the maximum sum at the moment can either be the current cumulative sum (what was added up so far) or it could start from the current value. The current cumulative sum can fall below the current nums value (cause negative values are possible), in which we have to reassign our cumulative sum variable as the current nums value (cause it can never grow bigger if it\\'s subtracting from our cumulative sum at that point). We then can compare every valid cumulative sum with each other by keeping track of the global maximum like we\\'ve been doing in the previous solutions.\\n\\nA different way to visualize it can be a sliding-window. Imagine that we\\'re changing the starting index of our subarray, once we find that the sum of the current subarray is smaller than the nums value at our current index. So we update the start index to be the current index. But we don\\'t actually needed to keep track of the indices of our \"subarray window\" cause we can just keep track of the cumulative sum. If you approach this problem through the sliding-window way, you should still arrive at the same optimized answer I have given below once you realize you don\\'t need to keep track of the indices.\\n\\nAn explanation for more proofy people, the invariant holds true that we can\\'t increase the cumulative sum anymore on every iteration when we know that the current cumulative sum (includes the curr value) falls below our curr value. The current cumulative sum will never be bigger than if we just start the cumulative sum from the curr index. We can then just keep track of a global maximum value, to find which valid cumulative sums are possible.\\n\\nI basically said the same thing 3 times... You get the point.\\n\\ntime: O(n), space: O(1)\\n100%! :))\\n```java\\npublic int solution4(int[] nums) {\\n\\tif (nums.length == 0) {\\n\\t\\treturn 0;\\n\\t}\\n\\tint currSum = nums[0];\\n\\tint max = nums[0];\\n\\tfor (int i = 1; i < nums.length; i++) {\\n\\t\\tcurrSum += nums[i];\\n\\t\\tcurrSum = Math.max(nums[i], currSum); // curr value vs curr cumulativee\\n\\t\\tmax = Math.max(max, currSum);\\n\\t}\\n\\treturn max;\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic int solution1(int[] nums) {\\n\\tint max = 0;\\n\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\tfor (int j = i; j < nums.length; j++) {\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tfor (int k = i; k <= j; k++) {\\n\\t\\t\\t\\tsum += nums[k];\\n\\t\\t\\t}\\n\\t\\t\\tmax = Math.max(max, sum);\\n\\t\\t}\\n\\t}\\n\\treturn max;\\n}\\n```\n```\\npublic int solution2(int[] nums) {\\n\\tint max = 0;\\n\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\tint memo[] = new int[nums.length + 1 - i];\\n\\t\\tmemo[0] = nums[i];\\n\\t\\tmax = Math.max(max, memo[0]);\\n\\t\\tfor (int j = 1; j < memo.length - 1; j++) {\\n\\t\\t\\tmemo[j] = memo[j - 1] + nums[i + j];\\n\\t\\t\\tmax = Math.max(max, memo[j]);\\n\\t\\t}\\n\\t}\\n\\treturn max;\\n}\\n```\n```java\\npublic int solution3(int[] nums) {\\n\\tint max = 0;\\n\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\tint memo = nums[i];\\n\\t\\tmax = Math.max(max, nums[i]);\\n\\t\\tfor (int j = 1; j < nums.length - i; j++) {\\n\\t\\t\\tmemo = memo + nums[i + j]; // currVal = prevVal + currNum\\n\\t\\t\\tmax = Math.max(max, memo);\\n\\t\\t}\\n\\t}\\n\\treturn max;\\n}\\n```\n```java\\npublic int solution4(int[] nums) {\\n\\tif (nums.length == 0) {\\n\\t\\treturn 0;\\n\\t}\\n\\tint currSum = nums[0];\\n\\tint max = nums[0];\\n\\tfor (int i = 1; i < nums.length; i++) {\\n\\t\\tcurrSum += nums[i];\\n\\t\\tcurrSum = Math.max(nums[i], currSum); // curr value vs curr cumulativee\\n\\t\\tmax = Math.max(max, currSum);\\n\\t}\\n\\treturn max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1428422,
                "title": "javascript-maximum-subarray-written-explanation-code-demo",
                "content": "# Table of Contents:\\n* High level overview of the problem\\n* Translate words to solution\\n* Code demo\\n\\n## **High level overview of the problem:**\\n\\n*Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.*\\n\\n*A subarray is a contiguous part of an array.*\\n\\nFind a combination of the array that has the largest sum. The problem states that is has to be contiguous, which implies that the order of the index cannot be random, it needs to be in order.\\n\\n**There are 2 ways to solve this problem:**\\n1. Brute Force\\n2. Kadane\\'s Algorithm\\n\\n## **Translate words to solution:**\\n\\n**Solution #1 Brute Force:**\\n\\nWe need to iterate over the array with one for loop and we need an additional for loop to scan the elements to the right of it, with this in mind, we can accumulate the combinations of the sub array to achieve the largest sum.\\n\\nThe reason we need to accumulate the combinations is because we need to keep track of the locally optimal max sum sub array while simultaneously comparing it to the global max sum sub array. Also, by accumulating the numbers in the sub array we might run into negative numbers that will decrease the total value of the sum, which is why we need to always compare the local sum to the global sum.\\n\\nAfter going through the entire array with double for loops, you should be able to return the global max sum sub array.\\n\\nTime Complexity: O(n^2)\\nSpace Complexity: O(1)\\n\\n**Solution #2 Kadane\\'s Algorithm:**\\n\\nKadane\\'s algorithm is a combination of the greedy algorithm and dynamic programming. \\n\\nGreedy algorithm:\\nWe keep track of the locally optimal solution while simultaneously comparing it to our global solution.\\n\\nDynamic programming:\\nOnce we solved the sub problem, in this case, the maximum sum of the sub array then we can use memoization to keep track of the solution. By keeping track of our previous solution (local solution), it allows us to solve the problem once and we can build the next solution. These overlapping sub problems plus the greedy algorithm allows us to build the solution piece by piece in O(n) time.\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(n)\\n\\n## **Code demo:**\\n\\n**Solution #1 Brute Force:**\\n\\n```\\nfunction maxSubArray(nums) {\\n  let globalMaxSum = -Infinity;\\n\\n  //  the reason we are looping through the entire nums.length is because a sub array can be the entire length\\n  for (let i = 0; i < nums.length; i++) {\\n\\tlet localMaxSum = 0;\\n\\t// the reason j is to i is because we are scanning all the combinations of the nums[i]\\n\\t// on every iteration of nums[i], localMaxSum will reset and the second for loop (j) will accumulate all the combinations \\n    for (let j = i; j < nums.length; j++) {\\n\\t\\tlocalMaxSum +=  nums[j];\\n\\n\\t\\tif (localMaxSum > globalMaxSum) {\\n\\t\\t\\tglobalMaxSum = localMaxSum;\\n\\t\\t}\\n    }\\n  }\\n\\n  return globalMaxSum;\\n}\\n\\n```\\n\\n**Solution #2 Kadane\\'s Algorithm:**\\n\\n```\\nfunction maxSubArray(nums) {\\n  let globalMaxSum = nums[0];\\n  let localMaxSum = nums[0];\\n\\t\\n  // We start the for loop at index 1 because localMaxSum + globalMaxSum has already been solved!\\n  // Now we can actually take the previous solution and apply it to index 1.\\n  for (let i = 1; i < nums.length; i++) {\\n\\t\\t// We keep track of the previous solution (localMaxSum[i - 1]) and we memoization it by storing it in localMaxSum\\n\\t\\t// As we iterate the array, do we keep nums[i] or do we keep accumlating our memoized solution?\\n\\t\\tlocalMaxSum = Math.max(nums[i], localMaxSum + nums[i]);\\n\\t\\t// Greedy algorithm, compare local solution to the global solution\\n\\t\\tglobalMaxSum = Math.max(localMaxSum, globalMaxSum);\\n  }\\n\\n  return globalMaxSum;\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction maxSubArray(nums) {\\n  let globalMaxSum = -Infinity;\\n\\n  //  the reason we are looping through the entire nums.length is because a sub array can be the entire length\\n  for (let i = 0; i < nums.length; i++) {\\n\\tlet localMaxSum = 0;\\n\\t// the reason j is to i is because we are scanning all the combinations of the nums[i]\\n\\t// on every iteration of nums[i], localMaxSum will reset and the second for loop (j) will accumulate all the combinations \\n    for (let j = i; j < nums.length; j++) {\\n\\t\\tlocalMaxSum +=  nums[j];\\n\\n\\t\\tif (localMaxSum > globalMaxSum) {\\n\\t\\t\\tglobalMaxSum = localMaxSum;\\n\\t\\t}\\n    }\\n  }\\n\\n  return globalMaxSum;\\n}\\n\\n```\n```\\nfunction maxSubArray(nums) {\\n  let globalMaxSum = nums[0];\\n  let localMaxSum = nums[0];\\n\\t\\n  // We start the for loop at index 1 because localMaxSum + globalMaxSum has already been solved!\\n  // Now we can actually take the previous solution and apply it to index 1.\\n  for (let i = 1; i < nums.length; i++) {\\n\\t\\t// We keep track of the previous solution (localMaxSum[i - 1]) and we memoization it by storing it in localMaxSum\\n\\t\\t// As we iterate the array, do we keep nums[i] or do we keep accumlating our memoized solution?\\n\\t\\tlocalMaxSum = Math.max(nums[i], localMaxSum + nums[i]);\\n\\t\\t// Greedy algorithm, compare local solution to the global solution\\n\\t\\tglobalMaxSum = Math.max(localMaxSum, globalMaxSum);\\n  }\\n\\n  return globalMaxSum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1341945,
                "title": "easy-java-solution-100-0-ms",
                "content": "If you like the solution please up vote :)\\n```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        if(nums.length == 1)return nums[0];\\n        int max =   nums[0];\\n        int prev = nums[0];       \\n        for(int i = 1 ; i < nums.length ;i++ ){\\n            if(prev + nums[i]  > nums[i]){\\n                prev =  prev + nums[i];             \\n            }else{\\n                prev = nums[i];                \\n            }\\n             max = Math.max(max , prev);\\n        }        \\n        return max;        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int maxSubArray(int[] nums) {\\n        if(nums.length == 1)return nums[0];\\n        int max =   nums[0];\\n        int prev = nums[0];       \\n        for(int i = 1 ; i < nums.length ;i++ ){\\n            if(prev + nums[i]  > nums[i]){\\n                prev =  prev + nums[i];             \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1280721,
                "title": "c-two-soln-o-n-o-n-2-explained",
                "content": "# KADEN\\'S ALGO\\n```\\n int maxSubArray(vector<int>& nums) {\\n        //Kaden\\'s algorithm\\n        \\n        int n=nums.size();\\n        int sum=0;\\n        int max_sum=INT_MIN; //if all the numbers are negative it works \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=nums[i];        \\n            max_sum=max(sum,max_sum); //taking max at each index\\n            if(sum<0) \\n            {               //if the sum till the present index is less than 0,\\n                            //we will skip all the numers till then\\n                sum=0;\\n            }\\n            \\n        }\\n        return max_sum;\\n\\t\\t}\\n```\\n\\n# BRUTE FORCE\\n```\\nint maxSubArray(vector<int>& nums) {\\n\\tint n=nums.size();\\n        int max_sum=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            int sum=0;\\n            for(int j=i;j<n;j++)\\n            {\\n                sum=sum+nums[j];\\n                max_sum=max(max_sum,sum);\\n                \\n            }\\n        }\\n        return max_sum;\\n\\t}\\n```\\n\\nIf you find any issue in understanding the solutions then comment below, will try to help you.\\nIf you found my solution useful.\\nSo please do upvote and encourage me to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n int maxSubArray(vector<int>& nums) {\\n        //Kaden\\'s algorithm\\n        \\n        int n=nums.size();\\n        int sum=0;\\n        int max_sum=INT_MIN; //if all the numbers are negative it works \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=nums[i];        \\n            max_sum=max(sum,max_sum); //taking max at each index\\n            if(sum<0) \\n            {               //if the sum till the present index is less than 0,\\n                            //we will skip all the numers till then\\n                sum=0;\\n            }\\n            \\n        }\\n        return max_sum;\\n\\t\\t}\\n```\n```\\nint maxSubArray(vector<int>& nums) {\\n\\tint n=nums.size();\\n        int max_sum=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            int sum=0;\\n            for(int j=i;j<n;j++)\\n            {\\n                sum=sum+nums[j];\\n                max_sum=max(max_sum,sum);\\n                \\n            }\\n        }\\n        return max_sum;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1152811,
                "title": "kadane-s-algorithm-javascript",
                "content": "Runtime: 80 ms, faster than 88.41% of JavaScript online submissions for Maximum Subarray.\\nMemory Usage: 39 MB, less than 85.87% of JavaScript online submissions for Maximum Subarray.\\n\\n```\\nvar maxSubArray = function(nums) {\\n    let sum = 0;\\n    let maxSum = -Infinity;\\n    \\n    if(nums.length === 0) return 0;\\n    if(nums.length === 1) return nums[0]\\n    \\n    for(let i = 0;i<nums.length;i++){\\n        sum+=nums[i];\\n        maxSum = Math.max(maxSum,sum);\\n        if(sum < 0) sum = 0;\\n    }\\n    return maxSum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxSubArray = function(nums) {\\n    let sum = 0;\\n    let maxSum = -Infinity;\\n    \\n    if(nums.length === 0) return 0;\\n    if(nums.length === 1) return nums[0]\\n    \\n    for(let i = 0;i<nums.length;i++){\\n        sum+=nums[i];\\n        maxSum = Math.max(maxSum,sum);\\n        if(sum < 0) sum = 0;\\n    }\\n    return maxSum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 20422,
                "title": "python-o-n-simple-kadane-s-algo",
                "content": "https://en.wikipedia.org/wiki/Maximum_subarray_problem\\n\\n    def maxSubArray(nums):\\n        sum = res = nums[0]\\n        for i in range(1,len(nums)):\\n            sum = max(nums[i], sum+nums[i])\\n            res = max(res, sum)\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "https://en.wikipedia.org/wiki/Maximum_subarray_problem\\n\\n    def maxSubArray(nums):\\n        sum = res = nums[0]\\n        for i in range(1,len(nums)):\\n            sum = max(nums[i], sum+nums[i])\\n            res = max(res, sum)\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 20546,
                "title": "explanation-on-applying-the-dynamic-programming-method-for-this-problem",
                "content": "The dynamic programming method to solve this problem relies on the following formulas: \\n\\n    L[i] = max(L[i-1] + A[i], A[i])\\n\\nwhere L[i] stores the maximum sum of continuous subarray starting from the element A[i] towards the end of A[0].\\n\\nNote that, the subarray that has the maximum value does not necessarily need to contain the element A[i]. It is just that L[i] holds the value, so that it can be used by the next iteration. \\n\\nOnce we reach the end of the array with L[i], which is to say that, we obtain the maximum sum of continuous subarray for the entire array. \\n\\n    public int maxSubArray(int[] A) {\\n        \\tif(A.length == 0){\\n        \\t\\treturn 0;\\n        \\t}\\n        \\t\\n        \\tint [] dp = new int[A.length]; \\n            \\n            int max_sum = A[0];\\n            dp[0] = A[0];\\n        \\t\\n            for(int i=1; i<A.length; i++){\\n                dp[i] = Math.max(dp[i-1] + A[i], A[i]);\\n                max_sum = Math.max(dp[i], max_sum);\\n        \\t}\\n            \\n            return max_sum;\\t \\n        }",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "The dynamic programming method to solve this problem relies on the following formulas: \\n\\n    L[i] = max(L[i-1] + A[i], A[i])\\n\\nwhere L[i] stores the maximum sum of continuous subarray starting from the element A[i] towards the end of A[0].\\n\\nNote that, the subarray that has the maximum value does not necessarily need to contain the element A[i]. It is just that L[i] holds the value, so that it can be used by the next iteration. \\n\\nOnce we reach the end of the array with L[i], which is to say that, we obtain the maximum sum of continuous subarray for the entire array. \\n\\n    public int maxSubArray(int[] A) {\\n        \\tif(A.length == 0){\\n        \\t\\treturn 0;\\n        \\t}\\n        \\t\\n        \\tint [] dp = new int[A.length]; \\n            \\n            int max_sum = A[0];\\n            dp[0] = A[0];\\n        \\t\\n            for(int i=1; i<A.length; i++){\\n                dp[i] = Math.max(dp[i-1] + A[i], A[i]);\\n                max_sum = Math.max(dp[i], max_sum);\\n        \\t}\\n            \\n            return max_sum;\\t \\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3401689,
                "title": "very-easy-solution-beats-100-java-o-n-timecomplexity",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int count=0;\\n        int max=nums[0];\\n        for(int i=0;i<nums.length;i++){\\n            count+=nums[i];\\n            if(max<count){\\n                max=count;\\n            }\\n            if(count<0){\\n                count=0;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```\\nUpvote if you Like it \\uD83D\\uDE0A\\n\\u2B07\\uFE0F",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int count=0;\\n        int max=nums[0];\\n        for(int i=0;i<nums.length;i++){\\n            count+=nums[i];\\n            if(max<count){\\n                max=count;\\n            }\\n            if(count<0){\\n                count=0;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3067286,
                "title": "simple-c-vey-short-and-clear-explanation-kadane-s-algo",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSo if there is not any negative number then the whole array wil be answer and keeping this in mind when a negative number comes if our sum is still positive we can include that but if our sum becomes negative then we gonna start out subarry after this . Basically we have to include as many elements as we can but when negative comes in between we have to check if sum is still postive because if sum is negative then they are not good to include ....\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo just keep two variables sum and maxi and check if our sum beomes less than zero then  start form the next elemnt if not then keep adding the elements in the sum and keep upadating our maxi .\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& arr) {\\n        int n=arr.size();\\n        int maxi=arr[0],sum=arr[0];\\n        for(int i=1;i<n;i++){\\n           if(sum<0)sum=arr[i];\\n           else sum+=arr[i];\\n           maxi=max(sum,maxi);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& arr) {\\n        int n=arr.size();\\n        int maxi=arr[0],sum=arr[0];\\n        for(int i=1;i<n;i++){\\n           if(sum<0)sum=arr[i];\\n           else sum+=arr[i];\\n           maxi=max(sum,maxi);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2704505,
                "title": "c-java-python3-javascript-faster-than-95-o-n",
                "content": "### C#,Java,Python3,JavaScript  solution with explanation\\n**\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-53-maximum-subarray-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-53-maximum-subarray-solution-and-explanation-en/)\\u2B50**\\n\\n \\n#### **Example : JavaScript( \\u2B06To see other languages \\u2B06)**\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxSubArray = function(nums) {\\n    var max = nums[0];\\n    var tmp =0;\\n    for(var i = 0;i<nums.length;i++)\\n    {\\n        tmp+=nums[i];\\n        if(tmp>max)\\n        {\\n            max = tmp;\\n        }\\n        if(tmp<0)\\n        {\\n            tmp = 0;\\n        }\\n    }\\n    return max;\\n};\\n```\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know (leave comment or messenger me).\\n\\n**Thanks!**\\n\\nYou can find out other LeetCode problems solution here\\n**\\uD83E\\uDDE1[Zyrastory - Food & Code Research Center](https://zyrastory.com/en/category/coding-en/leetcode-en/)**",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar maxSubArray = function(nums) {\\n    var max = nums[0];\\n    var tmp =0;\\n    for(var i = 0;i<nums.length;i++)\\n    {\\n        tmp+=nums[i];\\n        if(tmp>max)\\n        {\\n            max = tmp;\\n        }\\n        if(tmp<0)\\n        {\\n            tmp = 0;\\n        }\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2693020,
                "title": "c-easy-fast-and-short-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        vector<int> dp(nums.size());\\n        int ans = nums[0];\\n        dp[0]=nums[0];\\n        \\n        for(int i=1;i<nums.size();i++)\\n        {\\n            dp[i]=max(nums[i], nums[i]+dp[i-1]);\\n            ans = max(ans, dp[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**UPVOTE**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        vector<int> dp(nums.size());\\n        int ans = nums[0];\\n        dp[0]=nums[0];\\n        \\n        for(int i=1;i<nums.size();i++)\\n        {\\n            dp[i]=max(nums[i], nums[i]+dp[i-1]);\\n            ans = max(ans, dp[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2625218,
                "title": "python-three-liner",
                "content": "```\\ndef maxSubArray(self, nums):\\n        for i in range(1, len(nums)):\\n            nums[i] = max(nums[i-1] + nums[i], nums[i])\\n        return max(nums)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef maxSubArray(self, nums):\\n        for i in range(1, len(nums)):\\n            nums[i] = max(nums[i-1] + nums[i], nums[i])\\n        return max(nums)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2239330,
                "title": "python-kadane-s-algorithm-time-o-n-space-o-1-explained",
                "content": "# Explaination:\\nThis problem is basically asking us, if we were to check every sum of every single subarray in the input array we were given, what would be the max sum?\\n**Example Input:** [1,2,-2]\\n**Subarrays:**\\n[1] -> Sum = 1\\n[1,2] -> Sum = 3\\n[1,2,-2] -> Sum = 1\\n[2] -> Sum = 2\\n[2,-2] -> Sum = 0\\n[-2] -> Sum = -2\\nThe Max Sum would be 3 from the subarray [1,2]\\n\\nA subarray basically means there are no breaks in-between. \\nSo for the example, that input [1,2,-2]\\nA valid subarray is [1,2] or [1,2,-2]. \\nBut [1,-2] would NOT be a subarray because it skipped 2.\\n\\n**Solution Explaination:**\\nTo solve this problem we break it down into sub problems. Basically we will use Kadane\\'s Algorithm. All we will be doing is, on every iteration we ask ourselves, **\"Do we want to extend the subarray we have seen so far? Or do we want to start a new subarray?\"**\\n\\nTo answer these questions, we look at the sum of the previous subarray and add it to the current number we are on, this will be the sum if we extend the subarray we have seen so far.\\nThen we just compare the sum of the extension to the number we are at currently, if the number we are at currently is bigger than the sum after extending the previous subarray, we start a new subarray. \\n**Lets see an example:** [1,2,-2]\\nLets say we visited 1 already, so our currentSum is 1.\\nNow we are at 2, we ask ourselves, \"should I extend my previous subarray `[1]` with the sum of 1, or should I start a new subarray at `[2]`?\\nIf we extend, the new subarray will be `[1,2]` with a sum of 3\\nIf we don\\'t extend and start a new subarray, the new subarray will be `[2]` with a sum of 2.\\n3 is greater than 2, so we choose to extend our previous subarray.\\n\\nBut now we are at -2.\\nDo we extend our previous subarray or start a new?\\nWell, our previous subarray `[1,2]` has a sum 3, and if we add -2, it becomes 1\\nSo if we start a new subarray it will be `[-2]` with a sum of -2.\\n1 is greater than -2 so we extend our previous subarray.\\n\\nWhat if our input was instead, [1,2,-4, 1]?\\nLets say we reach -3, our previous subarray would be 3 so if we extend we do 3 + -4 which would be -1 and -1 is greater than -4 so we just extend the subarray.\\nBut notice, now we reach 1, the last input in the array.\\n\\nIf we extend we will do -1 + 1 which will be 0.\\nIf we start a new subarray, it will be 1.\\n1 is greater than 0, so we start a new subarray. This is the case we must handle and watch out for because this can change our entire answer.\\n\\n**Solution Breakdown:**\\n1. We create a variable `maxSum` to keep track of the max sum we have seen from all the subarrays.\\n2. We create a variable `curSum` to keep track of the current subarray sum\\n3. Now we just use a `for` loop to iterate through every number in `nums`\\n4. Now we ask ourselves the question on every iteration. **\"Do we want to extend from our previous subarray sum? Or do we want to start a new subarray?**\\n5. `curSum + num` represents the sum we will get if we extend from our previous subarray and `num` just represents the new sum we will have if we start a new subarray. If the sum after extending the previous subarray is smaller than the sum of the current number we are on, we just start a new subarray and save the current number to `curSum`\\n6. If the sum after extending the previous subarray is bigger or equal, then we just add the current number to our previous subarray sum `curSum` to continue extending.\\n7. On every iteration we check if our `curSum` for the subarray we are on is bigger than our previous `maxSum` and if it is, we save it in `maxSum`\\n8. Finally we just return `maxSum`\\n\\n**Time O(N) | Space O(1)**\\nTime is O(N) because we just iterate through the entire array once.\\nSpace is O(1) because we are using scaling memory/space which scales with the input. We only have variables that we are modifiyng. \\n\\n```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        maxSum = nums[0] # Keep track of max sub-array sum\\n        curSum = 0 # Keep track of current sub-array sum\\n        \\n        for num in nums:\\n            if curSum + num < num:\\n                curSum = num # Start a new sub-array\\n            else:\\n                curSum = curSum + num # Extend from our previous sub-array\\n            maxSum = max(maxSum, curSum)\\n        return maxSum\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        maxSum = nums[0] # Keep track of max sub-array sum\\n        curSum = 0 # Keep track of current sub-array sum\\n        \\n        for num in nums:\\n            if curSum + num < num:\\n                curSum = num # Start a new sub-array\\n            else:\\n                curSum = curSum + num # Extend from our previous sub-array\\n            maxSum = max(maxSum, curSum)\\n        return maxSum\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2213371,
                "title": "c-recursive-mmemoized-and-divide-and-conquor-methods-no-kadanes-algo",
                "content": "Method 1- Recursion - TLE( O(n^2) )\\n\\n```\\nclass Solution {\\npublic:\\n    int f(vector<int>& nums,int idx,bool takeit)\\n    {\\n\\t   //took a value and reached the end, now cannot take anything so return 0, else it means you havent taken anything till now, not a valid case\\n        if(idx>=nums.size())\\n        {\\n            return takeit?0:-1e9;\\n        }\\n        //if taken a value previosuly, either return with that value, or take curr value again and recurse\\n        if(takeit)\\n        {\\n            return max(0,nums[idx]+f(nums,idx+1,true));\\n        }\\n        //if not taken any value before, take currvalue and recurse or not take curr value and recurse\\n        return max(nums[idx]+f(nums,idx+1,true) , f(nums,idx+1,false));\\n    }\\n    int maxSubArray(vector<int>& nums) {\\n        return f(nums,0,false);\\n    }\\n};\\n```\\n\\nMethod -2 Memoized Code (O(n))\\n```\\nclass Solution {\\npublic:\\n    int f(vector<vector<int>>&dp,vector<int>& nums,int idx,bool takeit)\\n    {\\n        if(idx>=nums.size())\\n        {\\n            return takeit?0:-1e9;\\n        }\\n        if(dp[idx][takeit]!=-1)\\n        {\\n            return dp[idx][takeit];\\n        }\\n        //if taken a value previosuly, either return with that value, or take curr value again and recurse\\n        if(takeit)\\n        {\\n            return dp[idx][takeit]=max(0,nums[idx]+f(dp,nums,idx+1,true));\\n        }\\n        //if not taken any value before, take currvalue and recurse or not take curr value and recurse\\n        return dp[idx][takeit]=max(nums[idx]+f(dp,nums,idx+1,true) , f(dp,nums,idx+1,false));\\n    }\\n    int maxSubArray(vector<int>& nums) {\\n        vector<vector<int>>dp(nums.size(),vector<int>(2,-1));\\n        return f(dp,nums,0,false);\\n    }\\n};\\n```\\n\\nMethod-3 Divide and Conqour (O(nlogn)\\nat any index i, \\n* Either max subarray sum lies in left half of i \\n* or right half of i\\n* or some part on left of i and some part on right of i including i\\n\\n```\\nclass Solution {\\npublic:\\n    int dc(vector<int>& nums,int l,int r)\\n    {\\n        //invalid case,no elements are there to take in sum\\n        if(l>r)\\n        {\\n            return INT_MIN;\\n        }\\n        int mid=(l+r)/2;\\n        int leftsum=0;\\n        int rightsum=0;\\n        int curr=0;\\n        for(int i=mid-1;i>=l;i--)\\n        {\\n            curr+=nums[i];\\n            leftsum=max(leftsum,curr);\\n        }\\n        curr=0;\\n        for(int i=mid+1;i<=r;i++)\\n        {\\n            curr+=nums[i];\\n            rightsum=max(rightsum,curr);\\n        }\\n        \\n        return max(leftsum+nums[mid]+rightsum ,max(dc(nums,l,mid-1) , dc(nums,mid+1,r)));\\n    }\\n    int maxSubArray(vector<int>& nums) {\\n        int l=0;\\n        int r=nums.size()-1;\\n        return dc(nums,l,r);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Divide and Conquer",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(vector<int>& nums,int idx,bool takeit)\\n    {\\n\\t   //took a value and reached the end, now cannot take anything so return 0, else it means you havent taken anything till now, not a valid case\\n        if(idx>=nums.size())\\n        {\\n            return takeit?0:-1e9;\\n        }\\n        //if taken a value previosuly, either return with that value, or take curr value again and recurse\\n        if(takeit)\\n        {\\n            return max(0,nums[idx]+f(nums,idx+1,true));\\n        }\\n        //if not taken any value before, take currvalue and recurse or not take curr value and recurse\\n        return max(nums[idx]+f(nums,idx+1,true) , f(nums,idx+1,false));\\n    }\\n    int maxSubArray(vector<int>& nums) {\\n        return f(nums,0,false);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int f(vector<vector<int>>&dp,vector<int>& nums,int idx,bool takeit)\\n    {\\n        if(idx>=nums.size())\\n        {\\n            return takeit?0:-1e9;\\n        }\\n        if(dp[idx][takeit]!=-1)\\n        {\\n            return dp[idx][takeit];\\n        }\\n        //if taken a value previosuly, either return with that value, or take curr value again and recurse\\n        if(takeit)\\n        {\\n            return dp[idx][takeit]=max(0,nums[idx]+f(dp,nums,idx+1,true));\\n        }\\n        //if not taken any value before, take currvalue and recurse or not take curr value and recurse\\n        return dp[idx][takeit]=max(nums[idx]+f(dp,nums,idx+1,true) , f(dp,nums,idx+1,false));\\n    }\\n    int maxSubArray(vector<int>& nums) {\\n        vector<vector<int>>dp(nums.size(),vector<int>(2,-1));\\n        return f(dp,nums,0,false);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int dc(vector<int>& nums,int l,int r)\\n    {\\n        //invalid case,no elements are there to take in sum\\n        if(l>r)\\n        {\\n            return INT_MIN;\\n        }\\n        int mid=(l+r)/2;\\n        int leftsum=0;\\n        int rightsum=0;\\n        int curr=0;\\n        for(int i=mid-1;i>=l;i--)\\n        {\\n            curr+=nums[i];\\n            leftsum=max(leftsum,curr);\\n        }\\n        curr=0;\\n        for(int i=mid+1;i<=r;i++)\\n        {\\n            curr+=nums[i];\\n            rightsum=max(rightsum,curr);\\n        }\\n        \\n        return max(leftsum+nums[mid]+rightsum ,max(dc(nums,l,mid-1) , dc(nums,mid+1,r)));\\n    }\\n    int maxSubArray(vector<int>& nums) {\\n        int l=0;\\n        int r=nums.size()-1;\\n        return dc(nums,l,r);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1990093,
                "title": "python-simple-iterative-solution-kadane-s-algorithm",
                "content": "```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        \\n        max_sub = nums[0]\\n        current_sum = 0\\n        \\n        for n in nums:\\n            if current_sum < 0:\\n                current_sum = 0\\n            current_sum += n\\n            \\n            max_sub = max(max_sub, current_sum)\\n        \\n        return max_sub\\n        \\n```\\nTime complexity: O(N)\\nSpace complexity: O(1)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        \\n        max_sub = nums[0]\\n        current_sum = 0\\n        \\n        for n in nums:\\n            if current_sum < 0:\\n                current_sum = 0\\n            current_sum += n\\n            \\n            max_sub = max(max_sub, current_sum)\\n        \\n        return max_sub\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1859798,
                "title": "o-n-solution-start-and-end-index-of-subarray-follow-up",
                "content": "**Motivation:**\\nIt is intuitive to find the maximum subarray sum in linear time (use Kadane\\'s algo or dynamic programming). \\nBut what if we are asked to find the elements in the maximum subarray? (Follow-up question)\\nHow do we find the start and end index of the maximum subarray?\\n\\n**Explanation:**\\nWe need 2 variables to keep track of local (\"current\") subarray start/end index as we traverse the input array.\\nWe also need 2 variables that store the \"global\" start/end index of the maximum subarray. We update the \"global\" start/end index whenever we find a \"better\" subarray with a greater sum.\\n\\n**Code:**\\n```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        if not nums:\\n            return\\n        max_sum = curr_sum = -math.inf\\n        start = end = 0 # init vars\\n        \\n        for i, n in enumerate(nums):\\n            if curr_sum + n < n: \\n                curr_sum = n # don\\'t need previous subarr sum\\n                curr_start = curr_end = i # reset indices \\n            else:\\n                curr_sum += n # need previous subarr\\n                curr_end = i # update right index\\n            if curr_sum > max_sum: # found a subarr with greater sum\\n                max_sum = curr_sum\\n                start, end = curr_start, curr_end # assign indices for later use\\n    \\n        return sum(nums[start:end+1]) # max sum using start/end index\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        if not nums:\\n            return\\n        max_sum = curr_sum = -math.inf\\n        start = end = 0 # init vars\\n        \\n        for i, n in enumerate(nums):\\n            if curr_sum + n < n: \\n                curr_sum = n # don\\'t need previous subarr sum\\n                curr_start = curr_end = i # reset indices \\n            else:\\n                curr_sum += n # need previous subarr\\n                curr_end = i # update right index\\n            if curr_sum > max_sum: # found a subarr with greater sum\\n                max_sum = curr_sum\\n                start, end = curr_start, curr_end # assign indices for later use\\n    \\n        return sum(nums[start:end+1]) # max sum using start/end index\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1849465,
                "title": "divide-and-conquer-approach-with-python",
                "content": "After splitting into two sub arrays, in addition to the max sum in each sub array, we need also consider the case that contains the both left tail and right head element. As in graph shown below:\\n1. (Green): Max sum from left sub array.\\n1. (Orance): Max sum from right sub array.\\n1. (Red): Max sum which must include both left tail (**mid**) and right head (**mid + 1**).\\n![image](https://assets.leetcode.com/users/images/211149ea-8d22-4ca2-81e1-3afab2558f8e_1647277866.9101987.png)\\n\\nThe first two can be obtained by directly calling recursive function. \\nFor the 3rd one, we can start from tail/head and iterate through the entire sub array to get the max sums. Then we can add them together and compare with the two sums from #1 and #2.  \\n\\xB7\\xB7\\xB7\\n\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        def helper_subArray(left, right):\\n            if left == right:\\n                return (nums[left])\\n\\n            # Calculate max sum of left and right sub array\\n            mid = left + (right - left) // 2\\n            left_max = helper_subArray(left, mid)\\n            right_max = helper_subArray(mid + 1, right)\\n\\n            # Calculate max sum which contains both left tail and right head\\n            \\n            # Get left max with the tail of left sub array included\\n            left_cross_max = -2 * (10 ** 4)\\n            left_cross_sum = 0\\n            for i in range(mid, left - 1, -1):\\n                left_cross_sum += nums[i]\\n                left_cross_max = max(left_cross_max, left_cross_sum)\\n            \\n            # Get right max with the head of right sub array included\\n            right_cross_max = nums[mid + 1]\\n            right_cross_sum = 0\\n            for j in range(mid + 1, right + 1):\\n                right_cross_sum += nums[j]\\n                right_cross_max = max(right_cross_max, right_cross_sum)\\n            \\n            # Compare 3 and return grand max\\n            cross_max = left_cross_max + right_cross_max\\n            return max(cross_max, max(left_max, right_max))\\n\\n        return helper_subArray(0, len(nums) - 1)\\n\\n\\xB7\\xB7\\xB7",
                "solutionTags": [
                    "Divide and Conquer"
                ],
                "code": "After splitting into two sub arrays, in addition to the max sum in each sub array, we need also consider the case that contains the both left tail and right head element. As in graph shown below:\\n1. (Green): Max sum from left sub array.\\n1. (Orance): Max sum from right sub array.\\n1. (Red): Max sum which must include both left tail (**mid**) and right head (**mid + 1**).\\n![image](https://assets.leetcode.com/users/images/211149ea-8d22-4ca2-81e1-3afab2558f8e_1647277866.9101987.png)\\n\\nThe first two can be obtained by directly calling recursive function. \\nFor the 3rd one, we can start from tail/head and iterate through the entire sub array to get the max sums. Then we can add them together and compare with the two sums from #1 and #2.  \\n\\xB7\\xB7\\xB7\\n\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        def helper_subArray(left, right):\\n            if left == right:\\n                return (nums[left])\\n\\n            # Calculate max sum of left and right sub array\\n            mid = left + (right - left) // 2\\n            left_max = helper_subArray(left, mid)\\n            right_max = helper_subArray(mid + 1, right)\\n\\n            # Calculate max sum which contains both left tail and right head\\n            \\n            # Get left max with the tail of left sub array included\\n            left_cross_max = -2 * (10 ** 4)\\n            left_cross_sum = 0\\n            for i in range(mid, left - 1, -1):\\n                left_cross_sum += nums[i]\\n                left_cross_max = max(left_cross_max, left_cross_sum)\\n            \\n            # Get right max with the head of right sub array included\\n            right_cross_max = nums[mid + 1]\\n            right_cross_sum = 0\\n            for j in range(mid + 1, right + 1):\\n                right_cross_sum += nums[j]\\n                right_cross_max = max(right_cross_max, right_cross_sum)\\n            \\n            # Compare 3 and return grand max\\n            cross_max = left_cross_max + right_cross_max\\n            return max(cross_max, max(left_max, right_max))\\n\\n        return helper_subArray(0, len(nums) - 1)\\n\\n\\xB7\\xB7\\xB7",
                "codeTag": "Python3"
            },
            {
                "id": 1661797,
                "title": "1ms-100-faster-java-solution-super-easy-to-understand",
                "content": "Here we have taken two counters, basically int tillNow check the **MAX** between **tillNow+nums[i] and nums[i].**\\n*(nums[i] is nothing but the next index\\'s value.)*\\nAnd on the other hand, int soFar checks which one is **MAX** between **soFar and tillNow.**\\n\\nThis way we are taking time to decide what if we add the next index\\'s value, will it be smaller than the next element? if not then it\\'ll **continue adding**.\\n\\n```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int soFar = nums[0], tillNow = nums[0], i=1;\\n        while(i<nums.length) {\\n            tillNow = Math.max(tillNow+nums[i], nums[i]);\\n            soFar = Math.max(soFar, tillNow);\\n            i++;\\n        }\\n        return soFar;\\n    }\\n}\\n```\\n\\n\\n**Why we are not using for loop?**\\nAns: While loop took 1ms & 49.8 MB whereas for loop took >=2 ms & 90MB.\\n\\t\\tThere\\'s no issue with for loop. It\\'s upto the programmer.\\n\\n**An Upvote will be appreciated!\\nThank You!**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int soFar = nums[0], tillNow = nums[0], i=1;\\n        while(i<nums.length) {\\n            tillNow = Math.max(tillNow+nums[i], nums[i]);\\n            soFar = Math.max(soFar, tillNow);\\n            i++;\\n        }\\n        return soFar;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1523778,
                "title": "java-optimised-solution",
                "content": "```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum = 0;\\n        int max = Integer.MIN_VALUE;\\n        for(int i : nums){\\n            sum += i;\\n            max = Math.max(max, sum);\\n            sum = sum < 0  ? 0 : sum;\\n        }\\n        return max;\\n    }\\n}\\n```\\n\\nTime Complexity : O(n)\\nSpace Complexity : O(1)\\n\\n***Please upvote if you like the solution***",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum = 0;\\n        int max = Integer.MIN_VALUE;\\n        for(int i : nums){\\n            sum += i;\\n            max = Math.max(max, sum);\\n            sum = sum < 0  ? 0 : sum;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1454327,
                "title": "easy-c-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n);\\n        dp[0] = nums[0];\\n        for(int i=1; i<n; i++){\\n            dp[i] =max(0, dp[i-1]) + nums[i];\\n        }\\n        return *max_element(dp.begin(), dp.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> dp(n);\\n        dp[0] = nums[0];\\n        for(int i=1; i<n; i++){\\n            dp[i] =max(0, dp[i-1]) + nums[i];\\n        }\\n        return *max_element(dp.begin(), dp.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1077530,
                "title": "four-line-solution-mja-aa-jayega",
                "content": "class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {  \\n     for(int i=1;i<nums.size();i++)\\n     {nums[i]=max(nums[i],nums[i]+nums[i-1]);\\n      nums[0]=max(nums[0],nums[i]);}\\n     return nums[0];   \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {  \\n     for(int i=1;i<nums.size();i++)\\n     {nums[i]=max(nums[i],nums[i]+nums[i-1]);\\n      nums[0]=max(nums[0],nums[i]);}",
                "codeTag": "Java"
            },
            {
                "id": 745456,
                "title": "python-sliding-window-in-o-n",
                "content": "The idea is similar to the sliding window approach.\\n\\n```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        \\n        max_sum = float(\\'-inf\\')\\n        curr_sum = 0\\n        for num in nums:\\n            # compute sum for previous subarray\\n            curr_sum += num\\n            \\n            # if current sum <= the current number,\\n            # no need to include previous subarray\\n            if curr_sum <= num:\\n                curr_sum = num\\n                \\n            max_sum = max(max_sum, curr_sum)  \\n        return max_sum\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        \\n        max_sum = float(\\'-inf\\')\\n        curr_sum = 0\\n        for num in nums:\\n            # compute sum for previous subarray\\n            curr_sum += num\\n            \\n            # if current sum <= the current number,\\n            # no need to include previous subarray\\n            if curr_sum <= num:\\n                curr_sum = num\\n                \\n            max_sum = max(max_sum, curr_sum)  \\n        return max_sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2194598,
                "title": "python-kadane-s-algorithm-self-explanatory-code",
                "content": "```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        currsum, overallsum = nums[0], nums[0]\\n        if len(nums)==1: return nums[0]\\n        for i in range (1,len(nums)):\\n            if currsum>=0: currsum+=nums[i]\\n            else: currsum=nums[i]\\n            if currsum>overallsum: overallsum=currsum\\n        return overallsum\\n```\\n***Pls upvote if you find it helpful***",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        currsum, overallsum = nums[0], nums[0]\\n        if len(nums)==1: return nums[0]\\n        for i in range (1,len(nums)):\\n            if currsum>=0: currsum+=nums[i]\\n            else: currsum=nums[i]\\n            if currsum>overallsum: overallsum=currsum\\n        return overallsum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2047442,
                "title": "java-simple-runtime-1ms-100",
                "content": "```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int max = nums[0];\\n        int sec = 0;\\n        for (int num : nums) {\\n            sec += num;\\n            if (max < sec) max = sec;\\n            if (sec < 0)  sec = 0;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int max = nums[0];\\n        int sec = 0;\\n        for (int num : nums) {\\n            sec += num;\\n            if (max < sec) max = sec;\\n            if (sec < 0)  sec = 0;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2029740,
                "title": "python-easy-solution-with-comments",
                "content": "```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        # init max sum, curr sum to the first element\\n        curr_sum, max_sum = nums[0], nums[0]\\n        \\n        # iterate nums\\n        for num in nums[1:]:\\n            # for each num, we have 2 options:\\n            # we can choose to add it to the cumulative sum,\\n            # or start a new cumulative sum from the current num\\n            \\n            # if the current number is greater than current sum + current number, we\\'ll reset the sum to curr number\\n            if num > num + curr_sum:\\n                curr_sum = num\\n            else:\\n                curr_sum += num\\n            \\n            # we\\'ll update the max sum each time\\n            max_sum = max(curr_sum, max_sum)\\n        \\n        return max_sum\\n            \\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        # init max sum, curr sum to the first element\\n        curr_sum, max_sum = nums[0], nums[0]\\n        \\n        # iterate nums\\n        for num in nums[1:]:\\n            # for each num, we have 2 options:\\n            # we can choose to add it to the cumulative sum,\\n            # or start a new cumulative sum from the current num\\n            \\n            # if the current number is greater than current sum + current number, we\\'ll reset the sum to curr number\\n            if num > num + curr_sum:\\n                curr_sum = num\\n            else:\\n                curr_sum += num\\n            \\n            # we\\'ll update the max sum each time\\n            max_sum = max(curr_sum, max_sum)\\n        \\n        return max_sum\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1850628,
                "title": "simplest-java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int currentSum = 0;\\n        int maxSum = Integer.MIN_VALUE;\\n        \\n        for(int i=0;i<nums.length;i++) {\\n            currentSum += nums[i];\\n            if(currentSum > maxSum) {\\n                maxSum = currentSum;\\n            }\\n            if(currentSum < 0) {\\n                currentSum = 0;\\n            }\\n        }\\n        return maxSum;\\n    }\\n}\\n```\\n**Like the solution?\\nPlease upvote \\u30C4**\\n\\nIf you can\\'t understand any step/point, feel free to comment.\\nHappy to help.",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int currentSum = 0;\\n        int maxSum = Integer.MIN_VALUE;\\n        \\n        for(int i=0;i<nums.length;i++) {\\n            currentSum += nums[i];\\n            if(currentSum > maxSum) {\\n                maxSum = currentSum;\\n            }\\n            if(currentSum < 0) {\\n                currentSum = 0;\\n            }\\n        }\\n        return maxSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749512,
                "title": "simple-python-solution",
                "content": "\\n```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        for i in range(1,len(nums)):\\n            nums[i] = max(nums[i]+nums[i-1],nums[i])\\n        return max(nums)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        for i in range(1,len(nums)):\\n            nums[i] = max(nums[i]+nums[i-1],nums[i])\\n        return max(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1611064,
                "title": "java-divide-and-conquer-solution",
                "content": "**Note**: Kadane\\'s algorithm is better because it has linear complexity. \\nThis post is limited to divide and conquer solution, more generic approach.\\n\\nIn divide and conquer we divide array in half and solve both halves recursively.\\n\\n**There are 3 cases:**\\n1. best subarray sum is on the left\\n1. best subarray sum is on the right\\n1. best subarray sum is crossing the middle element\\n\\nWe solve 1. and 2. recursively\\nFor 3. we go over array from the middle to both sides keeping track of best sum for left and right side\\n\\n**Pseudocode**\\n```\\nmaxSubarray(A, lo, hi) {\\n\\tif lo == hi return A[lo]\\n\\tmid = (lo + hi) / 2\\n\\tL = maxSubarray(A, lo, mid - 1)\\n\\tR = maxSubarray(A, mid + 1, hi)\\n\\tC = maxCrossingSubarray(A, lo, mid, hi)\\n\\treturn max(L, R, C)\\n}\\n```\\n\\n**Java**\\n```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        return solve(nums, 0, nums.length - 1);\\n    }\\n    \\n    int solve(int[] nums, int lo, int hi) {\\n        if(lo >= hi) {\\n            return nums[lo];\\n        }\\n        int mid = lo + (hi - lo) / 2;\\n        int L = solve(nums, lo, mid - 1);\\n        int R = solve(nums, mid + 1, hi);\\n        int C = cross(nums, lo, mid, hi);\\n        return Math.max(L, Math.max(R, C));\\n    }\\n    \\n    int cross(int[] nums, int lo, int mid, int hi) {\\n        int left = 0, maxLeft = 0;\\n        int right = 0, maxRight = 0;\\n        for(int i = mid - 1; i >= lo; i--) {\\n            left += nums[i];\\n            maxLeft = Math.max(left, maxLeft);\\n        }\\n        for(int i = mid + 1; i <= hi; i++) {\\n            right += nums[i];\\n            maxRight = Math.max(right, maxRight);\\n        }\\n        return maxLeft + maxRight + nums[mid];\\n    }\\n}\\n```\\n\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        return rec(nums, 0, nums.size());\\n    }\\n\\n    int rec(vector<int>& nums, int lo, int hi) {\\n        if(lo >= hi) {\\n            return -1e9;\\n        }\\n        int mid = lo + (hi - lo) / 2;\\n        int L = rec(nums, lo, mid);\\n        int R = rec(nums, mid + 1, hi);\\n        int Cross = cross(nums, lo, mid, hi);\\n        return max({L, R, Cross});\\n    }\\n\\n    int cross(vector<int>& nums, int lo, int mid, int hi) {        \\n        int left = 0, curr = 0;\\n        for(int i = mid - 1; i >= lo; i--) {\\n            curr += nums[i];\\n            left = max(left, curr);\\n        }\\n        curr = 0;\\n        int right = 0;\\n        for(int i = mid + 1; i < hi; i++) {\\n            curr += nums[i];\\n            right = max(right, curr);\\n        }\\n        return left + nums[mid] + right;        \\n    }\\n};\\n```\\n\\n**Time complexity:** O(n * log(n))",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Divide and Conquer"
                ],
                "code": "```\\nmaxSubarray(A, lo, hi) {\\n\\tif lo == hi return A[lo]\\n\\tmid = (lo + hi) / 2\\n\\tL = maxSubarray(A, lo, mid - 1)\\n\\tR = maxSubarray(A, mid + 1, hi)\\n\\tC = maxCrossingSubarray(A, lo, mid, hi)\\n\\treturn max(L, R, C)\\n}\\n```\n```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        return solve(nums, 0, nums.length - 1);\\n    }\\n    \\n    int solve(int[] nums, int lo, int hi) {\\n        if(lo >= hi) {\\n            return nums[lo];\\n        }\\n        int mid = lo + (hi - lo) / 2;\\n        int L = solve(nums, lo, mid - 1);\\n        int R = solve(nums, mid + 1, hi);\\n        int C = cross(nums, lo, mid, hi);\\n        return Math.max(L, Math.max(R, C));\\n    }\\n    \\n    int cross(int[] nums, int lo, int mid, int hi) {\\n        int left = 0, maxLeft = 0;\\n        int right = 0, maxRight = 0;\\n        for(int i = mid - 1; i >= lo; i--) {\\n            left += nums[i];\\n            maxLeft = Math.max(left, maxLeft);\\n        }\\n        for(int i = mid + 1; i <= hi; i++) {\\n            right += nums[i];\\n            maxRight = Math.max(right, maxRight);\\n        }\\n        return maxLeft + maxRight + nums[mid];\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        return rec(nums, 0, nums.size());\\n    }\\n\\n    int rec(vector<int>& nums, int lo, int hi) {\\n        if(lo >= hi) {\\n            return -1e9;\\n        }\\n        int mid = lo + (hi - lo) / 2;\\n        int L = rec(nums, lo, mid);\\n        int R = rec(nums, mid + 1, hi);\\n        int Cross = cross(nums, lo, mid, hi);\\n        return max({L, R, Cross});\\n    }\\n\\n    int cross(vector<int>& nums, int lo, int mid, int hi) {        \\n        int left = 0, curr = 0;\\n        for(int i = mid - 1; i >= lo; i--) {\\n            curr += nums[i];\\n            left = max(left, curr);\\n        }\\n        curr = 0;\\n        int right = 0;\\n        for(int i = mid + 1; i < hi; i++) {\\n            curr += nums[i];\\n            right = max(right, curr);\\n        }\\n        return left + nums[mid] + right;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1594944,
                "title": "c-simple-and-clean-one-pass-solution-brief-explanation",
                "content": "**Idea:**\\nWe iterate through the array, while summing it.\\nEach time, we check what\\'s worth more: the running sum or only the current element.\\nWhich means, that if the running sum went below zero and the current number is positive, we will want to try starting our subarray from here.\\nIn `max_sum` we keep the maximum subarray so far.\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:** O(1)\\n```\\nclass Solution {\\npublic:  \\n    int maxSubArray(vector<int>& nums) {\\n        int max_sum = nums[0], sum = nums[0];\\n        for (int i = 1; i < nums.size(); i++) {\\n            sum = max(sum + nums[i], nums[i]);\\n            max_sum = max(max_sum, sum);\\n        }\\n        return max_sum;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:  \\n    int maxSubArray(vector<int>& nums) {\\n        int max_sum = nums[0], sum = nums[0];\\n        for (int i = 1; i < nums.size(); i++) {\\n            sum = max(sum + nums[i], nums[i]);\\n            max_sum = max(max_sum, sum);\\n        }\\n        return max_sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1485418,
                "title": "python-kadane-s-algorithm-time-o-n-space-o-1",
                "content": "```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        current, result = nums[0], nums[0]\\n        for i in range(1, len(nums)):\\n            current = max(current + nums[i], nums[i] )\\n            result = max(current, result)\\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        current, result = nums[0], nums[0]\\n        for i in range(1, len(nums)):\\n            current = max(current + nums[i], nums[i] )\\n            result = max(current, result)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1304544,
                "title": "go-easy-o-1-space",
                "content": "Do upvote if it helps! :)\\n```\\nfunc max(a int, b int) int{\\n    if a>b{\\n        return a\\n    }\\n    return b\\n}\\nfunc maxSubArray(nums []int) int {\\n    running_sum:=nums[0]\\n    sum:=nums[0]\\n    for i:=1;i<len(nums);i++{\\n        running_sum=max(running_sum+nums[i],nums[i])\\n        if(running_sum>sum){\\n            sum=running_sum\\n        }\\n        if(running_sum<0){\\n            running_sum=0\\n        }\\n    }\\n    return sum\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc max(a int, b int) int{\\n    if a>b{\\n        return a\\n    }\\n    return b\\n}\\nfunc maxSubArray(nums []int) int {\\n    running_sum:=nums[0]\\n    sum:=nums[0]\\n    for i:=1;i<len(nums);i++{\\n        running_sum=max(running_sum+nums[i],nums[i])\\n        if(running_sum>sum){\\n            sum=running_sum\\n        }\\n        if(running_sum<0){\\n            running_sum=0\\n        }\\n    }\\n    return sum\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1243564,
                "title": "c-3-interview-approaches",
                "content": "```\\n//Approach-1 (Time : O(n^2))\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int n   = nums.size();\\n        for(int i = 1; i<n; i++) {\\n            nums[i] += nums[i-1];\\n        }\\n        int maxS = INT_MIN;\\n        \\n        for(int i = 0; i<n; i++) {\\n            for(int j = i; j<n; j++) {\\n                int end   =  nums[j];\\n                int start =  i > 0 ? nums[i-1] : 0;\\n                maxS = max(maxS, end-start);\\n            }\\n        }\\n        \\n        return maxS;\\n    }\\n};\\n```\\n\\n```\\n//Approach-2 (Time : O(nlogn))\\nclass Solution {\\npublic:\\n    int divideConquer(vector<int>& nums, int l, int r) {\\n        if(l > r) {\\n            return INT_MIN;\\n        }\\n        \\n        int mid   = l + (r-l)/2;\\n        int Lsum  = divideConquer(nums, l, mid-1);\\n        int Rsum  = divideConquer(nums, mid+1, r);\\n        \\n        int leftSum  = 0;\\n        int rightSum = 0;\\n        int tempSum  =  0 ;\\n        for(int i = mid-1; i >= l; i--) {\\n            tempSum += nums[i];\\n            leftSum = max(leftSum, tempSum);\\n        }\\n        \\n        tempSum = 0;\\n        for(int i = mid+1; i <= r; i++) {\\n            tempSum += nums[i];\\n            rightSum = max(rightSum, tempSum);\\n        }\\n        \\n        return max({Lsum, Rsum, leftSum + rightSum + nums[mid]});\\n    }\\n    int maxSubArray(vector<int>& nums) {\\n        int n   = nums.size();\\n        \\n        return divideConquer(nums, 0, n-1);\\n    }\\n};\\n```\\n\\n```\\n//Approach-3 (Time : O(n)) Kadane\\'s Algorithm\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int n       = nums.size();\\n        int sum     = nums[0];\\n        int maxSum  = nums[0];\\n        \\n        for(int i = 1; i<n; i++) {\\n            sum     = max(sum + nums[i], nums[i]);\\n            maxSum  = max(maxSum, sum);\\n        }\\n        \\n        return maxSum;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (Time : O(n^2))\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int n   = nums.size();\\n        for(int i = 1; i<n; i++) {\\n            nums[i] += nums[i-1];\\n        }\\n        int maxS = INT_MIN;\\n        \\n        for(int i = 0; i<n; i++) {\\n            for(int j = i; j<n; j++) {\\n                int end   =  nums[j];\\n                int start =  i > 0 ? nums[i-1] : 0;\\n                maxS = max(maxS, end-start);\\n            }\\n        }\\n        \\n        return maxS;\\n    }\\n};\\n```\n```\\n//Approach-2 (Time : O(nlogn))\\nclass Solution {\\npublic:\\n    int divideConquer(vector<int>& nums, int l, int r) {\\n        if(l > r) {\\n            return INT_MIN;\\n        }\\n        \\n        int mid   = l + (r-l)/2;\\n        int Lsum  = divideConquer(nums, l, mid-1);\\n        int Rsum  = divideConquer(nums, mid+1, r);\\n        \\n        int leftSum  = 0;\\n        int rightSum = 0;\\n        int tempSum  =  0 ;\\n        for(int i = mid-1; i >= l; i--) {\\n            tempSum += nums[i];\\n            leftSum = max(leftSum, tempSum);\\n        }\\n        \\n        tempSum = 0;\\n        for(int i = mid+1; i <= r; i++) {\\n            tempSum += nums[i];\\n            rightSum = max(rightSum, tempSum);\\n        }\\n        \\n        return max({Lsum, Rsum, leftSum + rightSum + nums[mid]});\\n    }\\n    int maxSubArray(vector<int>& nums) {\\n        int n   = nums.size();\\n        \\n        return divideConquer(nums, 0, n-1);\\n    }\\n};\\n```\n```\\n//Approach-3 (Time : O(n)) Kadane\\'s Algorithm\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int n       = nums.size();\\n        int sum     = nums[0];\\n        int maxSum  = nums[0];\\n        \\n        for(int i = 1; i<n; i++) {\\n            sum     = max(sum + nums[i], nums[i]);\\n            maxSum  = max(maxSum, sum);\\n        }\\n        \\n        return maxSum;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1234480,
                "title": "python-o-n-logn-divide-conquer-o-n-using-kadane-s-algorithm",
                "content": "**Following is the O(n) solution using the Kadane\\'s Algorithm**\\n```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        add = 0                                     # A variable to store the sum of the elements\\n        ans = 0                                     # A variable to store the last positive sum value\\n        cnt = 0                                     # A variable to store the count of negative numbers in the list\\n        \\n        maxNegative = -math.inf                     # A variable to store the max negative value in the list, initial value of -infinity\\n        \\n        for i in nums:                              # Traverse all the elements in the list\\n            if i < 0:                               # If the ith element is negative\\n                cnt += 1                            # Then, increase the count value of negative elements in the list\\n                maxNegative = max(i, maxNegative)   # And update the value of \\'maxNegative\\'\\n                \\n            if add + i > 0:                         # If the summed value of \\'add\\' & the ith element is greater than 0\\n                add += i                            # Then, add the ith element with \\'add\\' & and store it to \\'add\\'\\n                \\n            else:                                   # Else if the summed value is negative\\n                add = 0                             # Then, reset the value of \\'add\\'\\n                \\n            ans = max(add, ans)                     # Update the value of \\'ans\\' with the max of \\'add\\' & \\'ans\\'\\n        \\n        # Check if all the values in the list are negative or not, if yes then return \\'maxNegative\\', else return \\'ans\\'\\n        return maxNegative if cnt==len(nums) else ans\\n\\n```\\n\\n**Following is the O(n.logn) solution using Divide & Conquer with Recursion**\\n```\\ndef maxSumSubarray(nums, low, high):\\n    if low == high:                                      # The base case, if the array has a single element,\\n        return nums[0]                                   # Then return it as the sub-array sum value\\n    \\n    mid = (low+high)//2                                  # Else, get the mid index\\n    leftMaxSubarray = maxSumSubarray(nums, low, mid)     # And, recall the \\'maxSumSubarray\\' fuction for the left subarray and store the max sum from that part in \\'leftMaxSubarray\\'\\n    rightMaxSubarray = maxSumSubarray(nums, mid+1, high) # And, recall the \\'maxSumSubarray\\' fuction for the right subarray and store the max sum from that part in \\'rightMaxSubarray\\'\\n    \\n                                                         # Now, get only the left half\\'s and right half\\'s sum and store\\n    leftSum = -math.inf                                  # To store the sum of the left half, initial value of negative infinity \\n    rightSum = -math.inf                                 # To store the sum of the right half, initial value of negative infinity \\n    \\n    add = 0                                              # To store the sum of the right sub-arrays, initialize with 0\\n\\n    i = mid                                              # First, the right sub-array, starting from the \\'mid\\' index\\n    while i < high:                                      # Traverse till the last index\\n        add += nums[i]                                   # Add each element to the \\'add\\' variable \\n        rightSum = max(add, rightSum)                    # Update the value of \\'rightSum\\' by taking the max between \\'add\\' & \\'rightSum\\'\\n        i += 1                                           # Move \\'i\\' to the next index\\n    \\n    add = 0                                              # To store the sum of the left sub-arrays, initialize with 0\\n    \\n    i = 0                                                # Then, the left sub-array, starting from the 1st index\\n    while i < mid:                                       # Traverse till the \\'mid\\' index\\n        add += nums[i]                                   # Add each element to the \\'add\\' variable \\n        leftSum = max(add, leftSum)                      # Update the value of \\'leftSum\\' by taking the max between \\'add\\' & \\'leftSum\\'\\n        i += 1                                           # Move \\'i\\' to the next index\\n        \\n    ans = max(leftMaxSubarray, rightMaxSubarray)         # Store the max of the max values of the left and right sub-arrays to \\'ans\\'\\n    return max(ans, leftSum+rightSum)                    # Return the max between \\'ans\\' and the sum of \\'leftSum\\' & \\'rightSum\\'\\n    \\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        return maxSumSubarray(nums, 0, len(nums))        # Return the value returned from the \\'maxSumSubarray\\' function\\n\\t\\t\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        add = 0                                     # A variable to store the sum of the elements\\n        ans = 0                                     # A variable to store the last positive sum value\\n        cnt = 0                                     # A variable to store the count of negative numbers in the list\\n        \\n        maxNegative = -math.inf                     # A variable to store the max negative value in the list, initial value of -infinity\\n        \\n        for i in nums:                              # Traverse all the elements in the list\\n            if i < 0:                               # If the ith element is negative\\n                cnt += 1                            # Then, increase the count value of negative elements in the list\\n                maxNegative = max(i, maxNegative)   # And update the value of \\'maxNegative\\'\\n                \\n            if add + i > 0:                         # If the summed value of \\'add\\' & the ith element is greater than 0\\n                add += i                            # Then, add the ith element with \\'add\\' & and store it to \\'add\\'\\n                \\n            else:                                   # Else if the summed value is negative\\n                add = 0                             # Then, reset the value of \\'add\\'\\n                \\n            ans = max(add, ans)                     # Update the value of \\'ans\\' with the max of \\'add\\' & \\'ans\\'\\n        \\n        # Check if all the values in the list are negative or not, if yes then return \\'maxNegative\\', else return \\'ans\\'\\n        return maxNegative if cnt==len(nums) else ans\\n\\n```\n```\\ndef maxSumSubarray(nums, low, high):\\n    if low == high:                                      # The base case, if the array has a single element,\\n        return nums[0]                                   # Then return it as the sub-array sum value\\n    \\n    mid = (low+high)//2                                  # Else, get the mid index\\n    leftMaxSubarray = maxSumSubarray(nums, low, mid)     # And, recall the \\'maxSumSubarray\\' fuction for the left subarray and store the max sum from that part in \\'leftMaxSubarray\\'\\n    rightMaxSubarray = maxSumSubarray(nums, mid+1, high) # And, recall the \\'maxSumSubarray\\' fuction for the right subarray and store the max sum from that part in \\'rightMaxSubarray\\'\\n    \\n                                                         # Now, get only the left half\\'s and right half\\'s sum and store\\n    leftSum = -math.inf                                  # To store the sum of the left half, initial value of negative infinity \\n    rightSum = -math.inf                                 # To store the sum of the right half, initial value of negative infinity \\n    \\n    add = 0                                              # To store the sum of the right sub-arrays, initialize with 0\\n\\n    i = mid                                              # First, the right sub-array, starting from the \\'mid\\' index\\n    while i < high:                                      # Traverse till the last index\\n        add += nums[i]                                   # Add each element to the \\'add\\' variable \\n        rightSum = max(add, rightSum)                    # Update the value of \\'rightSum\\' by taking the max between \\'add\\' & \\'rightSum\\'\\n        i += 1                                           # Move \\'i\\' to the next index\\n    \\n    add = 0                                              # To store the sum of the left sub-arrays, initialize with 0\\n    \\n    i = 0                                                # Then, the left sub-array, starting from the 1st index\\n    while i < mid:                                       # Traverse till the \\'mid\\' index\\n        add += nums[i]                                   # Add each element to the \\'add\\' variable \\n        leftSum = max(add, leftSum)                      # Update the value of \\'leftSum\\' by taking the max between \\'add\\' & \\'leftSum\\'\\n        i += 1                                           # Move \\'i\\' to the next index\\n        \\n    ans = max(leftMaxSubarray, rightMaxSubarray)         # Store the max of the max values of the left and right sub-arrays to \\'ans\\'\\n    return max(ans, leftSum+rightSum)                    # Return the max between \\'ans\\' and the sum of \\'leftSum\\' & \\'rightSum\\'\\n    \\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        return maxSumSubarray(nums, 0, len(nums))        # Return the value returned from the \\'maxSumSubarray\\' function\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794989,
                "title": "kadane-s-algorithm-o-n-js-solution",
                "content": "```\\n// Kadane\\'s Algorithm\\nvar maxSubArray = function(nums) {\\n\\tif (!nums.length) return 0;\\n    let subArrSum = nums[0], maxSum = nums[0];\\n    for(let i = 1; i < nums.length; i++){\\n        subArrSum = Math.max(nums[i], subArrSum + nums[i])\\n        maxSum = Math.max(maxSum, subArrSum);\\n    }\\n    return maxSum;\\n    \\n    /*\\n    1. Initialise two variables, subArrSum and maxSum, both to the first element of input , because the first element is the only subarray sum and maximum sum we can have at this point.\\n    2. Loop over the array from second element and compare the element with the subarray sum + the element. So, we are basically deciding whether to include this element in our subarray sum we have had so far or start a new subarray sum from this element. We choose the greater one since we want to maximise our sum.\\n    3. For every iteration, we update our return variable to store the maximum subarry sum.\\n    4. Return the return varianle.\\n    \\n    Time Complexity: O(n)\\n    Space Complexity: O(1)\\n    */\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// Kadane\\'s Algorithm\\nvar maxSubArray = function(nums) {\\n\\tif (!nums.length) return 0;\\n    let subArrSum = nums[0], maxSum = nums[0];\\n    for(let i = 1; i < nums.length; i++){\\n        subArrSum = Math.max(nums[i], subArrSum + nums[i])\\n        maxSum = Math.max(maxSum, subArrSum);\\n    }\\n    return maxSum;\\n    \\n    /*\\n    1. Initialise two variables, subArrSum and maxSum, both to the first element of input , because the first element is the only subarray sum and maximum sum we can have at this point.\\n    2. Loop over the array from second element and compare the element with the subarray sum + the element. So, we are basically deciding whether to include this element in our subarray sum we have had so far or start a new subarray sum from this element. We choose the greater one since we want to maximise our sum.\\n    3. For every iteration, we update our return variable to store the maximum subarry sum.\\n    4. Return the return varianle.\\n    \\n    Time Complexity: O(n)\\n    Space Complexity: O(1)\\n    */\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 608209,
                "title": "4-approaches-o-n-3-o-n-2-o-nlogn-o-n-interview-java",
                "content": "**/*\\n*   There are almost 4 methods to do this problem with varying Time Complexity\\n* 1) Brute force by making 2 nested loops for picking all subarrays and third nested loop for calculating sum from i-->j    TC O(N^3)\\n* 2) Better Approch is to Maintain a prefix sum from index i->j and use only outer two loops for calculting sum   TC O(N^2)\\n* 3) Using Divide and Conquer based approach with Recurence similer to merge sort Algorithm  TC O(NlogN)\\n* 4) Using Some Sliding window based approach or better known as Kadanes Algorithm TC  O(N)\\n*\\n*/**\\n\\n```\\n // Approach 1   TC=O(N^3)       SC=O(1)\\n    public int maxSubArray(final int[] nums) {\\n              if(nums==null || nums.length==0)return 0;\\n              int max=Integer.MIN_VALUE;\\n              int sum=0;\\n              for(int i=0;i<nums.length;i++){\\n                   for(int j=i;j< nums.length;j++){\\n                       //Compute sum b/w i-->j\\n                       sum=0;\\n                       for(int k=i;k<=j;k++){\\n                           sum+=nums[k];\\n                       }\\n                       if(max<sum)\\n                           max=sum;\\n                   }\\n               }\\n              return max;\\n    }\\n```\\n\\n```\\n// Approach 2   TC=O(N^2)       SC=O(N)\\n    public int maxSubArray(final int[] nums) {\\n        if(nums==null || nums.length==0)return 0;// Invalid\\n        int max=Integer.MIN_VALUE;\\n        int[] prefix=new int[nums.length+1];\\n        // Generate the prefix sum\\n        for(int i=0;i<nums.length;i++){\\n            prefix[i+1]=prefix[i] + nums[i];\\n        }\\n\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i;j< nums.length;j++){\\n                sum=prefix[j+1] - prefix[i];\\n                if(max<sum)\\n                    max=sum;\\n            }\\n        }\\n          return max;\\n    }\\n```\\n\\n```\\n\\n        // Approach 3   TC=O(NlogN)       SC=O(N)           // Quite Similer to merge sort\\n        private int Conquer(final int[] arr,int low,int mid,int high){\\n\\n                    int left_contagious_sum=Integer.MIN_VALUE;\\n                    int right_contagious_sum=Integer.MIN_VALUE;\\n\\n                    // Moving to left side from mid included to low included\\n                    int temp_left_sum=0;\\n                    for(int i=mid;i>=low;i--){\\n                        temp_left_sum+=arr[i];\\n                        if(left_contagious_sum<temp_left_sum)\\n                            left_contagious_sum=temp_left_sum;\\n                    }\\n\\n                    // Moving to right side from mid excluded to high included\\n                    int temp_right_sum=0;\\n                    for(int i=mid+1;i<=high;i++){\\n                        temp_right_sum+=arr[i];\\n                        if(right_contagious_sum<temp_right_sum)\\n                            right_contagious_sum=temp_right_sum;\\n                    }\\n\\n                    return left_contagious_sum+right_contagious_sum;\\n        }\\n        private int Divide(final int[] arr,int low,int high){\\n                    if(low==high)return arr[low];      // Single element is itself the maximum sum in that subarray\\n\\n                    int mid=(low + (high-low)/2);\\n\\n                    int left_sum=  Divide(arr,low,mid);        // Divide the array with left part containing extra element in case of total odd elements\\n                    int right_sum= Divide(arr,mid+1,high);\\n                    // Conquer step or merge step\\n                    int merged_sum=Conquer(arr,low,mid,high);// This step would provide their maximum sum considering them contagious\\n                    return Math.max(left_sum,Math.max(right_sum,merged_sum));\\n        }\\n        public int maxSubArray(final int[] nums) {\\n            if (nums == null || nums.length == 0) return 0;// Invalid\\n            return Divide(nums,0,nums.length-1);\\n        }\\n\\n```\\n\\n```\\n // Approach 4    kadanes Algorithm        TC(O(N))   SC(O(1))   // Basically sliding window approach\\n                                                                        // The Main idea is that, we should restart counting the sum, as soon as sum becomes -ve\\n\\n\\n\\n    public int maxSubArray(final int[] nums) {\\n        if (nums == null || nums.length == 0) return 0;// Invalid\\n        int maxsum=Integer.MIN_VALUE;\\n        int currsum=0;\\n\\n        for(int i=0;i<nums.length;i++){\\n            currsum+=nums[i];\\n            if(maxsum<currsum)\\n                maxsum=currsum;\\n\\n            if(currsum<0)\\n                currsum=0;//Rest for fresh start\\n\\n        }\\n        return maxsum;\\n    }\\n\\n\\n```\\n\\nIf you have made it till here ,\\n***Please up vote if you liked my code so that it can also help others ***\\nThanks a lot !",
                "solutionTags": [],
                "code": "```\\n // Approach 1   TC=O(N^3)       SC=O(1)\\n    public int maxSubArray(final int[] nums) {\\n              if(nums==null || nums.length==0)return 0;\\n              int max=Integer.MIN_VALUE;\\n              int sum=0;\\n              for(int i=0;i<nums.length;i++){\\n                   for(int j=i;j< nums.length;j++){\\n                       //Compute sum b/w i-->j\\n                       sum=0;\\n                       for(int k=i;k<=j;k++){\\n                           sum+=nums[k];\\n                       }\\n                       if(max<sum)\\n                           max=sum;\\n                   }\\n               }\\n              return max;\\n    }\\n```\n```\\n// Approach 2   TC=O(N^2)       SC=O(N)\\n    public int maxSubArray(final int[] nums) {\\n        if(nums==null || nums.length==0)return 0;// Invalid\\n        int max=Integer.MIN_VALUE;\\n        int[] prefix=new int[nums.length+1];\\n        // Generate the prefix sum\\n        for(int i=0;i<nums.length;i++){\\n            prefix[i+1]=prefix[i] + nums[i];\\n        }\\n\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i;j< nums.length;j++){\\n                sum=prefix[j+1] - prefix[i];\\n                if(max<sum)\\n                    max=sum;\\n            }\\n        }\\n          return max;\\n    }\\n```\n```\\n\\n        // Approach 3   TC=O(NlogN)       SC=O(N)           // Quite Similer to merge sort\\n        private int Conquer(final int[] arr,int low,int mid,int high){\\n\\n                    int left_contagious_sum=Integer.MIN_VALUE;\\n                    int right_contagious_sum=Integer.MIN_VALUE;\\n\\n                    // Moving to left side from mid included to low included\\n                    int temp_left_sum=0;\\n                    for(int i=mid;i>=low;i--){\\n                        temp_left_sum+=arr[i];\\n                        if(left_contagious_sum<temp_left_sum)\\n                            left_contagious_sum=temp_left_sum;\\n                    }\\n\\n                    // Moving to right side from mid excluded to high included\\n                    int temp_right_sum=0;\\n                    for(int i=mid+1;i<=high;i++){\\n                        temp_right_sum+=arr[i];\\n                        if(right_contagious_sum<temp_right_sum)\\n                            right_contagious_sum=temp_right_sum;\\n                    }\\n\\n                    return left_contagious_sum+right_contagious_sum;\\n        }\\n        private int Divide(final int[] arr,int low,int high){\\n                    if(low==high)return arr[low];      // Single element is itself the maximum sum in that subarray\\n\\n                    int mid=(low + (high-low)/2);\\n\\n                    int left_sum=  Divide(arr,low,mid);        // Divide the array with left part containing extra element in case of total odd elements\\n                    int right_sum= Divide(arr,mid+1,high);\\n                    // Conquer step or merge step\\n                    int merged_sum=Conquer(arr,low,mid,high);// This step would provide their maximum sum considering them contagious\\n                    return Math.max(left_sum,Math.max(right_sum,merged_sum));\\n        }\\n        public int maxSubArray(final int[] nums) {\\n            if (nums == null || nums.length == 0) return 0;// Invalid\\n            return Divide(nums,0,nums.length-1);\\n        }\\n\\n```\n```\\n // Approach 4    kadanes Algorithm        TC(O(N))   SC(O(1))   // Basically sliding window approach\\n                                                                        // The Main idea is that, we should restart counting the sum, as soon as sum becomes -ve\\n\\n\\n\\n    public int maxSubArray(final int[] nums) {\\n        if (nums == null || nums.length == 0) return 0;// Invalid\\n        int maxsum=Integer.MIN_VALUE;\\n        int currsum=0;\\n\\n        for(int i=0;i<nums.length;i++){\\n            currsum+=nums[i];\\n            if(maxsum<currsum)\\n                maxsum=currsum;\\n\\n            if(currsum<0)\\n                currsum=0;//Rest for fresh start\\n\\n        }\\n        return maxsum;\\n    }\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 578388,
                "title": "divide-and-conquer",
                "content": "Subarray can be either entirely in left sub array or right subarray or crossing between two.\\nclass Solution(object):\\n\\n    class Solution(object):\\n    def maxcrossingSubArray(self,nums,mid):\\n        max_l_sum = max_r_sum = float(\\'-inf\\')\\n        sum = 0\\n        for i in xrange(mid-1,-1,-1):\\n            sum += nums[i]\\n            max_l_sum = max( max_l_sum ,sum)\\n        sum = 0\\n       \\n        for i in xrange(mid,len(nums),1):\\n            sum += nums[i]\\n            max_r_sum = max( max_r_sum ,sum)\\n        return max_l_sum + max_r_sum\\n        \\n        \\n        \\n    def maxSubArray(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if len(nums) ==  1 :\\n            return nums[0]\\n        elif not nums:\\n            return 0\\n        else :\\n            mid = len(nums)/2\\n            print(mid)\\n            l_sum = self.maxSubArray(nums[:mid])\\n            r_sum = self.maxSubArray(nums[mid:])\\n            c_sum = self.maxcrossingSubArray(nums,mid)\\n            print(l_sum,r_sum,c_sum)\\n            return max(l_sum,r_sum,c_sum)\\n            \\n        \\n",
                "solutionTags": [
                    "Python",
                    "Divide and Conquer"
                ],
                "code": "Subarray can be either entirely in left sub array or right subarray or crossing between two.\\nclass Solution(object):\\n\\n    class Solution(object):\\n    def maxcrossingSubArray(self,nums,mid):\\n        max_l_sum = max_r_sum = float(\\'-inf\\')\\n        sum = 0\\n        for i in xrange(mid-1,-1,-1):\\n            sum += nums[i]\\n            max_l_sum = max( max_l_sum ,sum)\\n        sum = 0\\n       \\n        for i in xrange(mid,len(nums),1):\\n            sum += nums[i]\\n            max_r_sum = max( max_r_sum ,sum)\\n        return max_l_sum + max_r_sum\\n        \\n        \\n        \\n    def maxSubArray(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if len(nums) ==  1 :\\n            return nums[0]\\n        elif not nums:\\n            return 0\\n        else :\\n            mid = len(nums)/2\\n            print(mid)\\n            l_sum = self.maxSubArray(nums[:mid])\\n            r_sum = self.maxSubArray(nums[mid:])\\n            c_sum = self.maxcrossingSubArray(nums,mid)\\n            print(l_sum,r_sum,c_sum)\\n            return max(l_sum,r_sum,c_sum)\\n            \\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 561967,
                "title": "53-javascript-1-line-solution",
                "content": "> Runtime: **60 ms**, faster than *67.95%* of JavaScript online submissions\\n> Memory Usage: **38 MB**, less than *5.55%* of JavaScript online submissions\\n\\n```javascript\\nconst maxSubArray = nums =>\\n  nums.reduce(\\n    ([localMax, globalMax], curr) => [\\n      Math.max(curr, localMax + curr),\\n      Math.max(curr, localMax + curr, globalMax),\\n    ],\\n    [-Infinity, -Infinity],\\n  )[1];\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nconst maxSubArray = nums =>\\n  nums.reduce(\\n    ([localMax, globalMax], curr) => [\\n      Math.max(curr, localMax + curr),\\n      Math.max(curr, localMax + curr, globalMax),\\n    ],\\n    [-Infinity, -Infinity],\\n  )[1];\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 553204,
                "title": "simple-easy-to-understand-o-n-solution-in-python",
                "content": "We use the fact that the max sum at any index will \\n1)either be the value at that index itself\\n2)or it would be the extension of the best subarray till the prev index added to the current idex\\'s value\\n```\\nclass Solution(object):\\n    def maxSubArray(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        maxcurr = nums[0]\\n        maxglobal = nums[0]\\n        for i in range(1,len(nums)):\\n            maxcurr = max(nums[i], maxcurr + nums[i]) \\n            maxglobal = max(maxcurr, maxglobal)\\n        return maxglobal\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxSubArray(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        maxcurr = nums[0]\\n        maxglobal = nums[0]\\n        for i in range(1,len(nums)):\\n            maxcurr = max(nums[i], maxcurr + nums[i]) \\n            maxglobal = max(maxcurr, maxglobal)\\n        return maxglobal\\n```",
                "codeTag": "Java"
            },
            {
                "id": 540951,
                "title": "c-divide-and-conquer-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> arr;\\n\\n\\t\\tint cross(int left,int right,int mid){\\n\\t\\t\\t//if(left==right) return arr[left];\\n\\t\\t\\tint cur=0;\\n\\t\\t\\tint ans1=INT_MIN;\\n\\t\\t\\tint ans2=INT_MIN;\\n\\t\\t\\tfor(int i=mid;i>=left;i--){\\n\\t\\t\\t\\tcur+=arr[i];\\n\\t\\t\\t\\tans1=max(ans1,cur);\\n\\t\\t\\t}\\n\\n\\t\\t\\tcur=0;\\n\\t\\t\\tfor(int i=mid+1;i<=right;i++){\\n\\t\\t\\t\\tcur+=arr[i];\\n\\t\\t\\t\\tans2=max(ans2,cur);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans1+ans2;\\n\\n\\n\\t\\t}\\n\\n\\t\\tint helper(int left, int right){\\n\\t\\t\\tif(left>=right){\\n\\t\\t\\t\\treturn arr[left];\\n\\t\\t\\t}\\n\\t\\t\\tint mid=(left+right)/2;\\n\\n\\t\\t\\tint sumLeft=helper(left,mid);\\n\\t\\t\\tint sumRight=helper(mid+1,right);\\n\\t\\t\\tint sumCross=cross(left,right,mid);\\n\\n\\t\\t\\treturn max(sumCross,max(sumLeft,sumRight));\\n\\t\\t}\\n\\t\\tint maxSubArray(vector<int>& nums) {\\n\\t\\t\\tarr=nums;\\n\\t\\t\\tint n=nums.size();\\n\\t\\t\\treturn helper(0,n-1);\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Divide and Conquer"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> arr;\\n\\n\\t\\tint cross(int left,int right,int mid){\\n\\t\\t\\t//if(left==right) return arr[left];\\n\\t\\t\\tint cur=0;\\n\\t\\t\\tint ans1=INT_MIN;\\n\\t\\t\\tint ans2=INT_MIN;\\n\\t\\t\\tfor(int i=mid;i>=left;i--){\\n\\t\\t\\t\\tcur+=arr[i];\\n\\t\\t\\t\\tans1=max(ans1,cur);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 353745,
                "title": "convert-to-the-best-time-to-buy-and-sell-stock-problem",
                "content": "This problem can be converted to the \"Best Time to Buy and Sell Stock\" Problem. It would be easier to understand in this way.\\n\\nFirst, we can create an array in which the i-th element is the sum from nums[0] to nums[i]. To implement this in-place by Python, we have \\n```\\nlen_nums=len(nums)\\nfor i in range(1,len_nums):\\n\\tnums[i]+=nums[i-1]\\n```\\n\\nNow, nums[j]-nums[i] is the sum of contiguous subarray (from i+1 to j).  If we insert a 0 to head of nums, then finding Maximum Subarray becomes the \"Best Time to Buy and Sell Stock\" Problem. Any solution in the Sell Stock problem can be used here.  My Python solution is\\n```\\nmin_price=0\\nmax_profit=float(\\'-inf\\')\\nfor num in nums:\\n\\tprofit=num-min_price\\n\\tif profit>max_profit:\\n\\t\\tmax_profit=profit\\n\\tif num<min_price:\\n\\t\\tmin_price=num\\nreturn max_profit\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nlen_nums=len(nums)\\nfor i in range(1,len_nums):\\n\\tnums[i]+=nums[i-1]\\n```\n```\\nmin_price=0\\nmax_profit=float(\\'-inf\\')\\nfor num in nums:\\n\\tprofit=num-min_price\\n\\tif profit>max_profit:\\n\\t\\tmax_profit=profit\\n\\tif num<min_price:\\n\\t\\tmin_price=num\\nreturn max_profit\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 165323,
                "title": "scala-1-line-dp",
                "content": "```nums.tail.scan(nums.head){(s,e) => math.max(s+e, e)}.max```",
                "solutionTags": [],
                "code": "```nums.tail.scan(nums.head){(s,e) => math.max(s+e, e)}.max```",
                "codeTag": "Unknown"
            },
            {
                "id": 20428,
                "title": "o-n-time-o-1-space-dynamic-programming-8-line-java-solution-with-comment",
                "content": "Define: sum[i] as the maximum subarray sum of [0...i], and this subarray MUST END WITH nums[i].\\n\\n(Some thought -- when facing \"consecutive sequence problems\" such as subarray or substring, the subproblems usually MUST END WITH current element, so that when NEXT element comes, the sequence will still remain consecutive).\\n\\n    /*Then, from i --> i+1:\\n    -- if sum[i] >= 0, it gives non-negative contribution, sum[i+1] = sum[i] + a[i+1]\\n    -- if sum[i] < 0, it gives negative contribution, sum[i+1] = a[i+1]*/\\n \\n    public class Solution {\\n        public int maxSubArray(int[] nums) {\\n            if (nums==null || nums.length==0) { return 0; }\\n            int max = nums[0], sum = nums[0];\\n            for (int i=1; i<nums.length; ++i) {\\n                if (sum >= 0) { sum += nums[i]; }\\n                else { sum = nums[i]; }\\n                max = Math.max(max, sum);\\n            }\\n            return max;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n        public int maxSubArray(int[] nums) {\\n            if (nums==null || nums.length==0) { return 0; }",
                "codeTag": "Java"
            },
            {
                "id": 2803078,
                "title": "beats-81-51-tc-using-simple-python-solution-for-maximum-subarray",
                "content": "![image.png](https://assets.leetcode.com/users/images/3add05d1-a7ac-45d8-a4b7-871005f88074_1668161027.768722.png)\\n\\n# Intuition\\nIgnore elements which results in negative value by sum, and compare the values to get max subarray value\\n\\n# Approach\\n1. Declare first element as max_val, and temp as 0\\n2. Loop through the nums list\\n    1. if temp is less than 0, assign temp as 0\\n    2. add current element to temp\\n    3. get max by comparing max_val and temp.\\n3. return max_val \\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        max_val = nums[0]\\n        temp = 0\\n\\n        for i in nums:\\n            if temp < 0:\\n                temp = 0            \\n            temp += i\\n            max_val = max(max_val, temp)\\n        \\n        return max_val\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        max_val = nums[0]\\n        temp = 0\\n\\n        for i in nums:\\n            if temp < 0:\\n                temp = 0            \\n            temp += i\\n            max_val = max(max_val, temp)\\n        \\n        return max_val\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2603051,
                "title": "easy-logic-linear-o-n-kadane-python-solution",
                "content": "**Leave an upvote if you like the solution :)**\\n\\n```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        ans = -inf\\n        currSum = 0\\n        \\n        for num in nums:\\n            currSum += num\\n            ans = max(ans, currSum)\\n            \\n\\t\\t\\t# if currSum < 0 then why to accumulate it further just ignore it and make it 0\\n            if currSum < 0:\\n                currSum = 0\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        ans = -inf\\n        currSum = 0\\n        \\n        for num in nums:\\n            currSum += num\\n            ans = max(ans, currSum)\\n            \\n\\t\\t\\t# if currSum < 0 then why to accumulate it further just ignore it and make it 0\\n            if currSum < 0:\\n                currSum = 0\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2113078,
                "title": "effective-solution-time-complexity-o-n",
                "content": "```class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int c = 0,  ans = INT_MIN;\\n        for(int i = 0; i < nums.size(); i++){\\n            c = max(nums[i], c + nums[i]);\\n            ans = max(ans, c);\\n        }\\n        return ans;  \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int c = 0,  ans = INT_MIN;\\n        for(int i = 0; i < nums.size(); i++){\\n            c = max(nums[i], c + nums[i]);\\n            ans = max(ans, c);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2062511,
                "title": "python-o-n-time-o-1-space",
                "content": "## method 3\\n```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        max_sum = nums[0]\\n        \\n        recent_sum = 0\\n        for num in nums:\\n            recent_sum += num\\n                \\n            if recent_sum > max_sum:\\n                max_sum = recent_sum\\n            \\n            if recent_sum < 0:\\n                recent_sum = 0\\n        \\n        return max_sum\\n```\\nLet `n` be the length of `nums`\\nTime: O(n)\\nSpace: O(1)\\n\\n## method 2: faster brute force (time limit exceeded)\\n```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        \\n        accumulations = [0] * n\\n        accumulations[0] = nums[0]\\n        for i in range(1, n):\\n            accumulations[i] = accumulations[i - 1] + nums[i]\\n        \\n        max_sum = max(accumulations)\\n        \\n        for i in range(n):\\n            for j in range(i+1, n):\\n                max_sum = max(max_sum, accumulations[j] - accumulations[i])\\n        \\n        return max_sum\\n```\\nLet `n` be the length of `nums`\\nTime: O(n^2) \\nSpace: O(n)\\n\\n## method 1: brute force (time limit exceeded)\\n```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        \\n        max_sum = nums[0]\\n        \\n        for i in range(n):\\n            for j in range(i, n):\\n                max_sum = max(max_sum, sum(nums[i : j+1]))\\n        \\n        return max_sum\\n```\\nLet `n` be the length of `nums`\\nTime: O(n^3)\\nSpace: O(n)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        max_sum = nums[0]\\n        \\n        recent_sum = 0\\n        for num in nums:\\n            recent_sum += num\\n                \\n            if recent_sum > max_sum:\\n                max_sum = recent_sum\\n            \\n            if recent_sum < 0:\\n                recent_sum = 0\\n        \\n        return max_sum\\n```\n```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        \\n        accumulations = [0] * n\\n        accumulations[0] = nums[0]\\n        for i in range(1, n):\\n            accumulations[i] = accumulations[i - 1] + nums[i]\\n        \\n        max_sum = max(accumulations)\\n        \\n        for i in range(n):\\n            for j in range(i+1, n):\\n                max_sum = max(max_sum, accumulations[j] - accumulations[i])\\n        \\n        return max_sum\\n```\n```\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        \\n        max_sum = nums[0]\\n        \\n        for i in range(n):\\n            for j in range(i, n):\\n                max_sum = max(max_sum, sum(nums[i : j+1]))\\n        \\n        return max_sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1753529,
                "title": "faster-than-100-very-easy-java-solution",
                "content": "```\\n#**Please upvote if you like the Solution\\nclass Solution {\\n    public int maxSubArray(int[] nums) \\n    {\\n        int sum=0;\\n        int maxi=Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            sum=sum+nums[i];\\n             maxi=Math.max(sum,maxi);\\n            if(sum<0)\\n            {\\n                sum=0;\\n            }\\n           \\n        }\\n        return maxi;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int maxSubArray(int[] nums) \\n    {\\n        int sum=0;\\n        int maxi=Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            sum=sum+nums[i];\\n             maxi=Math.max(sum,maxi);\\n            if(sum<0)\\n            {\\n                sum=0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1667107,
                "title": "js-97-faster-than-other-solutions",
                "content": "```\\nvar maxSubArray = function(nums) {\\n    if (!nums || !nums.length) {\\n        return 0;\\n    }\\n    let max = nums[0];\\n    for (let i = 1; i < nums.length; i++) {\\n        nums[i] = Math.max(nums[i], nums[i] + nums[i-1]);\\n        if (nums[i] > max) {\\n            max = nums[i];\\n        }\\n    }\\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar maxSubArray = function(nums) {\\n    if (!nums || !nums.length) {\\n        return 0;\\n    }\\n    let max = nums[0];\\n    for (let i = 1; i < nums.length; i++) {\\n        nums[i] = Math.max(nums[i], nums[i] + nums[i-1]);\\n        if (nums[i] > max) {\\n            max = nums[i];\\n        }\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1489447,
                "title": "no-magic-only-2-simple-steps",
                "content": "```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        \\n        // Store 1st element in for maxSum and currSum\\n        int currSum = nums[0];\\n        int maxSum = nums[0];\\n        for(int i = 1; i < nums.length; i++){\\n            // If ongoing subarray sum is less than 0, discard it and start taking sum for new sub array\\n            if(currSum<0){\\n                currSum =0;\\n            }\\n            \\n            // add current element from nums arr to our ongoing subarray sum\\n            currSum += nums[i];\\n            \\n            // check if current sum of going subarray is greater than max sum till now, \\n\\t\\t\\t// then set max sum to current sum\\n            if(currSum > maxSum){\\n                maxSum = currSum;\\n            }\\n        }\\n        return maxSum;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        \\n        // Store 1st element in for maxSum and currSum\\n        int currSum = nums[0];\\n        int maxSum = nums[0];\\n        for(int i = 1; i < nums.length; i++){\\n            // If ongoing subarray sum is less than 0, discard it and start taking sum for new sub array\\n            if(currSum<0){\\n                currSum =0;\\n            }\\n            \\n            // add current element from nums arr to our ongoing subarray sum\\n            currSum += nums[i];\\n            \\n            // check if current sum of going subarray is greater than max sum till now, \\n\\t\\t\\t// then set max sum to current sum\\n            if(currSum > maxSum){\\n                maxSum = currSum;\\n            }\\n        }\\n        return maxSum;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564960,
                "content": [
                    {
                        "username": "chentao169",
                        "content": "I solve this problem in O(n). But the hint says it would be solved by using the divide and conquer approach.\\nI cannot figure out how to do it with divide and conquer.\\nYou guys have ideas?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I think I found one divide-and-conquer solution with O(nlogn) time (slower than Kadane\\'s algorithm) and O(1) space (same as Kadane\\'s).\\n\\nSome insights: If we cut the original array into 2 equal halves, then the max subarray must be in either one of the 3 positions: completely in the left half, completely in the right half, or spanning across 2 halves. So, we can form 3 corresponding sub-problems to find the max array in each of these 3 positions, then choose the max of the 3 arrays to be the ultimate answer.\\n\\nThe first 2 subtasks can be solved using recursion, while the last one (max sub-array spanning across 2 halves) can be done in a pretty similar fashion as the Kadane\\'s algorithm (hint: iterate the array from the middle point to the 2 ends and utilize the `current_sum` variable).\\n\\nAnd that\\'s it. Hope you can find the solution!"
                    },
                    {
                        "username": "kolojoe",
                        "content": "My solution was O(log(n)) using divide and conquer (albeit definitely a bit more verbose than the DP methods using O(n)): https://leetcode.com/problems/maximum-subarray/solutions/2905607/recursive-o-log-n-mathematical-approach-summing-via-logical-continuity/"
                    },
                    {
                        "username": "xcznu",
                        "content": "I feel its misleading to instruct to \"find\" the subarray (int[]), when function is returning the max sum (int).  May be use another word for \"find\" - eg. \"calculate\" the sum of largest contigous subarray \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "coder_bgn",
                        "content": "[@ayooluwaadeleye17](/ayooluwaadeleye17) but how to find the subarray\\n....can u give the code here to find the subarray , im unable to find it"
                    },
                    {
                        "username": "johnppkyaw",
                        "content": "I agree.  That was confusing.  "
                    },
                    {
                        "username": "ayooluwaadeleye17",
                        "content": "Yes i was confused when i was trying to return the subarray and it ws wrong because I was supposed to return the sum"
                    },
                    {
                        "username": "usaar33",
                        "content": "Certainly, the O(n^3) algorithm (brute force) is \"easy\" (even a slightly optimized O(n^2) using sliding windows), but I fail to see how the O(n) algorithm (Kadane\\'s) is \"easy\".  Having done this in an interview setting, I found it more challenging than most \"medium\" problems here (subsets, iterative binary tree inorder traversal, permutations, group anagrams, merge intervals, just to name a few).  \\n\\n1. With the before-mentioned \"medium\" problems, basically understanding the problem definition and drawing it out and knowing recursion/core CS data structures -- you can pull off an algorithm pretty directly.   But even if you get as far as recognizing this as a 1-D DP problem, building the subproblems and advancing them aren\\'t obvious. (let alone convincing yourself what you are doing is valid)\\n2. That the algorithm has someone\\'s name attached to it (Kadane) makes me question whether it is trivial. :)\\n\\nAdmitedly, once you\\'ve done it before, it feels trivial to code. In that sense, this problem reminds me a bit of the linked list cycle problem (with no prior context) -- trivial in O(n) time/O(n) space - a lot harder (admitedly more difficult than coming up with Kadane\\'s algorithm) with O(1) space.\\n\\nAs a comparison to another leetcode problem, this feels about as challenging as [Best time to buy & sell stock with txn fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/), a 1D DP problem with not-so-obvious subproblems."
                    },
                    {
                        "username": "user0626kd",
                        "content": "tbh the \"1-d dp\" isn\\'t really a dp, it\\'s a greedy algorithm"
                    },
                    {
                        "username": "snrklyc",
                        "content": "Precisely. If the solution you seek has but one single way of doing it, it means you’re not seeking if the candidate is capable of reducing complexity, but if they happen to know the esoteric algorithm you know. Such questions are frowned upon in my company, I always tell new interviewers to never ask them. "
                    },
                    {
                        "username": "BenSwitala",
                        "content": "This is a hard problem, not an easy one!  An algorithm to solve it is named after a person, Kadane!"
                    },
                    {
                        "username": "20credi",
                        "content": "thank you"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Brute force solution doesn\\'t pass and Optimized solutions are not obvious."
                    },
                    {
                        "username": "_nik_",
                        "content": "Problem with brute force is that it is taking longer time and after using kadanes, it is only working for positive array not the negative ones."
                    },
                    {
                        "username": "nathanad",
                        "content": "I don\\'t understand why this is considered an easy question when it took University professors years to come up with an O(n)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) no he didnt lmao "
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "nice logic"
                    },
                    {
                        "username": "llulek",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) the problem is my name is not Kadane ;) "
                    },
                    {
                        "username": "petahertz",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) But how long did it take to find the one person who could solve it in a minute? :-)"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "You realise it took kadane a minute to figure it out?"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "its med"
                    },
                    {
                        "username": "Jayaramachandran",
                        "content": "Video explaining how to solve the maximum sub-array problem using the kadane\\'s algorithm\\n\\nhttps://youtu.be/Id_hZTV7_IA\\n\\n\\n\\nThe kadane algorithm helps us to compute the maximum sum at each index position. The core of kadane algorithm is, the maximum sum at any given index position is either the value at that index or the sum of value at current index position and the maximum sum at the previous index position.\\nLet\\u2019s see the pseudo code of kadane algorithm,\\nStep 1: Assign the zeroth index value to the current index maximum sum and overall maximum sum.\\nStep 2: Start from the index position one and iterate till n and find the max value between the current index position value and sum of current index position value and last index maximum sum.\\nStep 3: if the current index maximum value is greater than overall maximum value, then replace the overall maximum value with the current index maximum value."
                    },
                    {
                        "username": "almightyshiva",
                        "content": "why is for loop i<nums.length i should iterate all the values why is it less"
                    },
                    {
                        "username": "user4136j",
                        "content": "alternate explanation writing back into same array memory: https://www.youtube.com/watch?v=tmakGVOGV3A"
                    },
                    {
                        "username": "leewc",
                        "content": "I ran into this issue when trying the test case provided on the question, if you're like me where you usually copy paste the example as a test case and then clicking run code, you'll run into this.\\n\\nFirstly u\\\\u2212 is a Minus sign in Unicode.\\n\\nTurns out the example case used Unicode minus signs.\\n\\nNotice how the example,  `[\\u22122,1,\\u22123,4,\\u22121,2,1,\\u22125,4]` differs with  `[-2,1,-3,4,-1,2,1,-5,4]`, the signs are longer.\\n\\nPosting this here in hopes of helping people figure it out since I thought it was something wrong with my code."
                    },
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Can anyone try to solve this problem?\\nhttp://stackoverflow.com/questions/39084147/largest-sum-of-contiguous-subarray-no-larger-than-k"
                    },
                    {
                        "username": "shivansh100",
                        "content": "calculate prefix sum array, then while iterating use binarysearch or upperbound to get the value closest to sum K."
                    },
                    {
                        "username": "xiangu",
                        "content": "DP solution:\\n- Define dp[i] = max sum of sub-array ending with nums[i]\\n- result = max(dp) because the max sum subarray has to end at some element\\n- Base case: dp[0] = nums[0]\\n- Recurrence: dp[i] = nums[i] + max(0, dp[i-1])\\n\\nLet\\'s first accept the meaning of the dp array (I know it\\'s not natural to come up with this representation but let\\'s for now accept it. I will try to illustrate why we have this recurrence).\\n\\ninterpretation of the recurrence: To find the max subarray ending in element i, literally, it means we need to consider all subarrays that ends in element i:\\n\\n[element i],\\n[element i-1, element i],\\n[element i-2, element i-1, element i],\\n... \\n[element 0, ..., element i].\\n\\nThen we find the one with highest sum as dp[i]; that is, dp[i] = max(sum([element i]), sum([element i-1, element i]), ..., sum([element 0, ..., element i]))\\n\\n= nums[i] + max(sum([]), sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))\\n\\n\\n= nums[i] + max(0, sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1])) \\n\\n= nums[i] + max(0, *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*) \\n\\nHey, boy, look at this part *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*; this is exactly dp[i-1]!\\nThus, the recurrence equation can be expressed as dp[i] = nums[i] + max(0, dp[i-1]).\\n\\nNow, you can look at other posts to undersand how to further optimize this solution (on the space complexity from O(n) to O(1)) but I find this explanation most natural for first attempt!\\n\\n           \\n"
                    }
                ]
            },
            {
                "id": 1568734,
                "content": [
                    {
                        "username": "chentao169",
                        "content": "I solve this problem in O(n). But the hint says it would be solved by using the divide and conquer approach.\\nI cannot figure out how to do it with divide and conquer.\\nYou guys have ideas?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I think I found one divide-and-conquer solution with O(nlogn) time (slower than Kadane\\'s algorithm) and O(1) space (same as Kadane\\'s).\\n\\nSome insights: If we cut the original array into 2 equal halves, then the max subarray must be in either one of the 3 positions: completely in the left half, completely in the right half, or spanning across 2 halves. So, we can form 3 corresponding sub-problems to find the max array in each of these 3 positions, then choose the max of the 3 arrays to be the ultimate answer.\\n\\nThe first 2 subtasks can be solved using recursion, while the last one (max sub-array spanning across 2 halves) can be done in a pretty similar fashion as the Kadane\\'s algorithm (hint: iterate the array from the middle point to the 2 ends and utilize the `current_sum` variable).\\n\\nAnd that\\'s it. Hope you can find the solution!"
                    },
                    {
                        "username": "kolojoe",
                        "content": "My solution was O(log(n)) using divide and conquer (albeit definitely a bit more verbose than the DP methods using O(n)): https://leetcode.com/problems/maximum-subarray/solutions/2905607/recursive-o-log-n-mathematical-approach-summing-via-logical-continuity/"
                    },
                    {
                        "username": "xcznu",
                        "content": "I feel its misleading to instruct to \"find\" the subarray (int[]), when function is returning the max sum (int).  May be use another word for \"find\" - eg. \"calculate\" the sum of largest contigous subarray \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "coder_bgn",
                        "content": "[@ayooluwaadeleye17](/ayooluwaadeleye17) but how to find the subarray\\n....can u give the code here to find the subarray , im unable to find it"
                    },
                    {
                        "username": "johnppkyaw",
                        "content": "I agree.  That was confusing.  "
                    },
                    {
                        "username": "ayooluwaadeleye17",
                        "content": "Yes i was confused when i was trying to return the subarray and it ws wrong because I was supposed to return the sum"
                    },
                    {
                        "username": "usaar33",
                        "content": "Certainly, the O(n^3) algorithm (brute force) is \"easy\" (even a slightly optimized O(n^2) using sliding windows), but I fail to see how the O(n) algorithm (Kadane\\'s) is \"easy\".  Having done this in an interview setting, I found it more challenging than most \"medium\" problems here (subsets, iterative binary tree inorder traversal, permutations, group anagrams, merge intervals, just to name a few).  \\n\\n1. With the before-mentioned \"medium\" problems, basically understanding the problem definition and drawing it out and knowing recursion/core CS data structures -- you can pull off an algorithm pretty directly.   But even if you get as far as recognizing this as a 1-D DP problem, building the subproblems and advancing them aren\\'t obvious. (let alone convincing yourself what you are doing is valid)\\n2. That the algorithm has someone\\'s name attached to it (Kadane) makes me question whether it is trivial. :)\\n\\nAdmitedly, once you\\'ve done it before, it feels trivial to code. In that sense, this problem reminds me a bit of the linked list cycle problem (with no prior context) -- trivial in O(n) time/O(n) space - a lot harder (admitedly more difficult than coming up with Kadane\\'s algorithm) with O(1) space.\\n\\nAs a comparison to another leetcode problem, this feels about as challenging as [Best time to buy & sell stock with txn fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/), a 1D DP problem with not-so-obvious subproblems."
                    },
                    {
                        "username": "user0626kd",
                        "content": "tbh the \"1-d dp\" isn\\'t really a dp, it\\'s a greedy algorithm"
                    },
                    {
                        "username": "snrklyc",
                        "content": "Precisely. If the solution you seek has but one single way of doing it, it means you’re not seeking if the candidate is capable of reducing complexity, but if they happen to know the esoteric algorithm you know. Such questions are frowned upon in my company, I always tell new interviewers to never ask them. "
                    },
                    {
                        "username": "BenSwitala",
                        "content": "This is a hard problem, not an easy one!  An algorithm to solve it is named after a person, Kadane!"
                    },
                    {
                        "username": "20credi",
                        "content": "thank you"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Brute force solution doesn\\'t pass and Optimized solutions are not obvious."
                    },
                    {
                        "username": "_nik_",
                        "content": "Problem with brute force is that it is taking longer time and after using kadanes, it is only working for positive array not the negative ones."
                    },
                    {
                        "username": "nathanad",
                        "content": "I don\\'t understand why this is considered an easy question when it took University professors years to come up with an O(n)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) no he didnt lmao "
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "nice logic"
                    },
                    {
                        "username": "llulek",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) the problem is my name is not Kadane ;) "
                    },
                    {
                        "username": "petahertz",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) But how long did it take to find the one person who could solve it in a minute? :-)"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "You realise it took kadane a minute to figure it out?"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "its med"
                    },
                    {
                        "username": "Jayaramachandran",
                        "content": "Video explaining how to solve the maximum sub-array problem using the kadane\\'s algorithm\\n\\nhttps://youtu.be/Id_hZTV7_IA\\n\\n\\n\\nThe kadane algorithm helps us to compute the maximum sum at each index position. The core of kadane algorithm is, the maximum sum at any given index position is either the value at that index or the sum of value at current index position and the maximum sum at the previous index position.\\nLet\\u2019s see the pseudo code of kadane algorithm,\\nStep 1: Assign the zeroth index value to the current index maximum sum and overall maximum sum.\\nStep 2: Start from the index position one and iterate till n and find the max value between the current index position value and sum of current index position value and last index maximum sum.\\nStep 3: if the current index maximum value is greater than overall maximum value, then replace the overall maximum value with the current index maximum value."
                    },
                    {
                        "username": "almightyshiva",
                        "content": "why is for loop i<nums.length i should iterate all the values why is it less"
                    },
                    {
                        "username": "user4136j",
                        "content": "alternate explanation writing back into same array memory: https://www.youtube.com/watch?v=tmakGVOGV3A"
                    },
                    {
                        "username": "leewc",
                        "content": "I ran into this issue when trying the test case provided on the question, if you're like me where you usually copy paste the example as a test case and then clicking run code, you'll run into this.\\n\\nFirstly u\\\\u2212 is a Minus sign in Unicode.\\n\\nTurns out the example case used Unicode minus signs.\\n\\nNotice how the example,  `[\\u22122,1,\\u22123,4,\\u22121,2,1,\\u22125,4]` differs with  `[-2,1,-3,4,-1,2,1,-5,4]`, the signs are longer.\\n\\nPosting this here in hopes of helping people figure it out since I thought it was something wrong with my code."
                    },
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Can anyone try to solve this problem?\\nhttp://stackoverflow.com/questions/39084147/largest-sum-of-contiguous-subarray-no-larger-than-k"
                    },
                    {
                        "username": "shivansh100",
                        "content": "calculate prefix sum array, then while iterating use binarysearch or upperbound to get the value closest to sum K."
                    },
                    {
                        "username": "xiangu",
                        "content": "DP solution:\\n- Define dp[i] = max sum of sub-array ending with nums[i]\\n- result = max(dp) because the max sum subarray has to end at some element\\n- Base case: dp[0] = nums[0]\\n- Recurrence: dp[i] = nums[i] + max(0, dp[i-1])\\n\\nLet\\'s first accept the meaning of the dp array (I know it\\'s not natural to come up with this representation but let\\'s for now accept it. I will try to illustrate why we have this recurrence).\\n\\ninterpretation of the recurrence: To find the max subarray ending in element i, literally, it means we need to consider all subarrays that ends in element i:\\n\\n[element i],\\n[element i-1, element i],\\n[element i-2, element i-1, element i],\\n... \\n[element 0, ..., element i].\\n\\nThen we find the one with highest sum as dp[i]; that is, dp[i] = max(sum([element i]), sum([element i-1, element i]), ..., sum([element 0, ..., element i]))\\n\\n= nums[i] + max(sum([]), sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))\\n\\n\\n= nums[i] + max(0, sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1])) \\n\\n= nums[i] + max(0, *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*) \\n\\nHey, boy, look at this part *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*; this is exactly dp[i-1]!\\nThus, the recurrence equation can be expressed as dp[i] = nums[i] + max(0, dp[i-1]).\\n\\nNow, you can look at other posts to undersand how to further optimize this solution (on the space complexity from O(n) to O(1)) but I find this explanation most natural for first attempt!\\n\\n           \\n"
                    }
                ]
            },
            {
                "id": 1565011,
                "content": [
                    {
                        "username": "chentao169",
                        "content": "I solve this problem in O(n). But the hint says it would be solved by using the divide and conquer approach.\\nI cannot figure out how to do it with divide and conquer.\\nYou guys have ideas?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I think I found one divide-and-conquer solution with O(nlogn) time (slower than Kadane\\'s algorithm) and O(1) space (same as Kadane\\'s).\\n\\nSome insights: If we cut the original array into 2 equal halves, then the max subarray must be in either one of the 3 positions: completely in the left half, completely in the right half, or spanning across 2 halves. So, we can form 3 corresponding sub-problems to find the max array in each of these 3 positions, then choose the max of the 3 arrays to be the ultimate answer.\\n\\nThe first 2 subtasks can be solved using recursion, while the last one (max sub-array spanning across 2 halves) can be done in a pretty similar fashion as the Kadane\\'s algorithm (hint: iterate the array from the middle point to the 2 ends and utilize the `current_sum` variable).\\n\\nAnd that\\'s it. Hope you can find the solution!"
                    },
                    {
                        "username": "kolojoe",
                        "content": "My solution was O(log(n)) using divide and conquer (albeit definitely a bit more verbose than the DP methods using O(n)): https://leetcode.com/problems/maximum-subarray/solutions/2905607/recursive-o-log-n-mathematical-approach-summing-via-logical-continuity/"
                    },
                    {
                        "username": "xcznu",
                        "content": "I feel its misleading to instruct to \"find\" the subarray (int[]), when function is returning the max sum (int).  May be use another word for \"find\" - eg. \"calculate\" the sum of largest contigous subarray \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "coder_bgn",
                        "content": "[@ayooluwaadeleye17](/ayooluwaadeleye17) but how to find the subarray\\n....can u give the code here to find the subarray , im unable to find it"
                    },
                    {
                        "username": "johnppkyaw",
                        "content": "I agree.  That was confusing.  "
                    },
                    {
                        "username": "ayooluwaadeleye17",
                        "content": "Yes i was confused when i was trying to return the subarray and it ws wrong because I was supposed to return the sum"
                    },
                    {
                        "username": "usaar33",
                        "content": "Certainly, the O(n^3) algorithm (brute force) is \"easy\" (even a slightly optimized O(n^2) using sliding windows), but I fail to see how the O(n) algorithm (Kadane\\'s) is \"easy\".  Having done this in an interview setting, I found it more challenging than most \"medium\" problems here (subsets, iterative binary tree inorder traversal, permutations, group anagrams, merge intervals, just to name a few).  \\n\\n1. With the before-mentioned \"medium\" problems, basically understanding the problem definition and drawing it out and knowing recursion/core CS data structures -- you can pull off an algorithm pretty directly.   But even if you get as far as recognizing this as a 1-D DP problem, building the subproblems and advancing them aren\\'t obvious. (let alone convincing yourself what you are doing is valid)\\n2. That the algorithm has someone\\'s name attached to it (Kadane) makes me question whether it is trivial. :)\\n\\nAdmitedly, once you\\'ve done it before, it feels trivial to code. In that sense, this problem reminds me a bit of the linked list cycle problem (with no prior context) -- trivial in O(n) time/O(n) space - a lot harder (admitedly more difficult than coming up with Kadane\\'s algorithm) with O(1) space.\\n\\nAs a comparison to another leetcode problem, this feels about as challenging as [Best time to buy & sell stock with txn fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/), a 1D DP problem with not-so-obvious subproblems."
                    },
                    {
                        "username": "user0626kd",
                        "content": "tbh the \"1-d dp\" isn\\'t really a dp, it\\'s a greedy algorithm"
                    },
                    {
                        "username": "snrklyc",
                        "content": "Precisely. If the solution you seek has but one single way of doing it, it means you’re not seeking if the candidate is capable of reducing complexity, but if they happen to know the esoteric algorithm you know. Such questions are frowned upon in my company, I always tell new interviewers to never ask them. "
                    },
                    {
                        "username": "BenSwitala",
                        "content": "This is a hard problem, not an easy one!  An algorithm to solve it is named after a person, Kadane!"
                    },
                    {
                        "username": "20credi",
                        "content": "thank you"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Brute force solution doesn\\'t pass and Optimized solutions are not obvious."
                    },
                    {
                        "username": "_nik_",
                        "content": "Problem with brute force is that it is taking longer time and after using kadanes, it is only working for positive array not the negative ones."
                    },
                    {
                        "username": "nathanad",
                        "content": "I don\\'t understand why this is considered an easy question when it took University professors years to come up with an O(n)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) no he didnt lmao "
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "nice logic"
                    },
                    {
                        "username": "llulek",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) the problem is my name is not Kadane ;) "
                    },
                    {
                        "username": "petahertz",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) But how long did it take to find the one person who could solve it in a minute? :-)"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "You realise it took kadane a minute to figure it out?"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "its med"
                    },
                    {
                        "username": "Jayaramachandran",
                        "content": "Video explaining how to solve the maximum sub-array problem using the kadane\\'s algorithm\\n\\nhttps://youtu.be/Id_hZTV7_IA\\n\\n\\n\\nThe kadane algorithm helps us to compute the maximum sum at each index position. The core of kadane algorithm is, the maximum sum at any given index position is either the value at that index or the sum of value at current index position and the maximum sum at the previous index position.\\nLet\\u2019s see the pseudo code of kadane algorithm,\\nStep 1: Assign the zeroth index value to the current index maximum sum and overall maximum sum.\\nStep 2: Start from the index position one and iterate till n and find the max value between the current index position value and sum of current index position value and last index maximum sum.\\nStep 3: if the current index maximum value is greater than overall maximum value, then replace the overall maximum value with the current index maximum value."
                    },
                    {
                        "username": "almightyshiva",
                        "content": "why is for loop i<nums.length i should iterate all the values why is it less"
                    },
                    {
                        "username": "user4136j",
                        "content": "alternate explanation writing back into same array memory: https://www.youtube.com/watch?v=tmakGVOGV3A"
                    },
                    {
                        "username": "leewc",
                        "content": "I ran into this issue when trying the test case provided on the question, if you're like me where you usually copy paste the example as a test case and then clicking run code, you'll run into this.\\n\\nFirstly u\\\\u2212 is a Minus sign in Unicode.\\n\\nTurns out the example case used Unicode minus signs.\\n\\nNotice how the example,  `[\\u22122,1,\\u22123,4,\\u22121,2,1,\\u22125,4]` differs with  `[-2,1,-3,4,-1,2,1,-5,4]`, the signs are longer.\\n\\nPosting this here in hopes of helping people figure it out since I thought it was something wrong with my code."
                    },
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Can anyone try to solve this problem?\\nhttp://stackoverflow.com/questions/39084147/largest-sum-of-contiguous-subarray-no-larger-than-k"
                    },
                    {
                        "username": "shivansh100",
                        "content": "calculate prefix sum array, then while iterating use binarysearch or upperbound to get the value closest to sum K."
                    },
                    {
                        "username": "xiangu",
                        "content": "DP solution:\\n- Define dp[i] = max sum of sub-array ending with nums[i]\\n- result = max(dp) because the max sum subarray has to end at some element\\n- Base case: dp[0] = nums[0]\\n- Recurrence: dp[i] = nums[i] + max(0, dp[i-1])\\n\\nLet\\'s first accept the meaning of the dp array (I know it\\'s not natural to come up with this representation but let\\'s for now accept it. I will try to illustrate why we have this recurrence).\\n\\ninterpretation of the recurrence: To find the max subarray ending in element i, literally, it means we need to consider all subarrays that ends in element i:\\n\\n[element i],\\n[element i-1, element i],\\n[element i-2, element i-1, element i],\\n... \\n[element 0, ..., element i].\\n\\nThen we find the one with highest sum as dp[i]; that is, dp[i] = max(sum([element i]), sum([element i-1, element i]), ..., sum([element 0, ..., element i]))\\n\\n= nums[i] + max(sum([]), sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))\\n\\n\\n= nums[i] + max(0, sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1])) \\n\\n= nums[i] + max(0, *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*) \\n\\nHey, boy, look at this part *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*; this is exactly dp[i-1]!\\nThus, the recurrence equation can be expressed as dp[i] = nums[i] + max(0, dp[i-1]).\\n\\nNow, you can look at other posts to undersand how to further optimize this solution (on the space complexity from O(n) to O(1)) but I find this explanation most natural for first attempt!\\n\\n           \\n"
                    }
                ]
            },
            {
                "id": 1566595,
                "content": [
                    {
                        "username": "chentao169",
                        "content": "I solve this problem in O(n). But the hint says it would be solved by using the divide and conquer approach.\\nI cannot figure out how to do it with divide and conquer.\\nYou guys have ideas?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I think I found one divide-and-conquer solution with O(nlogn) time (slower than Kadane\\'s algorithm) and O(1) space (same as Kadane\\'s).\\n\\nSome insights: If we cut the original array into 2 equal halves, then the max subarray must be in either one of the 3 positions: completely in the left half, completely in the right half, or spanning across 2 halves. So, we can form 3 corresponding sub-problems to find the max array in each of these 3 positions, then choose the max of the 3 arrays to be the ultimate answer.\\n\\nThe first 2 subtasks can be solved using recursion, while the last one (max sub-array spanning across 2 halves) can be done in a pretty similar fashion as the Kadane\\'s algorithm (hint: iterate the array from the middle point to the 2 ends and utilize the `current_sum` variable).\\n\\nAnd that\\'s it. Hope you can find the solution!"
                    },
                    {
                        "username": "kolojoe",
                        "content": "My solution was O(log(n)) using divide and conquer (albeit definitely a bit more verbose than the DP methods using O(n)): https://leetcode.com/problems/maximum-subarray/solutions/2905607/recursive-o-log-n-mathematical-approach-summing-via-logical-continuity/"
                    },
                    {
                        "username": "xcznu",
                        "content": "I feel its misleading to instruct to \"find\" the subarray (int[]), when function is returning the max sum (int).  May be use another word for \"find\" - eg. \"calculate\" the sum of largest contigous subarray \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "coder_bgn",
                        "content": "[@ayooluwaadeleye17](/ayooluwaadeleye17) but how to find the subarray\\n....can u give the code here to find the subarray , im unable to find it"
                    },
                    {
                        "username": "johnppkyaw",
                        "content": "I agree.  That was confusing.  "
                    },
                    {
                        "username": "ayooluwaadeleye17",
                        "content": "Yes i was confused when i was trying to return the subarray and it ws wrong because I was supposed to return the sum"
                    },
                    {
                        "username": "usaar33",
                        "content": "Certainly, the O(n^3) algorithm (brute force) is \"easy\" (even a slightly optimized O(n^2) using sliding windows), but I fail to see how the O(n) algorithm (Kadane\\'s) is \"easy\".  Having done this in an interview setting, I found it more challenging than most \"medium\" problems here (subsets, iterative binary tree inorder traversal, permutations, group anagrams, merge intervals, just to name a few).  \\n\\n1. With the before-mentioned \"medium\" problems, basically understanding the problem definition and drawing it out and knowing recursion/core CS data structures -- you can pull off an algorithm pretty directly.   But even if you get as far as recognizing this as a 1-D DP problem, building the subproblems and advancing them aren\\'t obvious. (let alone convincing yourself what you are doing is valid)\\n2. That the algorithm has someone\\'s name attached to it (Kadane) makes me question whether it is trivial. :)\\n\\nAdmitedly, once you\\'ve done it before, it feels trivial to code. In that sense, this problem reminds me a bit of the linked list cycle problem (with no prior context) -- trivial in O(n) time/O(n) space - a lot harder (admitedly more difficult than coming up with Kadane\\'s algorithm) with O(1) space.\\n\\nAs a comparison to another leetcode problem, this feels about as challenging as [Best time to buy & sell stock with txn fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/), a 1D DP problem with not-so-obvious subproblems."
                    },
                    {
                        "username": "user0626kd",
                        "content": "tbh the \"1-d dp\" isn\\'t really a dp, it\\'s a greedy algorithm"
                    },
                    {
                        "username": "snrklyc",
                        "content": "Precisely. If the solution you seek has but one single way of doing it, it means you’re not seeking if the candidate is capable of reducing complexity, but if they happen to know the esoteric algorithm you know. Such questions are frowned upon in my company, I always tell new interviewers to never ask them. "
                    },
                    {
                        "username": "BenSwitala",
                        "content": "This is a hard problem, not an easy one!  An algorithm to solve it is named after a person, Kadane!"
                    },
                    {
                        "username": "20credi",
                        "content": "thank you"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Brute force solution doesn\\'t pass and Optimized solutions are not obvious."
                    },
                    {
                        "username": "_nik_",
                        "content": "Problem with brute force is that it is taking longer time and after using kadanes, it is only working for positive array not the negative ones."
                    },
                    {
                        "username": "nathanad",
                        "content": "I don\\'t understand why this is considered an easy question when it took University professors years to come up with an O(n)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) no he didnt lmao "
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "nice logic"
                    },
                    {
                        "username": "llulek",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) the problem is my name is not Kadane ;) "
                    },
                    {
                        "username": "petahertz",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) But how long did it take to find the one person who could solve it in a minute? :-)"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "You realise it took kadane a minute to figure it out?"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "its med"
                    },
                    {
                        "username": "Jayaramachandran",
                        "content": "Video explaining how to solve the maximum sub-array problem using the kadane\\'s algorithm\\n\\nhttps://youtu.be/Id_hZTV7_IA\\n\\n\\n\\nThe kadane algorithm helps us to compute the maximum sum at each index position. The core of kadane algorithm is, the maximum sum at any given index position is either the value at that index or the sum of value at current index position and the maximum sum at the previous index position.\\nLet\\u2019s see the pseudo code of kadane algorithm,\\nStep 1: Assign the zeroth index value to the current index maximum sum and overall maximum sum.\\nStep 2: Start from the index position one and iterate till n and find the max value between the current index position value and sum of current index position value and last index maximum sum.\\nStep 3: if the current index maximum value is greater than overall maximum value, then replace the overall maximum value with the current index maximum value."
                    },
                    {
                        "username": "almightyshiva",
                        "content": "why is for loop i<nums.length i should iterate all the values why is it less"
                    },
                    {
                        "username": "user4136j",
                        "content": "alternate explanation writing back into same array memory: https://www.youtube.com/watch?v=tmakGVOGV3A"
                    },
                    {
                        "username": "leewc",
                        "content": "I ran into this issue when trying the test case provided on the question, if you're like me where you usually copy paste the example as a test case and then clicking run code, you'll run into this.\\n\\nFirstly u\\\\u2212 is a Minus sign in Unicode.\\n\\nTurns out the example case used Unicode minus signs.\\n\\nNotice how the example,  `[\\u22122,1,\\u22123,4,\\u22121,2,1,\\u22125,4]` differs with  `[-2,1,-3,4,-1,2,1,-5,4]`, the signs are longer.\\n\\nPosting this here in hopes of helping people figure it out since I thought it was something wrong with my code."
                    },
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Can anyone try to solve this problem?\\nhttp://stackoverflow.com/questions/39084147/largest-sum-of-contiguous-subarray-no-larger-than-k"
                    },
                    {
                        "username": "shivansh100",
                        "content": "calculate prefix sum array, then while iterating use binarysearch or upperbound to get the value closest to sum K."
                    },
                    {
                        "username": "xiangu",
                        "content": "DP solution:\\n- Define dp[i] = max sum of sub-array ending with nums[i]\\n- result = max(dp) because the max sum subarray has to end at some element\\n- Base case: dp[0] = nums[0]\\n- Recurrence: dp[i] = nums[i] + max(0, dp[i-1])\\n\\nLet\\'s first accept the meaning of the dp array (I know it\\'s not natural to come up with this representation but let\\'s for now accept it. I will try to illustrate why we have this recurrence).\\n\\ninterpretation of the recurrence: To find the max subarray ending in element i, literally, it means we need to consider all subarrays that ends in element i:\\n\\n[element i],\\n[element i-1, element i],\\n[element i-2, element i-1, element i],\\n... \\n[element 0, ..., element i].\\n\\nThen we find the one with highest sum as dp[i]; that is, dp[i] = max(sum([element i]), sum([element i-1, element i]), ..., sum([element 0, ..., element i]))\\n\\n= nums[i] + max(sum([]), sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))\\n\\n\\n= nums[i] + max(0, sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1])) \\n\\n= nums[i] + max(0, *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*) \\n\\nHey, boy, look at this part *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*; this is exactly dp[i-1]!\\nThus, the recurrence equation can be expressed as dp[i] = nums[i] + max(0, dp[i-1]).\\n\\nNow, you can look at other posts to undersand how to further optimize this solution (on the space complexity from O(n) to O(1)) but I find this explanation most natural for first attempt!\\n\\n           \\n"
                    }
                ]
            },
            {
                "id": 1567101,
                "content": [
                    {
                        "username": "chentao169",
                        "content": "I solve this problem in O(n). But the hint says it would be solved by using the divide and conquer approach.\\nI cannot figure out how to do it with divide and conquer.\\nYou guys have ideas?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I think I found one divide-and-conquer solution with O(nlogn) time (slower than Kadane\\'s algorithm) and O(1) space (same as Kadane\\'s).\\n\\nSome insights: If we cut the original array into 2 equal halves, then the max subarray must be in either one of the 3 positions: completely in the left half, completely in the right half, or spanning across 2 halves. So, we can form 3 corresponding sub-problems to find the max array in each of these 3 positions, then choose the max of the 3 arrays to be the ultimate answer.\\n\\nThe first 2 subtasks can be solved using recursion, while the last one (max sub-array spanning across 2 halves) can be done in a pretty similar fashion as the Kadane\\'s algorithm (hint: iterate the array from the middle point to the 2 ends and utilize the `current_sum` variable).\\n\\nAnd that\\'s it. Hope you can find the solution!"
                    },
                    {
                        "username": "kolojoe",
                        "content": "My solution was O(log(n)) using divide and conquer (albeit definitely a bit more verbose than the DP methods using O(n)): https://leetcode.com/problems/maximum-subarray/solutions/2905607/recursive-o-log-n-mathematical-approach-summing-via-logical-continuity/"
                    },
                    {
                        "username": "xcznu",
                        "content": "I feel its misleading to instruct to \"find\" the subarray (int[]), when function is returning the max sum (int).  May be use another word for \"find\" - eg. \"calculate\" the sum of largest contigous subarray \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "coder_bgn",
                        "content": "[@ayooluwaadeleye17](/ayooluwaadeleye17) but how to find the subarray\\n....can u give the code here to find the subarray , im unable to find it"
                    },
                    {
                        "username": "johnppkyaw",
                        "content": "I agree.  That was confusing.  "
                    },
                    {
                        "username": "ayooluwaadeleye17",
                        "content": "Yes i was confused when i was trying to return the subarray and it ws wrong because I was supposed to return the sum"
                    },
                    {
                        "username": "usaar33",
                        "content": "Certainly, the O(n^3) algorithm (brute force) is \"easy\" (even a slightly optimized O(n^2) using sliding windows), but I fail to see how the O(n) algorithm (Kadane\\'s) is \"easy\".  Having done this in an interview setting, I found it more challenging than most \"medium\" problems here (subsets, iterative binary tree inorder traversal, permutations, group anagrams, merge intervals, just to name a few).  \\n\\n1. With the before-mentioned \"medium\" problems, basically understanding the problem definition and drawing it out and knowing recursion/core CS data structures -- you can pull off an algorithm pretty directly.   But even if you get as far as recognizing this as a 1-D DP problem, building the subproblems and advancing them aren\\'t obvious. (let alone convincing yourself what you are doing is valid)\\n2. That the algorithm has someone\\'s name attached to it (Kadane) makes me question whether it is trivial. :)\\n\\nAdmitedly, once you\\'ve done it before, it feels trivial to code. In that sense, this problem reminds me a bit of the linked list cycle problem (with no prior context) -- trivial in O(n) time/O(n) space - a lot harder (admitedly more difficult than coming up with Kadane\\'s algorithm) with O(1) space.\\n\\nAs a comparison to another leetcode problem, this feels about as challenging as [Best time to buy & sell stock with txn fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/), a 1D DP problem with not-so-obvious subproblems."
                    },
                    {
                        "username": "user0626kd",
                        "content": "tbh the \"1-d dp\" isn\\'t really a dp, it\\'s a greedy algorithm"
                    },
                    {
                        "username": "snrklyc",
                        "content": "Precisely. If the solution you seek has but one single way of doing it, it means you’re not seeking if the candidate is capable of reducing complexity, but if they happen to know the esoteric algorithm you know. Such questions are frowned upon in my company, I always tell new interviewers to never ask them. "
                    },
                    {
                        "username": "BenSwitala",
                        "content": "This is a hard problem, not an easy one!  An algorithm to solve it is named after a person, Kadane!"
                    },
                    {
                        "username": "20credi",
                        "content": "thank you"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Brute force solution doesn\\'t pass and Optimized solutions are not obvious."
                    },
                    {
                        "username": "_nik_",
                        "content": "Problem with brute force is that it is taking longer time and after using kadanes, it is only working for positive array not the negative ones."
                    },
                    {
                        "username": "nathanad",
                        "content": "I don\\'t understand why this is considered an easy question when it took University professors years to come up with an O(n)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) no he didnt lmao "
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "nice logic"
                    },
                    {
                        "username": "llulek",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) the problem is my name is not Kadane ;) "
                    },
                    {
                        "username": "petahertz",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) But how long did it take to find the one person who could solve it in a minute? :-)"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "You realise it took kadane a minute to figure it out?"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "its med"
                    },
                    {
                        "username": "Jayaramachandran",
                        "content": "Video explaining how to solve the maximum sub-array problem using the kadane\\'s algorithm\\n\\nhttps://youtu.be/Id_hZTV7_IA\\n\\n\\n\\nThe kadane algorithm helps us to compute the maximum sum at each index position. The core of kadane algorithm is, the maximum sum at any given index position is either the value at that index or the sum of value at current index position and the maximum sum at the previous index position.\\nLet\\u2019s see the pseudo code of kadane algorithm,\\nStep 1: Assign the zeroth index value to the current index maximum sum and overall maximum sum.\\nStep 2: Start from the index position one and iterate till n and find the max value between the current index position value and sum of current index position value and last index maximum sum.\\nStep 3: if the current index maximum value is greater than overall maximum value, then replace the overall maximum value with the current index maximum value."
                    },
                    {
                        "username": "almightyshiva",
                        "content": "why is for loop i<nums.length i should iterate all the values why is it less"
                    },
                    {
                        "username": "user4136j",
                        "content": "alternate explanation writing back into same array memory: https://www.youtube.com/watch?v=tmakGVOGV3A"
                    },
                    {
                        "username": "leewc",
                        "content": "I ran into this issue when trying the test case provided on the question, if you're like me where you usually copy paste the example as a test case and then clicking run code, you'll run into this.\\n\\nFirstly u\\\\u2212 is a Minus sign in Unicode.\\n\\nTurns out the example case used Unicode minus signs.\\n\\nNotice how the example,  `[\\u22122,1,\\u22123,4,\\u22121,2,1,\\u22125,4]` differs with  `[-2,1,-3,4,-1,2,1,-5,4]`, the signs are longer.\\n\\nPosting this here in hopes of helping people figure it out since I thought it was something wrong with my code."
                    },
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Can anyone try to solve this problem?\\nhttp://stackoverflow.com/questions/39084147/largest-sum-of-contiguous-subarray-no-larger-than-k"
                    },
                    {
                        "username": "shivansh100",
                        "content": "calculate prefix sum array, then while iterating use binarysearch or upperbound to get the value closest to sum K."
                    },
                    {
                        "username": "xiangu",
                        "content": "DP solution:\\n- Define dp[i] = max sum of sub-array ending with nums[i]\\n- result = max(dp) because the max sum subarray has to end at some element\\n- Base case: dp[0] = nums[0]\\n- Recurrence: dp[i] = nums[i] + max(0, dp[i-1])\\n\\nLet\\'s first accept the meaning of the dp array (I know it\\'s not natural to come up with this representation but let\\'s for now accept it. I will try to illustrate why we have this recurrence).\\n\\ninterpretation of the recurrence: To find the max subarray ending in element i, literally, it means we need to consider all subarrays that ends in element i:\\n\\n[element i],\\n[element i-1, element i],\\n[element i-2, element i-1, element i],\\n... \\n[element 0, ..., element i].\\n\\nThen we find the one with highest sum as dp[i]; that is, dp[i] = max(sum([element i]), sum([element i-1, element i]), ..., sum([element 0, ..., element i]))\\n\\n= nums[i] + max(sum([]), sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))\\n\\n\\n= nums[i] + max(0, sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1])) \\n\\n= nums[i] + max(0, *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*) \\n\\nHey, boy, look at this part *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*; this is exactly dp[i-1]!\\nThus, the recurrence equation can be expressed as dp[i] = nums[i] + max(0, dp[i-1]).\\n\\nNow, you can look at other posts to undersand how to further optimize this solution (on the space complexity from O(n) to O(1)) but I find this explanation most natural for first attempt!\\n\\n           \\n"
                    }
                ]
            },
            {
                "id": 1566592,
                "content": [
                    {
                        "username": "chentao169",
                        "content": "I solve this problem in O(n). But the hint says it would be solved by using the divide and conquer approach.\\nI cannot figure out how to do it with divide and conquer.\\nYou guys have ideas?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I think I found one divide-and-conquer solution with O(nlogn) time (slower than Kadane\\'s algorithm) and O(1) space (same as Kadane\\'s).\\n\\nSome insights: If we cut the original array into 2 equal halves, then the max subarray must be in either one of the 3 positions: completely in the left half, completely in the right half, or spanning across 2 halves. So, we can form 3 corresponding sub-problems to find the max array in each of these 3 positions, then choose the max of the 3 arrays to be the ultimate answer.\\n\\nThe first 2 subtasks can be solved using recursion, while the last one (max sub-array spanning across 2 halves) can be done in a pretty similar fashion as the Kadane\\'s algorithm (hint: iterate the array from the middle point to the 2 ends and utilize the `current_sum` variable).\\n\\nAnd that\\'s it. Hope you can find the solution!"
                    },
                    {
                        "username": "kolojoe",
                        "content": "My solution was O(log(n)) using divide and conquer (albeit definitely a bit more verbose than the DP methods using O(n)): https://leetcode.com/problems/maximum-subarray/solutions/2905607/recursive-o-log-n-mathematical-approach-summing-via-logical-continuity/"
                    },
                    {
                        "username": "xcznu",
                        "content": "I feel its misleading to instruct to \"find\" the subarray (int[]), when function is returning the max sum (int).  May be use another word for \"find\" - eg. \"calculate\" the sum of largest contigous subarray \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "coder_bgn",
                        "content": "[@ayooluwaadeleye17](/ayooluwaadeleye17) but how to find the subarray\\n....can u give the code here to find the subarray , im unable to find it"
                    },
                    {
                        "username": "johnppkyaw",
                        "content": "I agree.  That was confusing.  "
                    },
                    {
                        "username": "ayooluwaadeleye17",
                        "content": "Yes i was confused when i was trying to return the subarray and it ws wrong because I was supposed to return the sum"
                    },
                    {
                        "username": "usaar33",
                        "content": "Certainly, the O(n^3) algorithm (brute force) is \"easy\" (even a slightly optimized O(n^2) using sliding windows), but I fail to see how the O(n) algorithm (Kadane\\'s) is \"easy\".  Having done this in an interview setting, I found it more challenging than most \"medium\" problems here (subsets, iterative binary tree inorder traversal, permutations, group anagrams, merge intervals, just to name a few).  \\n\\n1. With the before-mentioned \"medium\" problems, basically understanding the problem definition and drawing it out and knowing recursion/core CS data structures -- you can pull off an algorithm pretty directly.   But even if you get as far as recognizing this as a 1-D DP problem, building the subproblems and advancing them aren\\'t obvious. (let alone convincing yourself what you are doing is valid)\\n2. That the algorithm has someone\\'s name attached to it (Kadane) makes me question whether it is trivial. :)\\n\\nAdmitedly, once you\\'ve done it before, it feels trivial to code. In that sense, this problem reminds me a bit of the linked list cycle problem (with no prior context) -- trivial in O(n) time/O(n) space - a lot harder (admitedly more difficult than coming up with Kadane\\'s algorithm) with O(1) space.\\n\\nAs a comparison to another leetcode problem, this feels about as challenging as [Best time to buy & sell stock with txn fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/), a 1D DP problem with not-so-obvious subproblems."
                    },
                    {
                        "username": "user0626kd",
                        "content": "tbh the \"1-d dp\" isn\\'t really a dp, it\\'s a greedy algorithm"
                    },
                    {
                        "username": "snrklyc",
                        "content": "Precisely. If the solution you seek has but one single way of doing it, it means you’re not seeking if the candidate is capable of reducing complexity, but if they happen to know the esoteric algorithm you know. Such questions are frowned upon in my company, I always tell new interviewers to never ask them. "
                    },
                    {
                        "username": "BenSwitala",
                        "content": "This is a hard problem, not an easy one!  An algorithm to solve it is named after a person, Kadane!"
                    },
                    {
                        "username": "20credi",
                        "content": "thank you"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Brute force solution doesn\\'t pass and Optimized solutions are not obvious."
                    },
                    {
                        "username": "_nik_",
                        "content": "Problem with brute force is that it is taking longer time and after using kadanes, it is only working for positive array not the negative ones."
                    },
                    {
                        "username": "nathanad",
                        "content": "I don\\'t understand why this is considered an easy question when it took University professors years to come up with an O(n)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) no he didnt lmao "
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "nice logic"
                    },
                    {
                        "username": "llulek",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) the problem is my name is not Kadane ;) "
                    },
                    {
                        "username": "petahertz",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) But how long did it take to find the one person who could solve it in a minute? :-)"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "You realise it took kadane a minute to figure it out?"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "its med"
                    },
                    {
                        "username": "Jayaramachandran",
                        "content": "Video explaining how to solve the maximum sub-array problem using the kadane\\'s algorithm\\n\\nhttps://youtu.be/Id_hZTV7_IA\\n\\n\\n\\nThe kadane algorithm helps us to compute the maximum sum at each index position. The core of kadane algorithm is, the maximum sum at any given index position is either the value at that index or the sum of value at current index position and the maximum sum at the previous index position.\\nLet\\u2019s see the pseudo code of kadane algorithm,\\nStep 1: Assign the zeroth index value to the current index maximum sum and overall maximum sum.\\nStep 2: Start from the index position one and iterate till n and find the max value between the current index position value and sum of current index position value and last index maximum sum.\\nStep 3: if the current index maximum value is greater than overall maximum value, then replace the overall maximum value with the current index maximum value."
                    },
                    {
                        "username": "almightyshiva",
                        "content": "why is for loop i<nums.length i should iterate all the values why is it less"
                    },
                    {
                        "username": "user4136j",
                        "content": "alternate explanation writing back into same array memory: https://www.youtube.com/watch?v=tmakGVOGV3A"
                    },
                    {
                        "username": "leewc",
                        "content": "I ran into this issue when trying the test case provided on the question, if you're like me where you usually copy paste the example as a test case and then clicking run code, you'll run into this.\\n\\nFirstly u\\\\u2212 is a Minus sign in Unicode.\\n\\nTurns out the example case used Unicode minus signs.\\n\\nNotice how the example,  `[\\u22122,1,\\u22123,4,\\u22121,2,1,\\u22125,4]` differs with  `[-2,1,-3,4,-1,2,1,-5,4]`, the signs are longer.\\n\\nPosting this here in hopes of helping people figure it out since I thought it was something wrong with my code."
                    },
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Can anyone try to solve this problem?\\nhttp://stackoverflow.com/questions/39084147/largest-sum-of-contiguous-subarray-no-larger-than-k"
                    },
                    {
                        "username": "shivansh100",
                        "content": "calculate prefix sum array, then while iterating use binarysearch or upperbound to get the value closest to sum K."
                    },
                    {
                        "username": "xiangu",
                        "content": "DP solution:\\n- Define dp[i] = max sum of sub-array ending with nums[i]\\n- result = max(dp) because the max sum subarray has to end at some element\\n- Base case: dp[0] = nums[0]\\n- Recurrence: dp[i] = nums[i] + max(0, dp[i-1])\\n\\nLet\\'s first accept the meaning of the dp array (I know it\\'s not natural to come up with this representation but let\\'s for now accept it. I will try to illustrate why we have this recurrence).\\n\\ninterpretation of the recurrence: To find the max subarray ending in element i, literally, it means we need to consider all subarrays that ends in element i:\\n\\n[element i],\\n[element i-1, element i],\\n[element i-2, element i-1, element i],\\n... \\n[element 0, ..., element i].\\n\\nThen we find the one with highest sum as dp[i]; that is, dp[i] = max(sum([element i]), sum([element i-1, element i]), ..., sum([element 0, ..., element i]))\\n\\n= nums[i] + max(sum([]), sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))\\n\\n\\n= nums[i] + max(0, sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1])) \\n\\n= nums[i] + max(0, *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*) \\n\\nHey, boy, look at this part *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*; this is exactly dp[i-1]!\\nThus, the recurrence equation can be expressed as dp[i] = nums[i] + max(0, dp[i-1]).\\n\\nNow, you can look at other posts to undersand how to further optimize this solution (on the space complexity from O(n) to O(1)) but I find this explanation most natural for first attempt!\\n\\n           \\n"
                    }
                ]
            },
            {
                "id": 1568228,
                "content": [
                    {
                        "username": "chentao169",
                        "content": "I solve this problem in O(n). But the hint says it would be solved by using the divide and conquer approach.\\nI cannot figure out how to do it with divide and conquer.\\nYou guys have ideas?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I think I found one divide-and-conquer solution with O(nlogn) time (slower than Kadane\\'s algorithm) and O(1) space (same as Kadane\\'s).\\n\\nSome insights: If we cut the original array into 2 equal halves, then the max subarray must be in either one of the 3 positions: completely in the left half, completely in the right half, or spanning across 2 halves. So, we can form 3 corresponding sub-problems to find the max array in each of these 3 positions, then choose the max of the 3 arrays to be the ultimate answer.\\n\\nThe first 2 subtasks can be solved using recursion, while the last one (max sub-array spanning across 2 halves) can be done in a pretty similar fashion as the Kadane\\'s algorithm (hint: iterate the array from the middle point to the 2 ends and utilize the `current_sum` variable).\\n\\nAnd that\\'s it. Hope you can find the solution!"
                    },
                    {
                        "username": "kolojoe",
                        "content": "My solution was O(log(n)) using divide and conquer (albeit definitely a bit more verbose than the DP methods using O(n)): https://leetcode.com/problems/maximum-subarray/solutions/2905607/recursive-o-log-n-mathematical-approach-summing-via-logical-continuity/"
                    },
                    {
                        "username": "xcznu",
                        "content": "I feel its misleading to instruct to \"find\" the subarray (int[]), when function is returning the max sum (int).  May be use another word for \"find\" - eg. \"calculate\" the sum of largest contigous subarray \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "coder_bgn",
                        "content": "[@ayooluwaadeleye17](/ayooluwaadeleye17) but how to find the subarray\\n....can u give the code here to find the subarray , im unable to find it"
                    },
                    {
                        "username": "johnppkyaw",
                        "content": "I agree.  That was confusing.  "
                    },
                    {
                        "username": "ayooluwaadeleye17",
                        "content": "Yes i was confused when i was trying to return the subarray and it ws wrong because I was supposed to return the sum"
                    },
                    {
                        "username": "usaar33",
                        "content": "Certainly, the O(n^3) algorithm (brute force) is \"easy\" (even a slightly optimized O(n^2) using sliding windows), but I fail to see how the O(n) algorithm (Kadane\\'s) is \"easy\".  Having done this in an interview setting, I found it more challenging than most \"medium\" problems here (subsets, iterative binary tree inorder traversal, permutations, group anagrams, merge intervals, just to name a few).  \\n\\n1. With the before-mentioned \"medium\" problems, basically understanding the problem definition and drawing it out and knowing recursion/core CS data structures -- you can pull off an algorithm pretty directly.   But even if you get as far as recognizing this as a 1-D DP problem, building the subproblems and advancing them aren\\'t obvious. (let alone convincing yourself what you are doing is valid)\\n2. That the algorithm has someone\\'s name attached to it (Kadane) makes me question whether it is trivial. :)\\n\\nAdmitedly, once you\\'ve done it before, it feels trivial to code. In that sense, this problem reminds me a bit of the linked list cycle problem (with no prior context) -- trivial in O(n) time/O(n) space - a lot harder (admitedly more difficult than coming up with Kadane\\'s algorithm) with O(1) space.\\n\\nAs a comparison to another leetcode problem, this feels about as challenging as [Best time to buy & sell stock with txn fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/), a 1D DP problem with not-so-obvious subproblems."
                    },
                    {
                        "username": "user0626kd",
                        "content": "tbh the \"1-d dp\" isn\\'t really a dp, it\\'s a greedy algorithm"
                    },
                    {
                        "username": "snrklyc",
                        "content": "Precisely. If the solution you seek has but one single way of doing it, it means you’re not seeking if the candidate is capable of reducing complexity, but if they happen to know the esoteric algorithm you know. Such questions are frowned upon in my company, I always tell new interviewers to never ask them. "
                    },
                    {
                        "username": "BenSwitala",
                        "content": "This is a hard problem, not an easy one!  An algorithm to solve it is named after a person, Kadane!"
                    },
                    {
                        "username": "20credi",
                        "content": "thank you"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Brute force solution doesn\\'t pass and Optimized solutions are not obvious."
                    },
                    {
                        "username": "_nik_",
                        "content": "Problem with brute force is that it is taking longer time and after using kadanes, it is only working for positive array not the negative ones."
                    },
                    {
                        "username": "nathanad",
                        "content": "I don\\'t understand why this is considered an easy question when it took University professors years to come up with an O(n)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) no he didnt lmao "
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "nice logic"
                    },
                    {
                        "username": "llulek",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) the problem is my name is not Kadane ;) "
                    },
                    {
                        "username": "petahertz",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) But how long did it take to find the one person who could solve it in a minute? :-)"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "You realise it took kadane a minute to figure it out?"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "its med"
                    },
                    {
                        "username": "Jayaramachandran",
                        "content": "Video explaining how to solve the maximum sub-array problem using the kadane\\'s algorithm\\n\\nhttps://youtu.be/Id_hZTV7_IA\\n\\n\\n\\nThe kadane algorithm helps us to compute the maximum sum at each index position. The core of kadane algorithm is, the maximum sum at any given index position is either the value at that index or the sum of value at current index position and the maximum sum at the previous index position.\\nLet\\u2019s see the pseudo code of kadane algorithm,\\nStep 1: Assign the zeroth index value to the current index maximum sum and overall maximum sum.\\nStep 2: Start from the index position one and iterate till n and find the max value between the current index position value and sum of current index position value and last index maximum sum.\\nStep 3: if the current index maximum value is greater than overall maximum value, then replace the overall maximum value with the current index maximum value."
                    },
                    {
                        "username": "almightyshiva",
                        "content": "why is for loop i<nums.length i should iterate all the values why is it less"
                    },
                    {
                        "username": "user4136j",
                        "content": "alternate explanation writing back into same array memory: https://www.youtube.com/watch?v=tmakGVOGV3A"
                    },
                    {
                        "username": "leewc",
                        "content": "I ran into this issue when trying the test case provided on the question, if you're like me where you usually copy paste the example as a test case and then clicking run code, you'll run into this.\\n\\nFirstly u\\\\u2212 is a Minus sign in Unicode.\\n\\nTurns out the example case used Unicode minus signs.\\n\\nNotice how the example,  `[\\u22122,1,\\u22123,4,\\u22121,2,1,\\u22125,4]` differs with  `[-2,1,-3,4,-1,2,1,-5,4]`, the signs are longer.\\n\\nPosting this here in hopes of helping people figure it out since I thought it was something wrong with my code."
                    },
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Can anyone try to solve this problem?\\nhttp://stackoverflow.com/questions/39084147/largest-sum-of-contiguous-subarray-no-larger-than-k"
                    },
                    {
                        "username": "shivansh100",
                        "content": "calculate prefix sum array, then while iterating use binarysearch or upperbound to get the value closest to sum K."
                    },
                    {
                        "username": "xiangu",
                        "content": "DP solution:\\n- Define dp[i] = max sum of sub-array ending with nums[i]\\n- result = max(dp) because the max sum subarray has to end at some element\\n- Base case: dp[0] = nums[0]\\n- Recurrence: dp[i] = nums[i] + max(0, dp[i-1])\\n\\nLet\\'s first accept the meaning of the dp array (I know it\\'s not natural to come up with this representation but let\\'s for now accept it. I will try to illustrate why we have this recurrence).\\n\\ninterpretation of the recurrence: To find the max subarray ending in element i, literally, it means we need to consider all subarrays that ends in element i:\\n\\n[element i],\\n[element i-1, element i],\\n[element i-2, element i-1, element i],\\n... \\n[element 0, ..., element i].\\n\\nThen we find the one with highest sum as dp[i]; that is, dp[i] = max(sum([element i]), sum([element i-1, element i]), ..., sum([element 0, ..., element i]))\\n\\n= nums[i] + max(sum([]), sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))\\n\\n\\n= nums[i] + max(0, sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1])) \\n\\n= nums[i] + max(0, *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*) \\n\\nHey, boy, look at this part *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*; this is exactly dp[i-1]!\\nThus, the recurrence equation can be expressed as dp[i] = nums[i] + max(0, dp[i-1]).\\n\\nNow, you can look at other posts to undersand how to further optimize this solution (on the space complexity from O(n) to O(1)) but I find this explanation most natural for first attempt!\\n\\n           \\n"
                    }
                ]
            },
            {
                "id": 1566067,
                "content": [
                    {
                        "username": "chentao169",
                        "content": "I solve this problem in O(n). But the hint says it would be solved by using the divide and conquer approach.\\nI cannot figure out how to do it with divide and conquer.\\nYou guys have ideas?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I think I found one divide-and-conquer solution with O(nlogn) time (slower than Kadane\\'s algorithm) and O(1) space (same as Kadane\\'s).\\n\\nSome insights: If we cut the original array into 2 equal halves, then the max subarray must be in either one of the 3 positions: completely in the left half, completely in the right half, or spanning across 2 halves. So, we can form 3 corresponding sub-problems to find the max array in each of these 3 positions, then choose the max of the 3 arrays to be the ultimate answer.\\n\\nThe first 2 subtasks can be solved using recursion, while the last one (max sub-array spanning across 2 halves) can be done in a pretty similar fashion as the Kadane\\'s algorithm (hint: iterate the array from the middle point to the 2 ends and utilize the `current_sum` variable).\\n\\nAnd that\\'s it. Hope you can find the solution!"
                    },
                    {
                        "username": "kolojoe",
                        "content": "My solution was O(log(n)) using divide and conquer (albeit definitely a bit more verbose than the DP methods using O(n)): https://leetcode.com/problems/maximum-subarray/solutions/2905607/recursive-o-log-n-mathematical-approach-summing-via-logical-continuity/"
                    },
                    {
                        "username": "xcznu",
                        "content": "I feel its misleading to instruct to \"find\" the subarray (int[]), when function is returning the max sum (int).  May be use another word for \"find\" - eg. \"calculate\" the sum of largest contigous subarray \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "coder_bgn",
                        "content": "[@ayooluwaadeleye17](/ayooluwaadeleye17) but how to find the subarray\\n....can u give the code here to find the subarray , im unable to find it"
                    },
                    {
                        "username": "johnppkyaw",
                        "content": "I agree.  That was confusing.  "
                    },
                    {
                        "username": "ayooluwaadeleye17",
                        "content": "Yes i was confused when i was trying to return the subarray and it ws wrong because I was supposed to return the sum"
                    },
                    {
                        "username": "usaar33",
                        "content": "Certainly, the O(n^3) algorithm (brute force) is \"easy\" (even a slightly optimized O(n^2) using sliding windows), but I fail to see how the O(n) algorithm (Kadane\\'s) is \"easy\".  Having done this in an interview setting, I found it more challenging than most \"medium\" problems here (subsets, iterative binary tree inorder traversal, permutations, group anagrams, merge intervals, just to name a few).  \\n\\n1. With the before-mentioned \"medium\" problems, basically understanding the problem definition and drawing it out and knowing recursion/core CS data structures -- you can pull off an algorithm pretty directly.   But even if you get as far as recognizing this as a 1-D DP problem, building the subproblems and advancing them aren\\'t obvious. (let alone convincing yourself what you are doing is valid)\\n2. That the algorithm has someone\\'s name attached to it (Kadane) makes me question whether it is trivial. :)\\n\\nAdmitedly, once you\\'ve done it before, it feels trivial to code. In that sense, this problem reminds me a bit of the linked list cycle problem (with no prior context) -- trivial in O(n) time/O(n) space - a lot harder (admitedly more difficult than coming up with Kadane\\'s algorithm) with O(1) space.\\n\\nAs a comparison to another leetcode problem, this feels about as challenging as [Best time to buy & sell stock with txn fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/), a 1D DP problem with not-so-obvious subproblems."
                    },
                    {
                        "username": "user0626kd",
                        "content": "tbh the \"1-d dp\" isn\\'t really a dp, it\\'s a greedy algorithm"
                    },
                    {
                        "username": "snrklyc",
                        "content": "Precisely. If the solution you seek has but one single way of doing it, it means you’re not seeking if the candidate is capable of reducing complexity, but if they happen to know the esoteric algorithm you know. Such questions are frowned upon in my company, I always tell new interviewers to never ask them. "
                    },
                    {
                        "username": "BenSwitala",
                        "content": "This is a hard problem, not an easy one!  An algorithm to solve it is named after a person, Kadane!"
                    },
                    {
                        "username": "20credi",
                        "content": "thank you"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Brute force solution doesn\\'t pass and Optimized solutions are not obvious."
                    },
                    {
                        "username": "_nik_",
                        "content": "Problem with brute force is that it is taking longer time and after using kadanes, it is only working for positive array not the negative ones."
                    },
                    {
                        "username": "nathanad",
                        "content": "I don\\'t understand why this is considered an easy question when it took University professors years to come up with an O(n)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) no he didnt lmao "
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "nice logic"
                    },
                    {
                        "username": "llulek",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) the problem is my name is not Kadane ;) "
                    },
                    {
                        "username": "petahertz",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) But how long did it take to find the one person who could solve it in a minute? :-)"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "You realise it took kadane a minute to figure it out?"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "its med"
                    },
                    {
                        "username": "Jayaramachandran",
                        "content": "Video explaining how to solve the maximum sub-array problem using the kadane\\'s algorithm\\n\\nhttps://youtu.be/Id_hZTV7_IA\\n\\n\\n\\nThe kadane algorithm helps us to compute the maximum sum at each index position. The core of kadane algorithm is, the maximum sum at any given index position is either the value at that index or the sum of value at current index position and the maximum sum at the previous index position.\\nLet\\u2019s see the pseudo code of kadane algorithm,\\nStep 1: Assign the zeroth index value to the current index maximum sum and overall maximum sum.\\nStep 2: Start from the index position one and iterate till n and find the max value between the current index position value and sum of current index position value and last index maximum sum.\\nStep 3: if the current index maximum value is greater than overall maximum value, then replace the overall maximum value with the current index maximum value."
                    },
                    {
                        "username": "almightyshiva",
                        "content": "why is for loop i<nums.length i should iterate all the values why is it less"
                    },
                    {
                        "username": "user4136j",
                        "content": "alternate explanation writing back into same array memory: https://www.youtube.com/watch?v=tmakGVOGV3A"
                    },
                    {
                        "username": "leewc",
                        "content": "I ran into this issue when trying the test case provided on the question, if you're like me where you usually copy paste the example as a test case and then clicking run code, you'll run into this.\\n\\nFirstly u\\\\u2212 is a Minus sign in Unicode.\\n\\nTurns out the example case used Unicode minus signs.\\n\\nNotice how the example,  `[\\u22122,1,\\u22123,4,\\u22121,2,1,\\u22125,4]` differs with  `[-2,1,-3,4,-1,2,1,-5,4]`, the signs are longer.\\n\\nPosting this here in hopes of helping people figure it out since I thought it was something wrong with my code."
                    },
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Can anyone try to solve this problem?\\nhttp://stackoverflow.com/questions/39084147/largest-sum-of-contiguous-subarray-no-larger-than-k"
                    },
                    {
                        "username": "shivansh100",
                        "content": "calculate prefix sum array, then while iterating use binarysearch or upperbound to get the value closest to sum K."
                    },
                    {
                        "username": "xiangu",
                        "content": "DP solution:\\n- Define dp[i] = max sum of sub-array ending with nums[i]\\n- result = max(dp) because the max sum subarray has to end at some element\\n- Base case: dp[0] = nums[0]\\n- Recurrence: dp[i] = nums[i] + max(0, dp[i-1])\\n\\nLet\\'s first accept the meaning of the dp array (I know it\\'s not natural to come up with this representation but let\\'s for now accept it. I will try to illustrate why we have this recurrence).\\n\\ninterpretation of the recurrence: To find the max subarray ending in element i, literally, it means we need to consider all subarrays that ends in element i:\\n\\n[element i],\\n[element i-1, element i],\\n[element i-2, element i-1, element i],\\n... \\n[element 0, ..., element i].\\n\\nThen we find the one with highest sum as dp[i]; that is, dp[i] = max(sum([element i]), sum([element i-1, element i]), ..., sum([element 0, ..., element i]))\\n\\n= nums[i] + max(sum([]), sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))\\n\\n\\n= nums[i] + max(0, sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1])) \\n\\n= nums[i] + max(0, *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*) \\n\\nHey, boy, look at this part *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*; this is exactly dp[i-1]!\\nThus, the recurrence equation can be expressed as dp[i] = nums[i] + max(0, dp[i-1]).\\n\\nNow, you can look at other posts to undersand how to further optimize this solution (on the space complexity from O(n) to O(1)) but I find this explanation most natural for first attempt!\\n\\n           \\n"
                    }
                ]
            },
            {
                "id": 1565942,
                "content": [
                    {
                        "username": "chentao169",
                        "content": "I solve this problem in O(n). But the hint says it would be solved by using the divide and conquer approach.\\nI cannot figure out how to do it with divide and conquer.\\nYou guys have ideas?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I think I found one divide-and-conquer solution with O(nlogn) time (slower than Kadane\\'s algorithm) and O(1) space (same as Kadane\\'s).\\n\\nSome insights: If we cut the original array into 2 equal halves, then the max subarray must be in either one of the 3 positions: completely in the left half, completely in the right half, or spanning across 2 halves. So, we can form 3 corresponding sub-problems to find the max array in each of these 3 positions, then choose the max of the 3 arrays to be the ultimate answer.\\n\\nThe first 2 subtasks can be solved using recursion, while the last one (max sub-array spanning across 2 halves) can be done in a pretty similar fashion as the Kadane\\'s algorithm (hint: iterate the array from the middle point to the 2 ends and utilize the `current_sum` variable).\\n\\nAnd that\\'s it. Hope you can find the solution!"
                    },
                    {
                        "username": "kolojoe",
                        "content": "My solution was O(log(n)) using divide and conquer (albeit definitely a bit more verbose than the DP methods using O(n)): https://leetcode.com/problems/maximum-subarray/solutions/2905607/recursive-o-log-n-mathematical-approach-summing-via-logical-continuity/"
                    },
                    {
                        "username": "xcznu",
                        "content": "I feel its misleading to instruct to \"find\" the subarray (int[]), when function is returning the max sum (int).  May be use another word for \"find\" - eg. \"calculate\" the sum of largest contigous subarray \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "coder_bgn",
                        "content": "[@ayooluwaadeleye17](/ayooluwaadeleye17) but how to find the subarray\\n....can u give the code here to find the subarray , im unable to find it"
                    },
                    {
                        "username": "johnppkyaw",
                        "content": "I agree.  That was confusing.  "
                    },
                    {
                        "username": "ayooluwaadeleye17",
                        "content": "Yes i was confused when i was trying to return the subarray and it ws wrong because I was supposed to return the sum"
                    },
                    {
                        "username": "usaar33",
                        "content": "Certainly, the O(n^3) algorithm (brute force) is \"easy\" (even a slightly optimized O(n^2) using sliding windows), but I fail to see how the O(n) algorithm (Kadane\\'s) is \"easy\".  Having done this in an interview setting, I found it more challenging than most \"medium\" problems here (subsets, iterative binary tree inorder traversal, permutations, group anagrams, merge intervals, just to name a few).  \\n\\n1. With the before-mentioned \"medium\" problems, basically understanding the problem definition and drawing it out and knowing recursion/core CS data structures -- you can pull off an algorithm pretty directly.   But even if you get as far as recognizing this as a 1-D DP problem, building the subproblems and advancing them aren\\'t obvious. (let alone convincing yourself what you are doing is valid)\\n2. That the algorithm has someone\\'s name attached to it (Kadane) makes me question whether it is trivial. :)\\n\\nAdmitedly, once you\\'ve done it before, it feels trivial to code. In that sense, this problem reminds me a bit of the linked list cycle problem (with no prior context) -- trivial in O(n) time/O(n) space - a lot harder (admitedly more difficult than coming up with Kadane\\'s algorithm) with O(1) space.\\n\\nAs a comparison to another leetcode problem, this feels about as challenging as [Best time to buy & sell stock with txn fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/), a 1D DP problem with not-so-obvious subproblems."
                    },
                    {
                        "username": "user0626kd",
                        "content": "tbh the \"1-d dp\" isn\\'t really a dp, it\\'s a greedy algorithm"
                    },
                    {
                        "username": "snrklyc",
                        "content": "Precisely. If the solution you seek has but one single way of doing it, it means you’re not seeking if the candidate is capable of reducing complexity, but if they happen to know the esoteric algorithm you know. Such questions are frowned upon in my company, I always tell new interviewers to never ask them. "
                    },
                    {
                        "username": "BenSwitala",
                        "content": "This is a hard problem, not an easy one!  An algorithm to solve it is named after a person, Kadane!"
                    },
                    {
                        "username": "20credi",
                        "content": "thank you"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Brute force solution doesn\\'t pass and Optimized solutions are not obvious."
                    },
                    {
                        "username": "_nik_",
                        "content": "Problem with brute force is that it is taking longer time and after using kadanes, it is only working for positive array not the negative ones."
                    },
                    {
                        "username": "nathanad",
                        "content": "I don\\'t understand why this is considered an easy question when it took University professors years to come up with an O(n)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) no he didnt lmao "
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "nice logic"
                    },
                    {
                        "username": "llulek",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) the problem is my name is not Kadane ;) "
                    },
                    {
                        "username": "petahertz",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) But how long did it take to find the one person who could solve it in a minute? :-)"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "You realise it took kadane a minute to figure it out?"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "its med"
                    },
                    {
                        "username": "Jayaramachandran",
                        "content": "Video explaining how to solve the maximum sub-array problem using the kadane\\'s algorithm\\n\\nhttps://youtu.be/Id_hZTV7_IA\\n\\n\\n\\nThe kadane algorithm helps us to compute the maximum sum at each index position. The core of kadane algorithm is, the maximum sum at any given index position is either the value at that index or the sum of value at current index position and the maximum sum at the previous index position.\\nLet\\u2019s see the pseudo code of kadane algorithm,\\nStep 1: Assign the zeroth index value to the current index maximum sum and overall maximum sum.\\nStep 2: Start from the index position one and iterate till n and find the max value between the current index position value and sum of current index position value and last index maximum sum.\\nStep 3: if the current index maximum value is greater than overall maximum value, then replace the overall maximum value with the current index maximum value."
                    },
                    {
                        "username": "almightyshiva",
                        "content": "why is for loop i<nums.length i should iterate all the values why is it less"
                    },
                    {
                        "username": "user4136j",
                        "content": "alternate explanation writing back into same array memory: https://www.youtube.com/watch?v=tmakGVOGV3A"
                    },
                    {
                        "username": "leewc",
                        "content": "I ran into this issue when trying the test case provided on the question, if you're like me where you usually copy paste the example as a test case and then clicking run code, you'll run into this.\\n\\nFirstly u\\\\u2212 is a Minus sign in Unicode.\\n\\nTurns out the example case used Unicode minus signs.\\n\\nNotice how the example,  `[\\u22122,1,\\u22123,4,\\u22121,2,1,\\u22125,4]` differs with  `[-2,1,-3,4,-1,2,1,-5,4]`, the signs are longer.\\n\\nPosting this here in hopes of helping people figure it out since I thought it was something wrong with my code."
                    },
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Can anyone try to solve this problem?\\nhttp://stackoverflow.com/questions/39084147/largest-sum-of-contiguous-subarray-no-larger-than-k"
                    },
                    {
                        "username": "shivansh100",
                        "content": "calculate prefix sum array, then while iterating use binarysearch or upperbound to get the value closest to sum K."
                    },
                    {
                        "username": "xiangu",
                        "content": "DP solution:\\n- Define dp[i] = max sum of sub-array ending with nums[i]\\n- result = max(dp) because the max sum subarray has to end at some element\\n- Base case: dp[0] = nums[0]\\n- Recurrence: dp[i] = nums[i] + max(0, dp[i-1])\\n\\nLet\\'s first accept the meaning of the dp array (I know it\\'s not natural to come up with this representation but let\\'s for now accept it. I will try to illustrate why we have this recurrence).\\n\\ninterpretation of the recurrence: To find the max subarray ending in element i, literally, it means we need to consider all subarrays that ends in element i:\\n\\n[element i],\\n[element i-1, element i],\\n[element i-2, element i-1, element i],\\n... \\n[element 0, ..., element i].\\n\\nThen we find the one with highest sum as dp[i]; that is, dp[i] = max(sum([element i]), sum([element i-1, element i]), ..., sum([element 0, ..., element i]))\\n\\n= nums[i] + max(sum([]), sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))\\n\\n\\n= nums[i] + max(0, sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1])) \\n\\n= nums[i] + max(0, *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*) \\n\\nHey, boy, look at this part *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*; this is exactly dp[i-1]!\\nThus, the recurrence equation can be expressed as dp[i] = nums[i] + max(0, dp[i-1]).\\n\\nNow, you can look at other posts to undersand how to further optimize this solution (on the space complexity from O(n) to O(1)) but I find this explanation most natural for first attempt!\\n\\n           \\n"
                    }
                ]
            },
            {
                "id": 1569914,
                "content": [
                    {
                        "username": "chentao169",
                        "content": "I solve this problem in O(n). But the hint says it would be solved by using the divide and conquer approach.\\nI cannot figure out how to do it with divide and conquer.\\nYou guys have ideas?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I think I found one divide-and-conquer solution with O(nlogn) time (slower than Kadane\\'s algorithm) and O(1) space (same as Kadane\\'s).\\n\\nSome insights: If we cut the original array into 2 equal halves, then the max subarray must be in either one of the 3 positions: completely in the left half, completely in the right half, or spanning across 2 halves. So, we can form 3 corresponding sub-problems to find the max array in each of these 3 positions, then choose the max of the 3 arrays to be the ultimate answer.\\n\\nThe first 2 subtasks can be solved using recursion, while the last one (max sub-array spanning across 2 halves) can be done in a pretty similar fashion as the Kadane\\'s algorithm (hint: iterate the array from the middle point to the 2 ends and utilize the `current_sum` variable).\\n\\nAnd that\\'s it. Hope you can find the solution!"
                    },
                    {
                        "username": "kolojoe",
                        "content": "My solution was O(log(n)) using divide and conquer (albeit definitely a bit more verbose than the DP methods using O(n)): https://leetcode.com/problems/maximum-subarray/solutions/2905607/recursive-o-log-n-mathematical-approach-summing-via-logical-continuity/"
                    },
                    {
                        "username": "xcznu",
                        "content": "I feel its misleading to instruct to \"find\" the subarray (int[]), when function is returning the max sum (int).  May be use another word for \"find\" - eg. \"calculate\" the sum of largest contigous subarray \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "coder_bgn",
                        "content": "[@ayooluwaadeleye17](/ayooluwaadeleye17) but how to find the subarray\\n....can u give the code here to find the subarray , im unable to find it"
                    },
                    {
                        "username": "johnppkyaw",
                        "content": "I agree.  That was confusing.  "
                    },
                    {
                        "username": "ayooluwaadeleye17",
                        "content": "Yes i was confused when i was trying to return the subarray and it ws wrong because I was supposed to return the sum"
                    },
                    {
                        "username": "usaar33",
                        "content": "Certainly, the O(n^3) algorithm (brute force) is \"easy\" (even a slightly optimized O(n^2) using sliding windows), but I fail to see how the O(n) algorithm (Kadane\\'s) is \"easy\".  Having done this in an interview setting, I found it more challenging than most \"medium\" problems here (subsets, iterative binary tree inorder traversal, permutations, group anagrams, merge intervals, just to name a few).  \\n\\n1. With the before-mentioned \"medium\" problems, basically understanding the problem definition and drawing it out and knowing recursion/core CS data structures -- you can pull off an algorithm pretty directly.   But even if you get as far as recognizing this as a 1-D DP problem, building the subproblems and advancing them aren\\'t obvious. (let alone convincing yourself what you are doing is valid)\\n2. That the algorithm has someone\\'s name attached to it (Kadane) makes me question whether it is trivial. :)\\n\\nAdmitedly, once you\\'ve done it before, it feels trivial to code. In that sense, this problem reminds me a bit of the linked list cycle problem (with no prior context) -- trivial in O(n) time/O(n) space - a lot harder (admitedly more difficult than coming up with Kadane\\'s algorithm) with O(1) space.\\n\\nAs a comparison to another leetcode problem, this feels about as challenging as [Best time to buy & sell stock with txn fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/), a 1D DP problem with not-so-obvious subproblems."
                    },
                    {
                        "username": "user0626kd",
                        "content": "tbh the \"1-d dp\" isn\\'t really a dp, it\\'s a greedy algorithm"
                    },
                    {
                        "username": "snrklyc",
                        "content": "Precisely. If the solution you seek has but one single way of doing it, it means you’re not seeking if the candidate is capable of reducing complexity, but if they happen to know the esoteric algorithm you know. Such questions are frowned upon in my company, I always tell new interviewers to never ask them. "
                    },
                    {
                        "username": "BenSwitala",
                        "content": "This is a hard problem, not an easy one!  An algorithm to solve it is named after a person, Kadane!"
                    },
                    {
                        "username": "20credi",
                        "content": "thank you"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Brute force solution doesn\\'t pass and Optimized solutions are not obvious."
                    },
                    {
                        "username": "_nik_",
                        "content": "Problem with brute force is that it is taking longer time and after using kadanes, it is only working for positive array not the negative ones."
                    },
                    {
                        "username": "nathanad",
                        "content": "I don\\'t understand why this is considered an easy question when it took University professors years to come up with an O(n)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) no he didnt lmao "
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "nice logic"
                    },
                    {
                        "username": "llulek",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) the problem is my name is not Kadane ;) "
                    },
                    {
                        "username": "petahertz",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) But how long did it take to find the one person who could solve it in a minute? :-)"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "You realise it took kadane a minute to figure it out?"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "its med"
                    },
                    {
                        "username": "Jayaramachandran",
                        "content": "Video explaining how to solve the maximum sub-array problem using the kadane\\'s algorithm\\n\\nhttps://youtu.be/Id_hZTV7_IA\\n\\n\\n\\nThe kadane algorithm helps us to compute the maximum sum at each index position. The core of kadane algorithm is, the maximum sum at any given index position is either the value at that index or the sum of value at current index position and the maximum sum at the previous index position.\\nLet\\u2019s see the pseudo code of kadane algorithm,\\nStep 1: Assign the zeroth index value to the current index maximum sum and overall maximum sum.\\nStep 2: Start from the index position one and iterate till n and find the max value between the current index position value and sum of current index position value and last index maximum sum.\\nStep 3: if the current index maximum value is greater than overall maximum value, then replace the overall maximum value with the current index maximum value."
                    },
                    {
                        "username": "almightyshiva",
                        "content": "why is for loop i<nums.length i should iterate all the values why is it less"
                    },
                    {
                        "username": "user4136j",
                        "content": "alternate explanation writing back into same array memory: https://www.youtube.com/watch?v=tmakGVOGV3A"
                    },
                    {
                        "username": "leewc",
                        "content": "I ran into this issue when trying the test case provided on the question, if you're like me where you usually copy paste the example as a test case and then clicking run code, you'll run into this.\\n\\nFirstly u\\\\u2212 is a Minus sign in Unicode.\\n\\nTurns out the example case used Unicode minus signs.\\n\\nNotice how the example,  `[\\u22122,1,\\u22123,4,\\u22121,2,1,\\u22125,4]` differs with  `[-2,1,-3,4,-1,2,1,-5,4]`, the signs are longer.\\n\\nPosting this here in hopes of helping people figure it out since I thought it was something wrong with my code."
                    },
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Can anyone try to solve this problem?\\nhttp://stackoverflow.com/questions/39084147/largest-sum-of-contiguous-subarray-no-larger-than-k"
                    },
                    {
                        "username": "shivansh100",
                        "content": "calculate prefix sum array, then while iterating use binarysearch or upperbound to get the value closest to sum K."
                    },
                    {
                        "username": "xiangu",
                        "content": "DP solution:\\n- Define dp[i] = max sum of sub-array ending with nums[i]\\n- result = max(dp) because the max sum subarray has to end at some element\\n- Base case: dp[0] = nums[0]\\n- Recurrence: dp[i] = nums[i] + max(0, dp[i-1])\\n\\nLet\\'s first accept the meaning of the dp array (I know it\\'s not natural to come up with this representation but let\\'s for now accept it. I will try to illustrate why we have this recurrence).\\n\\ninterpretation of the recurrence: To find the max subarray ending in element i, literally, it means we need to consider all subarrays that ends in element i:\\n\\n[element i],\\n[element i-1, element i],\\n[element i-2, element i-1, element i],\\n... \\n[element 0, ..., element i].\\n\\nThen we find the one with highest sum as dp[i]; that is, dp[i] = max(sum([element i]), sum([element i-1, element i]), ..., sum([element 0, ..., element i]))\\n\\n= nums[i] + max(sum([]), sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))\\n\\n\\n= nums[i] + max(0, sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1])) \\n\\n= nums[i] + max(0, *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*) \\n\\nHey, boy, look at this part *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*; this is exactly dp[i-1]!\\nThus, the recurrence equation can be expressed as dp[i] = nums[i] + max(0, dp[i-1]).\\n\\nNow, you can look at other posts to undersand how to further optimize this solution (on the space complexity from O(n) to O(1)) but I find this explanation most natural for first attempt!\\n\\n           \\n"
                    }
                ]
            },
            {
                "id": 1564960,
                "content": [
                    {
                        "username": "chentao169",
                        "content": "I solve this problem in O(n). But the hint says it would be solved by using the divide and conquer approach.\\nI cannot figure out how to do it with divide and conquer.\\nYou guys have ideas?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I think I found one divide-and-conquer solution with O(nlogn) time (slower than Kadane\\'s algorithm) and O(1) space (same as Kadane\\'s).\\n\\nSome insights: If we cut the original array into 2 equal halves, then the max subarray must be in either one of the 3 positions: completely in the left half, completely in the right half, or spanning across 2 halves. So, we can form 3 corresponding sub-problems to find the max array in each of these 3 positions, then choose the max of the 3 arrays to be the ultimate answer.\\n\\nThe first 2 subtasks can be solved using recursion, while the last one (max sub-array spanning across 2 halves) can be done in a pretty similar fashion as the Kadane\\'s algorithm (hint: iterate the array from the middle point to the 2 ends and utilize the `current_sum` variable).\\n\\nAnd that\\'s it. Hope you can find the solution!"
                    },
                    {
                        "username": "kolojoe",
                        "content": "My solution was O(log(n)) using divide and conquer (albeit definitely a bit more verbose than the DP methods using O(n)): https://leetcode.com/problems/maximum-subarray/solutions/2905607/recursive-o-log-n-mathematical-approach-summing-via-logical-continuity/"
                    },
                    {
                        "username": "xcznu",
                        "content": "I feel its misleading to instruct to \"find\" the subarray (int[]), when function is returning the max sum (int).  May be use another word for \"find\" - eg. \"calculate\" the sum of largest contigous subarray \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "coder_bgn",
                        "content": "[@ayooluwaadeleye17](/ayooluwaadeleye17) but how to find the subarray\\n....can u give the code here to find the subarray , im unable to find it"
                    },
                    {
                        "username": "johnppkyaw",
                        "content": "I agree.  That was confusing.  "
                    },
                    {
                        "username": "ayooluwaadeleye17",
                        "content": "Yes i was confused when i was trying to return the subarray and it ws wrong because I was supposed to return the sum"
                    },
                    {
                        "username": "usaar33",
                        "content": "Certainly, the O(n^3) algorithm (brute force) is \"easy\" (even a slightly optimized O(n^2) using sliding windows), but I fail to see how the O(n) algorithm (Kadane\\'s) is \"easy\".  Having done this in an interview setting, I found it more challenging than most \"medium\" problems here (subsets, iterative binary tree inorder traversal, permutations, group anagrams, merge intervals, just to name a few).  \\n\\n1. With the before-mentioned \"medium\" problems, basically understanding the problem definition and drawing it out and knowing recursion/core CS data structures -- you can pull off an algorithm pretty directly.   But even if you get as far as recognizing this as a 1-D DP problem, building the subproblems and advancing them aren\\'t obvious. (let alone convincing yourself what you are doing is valid)\\n2. That the algorithm has someone\\'s name attached to it (Kadane) makes me question whether it is trivial. :)\\n\\nAdmitedly, once you\\'ve done it before, it feels trivial to code. In that sense, this problem reminds me a bit of the linked list cycle problem (with no prior context) -- trivial in O(n) time/O(n) space - a lot harder (admitedly more difficult than coming up with Kadane\\'s algorithm) with O(1) space.\\n\\nAs a comparison to another leetcode problem, this feels about as challenging as [Best time to buy & sell stock with txn fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/), a 1D DP problem with not-so-obvious subproblems."
                    },
                    {
                        "username": "user0626kd",
                        "content": "tbh the \"1-d dp\" isn\\'t really a dp, it\\'s a greedy algorithm"
                    },
                    {
                        "username": "snrklyc",
                        "content": "Precisely. If the solution you seek has but one single way of doing it, it means you’re not seeking if the candidate is capable of reducing complexity, but if they happen to know the esoteric algorithm you know. Such questions are frowned upon in my company, I always tell new interviewers to never ask them. "
                    },
                    {
                        "username": "BenSwitala",
                        "content": "This is a hard problem, not an easy one!  An algorithm to solve it is named after a person, Kadane!"
                    },
                    {
                        "username": "20credi",
                        "content": "thank you"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Brute force solution doesn\\'t pass and Optimized solutions are not obvious."
                    },
                    {
                        "username": "_nik_",
                        "content": "Problem with brute force is that it is taking longer time and after using kadanes, it is only working for positive array not the negative ones."
                    },
                    {
                        "username": "nathanad",
                        "content": "I don\\'t understand why this is considered an easy question when it took University professors years to come up with an O(n)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) no he didnt lmao "
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "nice logic"
                    },
                    {
                        "username": "llulek",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) the problem is my name is not Kadane ;) "
                    },
                    {
                        "username": "petahertz",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) But how long did it take to find the one person who could solve it in a minute? :-)"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "You realise it took kadane a minute to figure it out?"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "its med"
                    },
                    {
                        "username": "Jayaramachandran",
                        "content": "Video explaining how to solve the maximum sub-array problem using the kadane\\'s algorithm\\n\\nhttps://youtu.be/Id_hZTV7_IA\\n\\n\\n\\nThe kadane algorithm helps us to compute the maximum sum at each index position. The core of kadane algorithm is, the maximum sum at any given index position is either the value at that index or the sum of value at current index position and the maximum sum at the previous index position.\\nLet\\u2019s see the pseudo code of kadane algorithm,\\nStep 1: Assign the zeroth index value to the current index maximum sum and overall maximum sum.\\nStep 2: Start from the index position one and iterate till n and find the max value between the current index position value and sum of current index position value and last index maximum sum.\\nStep 3: if the current index maximum value is greater than overall maximum value, then replace the overall maximum value with the current index maximum value."
                    },
                    {
                        "username": "almightyshiva",
                        "content": "why is for loop i<nums.length i should iterate all the values why is it less"
                    },
                    {
                        "username": "user4136j",
                        "content": "alternate explanation writing back into same array memory: https://www.youtube.com/watch?v=tmakGVOGV3A"
                    },
                    {
                        "username": "leewc",
                        "content": "I ran into this issue when trying the test case provided on the question, if you're like me where you usually copy paste the example as a test case and then clicking run code, you'll run into this.\\n\\nFirstly u\\\\u2212 is a Minus sign in Unicode.\\n\\nTurns out the example case used Unicode minus signs.\\n\\nNotice how the example,  `[\\u22122,1,\\u22123,4,\\u22121,2,1,\\u22125,4]` differs with  `[-2,1,-3,4,-1,2,1,-5,4]`, the signs are longer.\\n\\nPosting this here in hopes of helping people figure it out since I thought it was something wrong with my code."
                    },
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Can anyone try to solve this problem?\\nhttp://stackoverflow.com/questions/39084147/largest-sum-of-contiguous-subarray-no-larger-than-k"
                    },
                    {
                        "username": "shivansh100",
                        "content": "calculate prefix sum array, then while iterating use binarysearch or upperbound to get the value closest to sum K."
                    },
                    {
                        "username": "xiangu",
                        "content": "DP solution:\\n- Define dp[i] = max sum of sub-array ending with nums[i]\\n- result = max(dp) because the max sum subarray has to end at some element\\n- Base case: dp[0] = nums[0]\\n- Recurrence: dp[i] = nums[i] + max(0, dp[i-1])\\n\\nLet\\'s first accept the meaning of the dp array (I know it\\'s not natural to come up with this representation but let\\'s for now accept it. I will try to illustrate why we have this recurrence).\\n\\ninterpretation of the recurrence: To find the max subarray ending in element i, literally, it means we need to consider all subarrays that ends in element i:\\n\\n[element i],\\n[element i-1, element i],\\n[element i-2, element i-1, element i],\\n... \\n[element 0, ..., element i].\\n\\nThen we find the one with highest sum as dp[i]; that is, dp[i] = max(sum([element i]), sum([element i-1, element i]), ..., sum([element 0, ..., element i]))\\n\\n= nums[i] + max(sum([]), sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))\\n\\n\\n= nums[i] + max(0, sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1])) \\n\\n= nums[i] + max(0, *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*) \\n\\nHey, boy, look at this part *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*; this is exactly dp[i-1]!\\nThus, the recurrence equation can be expressed as dp[i] = nums[i] + max(0, dp[i-1]).\\n\\nNow, you can look at other posts to undersand how to further optimize this solution (on the space complexity from O(n) to O(1)) but I find this explanation most natural for first attempt!\\n\\n           \\n"
                    }
                ]
            },
            {
                "id": 1568734,
                "content": [
                    {
                        "username": "chentao169",
                        "content": "I solve this problem in O(n). But the hint says it would be solved by using the divide and conquer approach.\\nI cannot figure out how to do it with divide and conquer.\\nYou guys have ideas?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I think I found one divide-and-conquer solution with O(nlogn) time (slower than Kadane\\'s algorithm) and O(1) space (same as Kadane\\'s).\\n\\nSome insights: If we cut the original array into 2 equal halves, then the max subarray must be in either one of the 3 positions: completely in the left half, completely in the right half, or spanning across 2 halves. So, we can form 3 corresponding sub-problems to find the max array in each of these 3 positions, then choose the max of the 3 arrays to be the ultimate answer.\\n\\nThe first 2 subtasks can be solved using recursion, while the last one (max sub-array spanning across 2 halves) can be done in a pretty similar fashion as the Kadane\\'s algorithm (hint: iterate the array from the middle point to the 2 ends and utilize the `current_sum` variable).\\n\\nAnd that\\'s it. Hope you can find the solution!"
                    },
                    {
                        "username": "kolojoe",
                        "content": "My solution was O(log(n)) using divide and conquer (albeit definitely a bit more verbose than the DP methods using O(n)): https://leetcode.com/problems/maximum-subarray/solutions/2905607/recursive-o-log-n-mathematical-approach-summing-via-logical-continuity/"
                    },
                    {
                        "username": "xcznu",
                        "content": "I feel its misleading to instruct to \"find\" the subarray (int[]), when function is returning the max sum (int).  May be use another word for \"find\" - eg. \"calculate\" the sum of largest contigous subarray \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "coder_bgn",
                        "content": "[@ayooluwaadeleye17](/ayooluwaadeleye17) but how to find the subarray\\n....can u give the code here to find the subarray , im unable to find it"
                    },
                    {
                        "username": "johnppkyaw",
                        "content": "I agree.  That was confusing.  "
                    },
                    {
                        "username": "ayooluwaadeleye17",
                        "content": "Yes i was confused when i was trying to return the subarray and it ws wrong because I was supposed to return the sum"
                    },
                    {
                        "username": "usaar33",
                        "content": "Certainly, the O(n^3) algorithm (brute force) is \"easy\" (even a slightly optimized O(n^2) using sliding windows), but I fail to see how the O(n) algorithm (Kadane\\'s) is \"easy\".  Having done this in an interview setting, I found it more challenging than most \"medium\" problems here (subsets, iterative binary tree inorder traversal, permutations, group anagrams, merge intervals, just to name a few).  \\n\\n1. With the before-mentioned \"medium\" problems, basically understanding the problem definition and drawing it out and knowing recursion/core CS data structures -- you can pull off an algorithm pretty directly.   But even if you get as far as recognizing this as a 1-D DP problem, building the subproblems and advancing them aren\\'t obvious. (let alone convincing yourself what you are doing is valid)\\n2. That the algorithm has someone\\'s name attached to it (Kadane) makes me question whether it is trivial. :)\\n\\nAdmitedly, once you\\'ve done it before, it feels trivial to code. In that sense, this problem reminds me a bit of the linked list cycle problem (with no prior context) -- trivial in O(n) time/O(n) space - a lot harder (admitedly more difficult than coming up with Kadane\\'s algorithm) with O(1) space.\\n\\nAs a comparison to another leetcode problem, this feels about as challenging as [Best time to buy & sell stock with txn fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/), a 1D DP problem with not-so-obvious subproblems."
                    },
                    {
                        "username": "user0626kd",
                        "content": "tbh the \"1-d dp\" isn\\'t really a dp, it\\'s a greedy algorithm"
                    },
                    {
                        "username": "snrklyc",
                        "content": "Precisely. If the solution you seek has but one single way of doing it, it means you’re not seeking if the candidate is capable of reducing complexity, but if they happen to know the esoteric algorithm you know. Such questions are frowned upon in my company, I always tell new interviewers to never ask them. "
                    },
                    {
                        "username": "BenSwitala",
                        "content": "This is a hard problem, not an easy one!  An algorithm to solve it is named after a person, Kadane!"
                    },
                    {
                        "username": "20credi",
                        "content": "thank you"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Brute force solution doesn\\'t pass and Optimized solutions are not obvious."
                    },
                    {
                        "username": "_nik_",
                        "content": "Problem with brute force is that it is taking longer time and after using kadanes, it is only working for positive array not the negative ones."
                    },
                    {
                        "username": "nathanad",
                        "content": "I don\\'t understand why this is considered an easy question when it took University professors years to come up with an O(n)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) no he didnt lmao "
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "nice logic"
                    },
                    {
                        "username": "llulek",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) the problem is my name is not Kadane ;) "
                    },
                    {
                        "username": "petahertz",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) But how long did it take to find the one person who could solve it in a minute? :-)"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "You realise it took kadane a minute to figure it out?"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "its med"
                    },
                    {
                        "username": "Jayaramachandran",
                        "content": "Video explaining how to solve the maximum sub-array problem using the kadane\\'s algorithm\\n\\nhttps://youtu.be/Id_hZTV7_IA\\n\\n\\n\\nThe kadane algorithm helps us to compute the maximum sum at each index position. The core of kadane algorithm is, the maximum sum at any given index position is either the value at that index or the sum of value at current index position and the maximum sum at the previous index position.\\nLet\\u2019s see the pseudo code of kadane algorithm,\\nStep 1: Assign the zeroth index value to the current index maximum sum and overall maximum sum.\\nStep 2: Start from the index position one and iterate till n and find the max value between the current index position value and sum of current index position value and last index maximum sum.\\nStep 3: if the current index maximum value is greater than overall maximum value, then replace the overall maximum value with the current index maximum value."
                    },
                    {
                        "username": "almightyshiva",
                        "content": "why is for loop i<nums.length i should iterate all the values why is it less"
                    },
                    {
                        "username": "user4136j",
                        "content": "alternate explanation writing back into same array memory: https://www.youtube.com/watch?v=tmakGVOGV3A"
                    },
                    {
                        "username": "leewc",
                        "content": "I ran into this issue when trying the test case provided on the question, if you're like me where you usually copy paste the example as a test case and then clicking run code, you'll run into this.\\n\\nFirstly u\\\\u2212 is a Minus sign in Unicode.\\n\\nTurns out the example case used Unicode minus signs.\\n\\nNotice how the example,  `[\\u22122,1,\\u22123,4,\\u22121,2,1,\\u22125,4]` differs with  `[-2,1,-3,4,-1,2,1,-5,4]`, the signs are longer.\\n\\nPosting this here in hopes of helping people figure it out since I thought it was something wrong with my code."
                    },
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Can anyone try to solve this problem?\\nhttp://stackoverflow.com/questions/39084147/largest-sum-of-contiguous-subarray-no-larger-than-k"
                    },
                    {
                        "username": "shivansh100",
                        "content": "calculate prefix sum array, then while iterating use binarysearch or upperbound to get the value closest to sum K."
                    },
                    {
                        "username": "xiangu",
                        "content": "DP solution:\\n- Define dp[i] = max sum of sub-array ending with nums[i]\\n- result = max(dp) because the max sum subarray has to end at some element\\n- Base case: dp[0] = nums[0]\\n- Recurrence: dp[i] = nums[i] + max(0, dp[i-1])\\n\\nLet\\'s first accept the meaning of the dp array (I know it\\'s not natural to come up with this representation but let\\'s for now accept it. I will try to illustrate why we have this recurrence).\\n\\ninterpretation of the recurrence: To find the max subarray ending in element i, literally, it means we need to consider all subarrays that ends in element i:\\n\\n[element i],\\n[element i-1, element i],\\n[element i-2, element i-1, element i],\\n... \\n[element 0, ..., element i].\\n\\nThen we find the one with highest sum as dp[i]; that is, dp[i] = max(sum([element i]), sum([element i-1, element i]), ..., sum([element 0, ..., element i]))\\n\\n= nums[i] + max(sum([]), sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))\\n\\n\\n= nums[i] + max(0, sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1])) \\n\\n= nums[i] + max(0, *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*) \\n\\nHey, boy, look at this part *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*; this is exactly dp[i-1]!\\nThus, the recurrence equation can be expressed as dp[i] = nums[i] + max(0, dp[i-1]).\\n\\nNow, you can look at other posts to undersand how to further optimize this solution (on the space complexity from O(n) to O(1)) but I find this explanation most natural for first attempt!\\n\\n           \\n"
                    }
                ]
            },
            {
                "id": 1565011,
                "content": [
                    {
                        "username": "chentao169",
                        "content": "I solve this problem in O(n). But the hint says it would be solved by using the divide and conquer approach.\\nI cannot figure out how to do it with divide and conquer.\\nYou guys have ideas?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I think I found one divide-and-conquer solution with O(nlogn) time (slower than Kadane\\'s algorithm) and O(1) space (same as Kadane\\'s).\\n\\nSome insights: If we cut the original array into 2 equal halves, then the max subarray must be in either one of the 3 positions: completely in the left half, completely in the right half, or spanning across 2 halves. So, we can form 3 corresponding sub-problems to find the max array in each of these 3 positions, then choose the max of the 3 arrays to be the ultimate answer.\\n\\nThe first 2 subtasks can be solved using recursion, while the last one (max sub-array spanning across 2 halves) can be done in a pretty similar fashion as the Kadane\\'s algorithm (hint: iterate the array from the middle point to the 2 ends and utilize the `current_sum` variable).\\n\\nAnd that\\'s it. Hope you can find the solution!"
                    },
                    {
                        "username": "kolojoe",
                        "content": "My solution was O(log(n)) using divide and conquer (albeit definitely a bit more verbose than the DP methods using O(n)): https://leetcode.com/problems/maximum-subarray/solutions/2905607/recursive-o-log-n-mathematical-approach-summing-via-logical-continuity/"
                    },
                    {
                        "username": "xcznu",
                        "content": "I feel its misleading to instruct to \"find\" the subarray (int[]), when function is returning the max sum (int).  May be use another word for \"find\" - eg. \"calculate\" the sum of largest contigous subarray \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "coder_bgn",
                        "content": "[@ayooluwaadeleye17](/ayooluwaadeleye17) but how to find the subarray\\n....can u give the code here to find the subarray , im unable to find it"
                    },
                    {
                        "username": "johnppkyaw",
                        "content": "I agree.  That was confusing.  "
                    },
                    {
                        "username": "ayooluwaadeleye17",
                        "content": "Yes i was confused when i was trying to return the subarray and it ws wrong because I was supposed to return the sum"
                    },
                    {
                        "username": "usaar33",
                        "content": "Certainly, the O(n^3) algorithm (brute force) is \"easy\" (even a slightly optimized O(n^2) using sliding windows), but I fail to see how the O(n) algorithm (Kadane\\'s) is \"easy\".  Having done this in an interview setting, I found it more challenging than most \"medium\" problems here (subsets, iterative binary tree inorder traversal, permutations, group anagrams, merge intervals, just to name a few).  \\n\\n1. With the before-mentioned \"medium\" problems, basically understanding the problem definition and drawing it out and knowing recursion/core CS data structures -- you can pull off an algorithm pretty directly.   But even if you get as far as recognizing this as a 1-D DP problem, building the subproblems and advancing them aren\\'t obvious. (let alone convincing yourself what you are doing is valid)\\n2. That the algorithm has someone\\'s name attached to it (Kadane) makes me question whether it is trivial. :)\\n\\nAdmitedly, once you\\'ve done it before, it feels trivial to code. In that sense, this problem reminds me a bit of the linked list cycle problem (with no prior context) -- trivial in O(n) time/O(n) space - a lot harder (admitedly more difficult than coming up with Kadane\\'s algorithm) with O(1) space.\\n\\nAs a comparison to another leetcode problem, this feels about as challenging as [Best time to buy & sell stock with txn fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/), a 1D DP problem with not-so-obvious subproblems."
                    },
                    {
                        "username": "user0626kd",
                        "content": "tbh the \"1-d dp\" isn\\'t really a dp, it\\'s a greedy algorithm"
                    },
                    {
                        "username": "snrklyc",
                        "content": "Precisely. If the solution you seek has but one single way of doing it, it means you’re not seeking if the candidate is capable of reducing complexity, but if they happen to know the esoteric algorithm you know. Such questions are frowned upon in my company, I always tell new interviewers to never ask them. "
                    },
                    {
                        "username": "BenSwitala",
                        "content": "This is a hard problem, not an easy one!  An algorithm to solve it is named after a person, Kadane!"
                    },
                    {
                        "username": "20credi",
                        "content": "thank you"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Brute force solution doesn\\'t pass and Optimized solutions are not obvious."
                    },
                    {
                        "username": "_nik_",
                        "content": "Problem with brute force is that it is taking longer time and after using kadanes, it is only working for positive array not the negative ones."
                    },
                    {
                        "username": "nathanad",
                        "content": "I don\\'t understand why this is considered an easy question when it took University professors years to come up with an O(n)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) no he didnt lmao "
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "nice logic"
                    },
                    {
                        "username": "llulek",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) the problem is my name is not Kadane ;) "
                    },
                    {
                        "username": "petahertz",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) But how long did it take to find the one person who could solve it in a minute? :-)"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "You realise it took kadane a minute to figure it out?"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "its med"
                    },
                    {
                        "username": "Jayaramachandran",
                        "content": "Video explaining how to solve the maximum sub-array problem using the kadane\\'s algorithm\\n\\nhttps://youtu.be/Id_hZTV7_IA\\n\\n\\n\\nThe kadane algorithm helps us to compute the maximum sum at each index position. The core of kadane algorithm is, the maximum sum at any given index position is either the value at that index or the sum of value at current index position and the maximum sum at the previous index position.\\nLet\\u2019s see the pseudo code of kadane algorithm,\\nStep 1: Assign the zeroth index value to the current index maximum sum and overall maximum sum.\\nStep 2: Start from the index position one and iterate till n and find the max value between the current index position value and sum of current index position value and last index maximum sum.\\nStep 3: if the current index maximum value is greater than overall maximum value, then replace the overall maximum value with the current index maximum value."
                    },
                    {
                        "username": "almightyshiva",
                        "content": "why is for loop i<nums.length i should iterate all the values why is it less"
                    },
                    {
                        "username": "user4136j",
                        "content": "alternate explanation writing back into same array memory: https://www.youtube.com/watch?v=tmakGVOGV3A"
                    },
                    {
                        "username": "leewc",
                        "content": "I ran into this issue when trying the test case provided on the question, if you're like me where you usually copy paste the example as a test case and then clicking run code, you'll run into this.\\n\\nFirstly u\\\\u2212 is a Minus sign in Unicode.\\n\\nTurns out the example case used Unicode minus signs.\\n\\nNotice how the example,  `[\\u22122,1,\\u22123,4,\\u22121,2,1,\\u22125,4]` differs with  `[-2,1,-3,4,-1,2,1,-5,4]`, the signs are longer.\\n\\nPosting this here in hopes of helping people figure it out since I thought it was something wrong with my code."
                    },
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Can anyone try to solve this problem?\\nhttp://stackoverflow.com/questions/39084147/largest-sum-of-contiguous-subarray-no-larger-than-k"
                    },
                    {
                        "username": "shivansh100",
                        "content": "calculate prefix sum array, then while iterating use binarysearch or upperbound to get the value closest to sum K."
                    },
                    {
                        "username": "xiangu",
                        "content": "DP solution:\\n- Define dp[i] = max sum of sub-array ending with nums[i]\\n- result = max(dp) because the max sum subarray has to end at some element\\n- Base case: dp[0] = nums[0]\\n- Recurrence: dp[i] = nums[i] + max(0, dp[i-1])\\n\\nLet\\'s first accept the meaning of the dp array (I know it\\'s not natural to come up with this representation but let\\'s for now accept it. I will try to illustrate why we have this recurrence).\\n\\ninterpretation of the recurrence: To find the max subarray ending in element i, literally, it means we need to consider all subarrays that ends in element i:\\n\\n[element i],\\n[element i-1, element i],\\n[element i-2, element i-1, element i],\\n... \\n[element 0, ..., element i].\\n\\nThen we find the one with highest sum as dp[i]; that is, dp[i] = max(sum([element i]), sum([element i-1, element i]), ..., sum([element 0, ..., element i]))\\n\\n= nums[i] + max(sum([]), sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))\\n\\n\\n= nums[i] + max(0, sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1])) \\n\\n= nums[i] + max(0, *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*) \\n\\nHey, boy, look at this part *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*; this is exactly dp[i-1]!\\nThus, the recurrence equation can be expressed as dp[i] = nums[i] + max(0, dp[i-1]).\\n\\nNow, you can look at other posts to undersand how to further optimize this solution (on the space complexity from O(n) to O(1)) but I find this explanation most natural for first attempt!\\n\\n           \\n"
                    }
                ]
            },
            {
                "id": 1566595,
                "content": [
                    {
                        "username": "chentao169",
                        "content": "I solve this problem in O(n). But the hint says it would be solved by using the divide and conquer approach.\\nI cannot figure out how to do it with divide and conquer.\\nYou guys have ideas?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I think I found one divide-and-conquer solution with O(nlogn) time (slower than Kadane\\'s algorithm) and O(1) space (same as Kadane\\'s).\\n\\nSome insights: If we cut the original array into 2 equal halves, then the max subarray must be in either one of the 3 positions: completely in the left half, completely in the right half, or spanning across 2 halves. So, we can form 3 corresponding sub-problems to find the max array in each of these 3 positions, then choose the max of the 3 arrays to be the ultimate answer.\\n\\nThe first 2 subtasks can be solved using recursion, while the last one (max sub-array spanning across 2 halves) can be done in a pretty similar fashion as the Kadane\\'s algorithm (hint: iterate the array from the middle point to the 2 ends and utilize the `current_sum` variable).\\n\\nAnd that\\'s it. Hope you can find the solution!"
                    },
                    {
                        "username": "kolojoe",
                        "content": "My solution was O(log(n)) using divide and conquer (albeit definitely a bit more verbose than the DP methods using O(n)): https://leetcode.com/problems/maximum-subarray/solutions/2905607/recursive-o-log-n-mathematical-approach-summing-via-logical-continuity/"
                    },
                    {
                        "username": "xcznu",
                        "content": "I feel its misleading to instruct to \"find\" the subarray (int[]), when function is returning the max sum (int).  May be use another word for \"find\" - eg. \"calculate\" the sum of largest contigous subarray \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "coder_bgn",
                        "content": "[@ayooluwaadeleye17](/ayooluwaadeleye17) but how to find the subarray\\n....can u give the code here to find the subarray , im unable to find it"
                    },
                    {
                        "username": "johnppkyaw",
                        "content": "I agree.  That was confusing.  "
                    },
                    {
                        "username": "ayooluwaadeleye17",
                        "content": "Yes i was confused when i was trying to return the subarray and it ws wrong because I was supposed to return the sum"
                    },
                    {
                        "username": "usaar33",
                        "content": "Certainly, the O(n^3) algorithm (brute force) is \"easy\" (even a slightly optimized O(n^2) using sliding windows), but I fail to see how the O(n) algorithm (Kadane\\'s) is \"easy\".  Having done this in an interview setting, I found it more challenging than most \"medium\" problems here (subsets, iterative binary tree inorder traversal, permutations, group anagrams, merge intervals, just to name a few).  \\n\\n1. With the before-mentioned \"medium\" problems, basically understanding the problem definition and drawing it out and knowing recursion/core CS data structures -- you can pull off an algorithm pretty directly.   But even if you get as far as recognizing this as a 1-D DP problem, building the subproblems and advancing them aren\\'t obvious. (let alone convincing yourself what you are doing is valid)\\n2. That the algorithm has someone\\'s name attached to it (Kadane) makes me question whether it is trivial. :)\\n\\nAdmitedly, once you\\'ve done it before, it feels trivial to code. In that sense, this problem reminds me a bit of the linked list cycle problem (with no prior context) -- trivial in O(n) time/O(n) space - a lot harder (admitedly more difficult than coming up with Kadane\\'s algorithm) with O(1) space.\\n\\nAs a comparison to another leetcode problem, this feels about as challenging as [Best time to buy & sell stock with txn fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/), a 1D DP problem with not-so-obvious subproblems."
                    },
                    {
                        "username": "user0626kd",
                        "content": "tbh the \"1-d dp\" isn\\'t really a dp, it\\'s a greedy algorithm"
                    },
                    {
                        "username": "snrklyc",
                        "content": "Precisely. If the solution you seek has but one single way of doing it, it means you’re not seeking if the candidate is capable of reducing complexity, but if they happen to know the esoteric algorithm you know. Such questions are frowned upon in my company, I always tell new interviewers to never ask them. "
                    },
                    {
                        "username": "BenSwitala",
                        "content": "This is a hard problem, not an easy one!  An algorithm to solve it is named after a person, Kadane!"
                    },
                    {
                        "username": "20credi",
                        "content": "thank you"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Brute force solution doesn\\'t pass and Optimized solutions are not obvious."
                    },
                    {
                        "username": "_nik_",
                        "content": "Problem with brute force is that it is taking longer time and after using kadanes, it is only working for positive array not the negative ones."
                    },
                    {
                        "username": "nathanad",
                        "content": "I don\\'t understand why this is considered an easy question when it took University professors years to come up with an O(n)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) no he didnt lmao "
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "nice logic"
                    },
                    {
                        "username": "llulek",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) the problem is my name is not Kadane ;) "
                    },
                    {
                        "username": "petahertz",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) But how long did it take to find the one person who could solve it in a minute? :-)"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "You realise it took kadane a minute to figure it out?"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "its med"
                    },
                    {
                        "username": "Jayaramachandran",
                        "content": "Video explaining how to solve the maximum sub-array problem using the kadane\\'s algorithm\\n\\nhttps://youtu.be/Id_hZTV7_IA\\n\\n\\n\\nThe kadane algorithm helps us to compute the maximum sum at each index position. The core of kadane algorithm is, the maximum sum at any given index position is either the value at that index or the sum of value at current index position and the maximum sum at the previous index position.\\nLet\\u2019s see the pseudo code of kadane algorithm,\\nStep 1: Assign the zeroth index value to the current index maximum sum and overall maximum sum.\\nStep 2: Start from the index position one and iterate till n and find the max value between the current index position value and sum of current index position value and last index maximum sum.\\nStep 3: if the current index maximum value is greater than overall maximum value, then replace the overall maximum value with the current index maximum value."
                    },
                    {
                        "username": "almightyshiva",
                        "content": "why is for loop i<nums.length i should iterate all the values why is it less"
                    },
                    {
                        "username": "user4136j",
                        "content": "alternate explanation writing back into same array memory: https://www.youtube.com/watch?v=tmakGVOGV3A"
                    },
                    {
                        "username": "leewc",
                        "content": "I ran into this issue when trying the test case provided on the question, if you're like me where you usually copy paste the example as a test case and then clicking run code, you'll run into this.\\n\\nFirstly u\\\\u2212 is a Minus sign in Unicode.\\n\\nTurns out the example case used Unicode minus signs.\\n\\nNotice how the example,  `[\\u22122,1,\\u22123,4,\\u22121,2,1,\\u22125,4]` differs with  `[-2,1,-3,4,-1,2,1,-5,4]`, the signs are longer.\\n\\nPosting this here in hopes of helping people figure it out since I thought it was something wrong with my code."
                    },
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Can anyone try to solve this problem?\\nhttp://stackoverflow.com/questions/39084147/largest-sum-of-contiguous-subarray-no-larger-than-k"
                    },
                    {
                        "username": "shivansh100",
                        "content": "calculate prefix sum array, then while iterating use binarysearch or upperbound to get the value closest to sum K."
                    },
                    {
                        "username": "xiangu",
                        "content": "DP solution:\\n- Define dp[i] = max sum of sub-array ending with nums[i]\\n- result = max(dp) because the max sum subarray has to end at some element\\n- Base case: dp[0] = nums[0]\\n- Recurrence: dp[i] = nums[i] + max(0, dp[i-1])\\n\\nLet\\'s first accept the meaning of the dp array (I know it\\'s not natural to come up with this representation but let\\'s for now accept it. I will try to illustrate why we have this recurrence).\\n\\ninterpretation of the recurrence: To find the max subarray ending in element i, literally, it means we need to consider all subarrays that ends in element i:\\n\\n[element i],\\n[element i-1, element i],\\n[element i-2, element i-1, element i],\\n... \\n[element 0, ..., element i].\\n\\nThen we find the one with highest sum as dp[i]; that is, dp[i] = max(sum([element i]), sum([element i-1, element i]), ..., sum([element 0, ..., element i]))\\n\\n= nums[i] + max(sum([]), sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))\\n\\n\\n= nums[i] + max(0, sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1])) \\n\\n= nums[i] + max(0, *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*) \\n\\nHey, boy, look at this part *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*; this is exactly dp[i-1]!\\nThus, the recurrence equation can be expressed as dp[i] = nums[i] + max(0, dp[i-1]).\\n\\nNow, you can look at other posts to undersand how to further optimize this solution (on the space complexity from O(n) to O(1)) but I find this explanation most natural for first attempt!\\n\\n           \\n"
                    }
                ]
            },
            {
                "id": 1567101,
                "content": [
                    {
                        "username": "chentao169",
                        "content": "I solve this problem in O(n). But the hint says it would be solved by using the divide and conquer approach.\\nI cannot figure out how to do it with divide and conquer.\\nYou guys have ideas?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I think I found one divide-and-conquer solution with O(nlogn) time (slower than Kadane\\'s algorithm) and O(1) space (same as Kadane\\'s).\\n\\nSome insights: If we cut the original array into 2 equal halves, then the max subarray must be in either one of the 3 positions: completely in the left half, completely in the right half, or spanning across 2 halves. So, we can form 3 corresponding sub-problems to find the max array in each of these 3 positions, then choose the max of the 3 arrays to be the ultimate answer.\\n\\nThe first 2 subtasks can be solved using recursion, while the last one (max sub-array spanning across 2 halves) can be done in a pretty similar fashion as the Kadane\\'s algorithm (hint: iterate the array from the middle point to the 2 ends and utilize the `current_sum` variable).\\n\\nAnd that\\'s it. Hope you can find the solution!"
                    },
                    {
                        "username": "kolojoe",
                        "content": "My solution was O(log(n)) using divide and conquer (albeit definitely a bit more verbose than the DP methods using O(n)): https://leetcode.com/problems/maximum-subarray/solutions/2905607/recursive-o-log-n-mathematical-approach-summing-via-logical-continuity/"
                    },
                    {
                        "username": "xcznu",
                        "content": "I feel its misleading to instruct to \"find\" the subarray (int[]), when function is returning the max sum (int).  May be use another word for \"find\" - eg. \"calculate\" the sum of largest contigous subarray \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "coder_bgn",
                        "content": "[@ayooluwaadeleye17](/ayooluwaadeleye17) but how to find the subarray\\n....can u give the code here to find the subarray , im unable to find it"
                    },
                    {
                        "username": "johnppkyaw",
                        "content": "I agree.  That was confusing.  "
                    },
                    {
                        "username": "ayooluwaadeleye17",
                        "content": "Yes i was confused when i was trying to return the subarray and it ws wrong because I was supposed to return the sum"
                    },
                    {
                        "username": "usaar33",
                        "content": "Certainly, the O(n^3) algorithm (brute force) is \"easy\" (even a slightly optimized O(n^2) using sliding windows), but I fail to see how the O(n) algorithm (Kadane\\'s) is \"easy\".  Having done this in an interview setting, I found it more challenging than most \"medium\" problems here (subsets, iterative binary tree inorder traversal, permutations, group anagrams, merge intervals, just to name a few).  \\n\\n1. With the before-mentioned \"medium\" problems, basically understanding the problem definition and drawing it out and knowing recursion/core CS data structures -- you can pull off an algorithm pretty directly.   But even if you get as far as recognizing this as a 1-D DP problem, building the subproblems and advancing them aren\\'t obvious. (let alone convincing yourself what you are doing is valid)\\n2. That the algorithm has someone\\'s name attached to it (Kadane) makes me question whether it is trivial. :)\\n\\nAdmitedly, once you\\'ve done it before, it feels trivial to code. In that sense, this problem reminds me a bit of the linked list cycle problem (with no prior context) -- trivial in O(n) time/O(n) space - a lot harder (admitedly more difficult than coming up with Kadane\\'s algorithm) with O(1) space.\\n\\nAs a comparison to another leetcode problem, this feels about as challenging as [Best time to buy & sell stock with txn fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/), a 1D DP problem with not-so-obvious subproblems."
                    },
                    {
                        "username": "user0626kd",
                        "content": "tbh the \"1-d dp\" isn\\'t really a dp, it\\'s a greedy algorithm"
                    },
                    {
                        "username": "snrklyc",
                        "content": "Precisely. If the solution you seek has but one single way of doing it, it means you’re not seeking if the candidate is capable of reducing complexity, but if they happen to know the esoteric algorithm you know. Such questions are frowned upon in my company, I always tell new interviewers to never ask them. "
                    },
                    {
                        "username": "BenSwitala",
                        "content": "This is a hard problem, not an easy one!  An algorithm to solve it is named after a person, Kadane!"
                    },
                    {
                        "username": "20credi",
                        "content": "thank you"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Brute force solution doesn\\'t pass and Optimized solutions are not obvious."
                    },
                    {
                        "username": "_nik_",
                        "content": "Problem with brute force is that it is taking longer time and after using kadanes, it is only working for positive array not the negative ones."
                    },
                    {
                        "username": "nathanad",
                        "content": "I don\\'t understand why this is considered an easy question when it took University professors years to come up with an O(n)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) no he didnt lmao "
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "nice logic"
                    },
                    {
                        "username": "llulek",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) the problem is my name is not Kadane ;) "
                    },
                    {
                        "username": "petahertz",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) But how long did it take to find the one person who could solve it in a minute? :-)"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "You realise it took kadane a minute to figure it out?"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "its med"
                    },
                    {
                        "username": "Jayaramachandran",
                        "content": "Video explaining how to solve the maximum sub-array problem using the kadane\\'s algorithm\\n\\nhttps://youtu.be/Id_hZTV7_IA\\n\\n\\n\\nThe kadane algorithm helps us to compute the maximum sum at each index position. The core of kadane algorithm is, the maximum sum at any given index position is either the value at that index or the sum of value at current index position and the maximum sum at the previous index position.\\nLet\\u2019s see the pseudo code of kadane algorithm,\\nStep 1: Assign the zeroth index value to the current index maximum sum and overall maximum sum.\\nStep 2: Start from the index position one and iterate till n and find the max value between the current index position value and sum of current index position value and last index maximum sum.\\nStep 3: if the current index maximum value is greater than overall maximum value, then replace the overall maximum value with the current index maximum value."
                    },
                    {
                        "username": "almightyshiva",
                        "content": "why is for loop i<nums.length i should iterate all the values why is it less"
                    },
                    {
                        "username": "user4136j",
                        "content": "alternate explanation writing back into same array memory: https://www.youtube.com/watch?v=tmakGVOGV3A"
                    },
                    {
                        "username": "leewc",
                        "content": "I ran into this issue when trying the test case provided on the question, if you're like me where you usually copy paste the example as a test case and then clicking run code, you'll run into this.\\n\\nFirstly u\\\\u2212 is a Minus sign in Unicode.\\n\\nTurns out the example case used Unicode minus signs.\\n\\nNotice how the example,  `[\\u22122,1,\\u22123,4,\\u22121,2,1,\\u22125,4]` differs with  `[-2,1,-3,4,-1,2,1,-5,4]`, the signs are longer.\\n\\nPosting this here in hopes of helping people figure it out since I thought it was something wrong with my code."
                    },
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Can anyone try to solve this problem?\\nhttp://stackoverflow.com/questions/39084147/largest-sum-of-contiguous-subarray-no-larger-than-k"
                    },
                    {
                        "username": "shivansh100",
                        "content": "calculate prefix sum array, then while iterating use binarysearch or upperbound to get the value closest to sum K."
                    },
                    {
                        "username": "xiangu",
                        "content": "DP solution:\\n- Define dp[i] = max sum of sub-array ending with nums[i]\\n- result = max(dp) because the max sum subarray has to end at some element\\n- Base case: dp[0] = nums[0]\\n- Recurrence: dp[i] = nums[i] + max(0, dp[i-1])\\n\\nLet\\'s first accept the meaning of the dp array (I know it\\'s not natural to come up with this representation but let\\'s for now accept it. I will try to illustrate why we have this recurrence).\\n\\ninterpretation of the recurrence: To find the max subarray ending in element i, literally, it means we need to consider all subarrays that ends in element i:\\n\\n[element i],\\n[element i-1, element i],\\n[element i-2, element i-1, element i],\\n... \\n[element 0, ..., element i].\\n\\nThen we find the one with highest sum as dp[i]; that is, dp[i] = max(sum([element i]), sum([element i-1, element i]), ..., sum([element 0, ..., element i]))\\n\\n= nums[i] + max(sum([]), sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))\\n\\n\\n= nums[i] + max(0, sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1])) \\n\\n= nums[i] + max(0, *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*) \\n\\nHey, boy, look at this part *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*; this is exactly dp[i-1]!\\nThus, the recurrence equation can be expressed as dp[i] = nums[i] + max(0, dp[i-1]).\\n\\nNow, you can look at other posts to undersand how to further optimize this solution (on the space complexity from O(n) to O(1)) but I find this explanation most natural for first attempt!\\n\\n           \\n"
                    }
                ]
            },
            {
                "id": 1566592,
                "content": [
                    {
                        "username": "chentao169",
                        "content": "I solve this problem in O(n). But the hint says it would be solved by using the divide and conquer approach.\\nI cannot figure out how to do it with divide and conquer.\\nYou guys have ideas?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I think I found one divide-and-conquer solution with O(nlogn) time (slower than Kadane\\'s algorithm) and O(1) space (same as Kadane\\'s).\\n\\nSome insights: If we cut the original array into 2 equal halves, then the max subarray must be in either one of the 3 positions: completely in the left half, completely in the right half, or spanning across 2 halves. So, we can form 3 corresponding sub-problems to find the max array in each of these 3 positions, then choose the max of the 3 arrays to be the ultimate answer.\\n\\nThe first 2 subtasks can be solved using recursion, while the last one (max sub-array spanning across 2 halves) can be done in a pretty similar fashion as the Kadane\\'s algorithm (hint: iterate the array from the middle point to the 2 ends and utilize the `current_sum` variable).\\n\\nAnd that\\'s it. Hope you can find the solution!"
                    },
                    {
                        "username": "kolojoe",
                        "content": "My solution was O(log(n)) using divide and conquer (albeit definitely a bit more verbose than the DP methods using O(n)): https://leetcode.com/problems/maximum-subarray/solutions/2905607/recursive-o-log-n-mathematical-approach-summing-via-logical-continuity/"
                    },
                    {
                        "username": "xcznu",
                        "content": "I feel its misleading to instruct to \"find\" the subarray (int[]), when function is returning the max sum (int).  May be use another word for \"find\" - eg. \"calculate\" the sum of largest contigous subarray \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "coder_bgn",
                        "content": "[@ayooluwaadeleye17](/ayooluwaadeleye17) but how to find the subarray\\n....can u give the code here to find the subarray , im unable to find it"
                    },
                    {
                        "username": "johnppkyaw",
                        "content": "I agree.  That was confusing.  "
                    },
                    {
                        "username": "ayooluwaadeleye17",
                        "content": "Yes i was confused when i was trying to return the subarray and it ws wrong because I was supposed to return the sum"
                    },
                    {
                        "username": "usaar33",
                        "content": "Certainly, the O(n^3) algorithm (brute force) is \"easy\" (even a slightly optimized O(n^2) using sliding windows), but I fail to see how the O(n) algorithm (Kadane\\'s) is \"easy\".  Having done this in an interview setting, I found it more challenging than most \"medium\" problems here (subsets, iterative binary tree inorder traversal, permutations, group anagrams, merge intervals, just to name a few).  \\n\\n1. With the before-mentioned \"medium\" problems, basically understanding the problem definition and drawing it out and knowing recursion/core CS data structures -- you can pull off an algorithm pretty directly.   But even if you get as far as recognizing this as a 1-D DP problem, building the subproblems and advancing them aren\\'t obvious. (let alone convincing yourself what you are doing is valid)\\n2. That the algorithm has someone\\'s name attached to it (Kadane) makes me question whether it is trivial. :)\\n\\nAdmitedly, once you\\'ve done it before, it feels trivial to code. In that sense, this problem reminds me a bit of the linked list cycle problem (with no prior context) -- trivial in O(n) time/O(n) space - a lot harder (admitedly more difficult than coming up with Kadane\\'s algorithm) with O(1) space.\\n\\nAs a comparison to another leetcode problem, this feels about as challenging as [Best time to buy & sell stock with txn fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/), a 1D DP problem with not-so-obvious subproblems."
                    },
                    {
                        "username": "user0626kd",
                        "content": "tbh the \"1-d dp\" isn\\'t really a dp, it\\'s a greedy algorithm"
                    },
                    {
                        "username": "snrklyc",
                        "content": "Precisely. If the solution you seek has but one single way of doing it, it means you’re not seeking if the candidate is capable of reducing complexity, but if they happen to know the esoteric algorithm you know. Such questions are frowned upon in my company, I always tell new interviewers to never ask them. "
                    },
                    {
                        "username": "BenSwitala",
                        "content": "This is a hard problem, not an easy one!  An algorithm to solve it is named after a person, Kadane!"
                    },
                    {
                        "username": "20credi",
                        "content": "thank you"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Brute force solution doesn\\'t pass and Optimized solutions are not obvious."
                    },
                    {
                        "username": "_nik_",
                        "content": "Problem with brute force is that it is taking longer time and after using kadanes, it is only working for positive array not the negative ones."
                    },
                    {
                        "username": "nathanad",
                        "content": "I don\\'t understand why this is considered an easy question when it took University professors years to come up with an O(n)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) no he didnt lmao "
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "nice logic"
                    },
                    {
                        "username": "llulek",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) the problem is my name is not Kadane ;) "
                    },
                    {
                        "username": "petahertz",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) But how long did it take to find the one person who could solve it in a minute? :-)"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "You realise it took kadane a minute to figure it out?"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "its med"
                    },
                    {
                        "username": "Jayaramachandran",
                        "content": "Video explaining how to solve the maximum sub-array problem using the kadane\\'s algorithm\\n\\nhttps://youtu.be/Id_hZTV7_IA\\n\\n\\n\\nThe kadane algorithm helps us to compute the maximum sum at each index position. The core of kadane algorithm is, the maximum sum at any given index position is either the value at that index or the sum of value at current index position and the maximum sum at the previous index position.\\nLet\\u2019s see the pseudo code of kadane algorithm,\\nStep 1: Assign the zeroth index value to the current index maximum sum and overall maximum sum.\\nStep 2: Start from the index position one and iterate till n and find the max value between the current index position value and sum of current index position value and last index maximum sum.\\nStep 3: if the current index maximum value is greater than overall maximum value, then replace the overall maximum value with the current index maximum value."
                    },
                    {
                        "username": "almightyshiva",
                        "content": "why is for loop i<nums.length i should iterate all the values why is it less"
                    },
                    {
                        "username": "user4136j",
                        "content": "alternate explanation writing back into same array memory: https://www.youtube.com/watch?v=tmakGVOGV3A"
                    },
                    {
                        "username": "leewc",
                        "content": "I ran into this issue when trying the test case provided on the question, if you're like me where you usually copy paste the example as a test case and then clicking run code, you'll run into this.\\n\\nFirstly u\\\\u2212 is a Minus sign in Unicode.\\n\\nTurns out the example case used Unicode minus signs.\\n\\nNotice how the example,  `[\\u22122,1,\\u22123,4,\\u22121,2,1,\\u22125,4]` differs with  `[-2,1,-3,4,-1,2,1,-5,4]`, the signs are longer.\\n\\nPosting this here in hopes of helping people figure it out since I thought it was something wrong with my code."
                    },
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Can anyone try to solve this problem?\\nhttp://stackoverflow.com/questions/39084147/largest-sum-of-contiguous-subarray-no-larger-than-k"
                    },
                    {
                        "username": "shivansh100",
                        "content": "calculate prefix sum array, then while iterating use binarysearch or upperbound to get the value closest to sum K."
                    },
                    {
                        "username": "xiangu",
                        "content": "DP solution:\\n- Define dp[i] = max sum of sub-array ending with nums[i]\\n- result = max(dp) because the max sum subarray has to end at some element\\n- Base case: dp[0] = nums[0]\\n- Recurrence: dp[i] = nums[i] + max(0, dp[i-1])\\n\\nLet\\'s first accept the meaning of the dp array (I know it\\'s not natural to come up with this representation but let\\'s for now accept it. I will try to illustrate why we have this recurrence).\\n\\ninterpretation of the recurrence: To find the max subarray ending in element i, literally, it means we need to consider all subarrays that ends in element i:\\n\\n[element i],\\n[element i-1, element i],\\n[element i-2, element i-1, element i],\\n... \\n[element 0, ..., element i].\\n\\nThen we find the one with highest sum as dp[i]; that is, dp[i] = max(sum([element i]), sum([element i-1, element i]), ..., sum([element 0, ..., element i]))\\n\\n= nums[i] + max(sum([]), sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))\\n\\n\\n= nums[i] + max(0, sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1])) \\n\\n= nums[i] + max(0, *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*) \\n\\nHey, boy, look at this part *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*; this is exactly dp[i-1]!\\nThus, the recurrence equation can be expressed as dp[i] = nums[i] + max(0, dp[i-1]).\\n\\nNow, you can look at other posts to undersand how to further optimize this solution (on the space complexity from O(n) to O(1)) but I find this explanation most natural for first attempt!\\n\\n           \\n"
                    }
                ]
            },
            {
                "id": 1568228,
                "content": [
                    {
                        "username": "chentao169",
                        "content": "I solve this problem in O(n). But the hint says it would be solved by using the divide and conquer approach.\\nI cannot figure out how to do it with divide and conquer.\\nYou guys have ideas?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I think I found one divide-and-conquer solution with O(nlogn) time (slower than Kadane\\'s algorithm) and O(1) space (same as Kadane\\'s).\\n\\nSome insights: If we cut the original array into 2 equal halves, then the max subarray must be in either one of the 3 positions: completely in the left half, completely in the right half, or spanning across 2 halves. So, we can form 3 corresponding sub-problems to find the max array in each of these 3 positions, then choose the max of the 3 arrays to be the ultimate answer.\\n\\nThe first 2 subtasks can be solved using recursion, while the last one (max sub-array spanning across 2 halves) can be done in a pretty similar fashion as the Kadane\\'s algorithm (hint: iterate the array from the middle point to the 2 ends and utilize the `current_sum` variable).\\n\\nAnd that\\'s it. Hope you can find the solution!"
                    },
                    {
                        "username": "kolojoe",
                        "content": "My solution was O(log(n)) using divide and conquer (albeit definitely a bit more verbose than the DP methods using O(n)): https://leetcode.com/problems/maximum-subarray/solutions/2905607/recursive-o-log-n-mathematical-approach-summing-via-logical-continuity/"
                    },
                    {
                        "username": "xcznu",
                        "content": "I feel its misleading to instruct to \"find\" the subarray (int[]), when function is returning the max sum (int).  May be use another word for \"find\" - eg. \"calculate\" the sum of largest contigous subarray \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "coder_bgn",
                        "content": "[@ayooluwaadeleye17](/ayooluwaadeleye17) but how to find the subarray\\n....can u give the code here to find the subarray , im unable to find it"
                    },
                    {
                        "username": "johnppkyaw",
                        "content": "I agree.  That was confusing.  "
                    },
                    {
                        "username": "ayooluwaadeleye17",
                        "content": "Yes i was confused when i was trying to return the subarray and it ws wrong because I was supposed to return the sum"
                    },
                    {
                        "username": "usaar33",
                        "content": "Certainly, the O(n^3) algorithm (brute force) is \"easy\" (even a slightly optimized O(n^2) using sliding windows), but I fail to see how the O(n) algorithm (Kadane\\'s) is \"easy\".  Having done this in an interview setting, I found it more challenging than most \"medium\" problems here (subsets, iterative binary tree inorder traversal, permutations, group anagrams, merge intervals, just to name a few).  \\n\\n1. With the before-mentioned \"medium\" problems, basically understanding the problem definition and drawing it out and knowing recursion/core CS data structures -- you can pull off an algorithm pretty directly.   But even if you get as far as recognizing this as a 1-D DP problem, building the subproblems and advancing them aren\\'t obvious. (let alone convincing yourself what you are doing is valid)\\n2. That the algorithm has someone\\'s name attached to it (Kadane) makes me question whether it is trivial. :)\\n\\nAdmitedly, once you\\'ve done it before, it feels trivial to code. In that sense, this problem reminds me a bit of the linked list cycle problem (with no prior context) -- trivial in O(n) time/O(n) space - a lot harder (admitedly more difficult than coming up with Kadane\\'s algorithm) with O(1) space.\\n\\nAs a comparison to another leetcode problem, this feels about as challenging as [Best time to buy & sell stock with txn fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/), a 1D DP problem with not-so-obvious subproblems."
                    },
                    {
                        "username": "user0626kd",
                        "content": "tbh the \"1-d dp\" isn\\'t really a dp, it\\'s a greedy algorithm"
                    },
                    {
                        "username": "snrklyc",
                        "content": "Precisely. If the solution you seek has but one single way of doing it, it means you’re not seeking if the candidate is capable of reducing complexity, but if they happen to know the esoteric algorithm you know. Such questions are frowned upon in my company, I always tell new interviewers to never ask them. "
                    },
                    {
                        "username": "BenSwitala",
                        "content": "This is a hard problem, not an easy one!  An algorithm to solve it is named after a person, Kadane!"
                    },
                    {
                        "username": "20credi",
                        "content": "thank you"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Brute force solution doesn\\'t pass and Optimized solutions are not obvious."
                    },
                    {
                        "username": "_nik_",
                        "content": "Problem with brute force is that it is taking longer time and after using kadanes, it is only working for positive array not the negative ones."
                    },
                    {
                        "username": "nathanad",
                        "content": "I don\\'t understand why this is considered an easy question when it took University professors years to come up with an O(n)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) no he didnt lmao "
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "nice logic"
                    },
                    {
                        "username": "llulek",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) the problem is my name is not Kadane ;) "
                    },
                    {
                        "username": "petahertz",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) But how long did it take to find the one person who could solve it in a minute? :-)"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "You realise it took kadane a minute to figure it out?"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "its med"
                    },
                    {
                        "username": "Jayaramachandran",
                        "content": "Video explaining how to solve the maximum sub-array problem using the kadane\\'s algorithm\\n\\nhttps://youtu.be/Id_hZTV7_IA\\n\\n\\n\\nThe kadane algorithm helps us to compute the maximum sum at each index position. The core of kadane algorithm is, the maximum sum at any given index position is either the value at that index or the sum of value at current index position and the maximum sum at the previous index position.\\nLet\\u2019s see the pseudo code of kadane algorithm,\\nStep 1: Assign the zeroth index value to the current index maximum sum and overall maximum sum.\\nStep 2: Start from the index position one and iterate till n and find the max value between the current index position value and sum of current index position value and last index maximum sum.\\nStep 3: if the current index maximum value is greater than overall maximum value, then replace the overall maximum value with the current index maximum value."
                    },
                    {
                        "username": "almightyshiva",
                        "content": "why is for loop i<nums.length i should iterate all the values why is it less"
                    },
                    {
                        "username": "user4136j",
                        "content": "alternate explanation writing back into same array memory: https://www.youtube.com/watch?v=tmakGVOGV3A"
                    },
                    {
                        "username": "leewc",
                        "content": "I ran into this issue when trying the test case provided on the question, if you're like me where you usually copy paste the example as a test case and then clicking run code, you'll run into this.\\n\\nFirstly u\\\\u2212 is a Minus sign in Unicode.\\n\\nTurns out the example case used Unicode minus signs.\\n\\nNotice how the example,  `[\\u22122,1,\\u22123,4,\\u22121,2,1,\\u22125,4]` differs with  `[-2,1,-3,4,-1,2,1,-5,4]`, the signs are longer.\\n\\nPosting this here in hopes of helping people figure it out since I thought it was something wrong with my code."
                    },
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Can anyone try to solve this problem?\\nhttp://stackoverflow.com/questions/39084147/largest-sum-of-contiguous-subarray-no-larger-than-k"
                    },
                    {
                        "username": "shivansh100",
                        "content": "calculate prefix sum array, then while iterating use binarysearch or upperbound to get the value closest to sum K."
                    },
                    {
                        "username": "xiangu",
                        "content": "DP solution:\\n- Define dp[i] = max sum of sub-array ending with nums[i]\\n- result = max(dp) because the max sum subarray has to end at some element\\n- Base case: dp[0] = nums[0]\\n- Recurrence: dp[i] = nums[i] + max(0, dp[i-1])\\n\\nLet\\'s first accept the meaning of the dp array (I know it\\'s not natural to come up with this representation but let\\'s for now accept it. I will try to illustrate why we have this recurrence).\\n\\ninterpretation of the recurrence: To find the max subarray ending in element i, literally, it means we need to consider all subarrays that ends in element i:\\n\\n[element i],\\n[element i-1, element i],\\n[element i-2, element i-1, element i],\\n... \\n[element 0, ..., element i].\\n\\nThen we find the one with highest sum as dp[i]; that is, dp[i] = max(sum([element i]), sum([element i-1, element i]), ..., sum([element 0, ..., element i]))\\n\\n= nums[i] + max(sum([]), sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))\\n\\n\\n= nums[i] + max(0, sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1])) \\n\\n= nums[i] + max(0, *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*) \\n\\nHey, boy, look at this part *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*; this is exactly dp[i-1]!\\nThus, the recurrence equation can be expressed as dp[i] = nums[i] + max(0, dp[i-1]).\\n\\nNow, you can look at other posts to undersand how to further optimize this solution (on the space complexity from O(n) to O(1)) but I find this explanation most natural for first attempt!\\n\\n           \\n"
                    }
                ]
            },
            {
                "id": 1566067,
                "content": [
                    {
                        "username": "chentao169",
                        "content": "I solve this problem in O(n). But the hint says it would be solved by using the divide and conquer approach.\\nI cannot figure out how to do it with divide and conquer.\\nYou guys have ideas?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I think I found one divide-and-conquer solution with O(nlogn) time (slower than Kadane\\'s algorithm) and O(1) space (same as Kadane\\'s).\\n\\nSome insights: If we cut the original array into 2 equal halves, then the max subarray must be in either one of the 3 positions: completely in the left half, completely in the right half, or spanning across 2 halves. So, we can form 3 corresponding sub-problems to find the max array in each of these 3 positions, then choose the max of the 3 arrays to be the ultimate answer.\\n\\nThe first 2 subtasks can be solved using recursion, while the last one (max sub-array spanning across 2 halves) can be done in a pretty similar fashion as the Kadane\\'s algorithm (hint: iterate the array from the middle point to the 2 ends and utilize the `current_sum` variable).\\n\\nAnd that\\'s it. Hope you can find the solution!"
                    },
                    {
                        "username": "kolojoe",
                        "content": "My solution was O(log(n)) using divide and conquer (albeit definitely a bit more verbose than the DP methods using O(n)): https://leetcode.com/problems/maximum-subarray/solutions/2905607/recursive-o-log-n-mathematical-approach-summing-via-logical-continuity/"
                    },
                    {
                        "username": "xcznu",
                        "content": "I feel its misleading to instruct to \"find\" the subarray (int[]), when function is returning the max sum (int).  May be use another word for \"find\" - eg. \"calculate\" the sum of largest contigous subarray \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "coder_bgn",
                        "content": "[@ayooluwaadeleye17](/ayooluwaadeleye17) but how to find the subarray\\n....can u give the code here to find the subarray , im unable to find it"
                    },
                    {
                        "username": "johnppkyaw",
                        "content": "I agree.  That was confusing.  "
                    },
                    {
                        "username": "ayooluwaadeleye17",
                        "content": "Yes i was confused when i was trying to return the subarray and it ws wrong because I was supposed to return the sum"
                    },
                    {
                        "username": "usaar33",
                        "content": "Certainly, the O(n^3) algorithm (brute force) is \"easy\" (even a slightly optimized O(n^2) using sliding windows), but I fail to see how the O(n) algorithm (Kadane\\'s) is \"easy\".  Having done this in an interview setting, I found it more challenging than most \"medium\" problems here (subsets, iterative binary tree inorder traversal, permutations, group anagrams, merge intervals, just to name a few).  \\n\\n1. With the before-mentioned \"medium\" problems, basically understanding the problem definition and drawing it out and knowing recursion/core CS data structures -- you can pull off an algorithm pretty directly.   But even if you get as far as recognizing this as a 1-D DP problem, building the subproblems and advancing them aren\\'t obvious. (let alone convincing yourself what you are doing is valid)\\n2. That the algorithm has someone\\'s name attached to it (Kadane) makes me question whether it is trivial. :)\\n\\nAdmitedly, once you\\'ve done it before, it feels trivial to code. In that sense, this problem reminds me a bit of the linked list cycle problem (with no prior context) -- trivial in O(n) time/O(n) space - a lot harder (admitedly more difficult than coming up with Kadane\\'s algorithm) with O(1) space.\\n\\nAs a comparison to another leetcode problem, this feels about as challenging as [Best time to buy & sell stock with txn fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/), a 1D DP problem with not-so-obvious subproblems."
                    },
                    {
                        "username": "user0626kd",
                        "content": "tbh the \"1-d dp\" isn\\'t really a dp, it\\'s a greedy algorithm"
                    },
                    {
                        "username": "snrklyc",
                        "content": "Precisely. If the solution you seek has but one single way of doing it, it means you’re not seeking if the candidate is capable of reducing complexity, but if they happen to know the esoteric algorithm you know. Such questions are frowned upon in my company, I always tell new interviewers to never ask them. "
                    },
                    {
                        "username": "BenSwitala",
                        "content": "This is a hard problem, not an easy one!  An algorithm to solve it is named after a person, Kadane!"
                    },
                    {
                        "username": "20credi",
                        "content": "thank you"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Brute force solution doesn\\'t pass and Optimized solutions are not obvious."
                    },
                    {
                        "username": "_nik_",
                        "content": "Problem with brute force is that it is taking longer time and after using kadanes, it is only working for positive array not the negative ones."
                    },
                    {
                        "username": "nathanad",
                        "content": "I don\\'t understand why this is considered an easy question when it took University professors years to come up with an O(n)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) no he didnt lmao "
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "nice logic"
                    },
                    {
                        "username": "llulek",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) the problem is my name is not Kadane ;) "
                    },
                    {
                        "username": "petahertz",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) But how long did it take to find the one person who could solve it in a minute? :-)"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "You realise it took kadane a minute to figure it out?"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "its med"
                    },
                    {
                        "username": "Jayaramachandran",
                        "content": "Video explaining how to solve the maximum sub-array problem using the kadane\\'s algorithm\\n\\nhttps://youtu.be/Id_hZTV7_IA\\n\\n\\n\\nThe kadane algorithm helps us to compute the maximum sum at each index position. The core of kadane algorithm is, the maximum sum at any given index position is either the value at that index or the sum of value at current index position and the maximum sum at the previous index position.\\nLet\\u2019s see the pseudo code of kadane algorithm,\\nStep 1: Assign the zeroth index value to the current index maximum sum and overall maximum sum.\\nStep 2: Start from the index position one and iterate till n and find the max value between the current index position value and sum of current index position value and last index maximum sum.\\nStep 3: if the current index maximum value is greater than overall maximum value, then replace the overall maximum value with the current index maximum value."
                    },
                    {
                        "username": "almightyshiva",
                        "content": "why is for loop i<nums.length i should iterate all the values why is it less"
                    },
                    {
                        "username": "user4136j",
                        "content": "alternate explanation writing back into same array memory: https://www.youtube.com/watch?v=tmakGVOGV3A"
                    },
                    {
                        "username": "leewc",
                        "content": "I ran into this issue when trying the test case provided on the question, if you're like me where you usually copy paste the example as a test case and then clicking run code, you'll run into this.\\n\\nFirstly u\\\\u2212 is a Minus sign in Unicode.\\n\\nTurns out the example case used Unicode minus signs.\\n\\nNotice how the example,  `[\\u22122,1,\\u22123,4,\\u22121,2,1,\\u22125,4]` differs with  `[-2,1,-3,4,-1,2,1,-5,4]`, the signs are longer.\\n\\nPosting this here in hopes of helping people figure it out since I thought it was something wrong with my code."
                    },
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Can anyone try to solve this problem?\\nhttp://stackoverflow.com/questions/39084147/largest-sum-of-contiguous-subarray-no-larger-than-k"
                    },
                    {
                        "username": "shivansh100",
                        "content": "calculate prefix sum array, then while iterating use binarysearch or upperbound to get the value closest to sum K."
                    },
                    {
                        "username": "xiangu",
                        "content": "DP solution:\\n- Define dp[i] = max sum of sub-array ending with nums[i]\\n- result = max(dp) because the max sum subarray has to end at some element\\n- Base case: dp[0] = nums[0]\\n- Recurrence: dp[i] = nums[i] + max(0, dp[i-1])\\n\\nLet\\'s first accept the meaning of the dp array (I know it\\'s not natural to come up with this representation but let\\'s for now accept it. I will try to illustrate why we have this recurrence).\\n\\ninterpretation of the recurrence: To find the max subarray ending in element i, literally, it means we need to consider all subarrays that ends in element i:\\n\\n[element i],\\n[element i-1, element i],\\n[element i-2, element i-1, element i],\\n... \\n[element 0, ..., element i].\\n\\nThen we find the one with highest sum as dp[i]; that is, dp[i] = max(sum([element i]), sum([element i-1, element i]), ..., sum([element 0, ..., element i]))\\n\\n= nums[i] + max(sum([]), sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))\\n\\n\\n= nums[i] + max(0, sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1])) \\n\\n= nums[i] + max(0, *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*) \\n\\nHey, boy, look at this part *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*; this is exactly dp[i-1]!\\nThus, the recurrence equation can be expressed as dp[i] = nums[i] + max(0, dp[i-1]).\\n\\nNow, you can look at other posts to undersand how to further optimize this solution (on the space complexity from O(n) to O(1)) but I find this explanation most natural for first attempt!\\n\\n           \\n"
                    }
                ]
            },
            {
                "id": 1565942,
                "content": [
                    {
                        "username": "chentao169",
                        "content": "I solve this problem in O(n). But the hint says it would be solved by using the divide and conquer approach.\\nI cannot figure out how to do it with divide and conquer.\\nYou guys have ideas?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I think I found one divide-and-conquer solution with O(nlogn) time (slower than Kadane\\'s algorithm) and O(1) space (same as Kadane\\'s).\\n\\nSome insights: If we cut the original array into 2 equal halves, then the max subarray must be in either one of the 3 positions: completely in the left half, completely in the right half, or spanning across 2 halves. So, we can form 3 corresponding sub-problems to find the max array in each of these 3 positions, then choose the max of the 3 arrays to be the ultimate answer.\\n\\nThe first 2 subtasks can be solved using recursion, while the last one (max sub-array spanning across 2 halves) can be done in a pretty similar fashion as the Kadane\\'s algorithm (hint: iterate the array from the middle point to the 2 ends and utilize the `current_sum` variable).\\n\\nAnd that\\'s it. Hope you can find the solution!"
                    },
                    {
                        "username": "kolojoe",
                        "content": "My solution was O(log(n)) using divide and conquer (albeit definitely a bit more verbose than the DP methods using O(n)): https://leetcode.com/problems/maximum-subarray/solutions/2905607/recursive-o-log-n-mathematical-approach-summing-via-logical-continuity/"
                    },
                    {
                        "username": "xcznu",
                        "content": "I feel its misleading to instruct to \"find\" the subarray (int[]), when function is returning the max sum (int).  May be use another word for \"find\" - eg. \"calculate\" the sum of largest contigous subarray \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "coder_bgn",
                        "content": "[@ayooluwaadeleye17](/ayooluwaadeleye17) but how to find the subarray\\n....can u give the code here to find the subarray , im unable to find it"
                    },
                    {
                        "username": "johnppkyaw",
                        "content": "I agree.  That was confusing.  "
                    },
                    {
                        "username": "ayooluwaadeleye17",
                        "content": "Yes i was confused when i was trying to return the subarray and it ws wrong because I was supposed to return the sum"
                    },
                    {
                        "username": "usaar33",
                        "content": "Certainly, the O(n^3) algorithm (brute force) is \"easy\" (even a slightly optimized O(n^2) using sliding windows), but I fail to see how the O(n) algorithm (Kadane\\'s) is \"easy\".  Having done this in an interview setting, I found it more challenging than most \"medium\" problems here (subsets, iterative binary tree inorder traversal, permutations, group anagrams, merge intervals, just to name a few).  \\n\\n1. With the before-mentioned \"medium\" problems, basically understanding the problem definition and drawing it out and knowing recursion/core CS data structures -- you can pull off an algorithm pretty directly.   But even if you get as far as recognizing this as a 1-D DP problem, building the subproblems and advancing them aren\\'t obvious. (let alone convincing yourself what you are doing is valid)\\n2. That the algorithm has someone\\'s name attached to it (Kadane) makes me question whether it is trivial. :)\\n\\nAdmitedly, once you\\'ve done it before, it feels trivial to code. In that sense, this problem reminds me a bit of the linked list cycle problem (with no prior context) -- trivial in O(n) time/O(n) space - a lot harder (admitedly more difficult than coming up with Kadane\\'s algorithm) with O(1) space.\\n\\nAs a comparison to another leetcode problem, this feels about as challenging as [Best time to buy & sell stock with txn fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/), a 1D DP problem with not-so-obvious subproblems."
                    },
                    {
                        "username": "user0626kd",
                        "content": "tbh the \"1-d dp\" isn\\'t really a dp, it\\'s a greedy algorithm"
                    },
                    {
                        "username": "snrklyc",
                        "content": "Precisely. If the solution you seek has but one single way of doing it, it means you’re not seeking if the candidate is capable of reducing complexity, but if they happen to know the esoteric algorithm you know. Such questions are frowned upon in my company, I always tell new interviewers to never ask them. "
                    },
                    {
                        "username": "BenSwitala",
                        "content": "This is a hard problem, not an easy one!  An algorithm to solve it is named after a person, Kadane!"
                    },
                    {
                        "username": "20credi",
                        "content": "thank you"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Brute force solution doesn\\'t pass and Optimized solutions are not obvious."
                    },
                    {
                        "username": "_nik_",
                        "content": "Problem with brute force is that it is taking longer time and after using kadanes, it is only working for positive array not the negative ones."
                    },
                    {
                        "username": "nathanad",
                        "content": "I don\\'t understand why this is considered an easy question when it took University professors years to come up with an O(n)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) no he didnt lmao "
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "nice logic"
                    },
                    {
                        "username": "llulek",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) the problem is my name is not Kadane ;) "
                    },
                    {
                        "username": "petahertz",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) But how long did it take to find the one person who could solve it in a minute? :-)"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "You realise it took kadane a minute to figure it out?"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "its med"
                    },
                    {
                        "username": "Jayaramachandran",
                        "content": "Video explaining how to solve the maximum sub-array problem using the kadane\\'s algorithm\\n\\nhttps://youtu.be/Id_hZTV7_IA\\n\\n\\n\\nThe kadane algorithm helps us to compute the maximum sum at each index position. The core of kadane algorithm is, the maximum sum at any given index position is either the value at that index or the sum of value at current index position and the maximum sum at the previous index position.\\nLet\\u2019s see the pseudo code of kadane algorithm,\\nStep 1: Assign the zeroth index value to the current index maximum sum and overall maximum sum.\\nStep 2: Start from the index position one and iterate till n and find the max value between the current index position value and sum of current index position value and last index maximum sum.\\nStep 3: if the current index maximum value is greater than overall maximum value, then replace the overall maximum value with the current index maximum value."
                    },
                    {
                        "username": "almightyshiva",
                        "content": "why is for loop i<nums.length i should iterate all the values why is it less"
                    },
                    {
                        "username": "user4136j",
                        "content": "alternate explanation writing back into same array memory: https://www.youtube.com/watch?v=tmakGVOGV3A"
                    },
                    {
                        "username": "leewc",
                        "content": "I ran into this issue when trying the test case provided on the question, if you're like me where you usually copy paste the example as a test case and then clicking run code, you'll run into this.\\n\\nFirstly u\\\\u2212 is a Minus sign in Unicode.\\n\\nTurns out the example case used Unicode minus signs.\\n\\nNotice how the example,  `[\\u22122,1,\\u22123,4,\\u22121,2,1,\\u22125,4]` differs with  `[-2,1,-3,4,-1,2,1,-5,4]`, the signs are longer.\\n\\nPosting this here in hopes of helping people figure it out since I thought it was something wrong with my code."
                    },
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Can anyone try to solve this problem?\\nhttp://stackoverflow.com/questions/39084147/largest-sum-of-contiguous-subarray-no-larger-than-k"
                    },
                    {
                        "username": "shivansh100",
                        "content": "calculate prefix sum array, then while iterating use binarysearch or upperbound to get the value closest to sum K."
                    },
                    {
                        "username": "xiangu",
                        "content": "DP solution:\\n- Define dp[i] = max sum of sub-array ending with nums[i]\\n- result = max(dp) because the max sum subarray has to end at some element\\n- Base case: dp[0] = nums[0]\\n- Recurrence: dp[i] = nums[i] + max(0, dp[i-1])\\n\\nLet\\'s first accept the meaning of the dp array (I know it\\'s not natural to come up with this representation but let\\'s for now accept it. I will try to illustrate why we have this recurrence).\\n\\ninterpretation of the recurrence: To find the max subarray ending in element i, literally, it means we need to consider all subarrays that ends in element i:\\n\\n[element i],\\n[element i-1, element i],\\n[element i-2, element i-1, element i],\\n... \\n[element 0, ..., element i].\\n\\nThen we find the one with highest sum as dp[i]; that is, dp[i] = max(sum([element i]), sum([element i-1, element i]), ..., sum([element 0, ..., element i]))\\n\\n= nums[i] + max(sum([]), sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))\\n\\n\\n= nums[i] + max(0, sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1])) \\n\\n= nums[i] + max(0, *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*) \\n\\nHey, boy, look at this part *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*; this is exactly dp[i-1]!\\nThus, the recurrence equation can be expressed as dp[i] = nums[i] + max(0, dp[i-1]).\\n\\nNow, you can look at other posts to undersand how to further optimize this solution (on the space complexity from O(n) to O(1)) but I find this explanation most natural for first attempt!\\n\\n           \\n"
                    }
                ]
            },
            {
                "id": 1569914,
                "content": [
                    {
                        "username": "chentao169",
                        "content": "I solve this problem in O(n). But the hint says it would be solved by using the divide and conquer approach.\\nI cannot figure out how to do it with divide and conquer.\\nYou guys have ideas?"
                    },
                    {
                        "username": "dragon1105",
                        "content": "I think I found one divide-and-conquer solution with O(nlogn) time (slower than Kadane\\'s algorithm) and O(1) space (same as Kadane\\'s).\\n\\nSome insights: If we cut the original array into 2 equal halves, then the max subarray must be in either one of the 3 positions: completely in the left half, completely in the right half, or spanning across 2 halves. So, we can form 3 corresponding sub-problems to find the max array in each of these 3 positions, then choose the max of the 3 arrays to be the ultimate answer.\\n\\nThe first 2 subtasks can be solved using recursion, while the last one (max sub-array spanning across 2 halves) can be done in a pretty similar fashion as the Kadane\\'s algorithm (hint: iterate the array from the middle point to the 2 ends and utilize the `current_sum` variable).\\n\\nAnd that\\'s it. Hope you can find the solution!"
                    },
                    {
                        "username": "kolojoe",
                        "content": "My solution was O(log(n)) using divide and conquer (albeit definitely a bit more verbose than the DP methods using O(n)): https://leetcode.com/problems/maximum-subarray/solutions/2905607/recursive-o-log-n-mathematical-approach-summing-via-logical-continuity/"
                    },
                    {
                        "username": "xcznu",
                        "content": "I feel its misleading to instruct to \"find\" the subarray (int[]), when function is returning the max sum (int).  May be use another word for \"find\" - eg. \"calculate\" the sum of largest contigous subarray \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "coder_bgn",
                        "content": "[@ayooluwaadeleye17](/ayooluwaadeleye17) but how to find the subarray\\n....can u give the code here to find the subarray , im unable to find it"
                    },
                    {
                        "username": "johnppkyaw",
                        "content": "I agree.  That was confusing.  "
                    },
                    {
                        "username": "ayooluwaadeleye17",
                        "content": "Yes i was confused when i was trying to return the subarray and it ws wrong because I was supposed to return the sum"
                    },
                    {
                        "username": "usaar33",
                        "content": "Certainly, the O(n^3) algorithm (brute force) is \"easy\" (even a slightly optimized O(n^2) using sliding windows), but I fail to see how the O(n) algorithm (Kadane\\'s) is \"easy\".  Having done this in an interview setting, I found it more challenging than most \"medium\" problems here (subsets, iterative binary tree inorder traversal, permutations, group anagrams, merge intervals, just to name a few).  \\n\\n1. With the before-mentioned \"medium\" problems, basically understanding the problem definition and drawing it out and knowing recursion/core CS data structures -- you can pull off an algorithm pretty directly.   But even if you get as far as recognizing this as a 1-D DP problem, building the subproblems and advancing them aren\\'t obvious. (let alone convincing yourself what you are doing is valid)\\n2. That the algorithm has someone\\'s name attached to it (Kadane) makes me question whether it is trivial. :)\\n\\nAdmitedly, once you\\'ve done it before, it feels trivial to code. In that sense, this problem reminds me a bit of the linked list cycle problem (with no prior context) -- trivial in O(n) time/O(n) space - a lot harder (admitedly more difficult than coming up with Kadane\\'s algorithm) with O(1) space.\\n\\nAs a comparison to another leetcode problem, this feels about as challenging as [Best time to buy & sell stock with txn fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/), a 1D DP problem with not-so-obvious subproblems."
                    },
                    {
                        "username": "user0626kd",
                        "content": "tbh the \"1-d dp\" isn\\'t really a dp, it\\'s a greedy algorithm"
                    },
                    {
                        "username": "snrklyc",
                        "content": "Precisely. If the solution you seek has but one single way of doing it, it means you’re not seeking if the candidate is capable of reducing complexity, but if they happen to know the esoteric algorithm you know. Such questions are frowned upon in my company, I always tell new interviewers to never ask them. "
                    },
                    {
                        "username": "BenSwitala",
                        "content": "This is a hard problem, not an easy one!  An algorithm to solve it is named after a person, Kadane!"
                    },
                    {
                        "username": "20credi",
                        "content": "thank you"
                    },
                    {
                        "username": "mandy1339",
                        "content": "Brute force solution doesn\\'t pass and Optimized solutions are not obvious."
                    },
                    {
                        "username": "_nik_",
                        "content": "Problem with brute force is that it is taking longer time and after using kadanes, it is only working for positive array not the negative ones."
                    },
                    {
                        "username": "nathanad",
                        "content": "I don\\'t understand why this is considered an easy question when it took University professors years to come up with an O(n)"
                    },
                    {
                        "username": "mochiball",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) no he didnt lmao "
                    },
                    {
                        "username": "AbdulHannan12",
                        "content": "nice logic"
                    },
                    {
                        "username": "llulek",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) the problem is my name is not Kadane ;) "
                    },
                    {
                        "username": "petahertz",
                        "content": "[@CaptainGalbatrollix](/CaptainGalbatrollix) But how long did it take to find the one person who could solve it in a minute? :-)"
                    },
                    {
                        "username": "CaptainGalbatrollix",
                        "content": "You realise it took kadane a minute to figure it out?"
                    },
                    {
                        "username": "danish-dbum",
                        "content": "its med"
                    },
                    {
                        "username": "Jayaramachandran",
                        "content": "Video explaining how to solve the maximum sub-array problem using the kadane\\'s algorithm\\n\\nhttps://youtu.be/Id_hZTV7_IA\\n\\n\\n\\nThe kadane algorithm helps us to compute the maximum sum at each index position. The core of kadane algorithm is, the maximum sum at any given index position is either the value at that index or the sum of value at current index position and the maximum sum at the previous index position.\\nLet\\u2019s see the pseudo code of kadane algorithm,\\nStep 1: Assign the zeroth index value to the current index maximum sum and overall maximum sum.\\nStep 2: Start from the index position one and iterate till n and find the max value between the current index position value and sum of current index position value and last index maximum sum.\\nStep 3: if the current index maximum value is greater than overall maximum value, then replace the overall maximum value with the current index maximum value."
                    },
                    {
                        "username": "almightyshiva",
                        "content": "why is for loop i<nums.length i should iterate all the values why is it less"
                    },
                    {
                        "username": "user4136j",
                        "content": "alternate explanation writing back into same array memory: https://www.youtube.com/watch?v=tmakGVOGV3A"
                    },
                    {
                        "username": "leewc",
                        "content": "I ran into this issue when trying the test case provided on the question, if you're like me where you usually copy paste the example as a test case and then clicking run code, you'll run into this.\\n\\nFirstly u\\\\u2212 is a Minus sign in Unicode.\\n\\nTurns out the example case used Unicode minus signs.\\n\\nNotice how the example,  `[\\u22122,1,\\u22123,4,\\u22121,2,1,\\u22125,4]` differs with  `[-2,1,-3,4,-1,2,1,-5,4]`, the signs are longer.\\n\\nPosting this here in hopes of helping people figure it out since I thought it was something wrong with my code."
                    },
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Can anyone try to solve this problem?\\nhttp://stackoverflow.com/questions/39084147/largest-sum-of-contiguous-subarray-no-larger-than-k"
                    },
                    {
                        "username": "shivansh100",
                        "content": "calculate prefix sum array, then while iterating use binarysearch or upperbound to get the value closest to sum K."
                    },
                    {
                        "username": "xiangu",
                        "content": "DP solution:\\n- Define dp[i] = max sum of sub-array ending with nums[i]\\n- result = max(dp) because the max sum subarray has to end at some element\\n- Base case: dp[0] = nums[0]\\n- Recurrence: dp[i] = nums[i] + max(0, dp[i-1])\\n\\nLet\\'s first accept the meaning of the dp array (I know it\\'s not natural to come up with this representation but let\\'s for now accept it. I will try to illustrate why we have this recurrence).\\n\\ninterpretation of the recurrence: To find the max subarray ending in element i, literally, it means we need to consider all subarrays that ends in element i:\\n\\n[element i],\\n[element i-1, element i],\\n[element i-2, element i-1, element i],\\n... \\n[element 0, ..., element i].\\n\\nThen we find the one with highest sum as dp[i]; that is, dp[i] = max(sum([element i]), sum([element i-1, element i]), ..., sum([element 0, ..., element i]))\\n\\n= nums[i] + max(sum([]), sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))\\n\\n\\n= nums[i] + max(0, sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1])) \\n\\n= nums[i] + max(0, *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*) \\n\\nHey, boy, look at this part *max(sum([element i-1]), sum([element i-2, element i-1]), ..., sum([element 0, ..., element i-1]))*; this is exactly dp[i-1]!\\nThus, the recurrence equation can be expressed as dp[i] = nums[i] + max(0, dp[i-1]).\\n\\nNow, you can look at other posts to undersand how to further optimize this solution (on the space complexity from O(n) to O(1)) but I find this explanation most natural for first attempt!\\n\\n           \\n"
                    }
                ]
            },
            {
                "id": 1564999,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Optimized Brute Force\n\n  \n**Approach 2:** Dynamic Programming, Kadane's Algorithm\n\n  \n**Approach 3:** Divide and Conquer (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "tejastejas12",
                        "content": "here we are using kadane\\'s algo which gives optimal solution  of O(n )"
                    },
                    {
                        "username": "daynis",
                        "content": "I was asked a follow up question to this question in an interview.\" How would we solve this given that there is an endless incoming stream of numbers ?\"    Ideas anybody?"
                    },
                    {
                        "username": "bparanj",
                        "content": " The idea here is that you have a potentially unbounded stream of numbers and you want to keep track of the maximum subarray sum at any given time.\\n\\n Since Kadane\\'s algorithm processes the input once without needing to look at future elements, it can work just as well in a streaming scenario. \\n\\nHere\\'s a simple Python implementation:\\n\\n```python\\ndef max_subarray_stream(nums):\\n    current_sum = max_sum = float(\\'-inf\\')\\n\\n    for num in nums:\\n        current_sum = max(num, current_sum + num)\\n        max_sum = max(max_sum, current_sum)\\n    \\n    return max_sum\\n```\\n\\nThis function can be used in a streaming context as follows:\\n\\n```python\\nstream = [...]  # Replace with the actual stream of numbers.\\nmax_sum = float(\\'-inf\\')\\n\\nfor chunk in stream:  # Process the stream in chunks.\\n    max_sum = max(max_sum, max_subarray_stream(chunk))\\n    print(f\\'Maximum subarray sum so far: {max_sum}\\')\\n```\\n\\nThis implementation assumes that the stream can be processed in chunks. Each chunk could be a list of numbers that are processed all at once by the `max_subarray_stream` function. \\n\\nIn a real-world scenario, the chunk size would depend on factors like the rate at which data is received from the stream and the memory constraints of the machine running this code. It\\'s worth noting that the chunk size does not affect the final result, because Kadane\\'s algorithm does not depend on future data."
                    },
                    {
                        "username": "lalananya55",
                        "content": "First output case says : [1, 4, -1, 2]  as max subarray with output 6\\nShould not it ne [1,4,2] with output 7\\n"
                    },
                    {
                        "username": "RanjeetP",
                        "content": "becoz we have to use contiguous subarray\\n"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "[@BinaryMusaib](/BinaryMusaib) why we have to subtract from -1 when we are getting maximum sum 7!"
                    },
                    {
                        "username": "BinaryMusaib",
                        "content": "No, The output will be 6 because you have to subtract (negative)1 to the array."
                    },
                    {
                        "username": "parambole",
                        "content": "There are several articles out there that mention ways to solve DP problems. But, the problem is that every DP problem is different. \\n\\nWhat one needs to learn is how to reach to the DP solution. \\n\\n**STEP 1: Start with Brute Force:** \\n\\nYes, you heard it right. Because DP is nothing but intelligent guessing. We need to do an exhaustive search on every possible combination and pick the most optimal combination. \\n\\n**STEP 2: Draw out your solution - > This is the most critical step**\\n\\nDraw the steps that your brute force solution is taking. Because unless you visualize what your algorithm is doing. You can never come up with a DP solution.\\n\\n**STEP 3: Think about repeated steps and how to store and use them**\\n\\nIt is not just important to know what steps are getting repeated. What is essential is to understand how can you store your calculations and re-usage them."
                    },
                    {
                        "username": "Thisismeaditya_singh",
                        "content": "Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\n\nShould'nt it be 7? with subarray of  [4,2,1] ??? Am I missing something here?"
                    },
                    {
                        "username": "varshinir822",
                        "content": "[@PrasannaNaik211](/PrasannaNaik211) because a subarray has to be a consecutive sequence"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "Yes even I also have same doubt why we have to subtract from -1 when we are already getting maximum sum 7\\n"
                    },
                    {
                        "username": "pythonCoderHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/maximum-subarray-leetcode-python-solution/"
                    },
                    {
                        "username": "Depender",
                        "content": "![image](https://assets.leetcode.com/users/images/7fa2d39d-0c2e-47b8-86a6-4726837c1676_1645458692.698741.png)\\n"
                    },
                    {
                        "username": "mknaveen837",
                        "content": "![image](https://assets.leetcode.com/users/images/fc6091ab-502c-42c6-8cdc-10280d415573_1598457725.3748913.png)\\nWhats the error The same custome test input works fine plz help"
                    },
                    {
                        "username": "p-neiderman",
                        "content": "I implemented the brute force solution after thinking on it for a while, but after trying and failing to think of an O(n) solution, I looked up Kadane\\'s algorithm and it seems almost trivial. I feel a little ashamed of not being able to implement it on my own. Are there some fundamental concepts I\\'m missing here? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Kadane\\'s Algorithm falls under the category of Dynamic Programming (DP), which is a technique used in computing to solve problems by breaking them down into simpler, smaller subproblems and using the solutions to these subproblems to construct a solution to the original problem. DP can be a tough concept to master, and it often isn\\'t immediately obvious how to apply it to a new problem. \\n\\nThe fundamental concept behind Kadane\\'s algorithm is the idea of \"local maximum\" and \"global maximum\". \\n\\n1. The local maximum at each position is the maximum of the current number and the sum of the current number and the previous local maximum. This basically means we have two choices at each step: to add the current number to the subarray or start a new subarray with the current number. We choose the option that gives the maximum sum.\\n\\n2. The global maximum is the maximum sum of all subarrays that we\\'ve seen so far.\\n\\nEven if you didn\\'t come up with this solution yourself, now that you\\'ve seen it and understand it, you\\'re likely to recognize similar problems in the future where a similar approach can be used. That\\'s how learning in programming often works: you encounter a wide variety of problems and learn techniques and algorithms from solving those problems, and then you apply those techniques to new problems."
                    },
                    {
                        "username": "ellenlloyd",
                        "content": "## How recent is this change? \\n\\nI know Maximum Subarray was [originally a **medium**](https://leetcode.com/discuss/general-discussion/522206/blind-curated-75-list-with-difficulty-level) when first released, but it was changed to rank **easy** since ages ago. (See [complaint posts](https://leetcode.com/problems/maximum-subarray/discuss/1727524/Shouldn\\'t-This-Problem-Be-A-Medium) like [these ones](https://leetcode.com/problems/maximum-subarray/discuss/475930/Why-is-this-classed-as-an-easy-question-It-is-not) in the [leetcode discussions](https://leetcode.com/problems/maximum-subarray/discuss/294613/Why-is-this-classified-as-%22easy%22).)\\n\\nNow it\\'s back as a medium! Must have changed within the last weeks at most? I\\'m curious to know when it happened.\\n\\nI do think it\\'s a good change. Even with guides and help, many a beginner coder has faced despair trying to understand this question AND the optimal-yet-unintuitive Kadane\\'s algorithm used to solve it. My past self included. \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    }
                ]
            },
            {
                "id": 1569319,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Optimized Brute Force\n\n  \n**Approach 2:** Dynamic Programming, Kadane's Algorithm\n\n  \n**Approach 3:** Divide and Conquer (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "tejastejas12",
                        "content": "here we are using kadane\\'s algo which gives optimal solution  of O(n )"
                    },
                    {
                        "username": "daynis",
                        "content": "I was asked a follow up question to this question in an interview.\" How would we solve this given that there is an endless incoming stream of numbers ?\"    Ideas anybody?"
                    },
                    {
                        "username": "bparanj",
                        "content": " The idea here is that you have a potentially unbounded stream of numbers and you want to keep track of the maximum subarray sum at any given time.\\n\\n Since Kadane\\'s algorithm processes the input once without needing to look at future elements, it can work just as well in a streaming scenario. \\n\\nHere\\'s a simple Python implementation:\\n\\n```python\\ndef max_subarray_stream(nums):\\n    current_sum = max_sum = float(\\'-inf\\')\\n\\n    for num in nums:\\n        current_sum = max(num, current_sum + num)\\n        max_sum = max(max_sum, current_sum)\\n    \\n    return max_sum\\n```\\n\\nThis function can be used in a streaming context as follows:\\n\\n```python\\nstream = [...]  # Replace with the actual stream of numbers.\\nmax_sum = float(\\'-inf\\')\\n\\nfor chunk in stream:  # Process the stream in chunks.\\n    max_sum = max(max_sum, max_subarray_stream(chunk))\\n    print(f\\'Maximum subarray sum so far: {max_sum}\\')\\n```\\n\\nThis implementation assumes that the stream can be processed in chunks. Each chunk could be a list of numbers that are processed all at once by the `max_subarray_stream` function. \\n\\nIn a real-world scenario, the chunk size would depend on factors like the rate at which data is received from the stream and the memory constraints of the machine running this code. It\\'s worth noting that the chunk size does not affect the final result, because Kadane\\'s algorithm does not depend on future data."
                    },
                    {
                        "username": "lalananya55",
                        "content": "First output case says : [1, 4, -1, 2]  as max subarray with output 6\\nShould not it ne [1,4,2] with output 7\\n"
                    },
                    {
                        "username": "RanjeetP",
                        "content": "becoz we have to use contiguous subarray\\n"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "[@BinaryMusaib](/BinaryMusaib) why we have to subtract from -1 when we are getting maximum sum 7!"
                    },
                    {
                        "username": "BinaryMusaib",
                        "content": "No, The output will be 6 because you have to subtract (negative)1 to the array."
                    },
                    {
                        "username": "parambole",
                        "content": "There are several articles out there that mention ways to solve DP problems. But, the problem is that every DP problem is different. \\n\\nWhat one needs to learn is how to reach to the DP solution. \\n\\n**STEP 1: Start with Brute Force:** \\n\\nYes, you heard it right. Because DP is nothing but intelligent guessing. We need to do an exhaustive search on every possible combination and pick the most optimal combination. \\n\\n**STEP 2: Draw out your solution - > This is the most critical step**\\n\\nDraw the steps that your brute force solution is taking. Because unless you visualize what your algorithm is doing. You can never come up with a DP solution.\\n\\n**STEP 3: Think about repeated steps and how to store and use them**\\n\\nIt is not just important to know what steps are getting repeated. What is essential is to understand how can you store your calculations and re-usage them."
                    },
                    {
                        "username": "Thisismeaditya_singh",
                        "content": "Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\n\nShould'nt it be 7? with subarray of  [4,2,1] ??? Am I missing something here?"
                    },
                    {
                        "username": "varshinir822",
                        "content": "[@PrasannaNaik211](/PrasannaNaik211) because a subarray has to be a consecutive sequence"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "Yes even I also have same doubt why we have to subtract from -1 when we are already getting maximum sum 7\\n"
                    },
                    {
                        "username": "pythonCoderHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/maximum-subarray-leetcode-python-solution/"
                    },
                    {
                        "username": "Depender",
                        "content": "![image](https://assets.leetcode.com/users/images/7fa2d39d-0c2e-47b8-86a6-4726837c1676_1645458692.698741.png)\\n"
                    },
                    {
                        "username": "mknaveen837",
                        "content": "![image](https://assets.leetcode.com/users/images/fc6091ab-502c-42c6-8cdc-10280d415573_1598457725.3748913.png)\\nWhats the error The same custome test input works fine plz help"
                    },
                    {
                        "username": "p-neiderman",
                        "content": "I implemented the brute force solution after thinking on it for a while, but after trying and failing to think of an O(n) solution, I looked up Kadane\\'s algorithm and it seems almost trivial. I feel a little ashamed of not being able to implement it on my own. Are there some fundamental concepts I\\'m missing here? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Kadane\\'s Algorithm falls under the category of Dynamic Programming (DP), which is a technique used in computing to solve problems by breaking them down into simpler, smaller subproblems and using the solutions to these subproblems to construct a solution to the original problem. DP can be a tough concept to master, and it often isn\\'t immediately obvious how to apply it to a new problem. \\n\\nThe fundamental concept behind Kadane\\'s algorithm is the idea of \"local maximum\" and \"global maximum\". \\n\\n1. The local maximum at each position is the maximum of the current number and the sum of the current number and the previous local maximum. This basically means we have two choices at each step: to add the current number to the subarray or start a new subarray with the current number. We choose the option that gives the maximum sum.\\n\\n2. The global maximum is the maximum sum of all subarrays that we\\'ve seen so far.\\n\\nEven if you didn\\'t come up with this solution yourself, now that you\\'ve seen it and understand it, you\\'re likely to recognize similar problems in the future where a similar approach can be used. That\\'s how learning in programming often works: you encounter a wide variety of problems and learn techniques and algorithms from solving those problems, and then you apply those techniques to new problems."
                    },
                    {
                        "username": "ellenlloyd",
                        "content": "## How recent is this change? \\n\\nI know Maximum Subarray was [originally a **medium**](https://leetcode.com/discuss/general-discussion/522206/blind-curated-75-list-with-difficulty-level) when first released, but it was changed to rank **easy** since ages ago. (See [complaint posts](https://leetcode.com/problems/maximum-subarray/discuss/1727524/Shouldn\\'t-This-Problem-Be-A-Medium) like [these ones](https://leetcode.com/problems/maximum-subarray/discuss/475930/Why-is-this-classed-as-an-easy-question-It-is-not) in the [leetcode discussions](https://leetcode.com/problems/maximum-subarray/discuss/294613/Why-is-this-classified-as-%22easy%22).)\\n\\nNow it\\'s back as a medium! Must have changed within the last weeks at most? I\\'m curious to know when it happened.\\n\\nI do think it\\'s a good change. Even with guides and help, many a beginner coder has faced despair trying to understand this question AND the optimal-yet-unintuitive Kadane\\'s algorithm used to solve it. My past self included. \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    }
                ]
            },
            {
                "id": 1809640,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Optimized Brute Force\n\n  \n**Approach 2:** Dynamic Programming, Kadane's Algorithm\n\n  \n**Approach 3:** Divide and Conquer (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "tejastejas12",
                        "content": "here we are using kadane\\'s algo which gives optimal solution  of O(n )"
                    },
                    {
                        "username": "daynis",
                        "content": "I was asked a follow up question to this question in an interview.\" How would we solve this given that there is an endless incoming stream of numbers ?\"    Ideas anybody?"
                    },
                    {
                        "username": "bparanj",
                        "content": " The idea here is that you have a potentially unbounded stream of numbers and you want to keep track of the maximum subarray sum at any given time.\\n\\n Since Kadane\\'s algorithm processes the input once without needing to look at future elements, it can work just as well in a streaming scenario. \\n\\nHere\\'s a simple Python implementation:\\n\\n```python\\ndef max_subarray_stream(nums):\\n    current_sum = max_sum = float(\\'-inf\\')\\n\\n    for num in nums:\\n        current_sum = max(num, current_sum + num)\\n        max_sum = max(max_sum, current_sum)\\n    \\n    return max_sum\\n```\\n\\nThis function can be used in a streaming context as follows:\\n\\n```python\\nstream = [...]  # Replace with the actual stream of numbers.\\nmax_sum = float(\\'-inf\\')\\n\\nfor chunk in stream:  # Process the stream in chunks.\\n    max_sum = max(max_sum, max_subarray_stream(chunk))\\n    print(f\\'Maximum subarray sum so far: {max_sum}\\')\\n```\\n\\nThis implementation assumes that the stream can be processed in chunks. Each chunk could be a list of numbers that are processed all at once by the `max_subarray_stream` function. \\n\\nIn a real-world scenario, the chunk size would depend on factors like the rate at which data is received from the stream and the memory constraints of the machine running this code. It\\'s worth noting that the chunk size does not affect the final result, because Kadane\\'s algorithm does not depend on future data."
                    },
                    {
                        "username": "lalananya55",
                        "content": "First output case says : [1, 4, -1, 2]  as max subarray with output 6\\nShould not it ne [1,4,2] with output 7\\n"
                    },
                    {
                        "username": "RanjeetP",
                        "content": "becoz we have to use contiguous subarray\\n"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "[@BinaryMusaib](/BinaryMusaib) why we have to subtract from -1 when we are getting maximum sum 7!"
                    },
                    {
                        "username": "BinaryMusaib",
                        "content": "No, The output will be 6 because you have to subtract (negative)1 to the array."
                    },
                    {
                        "username": "parambole",
                        "content": "There are several articles out there that mention ways to solve DP problems. But, the problem is that every DP problem is different. \\n\\nWhat one needs to learn is how to reach to the DP solution. \\n\\n**STEP 1: Start with Brute Force:** \\n\\nYes, you heard it right. Because DP is nothing but intelligent guessing. We need to do an exhaustive search on every possible combination and pick the most optimal combination. \\n\\n**STEP 2: Draw out your solution - > This is the most critical step**\\n\\nDraw the steps that your brute force solution is taking. Because unless you visualize what your algorithm is doing. You can never come up with a DP solution.\\n\\n**STEP 3: Think about repeated steps and how to store and use them**\\n\\nIt is not just important to know what steps are getting repeated. What is essential is to understand how can you store your calculations and re-usage them."
                    },
                    {
                        "username": "Thisismeaditya_singh",
                        "content": "Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\n\nShould'nt it be 7? with subarray of  [4,2,1] ??? Am I missing something here?"
                    },
                    {
                        "username": "varshinir822",
                        "content": "[@PrasannaNaik211](/PrasannaNaik211) because a subarray has to be a consecutive sequence"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "Yes even I also have same doubt why we have to subtract from -1 when we are already getting maximum sum 7\\n"
                    },
                    {
                        "username": "pythonCoderHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/maximum-subarray-leetcode-python-solution/"
                    },
                    {
                        "username": "Depender",
                        "content": "![image](https://assets.leetcode.com/users/images/7fa2d39d-0c2e-47b8-86a6-4726837c1676_1645458692.698741.png)\\n"
                    },
                    {
                        "username": "mknaveen837",
                        "content": "![image](https://assets.leetcode.com/users/images/fc6091ab-502c-42c6-8cdc-10280d415573_1598457725.3748913.png)\\nWhats the error The same custome test input works fine plz help"
                    },
                    {
                        "username": "p-neiderman",
                        "content": "I implemented the brute force solution after thinking on it for a while, but after trying and failing to think of an O(n) solution, I looked up Kadane\\'s algorithm and it seems almost trivial. I feel a little ashamed of not being able to implement it on my own. Are there some fundamental concepts I\\'m missing here? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Kadane\\'s Algorithm falls under the category of Dynamic Programming (DP), which is a technique used in computing to solve problems by breaking them down into simpler, smaller subproblems and using the solutions to these subproblems to construct a solution to the original problem. DP can be a tough concept to master, and it often isn\\'t immediately obvious how to apply it to a new problem. \\n\\nThe fundamental concept behind Kadane\\'s algorithm is the idea of \"local maximum\" and \"global maximum\". \\n\\n1. The local maximum at each position is the maximum of the current number and the sum of the current number and the previous local maximum. This basically means we have two choices at each step: to add the current number to the subarray or start a new subarray with the current number. We choose the option that gives the maximum sum.\\n\\n2. The global maximum is the maximum sum of all subarrays that we\\'ve seen so far.\\n\\nEven if you didn\\'t come up with this solution yourself, now that you\\'ve seen it and understand it, you\\'re likely to recognize similar problems in the future where a similar approach can be used. That\\'s how learning in programming often works: you encounter a wide variety of problems and learn techniques and algorithms from solving those problems, and then you apply those techniques to new problems."
                    },
                    {
                        "username": "ellenlloyd",
                        "content": "## How recent is this change? \\n\\nI know Maximum Subarray was [originally a **medium**](https://leetcode.com/discuss/general-discussion/522206/blind-curated-75-list-with-difficulty-level) when first released, but it was changed to rank **easy** since ages ago. (See [complaint posts](https://leetcode.com/problems/maximum-subarray/discuss/1727524/Shouldn\\'t-This-Problem-Be-A-Medium) like [these ones](https://leetcode.com/problems/maximum-subarray/discuss/475930/Why-is-this-classed-as-an-easy-question-It-is-not) in the [leetcode discussions](https://leetcode.com/problems/maximum-subarray/discuss/294613/Why-is-this-classified-as-%22easy%22).)\\n\\nNow it\\'s back as a medium! Must have changed within the last weeks at most? I\\'m curious to know when it happened.\\n\\nI do think it\\'s a good change. Even with guides and help, many a beginner coder has faced despair trying to understand this question AND the optimal-yet-unintuitive Kadane\\'s algorithm used to solve it. My past self included. \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    }
                ]
            },
            {
                "id": 1568251,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Optimized Brute Force\n\n  \n**Approach 2:** Dynamic Programming, Kadane's Algorithm\n\n  \n**Approach 3:** Divide and Conquer (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "tejastejas12",
                        "content": "here we are using kadane\\'s algo which gives optimal solution  of O(n )"
                    },
                    {
                        "username": "daynis",
                        "content": "I was asked a follow up question to this question in an interview.\" How would we solve this given that there is an endless incoming stream of numbers ?\"    Ideas anybody?"
                    },
                    {
                        "username": "bparanj",
                        "content": " The idea here is that you have a potentially unbounded stream of numbers and you want to keep track of the maximum subarray sum at any given time.\\n\\n Since Kadane\\'s algorithm processes the input once without needing to look at future elements, it can work just as well in a streaming scenario. \\n\\nHere\\'s a simple Python implementation:\\n\\n```python\\ndef max_subarray_stream(nums):\\n    current_sum = max_sum = float(\\'-inf\\')\\n\\n    for num in nums:\\n        current_sum = max(num, current_sum + num)\\n        max_sum = max(max_sum, current_sum)\\n    \\n    return max_sum\\n```\\n\\nThis function can be used in a streaming context as follows:\\n\\n```python\\nstream = [...]  # Replace with the actual stream of numbers.\\nmax_sum = float(\\'-inf\\')\\n\\nfor chunk in stream:  # Process the stream in chunks.\\n    max_sum = max(max_sum, max_subarray_stream(chunk))\\n    print(f\\'Maximum subarray sum so far: {max_sum}\\')\\n```\\n\\nThis implementation assumes that the stream can be processed in chunks. Each chunk could be a list of numbers that are processed all at once by the `max_subarray_stream` function. \\n\\nIn a real-world scenario, the chunk size would depend on factors like the rate at which data is received from the stream and the memory constraints of the machine running this code. It\\'s worth noting that the chunk size does not affect the final result, because Kadane\\'s algorithm does not depend on future data."
                    },
                    {
                        "username": "lalananya55",
                        "content": "First output case says : [1, 4, -1, 2]  as max subarray with output 6\\nShould not it ne [1,4,2] with output 7\\n"
                    },
                    {
                        "username": "RanjeetP",
                        "content": "becoz we have to use contiguous subarray\\n"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "[@BinaryMusaib](/BinaryMusaib) why we have to subtract from -1 when we are getting maximum sum 7!"
                    },
                    {
                        "username": "BinaryMusaib",
                        "content": "No, The output will be 6 because you have to subtract (negative)1 to the array."
                    },
                    {
                        "username": "parambole",
                        "content": "There are several articles out there that mention ways to solve DP problems. But, the problem is that every DP problem is different. \\n\\nWhat one needs to learn is how to reach to the DP solution. \\n\\n**STEP 1: Start with Brute Force:** \\n\\nYes, you heard it right. Because DP is nothing but intelligent guessing. We need to do an exhaustive search on every possible combination and pick the most optimal combination. \\n\\n**STEP 2: Draw out your solution - > This is the most critical step**\\n\\nDraw the steps that your brute force solution is taking. Because unless you visualize what your algorithm is doing. You can never come up with a DP solution.\\n\\n**STEP 3: Think about repeated steps and how to store and use them**\\n\\nIt is not just important to know what steps are getting repeated. What is essential is to understand how can you store your calculations and re-usage them."
                    },
                    {
                        "username": "Thisismeaditya_singh",
                        "content": "Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\n\nShould'nt it be 7? with subarray of  [4,2,1] ??? Am I missing something here?"
                    },
                    {
                        "username": "varshinir822",
                        "content": "[@PrasannaNaik211](/PrasannaNaik211) because a subarray has to be a consecutive sequence"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "Yes even I also have same doubt why we have to subtract from -1 when we are already getting maximum sum 7\\n"
                    },
                    {
                        "username": "pythonCoderHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/maximum-subarray-leetcode-python-solution/"
                    },
                    {
                        "username": "Depender",
                        "content": "![image](https://assets.leetcode.com/users/images/7fa2d39d-0c2e-47b8-86a6-4726837c1676_1645458692.698741.png)\\n"
                    },
                    {
                        "username": "mknaveen837",
                        "content": "![image](https://assets.leetcode.com/users/images/fc6091ab-502c-42c6-8cdc-10280d415573_1598457725.3748913.png)\\nWhats the error The same custome test input works fine plz help"
                    },
                    {
                        "username": "p-neiderman",
                        "content": "I implemented the brute force solution after thinking on it for a while, but after trying and failing to think of an O(n) solution, I looked up Kadane\\'s algorithm and it seems almost trivial. I feel a little ashamed of not being able to implement it on my own. Are there some fundamental concepts I\\'m missing here? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Kadane\\'s Algorithm falls under the category of Dynamic Programming (DP), which is a technique used in computing to solve problems by breaking them down into simpler, smaller subproblems and using the solutions to these subproblems to construct a solution to the original problem. DP can be a tough concept to master, and it often isn\\'t immediately obvious how to apply it to a new problem. \\n\\nThe fundamental concept behind Kadane\\'s algorithm is the idea of \"local maximum\" and \"global maximum\". \\n\\n1. The local maximum at each position is the maximum of the current number and the sum of the current number and the previous local maximum. This basically means we have two choices at each step: to add the current number to the subarray or start a new subarray with the current number. We choose the option that gives the maximum sum.\\n\\n2. The global maximum is the maximum sum of all subarrays that we\\'ve seen so far.\\n\\nEven if you didn\\'t come up with this solution yourself, now that you\\'ve seen it and understand it, you\\'re likely to recognize similar problems in the future where a similar approach can be used. That\\'s how learning in programming often works: you encounter a wide variety of problems and learn techniques and algorithms from solving those problems, and then you apply those techniques to new problems."
                    },
                    {
                        "username": "ellenlloyd",
                        "content": "## How recent is this change? \\n\\nI know Maximum Subarray was [originally a **medium**](https://leetcode.com/discuss/general-discussion/522206/blind-curated-75-list-with-difficulty-level) when first released, but it was changed to rank **easy** since ages ago. (See [complaint posts](https://leetcode.com/problems/maximum-subarray/discuss/1727524/Shouldn\\'t-This-Problem-Be-A-Medium) like [these ones](https://leetcode.com/problems/maximum-subarray/discuss/475930/Why-is-this-classed-as-an-easy-question-It-is-not) in the [leetcode discussions](https://leetcode.com/problems/maximum-subarray/discuss/294613/Why-is-this-classified-as-%22easy%22).)\\n\\nNow it\\'s back as a medium! Must have changed within the last weeks at most? I\\'m curious to know when it happened.\\n\\nI do think it\\'s a good change. Even with guides and help, many a beginner coder has faced despair trying to understand this question AND the optimal-yet-unintuitive Kadane\\'s algorithm used to solve it. My past self included. \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    }
                ]
            },
            {
                "id": 1774345,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Optimized Brute Force\n\n  \n**Approach 2:** Dynamic Programming, Kadane's Algorithm\n\n  \n**Approach 3:** Divide and Conquer (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "tejastejas12",
                        "content": "here we are using kadane\\'s algo which gives optimal solution  of O(n )"
                    },
                    {
                        "username": "daynis",
                        "content": "I was asked a follow up question to this question in an interview.\" How would we solve this given that there is an endless incoming stream of numbers ?\"    Ideas anybody?"
                    },
                    {
                        "username": "bparanj",
                        "content": " The idea here is that you have a potentially unbounded stream of numbers and you want to keep track of the maximum subarray sum at any given time.\\n\\n Since Kadane\\'s algorithm processes the input once without needing to look at future elements, it can work just as well in a streaming scenario. \\n\\nHere\\'s a simple Python implementation:\\n\\n```python\\ndef max_subarray_stream(nums):\\n    current_sum = max_sum = float(\\'-inf\\')\\n\\n    for num in nums:\\n        current_sum = max(num, current_sum + num)\\n        max_sum = max(max_sum, current_sum)\\n    \\n    return max_sum\\n```\\n\\nThis function can be used in a streaming context as follows:\\n\\n```python\\nstream = [...]  # Replace with the actual stream of numbers.\\nmax_sum = float(\\'-inf\\')\\n\\nfor chunk in stream:  # Process the stream in chunks.\\n    max_sum = max(max_sum, max_subarray_stream(chunk))\\n    print(f\\'Maximum subarray sum so far: {max_sum}\\')\\n```\\n\\nThis implementation assumes that the stream can be processed in chunks. Each chunk could be a list of numbers that are processed all at once by the `max_subarray_stream` function. \\n\\nIn a real-world scenario, the chunk size would depend on factors like the rate at which data is received from the stream and the memory constraints of the machine running this code. It\\'s worth noting that the chunk size does not affect the final result, because Kadane\\'s algorithm does not depend on future data."
                    },
                    {
                        "username": "lalananya55",
                        "content": "First output case says : [1, 4, -1, 2]  as max subarray with output 6\\nShould not it ne [1,4,2] with output 7\\n"
                    },
                    {
                        "username": "RanjeetP",
                        "content": "becoz we have to use contiguous subarray\\n"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "[@BinaryMusaib](/BinaryMusaib) why we have to subtract from -1 when we are getting maximum sum 7!"
                    },
                    {
                        "username": "BinaryMusaib",
                        "content": "No, The output will be 6 because you have to subtract (negative)1 to the array."
                    },
                    {
                        "username": "parambole",
                        "content": "There are several articles out there that mention ways to solve DP problems. But, the problem is that every DP problem is different. \\n\\nWhat one needs to learn is how to reach to the DP solution. \\n\\n**STEP 1: Start with Brute Force:** \\n\\nYes, you heard it right. Because DP is nothing but intelligent guessing. We need to do an exhaustive search on every possible combination and pick the most optimal combination. \\n\\n**STEP 2: Draw out your solution - > This is the most critical step**\\n\\nDraw the steps that your brute force solution is taking. Because unless you visualize what your algorithm is doing. You can never come up with a DP solution.\\n\\n**STEP 3: Think about repeated steps and how to store and use them**\\n\\nIt is not just important to know what steps are getting repeated. What is essential is to understand how can you store your calculations and re-usage them."
                    },
                    {
                        "username": "Thisismeaditya_singh",
                        "content": "Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\n\nShould'nt it be 7? with subarray of  [4,2,1] ??? Am I missing something here?"
                    },
                    {
                        "username": "varshinir822",
                        "content": "[@PrasannaNaik211](/PrasannaNaik211) because a subarray has to be a consecutive sequence"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "Yes even I also have same doubt why we have to subtract from -1 when we are already getting maximum sum 7\\n"
                    },
                    {
                        "username": "pythonCoderHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/maximum-subarray-leetcode-python-solution/"
                    },
                    {
                        "username": "Depender",
                        "content": "![image](https://assets.leetcode.com/users/images/7fa2d39d-0c2e-47b8-86a6-4726837c1676_1645458692.698741.png)\\n"
                    },
                    {
                        "username": "mknaveen837",
                        "content": "![image](https://assets.leetcode.com/users/images/fc6091ab-502c-42c6-8cdc-10280d415573_1598457725.3748913.png)\\nWhats the error The same custome test input works fine plz help"
                    },
                    {
                        "username": "p-neiderman",
                        "content": "I implemented the brute force solution after thinking on it for a while, but after trying and failing to think of an O(n) solution, I looked up Kadane\\'s algorithm and it seems almost trivial. I feel a little ashamed of not being able to implement it on my own. Are there some fundamental concepts I\\'m missing here? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Kadane\\'s Algorithm falls under the category of Dynamic Programming (DP), which is a technique used in computing to solve problems by breaking them down into simpler, smaller subproblems and using the solutions to these subproblems to construct a solution to the original problem. DP can be a tough concept to master, and it often isn\\'t immediately obvious how to apply it to a new problem. \\n\\nThe fundamental concept behind Kadane\\'s algorithm is the idea of \"local maximum\" and \"global maximum\". \\n\\n1. The local maximum at each position is the maximum of the current number and the sum of the current number and the previous local maximum. This basically means we have two choices at each step: to add the current number to the subarray or start a new subarray with the current number. We choose the option that gives the maximum sum.\\n\\n2. The global maximum is the maximum sum of all subarrays that we\\'ve seen so far.\\n\\nEven if you didn\\'t come up with this solution yourself, now that you\\'ve seen it and understand it, you\\'re likely to recognize similar problems in the future where a similar approach can be used. That\\'s how learning in programming often works: you encounter a wide variety of problems and learn techniques and algorithms from solving those problems, and then you apply those techniques to new problems."
                    },
                    {
                        "username": "ellenlloyd",
                        "content": "## How recent is this change? \\n\\nI know Maximum Subarray was [originally a **medium**](https://leetcode.com/discuss/general-discussion/522206/blind-curated-75-list-with-difficulty-level) when first released, but it was changed to rank **easy** since ages ago. (See [complaint posts](https://leetcode.com/problems/maximum-subarray/discuss/1727524/Shouldn\\'t-This-Problem-Be-A-Medium) like [these ones](https://leetcode.com/problems/maximum-subarray/discuss/475930/Why-is-this-classed-as-an-easy-question-It-is-not) in the [leetcode discussions](https://leetcode.com/problems/maximum-subarray/discuss/294613/Why-is-this-classified-as-%22easy%22).)\\n\\nNow it\\'s back as a medium! Must have changed within the last weeks at most? I\\'m curious to know when it happened.\\n\\nI do think it\\'s a good change. Even with guides and help, many a beginner coder has faced despair trying to understand this question AND the optimal-yet-unintuitive Kadane\\'s algorithm used to solve it. My past self included. \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    }
                ]
            },
            {
                "id": 1570888,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Optimized Brute Force\n\n  \n**Approach 2:** Dynamic Programming, Kadane's Algorithm\n\n  \n**Approach 3:** Divide and Conquer (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "tejastejas12",
                        "content": "here we are using kadane\\'s algo which gives optimal solution  of O(n )"
                    },
                    {
                        "username": "daynis",
                        "content": "I was asked a follow up question to this question in an interview.\" How would we solve this given that there is an endless incoming stream of numbers ?\"    Ideas anybody?"
                    },
                    {
                        "username": "bparanj",
                        "content": " The idea here is that you have a potentially unbounded stream of numbers and you want to keep track of the maximum subarray sum at any given time.\\n\\n Since Kadane\\'s algorithm processes the input once without needing to look at future elements, it can work just as well in a streaming scenario. \\n\\nHere\\'s a simple Python implementation:\\n\\n```python\\ndef max_subarray_stream(nums):\\n    current_sum = max_sum = float(\\'-inf\\')\\n\\n    for num in nums:\\n        current_sum = max(num, current_sum + num)\\n        max_sum = max(max_sum, current_sum)\\n    \\n    return max_sum\\n```\\n\\nThis function can be used in a streaming context as follows:\\n\\n```python\\nstream = [...]  # Replace with the actual stream of numbers.\\nmax_sum = float(\\'-inf\\')\\n\\nfor chunk in stream:  # Process the stream in chunks.\\n    max_sum = max(max_sum, max_subarray_stream(chunk))\\n    print(f\\'Maximum subarray sum so far: {max_sum}\\')\\n```\\n\\nThis implementation assumes that the stream can be processed in chunks. Each chunk could be a list of numbers that are processed all at once by the `max_subarray_stream` function. \\n\\nIn a real-world scenario, the chunk size would depend on factors like the rate at which data is received from the stream and the memory constraints of the machine running this code. It\\'s worth noting that the chunk size does not affect the final result, because Kadane\\'s algorithm does not depend on future data."
                    },
                    {
                        "username": "lalananya55",
                        "content": "First output case says : [1, 4, -1, 2]  as max subarray with output 6\\nShould not it ne [1,4,2] with output 7\\n"
                    },
                    {
                        "username": "RanjeetP",
                        "content": "becoz we have to use contiguous subarray\\n"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "[@BinaryMusaib](/BinaryMusaib) why we have to subtract from -1 when we are getting maximum sum 7!"
                    },
                    {
                        "username": "BinaryMusaib",
                        "content": "No, The output will be 6 because you have to subtract (negative)1 to the array."
                    },
                    {
                        "username": "parambole",
                        "content": "There are several articles out there that mention ways to solve DP problems. But, the problem is that every DP problem is different. \\n\\nWhat one needs to learn is how to reach to the DP solution. \\n\\n**STEP 1: Start with Brute Force:** \\n\\nYes, you heard it right. Because DP is nothing but intelligent guessing. We need to do an exhaustive search on every possible combination and pick the most optimal combination. \\n\\n**STEP 2: Draw out your solution - > This is the most critical step**\\n\\nDraw the steps that your brute force solution is taking. Because unless you visualize what your algorithm is doing. You can never come up with a DP solution.\\n\\n**STEP 3: Think about repeated steps and how to store and use them**\\n\\nIt is not just important to know what steps are getting repeated. What is essential is to understand how can you store your calculations and re-usage them."
                    },
                    {
                        "username": "Thisismeaditya_singh",
                        "content": "Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\n\nShould'nt it be 7? with subarray of  [4,2,1] ??? Am I missing something here?"
                    },
                    {
                        "username": "varshinir822",
                        "content": "[@PrasannaNaik211](/PrasannaNaik211) because a subarray has to be a consecutive sequence"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "Yes even I also have same doubt why we have to subtract from -1 when we are already getting maximum sum 7\\n"
                    },
                    {
                        "username": "pythonCoderHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/maximum-subarray-leetcode-python-solution/"
                    },
                    {
                        "username": "Depender",
                        "content": "![image](https://assets.leetcode.com/users/images/7fa2d39d-0c2e-47b8-86a6-4726837c1676_1645458692.698741.png)\\n"
                    },
                    {
                        "username": "mknaveen837",
                        "content": "![image](https://assets.leetcode.com/users/images/fc6091ab-502c-42c6-8cdc-10280d415573_1598457725.3748913.png)\\nWhats the error The same custome test input works fine plz help"
                    },
                    {
                        "username": "p-neiderman",
                        "content": "I implemented the brute force solution after thinking on it for a while, but after trying and failing to think of an O(n) solution, I looked up Kadane\\'s algorithm and it seems almost trivial. I feel a little ashamed of not being able to implement it on my own. Are there some fundamental concepts I\\'m missing here? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Kadane\\'s Algorithm falls under the category of Dynamic Programming (DP), which is a technique used in computing to solve problems by breaking them down into simpler, smaller subproblems and using the solutions to these subproblems to construct a solution to the original problem. DP can be a tough concept to master, and it often isn\\'t immediately obvious how to apply it to a new problem. \\n\\nThe fundamental concept behind Kadane\\'s algorithm is the idea of \"local maximum\" and \"global maximum\". \\n\\n1. The local maximum at each position is the maximum of the current number and the sum of the current number and the previous local maximum. This basically means we have two choices at each step: to add the current number to the subarray or start a new subarray with the current number. We choose the option that gives the maximum sum.\\n\\n2. The global maximum is the maximum sum of all subarrays that we\\'ve seen so far.\\n\\nEven if you didn\\'t come up with this solution yourself, now that you\\'ve seen it and understand it, you\\'re likely to recognize similar problems in the future where a similar approach can be used. That\\'s how learning in programming often works: you encounter a wide variety of problems and learn techniques and algorithms from solving those problems, and then you apply those techniques to new problems."
                    },
                    {
                        "username": "ellenlloyd",
                        "content": "## How recent is this change? \\n\\nI know Maximum Subarray was [originally a **medium**](https://leetcode.com/discuss/general-discussion/522206/blind-curated-75-list-with-difficulty-level) when first released, but it was changed to rank **easy** since ages ago. (See [complaint posts](https://leetcode.com/problems/maximum-subarray/discuss/1727524/Shouldn\\'t-This-Problem-Be-A-Medium) like [these ones](https://leetcode.com/problems/maximum-subarray/discuss/475930/Why-is-this-classed-as-an-easy-question-It-is-not) in the [leetcode discussions](https://leetcode.com/problems/maximum-subarray/discuss/294613/Why-is-this-classified-as-%22easy%22).)\\n\\nNow it\\'s back as a medium! Must have changed within the last weeks at most? I\\'m curious to know when it happened.\\n\\nI do think it\\'s a good change. Even with guides and help, many a beginner coder has faced despair trying to understand this question AND the optimal-yet-unintuitive Kadane\\'s algorithm used to solve it. My past self included. \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    }
                ]
            },
            {
                "id": 1570803,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Optimized Brute Force\n\n  \n**Approach 2:** Dynamic Programming, Kadane's Algorithm\n\n  \n**Approach 3:** Divide and Conquer (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "tejastejas12",
                        "content": "here we are using kadane\\'s algo which gives optimal solution  of O(n )"
                    },
                    {
                        "username": "daynis",
                        "content": "I was asked a follow up question to this question in an interview.\" How would we solve this given that there is an endless incoming stream of numbers ?\"    Ideas anybody?"
                    },
                    {
                        "username": "bparanj",
                        "content": " The idea here is that you have a potentially unbounded stream of numbers and you want to keep track of the maximum subarray sum at any given time.\\n\\n Since Kadane\\'s algorithm processes the input once without needing to look at future elements, it can work just as well in a streaming scenario. \\n\\nHere\\'s a simple Python implementation:\\n\\n```python\\ndef max_subarray_stream(nums):\\n    current_sum = max_sum = float(\\'-inf\\')\\n\\n    for num in nums:\\n        current_sum = max(num, current_sum + num)\\n        max_sum = max(max_sum, current_sum)\\n    \\n    return max_sum\\n```\\n\\nThis function can be used in a streaming context as follows:\\n\\n```python\\nstream = [...]  # Replace with the actual stream of numbers.\\nmax_sum = float(\\'-inf\\')\\n\\nfor chunk in stream:  # Process the stream in chunks.\\n    max_sum = max(max_sum, max_subarray_stream(chunk))\\n    print(f\\'Maximum subarray sum so far: {max_sum}\\')\\n```\\n\\nThis implementation assumes that the stream can be processed in chunks. Each chunk could be a list of numbers that are processed all at once by the `max_subarray_stream` function. \\n\\nIn a real-world scenario, the chunk size would depend on factors like the rate at which data is received from the stream and the memory constraints of the machine running this code. It\\'s worth noting that the chunk size does not affect the final result, because Kadane\\'s algorithm does not depend on future data."
                    },
                    {
                        "username": "lalananya55",
                        "content": "First output case says : [1, 4, -1, 2]  as max subarray with output 6\\nShould not it ne [1,4,2] with output 7\\n"
                    },
                    {
                        "username": "RanjeetP",
                        "content": "becoz we have to use contiguous subarray\\n"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "[@BinaryMusaib](/BinaryMusaib) why we have to subtract from -1 when we are getting maximum sum 7!"
                    },
                    {
                        "username": "BinaryMusaib",
                        "content": "No, The output will be 6 because you have to subtract (negative)1 to the array."
                    },
                    {
                        "username": "parambole",
                        "content": "There are several articles out there that mention ways to solve DP problems. But, the problem is that every DP problem is different. \\n\\nWhat one needs to learn is how to reach to the DP solution. \\n\\n**STEP 1: Start with Brute Force:** \\n\\nYes, you heard it right. Because DP is nothing but intelligent guessing. We need to do an exhaustive search on every possible combination and pick the most optimal combination. \\n\\n**STEP 2: Draw out your solution - > This is the most critical step**\\n\\nDraw the steps that your brute force solution is taking. Because unless you visualize what your algorithm is doing. You can never come up with a DP solution.\\n\\n**STEP 3: Think about repeated steps and how to store and use them**\\n\\nIt is not just important to know what steps are getting repeated. What is essential is to understand how can you store your calculations and re-usage them."
                    },
                    {
                        "username": "Thisismeaditya_singh",
                        "content": "Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\n\nShould'nt it be 7? with subarray of  [4,2,1] ??? Am I missing something here?"
                    },
                    {
                        "username": "varshinir822",
                        "content": "[@PrasannaNaik211](/PrasannaNaik211) because a subarray has to be a consecutive sequence"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "Yes even I also have same doubt why we have to subtract from -1 when we are already getting maximum sum 7\\n"
                    },
                    {
                        "username": "pythonCoderHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/maximum-subarray-leetcode-python-solution/"
                    },
                    {
                        "username": "Depender",
                        "content": "![image](https://assets.leetcode.com/users/images/7fa2d39d-0c2e-47b8-86a6-4726837c1676_1645458692.698741.png)\\n"
                    },
                    {
                        "username": "mknaveen837",
                        "content": "![image](https://assets.leetcode.com/users/images/fc6091ab-502c-42c6-8cdc-10280d415573_1598457725.3748913.png)\\nWhats the error The same custome test input works fine plz help"
                    },
                    {
                        "username": "p-neiderman",
                        "content": "I implemented the brute force solution after thinking on it for a while, but after trying and failing to think of an O(n) solution, I looked up Kadane\\'s algorithm and it seems almost trivial. I feel a little ashamed of not being able to implement it on my own. Are there some fundamental concepts I\\'m missing here? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Kadane\\'s Algorithm falls under the category of Dynamic Programming (DP), which is a technique used in computing to solve problems by breaking them down into simpler, smaller subproblems and using the solutions to these subproblems to construct a solution to the original problem. DP can be a tough concept to master, and it often isn\\'t immediately obvious how to apply it to a new problem. \\n\\nThe fundamental concept behind Kadane\\'s algorithm is the idea of \"local maximum\" and \"global maximum\". \\n\\n1. The local maximum at each position is the maximum of the current number and the sum of the current number and the previous local maximum. This basically means we have two choices at each step: to add the current number to the subarray or start a new subarray with the current number. We choose the option that gives the maximum sum.\\n\\n2. The global maximum is the maximum sum of all subarrays that we\\'ve seen so far.\\n\\nEven if you didn\\'t come up with this solution yourself, now that you\\'ve seen it and understand it, you\\'re likely to recognize similar problems in the future where a similar approach can be used. That\\'s how learning in programming often works: you encounter a wide variety of problems and learn techniques and algorithms from solving those problems, and then you apply those techniques to new problems."
                    },
                    {
                        "username": "ellenlloyd",
                        "content": "## How recent is this change? \\n\\nI know Maximum Subarray was [originally a **medium**](https://leetcode.com/discuss/general-discussion/522206/blind-curated-75-list-with-difficulty-level) when first released, but it was changed to rank **easy** since ages ago. (See [complaint posts](https://leetcode.com/problems/maximum-subarray/discuss/1727524/Shouldn\\'t-This-Problem-Be-A-Medium) like [these ones](https://leetcode.com/problems/maximum-subarray/discuss/475930/Why-is-this-classed-as-an-easy-question-It-is-not) in the [leetcode discussions](https://leetcode.com/problems/maximum-subarray/discuss/294613/Why-is-this-classified-as-%22easy%22).)\\n\\nNow it\\'s back as a medium! Must have changed within the last weeks at most? I\\'m curious to know when it happened.\\n\\nI do think it\\'s a good change. Even with guides and help, many a beginner coder has faced despair trying to understand this question AND the optimal-yet-unintuitive Kadane\\'s algorithm used to solve it. My past self included. \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    }
                ]
            },
            {
                "id": 1574280,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Optimized Brute Force\n\n  \n**Approach 2:** Dynamic Programming, Kadane's Algorithm\n\n  \n**Approach 3:** Divide and Conquer (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "tejastejas12",
                        "content": "here we are using kadane\\'s algo which gives optimal solution  of O(n )"
                    },
                    {
                        "username": "daynis",
                        "content": "I was asked a follow up question to this question in an interview.\" How would we solve this given that there is an endless incoming stream of numbers ?\"    Ideas anybody?"
                    },
                    {
                        "username": "bparanj",
                        "content": " The idea here is that you have a potentially unbounded stream of numbers and you want to keep track of the maximum subarray sum at any given time.\\n\\n Since Kadane\\'s algorithm processes the input once without needing to look at future elements, it can work just as well in a streaming scenario. \\n\\nHere\\'s a simple Python implementation:\\n\\n```python\\ndef max_subarray_stream(nums):\\n    current_sum = max_sum = float(\\'-inf\\')\\n\\n    for num in nums:\\n        current_sum = max(num, current_sum + num)\\n        max_sum = max(max_sum, current_sum)\\n    \\n    return max_sum\\n```\\n\\nThis function can be used in a streaming context as follows:\\n\\n```python\\nstream = [...]  # Replace with the actual stream of numbers.\\nmax_sum = float(\\'-inf\\')\\n\\nfor chunk in stream:  # Process the stream in chunks.\\n    max_sum = max(max_sum, max_subarray_stream(chunk))\\n    print(f\\'Maximum subarray sum so far: {max_sum}\\')\\n```\\n\\nThis implementation assumes that the stream can be processed in chunks. Each chunk could be a list of numbers that are processed all at once by the `max_subarray_stream` function. \\n\\nIn a real-world scenario, the chunk size would depend on factors like the rate at which data is received from the stream and the memory constraints of the machine running this code. It\\'s worth noting that the chunk size does not affect the final result, because Kadane\\'s algorithm does not depend on future data."
                    },
                    {
                        "username": "lalananya55",
                        "content": "First output case says : [1, 4, -1, 2]  as max subarray with output 6\\nShould not it ne [1,4,2] with output 7\\n"
                    },
                    {
                        "username": "RanjeetP",
                        "content": "becoz we have to use contiguous subarray\\n"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "[@BinaryMusaib](/BinaryMusaib) why we have to subtract from -1 when we are getting maximum sum 7!"
                    },
                    {
                        "username": "BinaryMusaib",
                        "content": "No, The output will be 6 because you have to subtract (negative)1 to the array."
                    },
                    {
                        "username": "parambole",
                        "content": "There are several articles out there that mention ways to solve DP problems. But, the problem is that every DP problem is different. \\n\\nWhat one needs to learn is how to reach to the DP solution. \\n\\n**STEP 1: Start with Brute Force:** \\n\\nYes, you heard it right. Because DP is nothing but intelligent guessing. We need to do an exhaustive search on every possible combination and pick the most optimal combination. \\n\\n**STEP 2: Draw out your solution - > This is the most critical step**\\n\\nDraw the steps that your brute force solution is taking. Because unless you visualize what your algorithm is doing. You can never come up with a DP solution.\\n\\n**STEP 3: Think about repeated steps and how to store and use them**\\n\\nIt is not just important to know what steps are getting repeated. What is essential is to understand how can you store your calculations and re-usage them."
                    },
                    {
                        "username": "Thisismeaditya_singh",
                        "content": "Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\n\nShould'nt it be 7? with subarray of  [4,2,1] ??? Am I missing something here?"
                    },
                    {
                        "username": "varshinir822",
                        "content": "[@PrasannaNaik211](/PrasannaNaik211) because a subarray has to be a consecutive sequence"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "Yes even I also have same doubt why we have to subtract from -1 when we are already getting maximum sum 7\\n"
                    },
                    {
                        "username": "pythonCoderHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/maximum-subarray-leetcode-python-solution/"
                    },
                    {
                        "username": "Depender",
                        "content": "![image](https://assets.leetcode.com/users/images/7fa2d39d-0c2e-47b8-86a6-4726837c1676_1645458692.698741.png)\\n"
                    },
                    {
                        "username": "mknaveen837",
                        "content": "![image](https://assets.leetcode.com/users/images/fc6091ab-502c-42c6-8cdc-10280d415573_1598457725.3748913.png)\\nWhats the error The same custome test input works fine plz help"
                    },
                    {
                        "username": "p-neiderman",
                        "content": "I implemented the brute force solution after thinking on it for a while, but after trying and failing to think of an O(n) solution, I looked up Kadane\\'s algorithm and it seems almost trivial. I feel a little ashamed of not being able to implement it on my own. Are there some fundamental concepts I\\'m missing here? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Kadane\\'s Algorithm falls under the category of Dynamic Programming (DP), which is a technique used in computing to solve problems by breaking them down into simpler, smaller subproblems and using the solutions to these subproblems to construct a solution to the original problem. DP can be a tough concept to master, and it often isn\\'t immediately obvious how to apply it to a new problem. \\n\\nThe fundamental concept behind Kadane\\'s algorithm is the idea of \"local maximum\" and \"global maximum\". \\n\\n1. The local maximum at each position is the maximum of the current number and the sum of the current number and the previous local maximum. This basically means we have two choices at each step: to add the current number to the subarray or start a new subarray with the current number. We choose the option that gives the maximum sum.\\n\\n2. The global maximum is the maximum sum of all subarrays that we\\'ve seen so far.\\n\\nEven if you didn\\'t come up with this solution yourself, now that you\\'ve seen it and understand it, you\\'re likely to recognize similar problems in the future where a similar approach can be used. That\\'s how learning in programming often works: you encounter a wide variety of problems and learn techniques and algorithms from solving those problems, and then you apply those techniques to new problems."
                    },
                    {
                        "username": "ellenlloyd",
                        "content": "## How recent is this change? \\n\\nI know Maximum Subarray was [originally a **medium**](https://leetcode.com/discuss/general-discussion/522206/blind-curated-75-list-with-difficulty-level) when first released, but it was changed to rank **easy** since ages ago. (See [complaint posts](https://leetcode.com/problems/maximum-subarray/discuss/1727524/Shouldn\\'t-This-Problem-Be-A-Medium) like [these ones](https://leetcode.com/problems/maximum-subarray/discuss/475930/Why-is-this-classed-as-an-easy-question-It-is-not) in the [leetcode discussions](https://leetcode.com/problems/maximum-subarray/discuss/294613/Why-is-this-classified-as-%22easy%22).)\\n\\nNow it\\'s back as a medium! Must have changed within the last weeks at most? I\\'m curious to know when it happened.\\n\\nI do think it\\'s a good change. Even with guides and help, many a beginner coder has faced despair trying to understand this question AND the optimal-yet-unintuitive Kadane\\'s algorithm used to solve it. My past self included. \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    }
                ]
            },
            {
                "id": 1685368,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Optimized Brute Force\n\n  \n**Approach 2:** Dynamic Programming, Kadane's Algorithm\n\n  \n**Approach 3:** Divide and Conquer (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "tejastejas12",
                        "content": "here we are using kadane\\'s algo which gives optimal solution  of O(n )"
                    },
                    {
                        "username": "daynis",
                        "content": "I was asked a follow up question to this question in an interview.\" How would we solve this given that there is an endless incoming stream of numbers ?\"    Ideas anybody?"
                    },
                    {
                        "username": "bparanj",
                        "content": " The idea here is that you have a potentially unbounded stream of numbers and you want to keep track of the maximum subarray sum at any given time.\\n\\n Since Kadane\\'s algorithm processes the input once without needing to look at future elements, it can work just as well in a streaming scenario. \\n\\nHere\\'s a simple Python implementation:\\n\\n```python\\ndef max_subarray_stream(nums):\\n    current_sum = max_sum = float(\\'-inf\\')\\n\\n    for num in nums:\\n        current_sum = max(num, current_sum + num)\\n        max_sum = max(max_sum, current_sum)\\n    \\n    return max_sum\\n```\\n\\nThis function can be used in a streaming context as follows:\\n\\n```python\\nstream = [...]  # Replace with the actual stream of numbers.\\nmax_sum = float(\\'-inf\\')\\n\\nfor chunk in stream:  # Process the stream in chunks.\\n    max_sum = max(max_sum, max_subarray_stream(chunk))\\n    print(f\\'Maximum subarray sum so far: {max_sum}\\')\\n```\\n\\nThis implementation assumes that the stream can be processed in chunks. Each chunk could be a list of numbers that are processed all at once by the `max_subarray_stream` function. \\n\\nIn a real-world scenario, the chunk size would depend on factors like the rate at which data is received from the stream and the memory constraints of the machine running this code. It\\'s worth noting that the chunk size does not affect the final result, because Kadane\\'s algorithm does not depend on future data."
                    },
                    {
                        "username": "lalananya55",
                        "content": "First output case says : [1, 4, -1, 2]  as max subarray with output 6\\nShould not it ne [1,4,2] with output 7\\n"
                    },
                    {
                        "username": "RanjeetP",
                        "content": "becoz we have to use contiguous subarray\\n"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "[@BinaryMusaib](/BinaryMusaib) why we have to subtract from -1 when we are getting maximum sum 7!"
                    },
                    {
                        "username": "BinaryMusaib",
                        "content": "No, The output will be 6 because you have to subtract (negative)1 to the array."
                    },
                    {
                        "username": "parambole",
                        "content": "There are several articles out there that mention ways to solve DP problems. But, the problem is that every DP problem is different. \\n\\nWhat one needs to learn is how to reach to the DP solution. \\n\\n**STEP 1: Start with Brute Force:** \\n\\nYes, you heard it right. Because DP is nothing but intelligent guessing. We need to do an exhaustive search on every possible combination and pick the most optimal combination. \\n\\n**STEP 2: Draw out your solution - > This is the most critical step**\\n\\nDraw the steps that your brute force solution is taking. Because unless you visualize what your algorithm is doing. You can never come up with a DP solution.\\n\\n**STEP 3: Think about repeated steps and how to store and use them**\\n\\nIt is not just important to know what steps are getting repeated. What is essential is to understand how can you store your calculations and re-usage them."
                    },
                    {
                        "username": "Thisismeaditya_singh",
                        "content": "Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\n\nShould'nt it be 7? with subarray of  [4,2,1] ??? Am I missing something here?"
                    },
                    {
                        "username": "varshinir822",
                        "content": "[@PrasannaNaik211](/PrasannaNaik211) because a subarray has to be a consecutive sequence"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "Yes even I also have same doubt why we have to subtract from -1 when we are already getting maximum sum 7\\n"
                    },
                    {
                        "username": "pythonCoderHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/maximum-subarray-leetcode-python-solution/"
                    },
                    {
                        "username": "Depender",
                        "content": "![image](https://assets.leetcode.com/users/images/7fa2d39d-0c2e-47b8-86a6-4726837c1676_1645458692.698741.png)\\n"
                    },
                    {
                        "username": "mknaveen837",
                        "content": "![image](https://assets.leetcode.com/users/images/fc6091ab-502c-42c6-8cdc-10280d415573_1598457725.3748913.png)\\nWhats the error The same custome test input works fine plz help"
                    },
                    {
                        "username": "p-neiderman",
                        "content": "I implemented the brute force solution after thinking on it for a while, but after trying and failing to think of an O(n) solution, I looked up Kadane\\'s algorithm and it seems almost trivial. I feel a little ashamed of not being able to implement it on my own. Are there some fundamental concepts I\\'m missing here? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Kadane\\'s Algorithm falls under the category of Dynamic Programming (DP), which is a technique used in computing to solve problems by breaking them down into simpler, smaller subproblems and using the solutions to these subproblems to construct a solution to the original problem. DP can be a tough concept to master, and it often isn\\'t immediately obvious how to apply it to a new problem. \\n\\nThe fundamental concept behind Kadane\\'s algorithm is the idea of \"local maximum\" and \"global maximum\". \\n\\n1. The local maximum at each position is the maximum of the current number and the sum of the current number and the previous local maximum. This basically means we have two choices at each step: to add the current number to the subarray or start a new subarray with the current number. We choose the option that gives the maximum sum.\\n\\n2. The global maximum is the maximum sum of all subarrays that we\\'ve seen so far.\\n\\nEven if you didn\\'t come up with this solution yourself, now that you\\'ve seen it and understand it, you\\'re likely to recognize similar problems in the future where a similar approach can be used. That\\'s how learning in programming often works: you encounter a wide variety of problems and learn techniques and algorithms from solving those problems, and then you apply those techniques to new problems."
                    },
                    {
                        "username": "ellenlloyd",
                        "content": "## How recent is this change? \\n\\nI know Maximum Subarray was [originally a **medium**](https://leetcode.com/discuss/general-discussion/522206/blind-curated-75-list-with-difficulty-level) when first released, but it was changed to rank **easy** since ages ago. (See [complaint posts](https://leetcode.com/problems/maximum-subarray/discuss/1727524/Shouldn\\'t-This-Problem-Be-A-Medium) like [these ones](https://leetcode.com/problems/maximum-subarray/discuss/475930/Why-is-this-classed-as-an-easy-question-It-is-not) in the [leetcode discussions](https://leetcode.com/problems/maximum-subarray/discuss/294613/Why-is-this-classified-as-%22easy%22).)\\n\\nNow it\\'s back as a medium! Must have changed within the last weeks at most? I\\'m curious to know when it happened.\\n\\nI do think it\\'s a good change. Even with guides and help, many a beginner coder has faced despair trying to understand this question AND the optimal-yet-unintuitive Kadane\\'s algorithm used to solve it. My past self included. \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    }
                ]
            },
            {
                "id": 1570942,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-subarray/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Optimized Brute Force\n\n  \n**Approach 2:** Dynamic Programming, Kadane's Algorithm\n\n  \n**Approach 3:** Divide and Conquer (Advanced)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "tejastejas12",
                        "content": "here we are using kadane\\'s algo which gives optimal solution  of O(n )"
                    },
                    {
                        "username": "daynis",
                        "content": "I was asked a follow up question to this question in an interview.\" How would we solve this given that there is an endless incoming stream of numbers ?\"    Ideas anybody?"
                    },
                    {
                        "username": "bparanj",
                        "content": " The idea here is that you have a potentially unbounded stream of numbers and you want to keep track of the maximum subarray sum at any given time.\\n\\n Since Kadane\\'s algorithm processes the input once without needing to look at future elements, it can work just as well in a streaming scenario. \\n\\nHere\\'s a simple Python implementation:\\n\\n```python\\ndef max_subarray_stream(nums):\\n    current_sum = max_sum = float(\\'-inf\\')\\n\\n    for num in nums:\\n        current_sum = max(num, current_sum + num)\\n        max_sum = max(max_sum, current_sum)\\n    \\n    return max_sum\\n```\\n\\nThis function can be used in a streaming context as follows:\\n\\n```python\\nstream = [...]  # Replace with the actual stream of numbers.\\nmax_sum = float(\\'-inf\\')\\n\\nfor chunk in stream:  # Process the stream in chunks.\\n    max_sum = max(max_sum, max_subarray_stream(chunk))\\n    print(f\\'Maximum subarray sum so far: {max_sum}\\')\\n```\\n\\nThis implementation assumes that the stream can be processed in chunks. Each chunk could be a list of numbers that are processed all at once by the `max_subarray_stream` function. \\n\\nIn a real-world scenario, the chunk size would depend on factors like the rate at which data is received from the stream and the memory constraints of the machine running this code. It\\'s worth noting that the chunk size does not affect the final result, because Kadane\\'s algorithm does not depend on future data."
                    },
                    {
                        "username": "lalananya55",
                        "content": "First output case says : [1, 4, -1, 2]  as max subarray with output 6\\nShould not it ne [1,4,2] with output 7\\n"
                    },
                    {
                        "username": "RanjeetP",
                        "content": "becoz we have to use contiguous subarray\\n"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "[@BinaryMusaib](/BinaryMusaib) why we have to subtract from -1 when we are getting maximum sum 7!"
                    },
                    {
                        "username": "BinaryMusaib",
                        "content": "No, The output will be 6 because you have to subtract (negative)1 to the array."
                    },
                    {
                        "username": "parambole",
                        "content": "There are several articles out there that mention ways to solve DP problems. But, the problem is that every DP problem is different. \\n\\nWhat one needs to learn is how to reach to the DP solution. \\n\\n**STEP 1: Start with Brute Force:** \\n\\nYes, you heard it right. Because DP is nothing but intelligent guessing. We need to do an exhaustive search on every possible combination and pick the most optimal combination. \\n\\n**STEP 2: Draw out your solution - > This is the most critical step**\\n\\nDraw the steps that your brute force solution is taking. Because unless you visualize what your algorithm is doing. You can never come up with a DP solution.\\n\\n**STEP 3: Think about repeated steps and how to store and use them**\\n\\nIt is not just important to know what steps are getting repeated. What is essential is to understand how can you store your calculations and re-usage them."
                    },
                    {
                        "username": "Thisismeaditya_singh",
                        "content": "Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\n\nShould'nt it be 7? with subarray of  [4,2,1] ??? Am I missing something here?"
                    },
                    {
                        "username": "varshinir822",
                        "content": "[@PrasannaNaik211](/PrasannaNaik211) because a subarray has to be a consecutive sequence"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "Yes even I also have same doubt why we have to subtract from -1 when we are already getting maximum sum 7\\n"
                    },
                    {
                        "username": "pythonCoderHere",
                        "content": "The Simple Solution to the Problem in python is here https://hecodesit.com/maximum-subarray-leetcode-python-solution/"
                    },
                    {
                        "username": "Depender",
                        "content": "![image](https://assets.leetcode.com/users/images/7fa2d39d-0c2e-47b8-86a6-4726837c1676_1645458692.698741.png)\\n"
                    },
                    {
                        "username": "mknaveen837",
                        "content": "![image](https://assets.leetcode.com/users/images/fc6091ab-502c-42c6-8cdc-10280d415573_1598457725.3748913.png)\\nWhats the error The same custome test input works fine plz help"
                    },
                    {
                        "username": "p-neiderman",
                        "content": "I implemented the brute force solution after thinking on it for a while, but after trying and failing to think of an O(n) solution, I looked up Kadane\\'s algorithm and it seems almost trivial. I feel a little ashamed of not being able to implement it on my own. Are there some fundamental concepts I\\'m missing here? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Kadane\\'s Algorithm falls under the category of Dynamic Programming (DP), which is a technique used in computing to solve problems by breaking them down into simpler, smaller subproblems and using the solutions to these subproblems to construct a solution to the original problem. DP can be a tough concept to master, and it often isn\\'t immediately obvious how to apply it to a new problem. \\n\\nThe fundamental concept behind Kadane\\'s algorithm is the idea of \"local maximum\" and \"global maximum\". \\n\\n1. The local maximum at each position is the maximum of the current number and the sum of the current number and the previous local maximum. This basically means we have two choices at each step: to add the current number to the subarray or start a new subarray with the current number. We choose the option that gives the maximum sum.\\n\\n2. The global maximum is the maximum sum of all subarrays that we\\'ve seen so far.\\n\\nEven if you didn\\'t come up with this solution yourself, now that you\\'ve seen it and understand it, you\\'re likely to recognize similar problems in the future where a similar approach can be used. That\\'s how learning in programming often works: you encounter a wide variety of problems and learn techniques and algorithms from solving those problems, and then you apply those techniques to new problems."
                    },
                    {
                        "username": "ellenlloyd",
                        "content": "## How recent is this change? \\n\\nI know Maximum Subarray was [originally a **medium**](https://leetcode.com/discuss/general-discussion/522206/blind-curated-75-list-with-difficulty-level) when first released, but it was changed to rank **easy** since ages ago. (See [complaint posts](https://leetcode.com/problems/maximum-subarray/discuss/1727524/Shouldn\\'t-This-Problem-Be-A-Medium) like [these ones](https://leetcode.com/problems/maximum-subarray/discuss/475930/Why-is-this-classed-as-an-easy-question-It-is-not) in the [leetcode discussions](https://leetcode.com/problems/maximum-subarray/discuss/294613/Why-is-this-classified-as-%22easy%22).)\\n\\nNow it\\'s back as a medium! Must have changed within the last weeks at most? I\\'m curious to know when it happened.\\n\\nI do think it\\'s a good change. Even with guides and help, many a beginner coder has faced despair trying to understand this question AND the optimal-yet-unintuitive Kadane\\'s algorithm used to solve it. My past self included. \\uD83D\\uDE2D\\uD83D\\uDE2D\\uD83D\\uDE2D"
                    }
                ]
            },
            {
                "id": 1570884,
                "content": [
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/7f0ba9b5-b3e6-4ac5-8e0d-7f23aa1d5461_1653130215.4718482.jpeg)\\n"
                    },
                    {
                        "username": "mostov",
                        "content": "For support array of negatives, just need to keep track of max element found in the array.  If this element is less than zero - return it.  Otherwise, return the result of accepted algorithm."
                    },
                    {
                        "username": "Rehmanali",
                        "content": "What to do if we want the start and end indexes?"
                    },
                    {
                        "username": "bparanj",
                        "content": "You can modify the Kadane\\'s algorithm slightly to also track the start and end indices of the maximum subarray.\\n\\nHere\\'s the Python code:\\n\\n```python\\ndef maxSubArray(nums):\\n    # Initial conditions\\n    max_sum = cur_sum = nums[0]\\n    start = end = 0\\n\\n    # Start a temporary index at 0\\n    temp_start = 0\\n\\n    for i in range(1, len(nums)):\\n        # If adding the current element is beneficial, add it\\n        # Otherwise, start a new sum at the current element\\n        if cur_sum + nums[i] > nums[i]:\\n            cur_sum += nums[i]\\n        else:\\n            cur_sum = nums[i]\\n            temp_start = i  # update temp_start index\\n\\n        # If the current sum is larger than the max_sum, update max_sum and indices\\n        if cur_sum > max_sum:\\n            max_sum = cur_sum\\n            start = temp_start\\n            end = i  # update end index\\n\\n    return max_sum, start, end\\n```\\n\\nThis code keeps track of where the maximum subarray sum starts and ends. It uses a temporary start index (`temp_start`) to keep track of potential starting points for the maximum sum subarray. When a new current sum surpasses the maximum sum, `temp_start` and `i` are saved as the new starting and ending points, respectively.\\n\\nSo, for the input `[-2,1,-3,4,-1,2,1,-5,4]`, it returns `(6, 3, 6)`, indicating that the maximum subarray sum is 6 and it is obtained from the subarray from index 3 to 6 inclusive (`[4, -1, 2, 1]`)."
                    },
                    {
                        "username": "mahnoor12",
                        "content": "Store the last index that gives you current Maximum sum. At the end, when you get to find maxSum, go to array and sum elements starting from that index and going backward (index-1). Sum till you get actual max sum and stop when you get the sum, here you get starting index."
                    },
                    {
                        "username": "Alfruno",
                        "content": "TL;DR: reading numbers from left to right, find the best subarray ending at the current position, then take the overall best.\\n\\nSee **https://alfie.prodo.ai/silent-land** (screenshot below) to poke at the code in a visual and interactive playground. \\n\\n![image](https://assets.leetcode.com/users/alfruno/image_1580473252.png)\\n"
                    },
                    {
                        "username": "jejacob",
                        "content": "my O(n^2) sliding window approach timed out the only way to solve is kadane"
                    },
                    {
                        "username": "thecheerlessguy",
                        "content": "Explanation for Test case 166 \\n\\nInput : [2,-1]\\nexpected outcome: [1]\\n\\nCan someone help me with explanation as according to me outcome should be -1?"
                    },
                    {
                        "username": "BinaryMusaib",
                        "content": "What is 2 + (-1)?\\nWe are adding the array elements. "
                    },
                    {
                        "username": "john_112",
                        "content": "The algorithm is called [Kadane\\'s algorithm](https://www.techiedelight.com/maximum-subarray-problem-kadanes-algorithm/). [Here](https://www.techiedelight.com/print-continuous-subarray-with-maximum-sum/)\\'s solution to print the subarray in C++/Java/Python."
                    },
                    {
                        "username": "kratos_srv",
                        "content": "it does not expect the whole subarray in output. For subarray one needs to remember the start and stop index of the subarray with the max sum"
                    },
                    {
                        "username": "madness97",
                        "content": "If the array has only neagtive numbers, then should the sum be the largest of the negative numbers or should we return zero?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem as stated, if the array has only negative numbers, the sum of the maximum subarray would be the largest (least negative) number in the array. This is because the problem asks for the maximum sum of any contiguous subarray, and an array of only negative numbers doesn\\'t contain a subarray with a sum of 0 (unless the array itself is empty, which is generally outside the scope of the problem as typically stated).\\n\\nSo for example, if the array is `[-2, -3, -1, -4]`, the maximum subarray would be `[-1]` and the sum would be `-1`.\\n\\nThis is how the problem is typically defined, because it allows for a meaningful answer in all cases (as long as the array is not empty). However, the exact specifications could vary depending on the specific problem statement you\\'re working with. Always make sure to read the problem statement carefully and understand exactly what it\\'s asking for."
                    },
                    {
                        "username": "nilay0193",
                        "content": "I think the expected answer for an empty array should be 0 instead of INT_MIN."
                    }
                ]
            },
            {
                "id": 1570681,
                "content": [
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/7f0ba9b5-b3e6-4ac5-8e0d-7f23aa1d5461_1653130215.4718482.jpeg)\\n"
                    },
                    {
                        "username": "mostov",
                        "content": "For support array of negatives, just need to keep track of max element found in the array.  If this element is less than zero - return it.  Otherwise, return the result of accepted algorithm."
                    },
                    {
                        "username": "Rehmanali",
                        "content": "What to do if we want the start and end indexes?"
                    },
                    {
                        "username": "bparanj",
                        "content": "You can modify the Kadane\\'s algorithm slightly to also track the start and end indices of the maximum subarray.\\n\\nHere\\'s the Python code:\\n\\n```python\\ndef maxSubArray(nums):\\n    # Initial conditions\\n    max_sum = cur_sum = nums[0]\\n    start = end = 0\\n\\n    # Start a temporary index at 0\\n    temp_start = 0\\n\\n    for i in range(1, len(nums)):\\n        # If adding the current element is beneficial, add it\\n        # Otherwise, start a new sum at the current element\\n        if cur_sum + nums[i] > nums[i]:\\n            cur_sum += nums[i]\\n        else:\\n            cur_sum = nums[i]\\n            temp_start = i  # update temp_start index\\n\\n        # If the current sum is larger than the max_sum, update max_sum and indices\\n        if cur_sum > max_sum:\\n            max_sum = cur_sum\\n            start = temp_start\\n            end = i  # update end index\\n\\n    return max_sum, start, end\\n```\\n\\nThis code keeps track of where the maximum subarray sum starts and ends. It uses a temporary start index (`temp_start`) to keep track of potential starting points for the maximum sum subarray. When a new current sum surpasses the maximum sum, `temp_start` and `i` are saved as the new starting and ending points, respectively.\\n\\nSo, for the input `[-2,1,-3,4,-1,2,1,-5,4]`, it returns `(6, 3, 6)`, indicating that the maximum subarray sum is 6 and it is obtained from the subarray from index 3 to 6 inclusive (`[4, -1, 2, 1]`)."
                    },
                    {
                        "username": "mahnoor12",
                        "content": "Store the last index that gives you current Maximum sum. At the end, when you get to find maxSum, go to array and sum elements starting from that index and going backward (index-1). Sum till you get actual max sum and stop when you get the sum, here you get starting index."
                    },
                    {
                        "username": "Alfruno",
                        "content": "TL;DR: reading numbers from left to right, find the best subarray ending at the current position, then take the overall best.\\n\\nSee **https://alfie.prodo.ai/silent-land** (screenshot below) to poke at the code in a visual and interactive playground. \\n\\n![image](https://assets.leetcode.com/users/alfruno/image_1580473252.png)\\n"
                    },
                    {
                        "username": "jejacob",
                        "content": "my O(n^2) sliding window approach timed out the only way to solve is kadane"
                    },
                    {
                        "username": "thecheerlessguy",
                        "content": "Explanation for Test case 166 \\n\\nInput : [2,-1]\\nexpected outcome: [1]\\n\\nCan someone help me with explanation as according to me outcome should be -1?"
                    },
                    {
                        "username": "BinaryMusaib",
                        "content": "What is 2 + (-1)?\\nWe are adding the array elements. "
                    },
                    {
                        "username": "john_112",
                        "content": "The algorithm is called [Kadane\\'s algorithm](https://www.techiedelight.com/maximum-subarray-problem-kadanes-algorithm/). [Here](https://www.techiedelight.com/print-continuous-subarray-with-maximum-sum/)\\'s solution to print the subarray in C++/Java/Python."
                    },
                    {
                        "username": "kratos_srv",
                        "content": "it does not expect the whole subarray in output. For subarray one needs to remember the start and stop index of the subarray with the max sum"
                    },
                    {
                        "username": "madness97",
                        "content": "If the array has only neagtive numbers, then should the sum be the largest of the negative numbers or should we return zero?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem as stated, if the array has only negative numbers, the sum of the maximum subarray would be the largest (least negative) number in the array. This is because the problem asks for the maximum sum of any contiguous subarray, and an array of only negative numbers doesn\\'t contain a subarray with a sum of 0 (unless the array itself is empty, which is generally outside the scope of the problem as typically stated).\\n\\nSo for example, if the array is `[-2, -3, -1, -4]`, the maximum subarray would be `[-1]` and the sum would be `-1`.\\n\\nThis is how the problem is typically defined, because it allows for a meaningful answer in all cases (as long as the array is not empty). However, the exact specifications could vary depending on the specific problem statement you\\'re working with. Always make sure to read the problem statement carefully and understand exactly what it\\'s asking for."
                    },
                    {
                        "username": "nilay0193",
                        "content": "I think the expected answer for an empty array should be 0 instead of INT_MIN."
                    }
                ]
            },
            {
                "id": 1568451,
                "content": [
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/7f0ba9b5-b3e6-4ac5-8e0d-7f23aa1d5461_1653130215.4718482.jpeg)\\n"
                    },
                    {
                        "username": "mostov",
                        "content": "For support array of negatives, just need to keep track of max element found in the array.  If this element is less than zero - return it.  Otherwise, return the result of accepted algorithm."
                    },
                    {
                        "username": "Rehmanali",
                        "content": "What to do if we want the start and end indexes?"
                    },
                    {
                        "username": "bparanj",
                        "content": "You can modify the Kadane\\'s algorithm slightly to also track the start and end indices of the maximum subarray.\\n\\nHere\\'s the Python code:\\n\\n```python\\ndef maxSubArray(nums):\\n    # Initial conditions\\n    max_sum = cur_sum = nums[0]\\n    start = end = 0\\n\\n    # Start a temporary index at 0\\n    temp_start = 0\\n\\n    for i in range(1, len(nums)):\\n        # If adding the current element is beneficial, add it\\n        # Otherwise, start a new sum at the current element\\n        if cur_sum + nums[i] > nums[i]:\\n            cur_sum += nums[i]\\n        else:\\n            cur_sum = nums[i]\\n            temp_start = i  # update temp_start index\\n\\n        # If the current sum is larger than the max_sum, update max_sum and indices\\n        if cur_sum > max_sum:\\n            max_sum = cur_sum\\n            start = temp_start\\n            end = i  # update end index\\n\\n    return max_sum, start, end\\n```\\n\\nThis code keeps track of where the maximum subarray sum starts and ends. It uses a temporary start index (`temp_start`) to keep track of potential starting points for the maximum sum subarray. When a new current sum surpasses the maximum sum, `temp_start` and `i` are saved as the new starting and ending points, respectively.\\n\\nSo, for the input `[-2,1,-3,4,-1,2,1,-5,4]`, it returns `(6, 3, 6)`, indicating that the maximum subarray sum is 6 and it is obtained from the subarray from index 3 to 6 inclusive (`[4, -1, 2, 1]`)."
                    },
                    {
                        "username": "mahnoor12",
                        "content": "Store the last index that gives you current Maximum sum. At the end, when you get to find maxSum, go to array and sum elements starting from that index and going backward (index-1). Sum till you get actual max sum and stop when you get the sum, here you get starting index."
                    },
                    {
                        "username": "Alfruno",
                        "content": "TL;DR: reading numbers from left to right, find the best subarray ending at the current position, then take the overall best.\\n\\nSee **https://alfie.prodo.ai/silent-land** (screenshot below) to poke at the code in a visual and interactive playground. \\n\\n![image](https://assets.leetcode.com/users/alfruno/image_1580473252.png)\\n"
                    },
                    {
                        "username": "jejacob",
                        "content": "my O(n^2) sliding window approach timed out the only way to solve is kadane"
                    },
                    {
                        "username": "thecheerlessguy",
                        "content": "Explanation for Test case 166 \\n\\nInput : [2,-1]\\nexpected outcome: [1]\\n\\nCan someone help me with explanation as according to me outcome should be -1?"
                    },
                    {
                        "username": "BinaryMusaib",
                        "content": "What is 2 + (-1)?\\nWe are adding the array elements. "
                    },
                    {
                        "username": "john_112",
                        "content": "The algorithm is called [Kadane\\'s algorithm](https://www.techiedelight.com/maximum-subarray-problem-kadanes-algorithm/). [Here](https://www.techiedelight.com/print-continuous-subarray-with-maximum-sum/)\\'s solution to print the subarray in C++/Java/Python."
                    },
                    {
                        "username": "kratos_srv",
                        "content": "it does not expect the whole subarray in output. For subarray one needs to remember the start and stop index of the subarray with the max sum"
                    },
                    {
                        "username": "madness97",
                        "content": "If the array has only neagtive numbers, then should the sum be the largest of the negative numbers or should we return zero?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem as stated, if the array has only negative numbers, the sum of the maximum subarray would be the largest (least negative) number in the array. This is because the problem asks for the maximum sum of any contiguous subarray, and an array of only negative numbers doesn\\'t contain a subarray with a sum of 0 (unless the array itself is empty, which is generally outside the scope of the problem as typically stated).\\n\\nSo for example, if the array is `[-2, -3, -1, -4]`, the maximum subarray would be `[-1]` and the sum would be `-1`.\\n\\nThis is how the problem is typically defined, because it allows for a meaningful answer in all cases (as long as the array is not empty). However, the exact specifications could vary depending on the specific problem statement you\\'re working with. Always make sure to read the problem statement carefully and understand exactly what it\\'s asking for."
                    },
                    {
                        "username": "nilay0193",
                        "content": "I think the expected answer for an empty array should be 0 instead of INT_MIN."
                    }
                ]
            },
            {
                "id": 1569760,
                "content": [
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/7f0ba9b5-b3e6-4ac5-8e0d-7f23aa1d5461_1653130215.4718482.jpeg)\\n"
                    },
                    {
                        "username": "mostov",
                        "content": "For support array of negatives, just need to keep track of max element found in the array.  If this element is less than zero - return it.  Otherwise, return the result of accepted algorithm."
                    },
                    {
                        "username": "Rehmanali",
                        "content": "What to do if we want the start and end indexes?"
                    },
                    {
                        "username": "bparanj",
                        "content": "You can modify the Kadane\\'s algorithm slightly to also track the start and end indices of the maximum subarray.\\n\\nHere\\'s the Python code:\\n\\n```python\\ndef maxSubArray(nums):\\n    # Initial conditions\\n    max_sum = cur_sum = nums[0]\\n    start = end = 0\\n\\n    # Start a temporary index at 0\\n    temp_start = 0\\n\\n    for i in range(1, len(nums)):\\n        # If adding the current element is beneficial, add it\\n        # Otherwise, start a new sum at the current element\\n        if cur_sum + nums[i] > nums[i]:\\n            cur_sum += nums[i]\\n        else:\\n            cur_sum = nums[i]\\n            temp_start = i  # update temp_start index\\n\\n        # If the current sum is larger than the max_sum, update max_sum and indices\\n        if cur_sum > max_sum:\\n            max_sum = cur_sum\\n            start = temp_start\\n            end = i  # update end index\\n\\n    return max_sum, start, end\\n```\\n\\nThis code keeps track of where the maximum subarray sum starts and ends. It uses a temporary start index (`temp_start`) to keep track of potential starting points for the maximum sum subarray. When a new current sum surpasses the maximum sum, `temp_start` and `i` are saved as the new starting and ending points, respectively.\\n\\nSo, for the input `[-2,1,-3,4,-1,2,1,-5,4]`, it returns `(6, 3, 6)`, indicating that the maximum subarray sum is 6 and it is obtained from the subarray from index 3 to 6 inclusive (`[4, -1, 2, 1]`)."
                    },
                    {
                        "username": "mahnoor12",
                        "content": "Store the last index that gives you current Maximum sum. At the end, when you get to find maxSum, go to array and sum elements starting from that index and going backward (index-1). Sum till you get actual max sum and stop when you get the sum, here you get starting index."
                    },
                    {
                        "username": "Alfruno",
                        "content": "TL;DR: reading numbers from left to right, find the best subarray ending at the current position, then take the overall best.\\n\\nSee **https://alfie.prodo.ai/silent-land** (screenshot below) to poke at the code in a visual and interactive playground. \\n\\n![image](https://assets.leetcode.com/users/alfruno/image_1580473252.png)\\n"
                    },
                    {
                        "username": "jejacob",
                        "content": "my O(n^2) sliding window approach timed out the only way to solve is kadane"
                    },
                    {
                        "username": "thecheerlessguy",
                        "content": "Explanation for Test case 166 \\n\\nInput : [2,-1]\\nexpected outcome: [1]\\n\\nCan someone help me with explanation as according to me outcome should be -1?"
                    },
                    {
                        "username": "BinaryMusaib",
                        "content": "What is 2 + (-1)?\\nWe are adding the array elements. "
                    },
                    {
                        "username": "john_112",
                        "content": "The algorithm is called [Kadane\\'s algorithm](https://www.techiedelight.com/maximum-subarray-problem-kadanes-algorithm/). [Here](https://www.techiedelight.com/print-continuous-subarray-with-maximum-sum/)\\'s solution to print the subarray in C++/Java/Python."
                    },
                    {
                        "username": "kratos_srv",
                        "content": "it does not expect the whole subarray in output. For subarray one needs to remember the start and stop index of the subarray with the max sum"
                    },
                    {
                        "username": "madness97",
                        "content": "If the array has only neagtive numbers, then should the sum be the largest of the negative numbers or should we return zero?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem as stated, if the array has only negative numbers, the sum of the maximum subarray would be the largest (least negative) number in the array. This is because the problem asks for the maximum sum of any contiguous subarray, and an array of only negative numbers doesn\\'t contain a subarray with a sum of 0 (unless the array itself is empty, which is generally outside the scope of the problem as typically stated).\\n\\nSo for example, if the array is `[-2, -3, -1, -4]`, the maximum subarray would be `[-1]` and the sum would be `-1`.\\n\\nThis is how the problem is typically defined, because it allows for a meaningful answer in all cases (as long as the array is not empty). However, the exact specifications could vary depending on the specific problem statement you\\'re working with. Always make sure to read the problem statement carefully and understand exactly what it\\'s asking for."
                    },
                    {
                        "username": "nilay0193",
                        "content": "I think the expected answer for an empty array should be 0 instead of INT_MIN."
                    }
                ]
            },
            {
                "id": 1965096,
                "content": [
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/7f0ba9b5-b3e6-4ac5-8e0d-7f23aa1d5461_1653130215.4718482.jpeg)\\n"
                    },
                    {
                        "username": "mostov",
                        "content": "For support array of negatives, just need to keep track of max element found in the array.  If this element is less than zero - return it.  Otherwise, return the result of accepted algorithm."
                    },
                    {
                        "username": "Rehmanali",
                        "content": "What to do if we want the start and end indexes?"
                    },
                    {
                        "username": "bparanj",
                        "content": "You can modify the Kadane\\'s algorithm slightly to also track the start and end indices of the maximum subarray.\\n\\nHere\\'s the Python code:\\n\\n```python\\ndef maxSubArray(nums):\\n    # Initial conditions\\n    max_sum = cur_sum = nums[0]\\n    start = end = 0\\n\\n    # Start a temporary index at 0\\n    temp_start = 0\\n\\n    for i in range(1, len(nums)):\\n        # If adding the current element is beneficial, add it\\n        # Otherwise, start a new sum at the current element\\n        if cur_sum + nums[i] > nums[i]:\\n            cur_sum += nums[i]\\n        else:\\n            cur_sum = nums[i]\\n            temp_start = i  # update temp_start index\\n\\n        # If the current sum is larger than the max_sum, update max_sum and indices\\n        if cur_sum > max_sum:\\n            max_sum = cur_sum\\n            start = temp_start\\n            end = i  # update end index\\n\\n    return max_sum, start, end\\n```\\n\\nThis code keeps track of where the maximum subarray sum starts and ends. It uses a temporary start index (`temp_start`) to keep track of potential starting points for the maximum sum subarray. When a new current sum surpasses the maximum sum, `temp_start` and `i` are saved as the new starting and ending points, respectively.\\n\\nSo, for the input `[-2,1,-3,4,-1,2,1,-5,4]`, it returns `(6, 3, 6)`, indicating that the maximum subarray sum is 6 and it is obtained from the subarray from index 3 to 6 inclusive (`[4, -1, 2, 1]`)."
                    },
                    {
                        "username": "mahnoor12",
                        "content": "Store the last index that gives you current Maximum sum. At the end, when you get to find maxSum, go to array and sum elements starting from that index and going backward (index-1). Sum till you get actual max sum and stop when you get the sum, here you get starting index."
                    },
                    {
                        "username": "Alfruno",
                        "content": "TL;DR: reading numbers from left to right, find the best subarray ending at the current position, then take the overall best.\\n\\nSee **https://alfie.prodo.ai/silent-land** (screenshot below) to poke at the code in a visual and interactive playground. \\n\\n![image](https://assets.leetcode.com/users/alfruno/image_1580473252.png)\\n"
                    },
                    {
                        "username": "jejacob",
                        "content": "my O(n^2) sliding window approach timed out the only way to solve is kadane"
                    },
                    {
                        "username": "thecheerlessguy",
                        "content": "Explanation for Test case 166 \\n\\nInput : [2,-1]\\nexpected outcome: [1]\\n\\nCan someone help me with explanation as according to me outcome should be -1?"
                    },
                    {
                        "username": "BinaryMusaib",
                        "content": "What is 2 + (-1)?\\nWe are adding the array elements. "
                    },
                    {
                        "username": "john_112",
                        "content": "The algorithm is called [Kadane\\'s algorithm](https://www.techiedelight.com/maximum-subarray-problem-kadanes-algorithm/). [Here](https://www.techiedelight.com/print-continuous-subarray-with-maximum-sum/)\\'s solution to print the subarray in C++/Java/Python."
                    },
                    {
                        "username": "kratos_srv",
                        "content": "it does not expect the whole subarray in output. For subarray one needs to remember the start and stop index of the subarray with the max sum"
                    },
                    {
                        "username": "madness97",
                        "content": "If the array has only neagtive numbers, then should the sum be the largest of the negative numbers or should we return zero?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem as stated, if the array has only negative numbers, the sum of the maximum subarray would be the largest (least negative) number in the array. This is because the problem asks for the maximum sum of any contiguous subarray, and an array of only negative numbers doesn\\'t contain a subarray with a sum of 0 (unless the array itself is empty, which is generally outside the scope of the problem as typically stated).\\n\\nSo for example, if the array is `[-2, -3, -1, -4]`, the maximum subarray would be `[-1]` and the sum would be `-1`.\\n\\nThis is how the problem is typically defined, because it allows for a meaningful answer in all cases (as long as the array is not empty). However, the exact specifications could vary depending on the specific problem statement you\\'re working with. Always make sure to read the problem statement carefully and understand exactly what it\\'s asking for."
                    },
                    {
                        "username": "nilay0193",
                        "content": "I think the expected answer for an empty array should be 0 instead of INT_MIN."
                    }
                ]
            },
            {
                "id": 1807084,
                "content": [
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/7f0ba9b5-b3e6-4ac5-8e0d-7f23aa1d5461_1653130215.4718482.jpeg)\\n"
                    },
                    {
                        "username": "mostov",
                        "content": "For support array of negatives, just need to keep track of max element found in the array.  If this element is less than zero - return it.  Otherwise, return the result of accepted algorithm."
                    },
                    {
                        "username": "Rehmanali",
                        "content": "What to do if we want the start and end indexes?"
                    },
                    {
                        "username": "bparanj",
                        "content": "You can modify the Kadane\\'s algorithm slightly to also track the start and end indices of the maximum subarray.\\n\\nHere\\'s the Python code:\\n\\n```python\\ndef maxSubArray(nums):\\n    # Initial conditions\\n    max_sum = cur_sum = nums[0]\\n    start = end = 0\\n\\n    # Start a temporary index at 0\\n    temp_start = 0\\n\\n    for i in range(1, len(nums)):\\n        # If adding the current element is beneficial, add it\\n        # Otherwise, start a new sum at the current element\\n        if cur_sum + nums[i] > nums[i]:\\n            cur_sum += nums[i]\\n        else:\\n            cur_sum = nums[i]\\n            temp_start = i  # update temp_start index\\n\\n        # If the current sum is larger than the max_sum, update max_sum and indices\\n        if cur_sum > max_sum:\\n            max_sum = cur_sum\\n            start = temp_start\\n            end = i  # update end index\\n\\n    return max_sum, start, end\\n```\\n\\nThis code keeps track of where the maximum subarray sum starts and ends. It uses a temporary start index (`temp_start`) to keep track of potential starting points for the maximum sum subarray. When a new current sum surpasses the maximum sum, `temp_start` and `i` are saved as the new starting and ending points, respectively.\\n\\nSo, for the input `[-2,1,-3,4,-1,2,1,-5,4]`, it returns `(6, 3, 6)`, indicating that the maximum subarray sum is 6 and it is obtained from the subarray from index 3 to 6 inclusive (`[4, -1, 2, 1]`)."
                    },
                    {
                        "username": "mahnoor12",
                        "content": "Store the last index that gives you current Maximum sum. At the end, when you get to find maxSum, go to array and sum elements starting from that index and going backward (index-1). Sum till you get actual max sum and stop when you get the sum, here you get starting index."
                    },
                    {
                        "username": "Alfruno",
                        "content": "TL;DR: reading numbers from left to right, find the best subarray ending at the current position, then take the overall best.\\n\\nSee **https://alfie.prodo.ai/silent-land** (screenshot below) to poke at the code in a visual and interactive playground. \\n\\n![image](https://assets.leetcode.com/users/alfruno/image_1580473252.png)\\n"
                    },
                    {
                        "username": "jejacob",
                        "content": "my O(n^2) sliding window approach timed out the only way to solve is kadane"
                    },
                    {
                        "username": "thecheerlessguy",
                        "content": "Explanation for Test case 166 \\n\\nInput : [2,-1]\\nexpected outcome: [1]\\n\\nCan someone help me with explanation as according to me outcome should be -1?"
                    },
                    {
                        "username": "BinaryMusaib",
                        "content": "What is 2 + (-1)?\\nWe are adding the array elements. "
                    },
                    {
                        "username": "john_112",
                        "content": "The algorithm is called [Kadane\\'s algorithm](https://www.techiedelight.com/maximum-subarray-problem-kadanes-algorithm/). [Here](https://www.techiedelight.com/print-continuous-subarray-with-maximum-sum/)\\'s solution to print the subarray in C++/Java/Python."
                    },
                    {
                        "username": "kratos_srv",
                        "content": "it does not expect the whole subarray in output. For subarray one needs to remember the start and stop index of the subarray with the max sum"
                    },
                    {
                        "username": "madness97",
                        "content": "If the array has only neagtive numbers, then should the sum be the largest of the negative numbers or should we return zero?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem as stated, if the array has only negative numbers, the sum of the maximum subarray would be the largest (least negative) number in the array. This is because the problem asks for the maximum sum of any contiguous subarray, and an array of only negative numbers doesn\\'t contain a subarray with a sum of 0 (unless the array itself is empty, which is generally outside the scope of the problem as typically stated).\\n\\nSo for example, if the array is `[-2, -3, -1, -4]`, the maximum subarray would be `[-1]` and the sum would be `-1`.\\n\\nThis is how the problem is typically defined, because it allows for a meaningful answer in all cases (as long as the array is not empty). However, the exact specifications could vary depending on the specific problem statement you\\'re working with. Always make sure to read the problem statement carefully and understand exactly what it\\'s asking for."
                    },
                    {
                        "username": "nilay0193",
                        "content": "I think the expected answer for an empty array should be 0 instead of INT_MIN."
                    }
                ]
            },
            {
                "id": 1569968,
                "content": [
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/7f0ba9b5-b3e6-4ac5-8e0d-7f23aa1d5461_1653130215.4718482.jpeg)\\n"
                    },
                    {
                        "username": "mostov",
                        "content": "For support array of negatives, just need to keep track of max element found in the array.  If this element is less than zero - return it.  Otherwise, return the result of accepted algorithm."
                    },
                    {
                        "username": "Rehmanali",
                        "content": "What to do if we want the start and end indexes?"
                    },
                    {
                        "username": "bparanj",
                        "content": "You can modify the Kadane\\'s algorithm slightly to also track the start and end indices of the maximum subarray.\\n\\nHere\\'s the Python code:\\n\\n```python\\ndef maxSubArray(nums):\\n    # Initial conditions\\n    max_sum = cur_sum = nums[0]\\n    start = end = 0\\n\\n    # Start a temporary index at 0\\n    temp_start = 0\\n\\n    for i in range(1, len(nums)):\\n        # If adding the current element is beneficial, add it\\n        # Otherwise, start a new sum at the current element\\n        if cur_sum + nums[i] > nums[i]:\\n            cur_sum += nums[i]\\n        else:\\n            cur_sum = nums[i]\\n            temp_start = i  # update temp_start index\\n\\n        # If the current sum is larger than the max_sum, update max_sum and indices\\n        if cur_sum > max_sum:\\n            max_sum = cur_sum\\n            start = temp_start\\n            end = i  # update end index\\n\\n    return max_sum, start, end\\n```\\n\\nThis code keeps track of where the maximum subarray sum starts and ends. It uses a temporary start index (`temp_start`) to keep track of potential starting points for the maximum sum subarray. When a new current sum surpasses the maximum sum, `temp_start` and `i` are saved as the new starting and ending points, respectively.\\n\\nSo, for the input `[-2,1,-3,4,-1,2,1,-5,4]`, it returns `(6, 3, 6)`, indicating that the maximum subarray sum is 6 and it is obtained from the subarray from index 3 to 6 inclusive (`[4, -1, 2, 1]`)."
                    },
                    {
                        "username": "mahnoor12",
                        "content": "Store the last index that gives you current Maximum sum. At the end, when you get to find maxSum, go to array and sum elements starting from that index and going backward (index-1). Sum till you get actual max sum and stop when you get the sum, here you get starting index."
                    },
                    {
                        "username": "Alfruno",
                        "content": "TL;DR: reading numbers from left to right, find the best subarray ending at the current position, then take the overall best.\\n\\nSee **https://alfie.prodo.ai/silent-land** (screenshot below) to poke at the code in a visual and interactive playground. \\n\\n![image](https://assets.leetcode.com/users/alfruno/image_1580473252.png)\\n"
                    },
                    {
                        "username": "jejacob",
                        "content": "my O(n^2) sliding window approach timed out the only way to solve is kadane"
                    },
                    {
                        "username": "thecheerlessguy",
                        "content": "Explanation for Test case 166 \\n\\nInput : [2,-1]\\nexpected outcome: [1]\\n\\nCan someone help me with explanation as according to me outcome should be -1?"
                    },
                    {
                        "username": "BinaryMusaib",
                        "content": "What is 2 + (-1)?\\nWe are adding the array elements. "
                    },
                    {
                        "username": "john_112",
                        "content": "The algorithm is called [Kadane\\'s algorithm](https://www.techiedelight.com/maximum-subarray-problem-kadanes-algorithm/). [Here](https://www.techiedelight.com/print-continuous-subarray-with-maximum-sum/)\\'s solution to print the subarray in C++/Java/Python."
                    },
                    {
                        "username": "kratos_srv",
                        "content": "it does not expect the whole subarray in output. For subarray one needs to remember the start and stop index of the subarray with the max sum"
                    },
                    {
                        "username": "madness97",
                        "content": "If the array has only neagtive numbers, then should the sum be the largest of the negative numbers or should we return zero?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem as stated, if the array has only negative numbers, the sum of the maximum subarray would be the largest (least negative) number in the array. This is because the problem asks for the maximum sum of any contiguous subarray, and an array of only negative numbers doesn\\'t contain a subarray with a sum of 0 (unless the array itself is empty, which is generally outside the scope of the problem as typically stated).\\n\\nSo for example, if the array is `[-2, -3, -1, -4]`, the maximum subarray would be `[-1]` and the sum would be `-1`.\\n\\nThis is how the problem is typically defined, because it allows for a meaningful answer in all cases (as long as the array is not empty). However, the exact specifications could vary depending on the specific problem statement you\\'re working with. Always make sure to read the problem statement carefully and understand exactly what it\\'s asking for."
                    },
                    {
                        "username": "nilay0193",
                        "content": "I think the expected answer for an empty array should be 0 instead of INT_MIN."
                    }
                ]
            },
            {
                "id": 1569720,
                "content": [
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/7f0ba9b5-b3e6-4ac5-8e0d-7f23aa1d5461_1653130215.4718482.jpeg)\\n"
                    },
                    {
                        "username": "mostov",
                        "content": "For support array of negatives, just need to keep track of max element found in the array.  If this element is less than zero - return it.  Otherwise, return the result of accepted algorithm."
                    },
                    {
                        "username": "Rehmanali",
                        "content": "What to do if we want the start and end indexes?"
                    },
                    {
                        "username": "bparanj",
                        "content": "You can modify the Kadane\\'s algorithm slightly to also track the start and end indices of the maximum subarray.\\n\\nHere\\'s the Python code:\\n\\n```python\\ndef maxSubArray(nums):\\n    # Initial conditions\\n    max_sum = cur_sum = nums[0]\\n    start = end = 0\\n\\n    # Start a temporary index at 0\\n    temp_start = 0\\n\\n    for i in range(1, len(nums)):\\n        # If adding the current element is beneficial, add it\\n        # Otherwise, start a new sum at the current element\\n        if cur_sum + nums[i] > nums[i]:\\n            cur_sum += nums[i]\\n        else:\\n            cur_sum = nums[i]\\n            temp_start = i  # update temp_start index\\n\\n        # If the current sum is larger than the max_sum, update max_sum and indices\\n        if cur_sum > max_sum:\\n            max_sum = cur_sum\\n            start = temp_start\\n            end = i  # update end index\\n\\n    return max_sum, start, end\\n```\\n\\nThis code keeps track of where the maximum subarray sum starts and ends. It uses a temporary start index (`temp_start`) to keep track of potential starting points for the maximum sum subarray. When a new current sum surpasses the maximum sum, `temp_start` and `i` are saved as the new starting and ending points, respectively.\\n\\nSo, for the input `[-2,1,-3,4,-1,2,1,-5,4]`, it returns `(6, 3, 6)`, indicating that the maximum subarray sum is 6 and it is obtained from the subarray from index 3 to 6 inclusive (`[4, -1, 2, 1]`)."
                    },
                    {
                        "username": "mahnoor12",
                        "content": "Store the last index that gives you current Maximum sum. At the end, when you get to find maxSum, go to array and sum elements starting from that index and going backward (index-1). Sum till you get actual max sum and stop when you get the sum, here you get starting index."
                    },
                    {
                        "username": "Alfruno",
                        "content": "TL;DR: reading numbers from left to right, find the best subarray ending at the current position, then take the overall best.\\n\\nSee **https://alfie.prodo.ai/silent-land** (screenshot below) to poke at the code in a visual and interactive playground. \\n\\n![image](https://assets.leetcode.com/users/alfruno/image_1580473252.png)\\n"
                    },
                    {
                        "username": "jejacob",
                        "content": "my O(n^2) sliding window approach timed out the only way to solve is kadane"
                    },
                    {
                        "username": "thecheerlessguy",
                        "content": "Explanation for Test case 166 \\n\\nInput : [2,-1]\\nexpected outcome: [1]\\n\\nCan someone help me with explanation as according to me outcome should be -1?"
                    },
                    {
                        "username": "BinaryMusaib",
                        "content": "What is 2 + (-1)?\\nWe are adding the array elements. "
                    },
                    {
                        "username": "john_112",
                        "content": "The algorithm is called [Kadane\\'s algorithm](https://www.techiedelight.com/maximum-subarray-problem-kadanes-algorithm/). [Here](https://www.techiedelight.com/print-continuous-subarray-with-maximum-sum/)\\'s solution to print the subarray in C++/Java/Python."
                    },
                    {
                        "username": "kratos_srv",
                        "content": "it does not expect the whole subarray in output. For subarray one needs to remember the start and stop index of the subarray with the max sum"
                    },
                    {
                        "username": "madness97",
                        "content": "If the array has only neagtive numbers, then should the sum be the largest of the negative numbers or should we return zero?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem as stated, if the array has only negative numbers, the sum of the maximum subarray would be the largest (least negative) number in the array. This is because the problem asks for the maximum sum of any contiguous subarray, and an array of only negative numbers doesn\\'t contain a subarray with a sum of 0 (unless the array itself is empty, which is generally outside the scope of the problem as typically stated).\\n\\nSo for example, if the array is `[-2, -3, -1, -4]`, the maximum subarray would be `[-1]` and the sum would be `-1`.\\n\\nThis is how the problem is typically defined, because it allows for a meaningful answer in all cases (as long as the array is not empty). However, the exact specifications could vary depending on the specific problem statement you\\'re working with. Always make sure to read the problem statement carefully and understand exactly what it\\'s asking for."
                    },
                    {
                        "username": "nilay0193",
                        "content": "I think the expected answer for an empty array should be 0 instead of INT_MIN."
                    }
                ]
            },
            {
                "id": 1569454,
                "content": [
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/7f0ba9b5-b3e6-4ac5-8e0d-7f23aa1d5461_1653130215.4718482.jpeg)\\n"
                    },
                    {
                        "username": "mostov",
                        "content": "For support array of negatives, just need to keep track of max element found in the array.  If this element is less than zero - return it.  Otherwise, return the result of accepted algorithm."
                    },
                    {
                        "username": "Rehmanali",
                        "content": "What to do if we want the start and end indexes?"
                    },
                    {
                        "username": "bparanj",
                        "content": "You can modify the Kadane\\'s algorithm slightly to also track the start and end indices of the maximum subarray.\\n\\nHere\\'s the Python code:\\n\\n```python\\ndef maxSubArray(nums):\\n    # Initial conditions\\n    max_sum = cur_sum = nums[0]\\n    start = end = 0\\n\\n    # Start a temporary index at 0\\n    temp_start = 0\\n\\n    for i in range(1, len(nums)):\\n        # If adding the current element is beneficial, add it\\n        # Otherwise, start a new sum at the current element\\n        if cur_sum + nums[i] > nums[i]:\\n            cur_sum += nums[i]\\n        else:\\n            cur_sum = nums[i]\\n            temp_start = i  # update temp_start index\\n\\n        # If the current sum is larger than the max_sum, update max_sum and indices\\n        if cur_sum > max_sum:\\n            max_sum = cur_sum\\n            start = temp_start\\n            end = i  # update end index\\n\\n    return max_sum, start, end\\n```\\n\\nThis code keeps track of where the maximum subarray sum starts and ends. It uses a temporary start index (`temp_start`) to keep track of potential starting points for the maximum sum subarray. When a new current sum surpasses the maximum sum, `temp_start` and `i` are saved as the new starting and ending points, respectively.\\n\\nSo, for the input `[-2,1,-3,4,-1,2,1,-5,4]`, it returns `(6, 3, 6)`, indicating that the maximum subarray sum is 6 and it is obtained from the subarray from index 3 to 6 inclusive (`[4, -1, 2, 1]`)."
                    },
                    {
                        "username": "mahnoor12",
                        "content": "Store the last index that gives you current Maximum sum. At the end, when you get to find maxSum, go to array and sum elements starting from that index and going backward (index-1). Sum till you get actual max sum and stop when you get the sum, here you get starting index."
                    },
                    {
                        "username": "Alfruno",
                        "content": "TL;DR: reading numbers from left to right, find the best subarray ending at the current position, then take the overall best.\\n\\nSee **https://alfie.prodo.ai/silent-land** (screenshot below) to poke at the code in a visual and interactive playground. \\n\\n![image](https://assets.leetcode.com/users/alfruno/image_1580473252.png)\\n"
                    },
                    {
                        "username": "jejacob",
                        "content": "my O(n^2) sliding window approach timed out the only way to solve is kadane"
                    },
                    {
                        "username": "thecheerlessguy",
                        "content": "Explanation for Test case 166 \\n\\nInput : [2,-1]\\nexpected outcome: [1]\\n\\nCan someone help me with explanation as according to me outcome should be -1?"
                    },
                    {
                        "username": "BinaryMusaib",
                        "content": "What is 2 + (-1)?\\nWe are adding the array elements. "
                    },
                    {
                        "username": "john_112",
                        "content": "The algorithm is called [Kadane\\'s algorithm](https://www.techiedelight.com/maximum-subarray-problem-kadanes-algorithm/). [Here](https://www.techiedelight.com/print-continuous-subarray-with-maximum-sum/)\\'s solution to print the subarray in C++/Java/Python."
                    },
                    {
                        "username": "kratos_srv",
                        "content": "it does not expect the whole subarray in output. For subarray one needs to remember the start and stop index of the subarray with the max sum"
                    },
                    {
                        "username": "madness97",
                        "content": "If the array has only neagtive numbers, then should the sum be the largest of the negative numbers or should we return zero?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem as stated, if the array has only negative numbers, the sum of the maximum subarray would be the largest (least negative) number in the array. This is because the problem asks for the maximum sum of any contiguous subarray, and an array of only negative numbers doesn\\'t contain a subarray with a sum of 0 (unless the array itself is empty, which is generally outside the scope of the problem as typically stated).\\n\\nSo for example, if the array is `[-2, -3, -1, -4]`, the maximum subarray would be `[-1]` and the sum would be `-1`.\\n\\nThis is how the problem is typically defined, because it allows for a meaningful answer in all cases (as long as the array is not empty). However, the exact specifications could vary depending on the specific problem statement you\\'re working with. Always make sure to read the problem statement carefully and understand exactly what it\\'s asking for."
                    },
                    {
                        "username": "nilay0193",
                        "content": "I think the expected answer for an empty array should be 0 instead of INT_MIN."
                    }
                ]
            },
            {
                "id": 1569199,
                "content": [
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/7f0ba9b5-b3e6-4ac5-8e0d-7f23aa1d5461_1653130215.4718482.jpeg)\\n"
                    },
                    {
                        "username": "mostov",
                        "content": "For support array of negatives, just need to keep track of max element found in the array.  If this element is less than zero - return it.  Otherwise, return the result of accepted algorithm."
                    },
                    {
                        "username": "Rehmanali",
                        "content": "What to do if we want the start and end indexes?"
                    },
                    {
                        "username": "bparanj",
                        "content": "You can modify the Kadane\\'s algorithm slightly to also track the start and end indices of the maximum subarray.\\n\\nHere\\'s the Python code:\\n\\n```python\\ndef maxSubArray(nums):\\n    # Initial conditions\\n    max_sum = cur_sum = nums[0]\\n    start = end = 0\\n\\n    # Start a temporary index at 0\\n    temp_start = 0\\n\\n    for i in range(1, len(nums)):\\n        # If adding the current element is beneficial, add it\\n        # Otherwise, start a new sum at the current element\\n        if cur_sum + nums[i] > nums[i]:\\n            cur_sum += nums[i]\\n        else:\\n            cur_sum = nums[i]\\n            temp_start = i  # update temp_start index\\n\\n        # If the current sum is larger than the max_sum, update max_sum and indices\\n        if cur_sum > max_sum:\\n            max_sum = cur_sum\\n            start = temp_start\\n            end = i  # update end index\\n\\n    return max_sum, start, end\\n```\\n\\nThis code keeps track of where the maximum subarray sum starts and ends. It uses a temporary start index (`temp_start`) to keep track of potential starting points for the maximum sum subarray. When a new current sum surpasses the maximum sum, `temp_start` and `i` are saved as the new starting and ending points, respectively.\\n\\nSo, for the input `[-2,1,-3,4,-1,2,1,-5,4]`, it returns `(6, 3, 6)`, indicating that the maximum subarray sum is 6 and it is obtained from the subarray from index 3 to 6 inclusive (`[4, -1, 2, 1]`)."
                    },
                    {
                        "username": "mahnoor12",
                        "content": "Store the last index that gives you current Maximum sum. At the end, when you get to find maxSum, go to array and sum elements starting from that index and going backward (index-1). Sum till you get actual max sum and stop when you get the sum, here you get starting index."
                    },
                    {
                        "username": "Alfruno",
                        "content": "TL;DR: reading numbers from left to right, find the best subarray ending at the current position, then take the overall best.\\n\\nSee **https://alfie.prodo.ai/silent-land** (screenshot below) to poke at the code in a visual and interactive playground. \\n\\n![image](https://assets.leetcode.com/users/alfruno/image_1580473252.png)\\n"
                    },
                    {
                        "username": "jejacob",
                        "content": "my O(n^2) sliding window approach timed out the only way to solve is kadane"
                    },
                    {
                        "username": "thecheerlessguy",
                        "content": "Explanation for Test case 166 \\n\\nInput : [2,-1]\\nexpected outcome: [1]\\n\\nCan someone help me with explanation as according to me outcome should be -1?"
                    },
                    {
                        "username": "BinaryMusaib",
                        "content": "What is 2 + (-1)?\\nWe are adding the array elements. "
                    },
                    {
                        "username": "john_112",
                        "content": "The algorithm is called [Kadane\\'s algorithm](https://www.techiedelight.com/maximum-subarray-problem-kadanes-algorithm/). [Here](https://www.techiedelight.com/print-continuous-subarray-with-maximum-sum/)\\'s solution to print the subarray in C++/Java/Python."
                    },
                    {
                        "username": "kratos_srv",
                        "content": "it does not expect the whole subarray in output. For subarray one needs to remember the start and stop index of the subarray with the max sum"
                    },
                    {
                        "username": "madness97",
                        "content": "If the array has only neagtive numbers, then should the sum be the largest of the negative numbers or should we return zero?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the problem as stated, if the array has only negative numbers, the sum of the maximum subarray would be the largest (least negative) number in the array. This is because the problem asks for the maximum sum of any contiguous subarray, and an array of only negative numbers doesn\\'t contain a subarray with a sum of 0 (unless the array itself is empty, which is generally outside the scope of the problem as typically stated).\\n\\nSo for example, if the array is `[-2, -3, -1, -4]`, the maximum subarray would be `[-1]` and the sum would be `-1`.\\n\\nThis is how the problem is typically defined, because it allows for a meaningful answer in all cases (as long as the array is not empty). However, the exact specifications could vary depending on the specific problem statement you\\'re working with. Always make sure to read the problem statement carefully and understand exactly what it\\'s asking for."
                    },
                    {
                        "username": "nilay0193",
                        "content": "I think the expected answer for an empty array should be 0 instead of INT_MIN."
                    }
                ]
            },
            {
                "id": 1571128,
                "content": [
                    {
                        "username": "503934695",
                        "content": "![0_1476127874542_upload-85404678-7bfb-4e5e-b3bb-5251fffc8bd9](/uploads/files/1476127875233-upload-85404678-7bfb-4e5e-b3bb-5251fffc8bd9.png)"
                    },
                    {
                        "username": "EvilMachine",
                        "content": "JavaScript 56 ms, 100%"
                    },
                    {
                        "username": "A-reum",
                        "content": " `what, that wasn\\'t so easy`"
                    },
                    {
                        "username": "ankush920",
                        "content": "3 METHOD with best code in C++ for solving this question\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nkadane , dp , recurrsion\\n\\nApproach\\nall three approch\\n\\nComplexity\\nTime complexity:\\n0(n) ,o(n) ,o(2^n)\\n\\nSpace complexity:\\no(1) ,o(n) ,0(n)\\n\\nCode\\n//find useful upvote it vro :)\\nkadane algo :-\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int maxi = nums[0]; \\n        int sum = nums[0];\\n        int i =0; \\n        int j = 1;\\n\\n        while(i<=j && j<nums.size())\\n        {\\n        \\n            if( sum>maxi)\\n            {\\n                maxi =sum;\\n            }\\n          \\n                \\n           if( sum <= 0 )\\n           { \\n             sum =nums[j];\\n             i=j;\\n             j++;\\n             continue ;\\n           }\\n\\n\\n           if( sum>0)\\n           {\\n                sum = sum+nums[j];\\n                j++;\\n           }        \\n        }\\n  \\n   \\n        return max(maxi ,sum);\\n        \\n    }\\n};\\n\\n//dynamic programming:-\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int maxi = nums[0]; \\n        int sum = nums[0];\\n        int i =0; \\n        int j = 1;\\n\\n        while(i<=j && j<nums.size())\\n        {\\n        \\n            if( sum>maxi)\\n            {\\n                maxi =sum;\\n            }\\n          \\n                \\n           if( sum <= 0 )\\n           { \\n             sum =nums[j];\\n             i=j;\\n             j++;\\n             continue ;\\n           }\\n\\n\\n           if( sum>0)\\n           {\\n                sum = sum+nums[j];\\n                j++;\\n           }        \\n        }\\n  \\n   \\n        return max(maxi ,sum);\\n        \\n    }\\n};\\n\\n//recurrsion (show TLE) :-\\nclass Solution {\\npublic:\\n\\nvoid help( int index ,int curr , vector<int>&nums ,int &total)\\n    { \\n        \\n    if( curr >total)\\n    {\\n         total =curr;\\n    }\\n\\n        if(index ==nums.size())\\n        {\\n             return ;\\n        }\\n    \\n\\nif( curr ==INT_MIN)\\n{\\n    curr=0;\\n}\\n    help( index+1 ,curr+nums[index],nums ,total );\\n    \\n    help( index +1 ,nums[index] , nums ,total );\\n    return ;\\n    \\n    }\\n    int maxSubArray(vector<int>& nums) {\\n      \\n      int total =INT_MIN;\\n      int curr = INT_MIN;\\n       help( 0,curr, nums,total); \\n       return total ; \\n        \\n    }\\n};"
                    },
                    {
                        "username": "aman3091",
                        "content": "i am using divide and conqure still getting error in [-2,1,-3,4,-1,2,1,-5,4]\\n testcase kindly see my code and help me \\nclass Solution {\\npublic:\\n    int maxsum(vector<int>&nums, int n){\\n        if(n==1){\\n            return nums[0];\\n        }\\n        int m=n/2;\\n        int leftmaxsum=maxsum(nums,m);\\n        int rightmaxsum=maxsum(nums,n-m);\\n        int leftsum=-1000000;\\n        int rightsum=-100000000;\\n        int sum=0;\\n        for(int i=m-1;i>=0;i--){\\n            sum+=nums[i];\\n            leftsum=max(leftsum,sum);\\n\\n        }\\n        sum=0;\\n        for(int i=m;i<n-m-1;i++){\\n            sum+=nums[i];\\n            rightsum=max(rightsum,sum);\\n        }\\n        int ans=max(leftmaxsum,rightmaxsum);\\n        int temp=leftsum+rightsum;\\n        ans=max(ans,temp);\\n        return ans;\\n    }\\n    int maxSubArray(vector<int>& nums) {\\n\\n   int n=nums.size();\\n   return maxsum(nums,n);\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The divide and conquer approach you\\'ve implemented for the problem seems to be the correct idea. However, there seems to be an issue with how the array is split in the recursive calls.\\n\\nIn your code, when you call `maxsum(nums, m)` and `maxsum(nums, n-m)`, you\\'re always starting from the beginning of the array, instead of dividing it into two parts. That\\'s why it\\'s causing the error.\\n\\nInstead of passing the length of the subarray, you should pass the starting and ending indices of the subarray. And when you\\'re making recursive calls, you should properly specify the start and end indices of the left and right subarrays.\\n\\nHere\\'s a corrected version of your function:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int maxsum(vector<int>& nums, int start, int end) {\\n        if(start == end)\\n            return nums[start];\\n\\n        int mid = start + (end - start) / 2;\\n        int leftmaxsum = maxsum(nums, start, mid);\\n        int rightmaxsum = maxsum(nums, mid + 1, end);\\n\\n        int leftsum = INT_MIN, rightsum = INT_MIN, sum = 0;\\n        for(int i = mid; i >= start; i--) {\\n            sum += nums[i];\\n            leftsum = max(leftsum, sum);\\n        }\\n\\n        sum = 0;\\n        for(int i = mid + 1; i <= end; i++) {\\n            sum += nums[i];\\n            rightsum = max(rightsum, sum);\\n        }\\n\\n        int crosssum = leftsum + rightsum;\\n        return max(max(leftmaxsum, rightmaxsum), crosssum);\\n    }\\n\\n    int maxSubArray(vector<int>& nums) {\\n        int n = nums.size();\\n        return maxsum(nums, 0, n - 1);\\n    }\\n};\\n```\\n\\nThe divide and conquer approach works by dividing the array into two halves and solving the problem for each half. It then combines the solutions from each half by considering the maximum subarray sum that could cross the midpoint. The maximum of these three is returned as the final result. The time complexity is O(n log n) because it\\'s a divide and conquer strategy similar to merge sort. The space complexity is O(log n) due to the recursion stack."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "I think the best way to approach this question is to have a currSum to accumulate all the numbers together and once the sum dips below 0, you can reset the currSum and start again from that point on. (A little bit about greedy is applied here)"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you\\'re absolutely right! The approach you\\'ve outlined is indeed the foundation of Kadane\\'s algorithm, which is widely used for solving this problem. Here\\'s a bit more detail:\\n\\n1. Initialize a variable `currSum` to 0 and `maxSum` to the smallest possible integer.\\n\\n2. Loop through each element in the array:\\n\\n    a. Add the current element to `currSum`.\\n\\n    b. If `currSum` becomes less than the current element\\'s value (which indicates that the sum of the current subarray is negative), reset `currSum` to the current element\\'s value. This effectively starts a new subarray.\\n\\n    c. If `currSum` is greater than `maxSum` (indicating that we\\'ve found a subarray with a larger sum), update `maxSum`.\\n\\n3. Once you\\'ve gone through the entire array, `maxSum` will hold the maximum subarray sum.\\n\\nThis approach leverages the insight that any subarray sum that becomes negative can\\'t contribute to a future subarray sum to make it larger. So, you\\'re better off starting a new subarray from the current position whenever you encounter a negative subarray sum. This is indeed a kind of greedy strategy, as you\\'re making the locally optimal choice at each step in the hopes that it will lead to a globally optimal solution."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Brilliant idea! Thank you for sharing!"
                    },
                    {
                        "username": "HurairaAnwer",
                        "content": "Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\nanother subarray is possible with a larger sum [1,4,2,1,4] ... with a sum of 12 - which is the largest, how can that not be the answer? am I missing something here? is it that the subarray can only be of elements that are next to each other? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes."
                    },
                    {
                        "username": "metapredicate",
                        "content": "```\\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4]\\nOutput: 6\\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\\n```\\n\\nWhy is `[4, 2, 1]` not the sub-array with the largest sum of 7? This is a sub array with a larger sum than `[4, -1, 2, 1]`?"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "[@shivyagarg3](/shivyagarg3) please look at the problem they didn\\'t mentioned the sub array should be contiguous."
                    },
                    {
                        "username": "shivyagarg3",
                        "content": "Because we want maximum  sum contiguous subarray"
                    },
                    {
                        "username": "dshgna",
                        "content": "In the case that the array contains all negative values, wouldn\\'t the dynamic programming solution given fall apart?"
                    },
                    {
                        "username": "JayeshSharma",
                        "content": "I solved it using kadane algo, which is ofcourse very efficient but as the question suggest this problem was supposed to solve with divide and conquer method. I couldn\\'t figure out how this can be done with divide and conquer, if you know please explain."
                    }
                ]
            },
            {
                "id": 1565023,
                "content": [
                    {
                        "username": "503934695",
                        "content": "![0_1476127874542_upload-85404678-7bfb-4e5e-b3bb-5251fffc8bd9](/uploads/files/1476127875233-upload-85404678-7bfb-4e5e-b3bb-5251fffc8bd9.png)"
                    },
                    {
                        "username": "EvilMachine",
                        "content": "JavaScript 56 ms, 100%"
                    },
                    {
                        "username": "A-reum",
                        "content": " `what, that wasn\\'t so easy`"
                    },
                    {
                        "username": "ankush920",
                        "content": "3 METHOD with best code in C++ for solving this question\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nkadane , dp , recurrsion\\n\\nApproach\\nall three approch\\n\\nComplexity\\nTime complexity:\\n0(n) ,o(n) ,o(2^n)\\n\\nSpace complexity:\\no(1) ,o(n) ,0(n)\\n\\nCode\\n//find useful upvote it vro :)\\nkadane algo :-\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int maxi = nums[0]; \\n        int sum = nums[0];\\n        int i =0; \\n        int j = 1;\\n\\n        while(i<=j && j<nums.size())\\n        {\\n        \\n            if( sum>maxi)\\n            {\\n                maxi =sum;\\n            }\\n          \\n                \\n           if( sum <= 0 )\\n           { \\n             sum =nums[j];\\n             i=j;\\n             j++;\\n             continue ;\\n           }\\n\\n\\n           if( sum>0)\\n           {\\n                sum = sum+nums[j];\\n                j++;\\n           }        \\n        }\\n  \\n   \\n        return max(maxi ,sum);\\n        \\n    }\\n};\\n\\n//dynamic programming:-\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int maxi = nums[0]; \\n        int sum = nums[0];\\n        int i =0; \\n        int j = 1;\\n\\n        while(i<=j && j<nums.size())\\n        {\\n        \\n            if( sum>maxi)\\n            {\\n                maxi =sum;\\n            }\\n          \\n                \\n           if( sum <= 0 )\\n           { \\n             sum =nums[j];\\n             i=j;\\n             j++;\\n             continue ;\\n           }\\n\\n\\n           if( sum>0)\\n           {\\n                sum = sum+nums[j];\\n                j++;\\n           }        \\n        }\\n  \\n   \\n        return max(maxi ,sum);\\n        \\n    }\\n};\\n\\n//recurrsion (show TLE) :-\\nclass Solution {\\npublic:\\n\\nvoid help( int index ,int curr , vector<int>&nums ,int &total)\\n    { \\n        \\n    if( curr >total)\\n    {\\n         total =curr;\\n    }\\n\\n        if(index ==nums.size())\\n        {\\n             return ;\\n        }\\n    \\n\\nif( curr ==INT_MIN)\\n{\\n    curr=0;\\n}\\n    help( index+1 ,curr+nums[index],nums ,total );\\n    \\n    help( index +1 ,nums[index] , nums ,total );\\n    return ;\\n    \\n    }\\n    int maxSubArray(vector<int>& nums) {\\n      \\n      int total =INT_MIN;\\n      int curr = INT_MIN;\\n       help( 0,curr, nums,total); \\n       return total ; \\n        \\n    }\\n};"
                    },
                    {
                        "username": "aman3091",
                        "content": "i am using divide and conqure still getting error in [-2,1,-3,4,-1,2,1,-5,4]\\n testcase kindly see my code and help me \\nclass Solution {\\npublic:\\n    int maxsum(vector<int>&nums, int n){\\n        if(n==1){\\n            return nums[0];\\n        }\\n        int m=n/2;\\n        int leftmaxsum=maxsum(nums,m);\\n        int rightmaxsum=maxsum(nums,n-m);\\n        int leftsum=-1000000;\\n        int rightsum=-100000000;\\n        int sum=0;\\n        for(int i=m-1;i>=0;i--){\\n            sum+=nums[i];\\n            leftsum=max(leftsum,sum);\\n\\n        }\\n        sum=0;\\n        for(int i=m;i<n-m-1;i++){\\n            sum+=nums[i];\\n            rightsum=max(rightsum,sum);\\n        }\\n        int ans=max(leftmaxsum,rightmaxsum);\\n        int temp=leftsum+rightsum;\\n        ans=max(ans,temp);\\n        return ans;\\n    }\\n    int maxSubArray(vector<int>& nums) {\\n\\n   int n=nums.size();\\n   return maxsum(nums,n);\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The divide and conquer approach you\\'ve implemented for the problem seems to be the correct idea. However, there seems to be an issue with how the array is split in the recursive calls.\\n\\nIn your code, when you call `maxsum(nums, m)` and `maxsum(nums, n-m)`, you\\'re always starting from the beginning of the array, instead of dividing it into two parts. That\\'s why it\\'s causing the error.\\n\\nInstead of passing the length of the subarray, you should pass the starting and ending indices of the subarray. And when you\\'re making recursive calls, you should properly specify the start and end indices of the left and right subarrays.\\n\\nHere\\'s a corrected version of your function:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int maxsum(vector<int>& nums, int start, int end) {\\n        if(start == end)\\n            return nums[start];\\n\\n        int mid = start + (end - start) / 2;\\n        int leftmaxsum = maxsum(nums, start, mid);\\n        int rightmaxsum = maxsum(nums, mid + 1, end);\\n\\n        int leftsum = INT_MIN, rightsum = INT_MIN, sum = 0;\\n        for(int i = mid; i >= start; i--) {\\n            sum += nums[i];\\n            leftsum = max(leftsum, sum);\\n        }\\n\\n        sum = 0;\\n        for(int i = mid + 1; i <= end; i++) {\\n            sum += nums[i];\\n            rightsum = max(rightsum, sum);\\n        }\\n\\n        int crosssum = leftsum + rightsum;\\n        return max(max(leftmaxsum, rightmaxsum), crosssum);\\n    }\\n\\n    int maxSubArray(vector<int>& nums) {\\n        int n = nums.size();\\n        return maxsum(nums, 0, n - 1);\\n    }\\n};\\n```\\n\\nThe divide and conquer approach works by dividing the array into two halves and solving the problem for each half. It then combines the solutions from each half by considering the maximum subarray sum that could cross the midpoint. The maximum of these three is returned as the final result. The time complexity is O(n log n) because it\\'s a divide and conquer strategy similar to merge sort. The space complexity is O(log n) due to the recursion stack."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "I think the best way to approach this question is to have a currSum to accumulate all the numbers together and once the sum dips below 0, you can reset the currSum and start again from that point on. (A little bit about greedy is applied here)"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you\\'re absolutely right! The approach you\\'ve outlined is indeed the foundation of Kadane\\'s algorithm, which is widely used for solving this problem. Here\\'s a bit more detail:\\n\\n1. Initialize a variable `currSum` to 0 and `maxSum` to the smallest possible integer.\\n\\n2. Loop through each element in the array:\\n\\n    a. Add the current element to `currSum`.\\n\\n    b. If `currSum` becomes less than the current element\\'s value (which indicates that the sum of the current subarray is negative), reset `currSum` to the current element\\'s value. This effectively starts a new subarray.\\n\\n    c. If `currSum` is greater than `maxSum` (indicating that we\\'ve found a subarray with a larger sum), update `maxSum`.\\n\\n3. Once you\\'ve gone through the entire array, `maxSum` will hold the maximum subarray sum.\\n\\nThis approach leverages the insight that any subarray sum that becomes negative can\\'t contribute to a future subarray sum to make it larger. So, you\\'re better off starting a new subarray from the current position whenever you encounter a negative subarray sum. This is indeed a kind of greedy strategy, as you\\'re making the locally optimal choice at each step in the hopes that it will lead to a globally optimal solution."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Brilliant idea! Thank you for sharing!"
                    },
                    {
                        "username": "HurairaAnwer",
                        "content": "Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\nanother subarray is possible with a larger sum [1,4,2,1,4] ... with a sum of 12 - which is the largest, how can that not be the answer? am I missing something here? is it that the subarray can only be of elements that are next to each other? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes."
                    },
                    {
                        "username": "metapredicate",
                        "content": "```\\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4]\\nOutput: 6\\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\\n```\\n\\nWhy is `[4, 2, 1]` not the sub-array with the largest sum of 7? This is a sub array with a larger sum than `[4, -1, 2, 1]`?"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "[@shivyagarg3](/shivyagarg3) please look at the problem they didn\\'t mentioned the sub array should be contiguous."
                    },
                    {
                        "username": "shivyagarg3",
                        "content": "Because we want maximum  sum contiguous subarray"
                    },
                    {
                        "username": "dshgna",
                        "content": "In the case that the array contains all negative values, wouldn\\'t the dynamic programming solution given fall apart?"
                    },
                    {
                        "username": "JayeshSharma",
                        "content": "I solved it using kadane algo, which is ofcourse very efficient but as the question suggest this problem was supposed to solve with divide and conquer method. I couldn\\'t figure out how this can be done with divide and conquer, if you know please explain."
                    }
                ]
            },
            {
                "id": 2034118,
                "content": [
                    {
                        "username": "503934695",
                        "content": "![0_1476127874542_upload-85404678-7bfb-4e5e-b3bb-5251fffc8bd9](/uploads/files/1476127875233-upload-85404678-7bfb-4e5e-b3bb-5251fffc8bd9.png)"
                    },
                    {
                        "username": "EvilMachine",
                        "content": "JavaScript 56 ms, 100%"
                    },
                    {
                        "username": "A-reum",
                        "content": " `what, that wasn\\'t so easy`"
                    },
                    {
                        "username": "ankush920",
                        "content": "3 METHOD with best code in C++ for solving this question\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nkadane , dp , recurrsion\\n\\nApproach\\nall three approch\\n\\nComplexity\\nTime complexity:\\n0(n) ,o(n) ,o(2^n)\\n\\nSpace complexity:\\no(1) ,o(n) ,0(n)\\n\\nCode\\n//find useful upvote it vro :)\\nkadane algo :-\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int maxi = nums[0]; \\n        int sum = nums[0];\\n        int i =0; \\n        int j = 1;\\n\\n        while(i<=j && j<nums.size())\\n        {\\n        \\n            if( sum>maxi)\\n            {\\n                maxi =sum;\\n            }\\n          \\n                \\n           if( sum <= 0 )\\n           { \\n             sum =nums[j];\\n             i=j;\\n             j++;\\n             continue ;\\n           }\\n\\n\\n           if( sum>0)\\n           {\\n                sum = sum+nums[j];\\n                j++;\\n           }        \\n        }\\n  \\n   \\n        return max(maxi ,sum);\\n        \\n    }\\n};\\n\\n//dynamic programming:-\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int maxi = nums[0]; \\n        int sum = nums[0];\\n        int i =0; \\n        int j = 1;\\n\\n        while(i<=j && j<nums.size())\\n        {\\n        \\n            if( sum>maxi)\\n            {\\n                maxi =sum;\\n            }\\n          \\n                \\n           if( sum <= 0 )\\n           { \\n             sum =nums[j];\\n             i=j;\\n             j++;\\n             continue ;\\n           }\\n\\n\\n           if( sum>0)\\n           {\\n                sum = sum+nums[j];\\n                j++;\\n           }        \\n        }\\n  \\n   \\n        return max(maxi ,sum);\\n        \\n    }\\n};\\n\\n//recurrsion (show TLE) :-\\nclass Solution {\\npublic:\\n\\nvoid help( int index ,int curr , vector<int>&nums ,int &total)\\n    { \\n        \\n    if( curr >total)\\n    {\\n         total =curr;\\n    }\\n\\n        if(index ==nums.size())\\n        {\\n             return ;\\n        }\\n    \\n\\nif( curr ==INT_MIN)\\n{\\n    curr=0;\\n}\\n    help( index+1 ,curr+nums[index],nums ,total );\\n    \\n    help( index +1 ,nums[index] , nums ,total );\\n    return ;\\n    \\n    }\\n    int maxSubArray(vector<int>& nums) {\\n      \\n      int total =INT_MIN;\\n      int curr = INT_MIN;\\n       help( 0,curr, nums,total); \\n       return total ; \\n        \\n    }\\n};"
                    },
                    {
                        "username": "aman3091",
                        "content": "i am using divide and conqure still getting error in [-2,1,-3,4,-1,2,1,-5,4]\\n testcase kindly see my code and help me \\nclass Solution {\\npublic:\\n    int maxsum(vector<int>&nums, int n){\\n        if(n==1){\\n            return nums[0];\\n        }\\n        int m=n/2;\\n        int leftmaxsum=maxsum(nums,m);\\n        int rightmaxsum=maxsum(nums,n-m);\\n        int leftsum=-1000000;\\n        int rightsum=-100000000;\\n        int sum=0;\\n        for(int i=m-1;i>=0;i--){\\n            sum+=nums[i];\\n            leftsum=max(leftsum,sum);\\n\\n        }\\n        sum=0;\\n        for(int i=m;i<n-m-1;i++){\\n            sum+=nums[i];\\n            rightsum=max(rightsum,sum);\\n        }\\n        int ans=max(leftmaxsum,rightmaxsum);\\n        int temp=leftsum+rightsum;\\n        ans=max(ans,temp);\\n        return ans;\\n    }\\n    int maxSubArray(vector<int>& nums) {\\n\\n   int n=nums.size();\\n   return maxsum(nums,n);\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The divide and conquer approach you\\'ve implemented for the problem seems to be the correct idea. However, there seems to be an issue with how the array is split in the recursive calls.\\n\\nIn your code, when you call `maxsum(nums, m)` and `maxsum(nums, n-m)`, you\\'re always starting from the beginning of the array, instead of dividing it into two parts. That\\'s why it\\'s causing the error.\\n\\nInstead of passing the length of the subarray, you should pass the starting and ending indices of the subarray. And when you\\'re making recursive calls, you should properly specify the start and end indices of the left and right subarrays.\\n\\nHere\\'s a corrected version of your function:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int maxsum(vector<int>& nums, int start, int end) {\\n        if(start == end)\\n            return nums[start];\\n\\n        int mid = start + (end - start) / 2;\\n        int leftmaxsum = maxsum(nums, start, mid);\\n        int rightmaxsum = maxsum(nums, mid + 1, end);\\n\\n        int leftsum = INT_MIN, rightsum = INT_MIN, sum = 0;\\n        for(int i = mid; i >= start; i--) {\\n            sum += nums[i];\\n            leftsum = max(leftsum, sum);\\n        }\\n\\n        sum = 0;\\n        for(int i = mid + 1; i <= end; i++) {\\n            sum += nums[i];\\n            rightsum = max(rightsum, sum);\\n        }\\n\\n        int crosssum = leftsum + rightsum;\\n        return max(max(leftmaxsum, rightmaxsum), crosssum);\\n    }\\n\\n    int maxSubArray(vector<int>& nums) {\\n        int n = nums.size();\\n        return maxsum(nums, 0, n - 1);\\n    }\\n};\\n```\\n\\nThe divide and conquer approach works by dividing the array into two halves and solving the problem for each half. It then combines the solutions from each half by considering the maximum subarray sum that could cross the midpoint. The maximum of these three is returned as the final result. The time complexity is O(n log n) because it\\'s a divide and conquer strategy similar to merge sort. The space complexity is O(log n) due to the recursion stack."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "I think the best way to approach this question is to have a currSum to accumulate all the numbers together and once the sum dips below 0, you can reset the currSum and start again from that point on. (A little bit about greedy is applied here)"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you\\'re absolutely right! The approach you\\'ve outlined is indeed the foundation of Kadane\\'s algorithm, which is widely used for solving this problem. Here\\'s a bit more detail:\\n\\n1. Initialize a variable `currSum` to 0 and `maxSum` to the smallest possible integer.\\n\\n2. Loop through each element in the array:\\n\\n    a. Add the current element to `currSum`.\\n\\n    b. If `currSum` becomes less than the current element\\'s value (which indicates that the sum of the current subarray is negative), reset `currSum` to the current element\\'s value. This effectively starts a new subarray.\\n\\n    c. If `currSum` is greater than `maxSum` (indicating that we\\'ve found a subarray with a larger sum), update `maxSum`.\\n\\n3. Once you\\'ve gone through the entire array, `maxSum` will hold the maximum subarray sum.\\n\\nThis approach leverages the insight that any subarray sum that becomes negative can\\'t contribute to a future subarray sum to make it larger. So, you\\'re better off starting a new subarray from the current position whenever you encounter a negative subarray sum. This is indeed a kind of greedy strategy, as you\\'re making the locally optimal choice at each step in the hopes that it will lead to a globally optimal solution."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Brilliant idea! Thank you for sharing!"
                    },
                    {
                        "username": "HurairaAnwer",
                        "content": "Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\nanother subarray is possible with a larger sum [1,4,2,1,4] ... with a sum of 12 - which is the largest, how can that not be the answer? am I missing something here? is it that the subarray can only be of elements that are next to each other? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes."
                    },
                    {
                        "username": "metapredicate",
                        "content": "```\\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4]\\nOutput: 6\\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\\n```\\n\\nWhy is `[4, 2, 1]` not the sub-array with the largest sum of 7? This is a sub array with a larger sum than `[4, -1, 2, 1]`?"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "[@shivyagarg3](/shivyagarg3) please look at the problem they didn\\'t mentioned the sub array should be contiguous."
                    },
                    {
                        "username": "shivyagarg3",
                        "content": "Because we want maximum  sum contiguous subarray"
                    },
                    {
                        "username": "dshgna",
                        "content": "In the case that the array contains all negative values, wouldn\\'t the dynamic programming solution given fall apart?"
                    },
                    {
                        "username": "JayeshSharma",
                        "content": "I solved it using kadane algo, which is ofcourse very efficient but as the question suggest this problem was supposed to solve with divide and conquer method. I couldn\\'t figure out how this can be done with divide and conquer, if you know please explain."
                    }
                ]
            },
            {
                "id": 1848008,
                "content": [
                    {
                        "username": "503934695",
                        "content": "![0_1476127874542_upload-85404678-7bfb-4e5e-b3bb-5251fffc8bd9](/uploads/files/1476127875233-upload-85404678-7bfb-4e5e-b3bb-5251fffc8bd9.png)"
                    },
                    {
                        "username": "EvilMachine",
                        "content": "JavaScript 56 ms, 100%"
                    },
                    {
                        "username": "A-reum",
                        "content": " `what, that wasn\\'t so easy`"
                    },
                    {
                        "username": "ankush920",
                        "content": "3 METHOD with best code in C++ for solving this question\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nkadane , dp , recurrsion\\n\\nApproach\\nall three approch\\n\\nComplexity\\nTime complexity:\\n0(n) ,o(n) ,o(2^n)\\n\\nSpace complexity:\\no(1) ,o(n) ,0(n)\\n\\nCode\\n//find useful upvote it vro :)\\nkadane algo :-\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int maxi = nums[0]; \\n        int sum = nums[0];\\n        int i =0; \\n        int j = 1;\\n\\n        while(i<=j && j<nums.size())\\n        {\\n        \\n            if( sum>maxi)\\n            {\\n                maxi =sum;\\n            }\\n          \\n                \\n           if( sum <= 0 )\\n           { \\n             sum =nums[j];\\n             i=j;\\n             j++;\\n             continue ;\\n           }\\n\\n\\n           if( sum>0)\\n           {\\n                sum = sum+nums[j];\\n                j++;\\n           }        \\n        }\\n  \\n   \\n        return max(maxi ,sum);\\n        \\n    }\\n};\\n\\n//dynamic programming:-\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int maxi = nums[0]; \\n        int sum = nums[0];\\n        int i =0; \\n        int j = 1;\\n\\n        while(i<=j && j<nums.size())\\n        {\\n        \\n            if( sum>maxi)\\n            {\\n                maxi =sum;\\n            }\\n          \\n                \\n           if( sum <= 0 )\\n           { \\n             sum =nums[j];\\n             i=j;\\n             j++;\\n             continue ;\\n           }\\n\\n\\n           if( sum>0)\\n           {\\n                sum = sum+nums[j];\\n                j++;\\n           }        \\n        }\\n  \\n   \\n        return max(maxi ,sum);\\n        \\n    }\\n};\\n\\n//recurrsion (show TLE) :-\\nclass Solution {\\npublic:\\n\\nvoid help( int index ,int curr , vector<int>&nums ,int &total)\\n    { \\n        \\n    if( curr >total)\\n    {\\n         total =curr;\\n    }\\n\\n        if(index ==nums.size())\\n        {\\n             return ;\\n        }\\n    \\n\\nif( curr ==INT_MIN)\\n{\\n    curr=0;\\n}\\n    help( index+1 ,curr+nums[index],nums ,total );\\n    \\n    help( index +1 ,nums[index] , nums ,total );\\n    return ;\\n    \\n    }\\n    int maxSubArray(vector<int>& nums) {\\n      \\n      int total =INT_MIN;\\n      int curr = INT_MIN;\\n       help( 0,curr, nums,total); \\n       return total ; \\n        \\n    }\\n};"
                    },
                    {
                        "username": "aman3091",
                        "content": "i am using divide and conqure still getting error in [-2,1,-3,4,-1,2,1,-5,4]\\n testcase kindly see my code and help me \\nclass Solution {\\npublic:\\n    int maxsum(vector<int>&nums, int n){\\n        if(n==1){\\n            return nums[0];\\n        }\\n        int m=n/2;\\n        int leftmaxsum=maxsum(nums,m);\\n        int rightmaxsum=maxsum(nums,n-m);\\n        int leftsum=-1000000;\\n        int rightsum=-100000000;\\n        int sum=0;\\n        for(int i=m-1;i>=0;i--){\\n            sum+=nums[i];\\n            leftsum=max(leftsum,sum);\\n\\n        }\\n        sum=0;\\n        for(int i=m;i<n-m-1;i++){\\n            sum+=nums[i];\\n            rightsum=max(rightsum,sum);\\n        }\\n        int ans=max(leftmaxsum,rightmaxsum);\\n        int temp=leftsum+rightsum;\\n        ans=max(ans,temp);\\n        return ans;\\n    }\\n    int maxSubArray(vector<int>& nums) {\\n\\n   int n=nums.size();\\n   return maxsum(nums,n);\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The divide and conquer approach you\\'ve implemented for the problem seems to be the correct idea. However, there seems to be an issue with how the array is split in the recursive calls.\\n\\nIn your code, when you call `maxsum(nums, m)` and `maxsum(nums, n-m)`, you\\'re always starting from the beginning of the array, instead of dividing it into two parts. That\\'s why it\\'s causing the error.\\n\\nInstead of passing the length of the subarray, you should pass the starting and ending indices of the subarray. And when you\\'re making recursive calls, you should properly specify the start and end indices of the left and right subarrays.\\n\\nHere\\'s a corrected version of your function:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int maxsum(vector<int>& nums, int start, int end) {\\n        if(start == end)\\n            return nums[start];\\n\\n        int mid = start + (end - start) / 2;\\n        int leftmaxsum = maxsum(nums, start, mid);\\n        int rightmaxsum = maxsum(nums, mid + 1, end);\\n\\n        int leftsum = INT_MIN, rightsum = INT_MIN, sum = 0;\\n        for(int i = mid; i >= start; i--) {\\n            sum += nums[i];\\n            leftsum = max(leftsum, sum);\\n        }\\n\\n        sum = 0;\\n        for(int i = mid + 1; i <= end; i++) {\\n            sum += nums[i];\\n            rightsum = max(rightsum, sum);\\n        }\\n\\n        int crosssum = leftsum + rightsum;\\n        return max(max(leftmaxsum, rightmaxsum), crosssum);\\n    }\\n\\n    int maxSubArray(vector<int>& nums) {\\n        int n = nums.size();\\n        return maxsum(nums, 0, n - 1);\\n    }\\n};\\n```\\n\\nThe divide and conquer approach works by dividing the array into two halves and solving the problem for each half. It then combines the solutions from each half by considering the maximum subarray sum that could cross the midpoint. The maximum of these three is returned as the final result. The time complexity is O(n log n) because it\\'s a divide and conquer strategy similar to merge sort. The space complexity is O(log n) due to the recursion stack."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "I think the best way to approach this question is to have a currSum to accumulate all the numbers together and once the sum dips below 0, you can reset the currSum and start again from that point on. (A little bit about greedy is applied here)"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you\\'re absolutely right! The approach you\\'ve outlined is indeed the foundation of Kadane\\'s algorithm, which is widely used for solving this problem. Here\\'s a bit more detail:\\n\\n1. Initialize a variable `currSum` to 0 and `maxSum` to the smallest possible integer.\\n\\n2. Loop through each element in the array:\\n\\n    a. Add the current element to `currSum`.\\n\\n    b. If `currSum` becomes less than the current element\\'s value (which indicates that the sum of the current subarray is negative), reset `currSum` to the current element\\'s value. This effectively starts a new subarray.\\n\\n    c. If `currSum` is greater than `maxSum` (indicating that we\\'ve found a subarray with a larger sum), update `maxSum`.\\n\\n3. Once you\\'ve gone through the entire array, `maxSum` will hold the maximum subarray sum.\\n\\nThis approach leverages the insight that any subarray sum that becomes negative can\\'t contribute to a future subarray sum to make it larger. So, you\\'re better off starting a new subarray from the current position whenever you encounter a negative subarray sum. This is indeed a kind of greedy strategy, as you\\'re making the locally optimal choice at each step in the hopes that it will lead to a globally optimal solution."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Brilliant idea! Thank you for sharing!"
                    },
                    {
                        "username": "HurairaAnwer",
                        "content": "Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\nanother subarray is possible with a larger sum [1,4,2,1,4] ... with a sum of 12 - which is the largest, how can that not be the answer? am I missing something here? is it that the subarray can only be of elements that are next to each other? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes."
                    },
                    {
                        "username": "metapredicate",
                        "content": "```\\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4]\\nOutput: 6\\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\\n```\\n\\nWhy is `[4, 2, 1]` not the sub-array with the largest sum of 7? This is a sub array with a larger sum than `[4, -1, 2, 1]`?"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "[@shivyagarg3](/shivyagarg3) please look at the problem they didn\\'t mentioned the sub array should be contiguous."
                    },
                    {
                        "username": "shivyagarg3",
                        "content": "Because we want maximum  sum contiguous subarray"
                    },
                    {
                        "username": "dshgna",
                        "content": "In the case that the array contains all negative values, wouldn\\'t the dynamic programming solution given fall apart?"
                    },
                    {
                        "username": "JayeshSharma",
                        "content": "I solved it using kadane algo, which is ofcourse very efficient but as the question suggest this problem was supposed to solve with divide and conquer method. I couldn\\'t figure out how this can be done with divide and conquer, if you know please explain."
                    }
                ]
            },
            {
                "id": 1842361,
                "content": [
                    {
                        "username": "503934695",
                        "content": "![0_1476127874542_upload-85404678-7bfb-4e5e-b3bb-5251fffc8bd9](/uploads/files/1476127875233-upload-85404678-7bfb-4e5e-b3bb-5251fffc8bd9.png)"
                    },
                    {
                        "username": "EvilMachine",
                        "content": "JavaScript 56 ms, 100%"
                    },
                    {
                        "username": "A-reum",
                        "content": " `what, that wasn\\'t so easy`"
                    },
                    {
                        "username": "ankush920",
                        "content": "3 METHOD with best code in C++ for solving this question\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nkadane , dp , recurrsion\\n\\nApproach\\nall three approch\\n\\nComplexity\\nTime complexity:\\n0(n) ,o(n) ,o(2^n)\\n\\nSpace complexity:\\no(1) ,o(n) ,0(n)\\n\\nCode\\n//find useful upvote it vro :)\\nkadane algo :-\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int maxi = nums[0]; \\n        int sum = nums[0];\\n        int i =0; \\n        int j = 1;\\n\\n        while(i<=j && j<nums.size())\\n        {\\n        \\n            if( sum>maxi)\\n            {\\n                maxi =sum;\\n            }\\n          \\n                \\n           if( sum <= 0 )\\n           { \\n             sum =nums[j];\\n             i=j;\\n             j++;\\n             continue ;\\n           }\\n\\n\\n           if( sum>0)\\n           {\\n                sum = sum+nums[j];\\n                j++;\\n           }        \\n        }\\n  \\n   \\n        return max(maxi ,sum);\\n        \\n    }\\n};\\n\\n//dynamic programming:-\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int maxi = nums[0]; \\n        int sum = nums[0];\\n        int i =0; \\n        int j = 1;\\n\\n        while(i<=j && j<nums.size())\\n        {\\n        \\n            if( sum>maxi)\\n            {\\n                maxi =sum;\\n            }\\n          \\n                \\n           if( sum <= 0 )\\n           { \\n             sum =nums[j];\\n             i=j;\\n             j++;\\n             continue ;\\n           }\\n\\n\\n           if( sum>0)\\n           {\\n                sum = sum+nums[j];\\n                j++;\\n           }        \\n        }\\n  \\n   \\n        return max(maxi ,sum);\\n        \\n    }\\n};\\n\\n//recurrsion (show TLE) :-\\nclass Solution {\\npublic:\\n\\nvoid help( int index ,int curr , vector<int>&nums ,int &total)\\n    { \\n        \\n    if( curr >total)\\n    {\\n         total =curr;\\n    }\\n\\n        if(index ==nums.size())\\n        {\\n             return ;\\n        }\\n    \\n\\nif( curr ==INT_MIN)\\n{\\n    curr=0;\\n}\\n    help( index+1 ,curr+nums[index],nums ,total );\\n    \\n    help( index +1 ,nums[index] , nums ,total );\\n    return ;\\n    \\n    }\\n    int maxSubArray(vector<int>& nums) {\\n      \\n      int total =INT_MIN;\\n      int curr = INT_MIN;\\n       help( 0,curr, nums,total); \\n       return total ; \\n        \\n    }\\n};"
                    },
                    {
                        "username": "aman3091",
                        "content": "i am using divide and conqure still getting error in [-2,1,-3,4,-1,2,1,-5,4]\\n testcase kindly see my code and help me \\nclass Solution {\\npublic:\\n    int maxsum(vector<int>&nums, int n){\\n        if(n==1){\\n            return nums[0];\\n        }\\n        int m=n/2;\\n        int leftmaxsum=maxsum(nums,m);\\n        int rightmaxsum=maxsum(nums,n-m);\\n        int leftsum=-1000000;\\n        int rightsum=-100000000;\\n        int sum=0;\\n        for(int i=m-1;i>=0;i--){\\n            sum+=nums[i];\\n            leftsum=max(leftsum,sum);\\n\\n        }\\n        sum=0;\\n        for(int i=m;i<n-m-1;i++){\\n            sum+=nums[i];\\n            rightsum=max(rightsum,sum);\\n        }\\n        int ans=max(leftmaxsum,rightmaxsum);\\n        int temp=leftsum+rightsum;\\n        ans=max(ans,temp);\\n        return ans;\\n    }\\n    int maxSubArray(vector<int>& nums) {\\n\\n   int n=nums.size();\\n   return maxsum(nums,n);\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The divide and conquer approach you\\'ve implemented for the problem seems to be the correct idea. However, there seems to be an issue with how the array is split in the recursive calls.\\n\\nIn your code, when you call `maxsum(nums, m)` and `maxsum(nums, n-m)`, you\\'re always starting from the beginning of the array, instead of dividing it into two parts. That\\'s why it\\'s causing the error.\\n\\nInstead of passing the length of the subarray, you should pass the starting and ending indices of the subarray. And when you\\'re making recursive calls, you should properly specify the start and end indices of the left and right subarrays.\\n\\nHere\\'s a corrected version of your function:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int maxsum(vector<int>& nums, int start, int end) {\\n        if(start == end)\\n            return nums[start];\\n\\n        int mid = start + (end - start) / 2;\\n        int leftmaxsum = maxsum(nums, start, mid);\\n        int rightmaxsum = maxsum(nums, mid + 1, end);\\n\\n        int leftsum = INT_MIN, rightsum = INT_MIN, sum = 0;\\n        for(int i = mid; i >= start; i--) {\\n            sum += nums[i];\\n            leftsum = max(leftsum, sum);\\n        }\\n\\n        sum = 0;\\n        for(int i = mid + 1; i <= end; i++) {\\n            sum += nums[i];\\n            rightsum = max(rightsum, sum);\\n        }\\n\\n        int crosssum = leftsum + rightsum;\\n        return max(max(leftmaxsum, rightmaxsum), crosssum);\\n    }\\n\\n    int maxSubArray(vector<int>& nums) {\\n        int n = nums.size();\\n        return maxsum(nums, 0, n - 1);\\n    }\\n};\\n```\\n\\nThe divide and conquer approach works by dividing the array into two halves and solving the problem for each half. It then combines the solutions from each half by considering the maximum subarray sum that could cross the midpoint. The maximum of these three is returned as the final result. The time complexity is O(n log n) because it\\'s a divide and conquer strategy similar to merge sort. The space complexity is O(log n) due to the recursion stack."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "I think the best way to approach this question is to have a currSum to accumulate all the numbers together and once the sum dips below 0, you can reset the currSum and start again from that point on. (A little bit about greedy is applied here)"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you\\'re absolutely right! The approach you\\'ve outlined is indeed the foundation of Kadane\\'s algorithm, which is widely used for solving this problem. Here\\'s a bit more detail:\\n\\n1. Initialize a variable `currSum` to 0 and `maxSum` to the smallest possible integer.\\n\\n2. Loop through each element in the array:\\n\\n    a. Add the current element to `currSum`.\\n\\n    b. If `currSum` becomes less than the current element\\'s value (which indicates that the sum of the current subarray is negative), reset `currSum` to the current element\\'s value. This effectively starts a new subarray.\\n\\n    c. If `currSum` is greater than `maxSum` (indicating that we\\'ve found a subarray with a larger sum), update `maxSum`.\\n\\n3. Once you\\'ve gone through the entire array, `maxSum` will hold the maximum subarray sum.\\n\\nThis approach leverages the insight that any subarray sum that becomes negative can\\'t contribute to a future subarray sum to make it larger. So, you\\'re better off starting a new subarray from the current position whenever you encounter a negative subarray sum. This is indeed a kind of greedy strategy, as you\\'re making the locally optimal choice at each step in the hopes that it will lead to a globally optimal solution."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Brilliant idea! Thank you for sharing!"
                    },
                    {
                        "username": "HurairaAnwer",
                        "content": "Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\nanother subarray is possible with a larger sum [1,4,2,1,4] ... with a sum of 12 - which is the largest, how can that not be the answer? am I missing something here? is it that the subarray can only be of elements that are next to each other? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes."
                    },
                    {
                        "username": "metapredicate",
                        "content": "```\\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4]\\nOutput: 6\\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\\n```\\n\\nWhy is `[4, 2, 1]` not the sub-array with the largest sum of 7? This is a sub array with a larger sum than `[4, -1, 2, 1]`?"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "[@shivyagarg3](/shivyagarg3) please look at the problem they didn\\'t mentioned the sub array should be contiguous."
                    },
                    {
                        "username": "shivyagarg3",
                        "content": "Because we want maximum  sum contiguous subarray"
                    },
                    {
                        "username": "dshgna",
                        "content": "In the case that the array contains all negative values, wouldn\\'t the dynamic programming solution given fall apart?"
                    },
                    {
                        "username": "JayeshSharma",
                        "content": "I solved it using kadane algo, which is ofcourse very efficient but as the question suggest this problem was supposed to solve with divide and conquer method. I couldn\\'t figure out how this can be done with divide and conquer, if you know please explain."
                    }
                ]
            },
            {
                "id": 1811188,
                "content": [
                    {
                        "username": "503934695",
                        "content": "![0_1476127874542_upload-85404678-7bfb-4e5e-b3bb-5251fffc8bd9](/uploads/files/1476127875233-upload-85404678-7bfb-4e5e-b3bb-5251fffc8bd9.png)"
                    },
                    {
                        "username": "EvilMachine",
                        "content": "JavaScript 56 ms, 100%"
                    },
                    {
                        "username": "A-reum",
                        "content": " `what, that wasn\\'t so easy`"
                    },
                    {
                        "username": "ankush920",
                        "content": "3 METHOD with best code in C++ for solving this question\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nkadane , dp , recurrsion\\n\\nApproach\\nall three approch\\n\\nComplexity\\nTime complexity:\\n0(n) ,o(n) ,o(2^n)\\n\\nSpace complexity:\\no(1) ,o(n) ,0(n)\\n\\nCode\\n//find useful upvote it vro :)\\nkadane algo :-\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int maxi = nums[0]; \\n        int sum = nums[0];\\n        int i =0; \\n        int j = 1;\\n\\n        while(i<=j && j<nums.size())\\n        {\\n        \\n            if( sum>maxi)\\n            {\\n                maxi =sum;\\n            }\\n          \\n                \\n           if( sum <= 0 )\\n           { \\n             sum =nums[j];\\n             i=j;\\n             j++;\\n             continue ;\\n           }\\n\\n\\n           if( sum>0)\\n           {\\n                sum = sum+nums[j];\\n                j++;\\n           }        \\n        }\\n  \\n   \\n        return max(maxi ,sum);\\n        \\n    }\\n};\\n\\n//dynamic programming:-\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int maxi = nums[0]; \\n        int sum = nums[0];\\n        int i =0; \\n        int j = 1;\\n\\n        while(i<=j && j<nums.size())\\n        {\\n        \\n            if( sum>maxi)\\n            {\\n                maxi =sum;\\n            }\\n          \\n                \\n           if( sum <= 0 )\\n           { \\n             sum =nums[j];\\n             i=j;\\n             j++;\\n             continue ;\\n           }\\n\\n\\n           if( sum>0)\\n           {\\n                sum = sum+nums[j];\\n                j++;\\n           }        \\n        }\\n  \\n   \\n        return max(maxi ,sum);\\n        \\n    }\\n};\\n\\n//recurrsion (show TLE) :-\\nclass Solution {\\npublic:\\n\\nvoid help( int index ,int curr , vector<int>&nums ,int &total)\\n    { \\n        \\n    if( curr >total)\\n    {\\n         total =curr;\\n    }\\n\\n        if(index ==nums.size())\\n        {\\n             return ;\\n        }\\n    \\n\\nif( curr ==INT_MIN)\\n{\\n    curr=0;\\n}\\n    help( index+1 ,curr+nums[index],nums ,total );\\n    \\n    help( index +1 ,nums[index] , nums ,total );\\n    return ;\\n    \\n    }\\n    int maxSubArray(vector<int>& nums) {\\n      \\n      int total =INT_MIN;\\n      int curr = INT_MIN;\\n       help( 0,curr, nums,total); \\n       return total ; \\n        \\n    }\\n};"
                    },
                    {
                        "username": "aman3091",
                        "content": "i am using divide and conqure still getting error in [-2,1,-3,4,-1,2,1,-5,4]\\n testcase kindly see my code and help me \\nclass Solution {\\npublic:\\n    int maxsum(vector<int>&nums, int n){\\n        if(n==1){\\n            return nums[0];\\n        }\\n        int m=n/2;\\n        int leftmaxsum=maxsum(nums,m);\\n        int rightmaxsum=maxsum(nums,n-m);\\n        int leftsum=-1000000;\\n        int rightsum=-100000000;\\n        int sum=0;\\n        for(int i=m-1;i>=0;i--){\\n            sum+=nums[i];\\n            leftsum=max(leftsum,sum);\\n\\n        }\\n        sum=0;\\n        for(int i=m;i<n-m-1;i++){\\n            sum+=nums[i];\\n            rightsum=max(rightsum,sum);\\n        }\\n        int ans=max(leftmaxsum,rightmaxsum);\\n        int temp=leftsum+rightsum;\\n        ans=max(ans,temp);\\n        return ans;\\n    }\\n    int maxSubArray(vector<int>& nums) {\\n\\n   int n=nums.size();\\n   return maxsum(nums,n);\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The divide and conquer approach you\\'ve implemented for the problem seems to be the correct idea. However, there seems to be an issue with how the array is split in the recursive calls.\\n\\nIn your code, when you call `maxsum(nums, m)` and `maxsum(nums, n-m)`, you\\'re always starting from the beginning of the array, instead of dividing it into two parts. That\\'s why it\\'s causing the error.\\n\\nInstead of passing the length of the subarray, you should pass the starting and ending indices of the subarray. And when you\\'re making recursive calls, you should properly specify the start and end indices of the left and right subarrays.\\n\\nHere\\'s a corrected version of your function:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int maxsum(vector<int>& nums, int start, int end) {\\n        if(start == end)\\n            return nums[start];\\n\\n        int mid = start + (end - start) / 2;\\n        int leftmaxsum = maxsum(nums, start, mid);\\n        int rightmaxsum = maxsum(nums, mid + 1, end);\\n\\n        int leftsum = INT_MIN, rightsum = INT_MIN, sum = 0;\\n        for(int i = mid; i >= start; i--) {\\n            sum += nums[i];\\n            leftsum = max(leftsum, sum);\\n        }\\n\\n        sum = 0;\\n        for(int i = mid + 1; i <= end; i++) {\\n            sum += nums[i];\\n            rightsum = max(rightsum, sum);\\n        }\\n\\n        int crosssum = leftsum + rightsum;\\n        return max(max(leftmaxsum, rightmaxsum), crosssum);\\n    }\\n\\n    int maxSubArray(vector<int>& nums) {\\n        int n = nums.size();\\n        return maxsum(nums, 0, n - 1);\\n    }\\n};\\n```\\n\\nThe divide and conquer approach works by dividing the array into two halves and solving the problem for each half. It then combines the solutions from each half by considering the maximum subarray sum that could cross the midpoint. The maximum of these three is returned as the final result. The time complexity is O(n log n) because it\\'s a divide and conquer strategy similar to merge sort. The space complexity is O(log n) due to the recursion stack."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "I think the best way to approach this question is to have a currSum to accumulate all the numbers together and once the sum dips below 0, you can reset the currSum and start again from that point on. (A little bit about greedy is applied here)"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you\\'re absolutely right! The approach you\\'ve outlined is indeed the foundation of Kadane\\'s algorithm, which is widely used for solving this problem. Here\\'s a bit more detail:\\n\\n1. Initialize a variable `currSum` to 0 and `maxSum` to the smallest possible integer.\\n\\n2. Loop through each element in the array:\\n\\n    a. Add the current element to `currSum`.\\n\\n    b. If `currSum` becomes less than the current element\\'s value (which indicates that the sum of the current subarray is negative), reset `currSum` to the current element\\'s value. This effectively starts a new subarray.\\n\\n    c. If `currSum` is greater than `maxSum` (indicating that we\\'ve found a subarray with a larger sum), update `maxSum`.\\n\\n3. Once you\\'ve gone through the entire array, `maxSum` will hold the maximum subarray sum.\\n\\nThis approach leverages the insight that any subarray sum that becomes negative can\\'t contribute to a future subarray sum to make it larger. So, you\\'re better off starting a new subarray from the current position whenever you encounter a negative subarray sum. This is indeed a kind of greedy strategy, as you\\'re making the locally optimal choice at each step in the hopes that it will lead to a globally optimal solution."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Brilliant idea! Thank you for sharing!"
                    },
                    {
                        "username": "HurairaAnwer",
                        "content": "Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\nanother subarray is possible with a larger sum [1,4,2,1,4] ... with a sum of 12 - which is the largest, how can that not be the answer? am I missing something here? is it that the subarray can only be of elements that are next to each other? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes."
                    },
                    {
                        "username": "metapredicate",
                        "content": "```\\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4]\\nOutput: 6\\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\\n```\\n\\nWhy is `[4, 2, 1]` not the sub-array with the largest sum of 7? This is a sub array with a larger sum than `[4, -1, 2, 1]`?"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "[@shivyagarg3](/shivyagarg3) please look at the problem they didn\\'t mentioned the sub array should be contiguous."
                    },
                    {
                        "username": "shivyagarg3",
                        "content": "Because we want maximum  sum contiguous subarray"
                    },
                    {
                        "username": "dshgna",
                        "content": "In the case that the array contains all negative values, wouldn\\'t the dynamic programming solution given fall apart?"
                    },
                    {
                        "username": "JayeshSharma",
                        "content": "I solved it using kadane algo, which is ofcourse very efficient but as the question suggest this problem was supposed to solve with divide and conquer method. I couldn\\'t figure out how this can be done with divide and conquer, if you know please explain."
                    }
                ]
            },
            {
                "id": 1795783,
                "content": [
                    {
                        "username": "503934695",
                        "content": "![0_1476127874542_upload-85404678-7bfb-4e5e-b3bb-5251fffc8bd9](/uploads/files/1476127875233-upload-85404678-7bfb-4e5e-b3bb-5251fffc8bd9.png)"
                    },
                    {
                        "username": "EvilMachine",
                        "content": "JavaScript 56 ms, 100%"
                    },
                    {
                        "username": "A-reum",
                        "content": " `what, that wasn\\'t so easy`"
                    },
                    {
                        "username": "ankush920",
                        "content": "3 METHOD with best code in C++ for solving this question\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nkadane , dp , recurrsion\\n\\nApproach\\nall three approch\\n\\nComplexity\\nTime complexity:\\n0(n) ,o(n) ,o(2^n)\\n\\nSpace complexity:\\no(1) ,o(n) ,0(n)\\n\\nCode\\n//find useful upvote it vro :)\\nkadane algo :-\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int maxi = nums[0]; \\n        int sum = nums[0];\\n        int i =0; \\n        int j = 1;\\n\\n        while(i<=j && j<nums.size())\\n        {\\n        \\n            if( sum>maxi)\\n            {\\n                maxi =sum;\\n            }\\n          \\n                \\n           if( sum <= 0 )\\n           { \\n             sum =nums[j];\\n             i=j;\\n             j++;\\n             continue ;\\n           }\\n\\n\\n           if( sum>0)\\n           {\\n                sum = sum+nums[j];\\n                j++;\\n           }        \\n        }\\n  \\n   \\n        return max(maxi ,sum);\\n        \\n    }\\n};\\n\\n//dynamic programming:-\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int maxi = nums[0]; \\n        int sum = nums[0];\\n        int i =0; \\n        int j = 1;\\n\\n        while(i<=j && j<nums.size())\\n        {\\n        \\n            if( sum>maxi)\\n            {\\n                maxi =sum;\\n            }\\n          \\n                \\n           if( sum <= 0 )\\n           { \\n             sum =nums[j];\\n             i=j;\\n             j++;\\n             continue ;\\n           }\\n\\n\\n           if( sum>0)\\n           {\\n                sum = sum+nums[j];\\n                j++;\\n           }        \\n        }\\n  \\n   \\n        return max(maxi ,sum);\\n        \\n    }\\n};\\n\\n//recurrsion (show TLE) :-\\nclass Solution {\\npublic:\\n\\nvoid help( int index ,int curr , vector<int>&nums ,int &total)\\n    { \\n        \\n    if( curr >total)\\n    {\\n         total =curr;\\n    }\\n\\n        if(index ==nums.size())\\n        {\\n             return ;\\n        }\\n    \\n\\nif( curr ==INT_MIN)\\n{\\n    curr=0;\\n}\\n    help( index+1 ,curr+nums[index],nums ,total );\\n    \\n    help( index +1 ,nums[index] , nums ,total );\\n    return ;\\n    \\n    }\\n    int maxSubArray(vector<int>& nums) {\\n      \\n      int total =INT_MIN;\\n      int curr = INT_MIN;\\n       help( 0,curr, nums,total); \\n       return total ; \\n        \\n    }\\n};"
                    },
                    {
                        "username": "aman3091",
                        "content": "i am using divide and conqure still getting error in [-2,1,-3,4,-1,2,1,-5,4]\\n testcase kindly see my code and help me \\nclass Solution {\\npublic:\\n    int maxsum(vector<int>&nums, int n){\\n        if(n==1){\\n            return nums[0];\\n        }\\n        int m=n/2;\\n        int leftmaxsum=maxsum(nums,m);\\n        int rightmaxsum=maxsum(nums,n-m);\\n        int leftsum=-1000000;\\n        int rightsum=-100000000;\\n        int sum=0;\\n        for(int i=m-1;i>=0;i--){\\n            sum+=nums[i];\\n            leftsum=max(leftsum,sum);\\n\\n        }\\n        sum=0;\\n        for(int i=m;i<n-m-1;i++){\\n            sum+=nums[i];\\n            rightsum=max(rightsum,sum);\\n        }\\n        int ans=max(leftmaxsum,rightmaxsum);\\n        int temp=leftsum+rightsum;\\n        ans=max(ans,temp);\\n        return ans;\\n    }\\n    int maxSubArray(vector<int>& nums) {\\n\\n   int n=nums.size();\\n   return maxsum(nums,n);\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The divide and conquer approach you\\'ve implemented for the problem seems to be the correct idea. However, there seems to be an issue with how the array is split in the recursive calls.\\n\\nIn your code, when you call `maxsum(nums, m)` and `maxsum(nums, n-m)`, you\\'re always starting from the beginning of the array, instead of dividing it into two parts. That\\'s why it\\'s causing the error.\\n\\nInstead of passing the length of the subarray, you should pass the starting and ending indices of the subarray. And when you\\'re making recursive calls, you should properly specify the start and end indices of the left and right subarrays.\\n\\nHere\\'s a corrected version of your function:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int maxsum(vector<int>& nums, int start, int end) {\\n        if(start == end)\\n            return nums[start];\\n\\n        int mid = start + (end - start) / 2;\\n        int leftmaxsum = maxsum(nums, start, mid);\\n        int rightmaxsum = maxsum(nums, mid + 1, end);\\n\\n        int leftsum = INT_MIN, rightsum = INT_MIN, sum = 0;\\n        for(int i = mid; i >= start; i--) {\\n            sum += nums[i];\\n            leftsum = max(leftsum, sum);\\n        }\\n\\n        sum = 0;\\n        for(int i = mid + 1; i <= end; i++) {\\n            sum += nums[i];\\n            rightsum = max(rightsum, sum);\\n        }\\n\\n        int crosssum = leftsum + rightsum;\\n        return max(max(leftmaxsum, rightmaxsum), crosssum);\\n    }\\n\\n    int maxSubArray(vector<int>& nums) {\\n        int n = nums.size();\\n        return maxsum(nums, 0, n - 1);\\n    }\\n};\\n```\\n\\nThe divide and conquer approach works by dividing the array into two halves and solving the problem for each half. It then combines the solutions from each half by considering the maximum subarray sum that could cross the midpoint. The maximum of these three is returned as the final result. The time complexity is O(n log n) because it\\'s a divide and conquer strategy similar to merge sort. The space complexity is O(log n) due to the recursion stack."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "I think the best way to approach this question is to have a currSum to accumulate all the numbers together and once the sum dips below 0, you can reset the currSum and start again from that point on. (A little bit about greedy is applied here)"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you\\'re absolutely right! The approach you\\'ve outlined is indeed the foundation of Kadane\\'s algorithm, which is widely used for solving this problem. Here\\'s a bit more detail:\\n\\n1. Initialize a variable `currSum` to 0 and `maxSum` to the smallest possible integer.\\n\\n2. Loop through each element in the array:\\n\\n    a. Add the current element to `currSum`.\\n\\n    b. If `currSum` becomes less than the current element\\'s value (which indicates that the sum of the current subarray is negative), reset `currSum` to the current element\\'s value. This effectively starts a new subarray.\\n\\n    c. If `currSum` is greater than `maxSum` (indicating that we\\'ve found a subarray with a larger sum), update `maxSum`.\\n\\n3. Once you\\'ve gone through the entire array, `maxSum` will hold the maximum subarray sum.\\n\\nThis approach leverages the insight that any subarray sum that becomes negative can\\'t contribute to a future subarray sum to make it larger. So, you\\'re better off starting a new subarray from the current position whenever you encounter a negative subarray sum. This is indeed a kind of greedy strategy, as you\\'re making the locally optimal choice at each step in the hopes that it will lead to a globally optimal solution."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Brilliant idea! Thank you for sharing!"
                    },
                    {
                        "username": "HurairaAnwer",
                        "content": "Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\nanother subarray is possible with a larger sum [1,4,2,1,4] ... with a sum of 12 - which is the largest, how can that not be the answer? am I missing something here? is it that the subarray can only be of elements that are next to each other? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes."
                    },
                    {
                        "username": "metapredicate",
                        "content": "```\\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4]\\nOutput: 6\\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\\n```\\n\\nWhy is `[4, 2, 1]` not the sub-array with the largest sum of 7? This is a sub array with a larger sum than `[4, -1, 2, 1]`?"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "[@shivyagarg3](/shivyagarg3) please look at the problem they didn\\'t mentioned the sub array should be contiguous."
                    },
                    {
                        "username": "shivyagarg3",
                        "content": "Because we want maximum  sum contiguous subarray"
                    },
                    {
                        "username": "dshgna",
                        "content": "In the case that the array contains all negative values, wouldn\\'t the dynamic programming solution given fall apart?"
                    },
                    {
                        "username": "JayeshSharma",
                        "content": "I solved it using kadane algo, which is ofcourse very efficient but as the question suggest this problem was supposed to solve with divide and conquer method. I couldn\\'t figure out how this can be done with divide and conquer, if you know please explain."
                    }
                ]
            },
            {
                "id": 1757905,
                "content": [
                    {
                        "username": "503934695",
                        "content": "![0_1476127874542_upload-85404678-7bfb-4e5e-b3bb-5251fffc8bd9](/uploads/files/1476127875233-upload-85404678-7bfb-4e5e-b3bb-5251fffc8bd9.png)"
                    },
                    {
                        "username": "EvilMachine",
                        "content": "JavaScript 56 ms, 100%"
                    },
                    {
                        "username": "A-reum",
                        "content": " `what, that wasn\\'t so easy`"
                    },
                    {
                        "username": "ankush920",
                        "content": "3 METHOD with best code in C++ for solving this question\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nkadane , dp , recurrsion\\n\\nApproach\\nall three approch\\n\\nComplexity\\nTime complexity:\\n0(n) ,o(n) ,o(2^n)\\n\\nSpace complexity:\\no(1) ,o(n) ,0(n)\\n\\nCode\\n//find useful upvote it vro :)\\nkadane algo :-\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int maxi = nums[0]; \\n        int sum = nums[0];\\n        int i =0; \\n        int j = 1;\\n\\n        while(i<=j && j<nums.size())\\n        {\\n        \\n            if( sum>maxi)\\n            {\\n                maxi =sum;\\n            }\\n          \\n                \\n           if( sum <= 0 )\\n           { \\n             sum =nums[j];\\n             i=j;\\n             j++;\\n             continue ;\\n           }\\n\\n\\n           if( sum>0)\\n           {\\n                sum = sum+nums[j];\\n                j++;\\n           }        \\n        }\\n  \\n   \\n        return max(maxi ,sum);\\n        \\n    }\\n};\\n\\n//dynamic programming:-\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int maxi = nums[0]; \\n        int sum = nums[0];\\n        int i =0; \\n        int j = 1;\\n\\n        while(i<=j && j<nums.size())\\n        {\\n        \\n            if( sum>maxi)\\n            {\\n                maxi =sum;\\n            }\\n          \\n                \\n           if( sum <= 0 )\\n           { \\n             sum =nums[j];\\n             i=j;\\n             j++;\\n             continue ;\\n           }\\n\\n\\n           if( sum>0)\\n           {\\n                sum = sum+nums[j];\\n                j++;\\n           }        \\n        }\\n  \\n   \\n        return max(maxi ,sum);\\n        \\n    }\\n};\\n\\n//recurrsion (show TLE) :-\\nclass Solution {\\npublic:\\n\\nvoid help( int index ,int curr , vector<int>&nums ,int &total)\\n    { \\n        \\n    if( curr >total)\\n    {\\n         total =curr;\\n    }\\n\\n        if(index ==nums.size())\\n        {\\n             return ;\\n        }\\n    \\n\\nif( curr ==INT_MIN)\\n{\\n    curr=0;\\n}\\n    help( index+1 ,curr+nums[index],nums ,total );\\n    \\n    help( index +1 ,nums[index] , nums ,total );\\n    return ;\\n    \\n    }\\n    int maxSubArray(vector<int>& nums) {\\n      \\n      int total =INT_MIN;\\n      int curr = INT_MIN;\\n       help( 0,curr, nums,total); \\n       return total ; \\n        \\n    }\\n};"
                    },
                    {
                        "username": "aman3091",
                        "content": "i am using divide and conqure still getting error in [-2,1,-3,4,-1,2,1,-5,4]\\n testcase kindly see my code and help me \\nclass Solution {\\npublic:\\n    int maxsum(vector<int>&nums, int n){\\n        if(n==1){\\n            return nums[0];\\n        }\\n        int m=n/2;\\n        int leftmaxsum=maxsum(nums,m);\\n        int rightmaxsum=maxsum(nums,n-m);\\n        int leftsum=-1000000;\\n        int rightsum=-100000000;\\n        int sum=0;\\n        for(int i=m-1;i>=0;i--){\\n            sum+=nums[i];\\n            leftsum=max(leftsum,sum);\\n\\n        }\\n        sum=0;\\n        for(int i=m;i<n-m-1;i++){\\n            sum+=nums[i];\\n            rightsum=max(rightsum,sum);\\n        }\\n        int ans=max(leftmaxsum,rightmaxsum);\\n        int temp=leftsum+rightsum;\\n        ans=max(ans,temp);\\n        return ans;\\n    }\\n    int maxSubArray(vector<int>& nums) {\\n\\n   int n=nums.size();\\n   return maxsum(nums,n);\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The divide and conquer approach you\\'ve implemented for the problem seems to be the correct idea. However, there seems to be an issue with how the array is split in the recursive calls.\\n\\nIn your code, when you call `maxsum(nums, m)` and `maxsum(nums, n-m)`, you\\'re always starting from the beginning of the array, instead of dividing it into two parts. That\\'s why it\\'s causing the error.\\n\\nInstead of passing the length of the subarray, you should pass the starting and ending indices of the subarray. And when you\\'re making recursive calls, you should properly specify the start and end indices of the left and right subarrays.\\n\\nHere\\'s a corrected version of your function:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int maxsum(vector<int>& nums, int start, int end) {\\n        if(start == end)\\n            return nums[start];\\n\\n        int mid = start + (end - start) / 2;\\n        int leftmaxsum = maxsum(nums, start, mid);\\n        int rightmaxsum = maxsum(nums, mid + 1, end);\\n\\n        int leftsum = INT_MIN, rightsum = INT_MIN, sum = 0;\\n        for(int i = mid; i >= start; i--) {\\n            sum += nums[i];\\n            leftsum = max(leftsum, sum);\\n        }\\n\\n        sum = 0;\\n        for(int i = mid + 1; i <= end; i++) {\\n            sum += nums[i];\\n            rightsum = max(rightsum, sum);\\n        }\\n\\n        int crosssum = leftsum + rightsum;\\n        return max(max(leftmaxsum, rightmaxsum), crosssum);\\n    }\\n\\n    int maxSubArray(vector<int>& nums) {\\n        int n = nums.size();\\n        return maxsum(nums, 0, n - 1);\\n    }\\n};\\n```\\n\\nThe divide and conquer approach works by dividing the array into two halves and solving the problem for each half. It then combines the solutions from each half by considering the maximum subarray sum that could cross the midpoint. The maximum of these three is returned as the final result. The time complexity is O(n log n) because it\\'s a divide and conquer strategy similar to merge sort. The space complexity is O(log n) due to the recursion stack."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "I think the best way to approach this question is to have a currSum to accumulate all the numbers together and once the sum dips below 0, you can reset the currSum and start again from that point on. (A little bit about greedy is applied here)"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you\\'re absolutely right! The approach you\\'ve outlined is indeed the foundation of Kadane\\'s algorithm, which is widely used for solving this problem. Here\\'s a bit more detail:\\n\\n1. Initialize a variable `currSum` to 0 and `maxSum` to the smallest possible integer.\\n\\n2. Loop through each element in the array:\\n\\n    a. Add the current element to `currSum`.\\n\\n    b. If `currSum` becomes less than the current element\\'s value (which indicates that the sum of the current subarray is negative), reset `currSum` to the current element\\'s value. This effectively starts a new subarray.\\n\\n    c. If `currSum` is greater than `maxSum` (indicating that we\\'ve found a subarray with a larger sum), update `maxSum`.\\n\\n3. Once you\\'ve gone through the entire array, `maxSum` will hold the maximum subarray sum.\\n\\nThis approach leverages the insight that any subarray sum that becomes negative can\\'t contribute to a future subarray sum to make it larger. So, you\\'re better off starting a new subarray from the current position whenever you encounter a negative subarray sum. This is indeed a kind of greedy strategy, as you\\'re making the locally optimal choice at each step in the hopes that it will lead to a globally optimal solution."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Brilliant idea! Thank you for sharing!"
                    },
                    {
                        "username": "HurairaAnwer",
                        "content": "Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\nanother subarray is possible with a larger sum [1,4,2,1,4] ... with a sum of 12 - which is the largest, how can that not be the answer? am I missing something here? is it that the subarray can only be of elements that are next to each other? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes."
                    },
                    {
                        "username": "metapredicate",
                        "content": "```\\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4]\\nOutput: 6\\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\\n```\\n\\nWhy is `[4, 2, 1]` not the sub-array with the largest sum of 7? This is a sub array with a larger sum than `[4, -1, 2, 1]`?"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "[@shivyagarg3](/shivyagarg3) please look at the problem they didn\\'t mentioned the sub array should be contiguous."
                    },
                    {
                        "username": "shivyagarg3",
                        "content": "Because we want maximum  sum contiguous subarray"
                    },
                    {
                        "username": "dshgna",
                        "content": "In the case that the array contains all negative values, wouldn\\'t the dynamic programming solution given fall apart?"
                    },
                    {
                        "username": "JayeshSharma",
                        "content": "I solved it using kadane algo, which is ofcourse very efficient but as the question suggest this problem was supposed to solve with divide and conquer method. I couldn\\'t figure out how this can be done with divide and conquer, if you know please explain."
                    }
                ]
            },
            {
                "id": 1575794,
                "content": [
                    {
                        "username": "503934695",
                        "content": "![0_1476127874542_upload-85404678-7bfb-4e5e-b3bb-5251fffc8bd9](/uploads/files/1476127875233-upload-85404678-7bfb-4e5e-b3bb-5251fffc8bd9.png)"
                    },
                    {
                        "username": "EvilMachine",
                        "content": "JavaScript 56 ms, 100%"
                    },
                    {
                        "username": "A-reum",
                        "content": " `what, that wasn\\'t so easy`"
                    },
                    {
                        "username": "ankush920",
                        "content": "3 METHOD with best code in C++ for solving this question\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nkadane , dp , recurrsion\\n\\nApproach\\nall three approch\\n\\nComplexity\\nTime complexity:\\n0(n) ,o(n) ,o(2^n)\\n\\nSpace complexity:\\no(1) ,o(n) ,0(n)\\n\\nCode\\n//find useful upvote it vro :)\\nkadane algo :-\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int maxi = nums[0]; \\n        int sum = nums[0];\\n        int i =0; \\n        int j = 1;\\n\\n        while(i<=j && j<nums.size())\\n        {\\n        \\n            if( sum>maxi)\\n            {\\n                maxi =sum;\\n            }\\n          \\n                \\n           if( sum <= 0 )\\n           { \\n             sum =nums[j];\\n             i=j;\\n             j++;\\n             continue ;\\n           }\\n\\n\\n           if( sum>0)\\n           {\\n                sum = sum+nums[j];\\n                j++;\\n           }        \\n        }\\n  \\n   \\n        return max(maxi ,sum);\\n        \\n    }\\n};\\n\\n//dynamic programming:-\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int maxi = nums[0]; \\n        int sum = nums[0];\\n        int i =0; \\n        int j = 1;\\n\\n        while(i<=j && j<nums.size())\\n        {\\n        \\n            if( sum>maxi)\\n            {\\n                maxi =sum;\\n            }\\n          \\n                \\n           if( sum <= 0 )\\n           { \\n             sum =nums[j];\\n             i=j;\\n             j++;\\n             continue ;\\n           }\\n\\n\\n           if( sum>0)\\n           {\\n                sum = sum+nums[j];\\n                j++;\\n           }        \\n        }\\n  \\n   \\n        return max(maxi ,sum);\\n        \\n    }\\n};\\n\\n//recurrsion (show TLE) :-\\nclass Solution {\\npublic:\\n\\nvoid help( int index ,int curr , vector<int>&nums ,int &total)\\n    { \\n        \\n    if( curr >total)\\n    {\\n         total =curr;\\n    }\\n\\n        if(index ==nums.size())\\n        {\\n             return ;\\n        }\\n    \\n\\nif( curr ==INT_MIN)\\n{\\n    curr=0;\\n}\\n    help( index+1 ,curr+nums[index],nums ,total );\\n    \\n    help( index +1 ,nums[index] , nums ,total );\\n    return ;\\n    \\n    }\\n    int maxSubArray(vector<int>& nums) {\\n      \\n      int total =INT_MIN;\\n      int curr = INT_MIN;\\n       help( 0,curr, nums,total); \\n       return total ; \\n        \\n    }\\n};"
                    },
                    {
                        "username": "aman3091",
                        "content": "i am using divide and conqure still getting error in [-2,1,-3,4,-1,2,1,-5,4]\\n testcase kindly see my code and help me \\nclass Solution {\\npublic:\\n    int maxsum(vector<int>&nums, int n){\\n        if(n==1){\\n            return nums[0];\\n        }\\n        int m=n/2;\\n        int leftmaxsum=maxsum(nums,m);\\n        int rightmaxsum=maxsum(nums,n-m);\\n        int leftsum=-1000000;\\n        int rightsum=-100000000;\\n        int sum=0;\\n        for(int i=m-1;i>=0;i--){\\n            sum+=nums[i];\\n            leftsum=max(leftsum,sum);\\n\\n        }\\n        sum=0;\\n        for(int i=m;i<n-m-1;i++){\\n            sum+=nums[i];\\n            rightsum=max(rightsum,sum);\\n        }\\n        int ans=max(leftmaxsum,rightmaxsum);\\n        int temp=leftsum+rightsum;\\n        ans=max(ans,temp);\\n        return ans;\\n    }\\n    int maxSubArray(vector<int>& nums) {\\n\\n   int n=nums.size();\\n   return maxsum(nums,n);\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The divide and conquer approach you\\'ve implemented for the problem seems to be the correct idea. However, there seems to be an issue with how the array is split in the recursive calls.\\n\\nIn your code, when you call `maxsum(nums, m)` and `maxsum(nums, n-m)`, you\\'re always starting from the beginning of the array, instead of dividing it into two parts. That\\'s why it\\'s causing the error.\\n\\nInstead of passing the length of the subarray, you should pass the starting and ending indices of the subarray. And when you\\'re making recursive calls, you should properly specify the start and end indices of the left and right subarrays.\\n\\nHere\\'s a corrected version of your function:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int maxsum(vector<int>& nums, int start, int end) {\\n        if(start == end)\\n            return nums[start];\\n\\n        int mid = start + (end - start) / 2;\\n        int leftmaxsum = maxsum(nums, start, mid);\\n        int rightmaxsum = maxsum(nums, mid + 1, end);\\n\\n        int leftsum = INT_MIN, rightsum = INT_MIN, sum = 0;\\n        for(int i = mid; i >= start; i--) {\\n            sum += nums[i];\\n            leftsum = max(leftsum, sum);\\n        }\\n\\n        sum = 0;\\n        for(int i = mid + 1; i <= end; i++) {\\n            sum += nums[i];\\n            rightsum = max(rightsum, sum);\\n        }\\n\\n        int crosssum = leftsum + rightsum;\\n        return max(max(leftmaxsum, rightmaxsum), crosssum);\\n    }\\n\\n    int maxSubArray(vector<int>& nums) {\\n        int n = nums.size();\\n        return maxsum(nums, 0, n - 1);\\n    }\\n};\\n```\\n\\nThe divide and conquer approach works by dividing the array into two halves and solving the problem for each half. It then combines the solutions from each half by considering the maximum subarray sum that could cross the midpoint. The maximum of these three is returned as the final result. The time complexity is O(n log n) because it\\'s a divide and conquer strategy similar to merge sort. The space complexity is O(log n) due to the recursion stack."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "I think the best way to approach this question is to have a currSum to accumulate all the numbers together and once the sum dips below 0, you can reset the currSum and start again from that point on. (A little bit about greedy is applied here)"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you\\'re absolutely right! The approach you\\'ve outlined is indeed the foundation of Kadane\\'s algorithm, which is widely used for solving this problem. Here\\'s a bit more detail:\\n\\n1. Initialize a variable `currSum` to 0 and `maxSum` to the smallest possible integer.\\n\\n2. Loop through each element in the array:\\n\\n    a. Add the current element to `currSum`.\\n\\n    b. If `currSum` becomes less than the current element\\'s value (which indicates that the sum of the current subarray is negative), reset `currSum` to the current element\\'s value. This effectively starts a new subarray.\\n\\n    c. If `currSum` is greater than `maxSum` (indicating that we\\'ve found a subarray with a larger sum), update `maxSum`.\\n\\n3. Once you\\'ve gone through the entire array, `maxSum` will hold the maximum subarray sum.\\n\\nThis approach leverages the insight that any subarray sum that becomes negative can\\'t contribute to a future subarray sum to make it larger. So, you\\'re better off starting a new subarray from the current position whenever you encounter a negative subarray sum. This is indeed a kind of greedy strategy, as you\\'re making the locally optimal choice at each step in the hopes that it will lead to a globally optimal solution."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Brilliant idea! Thank you for sharing!"
                    },
                    {
                        "username": "HurairaAnwer",
                        "content": "Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\nanother subarray is possible with a larger sum [1,4,2,1,4] ... with a sum of 12 - which is the largest, how can that not be the answer? am I missing something here? is it that the subarray can only be of elements that are next to each other? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes."
                    },
                    {
                        "username": "metapredicate",
                        "content": "```\\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4]\\nOutput: 6\\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\\n```\\n\\nWhy is `[4, 2, 1]` not the sub-array with the largest sum of 7? This is a sub array with a larger sum than `[4, -1, 2, 1]`?"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "[@shivyagarg3](/shivyagarg3) please look at the problem they didn\\'t mentioned the sub array should be contiguous."
                    },
                    {
                        "username": "shivyagarg3",
                        "content": "Because we want maximum  sum contiguous subarray"
                    },
                    {
                        "username": "dshgna",
                        "content": "In the case that the array contains all negative values, wouldn\\'t the dynamic programming solution given fall apart?"
                    },
                    {
                        "username": "JayeshSharma",
                        "content": "I solved it using kadane algo, which is ofcourse very efficient but as the question suggest this problem was supposed to solve with divide and conquer method. I couldn\\'t figure out how this can be done with divide and conquer, if you know please explain."
                    }
                ]
            },
            {
                "id": 1574347,
                "content": [
                    {
                        "username": "503934695",
                        "content": "![0_1476127874542_upload-85404678-7bfb-4e5e-b3bb-5251fffc8bd9](/uploads/files/1476127875233-upload-85404678-7bfb-4e5e-b3bb-5251fffc8bd9.png)"
                    },
                    {
                        "username": "EvilMachine",
                        "content": "JavaScript 56 ms, 100%"
                    },
                    {
                        "username": "A-reum",
                        "content": " `what, that wasn\\'t so easy`"
                    },
                    {
                        "username": "ankush920",
                        "content": "3 METHOD with best code in C++ for solving this question\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nkadane , dp , recurrsion\\n\\nApproach\\nall three approch\\n\\nComplexity\\nTime complexity:\\n0(n) ,o(n) ,o(2^n)\\n\\nSpace complexity:\\no(1) ,o(n) ,0(n)\\n\\nCode\\n//find useful upvote it vro :)\\nkadane algo :-\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int maxi = nums[0]; \\n        int sum = nums[0];\\n        int i =0; \\n        int j = 1;\\n\\n        while(i<=j && j<nums.size())\\n        {\\n        \\n            if( sum>maxi)\\n            {\\n                maxi =sum;\\n            }\\n          \\n                \\n           if( sum <= 0 )\\n           { \\n             sum =nums[j];\\n             i=j;\\n             j++;\\n             continue ;\\n           }\\n\\n\\n           if( sum>0)\\n           {\\n                sum = sum+nums[j];\\n                j++;\\n           }        \\n        }\\n  \\n   \\n        return max(maxi ,sum);\\n        \\n    }\\n};\\n\\n//dynamic programming:-\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int maxi = nums[0]; \\n        int sum = nums[0];\\n        int i =0; \\n        int j = 1;\\n\\n        while(i<=j && j<nums.size())\\n        {\\n        \\n            if( sum>maxi)\\n            {\\n                maxi =sum;\\n            }\\n          \\n                \\n           if( sum <= 0 )\\n           { \\n             sum =nums[j];\\n             i=j;\\n             j++;\\n             continue ;\\n           }\\n\\n\\n           if( sum>0)\\n           {\\n                sum = sum+nums[j];\\n                j++;\\n           }        \\n        }\\n  \\n   \\n        return max(maxi ,sum);\\n        \\n    }\\n};\\n\\n//recurrsion (show TLE) :-\\nclass Solution {\\npublic:\\n\\nvoid help( int index ,int curr , vector<int>&nums ,int &total)\\n    { \\n        \\n    if( curr >total)\\n    {\\n         total =curr;\\n    }\\n\\n        if(index ==nums.size())\\n        {\\n             return ;\\n        }\\n    \\n\\nif( curr ==INT_MIN)\\n{\\n    curr=0;\\n}\\n    help( index+1 ,curr+nums[index],nums ,total );\\n    \\n    help( index +1 ,nums[index] , nums ,total );\\n    return ;\\n    \\n    }\\n    int maxSubArray(vector<int>& nums) {\\n      \\n      int total =INT_MIN;\\n      int curr = INT_MIN;\\n       help( 0,curr, nums,total); \\n       return total ; \\n        \\n    }\\n};"
                    },
                    {
                        "username": "aman3091",
                        "content": "i am using divide and conqure still getting error in [-2,1,-3,4,-1,2,1,-5,4]\\n testcase kindly see my code and help me \\nclass Solution {\\npublic:\\n    int maxsum(vector<int>&nums, int n){\\n        if(n==1){\\n            return nums[0];\\n        }\\n        int m=n/2;\\n        int leftmaxsum=maxsum(nums,m);\\n        int rightmaxsum=maxsum(nums,n-m);\\n        int leftsum=-1000000;\\n        int rightsum=-100000000;\\n        int sum=0;\\n        for(int i=m-1;i>=0;i--){\\n            sum+=nums[i];\\n            leftsum=max(leftsum,sum);\\n\\n        }\\n        sum=0;\\n        for(int i=m;i<n-m-1;i++){\\n            sum+=nums[i];\\n            rightsum=max(rightsum,sum);\\n        }\\n        int ans=max(leftmaxsum,rightmaxsum);\\n        int temp=leftsum+rightsum;\\n        ans=max(ans,temp);\\n        return ans;\\n    }\\n    int maxSubArray(vector<int>& nums) {\\n\\n   int n=nums.size();\\n   return maxsum(nums,n);\\n    }\\n};\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "The divide and conquer approach you\\'ve implemented for the problem seems to be the correct idea. However, there seems to be an issue with how the array is split in the recursive calls.\\n\\nIn your code, when you call `maxsum(nums, m)` and `maxsum(nums, n-m)`, you\\'re always starting from the beginning of the array, instead of dividing it into two parts. That\\'s why it\\'s causing the error.\\n\\nInstead of passing the length of the subarray, you should pass the starting and ending indices of the subarray. And when you\\'re making recursive calls, you should properly specify the start and end indices of the left and right subarrays.\\n\\nHere\\'s a corrected version of your function:\\n\\n```c++\\nclass Solution {\\npublic:\\n    int maxsum(vector<int>& nums, int start, int end) {\\n        if(start == end)\\n            return nums[start];\\n\\n        int mid = start + (end - start) / 2;\\n        int leftmaxsum = maxsum(nums, start, mid);\\n        int rightmaxsum = maxsum(nums, mid + 1, end);\\n\\n        int leftsum = INT_MIN, rightsum = INT_MIN, sum = 0;\\n        for(int i = mid; i >= start; i--) {\\n            sum += nums[i];\\n            leftsum = max(leftsum, sum);\\n        }\\n\\n        sum = 0;\\n        for(int i = mid + 1; i <= end; i++) {\\n            sum += nums[i];\\n            rightsum = max(rightsum, sum);\\n        }\\n\\n        int crosssum = leftsum + rightsum;\\n        return max(max(leftmaxsum, rightmaxsum), crosssum);\\n    }\\n\\n    int maxSubArray(vector<int>& nums) {\\n        int n = nums.size();\\n        return maxsum(nums, 0, n - 1);\\n    }\\n};\\n```\\n\\nThe divide and conquer approach works by dividing the array into two halves and solving the problem for each half. It then combines the solutions from each half by considering the maximum subarray sum that could cross the midpoint. The maximum of these three is returned as the final result. The time complexity is O(n log n) because it\\'s a divide and conquer strategy similar to merge sort. The space complexity is O(log n) due to the recursion stack."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "I think the best way to approach this question is to have a currSum to accumulate all the numbers together and once the sum dips below 0, you can reset the currSum and start again from that point on. (A little bit about greedy is applied here)"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, you\\'re absolutely right! The approach you\\'ve outlined is indeed the foundation of Kadane\\'s algorithm, which is widely used for solving this problem. Here\\'s a bit more detail:\\n\\n1. Initialize a variable `currSum` to 0 and `maxSum` to the smallest possible integer.\\n\\n2. Loop through each element in the array:\\n\\n    a. Add the current element to `currSum`.\\n\\n    b. If `currSum` becomes less than the current element\\'s value (which indicates that the sum of the current subarray is negative), reset `currSum` to the current element\\'s value. This effectively starts a new subarray.\\n\\n    c. If `currSum` is greater than `maxSum` (indicating that we\\'ve found a subarray with a larger sum), update `maxSum`.\\n\\n3. Once you\\'ve gone through the entire array, `maxSum` will hold the maximum subarray sum.\\n\\nThis approach leverages the insight that any subarray sum that becomes negative can\\'t contribute to a future subarray sum to make it larger. So, you\\'re better off starting a new subarray from the current position whenever you encounter a negative subarray sum. This is indeed a kind of greedy strategy, as you\\'re making the locally optimal choice at each step in the hopes that it will lead to a globally optimal solution."
                    },
                    {
                        "username": "manifold1985",
                        "content": "Brilliant idea! Thank you for sharing!"
                    },
                    {
                        "username": "HurairaAnwer",
                        "content": "Input: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\nanother subarray is possible with a larger sum [1,4,2,1,4] ... with a sum of 12 - which is the largest, how can that not be the answer? am I missing something here? is it that the subarray can only be of elements that are next to each other? "
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes."
                    },
                    {
                        "username": "metapredicate",
                        "content": "```\\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4]\\nOutput: 6\\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\\n```\\n\\nWhy is `[4, 2, 1]` not the sub-array with the largest sum of 7? This is a sub array with a larger sum than `[4, -1, 2, 1]`?"
                    },
                    {
                        "username": "PrasannaNaik211",
                        "content": "[@shivyagarg3](/shivyagarg3) please look at the problem they didn\\'t mentioned the sub array should be contiguous."
                    },
                    {
                        "username": "shivyagarg3",
                        "content": "Because we want maximum  sum contiguous subarray"
                    },
                    {
                        "username": "dshgna",
                        "content": "In the case that the array contains all negative values, wouldn\\'t the dynamic programming solution given fall apart?"
                    },
                    {
                        "username": "JayeshSharma",
                        "content": "I solved it using kadane algo, which is ofcourse very efficient but as the question suggest this problem was supposed to solve with divide and conquer method. I couldn\\'t figure out how this can be done with divide and conquer, if you know please explain."
                    }
                ]
            },
            {
                "id": 1573793,
                "content": [
                    {
                        "username": "wen-han",
                        "content": "2 things to take care:\\n1) When temp sum is positive, if next one make it negative, get the new starting point\\n2) When temp sum is negative, if next one is bigger, start the new temp sum with the next value"
                    },
                    {
                        "username": "darioandpaoluigi",
                        "content": "So how can we assume that the max is either in the left right or cross? What if it\\'s a straight up positive array filled with positive numbers and all of them add up to the maximum sum?"
                    },
                    {
                        "username": "Spawnakshay",
                        "content": "This problem took 3-4 years to solve and some guy did solve it in O(n). This problem even has a wikipedia page. \\nhttps://en.wikipedia.org/wiki/Maximum_subarray_problem"
                    },
                    {
                        "username": "davis_benny",
                        "content": "Life Saver Video, I was able to solve the problem in 5 minutes with O(n) complexity\\n\\nhttps://youtu.be/WKN4yKgQNlc\\n\\nThank you.Highly recommended to all my friends."
                    },
                    {
                        "username": "deleted_user",
                        "content": "My first solution failed for input [-1]: \\n - returned 0\\n - expected -1\\n - \\nGiven that an array (subarray) could be empty, and that 0 > -1, I believe that my solution should have been accepted."
                    },
                    {
                        "username": "bparanj",
                        "content": "Constraints say the array length is atleast 1."
                    },
                    {
                        "username": "bananapancake",
                        "content": "I was reading CLRS \"divide and conquer\" section and this problem was the example, but the example was introduced as a \"best time to buy and sell stock\" problem. So I just realized that actually in this problem every element in the list can be considered as the difference between two stock prices in two consecutive days. The O(n) solution is the same idea as the solution to the stock price problem, and it is easier to understand for some people, I guess."
                    },
                    {
                        "username": "sawrubh",
                        "content": "I want to use [std::numeric_limits::min()][1] which is available in the limits standard library. But I don't see a way to include that in my code. Is there any option to do so?\\n\\n\\n  [1]: http://en.cppreference.com/w/cpp/types/numeric_limits"
                    },
                    {
                        "username": "yiming.cheng.524",
                        "content": "or the accepted algorithm cant handle all negative numbers situation"
                    },
                    {
                        "username": "hisully",
                        "content": "Here is an explanation of the O(n) solution, Kadane\\'s Algorithm, along with some visuals.\\nhttps://andrewsullivan.co/articles/2021/9/3/kadanes-algorithm-maximum-subarray"
                    },
                    {
                        "username": "izhongyuting",
                        "content": "s = m = nums[0];(1...nums.length).each{|i| s = [s+nums[i],nums[i]].max;m = [m,s].max};m\\n"
                    }
                ]
            },
            {
                "id": 1573569,
                "content": [
                    {
                        "username": "wen-han",
                        "content": "2 things to take care:\\n1) When temp sum is positive, if next one make it negative, get the new starting point\\n2) When temp sum is negative, if next one is bigger, start the new temp sum with the next value"
                    },
                    {
                        "username": "darioandpaoluigi",
                        "content": "So how can we assume that the max is either in the left right or cross? What if it\\'s a straight up positive array filled with positive numbers and all of them add up to the maximum sum?"
                    },
                    {
                        "username": "Spawnakshay",
                        "content": "This problem took 3-4 years to solve and some guy did solve it in O(n). This problem even has a wikipedia page. \\nhttps://en.wikipedia.org/wiki/Maximum_subarray_problem"
                    },
                    {
                        "username": "davis_benny",
                        "content": "Life Saver Video, I was able to solve the problem in 5 minutes with O(n) complexity\\n\\nhttps://youtu.be/WKN4yKgQNlc\\n\\nThank you.Highly recommended to all my friends."
                    },
                    {
                        "username": "deleted_user",
                        "content": "My first solution failed for input [-1]: \\n - returned 0\\n - expected -1\\n - \\nGiven that an array (subarray) could be empty, and that 0 > -1, I believe that my solution should have been accepted."
                    },
                    {
                        "username": "bparanj",
                        "content": "Constraints say the array length is atleast 1."
                    },
                    {
                        "username": "bananapancake",
                        "content": "I was reading CLRS \"divide and conquer\" section and this problem was the example, but the example was introduced as a \"best time to buy and sell stock\" problem. So I just realized that actually in this problem every element in the list can be considered as the difference between two stock prices in two consecutive days. The O(n) solution is the same idea as the solution to the stock price problem, and it is easier to understand for some people, I guess."
                    },
                    {
                        "username": "sawrubh",
                        "content": "I want to use [std::numeric_limits::min()][1] which is available in the limits standard library. But I don't see a way to include that in my code. Is there any option to do so?\\n\\n\\n  [1]: http://en.cppreference.com/w/cpp/types/numeric_limits"
                    },
                    {
                        "username": "yiming.cheng.524",
                        "content": "or the accepted algorithm cant handle all negative numbers situation"
                    },
                    {
                        "username": "hisully",
                        "content": "Here is an explanation of the O(n) solution, Kadane\\'s Algorithm, along with some visuals.\\nhttps://andrewsullivan.co/articles/2021/9/3/kadanes-algorithm-maximum-subarray"
                    },
                    {
                        "username": "izhongyuting",
                        "content": "s = m = nums[0];(1...nums.length).each{|i| s = [s+nums[i],nums[i]].max;m = [m,s].max};m\\n"
                    }
                ]
            },
            {
                "id": 1573333,
                "content": [
                    {
                        "username": "wen-han",
                        "content": "2 things to take care:\\n1) When temp sum is positive, if next one make it negative, get the new starting point\\n2) When temp sum is negative, if next one is bigger, start the new temp sum with the next value"
                    },
                    {
                        "username": "darioandpaoluigi",
                        "content": "So how can we assume that the max is either in the left right or cross? What if it\\'s a straight up positive array filled with positive numbers and all of them add up to the maximum sum?"
                    },
                    {
                        "username": "Spawnakshay",
                        "content": "This problem took 3-4 years to solve and some guy did solve it in O(n). This problem even has a wikipedia page. \\nhttps://en.wikipedia.org/wiki/Maximum_subarray_problem"
                    },
                    {
                        "username": "davis_benny",
                        "content": "Life Saver Video, I was able to solve the problem in 5 minutes with O(n) complexity\\n\\nhttps://youtu.be/WKN4yKgQNlc\\n\\nThank you.Highly recommended to all my friends."
                    },
                    {
                        "username": "deleted_user",
                        "content": "My first solution failed for input [-1]: \\n - returned 0\\n - expected -1\\n - \\nGiven that an array (subarray) could be empty, and that 0 > -1, I believe that my solution should have been accepted."
                    },
                    {
                        "username": "bparanj",
                        "content": "Constraints say the array length is atleast 1."
                    },
                    {
                        "username": "bananapancake",
                        "content": "I was reading CLRS \"divide and conquer\" section and this problem was the example, but the example was introduced as a \"best time to buy and sell stock\" problem. So I just realized that actually in this problem every element in the list can be considered as the difference between two stock prices in two consecutive days. The O(n) solution is the same idea as the solution to the stock price problem, and it is easier to understand for some people, I guess."
                    },
                    {
                        "username": "sawrubh",
                        "content": "I want to use [std::numeric_limits::min()][1] which is available in the limits standard library. But I don't see a way to include that in my code. Is there any option to do so?\\n\\n\\n  [1]: http://en.cppreference.com/w/cpp/types/numeric_limits"
                    },
                    {
                        "username": "yiming.cheng.524",
                        "content": "or the accepted algorithm cant handle all negative numbers situation"
                    },
                    {
                        "username": "hisully",
                        "content": "Here is an explanation of the O(n) solution, Kadane\\'s Algorithm, along with some visuals.\\nhttps://andrewsullivan.co/articles/2021/9/3/kadanes-algorithm-maximum-subarray"
                    },
                    {
                        "username": "izhongyuting",
                        "content": "s = m = nums[0];(1...nums.length).each{|i| s = [s+nums[i],nums[i]].max;m = [m,s].max};m\\n"
                    }
                ]
            },
            {
                "id": 1572710,
                "content": [
                    {
                        "username": "wen-han",
                        "content": "2 things to take care:\\n1) When temp sum is positive, if next one make it negative, get the new starting point\\n2) When temp sum is negative, if next one is bigger, start the new temp sum with the next value"
                    },
                    {
                        "username": "darioandpaoluigi",
                        "content": "So how can we assume that the max is either in the left right or cross? What if it\\'s a straight up positive array filled with positive numbers and all of them add up to the maximum sum?"
                    },
                    {
                        "username": "Spawnakshay",
                        "content": "This problem took 3-4 years to solve and some guy did solve it in O(n). This problem even has a wikipedia page. \\nhttps://en.wikipedia.org/wiki/Maximum_subarray_problem"
                    },
                    {
                        "username": "davis_benny",
                        "content": "Life Saver Video, I was able to solve the problem in 5 minutes with O(n) complexity\\n\\nhttps://youtu.be/WKN4yKgQNlc\\n\\nThank you.Highly recommended to all my friends."
                    },
                    {
                        "username": "deleted_user",
                        "content": "My first solution failed for input [-1]: \\n - returned 0\\n - expected -1\\n - \\nGiven that an array (subarray) could be empty, and that 0 > -1, I believe that my solution should have been accepted."
                    },
                    {
                        "username": "bparanj",
                        "content": "Constraints say the array length is atleast 1."
                    },
                    {
                        "username": "bananapancake",
                        "content": "I was reading CLRS \"divide and conquer\" section and this problem was the example, but the example was introduced as a \"best time to buy and sell stock\" problem. So I just realized that actually in this problem every element in the list can be considered as the difference between two stock prices in two consecutive days. The O(n) solution is the same idea as the solution to the stock price problem, and it is easier to understand for some people, I guess."
                    },
                    {
                        "username": "sawrubh",
                        "content": "I want to use [std::numeric_limits::min()][1] which is available in the limits standard library. But I don't see a way to include that in my code. Is there any option to do so?\\n\\n\\n  [1]: http://en.cppreference.com/w/cpp/types/numeric_limits"
                    },
                    {
                        "username": "yiming.cheng.524",
                        "content": "or the accepted algorithm cant handle all negative numbers situation"
                    },
                    {
                        "username": "hisully",
                        "content": "Here is an explanation of the O(n) solution, Kadane\\'s Algorithm, along with some visuals.\\nhttps://andrewsullivan.co/articles/2021/9/3/kadanes-algorithm-maximum-subarray"
                    },
                    {
                        "username": "izhongyuting",
                        "content": "s = m = nums[0];(1...nums.length).each{|i| s = [s+nums[i],nums[i]].max;m = [m,s].max};m\\n"
                    }
                ]
            },
            {
                "id": 1572229,
                "content": [
                    {
                        "username": "wen-han",
                        "content": "2 things to take care:\\n1) When temp sum is positive, if next one make it negative, get the new starting point\\n2) When temp sum is negative, if next one is bigger, start the new temp sum with the next value"
                    },
                    {
                        "username": "darioandpaoluigi",
                        "content": "So how can we assume that the max is either in the left right or cross? What if it\\'s a straight up positive array filled with positive numbers and all of them add up to the maximum sum?"
                    },
                    {
                        "username": "Spawnakshay",
                        "content": "This problem took 3-4 years to solve and some guy did solve it in O(n). This problem even has a wikipedia page. \\nhttps://en.wikipedia.org/wiki/Maximum_subarray_problem"
                    },
                    {
                        "username": "davis_benny",
                        "content": "Life Saver Video, I was able to solve the problem in 5 minutes with O(n) complexity\\n\\nhttps://youtu.be/WKN4yKgQNlc\\n\\nThank you.Highly recommended to all my friends."
                    },
                    {
                        "username": "deleted_user",
                        "content": "My first solution failed for input [-1]: \\n - returned 0\\n - expected -1\\n - \\nGiven that an array (subarray) could be empty, and that 0 > -1, I believe that my solution should have been accepted."
                    },
                    {
                        "username": "bparanj",
                        "content": "Constraints say the array length is atleast 1."
                    },
                    {
                        "username": "bananapancake",
                        "content": "I was reading CLRS \"divide and conquer\" section and this problem was the example, but the example was introduced as a \"best time to buy and sell stock\" problem. So I just realized that actually in this problem every element in the list can be considered as the difference between two stock prices in two consecutive days. The O(n) solution is the same idea as the solution to the stock price problem, and it is easier to understand for some people, I guess."
                    },
                    {
                        "username": "sawrubh",
                        "content": "I want to use [std::numeric_limits::min()][1] which is available in the limits standard library. But I don't see a way to include that in my code. Is there any option to do so?\\n\\n\\n  [1]: http://en.cppreference.com/w/cpp/types/numeric_limits"
                    },
                    {
                        "username": "yiming.cheng.524",
                        "content": "or the accepted algorithm cant handle all negative numbers situation"
                    },
                    {
                        "username": "hisully",
                        "content": "Here is an explanation of the O(n) solution, Kadane\\'s Algorithm, along with some visuals.\\nhttps://andrewsullivan.co/articles/2021/9/3/kadanes-algorithm-maximum-subarray"
                    },
                    {
                        "username": "izhongyuting",
                        "content": "s = m = nums[0];(1...nums.length).each{|i| s = [s+nums[i],nums[i]].max;m = [m,s].max};m\\n"
                    }
                ]
            },
            {
                "id": 1571129,
                "content": [
                    {
                        "username": "wen-han",
                        "content": "2 things to take care:\\n1) When temp sum is positive, if next one make it negative, get the new starting point\\n2) When temp sum is negative, if next one is bigger, start the new temp sum with the next value"
                    },
                    {
                        "username": "darioandpaoluigi",
                        "content": "So how can we assume that the max is either in the left right or cross? What if it\\'s a straight up positive array filled with positive numbers and all of them add up to the maximum sum?"
                    },
                    {
                        "username": "Spawnakshay",
                        "content": "This problem took 3-4 years to solve and some guy did solve it in O(n). This problem even has a wikipedia page. \\nhttps://en.wikipedia.org/wiki/Maximum_subarray_problem"
                    },
                    {
                        "username": "davis_benny",
                        "content": "Life Saver Video, I was able to solve the problem in 5 minutes with O(n) complexity\\n\\nhttps://youtu.be/WKN4yKgQNlc\\n\\nThank you.Highly recommended to all my friends."
                    },
                    {
                        "username": "deleted_user",
                        "content": "My first solution failed for input [-1]: \\n - returned 0\\n - expected -1\\n - \\nGiven that an array (subarray) could be empty, and that 0 > -1, I believe that my solution should have been accepted."
                    },
                    {
                        "username": "bparanj",
                        "content": "Constraints say the array length is atleast 1."
                    },
                    {
                        "username": "bananapancake",
                        "content": "I was reading CLRS \"divide and conquer\" section and this problem was the example, but the example was introduced as a \"best time to buy and sell stock\" problem. So I just realized that actually in this problem every element in the list can be considered as the difference between two stock prices in two consecutive days. The O(n) solution is the same idea as the solution to the stock price problem, and it is easier to understand for some people, I guess."
                    },
                    {
                        "username": "sawrubh",
                        "content": "I want to use [std::numeric_limits::min()][1] which is available in the limits standard library. But I don't see a way to include that in my code. Is there any option to do so?\\n\\n\\n  [1]: http://en.cppreference.com/w/cpp/types/numeric_limits"
                    },
                    {
                        "username": "yiming.cheng.524",
                        "content": "or the accepted algorithm cant handle all negative numbers situation"
                    },
                    {
                        "username": "hisully",
                        "content": "Here is an explanation of the O(n) solution, Kadane\\'s Algorithm, along with some visuals.\\nhttps://andrewsullivan.co/articles/2021/9/3/kadanes-algorithm-maximum-subarray"
                    },
                    {
                        "username": "izhongyuting",
                        "content": "s = m = nums[0];(1...nums.length).each{|i| s = [s+nums[i],nums[i]].max;m = [m,s].max};m\\n"
                    }
                ]
            },
            {
                "id": 1568877,
                "content": [
                    {
                        "username": "wen-han",
                        "content": "2 things to take care:\\n1) When temp sum is positive, if next one make it negative, get the new starting point\\n2) When temp sum is negative, if next one is bigger, start the new temp sum with the next value"
                    },
                    {
                        "username": "darioandpaoluigi",
                        "content": "So how can we assume that the max is either in the left right or cross? What if it\\'s a straight up positive array filled with positive numbers and all of them add up to the maximum sum?"
                    },
                    {
                        "username": "Spawnakshay",
                        "content": "This problem took 3-4 years to solve and some guy did solve it in O(n). This problem even has a wikipedia page. \\nhttps://en.wikipedia.org/wiki/Maximum_subarray_problem"
                    },
                    {
                        "username": "davis_benny",
                        "content": "Life Saver Video, I was able to solve the problem in 5 minutes with O(n) complexity\\n\\nhttps://youtu.be/WKN4yKgQNlc\\n\\nThank you.Highly recommended to all my friends."
                    },
                    {
                        "username": "deleted_user",
                        "content": "My first solution failed for input [-1]: \\n - returned 0\\n - expected -1\\n - \\nGiven that an array (subarray) could be empty, and that 0 > -1, I believe that my solution should have been accepted."
                    },
                    {
                        "username": "bparanj",
                        "content": "Constraints say the array length is atleast 1."
                    },
                    {
                        "username": "bananapancake",
                        "content": "I was reading CLRS \"divide and conquer\" section and this problem was the example, but the example was introduced as a \"best time to buy and sell stock\" problem. So I just realized that actually in this problem every element in the list can be considered as the difference between two stock prices in two consecutive days. The O(n) solution is the same idea as the solution to the stock price problem, and it is easier to understand for some people, I guess."
                    },
                    {
                        "username": "sawrubh",
                        "content": "I want to use [std::numeric_limits::min()][1] which is available in the limits standard library. But I don't see a way to include that in my code. Is there any option to do so?\\n\\n\\n  [1]: http://en.cppreference.com/w/cpp/types/numeric_limits"
                    },
                    {
                        "username": "yiming.cheng.524",
                        "content": "or the accepted algorithm cant handle all negative numbers situation"
                    },
                    {
                        "username": "hisully",
                        "content": "Here is an explanation of the O(n) solution, Kadane\\'s Algorithm, along with some visuals.\\nhttps://andrewsullivan.co/articles/2021/9/3/kadanes-algorithm-maximum-subarray"
                    },
                    {
                        "username": "izhongyuting",
                        "content": "s = m = nums[0];(1...nums.length).each{|i| s = [s+nums[i],nums[i]].max;m = [m,s].max};m\\n"
                    }
                ]
            },
            {
                "id": 1568876,
                "content": [
                    {
                        "username": "wen-han",
                        "content": "2 things to take care:\\n1) When temp sum is positive, if next one make it negative, get the new starting point\\n2) When temp sum is negative, if next one is bigger, start the new temp sum with the next value"
                    },
                    {
                        "username": "darioandpaoluigi",
                        "content": "So how can we assume that the max is either in the left right or cross? What if it\\'s a straight up positive array filled with positive numbers and all of them add up to the maximum sum?"
                    },
                    {
                        "username": "Spawnakshay",
                        "content": "This problem took 3-4 years to solve and some guy did solve it in O(n). This problem even has a wikipedia page. \\nhttps://en.wikipedia.org/wiki/Maximum_subarray_problem"
                    },
                    {
                        "username": "davis_benny",
                        "content": "Life Saver Video, I was able to solve the problem in 5 minutes with O(n) complexity\\n\\nhttps://youtu.be/WKN4yKgQNlc\\n\\nThank you.Highly recommended to all my friends."
                    },
                    {
                        "username": "deleted_user",
                        "content": "My first solution failed for input [-1]: \\n - returned 0\\n - expected -1\\n - \\nGiven that an array (subarray) could be empty, and that 0 > -1, I believe that my solution should have been accepted."
                    },
                    {
                        "username": "bparanj",
                        "content": "Constraints say the array length is atleast 1."
                    },
                    {
                        "username": "bananapancake",
                        "content": "I was reading CLRS \"divide and conquer\" section and this problem was the example, but the example was introduced as a \"best time to buy and sell stock\" problem. So I just realized that actually in this problem every element in the list can be considered as the difference between two stock prices in two consecutive days. The O(n) solution is the same idea as the solution to the stock price problem, and it is easier to understand for some people, I guess."
                    },
                    {
                        "username": "sawrubh",
                        "content": "I want to use [std::numeric_limits::min()][1] which is available in the limits standard library. But I don't see a way to include that in my code. Is there any option to do so?\\n\\n\\n  [1]: http://en.cppreference.com/w/cpp/types/numeric_limits"
                    },
                    {
                        "username": "yiming.cheng.524",
                        "content": "or the accepted algorithm cant handle all negative numbers situation"
                    },
                    {
                        "username": "hisully",
                        "content": "Here is an explanation of the O(n) solution, Kadane\\'s Algorithm, along with some visuals.\\nhttps://andrewsullivan.co/articles/2021/9/3/kadanes-algorithm-maximum-subarray"
                    },
                    {
                        "username": "izhongyuting",
                        "content": "s = m = nums[0];(1...nums.length).each{|i| s = [s+nums[i],nums[i]].max;m = [m,s].max};m\\n"
                    }
                ]
            },
            {
                "id": 1568643,
                "content": [
                    {
                        "username": "wen-han",
                        "content": "2 things to take care:\\n1) When temp sum is positive, if next one make it negative, get the new starting point\\n2) When temp sum is negative, if next one is bigger, start the new temp sum with the next value"
                    },
                    {
                        "username": "darioandpaoluigi",
                        "content": "So how can we assume that the max is either in the left right or cross? What if it\\'s a straight up positive array filled with positive numbers and all of them add up to the maximum sum?"
                    },
                    {
                        "username": "Spawnakshay",
                        "content": "This problem took 3-4 years to solve and some guy did solve it in O(n). This problem even has a wikipedia page. \\nhttps://en.wikipedia.org/wiki/Maximum_subarray_problem"
                    },
                    {
                        "username": "davis_benny",
                        "content": "Life Saver Video, I was able to solve the problem in 5 minutes with O(n) complexity\\n\\nhttps://youtu.be/WKN4yKgQNlc\\n\\nThank you.Highly recommended to all my friends."
                    },
                    {
                        "username": "deleted_user",
                        "content": "My first solution failed for input [-1]: \\n - returned 0\\n - expected -1\\n - \\nGiven that an array (subarray) could be empty, and that 0 > -1, I believe that my solution should have been accepted."
                    },
                    {
                        "username": "bparanj",
                        "content": "Constraints say the array length is atleast 1."
                    },
                    {
                        "username": "bananapancake",
                        "content": "I was reading CLRS \"divide and conquer\" section and this problem was the example, but the example was introduced as a \"best time to buy and sell stock\" problem. So I just realized that actually in this problem every element in the list can be considered as the difference between two stock prices in two consecutive days. The O(n) solution is the same idea as the solution to the stock price problem, and it is easier to understand for some people, I guess."
                    },
                    {
                        "username": "sawrubh",
                        "content": "I want to use [std::numeric_limits::min()][1] which is available in the limits standard library. But I don't see a way to include that in my code. Is there any option to do so?\\n\\n\\n  [1]: http://en.cppreference.com/w/cpp/types/numeric_limits"
                    },
                    {
                        "username": "yiming.cheng.524",
                        "content": "or the accepted algorithm cant handle all negative numbers situation"
                    },
                    {
                        "username": "hisully",
                        "content": "Here is an explanation of the O(n) solution, Kadane\\'s Algorithm, along with some visuals.\\nhttps://andrewsullivan.co/articles/2021/9/3/kadanes-algorithm-maximum-subarray"
                    },
                    {
                        "username": "izhongyuting",
                        "content": "s = m = nums[0];(1...nums.length).each{|i| s = [s+nums[i],nums[i]].max;m = [m,s].max};m\\n"
                    }
                ]
            },
            {
                "id": 1569527,
                "content": [
                    {
                        "username": "wen-han",
                        "content": "2 things to take care:\\n1) When temp sum is positive, if next one make it negative, get the new starting point\\n2) When temp sum is negative, if next one is bigger, start the new temp sum with the next value"
                    },
                    {
                        "username": "darioandpaoluigi",
                        "content": "So how can we assume that the max is either in the left right or cross? What if it\\'s a straight up positive array filled with positive numbers and all of them add up to the maximum sum?"
                    },
                    {
                        "username": "Spawnakshay",
                        "content": "This problem took 3-4 years to solve and some guy did solve it in O(n). This problem even has a wikipedia page. \\nhttps://en.wikipedia.org/wiki/Maximum_subarray_problem"
                    },
                    {
                        "username": "davis_benny",
                        "content": "Life Saver Video, I was able to solve the problem in 5 minutes with O(n) complexity\\n\\nhttps://youtu.be/WKN4yKgQNlc\\n\\nThank you.Highly recommended to all my friends."
                    },
                    {
                        "username": "deleted_user",
                        "content": "My first solution failed for input [-1]: \\n - returned 0\\n - expected -1\\n - \\nGiven that an array (subarray) could be empty, and that 0 > -1, I believe that my solution should have been accepted."
                    },
                    {
                        "username": "bparanj",
                        "content": "Constraints say the array length is atleast 1."
                    },
                    {
                        "username": "bananapancake",
                        "content": "I was reading CLRS \"divide and conquer\" section and this problem was the example, but the example was introduced as a \"best time to buy and sell stock\" problem. So I just realized that actually in this problem every element in the list can be considered as the difference between two stock prices in two consecutive days. The O(n) solution is the same idea as the solution to the stock price problem, and it is easier to understand for some people, I guess."
                    },
                    {
                        "username": "sawrubh",
                        "content": "I want to use [std::numeric_limits::min()][1] which is available in the limits standard library. But I don't see a way to include that in my code. Is there any option to do so?\\n\\n\\n  [1]: http://en.cppreference.com/w/cpp/types/numeric_limits"
                    },
                    {
                        "username": "yiming.cheng.524",
                        "content": "or the accepted algorithm cant handle all negative numbers situation"
                    },
                    {
                        "username": "hisully",
                        "content": "Here is an explanation of the O(n) solution, Kadane\\'s Algorithm, along with some visuals.\\nhttps://andrewsullivan.co/articles/2021/9/3/kadanes-algorithm-maximum-subarray"
                    },
                    {
                        "username": "izhongyuting",
                        "content": "s = m = nums[0];(1...nums.length).each{|i| s = [s+nums[i],nums[i]].max;m = [m,s].max};m\\n"
                    }
                ]
            },
            {
                "id": 1570097,
                "content": [
                    {
                        "username": "emailsemails7",
                        "content": "const maxSubArray = nums => nums.reduce((state, curr) => [Math.max(curr, state[0] + curr), Math.max(state[1], Math.max(curr, state[0] + curr))],[-Infinity, -Infinity])[1];"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tcurSum = maxSum = nums[0]\\n\\tfor val in nums[1 : ]:\\n\\t\\tcurSum = max(val, curSum + val)\\n\\t\\tmaxSum = max(maxSum, curSum)\\n\\treturn maxSum"
                    },
                    {
                        "username": "rafeedarian99",
                        "content": "If you have a list of only negative numbers, technically the empty subarray has a sum of 0, thus would be largest sum subarray.\\n\\nSo the question is actually asking for subarrays of at least length 1. Important distinction!"
                    },
                    {
                        "username": "_nik_",
                        "content": "Can someone explain how to solve this problem for a negative array?\\nI\\'m using kadanes method and it is solving for positive array. \\nPlease help. "
                    },
                    {
                        "username": "hola_aryan",
                        "content": "This is not at all an medium solution. You have to learn a new algorithm for optimized approach"
                    },
                    {
                        "username": "turtle5016",
                        "content": "My code as per Kadane\\'s Algorithm passes 195 cases out of 210. Is there any additional condition or base case needs to be added?\\nKindly suggest."
                    },
                    {
                        "username": "sonamsherpa16",
                        "content": "Kadane\\'s algorithm is more efficient than the Divide and Conquer Algorithm in a sense that it takes O(n) where Divide takes O(n log n) time. I don\\'t understand why Divide and Conquer is said to be more subtle. Can anybody explain to me why?"
                    },
                    {
                        "username": "shahansha001",
                        "content": "Start karo array ke pehle element se aur iterate karo array ke har element par.\\nHar step pe, decide karo: kya current element ko existing subarray mein add karna hai ya naya subarray start karna hai.\\nYeh decision aata hai by comparing the current element with the sum of the current element and the previous maximum subarray sum.\\nContinue this till the end of the array. \\n`\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) \\n{\\n        if(nums.empty()) \\nreturn 0;    \\n    int current_sum = nums[0], max_sum = nums[0];\\n    \\n    for(int i = 1; i < nums.size(); i++) {\\n        current_sum = max(nums[i], current_sum + nums[i]);\\n        max_sum = max(max_sum, current_sum);\\n    }\\n        return max_sum;\\n\\n    }\\n};`\\n"
                    },
                    {
                        "username": "sans_ki_party",
                        "content": "class Solution {\\n    public int maxSubArray(int[] nums) {\\n    \\n        int max = Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int sum=0;\\n            for(int j=i;j<nums.length;j++)\\n            {\\n                sum+=nums[j];\\n                if(sum>max)\\n                {\\n                    max=sum;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n\\nI don\\'t get this that if my logic is correct then why my code is unacceptable. This is the most annoying thing of leetcode and i guess you should allow us to do our code by whatever means we want. "
                    },
                    {
                        "username": "MukiKrishnan",
                        "content": "Can this problem please specify that the subarray has to be contiguous in terms of element ordering? It would make this problem more explicit, rather than having us infer this only from the examples."
                    }
                ]
            },
            {
                "id": 1574740,
                "content": [
                    {
                        "username": "emailsemails7",
                        "content": "const maxSubArray = nums => nums.reduce((state, curr) => [Math.max(curr, state[0] + curr), Math.max(state[1], Math.max(curr, state[0] + curr))],[-Infinity, -Infinity])[1];"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tcurSum = maxSum = nums[0]\\n\\tfor val in nums[1 : ]:\\n\\t\\tcurSum = max(val, curSum + val)\\n\\t\\tmaxSum = max(maxSum, curSum)\\n\\treturn maxSum"
                    },
                    {
                        "username": "rafeedarian99",
                        "content": "If you have a list of only negative numbers, technically the empty subarray has a sum of 0, thus would be largest sum subarray.\\n\\nSo the question is actually asking for subarrays of at least length 1. Important distinction!"
                    },
                    {
                        "username": "_nik_",
                        "content": "Can someone explain how to solve this problem for a negative array?\\nI\\'m using kadanes method and it is solving for positive array. \\nPlease help. "
                    },
                    {
                        "username": "hola_aryan",
                        "content": "This is not at all an medium solution. You have to learn a new algorithm for optimized approach"
                    },
                    {
                        "username": "turtle5016",
                        "content": "My code as per Kadane\\'s Algorithm passes 195 cases out of 210. Is there any additional condition or base case needs to be added?\\nKindly suggest."
                    },
                    {
                        "username": "sonamsherpa16",
                        "content": "Kadane\\'s algorithm is more efficient than the Divide and Conquer Algorithm in a sense that it takes O(n) where Divide takes O(n log n) time. I don\\'t understand why Divide and Conquer is said to be more subtle. Can anybody explain to me why?"
                    },
                    {
                        "username": "shahansha001",
                        "content": "Start karo array ke pehle element se aur iterate karo array ke har element par.\\nHar step pe, decide karo: kya current element ko existing subarray mein add karna hai ya naya subarray start karna hai.\\nYeh decision aata hai by comparing the current element with the sum of the current element and the previous maximum subarray sum.\\nContinue this till the end of the array. \\n`\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) \\n{\\n        if(nums.empty()) \\nreturn 0;    \\n    int current_sum = nums[0], max_sum = nums[0];\\n    \\n    for(int i = 1; i < nums.size(); i++) {\\n        current_sum = max(nums[i], current_sum + nums[i]);\\n        max_sum = max(max_sum, current_sum);\\n    }\\n        return max_sum;\\n\\n    }\\n};`\\n"
                    },
                    {
                        "username": "sans_ki_party",
                        "content": "class Solution {\\n    public int maxSubArray(int[] nums) {\\n    \\n        int max = Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int sum=0;\\n            for(int j=i;j<nums.length;j++)\\n            {\\n                sum+=nums[j];\\n                if(sum>max)\\n                {\\n                    max=sum;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n\\nI don\\'t get this that if my logic is correct then why my code is unacceptable. This is the most annoying thing of leetcode and i guess you should allow us to do our code by whatever means we want. "
                    },
                    {
                        "username": "MukiKrishnan",
                        "content": "Can this problem please specify that the subarray has to be contiguous in terms of element ordering? It would make this problem more explicit, rather than having us infer this only from the examples."
                    }
                ]
            },
            {
                "id": 2075112,
                "content": [
                    {
                        "username": "emailsemails7",
                        "content": "const maxSubArray = nums => nums.reduce((state, curr) => [Math.max(curr, state[0] + curr), Math.max(state[1], Math.max(curr, state[0] + curr))],[-Infinity, -Infinity])[1];"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tcurSum = maxSum = nums[0]\\n\\tfor val in nums[1 : ]:\\n\\t\\tcurSum = max(val, curSum + val)\\n\\t\\tmaxSum = max(maxSum, curSum)\\n\\treturn maxSum"
                    },
                    {
                        "username": "rafeedarian99",
                        "content": "If you have a list of only negative numbers, technically the empty subarray has a sum of 0, thus would be largest sum subarray.\\n\\nSo the question is actually asking for subarrays of at least length 1. Important distinction!"
                    },
                    {
                        "username": "_nik_",
                        "content": "Can someone explain how to solve this problem for a negative array?\\nI\\'m using kadanes method and it is solving for positive array. \\nPlease help. "
                    },
                    {
                        "username": "hola_aryan",
                        "content": "This is not at all an medium solution. You have to learn a new algorithm for optimized approach"
                    },
                    {
                        "username": "turtle5016",
                        "content": "My code as per Kadane\\'s Algorithm passes 195 cases out of 210. Is there any additional condition or base case needs to be added?\\nKindly suggest."
                    },
                    {
                        "username": "sonamsherpa16",
                        "content": "Kadane\\'s algorithm is more efficient than the Divide and Conquer Algorithm in a sense that it takes O(n) where Divide takes O(n log n) time. I don\\'t understand why Divide and Conquer is said to be more subtle. Can anybody explain to me why?"
                    },
                    {
                        "username": "shahansha001",
                        "content": "Start karo array ke pehle element se aur iterate karo array ke har element par.\\nHar step pe, decide karo: kya current element ko existing subarray mein add karna hai ya naya subarray start karna hai.\\nYeh decision aata hai by comparing the current element with the sum of the current element and the previous maximum subarray sum.\\nContinue this till the end of the array. \\n`\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) \\n{\\n        if(nums.empty()) \\nreturn 0;    \\n    int current_sum = nums[0], max_sum = nums[0];\\n    \\n    for(int i = 1; i < nums.size(); i++) {\\n        current_sum = max(nums[i], current_sum + nums[i]);\\n        max_sum = max(max_sum, current_sum);\\n    }\\n        return max_sum;\\n\\n    }\\n};`\\n"
                    },
                    {
                        "username": "sans_ki_party",
                        "content": "class Solution {\\n    public int maxSubArray(int[] nums) {\\n    \\n        int max = Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int sum=0;\\n            for(int j=i;j<nums.length;j++)\\n            {\\n                sum+=nums[j];\\n                if(sum>max)\\n                {\\n                    max=sum;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n\\nI don\\'t get this that if my logic is correct then why my code is unacceptable. This is the most annoying thing of leetcode and i guess you should allow us to do our code by whatever means we want. "
                    },
                    {
                        "username": "MukiKrishnan",
                        "content": "Can this problem please specify that the subarray has to be contiguous in terms of element ordering? It would make this problem more explicit, rather than having us infer this only from the examples."
                    }
                ]
            },
            {
                "id": 2067517,
                "content": [
                    {
                        "username": "emailsemails7",
                        "content": "const maxSubArray = nums => nums.reduce((state, curr) => [Math.max(curr, state[0] + curr), Math.max(state[1], Math.max(curr, state[0] + curr))],[-Infinity, -Infinity])[1];"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tcurSum = maxSum = nums[0]\\n\\tfor val in nums[1 : ]:\\n\\t\\tcurSum = max(val, curSum + val)\\n\\t\\tmaxSum = max(maxSum, curSum)\\n\\treturn maxSum"
                    },
                    {
                        "username": "rafeedarian99",
                        "content": "If you have a list of only negative numbers, technically the empty subarray has a sum of 0, thus would be largest sum subarray.\\n\\nSo the question is actually asking for subarrays of at least length 1. Important distinction!"
                    },
                    {
                        "username": "_nik_",
                        "content": "Can someone explain how to solve this problem for a negative array?\\nI\\'m using kadanes method and it is solving for positive array. \\nPlease help. "
                    },
                    {
                        "username": "hola_aryan",
                        "content": "This is not at all an medium solution. You have to learn a new algorithm for optimized approach"
                    },
                    {
                        "username": "turtle5016",
                        "content": "My code as per Kadane\\'s Algorithm passes 195 cases out of 210. Is there any additional condition or base case needs to be added?\\nKindly suggest."
                    },
                    {
                        "username": "sonamsherpa16",
                        "content": "Kadane\\'s algorithm is more efficient than the Divide and Conquer Algorithm in a sense that it takes O(n) where Divide takes O(n log n) time. I don\\'t understand why Divide and Conquer is said to be more subtle. Can anybody explain to me why?"
                    },
                    {
                        "username": "shahansha001",
                        "content": "Start karo array ke pehle element se aur iterate karo array ke har element par.\\nHar step pe, decide karo: kya current element ko existing subarray mein add karna hai ya naya subarray start karna hai.\\nYeh decision aata hai by comparing the current element with the sum of the current element and the previous maximum subarray sum.\\nContinue this till the end of the array. \\n`\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) \\n{\\n        if(nums.empty()) \\nreturn 0;    \\n    int current_sum = nums[0], max_sum = nums[0];\\n    \\n    for(int i = 1; i < nums.size(); i++) {\\n        current_sum = max(nums[i], current_sum + nums[i]);\\n        max_sum = max(max_sum, current_sum);\\n    }\\n        return max_sum;\\n\\n    }\\n};`\\n"
                    },
                    {
                        "username": "sans_ki_party",
                        "content": "class Solution {\\n    public int maxSubArray(int[] nums) {\\n    \\n        int max = Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int sum=0;\\n            for(int j=i;j<nums.length;j++)\\n            {\\n                sum+=nums[j];\\n                if(sum>max)\\n                {\\n                    max=sum;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n\\nI don\\'t get this that if my logic is correct then why my code is unacceptable. This is the most annoying thing of leetcode and i guess you should allow us to do our code by whatever means we want. "
                    },
                    {
                        "username": "MukiKrishnan",
                        "content": "Can this problem please specify that the subarray has to be contiguous in terms of element ordering? It would make this problem more explicit, rather than having us infer this only from the examples."
                    }
                ]
            },
            {
                "id": 2064540,
                "content": [
                    {
                        "username": "emailsemails7",
                        "content": "const maxSubArray = nums => nums.reduce((state, curr) => [Math.max(curr, state[0] + curr), Math.max(state[1], Math.max(curr, state[0] + curr))],[-Infinity, -Infinity])[1];"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tcurSum = maxSum = nums[0]\\n\\tfor val in nums[1 : ]:\\n\\t\\tcurSum = max(val, curSum + val)\\n\\t\\tmaxSum = max(maxSum, curSum)\\n\\treturn maxSum"
                    },
                    {
                        "username": "rafeedarian99",
                        "content": "If you have a list of only negative numbers, technically the empty subarray has a sum of 0, thus would be largest sum subarray.\\n\\nSo the question is actually asking for subarrays of at least length 1. Important distinction!"
                    },
                    {
                        "username": "_nik_",
                        "content": "Can someone explain how to solve this problem for a negative array?\\nI\\'m using kadanes method and it is solving for positive array. \\nPlease help. "
                    },
                    {
                        "username": "hola_aryan",
                        "content": "This is not at all an medium solution. You have to learn a new algorithm for optimized approach"
                    },
                    {
                        "username": "turtle5016",
                        "content": "My code as per Kadane\\'s Algorithm passes 195 cases out of 210. Is there any additional condition or base case needs to be added?\\nKindly suggest."
                    },
                    {
                        "username": "sonamsherpa16",
                        "content": "Kadane\\'s algorithm is more efficient than the Divide and Conquer Algorithm in a sense that it takes O(n) where Divide takes O(n log n) time. I don\\'t understand why Divide and Conquer is said to be more subtle. Can anybody explain to me why?"
                    },
                    {
                        "username": "shahansha001",
                        "content": "Start karo array ke pehle element se aur iterate karo array ke har element par.\\nHar step pe, decide karo: kya current element ko existing subarray mein add karna hai ya naya subarray start karna hai.\\nYeh decision aata hai by comparing the current element with the sum of the current element and the previous maximum subarray sum.\\nContinue this till the end of the array. \\n`\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) \\n{\\n        if(nums.empty()) \\nreturn 0;    \\n    int current_sum = nums[0], max_sum = nums[0];\\n    \\n    for(int i = 1; i < nums.size(); i++) {\\n        current_sum = max(nums[i], current_sum + nums[i]);\\n        max_sum = max(max_sum, current_sum);\\n    }\\n        return max_sum;\\n\\n    }\\n};`\\n"
                    },
                    {
                        "username": "sans_ki_party",
                        "content": "class Solution {\\n    public int maxSubArray(int[] nums) {\\n    \\n        int max = Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int sum=0;\\n            for(int j=i;j<nums.length;j++)\\n            {\\n                sum+=nums[j];\\n                if(sum>max)\\n                {\\n                    max=sum;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n\\nI don\\'t get this that if my logic is correct then why my code is unacceptable. This is the most annoying thing of leetcode and i guess you should allow us to do our code by whatever means we want. "
                    },
                    {
                        "username": "MukiKrishnan",
                        "content": "Can this problem please specify that the subarray has to be contiguous in terms of element ordering? It would make this problem more explicit, rather than having us infer this only from the examples."
                    }
                ]
            },
            {
                "id": 2063545,
                "content": [
                    {
                        "username": "emailsemails7",
                        "content": "const maxSubArray = nums => nums.reduce((state, curr) => [Math.max(curr, state[0] + curr), Math.max(state[1], Math.max(curr, state[0] + curr))],[-Infinity, -Infinity])[1];"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tcurSum = maxSum = nums[0]\\n\\tfor val in nums[1 : ]:\\n\\t\\tcurSum = max(val, curSum + val)\\n\\t\\tmaxSum = max(maxSum, curSum)\\n\\treturn maxSum"
                    },
                    {
                        "username": "rafeedarian99",
                        "content": "If you have a list of only negative numbers, technically the empty subarray has a sum of 0, thus would be largest sum subarray.\\n\\nSo the question is actually asking for subarrays of at least length 1. Important distinction!"
                    },
                    {
                        "username": "_nik_",
                        "content": "Can someone explain how to solve this problem for a negative array?\\nI\\'m using kadanes method and it is solving for positive array. \\nPlease help. "
                    },
                    {
                        "username": "hola_aryan",
                        "content": "This is not at all an medium solution. You have to learn a new algorithm for optimized approach"
                    },
                    {
                        "username": "turtle5016",
                        "content": "My code as per Kadane\\'s Algorithm passes 195 cases out of 210. Is there any additional condition or base case needs to be added?\\nKindly suggest."
                    },
                    {
                        "username": "sonamsherpa16",
                        "content": "Kadane\\'s algorithm is more efficient than the Divide and Conquer Algorithm in a sense that it takes O(n) where Divide takes O(n log n) time. I don\\'t understand why Divide and Conquer is said to be more subtle. Can anybody explain to me why?"
                    },
                    {
                        "username": "shahansha001",
                        "content": "Start karo array ke pehle element se aur iterate karo array ke har element par.\\nHar step pe, decide karo: kya current element ko existing subarray mein add karna hai ya naya subarray start karna hai.\\nYeh decision aata hai by comparing the current element with the sum of the current element and the previous maximum subarray sum.\\nContinue this till the end of the array. \\n`\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) \\n{\\n        if(nums.empty()) \\nreturn 0;    \\n    int current_sum = nums[0], max_sum = nums[0];\\n    \\n    for(int i = 1; i < nums.size(); i++) {\\n        current_sum = max(nums[i], current_sum + nums[i]);\\n        max_sum = max(max_sum, current_sum);\\n    }\\n        return max_sum;\\n\\n    }\\n};`\\n"
                    },
                    {
                        "username": "sans_ki_party",
                        "content": "class Solution {\\n    public int maxSubArray(int[] nums) {\\n    \\n        int max = Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int sum=0;\\n            for(int j=i;j<nums.length;j++)\\n            {\\n                sum+=nums[j];\\n                if(sum>max)\\n                {\\n                    max=sum;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n\\nI don\\'t get this that if my logic is correct then why my code is unacceptable. This is the most annoying thing of leetcode and i guess you should allow us to do our code by whatever means we want. "
                    },
                    {
                        "username": "MukiKrishnan",
                        "content": "Can this problem please specify that the subarray has to be contiguous in terms of element ordering? It would make this problem more explicit, rather than having us infer this only from the examples."
                    }
                ]
            },
            {
                "id": 2059278,
                "content": [
                    {
                        "username": "emailsemails7",
                        "content": "const maxSubArray = nums => nums.reduce((state, curr) => [Math.max(curr, state[0] + curr), Math.max(state[1], Math.max(curr, state[0] + curr))],[-Infinity, -Infinity])[1];"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tcurSum = maxSum = nums[0]\\n\\tfor val in nums[1 : ]:\\n\\t\\tcurSum = max(val, curSum + val)\\n\\t\\tmaxSum = max(maxSum, curSum)\\n\\treturn maxSum"
                    },
                    {
                        "username": "rafeedarian99",
                        "content": "If you have a list of only negative numbers, technically the empty subarray has a sum of 0, thus would be largest sum subarray.\\n\\nSo the question is actually asking for subarrays of at least length 1. Important distinction!"
                    },
                    {
                        "username": "_nik_",
                        "content": "Can someone explain how to solve this problem for a negative array?\\nI\\'m using kadanes method and it is solving for positive array. \\nPlease help. "
                    },
                    {
                        "username": "hola_aryan",
                        "content": "This is not at all an medium solution. You have to learn a new algorithm for optimized approach"
                    },
                    {
                        "username": "turtle5016",
                        "content": "My code as per Kadane\\'s Algorithm passes 195 cases out of 210. Is there any additional condition or base case needs to be added?\\nKindly suggest."
                    },
                    {
                        "username": "sonamsherpa16",
                        "content": "Kadane\\'s algorithm is more efficient than the Divide and Conquer Algorithm in a sense that it takes O(n) where Divide takes O(n log n) time. I don\\'t understand why Divide and Conquer is said to be more subtle. Can anybody explain to me why?"
                    },
                    {
                        "username": "shahansha001",
                        "content": "Start karo array ke pehle element se aur iterate karo array ke har element par.\\nHar step pe, decide karo: kya current element ko existing subarray mein add karna hai ya naya subarray start karna hai.\\nYeh decision aata hai by comparing the current element with the sum of the current element and the previous maximum subarray sum.\\nContinue this till the end of the array. \\n`\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) \\n{\\n        if(nums.empty()) \\nreturn 0;    \\n    int current_sum = nums[0], max_sum = nums[0];\\n    \\n    for(int i = 1; i < nums.size(); i++) {\\n        current_sum = max(nums[i], current_sum + nums[i]);\\n        max_sum = max(max_sum, current_sum);\\n    }\\n        return max_sum;\\n\\n    }\\n};`\\n"
                    },
                    {
                        "username": "sans_ki_party",
                        "content": "class Solution {\\n    public int maxSubArray(int[] nums) {\\n    \\n        int max = Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int sum=0;\\n            for(int j=i;j<nums.length;j++)\\n            {\\n                sum+=nums[j];\\n                if(sum>max)\\n                {\\n                    max=sum;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n\\nI don\\'t get this that if my logic is correct then why my code is unacceptable. This is the most annoying thing of leetcode and i guess you should allow us to do our code by whatever means we want. "
                    },
                    {
                        "username": "MukiKrishnan",
                        "content": "Can this problem please specify that the subarray has to be contiguous in terms of element ordering? It would make this problem more explicit, rather than having us infer this only from the examples."
                    }
                ]
            },
            {
                "id": 2057715,
                "content": [
                    {
                        "username": "emailsemails7",
                        "content": "const maxSubArray = nums => nums.reduce((state, curr) => [Math.max(curr, state[0] + curr), Math.max(state[1], Math.max(curr, state[0] + curr))],[-Infinity, -Infinity])[1];"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tcurSum = maxSum = nums[0]\\n\\tfor val in nums[1 : ]:\\n\\t\\tcurSum = max(val, curSum + val)\\n\\t\\tmaxSum = max(maxSum, curSum)\\n\\treturn maxSum"
                    },
                    {
                        "username": "rafeedarian99",
                        "content": "If you have a list of only negative numbers, technically the empty subarray has a sum of 0, thus would be largest sum subarray.\\n\\nSo the question is actually asking for subarrays of at least length 1. Important distinction!"
                    },
                    {
                        "username": "_nik_",
                        "content": "Can someone explain how to solve this problem for a negative array?\\nI\\'m using kadanes method and it is solving for positive array. \\nPlease help. "
                    },
                    {
                        "username": "hola_aryan",
                        "content": "This is not at all an medium solution. You have to learn a new algorithm for optimized approach"
                    },
                    {
                        "username": "turtle5016",
                        "content": "My code as per Kadane\\'s Algorithm passes 195 cases out of 210. Is there any additional condition or base case needs to be added?\\nKindly suggest."
                    },
                    {
                        "username": "sonamsherpa16",
                        "content": "Kadane\\'s algorithm is more efficient than the Divide and Conquer Algorithm in a sense that it takes O(n) where Divide takes O(n log n) time. I don\\'t understand why Divide and Conquer is said to be more subtle. Can anybody explain to me why?"
                    },
                    {
                        "username": "shahansha001",
                        "content": "Start karo array ke pehle element se aur iterate karo array ke har element par.\\nHar step pe, decide karo: kya current element ko existing subarray mein add karna hai ya naya subarray start karna hai.\\nYeh decision aata hai by comparing the current element with the sum of the current element and the previous maximum subarray sum.\\nContinue this till the end of the array. \\n`\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) \\n{\\n        if(nums.empty()) \\nreturn 0;    \\n    int current_sum = nums[0], max_sum = nums[0];\\n    \\n    for(int i = 1; i < nums.size(); i++) {\\n        current_sum = max(nums[i], current_sum + nums[i]);\\n        max_sum = max(max_sum, current_sum);\\n    }\\n        return max_sum;\\n\\n    }\\n};`\\n"
                    },
                    {
                        "username": "sans_ki_party",
                        "content": "class Solution {\\n    public int maxSubArray(int[] nums) {\\n    \\n        int max = Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int sum=0;\\n            for(int j=i;j<nums.length;j++)\\n            {\\n                sum+=nums[j];\\n                if(sum>max)\\n                {\\n                    max=sum;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n\\nI don\\'t get this that if my logic is correct then why my code is unacceptable. This is the most annoying thing of leetcode and i guess you should allow us to do our code by whatever means we want. "
                    },
                    {
                        "username": "MukiKrishnan",
                        "content": "Can this problem please specify that the subarray has to be contiguous in terms of element ordering? It would make this problem more explicit, rather than having us infer this only from the examples."
                    }
                ]
            },
            {
                "id": 2048087,
                "content": [
                    {
                        "username": "emailsemails7",
                        "content": "const maxSubArray = nums => nums.reduce((state, curr) => [Math.max(curr, state[0] + curr), Math.max(state[1], Math.max(curr, state[0] + curr))],[-Infinity, -Infinity])[1];"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tcurSum = maxSum = nums[0]\\n\\tfor val in nums[1 : ]:\\n\\t\\tcurSum = max(val, curSum + val)\\n\\t\\tmaxSum = max(maxSum, curSum)\\n\\treturn maxSum"
                    },
                    {
                        "username": "rafeedarian99",
                        "content": "If you have a list of only negative numbers, technically the empty subarray has a sum of 0, thus would be largest sum subarray.\\n\\nSo the question is actually asking for subarrays of at least length 1. Important distinction!"
                    },
                    {
                        "username": "_nik_",
                        "content": "Can someone explain how to solve this problem for a negative array?\\nI\\'m using kadanes method and it is solving for positive array. \\nPlease help. "
                    },
                    {
                        "username": "hola_aryan",
                        "content": "This is not at all an medium solution. You have to learn a new algorithm for optimized approach"
                    },
                    {
                        "username": "turtle5016",
                        "content": "My code as per Kadane\\'s Algorithm passes 195 cases out of 210. Is there any additional condition or base case needs to be added?\\nKindly suggest."
                    },
                    {
                        "username": "sonamsherpa16",
                        "content": "Kadane\\'s algorithm is more efficient than the Divide and Conquer Algorithm in a sense that it takes O(n) where Divide takes O(n log n) time. I don\\'t understand why Divide and Conquer is said to be more subtle. Can anybody explain to me why?"
                    },
                    {
                        "username": "shahansha001",
                        "content": "Start karo array ke pehle element se aur iterate karo array ke har element par.\\nHar step pe, decide karo: kya current element ko existing subarray mein add karna hai ya naya subarray start karna hai.\\nYeh decision aata hai by comparing the current element with the sum of the current element and the previous maximum subarray sum.\\nContinue this till the end of the array. \\n`\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) \\n{\\n        if(nums.empty()) \\nreturn 0;    \\n    int current_sum = nums[0], max_sum = nums[0];\\n    \\n    for(int i = 1; i < nums.size(); i++) {\\n        current_sum = max(nums[i], current_sum + nums[i]);\\n        max_sum = max(max_sum, current_sum);\\n    }\\n        return max_sum;\\n\\n    }\\n};`\\n"
                    },
                    {
                        "username": "sans_ki_party",
                        "content": "class Solution {\\n    public int maxSubArray(int[] nums) {\\n    \\n        int max = Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int sum=0;\\n            for(int j=i;j<nums.length;j++)\\n            {\\n                sum+=nums[j];\\n                if(sum>max)\\n                {\\n                    max=sum;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n\\nI don\\'t get this that if my logic is correct then why my code is unacceptable. This is the most annoying thing of leetcode and i guess you should allow us to do our code by whatever means we want. "
                    },
                    {
                        "username": "MukiKrishnan",
                        "content": "Can this problem please specify that the subarray has to be contiguous in terms of element ordering? It would make this problem more explicit, rather than having us infer this only from the examples."
                    }
                ]
            },
            {
                "id": 2039301,
                "content": [
                    {
                        "username": "emailsemails7",
                        "content": "const maxSubArray = nums => nums.reduce((state, curr) => [Math.max(curr, state[0] + curr), Math.max(state[1], Math.max(curr, state[0] + curr))],[-Infinity, -Infinity])[1];"
                    },
                    {
                        "username": "FACEPLANT",
                        "content": "\\tcurSum = maxSum = nums[0]\\n\\tfor val in nums[1 : ]:\\n\\t\\tcurSum = max(val, curSum + val)\\n\\t\\tmaxSum = max(maxSum, curSum)\\n\\treturn maxSum"
                    },
                    {
                        "username": "rafeedarian99",
                        "content": "If you have a list of only negative numbers, technically the empty subarray has a sum of 0, thus would be largest sum subarray.\\n\\nSo the question is actually asking for subarrays of at least length 1. Important distinction!"
                    },
                    {
                        "username": "_nik_",
                        "content": "Can someone explain how to solve this problem for a negative array?\\nI\\'m using kadanes method and it is solving for positive array. \\nPlease help. "
                    },
                    {
                        "username": "hola_aryan",
                        "content": "This is not at all an medium solution. You have to learn a new algorithm for optimized approach"
                    },
                    {
                        "username": "turtle5016",
                        "content": "My code as per Kadane\\'s Algorithm passes 195 cases out of 210. Is there any additional condition or base case needs to be added?\\nKindly suggest."
                    },
                    {
                        "username": "sonamsherpa16",
                        "content": "Kadane\\'s algorithm is more efficient than the Divide and Conquer Algorithm in a sense that it takes O(n) where Divide takes O(n log n) time. I don\\'t understand why Divide and Conquer is said to be more subtle. Can anybody explain to me why?"
                    },
                    {
                        "username": "shahansha001",
                        "content": "Start karo array ke pehle element se aur iterate karo array ke har element par.\\nHar step pe, decide karo: kya current element ko existing subarray mein add karna hai ya naya subarray start karna hai.\\nYeh decision aata hai by comparing the current element with the sum of the current element and the previous maximum subarray sum.\\nContinue this till the end of the array. \\n`\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) \\n{\\n        if(nums.empty()) \\nreturn 0;    \\n    int current_sum = nums[0], max_sum = nums[0];\\n    \\n    for(int i = 1; i < nums.size(); i++) {\\n        current_sum = max(nums[i], current_sum + nums[i]);\\n        max_sum = max(max_sum, current_sum);\\n    }\\n        return max_sum;\\n\\n    }\\n};`\\n"
                    },
                    {
                        "username": "sans_ki_party",
                        "content": "class Solution {\\n    public int maxSubArray(int[] nums) {\\n    \\n        int max = Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            int sum=0;\\n            for(int j=i;j<nums.length;j++)\\n            {\\n                sum+=nums[j];\\n                if(sum>max)\\n                {\\n                    max=sum;\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n\\nI don\\'t get this that if my logic is correct then why my code is unacceptable. This is the most annoying thing of leetcode and i guess you should allow us to do our code by whatever means we want. "
                    },
                    {
                        "username": "MukiKrishnan",
                        "content": "Can this problem please specify that the subarray has to be contiguous in terms of element ordering? It would make this problem more explicit, rather than having us infer this only from the examples."
                    }
                ]
            },
            {
                "id": 2022927,
                "content": [
                    {
                        "username": "ashishkumar0265aaa",
                        "content": "should have  mentioned that array should be contiguou."
                    },
                    {
                        "username": "ayushkaushik56",
                        "content": "181 test cases passed out of 210. Can anyone tell what is the problem with my code. \\nwhat I did is took the total sum of the array and based on which ever side is less on start or end side reduced it from and sum and compared it to total sum.\\n\\n`class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int start =0 ;\\n        int end = nums.size()-1;\\n        int total = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            total = total + nums[i];\\n        }\\n        int sum = total;\\n        while(start < end){\\n            if(nums[start] < nums[end])\\n            {\\n                sum = sum  - nums[start];\\n                start = start + 1;   \\n            }\\n            else\\n            {\\n                sum = sum - nums[end];\\n                end = end - 1;   \\n            }\\n            if(sum > total)\\n            total = sum;   \\n        }\\n        return total;\\n    }\\n\\n};`"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "nums = [-2,-1]\\n\\nOutput\\n0\\n\\nExpected\\n-1\\n\\nbut why? dont we have to consider empty array i.e 0 if the ans goes to -ve?\\n"
                    },
                    {
                        "username": "AnishDhomase",
                        "content": "Given an integer array nums, find the \\nsubarray .with the largest sum, and return its sum.\\nInorder to find sum we have to consider at least one element whichever is the maximum"
                    },
                    {
                        "username": "HKArcilla",
                        "content": "I think this problem would be better if an empty list ([] where sum = 0) were considered a subarray. It would be more consistent with theoretical understandings of empty strings / arrays."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Coded a O(n) solution with DP but memory limit exceeded... RIP"
                    },
                    {
                        "username": "kekazartsev",
                        "content": "One of your tests possibly incorrect:\\nArray [-1] have 2 sub-arrays:\\n[] and [-1].\\n\\nSo the subarray with maximum sum in []\\nSo max_sub_array([-1]) have to be equal 0.\\n\\n"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "Whoever designed the test cases and time restrictions knew what they were doing cuz damn! The brute force O(n^3) solution and the better O(n^2) solution they both hit TLE and only Kadane\\'s algo worked (thank you leetcode discussion people) \\uD83D\\uDC80"
                    },
                    {
                        "username": "prabal17",
                        "content": "Please help why is it giving wrong answer\\n `int maxSubArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int maxi=INT_MIN;\\n    \\n    for(int i=0;i<n;i++)\\n    {\\n        for(int j=i;j<n;j++)\\n        {\\n            int sum=0;\\n            for(int k=i;k<=j;k++)\\n            {\\n                sum=sum+nums[i];\\n            }\\n            maxi=max(sum,maxi);\\n            sum=0;\\n            \\n        }\\n    }\\n\\n    return maxi;\\n    }.`\\n"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "iterate the array, update the current sum of elements as we iterate, if current sum is greater than max sum, then update the max sum and if at anytime current sum is less than 0 (negative), update current sum to 0"
                    },
                    {
                        "username": "Whitchurch",
                        "content": "I tried memoizing the subarrays , using the subarrays as keys in a dictionary, but that does not seem to be enough to get over the TLE.\\nAny idea how to speed this up further "
                    }
                ]
            },
            {
                "id": 2019956,
                "content": [
                    {
                        "username": "ashishkumar0265aaa",
                        "content": "should have  mentioned that array should be contiguou."
                    },
                    {
                        "username": "ayushkaushik56",
                        "content": "181 test cases passed out of 210. Can anyone tell what is the problem with my code. \\nwhat I did is took the total sum of the array and based on which ever side is less on start or end side reduced it from and sum and compared it to total sum.\\n\\n`class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int start =0 ;\\n        int end = nums.size()-1;\\n        int total = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            total = total + nums[i];\\n        }\\n        int sum = total;\\n        while(start < end){\\n            if(nums[start] < nums[end])\\n            {\\n                sum = sum  - nums[start];\\n                start = start + 1;   \\n            }\\n            else\\n            {\\n                sum = sum - nums[end];\\n                end = end - 1;   \\n            }\\n            if(sum > total)\\n            total = sum;   \\n        }\\n        return total;\\n    }\\n\\n};`"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "nums = [-2,-1]\\n\\nOutput\\n0\\n\\nExpected\\n-1\\n\\nbut why? dont we have to consider empty array i.e 0 if the ans goes to -ve?\\n"
                    },
                    {
                        "username": "AnishDhomase",
                        "content": "Given an integer array nums, find the \\nsubarray .with the largest sum, and return its sum.\\nInorder to find sum we have to consider at least one element whichever is the maximum"
                    },
                    {
                        "username": "HKArcilla",
                        "content": "I think this problem would be better if an empty list ([] where sum = 0) were considered a subarray. It would be more consistent with theoretical understandings of empty strings / arrays."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Coded a O(n) solution with DP but memory limit exceeded... RIP"
                    },
                    {
                        "username": "kekazartsev",
                        "content": "One of your tests possibly incorrect:\\nArray [-1] have 2 sub-arrays:\\n[] and [-1].\\n\\nSo the subarray with maximum sum in []\\nSo max_sub_array([-1]) have to be equal 0.\\n\\n"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "Whoever designed the test cases and time restrictions knew what they were doing cuz damn! The brute force O(n^3) solution and the better O(n^2) solution they both hit TLE and only Kadane\\'s algo worked (thank you leetcode discussion people) \\uD83D\\uDC80"
                    },
                    {
                        "username": "prabal17",
                        "content": "Please help why is it giving wrong answer\\n `int maxSubArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int maxi=INT_MIN;\\n    \\n    for(int i=0;i<n;i++)\\n    {\\n        for(int j=i;j<n;j++)\\n        {\\n            int sum=0;\\n            for(int k=i;k<=j;k++)\\n            {\\n                sum=sum+nums[i];\\n            }\\n            maxi=max(sum,maxi);\\n            sum=0;\\n            \\n        }\\n    }\\n\\n    return maxi;\\n    }.`\\n"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "iterate the array, update the current sum of elements as we iterate, if current sum is greater than max sum, then update the max sum and if at anytime current sum is less than 0 (negative), update current sum to 0"
                    },
                    {
                        "username": "Whitchurch",
                        "content": "I tried memoizing the subarrays , using the subarrays as keys in a dictionary, but that does not seem to be enough to get over the TLE.\\nAny idea how to speed this up further "
                    }
                ]
            },
            {
                "id": 2014770,
                "content": [
                    {
                        "username": "ashishkumar0265aaa",
                        "content": "should have  mentioned that array should be contiguou."
                    },
                    {
                        "username": "ayushkaushik56",
                        "content": "181 test cases passed out of 210. Can anyone tell what is the problem with my code. \\nwhat I did is took the total sum of the array and based on which ever side is less on start or end side reduced it from and sum and compared it to total sum.\\n\\n`class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int start =0 ;\\n        int end = nums.size()-1;\\n        int total = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            total = total + nums[i];\\n        }\\n        int sum = total;\\n        while(start < end){\\n            if(nums[start] < nums[end])\\n            {\\n                sum = sum  - nums[start];\\n                start = start + 1;   \\n            }\\n            else\\n            {\\n                sum = sum - nums[end];\\n                end = end - 1;   \\n            }\\n            if(sum > total)\\n            total = sum;   \\n        }\\n        return total;\\n    }\\n\\n};`"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "nums = [-2,-1]\\n\\nOutput\\n0\\n\\nExpected\\n-1\\n\\nbut why? dont we have to consider empty array i.e 0 if the ans goes to -ve?\\n"
                    },
                    {
                        "username": "AnishDhomase",
                        "content": "Given an integer array nums, find the \\nsubarray .with the largest sum, and return its sum.\\nInorder to find sum we have to consider at least one element whichever is the maximum"
                    },
                    {
                        "username": "HKArcilla",
                        "content": "I think this problem would be better if an empty list ([] where sum = 0) were considered a subarray. It would be more consistent with theoretical understandings of empty strings / arrays."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Coded a O(n) solution with DP but memory limit exceeded... RIP"
                    },
                    {
                        "username": "kekazartsev",
                        "content": "One of your tests possibly incorrect:\\nArray [-1] have 2 sub-arrays:\\n[] and [-1].\\n\\nSo the subarray with maximum sum in []\\nSo max_sub_array([-1]) have to be equal 0.\\n\\n"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "Whoever designed the test cases and time restrictions knew what they were doing cuz damn! The brute force O(n^3) solution and the better O(n^2) solution they both hit TLE and only Kadane\\'s algo worked (thank you leetcode discussion people) \\uD83D\\uDC80"
                    },
                    {
                        "username": "prabal17",
                        "content": "Please help why is it giving wrong answer\\n `int maxSubArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int maxi=INT_MIN;\\n    \\n    for(int i=0;i<n;i++)\\n    {\\n        for(int j=i;j<n;j++)\\n        {\\n            int sum=0;\\n            for(int k=i;k<=j;k++)\\n            {\\n                sum=sum+nums[i];\\n            }\\n            maxi=max(sum,maxi);\\n            sum=0;\\n            \\n        }\\n    }\\n\\n    return maxi;\\n    }.`\\n"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "iterate the array, update the current sum of elements as we iterate, if current sum is greater than max sum, then update the max sum and if at anytime current sum is less than 0 (negative), update current sum to 0"
                    },
                    {
                        "username": "Whitchurch",
                        "content": "I tried memoizing the subarrays , using the subarrays as keys in a dictionary, but that does not seem to be enough to get over the TLE.\\nAny idea how to speed this up further "
                    }
                ]
            },
            {
                "id": 2005635,
                "content": [
                    {
                        "username": "ashishkumar0265aaa",
                        "content": "should have  mentioned that array should be contiguou."
                    },
                    {
                        "username": "ayushkaushik56",
                        "content": "181 test cases passed out of 210. Can anyone tell what is the problem with my code. \\nwhat I did is took the total sum of the array and based on which ever side is less on start or end side reduced it from and sum and compared it to total sum.\\n\\n`class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int start =0 ;\\n        int end = nums.size()-1;\\n        int total = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            total = total + nums[i];\\n        }\\n        int sum = total;\\n        while(start < end){\\n            if(nums[start] < nums[end])\\n            {\\n                sum = sum  - nums[start];\\n                start = start + 1;   \\n            }\\n            else\\n            {\\n                sum = sum - nums[end];\\n                end = end - 1;   \\n            }\\n            if(sum > total)\\n            total = sum;   \\n        }\\n        return total;\\n    }\\n\\n};`"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "nums = [-2,-1]\\n\\nOutput\\n0\\n\\nExpected\\n-1\\n\\nbut why? dont we have to consider empty array i.e 0 if the ans goes to -ve?\\n"
                    },
                    {
                        "username": "AnishDhomase",
                        "content": "Given an integer array nums, find the \\nsubarray .with the largest sum, and return its sum.\\nInorder to find sum we have to consider at least one element whichever is the maximum"
                    },
                    {
                        "username": "HKArcilla",
                        "content": "I think this problem would be better if an empty list ([] where sum = 0) were considered a subarray. It would be more consistent with theoretical understandings of empty strings / arrays."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Coded a O(n) solution with DP but memory limit exceeded... RIP"
                    },
                    {
                        "username": "kekazartsev",
                        "content": "One of your tests possibly incorrect:\\nArray [-1] have 2 sub-arrays:\\n[] and [-1].\\n\\nSo the subarray with maximum sum in []\\nSo max_sub_array([-1]) have to be equal 0.\\n\\n"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "Whoever designed the test cases and time restrictions knew what they were doing cuz damn! The brute force O(n^3) solution and the better O(n^2) solution they both hit TLE and only Kadane\\'s algo worked (thank you leetcode discussion people) \\uD83D\\uDC80"
                    },
                    {
                        "username": "prabal17",
                        "content": "Please help why is it giving wrong answer\\n `int maxSubArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int maxi=INT_MIN;\\n    \\n    for(int i=0;i<n;i++)\\n    {\\n        for(int j=i;j<n;j++)\\n        {\\n            int sum=0;\\n            for(int k=i;k<=j;k++)\\n            {\\n                sum=sum+nums[i];\\n            }\\n            maxi=max(sum,maxi);\\n            sum=0;\\n            \\n        }\\n    }\\n\\n    return maxi;\\n    }.`\\n"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "iterate the array, update the current sum of elements as we iterate, if current sum is greater than max sum, then update the max sum and if at anytime current sum is less than 0 (negative), update current sum to 0"
                    },
                    {
                        "username": "Whitchurch",
                        "content": "I tried memoizing the subarrays , using the subarrays as keys in a dictionary, but that does not seem to be enough to get over the TLE.\\nAny idea how to speed this up further "
                    }
                ]
            },
            {
                "id": 1995170,
                "content": [
                    {
                        "username": "ashishkumar0265aaa",
                        "content": "should have  mentioned that array should be contiguou."
                    },
                    {
                        "username": "ayushkaushik56",
                        "content": "181 test cases passed out of 210. Can anyone tell what is the problem with my code. \\nwhat I did is took the total sum of the array and based on which ever side is less on start or end side reduced it from and sum and compared it to total sum.\\n\\n`class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int start =0 ;\\n        int end = nums.size()-1;\\n        int total = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            total = total + nums[i];\\n        }\\n        int sum = total;\\n        while(start < end){\\n            if(nums[start] < nums[end])\\n            {\\n                sum = sum  - nums[start];\\n                start = start + 1;   \\n            }\\n            else\\n            {\\n                sum = sum - nums[end];\\n                end = end - 1;   \\n            }\\n            if(sum > total)\\n            total = sum;   \\n        }\\n        return total;\\n    }\\n\\n};`"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "nums = [-2,-1]\\n\\nOutput\\n0\\n\\nExpected\\n-1\\n\\nbut why? dont we have to consider empty array i.e 0 if the ans goes to -ve?\\n"
                    },
                    {
                        "username": "AnishDhomase",
                        "content": "Given an integer array nums, find the \\nsubarray .with the largest sum, and return its sum.\\nInorder to find sum we have to consider at least one element whichever is the maximum"
                    },
                    {
                        "username": "HKArcilla",
                        "content": "I think this problem would be better if an empty list ([] where sum = 0) were considered a subarray. It would be more consistent with theoretical understandings of empty strings / arrays."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Coded a O(n) solution with DP but memory limit exceeded... RIP"
                    },
                    {
                        "username": "kekazartsev",
                        "content": "One of your tests possibly incorrect:\\nArray [-1] have 2 sub-arrays:\\n[] and [-1].\\n\\nSo the subarray with maximum sum in []\\nSo max_sub_array([-1]) have to be equal 0.\\n\\n"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "Whoever designed the test cases and time restrictions knew what they were doing cuz damn! The brute force O(n^3) solution and the better O(n^2) solution they both hit TLE and only Kadane\\'s algo worked (thank you leetcode discussion people) \\uD83D\\uDC80"
                    },
                    {
                        "username": "prabal17",
                        "content": "Please help why is it giving wrong answer\\n `int maxSubArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int maxi=INT_MIN;\\n    \\n    for(int i=0;i<n;i++)\\n    {\\n        for(int j=i;j<n;j++)\\n        {\\n            int sum=0;\\n            for(int k=i;k<=j;k++)\\n            {\\n                sum=sum+nums[i];\\n            }\\n            maxi=max(sum,maxi);\\n            sum=0;\\n            \\n        }\\n    }\\n\\n    return maxi;\\n    }.`\\n"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "iterate the array, update the current sum of elements as we iterate, if current sum is greater than max sum, then update the max sum and if at anytime current sum is less than 0 (negative), update current sum to 0"
                    },
                    {
                        "username": "Whitchurch",
                        "content": "I tried memoizing the subarrays , using the subarrays as keys in a dictionary, but that does not seem to be enough to get over the TLE.\\nAny idea how to speed this up further "
                    }
                ]
            },
            {
                "id": 1990559,
                "content": [
                    {
                        "username": "ashishkumar0265aaa",
                        "content": "should have  mentioned that array should be contiguou."
                    },
                    {
                        "username": "ayushkaushik56",
                        "content": "181 test cases passed out of 210. Can anyone tell what is the problem with my code. \\nwhat I did is took the total sum of the array and based on which ever side is less on start or end side reduced it from and sum and compared it to total sum.\\n\\n`class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int start =0 ;\\n        int end = nums.size()-1;\\n        int total = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            total = total + nums[i];\\n        }\\n        int sum = total;\\n        while(start < end){\\n            if(nums[start] < nums[end])\\n            {\\n                sum = sum  - nums[start];\\n                start = start + 1;   \\n            }\\n            else\\n            {\\n                sum = sum - nums[end];\\n                end = end - 1;   \\n            }\\n            if(sum > total)\\n            total = sum;   \\n        }\\n        return total;\\n    }\\n\\n};`"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "nums = [-2,-1]\\n\\nOutput\\n0\\n\\nExpected\\n-1\\n\\nbut why? dont we have to consider empty array i.e 0 if the ans goes to -ve?\\n"
                    },
                    {
                        "username": "AnishDhomase",
                        "content": "Given an integer array nums, find the \\nsubarray .with the largest sum, and return its sum.\\nInorder to find sum we have to consider at least one element whichever is the maximum"
                    },
                    {
                        "username": "HKArcilla",
                        "content": "I think this problem would be better if an empty list ([] where sum = 0) were considered a subarray. It would be more consistent with theoretical understandings of empty strings / arrays."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Coded a O(n) solution with DP but memory limit exceeded... RIP"
                    },
                    {
                        "username": "kekazartsev",
                        "content": "One of your tests possibly incorrect:\\nArray [-1] have 2 sub-arrays:\\n[] and [-1].\\n\\nSo the subarray with maximum sum in []\\nSo max_sub_array([-1]) have to be equal 0.\\n\\n"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "Whoever designed the test cases and time restrictions knew what they were doing cuz damn! The brute force O(n^3) solution and the better O(n^2) solution they both hit TLE and only Kadane\\'s algo worked (thank you leetcode discussion people) \\uD83D\\uDC80"
                    },
                    {
                        "username": "prabal17",
                        "content": "Please help why is it giving wrong answer\\n `int maxSubArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int maxi=INT_MIN;\\n    \\n    for(int i=0;i<n;i++)\\n    {\\n        for(int j=i;j<n;j++)\\n        {\\n            int sum=0;\\n            for(int k=i;k<=j;k++)\\n            {\\n                sum=sum+nums[i];\\n            }\\n            maxi=max(sum,maxi);\\n            sum=0;\\n            \\n        }\\n    }\\n\\n    return maxi;\\n    }.`\\n"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "iterate the array, update the current sum of elements as we iterate, if current sum is greater than max sum, then update the max sum and if at anytime current sum is less than 0 (negative), update current sum to 0"
                    },
                    {
                        "username": "Whitchurch",
                        "content": "I tried memoizing the subarrays , using the subarrays as keys in a dictionary, but that does not seem to be enough to get over the TLE.\\nAny idea how to speed this up further "
                    }
                ]
            },
            {
                "id": 1990207,
                "content": [
                    {
                        "username": "ashishkumar0265aaa",
                        "content": "should have  mentioned that array should be contiguou."
                    },
                    {
                        "username": "ayushkaushik56",
                        "content": "181 test cases passed out of 210. Can anyone tell what is the problem with my code. \\nwhat I did is took the total sum of the array and based on which ever side is less on start or end side reduced it from and sum and compared it to total sum.\\n\\n`class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int start =0 ;\\n        int end = nums.size()-1;\\n        int total = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            total = total + nums[i];\\n        }\\n        int sum = total;\\n        while(start < end){\\n            if(nums[start] < nums[end])\\n            {\\n                sum = sum  - nums[start];\\n                start = start + 1;   \\n            }\\n            else\\n            {\\n                sum = sum - nums[end];\\n                end = end - 1;   \\n            }\\n            if(sum > total)\\n            total = sum;   \\n        }\\n        return total;\\n    }\\n\\n};`"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "nums = [-2,-1]\\n\\nOutput\\n0\\n\\nExpected\\n-1\\n\\nbut why? dont we have to consider empty array i.e 0 if the ans goes to -ve?\\n"
                    },
                    {
                        "username": "AnishDhomase",
                        "content": "Given an integer array nums, find the \\nsubarray .with the largest sum, and return its sum.\\nInorder to find sum we have to consider at least one element whichever is the maximum"
                    },
                    {
                        "username": "HKArcilla",
                        "content": "I think this problem would be better if an empty list ([] where sum = 0) were considered a subarray. It would be more consistent with theoretical understandings of empty strings / arrays."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Coded a O(n) solution with DP but memory limit exceeded... RIP"
                    },
                    {
                        "username": "kekazartsev",
                        "content": "One of your tests possibly incorrect:\\nArray [-1] have 2 sub-arrays:\\n[] and [-1].\\n\\nSo the subarray with maximum sum in []\\nSo max_sub_array([-1]) have to be equal 0.\\n\\n"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "Whoever designed the test cases and time restrictions knew what they were doing cuz damn! The brute force O(n^3) solution and the better O(n^2) solution they both hit TLE and only Kadane\\'s algo worked (thank you leetcode discussion people) \\uD83D\\uDC80"
                    },
                    {
                        "username": "prabal17",
                        "content": "Please help why is it giving wrong answer\\n `int maxSubArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int maxi=INT_MIN;\\n    \\n    for(int i=0;i<n;i++)\\n    {\\n        for(int j=i;j<n;j++)\\n        {\\n            int sum=0;\\n            for(int k=i;k<=j;k++)\\n            {\\n                sum=sum+nums[i];\\n            }\\n            maxi=max(sum,maxi);\\n            sum=0;\\n            \\n        }\\n    }\\n\\n    return maxi;\\n    }.`\\n"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "iterate the array, update the current sum of elements as we iterate, if current sum is greater than max sum, then update the max sum and if at anytime current sum is less than 0 (negative), update current sum to 0"
                    },
                    {
                        "username": "Whitchurch",
                        "content": "I tried memoizing the subarrays , using the subarrays as keys in a dictionary, but that does not seem to be enough to get over the TLE.\\nAny idea how to speed this up further "
                    }
                ]
            },
            {
                "id": 1980794,
                "content": [
                    {
                        "username": "ashishkumar0265aaa",
                        "content": "should have  mentioned that array should be contiguou."
                    },
                    {
                        "username": "ayushkaushik56",
                        "content": "181 test cases passed out of 210. Can anyone tell what is the problem with my code. \\nwhat I did is took the total sum of the array and based on which ever side is less on start or end side reduced it from and sum and compared it to total sum.\\n\\n`class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int start =0 ;\\n        int end = nums.size()-1;\\n        int total = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            total = total + nums[i];\\n        }\\n        int sum = total;\\n        while(start < end){\\n            if(nums[start] < nums[end])\\n            {\\n                sum = sum  - nums[start];\\n                start = start + 1;   \\n            }\\n            else\\n            {\\n                sum = sum - nums[end];\\n                end = end - 1;   \\n            }\\n            if(sum > total)\\n            total = sum;   \\n        }\\n        return total;\\n    }\\n\\n};`"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "nums = [-2,-1]\\n\\nOutput\\n0\\n\\nExpected\\n-1\\n\\nbut why? dont we have to consider empty array i.e 0 if the ans goes to -ve?\\n"
                    },
                    {
                        "username": "AnishDhomase",
                        "content": "Given an integer array nums, find the \\nsubarray .with the largest sum, and return its sum.\\nInorder to find sum we have to consider at least one element whichever is the maximum"
                    },
                    {
                        "username": "HKArcilla",
                        "content": "I think this problem would be better if an empty list ([] where sum = 0) were considered a subarray. It would be more consistent with theoretical understandings of empty strings / arrays."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Coded a O(n) solution with DP but memory limit exceeded... RIP"
                    },
                    {
                        "username": "kekazartsev",
                        "content": "One of your tests possibly incorrect:\\nArray [-1] have 2 sub-arrays:\\n[] and [-1].\\n\\nSo the subarray with maximum sum in []\\nSo max_sub_array([-1]) have to be equal 0.\\n\\n"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "Whoever designed the test cases and time restrictions knew what they were doing cuz damn! The brute force O(n^3) solution and the better O(n^2) solution they both hit TLE and only Kadane\\'s algo worked (thank you leetcode discussion people) \\uD83D\\uDC80"
                    },
                    {
                        "username": "prabal17",
                        "content": "Please help why is it giving wrong answer\\n `int maxSubArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int maxi=INT_MIN;\\n    \\n    for(int i=0;i<n;i++)\\n    {\\n        for(int j=i;j<n;j++)\\n        {\\n            int sum=0;\\n            for(int k=i;k<=j;k++)\\n            {\\n                sum=sum+nums[i];\\n            }\\n            maxi=max(sum,maxi);\\n            sum=0;\\n            \\n        }\\n    }\\n\\n    return maxi;\\n    }.`\\n"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "iterate the array, update the current sum of elements as we iterate, if current sum is greater than max sum, then update the max sum and if at anytime current sum is less than 0 (negative), update current sum to 0"
                    },
                    {
                        "username": "Whitchurch",
                        "content": "I tried memoizing the subarrays , using the subarrays as keys in a dictionary, but that does not seem to be enough to get over the TLE.\\nAny idea how to speed this up further "
                    }
                ]
            },
            {
                "id": 1974176,
                "content": [
                    {
                        "username": "ashishkumar0265aaa",
                        "content": "should have  mentioned that array should be contiguou."
                    },
                    {
                        "username": "ayushkaushik56",
                        "content": "181 test cases passed out of 210. Can anyone tell what is the problem with my code. \\nwhat I did is took the total sum of the array and based on which ever side is less on start or end side reduced it from and sum and compared it to total sum.\\n\\n`class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int start =0 ;\\n        int end = nums.size()-1;\\n        int total = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            total = total + nums[i];\\n        }\\n        int sum = total;\\n        while(start < end){\\n            if(nums[start] < nums[end])\\n            {\\n                sum = sum  - nums[start];\\n                start = start + 1;   \\n            }\\n            else\\n            {\\n                sum = sum - nums[end];\\n                end = end - 1;   \\n            }\\n            if(sum > total)\\n            total = sum;   \\n        }\\n        return total;\\n    }\\n\\n};`"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "nums = [-2,-1]\\n\\nOutput\\n0\\n\\nExpected\\n-1\\n\\nbut why? dont we have to consider empty array i.e 0 if the ans goes to -ve?\\n"
                    },
                    {
                        "username": "AnishDhomase",
                        "content": "Given an integer array nums, find the \\nsubarray .with the largest sum, and return its sum.\\nInorder to find sum we have to consider at least one element whichever is the maximum"
                    },
                    {
                        "username": "HKArcilla",
                        "content": "I think this problem would be better if an empty list ([] where sum = 0) were considered a subarray. It would be more consistent with theoretical understandings of empty strings / arrays."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Coded a O(n) solution with DP but memory limit exceeded... RIP"
                    },
                    {
                        "username": "kekazartsev",
                        "content": "One of your tests possibly incorrect:\\nArray [-1] have 2 sub-arrays:\\n[] and [-1].\\n\\nSo the subarray with maximum sum in []\\nSo max_sub_array([-1]) have to be equal 0.\\n\\n"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "Whoever designed the test cases and time restrictions knew what they were doing cuz damn! The brute force O(n^3) solution and the better O(n^2) solution they both hit TLE and only Kadane\\'s algo worked (thank you leetcode discussion people) \\uD83D\\uDC80"
                    },
                    {
                        "username": "prabal17",
                        "content": "Please help why is it giving wrong answer\\n `int maxSubArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int maxi=INT_MIN;\\n    \\n    for(int i=0;i<n;i++)\\n    {\\n        for(int j=i;j<n;j++)\\n        {\\n            int sum=0;\\n            for(int k=i;k<=j;k++)\\n            {\\n                sum=sum+nums[i];\\n            }\\n            maxi=max(sum,maxi);\\n            sum=0;\\n            \\n        }\\n    }\\n\\n    return maxi;\\n    }.`\\n"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "iterate the array, update the current sum of elements as we iterate, if current sum is greater than max sum, then update the max sum and if at anytime current sum is less than 0 (negative), update current sum to 0"
                    },
                    {
                        "username": "Whitchurch",
                        "content": "I tried memoizing the subarrays , using the subarrays as keys in a dictionary, but that does not seem to be enough to get over the TLE.\\nAny idea how to speed this up further "
                    }
                ]
            },
            {
                "id": 1968762,
                "content": [
                    {
                        "username": "ashishkumar0265aaa",
                        "content": "should have  mentioned that array should be contiguou."
                    },
                    {
                        "username": "ayushkaushik56",
                        "content": "181 test cases passed out of 210. Can anyone tell what is the problem with my code. \\nwhat I did is took the total sum of the array and based on which ever side is less on start or end side reduced it from and sum and compared it to total sum.\\n\\n`class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int start =0 ;\\n        int end = nums.size()-1;\\n        int total = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            total = total + nums[i];\\n        }\\n        int sum = total;\\n        while(start < end){\\n            if(nums[start] < nums[end])\\n            {\\n                sum = sum  - nums[start];\\n                start = start + 1;   \\n            }\\n            else\\n            {\\n                sum = sum - nums[end];\\n                end = end - 1;   \\n            }\\n            if(sum > total)\\n            total = sum;   \\n        }\\n        return total;\\n    }\\n\\n};`"
                    },
                    {
                        "username": "Ajay_Prabhu",
                        "content": "nums = [-2,-1]\\n\\nOutput\\n0\\n\\nExpected\\n-1\\n\\nbut why? dont we have to consider empty array i.e 0 if the ans goes to -ve?\\n"
                    },
                    {
                        "username": "AnishDhomase",
                        "content": "Given an integer array nums, find the \\nsubarray .with the largest sum, and return its sum.\\nInorder to find sum we have to consider at least one element whichever is the maximum"
                    },
                    {
                        "username": "HKArcilla",
                        "content": "I think this problem would be better if an empty list ([] where sum = 0) were considered a subarray. It would be more consistent with theoretical understandings of empty strings / arrays."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Coded a O(n) solution with DP but memory limit exceeded... RIP"
                    },
                    {
                        "username": "kekazartsev",
                        "content": "One of your tests possibly incorrect:\\nArray [-1] have 2 sub-arrays:\\n[] and [-1].\\n\\nSo the subarray with maximum sum in []\\nSo max_sub_array([-1]) have to be equal 0.\\n\\n"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "Whoever designed the test cases and time restrictions knew what they were doing cuz damn! The brute force O(n^3) solution and the better O(n^2) solution they both hit TLE and only Kadane\\'s algo worked (thank you leetcode discussion people) \\uD83D\\uDC80"
                    },
                    {
                        "username": "prabal17",
                        "content": "Please help why is it giving wrong answer\\n `int maxSubArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int maxi=INT_MIN;\\n    \\n    for(int i=0;i<n;i++)\\n    {\\n        for(int j=i;j<n;j++)\\n        {\\n            int sum=0;\\n            for(int k=i;k<=j;k++)\\n            {\\n                sum=sum+nums[i];\\n            }\\n            maxi=max(sum,maxi);\\n            sum=0;\\n            \\n        }\\n    }\\n\\n    return maxi;\\n    }.`\\n"
                    },
                    {
                        "username": "Radhika_20",
                        "content": "iterate the array, update the current sum of elements as we iterate, if current sum is greater than max sum, then update the max sum and if at anytime current sum is less than 0 (negative), update current sum to 0"
                    },
                    {
                        "username": "Whitchurch",
                        "content": "I tried memoizing the subarrays , using the subarrays as keys in a dictionary, but that does not seem to be enough to get over the TLE.\\nAny idea how to speed this up further "
                    }
                ]
            },
            {
                "id": 1961672,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 very important algorithm (kadane\\'s) \\n\\uD83D\\uDFE2 it seems difficult at first look but once you give it a genuine try and understand the essence of of the algo then it will be a cake walk for you"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "One of the ways to solve this problem is sliding window ,\nKeep on adding elements starting from left, whenever the sum becomes negative start removing elements from the beginning until it becomes non negative again. \nreturn the max of all these sums.  \n\nDetailed solution: \n[https://leetcode.com/problems/maximum-subarray/solutions/3704593/easy-solution-using-sliding-window/](https://leetcode.com/problems/maximum-subarray/solutions/3704593/easy-solution-using-sliding-window/)"
                    },
                    {
                        "username": "bparanj",
                        "content": "Kadane\\'s algorithm is simpler and more straightforward, making it easier to understand and debug. The sliding window variation adds an additional layer of complexity with the sliding window management which might make it slightly harder to grasp initially."
                    },
                    {
                        "username": "LunaeNova",
                        "content": "This is much more of an Algorithms question than a Data Structures question."
                    },
                    {
                        "username": "HeatOn123",
                        "content": "well my algorithm worked without considering individual elements as separate subarrays, now just need to edit that by moving my initial variable to the element that\\'s the largest....(F this)"
                    },
                    {
                        "username": "akshr228",
                        "content": "I thought of a different algorithm for this problem. After seeing Kadane\\'s algorithm I feel foolish men of myself.  However , We can connect in social Media . FB: https://www.facebook.com/profile.php?id=100087367675784 . "
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Make it easy one with \"Kadane\\'s Algorithm\"."
                    },
                    {
                        "username": "TK0510",
                        "content": "The best solution is using KADANE\\'s algorithm and the Tc is O(n)."
                    },
                    {
                        "username": "fafalachu",
                        "content": "I have some problem with golang when I use container.list. \nIn the 100000 length of data test case, it always show \"Time Limit Exceeded\", but running at my mac  just show about 12ms and completed.\nI don't know what's wrong ?"
                    },
                    {
                        "username": "imbikramsaha",
                        "content": "class Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        current_sum = max_sum = nums[0]  # Initialize both current_sum and max_sum with the first element\\n\\n        for num in nums[1:]:  # Start iterating from the second element\\n            current_sum = max(num, current_sum + num)  # Calculate the maximum between the current number and the sum of the current number and the previous subarray\\n            max_sum = max(max_sum, current_sum)  # Update the maximum sum if the current sum is greater\\n\\n        return max_sum"
                    },
                    {
                        "username": "akshatanand186",
                        "content": "I tried submitting the divide and conquer approach which has complexity O(nlogn), but it is giving me TLE. Is it because my code has errors or?\nclass Solution {\npublic:\n    int callsum(int i, int j, vector<int>&nums){\n        // debug2(i,j);\n        if(i>j) return -1e9;\n        if(i==j) return nums[i];\n        int mid = (i+j)/2;\n        int z=0;\n        int maxm = -1e9;\n        for(int k=mid;k>=0;k--) z+= nums[k],maxm = max(z,maxm);\n        z = 0;\n        int hi = maxm;\n        for(int k=mid+1;k<nums.size();k++) z+= nums[k], maxm = max(z+hi,maxm);  \n        int x = callsum(i,mid,nums);\n        int y = callsum(mid+1,j,nums); \n        return max({x,y,maxm});\n    }\n    int maxSubArray(vector<int>& nums) {\n        return callsum(0,nums.size()-1,nums);\n    }\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code looks fine for the divide-and-conquer approach. It\\'s true that the divide-and-conquer approach has a time complexity of O(n log n), which is higher than the O(n) time complexity of Kadane\\'s algorithm. \\n\\nHowever, \"Time Limit Exceeded\" (TLE) errors often indicate that your code may be doing unnecessary work or has an inefficient implementation that causes it to take longer than the maximum allowed time. \\n\\nThere are a few things that could potentially be improved in your code:\\n\\n1. Recursion overhead: While recursion can make the code more readable, it does add overhead, especially in languages like C++.\\n\\n2. Unnecessary computations: The loops from `mid` to `0` and `mid+1` to `nums.size()` will go out of the bounds of the current subarray when the subarray size is small, resulting in unnecessary computation.\\n\\n3. Multiple calls to `max` function: You can store the maximums in variables to reduce the number of calls to the `max` function.\\n\\nOne more thing to consider, some online coding platforms could have tighter time limits, and algorithms with higher time complexity, even if correctly implemented, might still exceed the time limit. So the divide-and-conquer approach might still not pass even after optimizing the above points.\\n\\nAlso remember, it\\'s common practice in coding interviews to discuss the time complexity of your solution. If your interviewer asks for a more efficient solution, that\\'s your cue to discuss or implement the O(n) Kadane\\'s algorithm."
                    }
                ]
            },
            {
                "id": 1951753,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 very important algorithm (kadane\\'s) \\n\\uD83D\\uDFE2 it seems difficult at first look but once you give it a genuine try and understand the essence of of the algo then it will be a cake walk for you"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "One of the ways to solve this problem is sliding window ,\nKeep on adding elements starting from left, whenever the sum becomes negative start removing elements from the beginning until it becomes non negative again. \nreturn the max of all these sums.  \n\nDetailed solution: \n[https://leetcode.com/problems/maximum-subarray/solutions/3704593/easy-solution-using-sliding-window/](https://leetcode.com/problems/maximum-subarray/solutions/3704593/easy-solution-using-sliding-window/)"
                    },
                    {
                        "username": "bparanj",
                        "content": "Kadane\\'s algorithm is simpler and more straightforward, making it easier to understand and debug. The sliding window variation adds an additional layer of complexity with the sliding window management which might make it slightly harder to grasp initially."
                    },
                    {
                        "username": "LunaeNova",
                        "content": "This is much more of an Algorithms question than a Data Structures question."
                    },
                    {
                        "username": "HeatOn123",
                        "content": "well my algorithm worked without considering individual elements as separate subarrays, now just need to edit that by moving my initial variable to the element that\\'s the largest....(F this)"
                    },
                    {
                        "username": "akshr228",
                        "content": "I thought of a different algorithm for this problem. After seeing Kadane\\'s algorithm I feel foolish men of myself.  However , We can connect in social Media . FB: https://www.facebook.com/profile.php?id=100087367675784 . "
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Make it easy one with \"Kadane\\'s Algorithm\"."
                    },
                    {
                        "username": "TK0510",
                        "content": "The best solution is using KADANE\\'s algorithm and the Tc is O(n)."
                    },
                    {
                        "username": "fafalachu",
                        "content": "I have some problem with golang when I use container.list. \nIn the 100000 length of data test case, it always show \"Time Limit Exceeded\", but running at my mac  just show about 12ms and completed.\nI don't know what's wrong ?"
                    },
                    {
                        "username": "imbikramsaha",
                        "content": "class Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        current_sum = max_sum = nums[0]  # Initialize both current_sum and max_sum with the first element\\n\\n        for num in nums[1:]:  # Start iterating from the second element\\n            current_sum = max(num, current_sum + num)  # Calculate the maximum between the current number and the sum of the current number and the previous subarray\\n            max_sum = max(max_sum, current_sum)  # Update the maximum sum if the current sum is greater\\n\\n        return max_sum"
                    },
                    {
                        "username": "akshatanand186",
                        "content": "I tried submitting the divide and conquer approach which has complexity O(nlogn), but it is giving me TLE. Is it because my code has errors or?\nclass Solution {\npublic:\n    int callsum(int i, int j, vector<int>&nums){\n        // debug2(i,j);\n        if(i>j) return -1e9;\n        if(i==j) return nums[i];\n        int mid = (i+j)/2;\n        int z=0;\n        int maxm = -1e9;\n        for(int k=mid;k>=0;k--) z+= nums[k],maxm = max(z,maxm);\n        z = 0;\n        int hi = maxm;\n        for(int k=mid+1;k<nums.size();k++) z+= nums[k], maxm = max(z+hi,maxm);  \n        int x = callsum(i,mid,nums);\n        int y = callsum(mid+1,j,nums); \n        return max({x,y,maxm});\n    }\n    int maxSubArray(vector<int>& nums) {\n        return callsum(0,nums.size()-1,nums);\n    }\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code looks fine for the divide-and-conquer approach. It\\'s true that the divide-and-conquer approach has a time complexity of O(n log n), which is higher than the O(n) time complexity of Kadane\\'s algorithm. \\n\\nHowever, \"Time Limit Exceeded\" (TLE) errors often indicate that your code may be doing unnecessary work or has an inefficient implementation that causes it to take longer than the maximum allowed time. \\n\\nThere are a few things that could potentially be improved in your code:\\n\\n1. Recursion overhead: While recursion can make the code more readable, it does add overhead, especially in languages like C++.\\n\\n2. Unnecessary computations: The loops from `mid` to `0` and `mid+1` to `nums.size()` will go out of the bounds of the current subarray when the subarray size is small, resulting in unnecessary computation.\\n\\n3. Multiple calls to `max` function: You can store the maximums in variables to reduce the number of calls to the `max` function.\\n\\nOne more thing to consider, some online coding platforms could have tighter time limits, and algorithms with higher time complexity, even if correctly implemented, might still exceed the time limit. So the divide-and-conquer approach might still not pass even after optimizing the above points.\\n\\nAlso remember, it\\'s common practice in coding interviews to discuss the time complexity of your solution. If your interviewer asks for a more efficient solution, that\\'s your cue to discuss or implement the O(n) Kadane\\'s algorithm."
                    }
                ]
            },
            {
                "id": 1940352,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 very important algorithm (kadane\\'s) \\n\\uD83D\\uDFE2 it seems difficult at first look but once you give it a genuine try and understand the essence of of the algo then it will be a cake walk for you"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "One of the ways to solve this problem is sliding window ,\nKeep on adding elements starting from left, whenever the sum becomes negative start removing elements from the beginning until it becomes non negative again. \nreturn the max of all these sums.  \n\nDetailed solution: \n[https://leetcode.com/problems/maximum-subarray/solutions/3704593/easy-solution-using-sliding-window/](https://leetcode.com/problems/maximum-subarray/solutions/3704593/easy-solution-using-sliding-window/)"
                    },
                    {
                        "username": "bparanj",
                        "content": "Kadane\\'s algorithm is simpler and more straightforward, making it easier to understand and debug. The sliding window variation adds an additional layer of complexity with the sliding window management which might make it slightly harder to grasp initially."
                    },
                    {
                        "username": "LunaeNova",
                        "content": "This is much more of an Algorithms question than a Data Structures question."
                    },
                    {
                        "username": "HeatOn123",
                        "content": "well my algorithm worked without considering individual elements as separate subarrays, now just need to edit that by moving my initial variable to the element that\\'s the largest....(F this)"
                    },
                    {
                        "username": "akshr228",
                        "content": "I thought of a different algorithm for this problem. After seeing Kadane\\'s algorithm I feel foolish men of myself.  However , We can connect in social Media . FB: https://www.facebook.com/profile.php?id=100087367675784 . "
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Make it easy one with \"Kadane\\'s Algorithm\"."
                    },
                    {
                        "username": "TK0510",
                        "content": "The best solution is using KADANE\\'s algorithm and the Tc is O(n)."
                    },
                    {
                        "username": "fafalachu",
                        "content": "I have some problem with golang when I use container.list. \nIn the 100000 length of data test case, it always show \"Time Limit Exceeded\", but running at my mac  just show about 12ms and completed.\nI don't know what's wrong ?"
                    },
                    {
                        "username": "imbikramsaha",
                        "content": "class Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        current_sum = max_sum = nums[0]  # Initialize both current_sum and max_sum with the first element\\n\\n        for num in nums[1:]:  # Start iterating from the second element\\n            current_sum = max(num, current_sum + num)  # Calculate the maximum between the current number and the sum of the current number and the previous subarray\\n            max_sum = max(max_sum, current_sum)  # Update the maximum sum if the current sum is greater\\n\\n        return max_sum"
                    },
                    {
                        "username": "akshatanand186",
                        "content": "I tried submitting the divide and conquer approach which has complexity O(nlogn), but it is giving me TLE. Is it because my code has errors or?\nclass Solution {\npublic:\n    int callsum(int i, int j, vector<int>&nums){\n        // debug2(i,j);\n        if(i>j) return -1e9;\n        if(i==j) return nums[i];\n        int mid = (i+j)/2;\n        int z=0;\n        int maxm = -1e9;\n        for(int k=mid;k>=0;k--) z+= nums[k],maxm = max(z,maxm);\n        z = 0;\n        int hi = maxm;\n        for(int k=mid+1;k<nums.size();k++) z+= nums[k], maxm = max(z+hi,maxm);  \n        int x = callsum(i,mid,nums);\n        int y = callsum(mid+1,j,nums); \n        return max({x,y,maxm});\n    }\n    int maxSubArray(vector<int>& nums) {\n        return callsum(0,nums.size()-1,nums);\n    }\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code looks fine for the divide-and-conquer approach. It\\'s true that the divide-and-conquer approach has a time complexity of O(n log n), which is higher than the O(n) time complexity of Kadane\\'s algorithm. \\n\\nHowever, \"Time Limit Exceeded\" (TLE) errors often indicate that your code may be doing unnecessary work or has an inefficient implementation that causes it to take longer than the maximum allowed time. \\n\\nThere are a few things that could potentially be improved in your code:\\n\\n1. Recursion overhead: While recursion can make the code more readable, it does add overhead, especially in languages like C++.\\n\\n2. Unnecessary computations: The loops from `mid` to `0` and `mid+1` to `nums.size()` will go out of the bounds of the current subarray when the subarray size is small, resulting in unnecessary computation.\\n\\n3. Multiple calls to `max` function: You can store the maximums in variables to reduce the number of calls to the `max` function.\\n\\nOne more thing to consider, some online coding platforms could have tighter time limits, and algorithms with higher time complexity, even if correctly implemented, might still exceed the time limit. So the divide-and-conquer approach might still not pass even after optimizing the above points.\\n\\nAlso remember, it\\'s common practice in coding interviews to discuss the time complexity of your solution. If your interviewer asks for a more efficient solution, that\\'s your cue to discuss or implement the O(n) Kadane\\'s algorithm."
                    }
                ]
            },
            {
                "id": 1935176,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 very important algorithm (kadane\\'s) \\n\\uD83D\\uDFE2 it seems difficult at first look but once you give it a genuine try and understand the essence of of the algo then it will be a cake walk for you"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "One of the ways to solve this problem is sliding window ,\nKeep on adding elements starting from left, whenever the sum becomes negative start removing elements from the beginning until it becomes non negative again. \nreturn the max of all these sums.  \n\nDetailed solution: \n[https://leetcode.com/problems/maximum-subarray/solutions/3704593/easy-solution-using-sliding-window/](https://leetcode.com/problems/maximum-subarray/solutions/3704593/easy-solution-using-sliding-window/)"
                    },
                    {
                        "username": "bparanj",
                        "content": "Kadane\\'s algorithm is simpler and more straightforward, making it easier to understand and debug. The sliding window variation adds an additional layer of complexity with the sliding window management which might make it slightly harder to grasp initially."
                    },
                    {
                        "username": "LunaeNova",
                        "content": "This is much more of an Algorithms question than a Data Structures question."
                    },
                    {
                        "username": "HeatOn123",
                        "content": "well my algorithm worked without considering individual elements as separate subarrays, now just need to edit that by moving my initial variable to the element that\\'s the largest....(F this)"
                    },
                    {
                        "username": "akshr228",
                        "content": "I thought of a different algorithm for this problem. After seeing Kadane\\'s algorithm I feel foolish men of myself.  However , We can connect in social Media . FB: https://www.facebook.com/profile.php?id=100087367675784 . "
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Make it easy one with \"Kadane\\'s Algorithm\"."
                    },
                    {
                        "username": "TK0510",
                        "content": "The best solution is using KADANE\\'s algorithm and the Tc is O(n)."
                    },
                    {
                        "username": "fafalachu",
                        "content": "I have some problem with golang when I use container.list. \nIn the 100000 length of data test case, it always show \"Time Limit Exceeded\", but running at my mac  just show about 12ms and completed.\nI don't know what's wrong ?"
                    },
                    {
                        "username": "imbikramsaha",
                        "content": "class Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        current_sum = max_sum = nums[0]  # Initialize both current_sum and max_sum with the first element\\n\\n        for num in nums[1:]:  # Start iterating from the second element\\n            current_sum = max(num, current_sum + num)  # Calculate the maximum between the current number and the sum of the current number and the previous subarray\\n            max_sum = max(max_sum, current_sum)  # Update the maximum sum if the current sum is greater\\n\\n        return max_sum"
                    },
                    {
                        "username": "akshatanand186",
                        "content": "I tried submitting the divide and conquer approach which has complexity O(nlogn), but it is giving me TLE. Is it because my code has errors or?\nclass Solution {\npublic:\n    int callsum(int i, int j, vector<int>&nums){\n        // debug2(i,j);\n        if(i>j) return -1e9;\n        if(i==j) return nums[i];\n        int mid = (i+j)/2;\n        int z=0;\n        int maxm = -1e9;\n        for(int k=mid;k>=0;k--) z+= nums[k],maxm = max(z,maxm);\n        z = 0;\n        int hi = maxm;\n        for(int k=mid+1;k<nums.size();k++) z+= nums[k], maxm = max(z+hi,maxm);  \n        int x = callsum(i,mid,nums);\n        int y = callsum(mid+1,j,nums); \n        return max({x,y,maxm});\n    }\n    int maxSubArray(vector<int>& nums) {\n        return callsum(0,nums.size()-1,nums);\n    }\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code looks fine for the divide-and-conquer approach. It\\'s true that the divide-and-conquer approach has a time complexity of O(n log n), which is higher than the O(n) time complexity of Kadane\\'s algorithm. \\n\\nHowever, \"Time Limit Exceeded\" (TLE) errors often indicate that your code may be doing unnecessary work or has an inefficient implementation that causes it to take longer than the maximum allowed time. \\n\\nThere are a few things that could potentially be improved in your code:\\n\\n1. Recursion overhead: While recursion can make the code more readable, it does add overhead, especially in languages like C++.\\n\\n2. Unnecessary computations: The loops from `mid` to `0` and `mid+1` to `nums.size()` will go out of the bounds of the current subarray when the subarray size is small, resulting in unnecessary computation.\\n\\n3. Multiple calls to `max` function: You can store the maximums in variables to reduce the number of calls to the `max` function.\\n\\nOne more thing to consider, some online coding platforms could have tighter time limits, and algorithms with higher time complexity, even if correctly implemented, might still exceed the time limit. So the divide-and-conquer approach might still not pass even after optimizing the above points.\\n\\nAlso remember, it\\'s common practice in coding interviews to discuss the time complexity of your solution. If your interviewer asks for a more efficient solution, that\\'s your cue to discuss or implement the O(n) Kadane\\'s algorithm."
                    }
                ]
            },
            {
                "id": 1932884,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 very important algorithm (kadane\\'s) \\n\\uD83D\\uDFE2 it seems difficult at first look but once you give it a genuine try and understand the essence of of the algo then it will be a cake walk for you"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "One of the ways to solve this problem is sliding window ,\nKeep on adding elements starting from left, whenever the sum becomes negative start removing elements from the beginning until it becomes non negative again. \nreturn the max of all these sums.  \n\nDetailed solution: \n[https://leetcode.com/problems/maximum-subarray/solutions/3704593/easy-solution-using-sliding-window/](https://leetcode.com/problems/maximum-subarray/solutions/3704593/easy-solution-using-sliding-window/)"
                    },
                    {
                        "username": "bparanj",
                        "content": "Kadane\\'s algorithm is simpler and more straightforward, making it easier to understand and debug. The sliding window variation adds an additional layer of complexity with the sliding window management which might make it slightly harder to grasp initially."
                    },
                    {
                        "username": "LunaeNova",
                        "content": "This is much more of an Algorithms question than a Data Structures question."
                    },
                    {
                        "username": "HeatOn123",
                        "content": "well my algorithm worked without considering individual elements as separate subarrays, now just need to edit that by moving my initial variable to the element that\\'s the largest....(F this)"
                    },
                    {
                        "username": "akshr228",
                        "content": "I thought of a different algorithm for this problem. After seeing Kadane\\'s algorithm I feel foolish men of myself.  However , We can connect in social Media . FB: https://www.facebook.com/profile.php?id=100087367675784 . "
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Make it easy one with \"Kadane\\'s Algorithm\"."
                    },
                    {
                        "username": "TK0510",
                        "content": "The best solution is using KADANE\\'s algorithm and the Tc is O(n)."
                    },
                    {
                        "username": "fafalachu",
                        "content": "I have some problem with golang when I use container.list. \nIn the 100000 length of data test case, it always show \"Time Limit Exceeded\", but running at my mac  just show about 12ms and completed.\nI don't know what's wrong ?"
                    },
                    {
                        "username": "imbikramsaha",
                        "content": "class Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        current_sum = max_sum = nums[0]  # Initialize both current_sum and max_sum with the first element\\n\\n        for num in nums[1:]:  # Start iterating from the second element\\n            current_sum = max(num, current_sum + num)  # Calculate the maximum between the current number and the sum of the current number and the previous subarray\\n            max_sum = max(max_sum, current_sum)  # Update the maximum sum if the current sum is greater\\n\\n        return max_sum"
                    },
                    {
                        "username": "akshatanand186",
                        "content": "I tried submitting the divide and conquer approach which has complexity O(nlogn), but it is giving me TLE. Is it because my code has errors or?\nclass Solution {\npublic:\n    int callsum(int i, int j, vector<int>&nums){\n        // debug2(i,j);\n        if(i>j) return -1e9;\n        if(i==j) return nums[i];\n        int mid = (i+j)/2;\n        int z=0;\n        int maxm = -1e9;\n        for(int k=mid;k>=0;k--) z+= nums[k],maxm = max(z,maxm);\n        z = 0;\n        int hi = maxm;\n        for(int k=mid+1;k<nums.size();k++) z+= nums[k], maxm = max(z+hi,maxm);  \n        int x = callsum(i,mid,nums);\n        int y = callsum(mid+1,j,nums); \n        return max({x,y,maxm});\n    }\n    int maxSubArray(vector<int>& nums) {\n        return callsum(0,nums.size()-1,nums);\n    }\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code looks fine for the divide-and-conquer approach. It\\'s true that the divide-and-conquer approach has a time complexity of O(n log n), which is higher than the O(n) time complexity of Kadane\\'s algorithm. \\n\\nHowever, \"Time Limit Exceeded\" (TLE) errors often indicate that your code may be doing unnecessary work or has an inefficient implementation that causes it to take longer than the maximum allowed time. \\n\\nThere are a few things that could potentially be improved in your code:\\n\\n1. Recursion overhead: While recursion can make the code more readable, it does add overhead, especially in languages like C++.\\n\\n2. Unnecessary computations: The loops from `mid` to `0` and `mid+1` to `nums.size()` will go out of the bounds of the current subarray when the subarray size is small, resulting in unnecessary computation.\\n\\n3. Multiple calls to `max` function: You can store the maximums in variables to reduce the number of calls to the `max` function.\\n\\nOne more thing to consider, some online coding platforms could have tighter time limits, and algorithms with higher time complexity, even if correctly implemented, might still exceed the time limit. So the divide-and-conquer approach might still not pass even after optimizing the above points.\\n\\nAlso remember, it\\'s common practice in coding interviews to discuss the time complexity of your solution. If your interviewer asks for a more efficient solution, that\\'s your cue to discuss or implement the O(n) Kadane\\'s algorithm."
                    }
                ]
            },
            {
                "id": 1921831,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 very important algorithm (kadane\\'s) \\n\\uD83D\\uDFE2 it seems difficult at first look but once you give it a genuine try and understand the essence of of the algo then it will be a cake walk for you"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "One of the ways to solve this problem is sliding window ,\nKeep on adding elements starting from left, whenever the sum becomes negative start removing elements from the beginning until it becomes non negative again. \nreturn the max of all these sums.  \n\nDetailed solution: \n[https://leetcode.com/problems/maximum-subarray/solutions/3704593/easy-solution-using-sliding-window/](https://leetcode.com/problems/maximum-subarray/solutions/3704593/easy-solution-using-sliding-window/)"
                    },
                    {
                        "username": "bparanj",
                        "content": "Kadane\\'s algorithm is simpler and more straightforward, making it easier to understand and debug. The sliding window variation adds an additional layer of complexity with the sliding window management which might make it slightly harder to grasp initially."
                    },
                    {
                        "username": "LunaeNova",
                        "content": "This is much more of an Algorithms question than a Data Structures question."
                    },
                    {
                        "username": "HeatOn123",
                        "content": "well my algorithm worked without considering individual elements as separate subarrays, now just need to edit that by moving my initial variable to the element that\\'s the largest....(F this)"
                    },
                    {
                        "username": "akshr228",
                        "content": "I thought of a different algorithm for this problem. After seeing Kadane\\'s algorithm I feel foolish men of myself.  However , We can connect in social Media . FB: https://www.facebook.com/profile.php?id=100087367675784 . "
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Make it easy one with \"Kadane\\'s Algorithm\"."
                    },
                    {
                        "username": "TK0510",
                        "content": "The best solution is using KADANE\\'s algorithm and the Tc is O(n)."
                    },
                    {
                        "username": "fafalachu",
                        "content": "I have some problem with golang when I use container.list. \nIn the 100000 length of data test case, it always show \"Time Limit Exceeded\", but running at my mac  just show about 12ms and completed.\nI don't know what's wrong ?"
                    },
                    {
                        "username": "imbikramsaha",
                        "content": "class Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        current_sum = max_sum = nums[0]  # Initialize both current_sum and max_sum with the first element\\n\\n        for num in nums[1:]:  # Start iterating from the second element\\n            current_sum = max(num, current_sum + num)  # Calculate the maximum between the current number and the sum of the current number and the previous subarray\\n            max_sum = max(max_sum, current_sum)  # Update the maximum sum if the current sum is greater\\n\\n        return max_sum"
                    },
                    {
                        "username": "akshatanand186",
                        "content": "I tried submitting the divide and conquer approach which has complexity O(nlogn), but it is giving me TLE. Is it because my code has errors or?\nclass Solution {\npublic:\n    int callsum(int i, int j, vector<int>&nums){\n        // debug2(i,j);\n        if(i>j) return -1e9;\n        if(i==j) return nums[i];\n        int mid = (i+j)/2;\n        int z=0;\n        int maxm = -1e9;\n        for(int k=mid;k>=0;k--) z+= nums[k],maxm = max(z,maxm);\n        z = 0;\n        int hi = maxm;\n        for(int k=mid+1;k<nums.size();k++) z+= nums[k], maxm = max(z+hi,maxm);  \n        int x = callsum(i,mid,nums);\n        int y = callsum(mid+1,j,nums); \n        return max({x,y,maxm});\n    }\n    int maxSubArray(vector<int>& nums) {\n        return callsum(0,nums.size()-1,nums);\n    }\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code looks fine for the divide-and-conquer approach. It\\'s true that the divide-and-conquer approach has a time complexity of O(n log n), which is higher than the O(n) time complexity of Kadane\\'s algorithm. \\n\\nHowever, \"Time Limit Exceeded\" (TLE) errors often indicate that your code may be doing unnecessary work or has an inefficient implementation that causes it to take longer than the maximum allowed time. \\n\\nThere are a few things that could potentially be improved in your code:\\n\\n1. Recursion overhead: While recursion can make the code more readable, it does add overhead, especially in languages like C++.\\n\\n2. Unnecessary computations: The loops from `mid` to `0` and `mid+1` to `nums.size()` will go out of the bounds of the current subarray when the subarray size is small, resulting in unnecessary computation.\\n\\n3. Multiple calls to `max` function: You can store the maximums in variables to reduce the number of calls to the `max` function.\\n\\nOne more thing to consider, some online coding platforms could have tighter time limits, and algorithms with higher time complexity, even if correctly implemented, might still exceed the time limit. So the divide-and-conquer approach might still not pass even after optimizing the above points.\\n\\nAlso remember, it\\'s common practice in coding interviews to discuss the time complexity of your solution. If your interviewer asks for a more efficient solution, that\\'s your cue to discuss or implement the O(n) Kadane\\'s algorithm."
                    }
                ]
            },
            {
                "id": 1906078,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 very important algorithm (kadane\\'s) \\n\\uD83D\\uDFE2 it seems difficult at first look but once you give it a genuine try and understand the essence of of the algo then it will be a cake walk for you"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "One of the ways to solve this problem is sliding window ,\nKeep on adding elements starting from left, whenever the sum becomes negative start removing elements from the beginning until it becomes non negative again. \nreturn the max of all these sums.  \n\nDetailed solution: \n[https://leetcode.com/problems/maximum-subarray/solutions/3704593/easy-solution-using-sliding-window/](https://leetcode.com/problems/maximum-subarray/solutions/3704593/easy-solution-using-sliding-window/)"
                    },
                    {
                        "username": "bparanj",
                        "content": "Kadane\\'s algorithm is simpler and more straightforward, making it easier to understand and debug. The sliding window variation adds an additional layer of complexity with the sliding window management which might make it slightly harder to grasp initially."
                    },
                    {
                        "username": "LunaeNova",
                        "content": "This is much more of an Algorithms question than a Data Structures question."
                    },
                    {
                        "username": "HeatOn123",
                        "content": "well my algorithm worked without considering individual elements as separate subarrays, now just need to edit that by moving my initial variable to the element that\\'s the largest....(F this)"
                    },
                    {
                        "username": "akshr228",
                        "content": "I thought of a different algorithm for this problem. After seeing Kadane\\'s algorithm I feel foolish men of myself.  However , We can connect in social Media . FB: https://www.facebook.com/profile.php?id=100087367675784 . "
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Make it easy one with \"Kadane\\'s Algorithm\"."
                    },
                    {
                        "username": "TK0510",
                        "content": "The best solution is using KADANE\\'s algorithm and the Tc is O(n)."
                    },
                    {
                        "username": "fafalachu",
                        "content": "I have some problem with golang when I use container.list. \nIn the 100000 length of data test case, it always show \"Time Limit Exceeded\", but running at my mac  just show about 12ms and completed.\nI don't know what's wrong ?"
                    },
                    {
                        "username": "imbikramsaha",
                        "content": "class Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        current_sum = max_sum = nums[0]  # Initialize both current_sum and max_sum with the first element\\n\\n        for num in nums[1:]:  # Start iterating from the second element\\n            current_sum = max(num, current_sum + num)  # Calculate the maximum between the current number and the sum of the current number and the previous subarray\\n            max_sum = max(max_sum, current_sum)  # Update the maximum sum if the current sum is greater\\n\\n        return max_sum"
                    },
                    {
                        "username": "akshatanand186",
                        "content": "I tried submitting the divide and conquer approach which has complexity O(nlogn), but it is giving me TLE. Is it because my code has errors or?\nclass Solution {\npublic:\n    int callsum(int i, int j, vector<int>&nums){\n        // debug2(i,j);\n        if(i>j) return -1e9;\n        if(i==j) return nums[i];\n        int mid = (i+j)/2;\n        int z=0;\n        int maxm = -1e9;\n        for(int k=mid;k>=0;k--) z+= nums[k],maxm = max(z,maxm);\n        z = 0;\n        int hi = maxm;\n        for(int k=mid+1;k<nums.size();k++) z+= nums[k], maxm = max(z+hi,maxm);  \n        int x = callsum(i,mid,nums);\n        int y = callsum(mid+1,j,nums); \n        return max({x,y,maxm});\n    }\n    int maxSubArray(vector<int>& nums) {\n        return callsum(0,nums.size()-1,nums);\n    }\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code looks fine for the divide-and-conquer approach. It\\'s true that the divide-and-conquer approach has a time complexity of O(n log n), which is higher than the O(n) time complexity of Kadane\\'s algorithm. \\n\\nHowever, \"Time Limit Exceeded\" (TLE) errors often indicate that your code may be doing unnecessary work or has an inefficient implementation that causes it to take longer than the maximum allowed time. \\n\\nThere are a few things that could potentially be improved in your code:\\n\\n1. Recursion overhead: While recursion can make the code more readable, it does add overhead, especially in languages like C++.\\n\\n2. Unnecessary computations: The loops from `mid` to `0` and `mid+1` to `nums.size()` will go out of the bounds of the current subarray when the subarray size is small, resulting in unnecessary computation.\\n\\n3. Multiple calls to `max` function: You can store the maximums in variables to reduce the number of calls to the `max` function.\\n\\nOne more thing to consider, some online coding platforms could have tighter time limits, and algorithms with higher time complexity, even if correctly implemented, might still exceed the time limit. So the divide-and-conquer approach might still not pass even after optimizing the above points.\\n\\nAlso remember, it\\'s common practice in coding interviews to discuss the time complexity of your solution. If your interviewer asks for a more efficient solution, that\\'s your cue to discuss or implement the O(n) Kadane\\'s algorithm."
                    }
                ]
            },
            {
                "id": 1897977,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 very important algorithm (kadane\\'s) \\n\\uD83D\\uDFE2 it seems difficult at first look but once you give it a genuine try and understand the essence of of the algo then it will be a cake walk for you"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "One of the ways to solve this problem is sliding window ,\nKeep on adding elements starting from left, whenever the sum becomes negative start removing elements from the beginning until it becomes non negative again. \nreturn the max of all these sums.  \n\nDetailed solution: \n[https://leetcode.com/problems/maximum-subarray/solutions/3704593/easy-solution-using-sliding-window/](https://leetcode.com/problems/maximum-subarray/solutions/3704593/easy-solution-using-sliding-window/)"
                    },
                    {
                        "username": "bparanj",
                        "content": "Kadane\\'s algorithm is simpler and more straightforward, making it easier to understand and debug. The sliding window variation adds an additional layer of complexity with the sliding window management which might make it slightly harder to grasp initially."
                    },
                    {
                        "username": "LunaeNova",
                        "content": "This is much more of an Algorithms question than a Data Structures question."
                    },
                    {
                        "username": "HeatOn123",
                        "content": "well my algorithm worked without considering individual elements as separate subarrays, now just need to edit that by moving my initial variable to the element that\\'s the largest....(F this)"
                    },
                    {
                        "username": "akshr228",
                        "content": "I thought of a different algorithm for this problem. After seeing Kadane\\'s algorithm I feel foolish men of myself.  However , We can connect in social Media . FB: https://www.facebook.com/profile.php?id=100087367675784 . "
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Make it easy one with \"Kadane\\'s Algorithm\"."
                    },
                    {
                        "username": "TK0510",
                        "content": "The best solution is using KADANE\\'s algorithm and the Tc is O(n)."
                    },
                    {
                        "username": "fafalachu",
                        "content": "I have some problem with golang when I use container.list. \nIn the 100000 length of data test case, it always show \"Time Limit Exceeded\", but running at my mac  just show about 12ms and completed.\nI don't know what's wrong ?"
                    },
                    {
                        "username": "imbikramsaha",
                        "content": "class Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        current_sum = max_sum = nums[0]  # Initialize both current_sum and max_sum with the first element\\n\\n        for num in nums[1:]:  # Start iterating from the second element\\n            current_sum = max(num, current_sum + num)  # Calculate the maximum between the current number and the sum of the current number and the previous subarray\\n            max_sum = max(max_sum, current_sum)  # Update the maximum sum if the current sum is greater\\n\\n        return max_sum"
                    },
                    {
                        "username": "akshatanand186",
                        "content": "I tried submitting the divide and conquer approach which has complexity O(nlogn), but it is giving me TLE. Is it because my code has errors or?\nclass Solution {\npublic:\n    int callsum(int i, int j, vector<int>&nums){\n        // debug2(i,j);\n        if(i>j) return -1e9;\n        if(i==j) return nums[i];\n        int mid = (i+j)/2;\n        int z=0;\n        int maxm = -1e9;\n        for(int k=mid;k>=0;k--) z+= nums[k],maxm = max(z,maxm);\n        z = 0;\n        int hi = maxm;\n        for(int k=mid+1;k<nums.size();k++) z+= nums[k], maxm = max(z+hi,maxm);  \n        int x = callsum(i,mid,nums);\n        int y = callsum(mid+1,j,nums); \n        return max({x,y,maxm});\n    }\n    int maxSubArray(vector<int>& nums) {\n        return callsum(0,nums.size()-1,nums);\n    }\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code looks fine for the divide-and-conquer approach. It\\'s true that the divide-and-conquer approach has a time complexity of O(n log n), which is higher than the O(n) time complexity of Kadane\\'s algorithm. \\n\\nHowever, \"Time Limit Exceeded\" (TLE) errors often indicate that your code may be doing unnecessary work or has an inefficient implementation that causes it to take longer than the maximum allowed time. \\n\\nThere are a few things that could potentially be improved in your code:\\n\\n1. Recursion overhead: While recursion can make the code more readable, it does add overhead, especially in languages like C++.\\n\\n2. Unnecessary computations: The loops from `mid` to `0` and `mid+1` to `nums.size()` will go out of the bounds of the current subarray when the subarray size is small, resulting in unnecessary computation.\\n\\n3. Multiple calls to `max` function: You can store the maximums in variables to reduce the number of calls to the `max` function.\\n\\nOne more thing to consider, some online coding platforms could have tighter time limits, and algorithms with higher time complexity, even if correctly implemented, might still exceed the time limit. So the divide-and-conquer approach might still not pass even after optimizing the above points.\\n\\nAlso remember, it\\'s common practice in coding interviews to discuss the time complexity of your solution. If your interviewer asks for a more efficient solution, that\\'s your cue to discuss or implement the O(n) Kadane\\'s algorithm."
                    }
                ]
            },
            {
                "id": 1897004,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 very important algorithm (kadane\\'s) \\n\\uD83D\\uDFE2 it seems difficult at first look but once you give it a genuine try and understand the essence of of the algo then it will be a cake walk for you"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "One of the ways to solve this problem is sliding window ,\nKeep on adding elements starting from left, whenever the sum becomes negative start removing elements from the beginning until it becomes non negative again. \nreturn the max of all these sums.  \n\nDetailed solution: \n[https://leetcode.com/problems/maximum-subarray/solutions/3704593/easy-solution-using-sliding-window/](https://leetcode.com/problems/maximum-subarray/solutions/3704593/easy-solution-using-sliding-window/)"
                    },
                    {
                        "username": "bparanj",
                        "content": "Kadane\\'s algorithm is simpler and more straightforward, making it easier to understand and debug. The sliding window variation adds an additional layer of complexity with the sliding window management which might make it slightly harder to grasp initially."
                    },
                    {
                        "username": "LunaeNova",
                        "content": "This is much more of an Algorithms question than a Data Structures question."
                    },
                    {
                        "username": "HeatOn123",
                        "content": "well my algorithm worked without considering individual elements as separate subarrays, now just need to edit that by moving my initial variable to the element that\\'s the largest....(F this)"
                    },
                    {
                        "username": "akshr228",
                        "content": "I thought of a different algorithm for this problem. After seeing Kadane\\'s algorithm I feel foolish men of myself.  However , We can connect in social Media . FB: https://www.facebook.com/profile.php?id=100087367675784 . "
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Make it easy one with \"Kadane\\'s Algorithm\"."
                    },
                    {
                        "username": "TK0510",
                        "content": "The best solution is using KADANE\\'s algorithm and the Tc is O(n)."
                    },
                    {
                        "username": "fafalachu",
                        "content": "I have some problem with golang when I use container.list. \nIn the 100000 length of data test case, it always show \"Time Limit Exceeded\", but running at my mac  just show about 12ms and completed.\nI don't know what's wrong ?"
                    },
                    {
                        "username": "imbikramsaha",
                        "content": "class Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        current_sum = max_sum = nums[0]  # Initialize both current_sum and max_sum with the first element\\n\\n        for num in nums[1:]:  # Start iterating from the second element\\n            current_sum = max(num, current_sum + num)  # Calculate the maximum between the current number and the sum of the current number and the previous subarray\\n            max_sum = max(max_sum, current_sum)  # Update the maximum sum if the current sum is greater\\n\\n        return max_sum"
                    },
                    {
                        "username": "akshatanand186",
                        "content": "I tried submitting the divide and conquer approach which has complexity O(nlogn), but it is giving me TLE. Is it because my code has errors or?\nclass Solution {\npublic:\n    int callsum(int i, int j, vector<int>&nums){\n        // debug2(i,j);\n        if(i>j) return -1e9;\n        if(i==j) return nums[i];\n        int mid = (i+j)/2;\n        int z=0;\n        int maxm = -1e9;\n        for(int k=mid;k>=0;k--) z+= nums[k],maxm = max(z,maxm);\n        z = 0;\n        int hi = maxm;\n        for(int k=mid+1;k<nums.size();k++) z+= nums[k], maxm = max(z+hi,maxm);  \n        int x = callsum(i,mid,nums);\n        int y = callsum(mid+1,j,nums); \n        return max({x,y,maxm});\n    }\n    int maxSubArray(vector<int>& nums) {\n        return callsum(0,nums.size()-1,nums);\n    }\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code looks fine for the divide-and-conquer approach. It\\'s true that the divide-and-conquer approach has a time complexity of O(n log n), which is higher than the O(n) time complexity of Kadane\\'s algorithm. \\n\\nHowever, \"Time Limit Exceeded\" (TLE) errors often indicate that your code may be doing unnecessary work or has an inefficient implementation that causes it to take longer than the maximum allowed time. \\n\\nThere are a few things that could potentially be improved in your code:\\n\\n1. Recursion overhead: While recursion can make the code more readable, it does add overhead, especially in languages like C++.\\n\\n2. Unnecessary computations: The loops from `mid` to `0` and `mid+1` to `nums.size()` will go out of the bounds of the current subarray when the subarray size is small, resulting in unnecessary computation.\\n\\n3. Multiple calls to `max` function: You can store the maximums in variables to reduce the number of calls to the `max` function.\\n\\nOne more thing to consider, some online coding platforms could have tighter time limits, and algorithms with higher time complexity, even if correctly implemented, might still exceed the time limit. So the divide-and-conquer approach might still not pass even after optimizing the above points.\\n\\nAlso remember, it\\'s common practice in coding interviews to discuss the time complexity of your solution. If your interviewer asks for a more efficient solution, that\\'s your cue to discuss or implement the O(n) Kadane\\'s algorithm."
                    }
                ]
            },
            {
                "id": 1896232,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 very important algorithm (kadane\\'s) \\n\\uD83D\\uDFE2 it seems difficult at first look but once you give it a genuine try and understand the essence of of the algo then it will be a cake walk for you"
                    },
                    {
                        "username": "wtfcoder",
                        "content": "One of the ways to solve this problem is sliding window ,\nKeep on adding elements starting from left, whenever the sum becomes negative start removing elements from the beginning until it becomes non negative again. \nreturn the max of all these sums.  \n\nDetailed solution: \n[https://leetcode.com/problems/maximum-subarray/solutions/3704593/easy-solution-using-sliding-window/](https://leetcode.com/problems/maximum-subarray/solutions/3704593/easy-solution-using-sliding-window/)"
                    },
                    {
                        "username": "bparanj",
                        "content": "Kadane\\'s algorithm is simpler and more straightforward, making it easier to understand and debug. The sliding window variation adds an additional layer of complexity with the sliding window management which might make it slightly harder to grasp initially."
                    },
                    {
                        "username": "LunaeNova",
                        "content": "This is much more of an Algorithms question than a Data Structures question."
                    },
                    {
                        "username": "HeatOn123",
                        "content": "well my algorithm worked without considering individual elements as separate subarrays, now just need to edit that by moving my initial variable to the element that\\'s the largest....(F this)"
                    },
                    {
                        "username": "akshr228",
                        "content": "I thought of a different algorithm for this problem. After seeing Kadane\\'s algorithm I feel foolish men of myself.  However , We can connect in social Media . FB: https://www.facebook.com/profile.php?id=100087367675784 . "
                    },
                    {
                        "username": "swati_dubey",
                        "content": "Make it easy one with \"Kadane\\'s Algorithm\"."
                    },
                    {
                        "username": "TK0510",
                        "content": "The best solution is using KADANE\\'s algorithm and the Tc is O(n)."
                    },
                    {
                        "username": "fafalachu",
                        "content": "I have some problem with golang when I use container.list. \nIn the 100000 length of data test case, it always show \"Time Limit Exceeded\", but running at my mac  just show about 12ms and completed.\nI don't know what's wrong ?"
                    },
                    {
                        "username": "imbikramsaha",
                        "content": "class Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        current_sum = max_sum = nums[0]  # Initialize both current_sum and max_sum with the first element\\n\\n        for num in nums[1:]:  # Start iterating from the second element\\n            current_sum = max(num, current_sum + num)  # Calculate the maximum between the current number and the sum of the current number and the previous subarray\\n            max_sum = max(max_sum, current_sum)  # Update the maximum sum if the current sum is greater\\n\\n        return max_sum"
                    },
                    {
                        "username": "akshatanand186",
                        "content": "I tried submitting the divide and conquer approach which has complexity O(nlogn), but it is giving me TLE. Is it because my code has errors or?\nclass Solution {\npublic:\n    int callsum(int i, int j, vector<int>&nums){\n        // debug2(i,j);\n        if(i>j) return -1e9;\n        if(i==j) return nums[i];\n        int mid = (i+j)/2;\n        int z=0;\n        int maxm = -1e9;\n        for(int k=mid;k>=0;k--) z+= nums[k],maxm = max(z,maxm);\n        z = 0;\n        int hi = maxm;\n        for(int k=mid+1;k<nums.size();k++) z+= nums[k], maxm = max(z+hi,maxm);  \n        int x = callsum(i,mid,nums);\n        int y = callsum(mid+1,j,nums); \n        return max({x,y,maxm});\n    }\n    int maxSubArray(vector<int>& nums) {\n        return callsum(0,nums.size()-1,nums);\n    }\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code looks fine for the divide-and-conquer approach. It\\'s true that the divide-and-conquer approach has a time complexity of O(n log n), which is higher than the O(n) time complexity of Kadane\\'s algorithm. \\n\\nHowever, \"Time Limit Exceeded\" (TLE) errors often indicate that your code may be doing unnecessary work or has an inefficient implementation that causes it to take longer than the maximum allowed time. \\n\\nThere are a few things that could potentially be improved in your code:\\n\\n1. Recursion overhead: While recursion can make the code more readable, it does add overhead, especially in languages like C++.\\n\\n2. Unnecessary computations: The loops from `mid` to `0` and `mid+1` to `nums.size()` will go out of the bounds of the current subarray when the subarray size is small, resulting in unnecessary computation.\\n\\n3. Multiple calls to `max` function: You can store the maximums in variables to reduce the number of calls to the `max` function.\\n\\nOne more thing to consider, some online coding platforms could have tighter time limits, and algorithms with higher time complexity, even if correctly implemented, might still exceed the time limit. So the divide-and-conquer approach might still not pass even after optimizing the above points.\\n\\nAlso remember, it\\'s common practice in coding interviews to discuss the time complexity of your solution. If your interviewer asks for a more efficient solution, that\\'s your cue to discuss or implement the O(n) Kadane\\'s algorithm."
                    }
                ]
            },
            {
                "id": 1895160,
                "content": [
                    {
                        "username": "london804",
                        "content": "Example 3:\nInput: nums = [5,4,-1,7,8]\nOutput: 23\nExplanation: The subarray [5,4,-1,7,8] has the largest sum 23. \nHow is Example 3 a subarray? Shouldn't the answer be 15"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of this problem, a \"subarray\" of an array is a contiguous portion of the array. A subarray could consist of any number of elements, from a single element up to the entire array. So, in Example 3, [5,4,-1,7,8] is considered a subarray of the original array [5,4,-1,7,8] -- in fact, it\\'s the entire array.\\n\\nThe subarray with the largest sum is [5,4,-1,7,8], and the sum of this subarray is 5+4+(-1)+7+8 = 23, not 15. The algorithm is trying to find the maximum sum that can be obtained from a subarray, not the maximum length or number of positive numbers in a subarray.\\n\\nSo the output 23 is correct for this example."
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "I have question. the problem indicate the nums element constraint can be from -10^4 to 10^4 which means the whole array can be negative nums even tho there is not a single test case that all array contains negative nums"
                    },
                    {
                        "username": "bparanj",
                        "content": "Just because the constraints allow for elements to be in the range -10^4 to 10^4, it doesn\\'t mean that all the test cases will have all negative numbers. The constraints are there to provide the boundaries within which your solution must work, but the actual test cases used to evaluate your solution can be anything within those boundaries, including cases where all elements are negative, all elements are positive, or a mix of positive and negative elements.\\n\\nFor the Maximum Subarray problem, if all the elements in the input array are negative, then the maximum subarray is simply the element with the least negative value (i.e., the element closest to zero). This is because adding negative numbers together only makes the sum more negative.\\n\\nFor example, if you have an input array like `[-3, -2, -1]`, the maximum subarray is simply `[-1]`, and the maximum sum is `-1`.\\n"
                    },
                    {
                        "username": "jaweriazaman",
                        "content": "why we use vectors here"
                    },
                    {
                        "username": "kalasaniuday",
                        "content": "Here, what if all the integers are negative?\\nfor example, [-1,-9, -2,-5] then largest sum subarray might be [-1], but how can we assume empty subarray equals to zero."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of the Maximum Subarray problem, an empty subarray is generally not considered, as the problem constraints specify that the size of the input array `nums` is at least 1. \\n\\nIf all the numbers in the array are negative, then the maximum subarray would be the subarray containing the single number with the least negative value (i.e., the number closest to zero). So, for the example `[-1,-9, -2,-5]`, the maximum subarray is indeed `[-1]`.\\n\\nThere\\'s no need to consider an empty subarray in this case, because an empty subarray would have a sum of zero, which would be less than any non-negative number and only more than negative numbers. Since the array always contains at least one number, the maximum subarray sum will always be at least as large as the maximum individual number.\\n\\nIf you are using Kadane\\'s algorithm to solve this problem, it essentially does the same thing - it maintains a running sum of the array, and if the sum becomes negative at any point, it resets the sum to zero (effectively \"discarding\" the previous numbers), because a negative sum would only decrease the total sum if we were to add more positive numbers to it. However, the algorithm also keeps track of the maximum sum it has seen so far, so even if all the numbers are negative, it will still return the least negative number as the maximum subarray sum.\\n\\nHere\\'s the algorithm for reference:\\n\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        max_sum = nums[0]\\n        curr_sum = 0\\n        for num in nums:\\n            if curr_sum < 0:\\n                curr_sum = 0\\n            curr_sum += num\\n            max_sum = max(max_sum, curr_sum)\\n        return max_sum\\n```\\nIn the case of all negative numbers, `curr_sum` would always be reset to 0, but `max_sum` would keep track of the maximum (least negative) number seen."
                    },
                    {
                        "username": "kuznetsov-m",
                        "content": "For example nums = [-1, -2, -3]\nWhy subarray can't be empty and maxSubArray = 0?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of the Maximum Subarray problem, the definition of a subarray typically requires that it contains at least one element. An empty set does not constitute a subarray as per this definition. Therefore, in the case of `nums = [-1, -2, -3]`, the maximum subarray cannot be empty and the maximum subarray sum cannot be 0.\\n\\nIf you consider an empty subarray as valid and having a sum of 0, then for any array that only has negative numbers, the maximum subarray would always be an empty set and the maximum sum would always be 0. But by requiring that a subarray contains at least one number, the problem becomes more interesting, as you then have to consider which number (or numbers) maximizes the sum.\\n\\nSo for `nums = [-1, -2, -3]`, the maximum subarray would be `[-1]`, and the maximum subarray sum would be -1, because -1 is greater than -2 and -3."
                    },
                    {
                        "username": "shubham_srivastav",
                        "content": "how can i conceder that the resultante subarray length i right?"
                    },
                    {
                        "username": "caroline_",
                        "content": "Hmm so in the case of test case [-1] apparently the optimal solution is -1 and not 0. This doesn\\'t seem right to me; a subarray of length 0 provides a higher sum technically, no?\\n\\nAnyway this is the type of thing one should ask the interviewer so I guess it doesn\\'t matter :)"
                    },
                    {
                        "username": "SmoothCriminalOww",
                        "content": "Largest sum right? why are we required to get a subarray with negative values for eg -1 in requirements?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The idea is to find the subarray that has the \"maximum sum\". In your example of an array with all negative values (e.g., [-1, -2, -3]), a subarray with a single element of -1 does provide the maximum sum. Although it\\'s a negative value, -1 is greater than -2 and -3. \\n\\nThe purpose of this requirement is to find the maximum sum of a continuous sub-sequence in the array, even if the maximum sum is negative. It adds more complexity to the problem as compared to simply discarding all negative numbers. \\n\\nSo even if the input array only has negative numbers, we don\\'t consider the maximum sum to be 0 by choosing an empty subarray; instead, we consider the maximum negative number as the maximum sum. If we allowed an empty subarray to be the maximum, then the solution for any input array with all negative numbers would be 0, which simplifies the problem and ignores the fact that a higher (less negative) number is actually \"greater\" than a lower (more negative) number."
                    },
                    {
                        "username": "daring-calf",
                        "content": "OMFG!!! After a year of leetcoding, I figured out the Kadane\\'s algorithm by myself in 2 hours!\\nI\\'m invincible now!!"
                    },
                    {
                        "username": "AssetDali",
                        "content": "Hint: if the the subarray has the largest sum, then the remaining elements have the minimum sum(either negative or no elements)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Actually, that hint isn\\'t entirely correct. It\\'s possible for a subarray with the maximum sum to not leave the remaining elements with the minimum sum. Consider the array [2, 1, -3, 4, -1, 2, 1, -5, 4]. The subarray with the largest sum is [4, -1, 2, 1] with a sum of 6. However, the remaining elements [2, 1, -3, -5, 4] don\\'t necessarily sum to the minimum possible sum in this array.\\n\\nWhat we can say is that if we\\'re trying to find the subarray with the maximum sum, it doesn\\'t make sense to include a prefix or suffix of negative numbers in that subarray. That\\'s because removing that prefix or suffix would lead to a higher sum.\\n\\nSo in the array [2, 1, -3, 4, -1, 2, 1, -5, 4], the subarray [4, -1, 2, 1] does not include the prefix [-3] or the suffix [-5], because doing so would lead to a smaller sum.\\n\\nA better hint might be: \\n\\nWhen examining the elements in the array, if the current element plus the running total (subarray sum up to this point) is less than the current element itself, then the running total should be discarded (set to zero) and start a new subarray from the current element. This is because a maximum subarray sum will never include a previous sum that is negative, it is better to start a new sum from the current element. This is the core idea behind Kadane\\'s algorithm."
                    }
                ]
            },
            {
                "id": 1892215,
                "content": [
                    {
                        "username": "london804",
                        "content": "Example 3:\nInput: nums = [5,4,-1,7,8]\nOutput: 23\nExplanation: The subarray [5,4,-1,7,8] has the largest sum 23. \nHow is Example 3 a subarray? Shouldn't the answer be 15"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of this problem, a \"subarray\" of an array is a contiguous portion of the array. A subarray could consist of any number of elements, from a single element up to the entire array. So, in Example 3, [5,4,-1,7,8] is considered a subarray of the original array [5,4,-1,7,8] -- in fact, it\\'s the entire array.\\n\\nThe subarray with the largest sum is [5,4,-1,7,8], and the sum of this subarray is 5+4+(-1)+7+8 = 23, not 15. The algorithm is trying to find the maximum sum that can be obtained from a subarray, not the maximum length or number of positive numbers in a subarray.\\n\\nSo the output 23 is correct for this example."
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "I have question. the problem indicate the nums element constraint can be from -10^4 to 10^4 which means the whole array can be negative nums even tho there is not a single test case that all array contains negative nums"
                    },
                    {
                        "username": "bparanj",
                        "content": "Just because the constraints allow for elements to be in the range -10^4 to 10^4, it doesn\\'t mean that all the test cases will have all negative numbers. The constraints are there to provide the boundaries within which your solution must work, but the actual test cases used to evaluate your solution can be anything within those boundaries, including cases where all elements are negative, all elements are positive, or a mix of positive and negative elements.\\n\\nFor the Maximum Subarray problem, if all the elements in the input array are negative, then the maximum subarray is simply the element with the least negative value (i.e., the element closest to zero). This is because adding negative numbers together only makes the sum more negative.\\n\\nFor example, if you have an input array like `[-3, -2, -1]`, the maximum subarray is simply `[-1]`, and the maximum sum is `-1`.\\n"
                    },
                    {
                        "username": "jaweriazaman",
                        "content": "why we use vectors here"
                    },
                    {
                        "username": "kalasaniuday",
                        "content": "Here, what if all the integers are negative?\\nfor example, [-1,-9, -2,-5] then largest sum subarray might be [-1], but how can we assume empty subarray equals to zero."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of the Maximum Subarray problem, an empty subarray is generally not considered, as the problem constraints specify that the size of the input array `nums` is at least 1. \\n\\nIf all the numbers in the array are negative, then the maximum subarray would be the subarray containing the single number with the least negative value (i.e., the number closest to zero). So, for the example `[-1,-9, -2,-5]`, the maximum subarray is indeed `[-1]`.\\n\\nThere\\'s no need to consider an empty subarray in this case, because an empty subarray would have a sum of zero, which would be less than any non-negative number and only more than negative numbers. Since the array always contains at least one number, the maximum subarray sum will always be at least as large as the maximum individual number.\\n\\nIf you are using Kadane\\'s algorithm to solve this problem, it essentially does the same thing - it maintains a running sum of the array, and if the sum becomes negative at any point, it resets the sum to zero (effectively \"discarding\" the previous numbers), because a negative sum would only decrease the total sum if we were to add more positive numbers to it. However, the algorithm also keeps track of the maximum sum it has seen so far, so even if all the numbers are negative, it will still return the least negative number as the maximum subarray sum.\\n\\nHere\\'s the algorithm for reference:\\n\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        max_sum = nums[0]\\n        curr_sum = 0\\n        for num in nums:\\n            if curr_sum < 0:\\n                curr_sum = 0\\n            curr_sum += num\\n            max_sum = max(max_sum, curr_sum)\\n        return max_sum\\n```\\nIn the case of all negative numbers, `curr_sum` would always be reset to 0, but `max_sum` would keep track of the maximum (least negative) number seen."
                    },
                    {
                        "username": "kuznetsov-m",
                        "content": "For example nums = [-1, -2, -3]\nWhy subarray can't be empty and maxSubArray = 0?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of the Maximum Subarray problem, the definition of a subarray typically requires that it contains at least one element. An empty set does not constitute a subarray as per this definition. Therefore, in the case of `nums = [-1, -2, -3]`, the maximum subarray cannot be empty and the maximum subarray sum cannot be 0.\\n\\nIf you consider an empty subarray as valid and having a sum of 0, then for any array that only has negative numbers, the maximum subarray would always be an empty set and the maximum sum would always be 0. But by requiring that a subarray contains at least one number, the problem becomes more interesting, as you then have to consider which number (or numbers) maximizes the sum.\\n\\nSo for `nums = [-1, -2, -3]`, the maximum subarray would be `[-1]`, and the maximum subarray sum would be -1, because -1 is greater than -2 and -3."
                    },
                    {
                        "username": "shubham_srivastav",
                        "content": "how can i conceder that the resultante subarray length i right?"
                    },
                    {
                        "username": "caroline_",
                        "content": "Hmm so in the case of test case [-1] apparently the optimal solution is -1 and not 0. This doesn\\'t seem right to me; a subarray of length 0 provides a higher sum technically, no?\\n\\nAnyway this is the type of thing one should ask the interviewer so I guess it doesn\\'t matter :)"
                    },
                    {
                        "username": "SmoothCriminalOww",
                        "content": "Largest sum right? why are we required to get a subarray with negative values for eg -1 in requirements?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The idea is to find the subarray that has the \"maximum sum\". In your example of an array with all negative values (e.g., [-1, -2, -3]), a subarray with a single element of -1 does provide the maximum sum. Although it\\'s a negative value, -1 is greater than -2 and -3. \\n\\nThe purpose of this requirement is to find the maximum sum of a continuous sub-sequence in the array, even if the maximum sum is negative. It adds more complexity to the problem as compared to simply discarding all negative numbers. \\n\\nSo even if the input array only has negative numbers, we don\\'t consider the maximum sum to be 0 by choosing an empty subarray; instead, we consider the maximum negative number as the maximum sum. If we allowed an empty subarray to be the maximum, then the solution for any input array with all negative numbers would be 0, which simplifies the problem and ignores the fact that a higher (less negative) number is actually \"greater\" than a lower (more negative) number."
                    },
                    {
                        "username": "daring-calf",
                        "content": "OMFG!!! After a year of leetcoding, I figured out the Kadane\\'s algorithm by myself in 2 hours!\\nI\\'m invincible now!!"
                    },
                    {
                        "username": "AssetDali",
                        "content": "Hint: if the the subarray has the largest sum, then the remaining elements have the minimum sum(either negative or no elements)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Actually, that hint isn\\'t entirely correct. It\\'s possible for a subarray with the maximum sum to not leave the remaining elements with the minimum sum. Consider the array [2, 1, -3, 4, -1, 2, 1, -5, 4]. The subarray with the largest sum is [4, -1, 2, 1] with a sum of 6. However, the remaining elements [2, 1, -3, -5, 4] don\\'t necessarily sum to the minimum possible sum in this array.\\n\\nWhat we can say is that if we\\'re trying to find the subarray with the maximum sum, it doesn\\'t make sense to include a prefix or suffix of negative numbers in that subarray. That\\'s because removing that prefix or suffix would lead to a higher sum.\\n\\nSo in the array [2, 1, -3, 4, -1, 2, 1, -5, 4], the subarray [4, -1, 2, 1] does not include the prefix [-3] or the suffix [-5], because doing so would lead to a smaller sum.\\n\\nA better hint might be: \\n\\nWhen examining the elements in the array, if the current element plus the running total (subarray sum up to this point) is less than the current element itself, then the running total should be discarded (set to zero) and start a new subarray from the current element. This is because a maximum subarray sum will never include a previous sum that is negative, it is better to start a new sum from the current element. This is the core idea behind Kadane\\'s algorithm."
                    }
                ]
            },
            {
                "id": 1891155,
                "content": [
                    {
                        "username": "london804",
                        "content": "Example 3:\nInput: nums = [5,4,-1,7,8]\nOutput: 23\nExplanation: The subarray [5,4,-1,7,8] has the largest sum 23. \nHow is Example 3 a subarray? Shouldn't the answer be 15"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of this problem, a \"subarray\" of an array is a contiguous portion of the array. A subarray could consist of any number of elements, from a single element up to the entire array. So, in Example 3, [5,4,-1,7,8] is considered a subarray of the original array [5,4,-1,7,8] -- in fact, it\\'s the entire array.\\n\\nThe subarray with the largest sum is [5,4,-1,7,8], and the sum of this subarray is 5+4+(-1)+7+8 = 23, not 15. The algorithm is trying to find the maximum sum that can be obtained from a subarray, not the maximum length or number of positive numbers in a subarray.\\n\\nSo the output 23 is correct for this example."
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "I have question. the problem indicate the nums element constraint can be from -10^4 to 10^4 which means the whole array can be negative nums even tho there is not a single test case that all array contains negative nums"
                    },
                    {
                        "username": "bparanj",
                        "content": "Just because the constraints allow for elements to be in the range -10^4 to 10^4, it doesn\\'t mean that all the test cases will have all negative numbers. The constraints are there to provide the boundaries within which your solution must work, but the actual test cases used to evaluate your solution can be anything within those boundaries, including cases where all elements are negative, all elements are positive, or a mix of positive and negative elements.\\n\\nFor the Maximum Subarray problem, if all the elements in the input array are negative, then the maximum subarray is simply the element with the least negative value (i.e., the element closest to zero). This is because adding negative numbers together only makes the sum more negative.\\n\\nFor example, if you have an input array like `[-3, -2, -1]`, the maximum subarray is simply `[-1]`, and the maximum sum is `-1`.\\n"
                    },
                    {
                        "username": "jaweriazaman",
                        "content": "why we use vectors here"
                    },
                    {
                        "username": "kalasaniuday",
                        "content": "Here, what if all the integers are negative?\\nfor example, [-1,-9, -2,-5] then largest sum subarray might be [-1], but how can we assume empty subarray equals to zero."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of the Maximum Subarray problem, an empty subarray is generally not considered, as the problem constraints specify that the size of the input array `nums` is at least 1. \\n\\nIf all the numbers in the array are negative, then the maximum subarray would be the subarray containing the single number with the least negative value (i.e., the number closest to zero). So, for the example `[-1,-9, -2,-5]`, the maximum subarray is indeed `[-1]`.\\n\\nThere\\'s no need to consider an empty subarray in this case, because an empty subarray would have a sum of zero, which would be less than any non-negative number and only more than negative numbers. Since the array always contains at least one number, the maximum subarray sum will always be at least as large as the maximum individual number.\\n\\nIf you are using Kadane\\'s algorithm to solve this problem, it essentially does the same thing - it maintains a running sum of the array, and if the sum becomes negative at any point, it resets the sum to zero (effectively \"discarding\" the previous numbers), because a negative sum would only decrease the total sum if we were to add more positive numbers to it. However, the algorithm also keeps track of the maximum sum it has seen so far, so even if all the numbers are negative, it will still return the least negative number as the maximum subarray sum.\\n\\nHere\\'s the algorithm for reference:\\n\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        max_sum = nums[0]\\n        curr_sum = 0\\n        for num in nums:\\n            if curr_sum < 0:\\n                curr_sum = 0\\n            curr_sum += num\\n            max_sum = max(max_sum, curr_sum)\\n        return max_sum\\n```\\nIn the case of all negative numbers, `curr_sum` would always be reset to 0, but `max_sum` would keep track of the maximum (least negative) number seen."
                    },
                    {
                        "username": "kuznetsov-m",
                        "content": "For example nums = [-1, -2, -3]\nWhy subarray can't be empty and maxSubArray = 0?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of the Maximum Subarray problem, the definition of a subarray typically requires that it contains at least one element. An empty set does not constitute a subarray as per this definition. Therefore, in the case of `nums = [-1, -2, -3]`, the maximum subarray cannot be empty and the maximum subarray sum cannot be 0.\\n\\nIf you consider an empty subarray as valid and having a sum of 0, then for any array that only has negative numbers, the maximum subarray would always be an empty set and the maximum sum would always be 0. But by requiring that a subarray contains at least one number, the problem becomes more interesting, as you then have to consider which number (or numbers) maximizes the sum.\\n\\nSo for `nums = [-1, -2, -3]`, the maximum subarray would be `[-1]`, and the maximum subarray sum would be -1, because -1 is greater than -2 and -3."
                    },
                    {
                        "username": "shubham_srivastav",
                        "content": "how can i conceder that the resultante subarray length i right?"
                    },
                    {
                        "username": "caroline_",
                        "content": "Hmm so in the case of test case [-1] apparently the optimal solution is -1 and not 0. This doesn\\'t seem right to me; a subarray of length 0 provides a higher sum technically, no?\\n\\nAnyway this is the type of thing one should ask the interviewer so I guess it doesn\\'t matter :)"
                    },
                    {
                        "username": "SmoothCriminalOww",
                        "content": "Largest sum right? why are we required to get a subarray with negative values for eg -1 in requirements?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The idea is to find the subarray that has the \"maximum sum\". In your example of an array with all negative values (e.g., [-1, -2, -3]), a subarray with a single element of -1 does provide the maximum sum. Although it\\'s a negative value, -1 is greater than -2 and -3. \\n\\nThe purpose of this requirement is to find the maximum sum of a continuous sub-sequence in the array, even if the maximum sum is negative. It adds more complexity to the problem as compared to simply discarding all negative numbers. \\n\\nSo even if the input array only has negative numbers, we don\\'t consider the maximum sum to be 0 by choosing an empty subarray; instead, we consider the maximum negative number as the maximum sum. If we allowed an empty subarray to be the maximum, then the solution for any input array with all negative numbers would be 0, which simplifies the problem and ignores the fact that a higher (less negative) number is actually \"greater\" than a lower (more negative) number."
                    },
                    {
                        "username": "daring-calf",
                        "content": "OMFG!!! After a year of leetcoding, I figured out the Kadane\\'s algorithm by myself in 2 hours!\\nI\\'m invincible now!!"
                    },
                    {
                        "username": "AssetDali",
                        "content": "Hint: if the the subarray has the largest sum, then the remaining elements have the minimum sum(either negative or no elements)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Actually, that hint isn\\'t entirely correct. It\\'s possible for a subarray with the maximum sum to not leave the remaining elements with the minimum sum. Consider the array [2, 1, -3, 4, -1, 2, 1, -5, 4]. The subarray with the largest sum is [4, -1, 2, 1] with a sum of 6. However, the remaining elements [2, 1, -3, -5, 4] don\\'t necessarily sum to the minimum possible sum in this array.\\n\\nWhat we can say is that if we\\'re trying to find the subarray with the maximum sum, it doesn\\'t make sense to include a prefix or suffix of negative numbers in that subarray. That\\'s because removing that prefix or suffix would lead to a higher sum.\\n\\nSo in the array [2, 1, -3, 4, -1, 2, 1, -5, 4], the subarray [4, -1, 2, 1] does not include the prefix [-3] or the suffix [-5], because doing so would lead to a smaller sum.\\n\\nA better hint might be: \\n\\nWhen examining the elements in the array, if the current element plus the running total (subarray sum up to this point) is less than the current element itself, then the running total should be discarded (set to zero) and start a new subarray from the current element. This is because a maximum subarray sum will never include a previous sum that is negative, it is better to start a new sum from the current element. This is the core idea behind Kadane\\'s algorithm."
                    }
                ]
            },
            {
                "id": 1889374,
                "content": [
                    {
                        "username": "london804",
                        "content": "Example 3:\nInput: nums = [5,4,-1,7,8]\nOutput: 23\nExplanation: The subarray [5,4,-1,7,8] has the largest sum 23. \nHow is Example 3 a subarray? Shouldn't the answer be 15"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of this problem, a \"subarray\" of an array is a contiguous portion of the array. A subarray could consist of any number of elements, from a single element up to the entire array. So, in Example 3, [5,4,-1,7,8] is considered a subarray of the original array [5,4,-1,7,8] -- in fact, it\\'s the entire array.\\n\\nThe subarray with the largest sum is [5,4,-1,7,8], and the sum of this subarray is 5+4+(-1)+7+8 = 23, not 15. The algorithm is trying to find the maximum sum that can be obtained from a subarray, not the maximum length or number of positive numbers in a subarray.\\n\\nSo the output 23 is correct for this example."
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "I have question. the problem indicate the nums element constraint can be from -10^4 to 10^4 which means the whole array can be negative nums even tho there is not a single test case that all array contains negative nums"
                    },
                    {
                        "username": "bparanj",
                        "content": "Just because the constraints allow for elements to be in the range -10^4 to 10^4, it doesn\\'t mean that all the test cases will have all negative numbers. The constraints are there to provide the boundaries within which your solution must work, but the actual test cases used to evaluate your solution can be anything within those boundaries, including cases where all elements are negative, all elements are positive, or a mix of positive and negative elements.\\n\\nFor the Maximum Subarray problem, if all the elements in the input array are negative, then the maximum subarray is simply the element with the least negative value (i.e., the element closest to zero). This is because adding negative numbers together only makes the sum more negative.\\n\\nFor example, if you have an input array like `[-3, -2, -1]`, the maximum subarray is simply `[-1]`, and the maximum sum is `-1`.\\n"
                    },
                    {
                        "username": "jaweriazaman",
                        "content": "why we use vectors here"
                    },
                    {
                        "username": "kalasaniuday",
                        "content": "Here, what if all the integers are negative?\\nfor example, [-1,-9, -2,-5] then largest sum subarray might be [-1], but how can we assume empty subarray equals to zero."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of the Maximum Subarray problem, an empty subarray is generally not considered, as the problem constraints specify that the size of the input array `nums` is at least 1. \\n\\nIf all the numbers in the array are negative, then the maximum subarray would be the subarray containing the single number with the least negative value (i.e., the number closest to zero). So, for the example `[-1,-9, -2,-5]`, the maximum subarray is indeed `[-1]`.\\n\\nThere\\'s no need to consider an empty subarray in this case, because an empty subarray would have a sum of zero, which would be less than any non-negative number and only more than negative numbers. Since the array always contains at least one number, the maximum subarray sum will always be at least as large as the maximum individual number.\\n\\nIf you are using Kadane\\'s algorithm to solve this problem, it essentially does the same thing - it maintains a running sum of the array, and if the sum becomes negative at any point, it resets the sum to zero (effectively \"discarding\" the previous numbers), because a negative sum would only decrease the total sum if we were to add more positive numbers to it. However, the algorithm also keeps track of the maximum sum it has seen so far, so even if all the numbers are negative, it will still return the least negative number as the maximum subarray sum.\\n\\nHere\\'s the algorithm for reference:\\n\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        max_sum = nums[0]\\n        curr_sum = 0\\n        for num in nums:\\n            if curr_sum < 0:\\n                curr_sum = 0\\n            curr_sum += num\\n            max_sum = max(max_sum, curr_sum)\\n        return max_sum\\n```\\nIn the case of all negative numbers, `curr_sum` would always be reset to 0, but `max_sum` would keep track of the maximum (least negative) number seen."
                    },
                    {
                        "username": "kuznetsov-m",
                        "content": "For example nums = [-1, -2, -3]\nWhy subarray can't be empty and maxSubArray = 0?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of the Maximum Subarray problem, the definition of a subarray typically requires that it contains at least one element. An empty set does not constitute a subarray as per this definition. Therefore, in the case of `nums = [-1, -2, -3]`, the maximum subarray cannot be empty and the maximum subarray sum cannot be 0.\\n\\nIf you consider an empty subarray as valid and having a sum of 0, then for any array that only has negative numbers, the maximum subarray would always be an empty set and the maximum sum would always be 0. But by requiring that a subarray contains at least one number, the problem becomes more interesting, as you then have to consider which number (or numbers) maximizes the sum.\\n\\nSo for `nums = [-1, -2, -3]`, the maximum subarray would be `[-1]`, and the maximum subarray sum would be -1, because -1 is greater than -2 and -3."
                    },
                    {
                        "username": "shubham_srivastav",
                        "content": "how can i conceder that the resultante subarray length i right?"
                    },
                    {
                        "username": "caroline_",
                        "content": "Hmm so in the case of test case [-1] apparently the optimal solution is -1 and not 0. This doesn\\'t seem right to me; a subarray of length 0 provides a higher sum technically, no?\\n\\nAnyway this is the type of thing one should ask the interviewer so I guess it doesn\\'t matter :)"
                    },
                    {
                        "username": "SmoothCriminalOww",
                        "content": "Largest sum right? why are we required to get a subarray with negative values for eg -1 in requirements?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The idea is to find the subarray that has the \"maximum sum\". In your example of an array with all negative values (e.g., [-1, -2, -3]), a subarray with a single element of -1 does provide the maximum sum. Although it\\'s a negative value, -1 is greater than -2 and -3. \\n\\nThe purpose of this requirement is to find the maximum sum of a continuous sub-sequence in the array, even if the maximum sum is negative. It adds more complexity to the problem as compared to simply discarding all negative numbers. \\n\\nSo even if the input array only has negative numbers, we don\\'t consider the maximum sum to be 0 by choosing an empty subarray; instead, we consider the maximum negative number as the maximum sum. If we allowed an empty subarray to be the maximum, then the solution for any input array with all negative numbers would be 0, which simplifies the problem and ignores the fact that a higher (less negative) number is actually \"greater\" than a lower (more negative) number."
                    },
                    {
                        "username": "daring-calf",
                        "content": "OMFG!!! After a year of leetcoding, I figured out the Kadane\\'s algorithm by myself in 2 hours!\\nI\\'m invincible now!!"
                    },
                    {
                        "username": "AssetDali",
                        "content": "Hint: if the the subarray has the largest sum, then the remaining elements have the minimum sum(either negative or no elements)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Actually, that hint isn\\'t entirely correct. It\\'s possible for a subarray with the maximum sum to not leave the remaining elements with the minimum sum. Consider the array [2, 1, -3, 4, -1, 2, 1, -5, 4]. The subarray with the largest sum is [4, -1, 2, 1] with a sum of 6. However, the remaining elements [2, 1, -3, -5, 4] don\\'t necessarily sum to the minimum possible sum in this array.\\n\\nWhat we can say is that if we\\'re trying to find the subarray with the maximum sum, it doesn\\'t make sense to include a prefix or suffix of negative numbers in that subarray. That\\'s because removing that prefix or suffix would lead to a higher sum.\\n\\nSo in the array [2, 1, -3, 4, -1, 2, 1, -5, 4], the subarray [4, -1, 2, 1] does not include the prefix [-3] or the suffix [-5], because doing so would lead to a smaller sum.\\n\\nA better hint might be: \\n\\nWhen examining the elements in the array, if the current element plus the running total (subarray sum up to this point) is less than the current element itself, then the running total should be discarded (set to zero) and start a new subarray from the current element. This is because a maximum subarray sum will never include a previous sum that is negative, it is better to start a new sum from the current element. This is the core idea behind Kadane\\'s algorithm."
                    }
                ]
            },
            {
                "id": 1880559,
                "content": [
                    {
                        "username": "london804",
                        "content": "Example 3:\nInput: nums = [5,4,-1,7,8]\nOutput: 23\nExplanation: The subarray [5,4,-1,7,8] has the largest sum 23. \nHow is Example 3 a subarray? Shouldn't the answer be 15"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of this problem, a \"subarray\" of an array is a contiguous portion of the array. A subarray could consist of any number of elements, from a single element up to the entire array. So, in Example 3, [5,4,-1,7,8] is considered a subarray of the original array [5,4,-1,7,8] -- in fact, it\\'s the entire array.\\n\\nThe subarray with the largest sum is [5,4,-1,7,8], and the sum of this subarray is 5+4+(-1)+7+8 = 23, not 15. The algorithm is trying to find the maximum sum that can be obtained from a subarray, not the maximum length or number of positive numbers in a subarray.\\n\\nSo the output 23 is correct for this example."
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "I have question. the problem indicate the nums element constraint can be from -10^4 to 10^4 which means the whole array can be negative nums even tho there is not a single test case that all array contains negative nums"
                    },
                    {
                        "username": "bparanj",
                        "content": "Just because the constraints allow for elements to be in the range -10^4 to 10^4, it doesn\\'t mean that all the test cases will have all negative numbers. The constraints are there to provide the boundaries within which your solution must work, but the actual test cases used to evaluate your solution can be anything within those boundaries, including cases where all elements are negative, all elements are positive, or a mix of positive and negative elements.\\n\\nFor the Maximum Subarray problem, if all the elements in the input array are negative, then the maximum subarray is simply the element with the least negative value (i.e., the element closest to zero). This is because adding negative numbers together only makes the sum more negative.\\n\\nFor example, if you have an input array like `[-3, -2, -1]`, the maximum subarray is simply `[-1]`, and the maximum sum is `-1`.\\n"
                    },
                    {
                        "username": "jaweriazaman",
                        "content": "why we use vectors here"
                    },
                    {
                        "username": "kalasaniuday",
                        "content": "Here, what if all the integers are negative?\\nfor example, [-1,-9, -2,-5] then largest sum subarray might be [-1], but how can we assume empty subarray equals to zero."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of the Maximum Subarray problem, an empty subarray is generally not considered, as the problem constraints specify that the size of the input array `nums` is at least 1. \\n\\nIf all the numbers in the array are negative, then the maximum subarray would be the subarray containing the single number with the least negative value (i.e., the number closest to zero). So, for the example `[-1,-9, -2,-5]`, the maximum subarray is indeed `[-1]`.\\n\\nThere\\'s no need to consider an empty subarray in this case, because an empty subarray would have a sum of zero, which would be less than any non-negative number and only more than negative numbers. Since the array always contains at least one number, the maximum subarray sum will always be at least as large as the maximum individual number.\\n\\nIf you are using Kadane\\'s algorithm to solve this problem, it essentially does the same thing - it maintains a running sum of the array, and if the sum becomes negative at any point, it resets the sum to zero (effectively \"discarding\" the previous numbers), because a negative sum would only decrease the total sum if we were to add more positive numbers to it. However, the algorithm also keeps track of the maximum sum it has seen so far, so even if all the numbers are negative, it will still return the least negative number as the maximum subarray sum.\\n\\nHere\\'s the algorithm for reference:\\n\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        max_sum = nums[0]\\n        curr_sum = 0\\n        for num in nums:\\n            if curr_sum < 0:\\n                curr_sum = 0\\n            curr_sum += num\\n            max_sum = max(max_sum, curr_sum)\\n        return max_sum\\n```\\nIn the case of all negative numbers, `curr_sum` would always be reset to 0, but `max_sum` would keep track of the maximum (least negative) number seen."
                    },
                    {
                        "username": "kuznetsov-m",
                        "content": "For example nums = [-1, -2, -3]\nWhy subarray can't be empty and maxSubArray = 0?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of the Maximum Subarray problem, the definition of a subarray typically requires that it contains at least one element. An empty set does not constitute a subarray as per this definition. Therefore, in the case of `nums = [-1, -2, -3]`, the maximum subarray cannot be empty and the maximum subarray sum cannot be 0.\\n\\nIf you consider an empty subarray as valid and having a sum of 0, then for any array that only has negative numbers, the maximum subarray would always be an empty set and the maximum sum would always be 0. But by requiring that a subarray contains at least one number, the problem becomes more interesting, as you then have to consider which number (or numbers) maximizes the sum.\\n\\nSo for `nums = [-1, -2, -3]`, the maximum subarray would be `[-1]`, and the maximum subarray sum would be -1, because -1 is greater than -2 and -3."
                    },
                    {
                        "username": "shubham_srivastav",
                        "content": "how can i conceder that the resultante subarray length i right?"
                    },
                    {
                        "username": "caroline_",
                        "content": "Hmm so in the case of test case [-1] apparently the optimal solution is -1 and not 0. This doesn\\'t seem right to me; a subarray of length 0 provides a higher sum technically, no?\\n\\nAnyway this is the type of thing one should ask the interviewer so I guess it doesn\\'t matter :)"
                    },
                    {
                        "username": "SmoothCriminalOww",
                        "content": "Largest sum right? why are we required to get a subarray with negative values for eg -1 in requirements?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The idea is to find the subarray that has the \"maximum sum\". In your example of an array with all negative values (e.g., [-1, -2, -3]), a subarray with a single element of -1 does provide the maximum sum. Although it\\'s a negative value, -1 is greater than -2 and -3. \\n\\nThe purpose of this requirement is to find the maximum sum of a continuous sub-sequence in the array, even if the maximum sum is negative. It adds more complexity to the problem as compared to simply discarding all negative numbers. \\n\\nSo even if the input array only has negative numbers, we don\\'t consider the maximum sum to be 0 by choosing an empty subarray; instead, we consider the maximum negative number as the maximum sum. If we allowed an empty subarray to be the maximum, then the solution for any input array with all negative numbers would be 0, which simplifies the problem and ignores the fact that a higher (less negative) number is actually \"greater\" than a lower (more negative) number."
                    },
                    {
                        "username": "daring-calf",
                        "content": "OMFG!!! After a year of leetcoding, I figured out the Kadane\\'s algorithm by myself in 2 hours!\\nI\\'m invincible now!!"
                    },
                    {
                        "username": "AssetDali",
                        "content": "Hint: if the the subarray has the largest sum, then the remaining elements have the minimum sum(either negative or no elements)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Actually, that hint isn\\'t entirely correct. It\\'s possible for a subarray with the maximum sum to not leave the remaining elements with the minimum sum. Consider the array [2, 1, -3, 4, -1, 2, 1, -5, 4]. The subarray with the largest sum is [4, -1, 2, 1] with a sum of 6. However, the remaining elements [2, 1, -3, -5, 4] don\\'t necessarily sum to the minimum possible sum in this array.\\n\\nWhat we can say is that if we\\'re trying to find the subarray with the maximum sum, it doesn\\'t make sense to include a prefix or suffix of negative numbers in that subarray. That\\'s because removing that prefix or suffix would lead to a higher sum.\\n\\nSo in the array [2, 1, -3, 4, -1, 2, 1, -5, 4], the subarray [4, -1, 2, 1] does not include the prefix [-3] or the suffix [-5], because doing so would lead to a smaller sum.\\n\\nA better hint might be: \\n\\nWhen examining the elements in the array, if the current element plus the running total (subarray sum up to this point) is less than the current element itself, then the running total should be discarded (set to zero) and start a new subarray from the current element. This is because a maximum subarray sum will never include a previous sum that is negative, it is better to start a new sum from the current element. This is the core idea behind Kadane\\'s algorithm."
                    }
                ]
            },
            {
                "id": 1874197,
                "content": [
                    {
                        "username": "london804",
                        "content": "Example 3:\nInput: nums = [5,4,-1,7,8]\nOutput: 23\nExplanation: The subarray [5,4,-1,7,8] has the largest sum 23. \nHow is Example 3 a subarray? Shouldn't the answer be 15"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of this problem, a \"subarray\" of an array is a contiguous portion of the array. A subarray could consist of any number of elements, from a single element up to the entire array. So, in Example 3, [5,4,-1,7,8] is considered a subarray of the original array [5,4,-1,7,8] -- in fact, it\\'s the entire array.\\n\\nThe subarray with the largest sum is [5,4,-1,7,8], and the sum of this subarray is 5+4+(-1)+7+8 = 23, not 15. The algorithm is trying to find the maximum sum that can be obtained from a subarray, not the maximum length or number of positive numbers in a subarray.\\n\\nSo the output 23 is correct for this example."
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "I have question. the problem indicate the nums element constraint can be from -10^4 to 10^4 which means the whole array can be negative nums even tho there is not a single test case that all array contains negative nums"
                    },
                    {
                        "username": "bparanj",
                        "content": "Just because the constraints allow for elements to be in the range -10^4 to 10^4, it doesn\\'t mean that all the test cases will have all negative numbers. The constraints are there to provide the boundaries within which your solution must work, but the actual test cases used to evaluate your solution can be anything within those boundaries, including cases where all elements are negative, all elements are positive, or a mix of positive and negative elements.\\n\\nFor the Maximum Subarray problem, if all the elements in the input array are negative, then the maximum subarray is simply the element with the least negative value (i.e., the element closest to zero). This is because adding negative numbers together only makes the sum more negative.\\n\\nFor example, if you have an input array like `[-3, -2, -1]`, the maximum subarray is simply `[-1]`, and the maximum sum is `-1`.\\n"
                    },
                    {
                        "username": "jaweriazaman",
                        "content": "why we use vectors here"
                    },
                    {
                        "username": "kalasaniuday",
                        "content": "Here, what if all the integers are negative?\\nfor example, [-1,-9, -2,-5] then largest sum subarray might be [-1], but how can we assume empty subarray equals to zero."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of the Maximum Subarray problem, an empty subarray is generally not considered, as the problem constraints specify that the size of the input array `nums` is at least 1. \\n\\nIf all the numbers in the array are negative, then the maximum subarray would be the subarray containing the single number with the least negative value (i.e., the number closest to zero). So, for the example `[-1,-9, -2,-5]`, the maximum subarray is indeed `[-1]`.\\n\\nThere\\'s no need to consider an empty subarray in this case, because an empty subarray would have a sum of zero, which would be less than any non-negative number and only more than negative numbers. Since the array always contains at least one number, the maximum subarray sum will always be at least as large as the maximum individual number.\\n\\nIf you are using Kadane\\'s algorithm to solve this problem, it essentially does the same thing - it maintains a running sum of the array, and if the sum becomes negative at any point, it resets the sum to zero (effectively \"discarding\" the previous numbers), because a negative sum would only decrease the total sum if we were to add more positive numbers to it. However, the algorithm also keeps track of the maximum sum it has seen so far, so even if all the numbers are negative, it will still return the least negative number as the maximum subarray sum.\\n\\nHere\\'s the algorithm for reference:\\n\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        max_sum = nums[0]\\n        curr_sum = 0\\n        for num in nums:\\n            if curr_sum < 0:\\n                curr_sum = 0\\n            curr_sum += num\\n            max_sum = max(max_sum, curr_sum)\\n        return max_sum\\n```\\nIn the case of all negative numbers, `curr_sum` would always be reset to 0, but `max_sum` would keep track of the maximum (least negative) number seen."
                    },
                    {
                        "username": "kuznetsov-m",
                        "content": "For example nums = [-1, -2, -3]\nWhy subarray can't be empty and maxSubArray = 0?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of the Maximum Subarray problem, the definition of a subarray typically requires that it contains at least one element. An empty set does not constitute a subarray as per this definition. Therefore, in the case of `nums = [-1, -2, -3]`, the maximum subarray cannot be empty and the maximum subarray sum cannot be 0.\\n\\nIf you consider an empty subarray as valid and having a sum of 0, then for any array that only has negative numbers, the maximum subarray would always be an empty set and the maximum sum would always be 0. But by requiring that a subarray contains at least one number, the problem becomes more interesting, as you then have to consider which number (or numbers) maximizes the sum.\\n\\nSo for `nums = [-1, -2, -3]`, the maximum subarray would be `[-1]`, and the maximum subarray sum would be -1, because -1 is greater than -2 and -3."
                    },
                    {
                        "username": "shubham_srivastav",
                        "content": "how can i conceder that the resultante subarray length i right?"
                    },
                    {
                        "username": "caroline_",
                        "content": "Hmm so in the case of test case [-1] apparently the optimal solution is -1 and not 0. This doesn\\'t seem right to me; a subarray of length 0 provides a higher sum technically, no?\\n\\nAnyway this is the type of thing one should ask the interviewer so I guess it doesn\\'t matter :)"
                    },
                    {
                        "username": "SmoothCriminalOww",
                        "content": "Largest sum right? why are we required to get a subarray with negative values for eg -1 in requirements?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The idea is to find the subarray that has the \"maximum sum\". In your example of an array with all negative values (e.g., [-1, -2, -3]), a subarray with a single element of -1 does provide the maximum sum. Although it\\'s a negative value, -1 is greater than -2 and -3. \\n\\nThe purpose of this requirement is to find the maximum sum of a continuous sub-sequence in the array, even if the maximum sum is negative. It adds more complexity to the problem as compared to simply discarding all negative numbers. \\n\\nSo even if the input array only has negative numbers, we don\\'t consider the maximum sum to be 0 by choosing an empty subarray; instead, we consider the maximum negative number as the maximum sum. If we allowed an empty subarray to be the maximum, then the solution for any input array with all negative numbers would be 0, which simplifies the problem and ignores the fact that a higher (less negative) number is actually \"greater\" than a lower (more negative) number."
                    },
                    {
                        "username": "daring-calf",
                        "content": "OMFG!!! After a year of leetcoding, I figured out the Kadane\\'s algorithm by myself in 2 hours!\\nI\\'m invincible now!!"
                    },
                    {
                        "username": "AssetDali",
                        "content": "Hint: if the the subarray has the largest sum, then the remaining elements have the minimum sum(either negative or no elements)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Actually, that hint isn\\'t entirely correct. It\\'s possible for a subarray with the maximum sum to not leave the remaining elements with the minimum sum. Consider the array [2, 1, -3, 4, -1, 2, 1, -5, 4]. The subarray with the largest sum is [4, -1, 2, 1] with a sum of 6. However, the remaining elements [2, 1, -3, -5, 4] don\\'t necessarily sum to the minimum possible sum in this array.\\n\\nWhat we can say is that if we\\'re trying to find the subarray with the maximum sum, it doesn\\'t make sense to include a prefix or suffix of negative numbers in that subarray. That\\'s because removing that prefix or suffix would lead to a higher sum.\\n\\nSo in the array [2, 1, -3, 4, -1, 2, 1, -5, 4], the subarray [4, -1, 2, 1] does not include the prefix [-3] or the suffix [-5], because doing so would lead to a smaller sum.\\n\\nA better hint might be: \\n\\nWhen examining the elements in the array, if the current element plus the running total (subarray sum up to this point) is less than the current element itself, then the running total should be discarded (set to zero) and start a new subarray from the current element. This is because a maximum subarray sum will never include a previous sum that is negative, it is better to start a new sum from the current element. This is the core idea behind Kadane\\'s algorithm."
                    }
                ]
            },
            {
                "id": 1873146,
                "content": [
                    {
                        "username": "london804",
                        "content": "Example 3:\nInput: nums = [5,4,-1,7,8]\nOutput: 23\nExplanation: The subarray [5,4,-1,7,8] has the largest sum 23. \nHow is Example 3 a subarray? Shouldn't the answer be 15"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of this problem, a \"subarray\" of an array is a contiguous portion of the array. A subarray could consist of any number of elements, from a single element up to the entire array. So, in Example 3, [5,4,-1,7,8] is considered a subarray of the original array [5,4,-1,7,8] -- in fact, it\\'s the entire array.\\n\\nThe subarray with the largest sum is [5,4,-1,7,8], and the sum of this subarray is 5+4+(-1)+7+8 = 23, not 15. The algorithm is trying to find the maximum sum that can be obtained from a subarray, not the maximum length or number of positive numbers in a subarray.\\n\\nSo the output 23 is correct for this example."
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "I have question. the problem indicate the nums element constraint can be from -10^4 to 10^4 which means the whole array can be negative nums even tho there is not a single test case that all array contains negative nums"
                    },
                    {
                        "username": "bparanj",
                        "content": "Just because the constraints allow for elements to be in the range -10^4 to 10^4, it doesn\\'t mean that all the test cases will have all negative numbers. The constraints are there to provide the boundaries within which your solution must work, but the actual test cases used to evaluate your solution can be anything within those boundaries, including cases where all elements are negative, all elements are positive, or a mix of positive and negative elements.\\n\\nFor the Maximum Subarray problem, if all the elements in the input array are negative, then the maximum subarray is simply the element with the least negative value (i.e., the element closest to zero). This is because adding negative numbers together only makes the sum more negative.\\n\\nFor example, if you have an input array like `[-3, -2, -1]`, the maximum subarray is simply `[-1]`, and the maximum sum is `-1`.\\n"
                    },
                    {
                        "username": "jaweriazaman",
                        "content": "why we use vectors here"
                    },
                    {
                        "username": "kalasaniuday",
                        "content": "Here, what if all the integers are negative?\\nfor example, [-1,-9, -2,-5] then largest sum subarray might be [-1], but how can we assume empty subarray equals to zero."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of the Maximum Subarray problem, an empty subarray is generally not considered, as the problem constraints specify that the size of the input array `nums` is at least 1. \\n\\nIf all the numbers in the array are negative, then the maximum subarray would be the subarray containing the single number with the least negative value (i.e., the number closest to zero). So, for the example `[-1,-9, -2,-5]`, the maximum subarray is indeed `[-1]`.\\n\\nThere\\'s no need to consider an empty subarray in this case, because an empty subarray would have a sum of zero, which would be less than any non-negative number and only more than negative numbers. Since the array always contains at least one number, the maximum subarray sum will always be at least as large as the maximum individual number.\\n\\nIf you are using Kadane\\'s algorithm to solve this problem, it essentially does the same thing - it maintains a running sum of the array, and if the sum becomes negative at any point, it resets the sum to zero (effectively \"discarding\" the previous numbers), because a negative sum would only decrease the total sum if we were to add more positive numbers to it. However, the algorithm also keeps track of the maximum sum it has seen so far, so even if all the numbers are negative, it will still return the least negative number as the maximum subarray sum.\\n\\nHere\\'s the algorithm for reference:\\n\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        max_sum = nums[0]\\n        curr_sum = 0\\n        for num in nums:\\n            if curr_sum < 0:\\n                curr_sum = 0\\n            curr_sum += num\\n            max_sum = max(max_sum, curr_sum)\\n        return max_sum\\n```\\nIn the case of all negative numbers, `curr_sum` would always be reset to 0, but `max_sum` would keep track of the maximum (least negative) number seen."
                    },
                    {
                        "username": "kuznetsov-m",
                        "content": "For example nums = [-1, -2, -3]\nWhy subarray can't be empty and maxSubArray = 0?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of the Maximum Subarray problem, the definition of a subarray typically requires that it contains at least one element. An empty set does not constitute a subarray as per this definition. Therefore, in the case of `nums = [-1, -2, -3]`, the maximum subarray cannot be empty and the maximum subarray sum cannot be 0.\\n\\nIf you consider an empty subarray as valid and having a sum of 0, then for any array that only has negative numbers, the maximum subarray would always be an empty set and the maximum sum would always be 0. But by requiring that a subarray contains at least one number, the problem becomes more interesting, as you then have to consider which number (or numbers) maximizes the sum.\\n\\nSo for `nums = [-1, -2, -3]`, the maximum subarray would be `[-1]`, and the maximum subarray sum would be -1, because -1 is greater than -2 and -3."
                    },
                    {
                        "username": "shubham_srivastav",
                        "content": "how can i conceder that the resultante subarray length i right?"
                    },
                    {
                        "username": "caroline_",
                        "content": "Hmm so in the case of test case [-1] apparently the optimal solution is -1 and not 0. This doesn\\'t seem right to me; a subarray of length 0 provides a higher sum technically, no?\\n\\nAnyway this is the type of thing one should ask the interviewer so I guess it doesn\\'t matter :)"
                    },
                    {
                        "username": "SmoothCriminalOww",
                        "content": "Largest sum right? why are we required to get a subarray with negative values for eg -1 in requirements?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The idea is to find the subarray that has the \"maximum sum\". In your example of an array with all negative values (e.g., [-1, -2, -3]), a subarray with a single element of -1 does provide the maximum sum. Although it\\'s a negative value, -1 is greater than -2 and -3. \\n\\nThe purpose of this requirement is to find the maximum sum of a continuous sub-sequence in the array, even if the maximum sum is negative. It adds more complexity to the problem as compared to simply discarding all negative numbers. \\n\\nSo even if the input array only has negative numbers, we don\\'t consider the maximum sum to be 0 by choosing an empty subarray; instead, we consider the maximum negative number as the maximum sum. If we allowed an empty subarray to be the maximum, then the solution for any input array with all negative numbers would be 0, which simplifies the problem and ignores the fact that a higher (less negative) number is actually \"greater\" than a lower (more negative) number."
                    },
                    {
                        "username": "daring-calf",
                        "content": "OMFG!!! After a year of leetcoding, I figured out the Kadane\\'s algorithm by myself in 2 hours!\\nI\\'m invincible now!!"
                    },
                    {
                        "username": "AssetDali",
                        "content": "Hint: if the the subarray has the largest sum, then the remaining elements have the minimum sum(either negative or no elements)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Actually, that hint isn\\'t entirely correct. It\\'s possible for a subarray with the maximum sum to not leave the remaining elements with the minimum sum. Consider the array [2, 1, -3, 4, -1, 2, 1, -5, 4]. The subarray with the largest sum is [4, -1, 2, 1] with a sum of 6. However, the remaining elements [2, 1, -3, -5, 4] don\\'t necessarily sum to the minimum possible sum in this array.\\n\\nWhat we can say is that if we\\'re trying to find the subarray with the maximum sum, it doesn\\'t make sense to include a prefix or suffix of negative numbers in that subarray. That\\'s because removing that prefix or suffix would lead to a higher sum.\\n\\nSo in the array [2, 1, -3, 4, -1, 2, 1, -5, 4], the subarray [4, -1, 2, 1] does not include the prefix [-3] or the suffix [-5], because doing so would lead to a smaller sum.\\n\\nA better hint might be: \\n\\nWhen examining the elements in the array, if the current element plus the running total (subarray sum up to this point) is less than the current element itself, then the running total should be discarded (set to zero) and start a new subarray from the current element. This is because a maximum subarray sum will never include a previous sum that is negative, it is better to start a new sum from the current element. This is the core idea behind Kadane\\'s algorithm."
                    }
                ]
            },
            {
                "id": 1872667,
                "content": [
                    {
                        "username": "london804",
                        "content": "Example 3:\nInput: nums = [5,4,-1,7,8]\nOutput: 23\nExplanation: The subarray [5,4,-1,7,8] has the largest sum 23. \nHow is Example 3 a subarray? Shouldn't the answer be 15"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of this problem, a \"subarray\" of an array is a contiguous portion of the array. A subarray could consist of any number of elements, from a single element up to the entire array. So, in Example 3, [5,4,-1,7,8] is considered a subarray of the original array [5,4,-1,7,8] -- in fact, it\\'s the entire array.\\n\\nThe subarray with the largest sum is [5,4,-1,7,8], and the sum of this subarray is 5+4+(-1)+7+8 = 23, not 15. The algorithm is trying to find the maximum sum that can be obtained from a subarray, not the maximum length or number of positive numbers in a subarray.\\n\\nSo the output 23 is correct for this example."
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "I have question. the problem indicate the nums element constraint can be from -10^4 to 10^4 which means the whole array can be negative nums even tho there is not a single test case that all array contains negative nums"
                    },
                    {
                        "username": "bparanj",
                        "content": "Just because the constraints allow for elements to be in the range -10^4 to 10^4, it doesn\\'t mean that all the test cases will have all negative numbers. The constraints are there to provide the boundaries within which your solution must work, but the actual test cases used to evaluate your solution can be anything within those boundaries, including cases where all elements are negative, all elements are positive, or a mix of positive and negative elements.\\n\\nFor the Maximum Subarray problem, if all the elements in the input array are negative, then the maximum subarray is simply the element with the least negative value (i.e., the element closest to zero). This is because adding negative numbers together only makes the sum more negative.\\n\\nFor example, if you have an input array like `[-3, -2, -1]`, the maximum subarray is simply `[-1]`, and the maximum sum is `-1`.\\n"
                    },
                    {
                        "username": "jaweriazaman",
                        "content": "why we use vectors here"
                    },
                    {
                        "username": "kalasaniuday",
                        "content": "Here, what if all the integers are negative?\\nfor example, [-1,-9, -2,-5] then largest sum subarray might be [-1], but how can we assume empty subarray equals to zero."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of the Maximum Subarray problem, an empty subarray is generally not considered, as the problem constraints specify that the size of the input array `nums` is at least 1. \\n\\nIf all the numbers in the array are negative, then the maximum subarray would be the subarray containing the single number with the least negative value (i.e., the number closest to zero). So, for the example `[-1,-9, -2,-5]`, the maximum subarray is indeed `[-1]`.\\n\\nThere\\'s no need to consider an empty subarray in this case, because an empty subarray would have a sum of zero, which would be less than any non-negative number and only more than negative numbers. Since the array always contains at least one number, the maximum subarray sum will always be at least as large as the maximum individual number.\\n\\nIf you are using Kadane\\'s algorithm to solve this problem, it essentially does the same thing - it maintains a running sum of the array, and if the sum becomes negative at any point, it resets the sum to zero (effectively \"discarding\" the previous numbers), because a negative sum would only decrease the total sum if we were to add more positive numbers to it. However, the algorithm also keeps track of the maximum sum it has seen so far, so even if all the numbers are negative, it will still return the least negative number as the maximum subarray sum.\\n\\nHere\\'s the algorithm for reference:\\n\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        max_sum = nums[0]\\n        curr_sum = 0\\n        for num in nums:\\n            if curr_sum < 0:\\n                curr_sum = 0\\n            curr_sum += num\\n            max_sum = max(max_sum, curr_sum)\\n        return max_sum\\n```\\nIn the case of all negative numbers, `curr_sum` would always be reset to 0, but `max_sum` would keep track of the maximum (least negative) number seen."
                    },
                    {
                        "username": "kuznetsov-m",
                        "content": "For example nums = [-1, -2, -3]\nWhy subarray can't be empty and maxSubArray = 0?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of the Maximum Subarray problem, the definition of a subarray typically requires that it contains at least one element. An empty set does not constitute a subarray as per this definition. Therefore, in the case of `nums = [-1, -2, -3]`, the maximum subarray cannot be empty and the maximum subarray sum cannot be 0.\\n\\nIf you consider an empty subarray as valid and having a sum of 0, then for any array that only has negative numbers, the maximum subarray would always be an empty set and the maximum sum would always be 0. But by requiring that a subarray contains at least one number, the problem becomes more interesting, as you then have to consider which number (or numbers) maximizes the sum.\\n\\nSo for `nums = [-1, -2, -3]`, the maximum subarray would be `[-1]`, and the maximum subarray sum would be -1, because -1 is greater than -2 and -3."
                    },
                    {
                        "username": "shubham_srivastav",
                        "content": "how can i conceder that the resultante subarray length i right?"
                    },
                    {
                        "username": "caroline_",
                        "content": "Hmm so in the case of test case [-1] apparently the optimal solution is -1 and not 0. This doesn\\'t seem right to me; a subarray of length 0 provides a higher sum technically, no?\\n\\nAnyway this is the type of thing one should ask the interviewer so I guess it doesn\\'t matter :)"
                    },
                    {
                        "username": "SmoothCriminalOww",
                        "content": "Largest sum right? why are we required to get a subarray with negative values for eg -1 in requirements?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The idea is to find the subarray that has the \"maximum sum\". In your example of an array with all negative values (e.g., [-1, -2, -3]), a subarray with a single element of -1 does provide the maximum sum. Although it\\'s a negative value, -1 is greater than -2 and -3. \\n\\nThe purpose of this requirement is to find the maximum sum of a continuous sub-sequence in the array, even if the maximum sum is negative. It adds more complexity to the problem as compared to simply discarding all negative numbers. \\n\\nSo even if the input array only has negative numbers, we don\\'t consider the maximum sum to be 0 by choosing an empty subarray; instead, we consider the maximum negative number as the maximum sum. If we allowed an empty subarray to be the maximum, then the solution for any input array with all negative numbers would be 0, which simplifies the problem and ignores the fact that a higher (less negative) number is actually \"greater\" than a lower (more negative) number."
                    },
                    {
                        "username": "daring-calf",
                        "content": "OMFG!!! After a year of leetcoding, I figured out the Kadane\\'s algorithm by myself in 2 hours!\\nI\\'m invincible now!!"
                    },
                    {
                        "username": "AssetDali",
                        "content": "Hint: if the the subarray has the largest sum, then the remaining elements have the minimum sum(either negative or no elements)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Actually, that hint isn\\'t entirely correct. It\\'s possible for a subarray with the maximum sum to not leave the remaining elements with the minimum sum. Consider the array [2, 1, -3, 4, -1, 2, 1, -5, 4]. The subarray with the largest sum is [4, -1, 2, 1] with a sum of 6. However, the remaining elements [2, 1, -3, -5, 4] don\\'t necessarily sum to the minimum possible sum in this array.\\n\\nWhat we can say is that if we\\'re trying to find the subarray with the maximum sum, it doesn\\'t make sense to include a prefix or suffix of negative numbers in that subarray. That\\'s because removing that prefix or suffix would lead to a higher sum.\\n\\nSo in the array [2, 1, -3, 4, -1, 2, 1, -5, 4], the subarray [4, -1, 2, 1] does not include the prefix [-3] or the suffix [-5], because doing so would lead to a smaller sum.\\n\\nA better hint might be: \\n\\nWhen examining the elements in the array, if the current element plus the running total (subarray sum up to this point) is less than the current element itself, then the running total should be discarded (set to zero) and start a new subarray from the current element. This is because a maximum subarray sum will never include a previous sum that is negative, it is better to start a new sum from the current element. This is the core idea behind Kadane\\'s algorithm."
                    }
                ]
            },
            {
                "id": 1867481,
                "content": [
                    {
                        "username": "london804",
                        "content": "Example 3:\nInput: nums = [5,4,-1,7,8]\nOutput: 23\nExplanation: The subarray [5,4,-1,7,8] has the largest sum 23. \nHow is Example 3 a subarray? Shouldn't the answer be 15"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of this problem, a \"subarray\" of an array is a contiguous portion of the array. A subarray could consist of any number of elements, from a single element up to the entire array. So, in Example 3, [5,4,-1,7,8] is considered a subarray of the original array [5,4,-1,7,8] -- in fact, it\\'s the entire array.\\n\\nThe subarray with the largest sum is [5,4,-1,7,8], and the sum of this subarray is 5+4+(-1)+7+8 = 23, not 15. The algorithm is trying to find the maximum sum that can be obtained from a subarray, not the maximum length or number of positive numbers in a subarray.\\n\\nSo the output 23 is correct for this example."
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "I have question. the problem indicate the nums element constraint can be from -10^4 to 10^4 which means the whole array can be negative nums even tho there is not a single test case that all array contains negative nums"
                    },
                    {
                        "username": "bparanj",
                        "content": "Just because the constraints allow for elements to be in the range -10^4 to 10^4, it doesn\\'t mean that all the test cases will have all negative numbers. The constraints are there to provide the boundaries within which your solution must work, but the actual test cases used to evaluate your solution can be anything within those boundaries, including cases where all elements are negative, all elements are positive, or a mix of positive and negative elements.\\n\\nFor the Maximum Subarray problem, if all the elements in the input array are negative, then the maximum subarray is simply the element with the least negative value (i.e., the element closest to zero). This is because adding negative numbers together only makes the sum more negative.\\n\\nFor example, if you have an input array like `[-3, -2, -1]`, the maximum subarray is simply `[-1]`, and the maximum sum is `-1`.\\n"
                    },
                    {
                        "username": "jaweriazaman",
                        "content": "why we use vectors here"
                    },
                    {
                        "username": "kalasaniuday",
                        "content": "Here, what if all the integers are negative?\\nfor example, [-1,-9, -2,-5] then largest sum subarray might be [-1], but how can we assume empty subarray equals to zero."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of the Maximum Subarray problem, an empty subarray is generally not considered, as the problem constraints specify that the size of the input array `nums` is at least 1. \\n\\nIf all the numbers in the array are negative, then the maximum subarray would be the subarray containing the single number with the least negative value (i.e., the number closest to zero). So, for the example `[-1,-9, -2,-5]`, the maximum subarray is indeed `[-1]`.\\n\\nThere\\'s no need to consider an empty subarray in this case, because an empty subarray would have a sum of zero, which would be less than any non-negative number and only more than negative numbers. Since the array always contains at least one number, the maximum subarray sum will always be at least as large as the maximum individual number.\\n\\nIf you are using Kadane\\'s algorithm to solve this problem, it essentially does the same thing - it maintains a running sum of the array, and if the sum becomes negative at any point, it resets the sum to zero (effectively \"discarding\" the previous numbers), because a negative sum would only decrease the total sum if we were to add more positive numbers to it. However, the algorithm also keeps track of the maximum sum it has seen so far, so even if all the numbers are negative, it will still return the least negative number as the maximum subarray sum.\\n\\nHere\\'s the algorithm for reference:\\n\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        max_sum = nums[0]\\n        curr_sum = 0\\n        for num in nums:\\n            if curr_sum < 0:\\n                curr_sum = 0\\n            curr_sum += num\\n            max_sum = max(max_sum, curr_sum)\\n        return max_sum\\n```\\nIn the case of all negative numbers, `curr_sum` would always be reset to 0, but `max_sum` would keep track of the maximum (least negative) number seen."
                    },
                    {
                        "username": "kuznetsov-m",
                        "content": "For example nums = [-1, -2, -3]\nWhy subarray can't be empty and maxSubArray = 0?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of the Maximum Subarray problem, the definition of a subarray typically requires that it contains at least one element. An empty set does not constitute a subarray as per this definition. Therefore, in the case of `nums = [-1, -2, -3]`, the maximum subarray cannot be empty and the maximum subarray sum cannot be 0.\\n\\nIf you consider an empty subarray as valid and having a sum of 0, then for any array that only has negative numbers, the maximum subarray would always be an empty set and the maximum sum would always be 0. But by requiring that a subarray contains at least one number, the problem becomes more interesting, as you then have to consider which number (or numbers) maximizes the sum.\\n\\nSo for `nums = [-1, -2, -3]`, the maximum subarray would be `[-1]`, and the maximum subarray sum would be -1, because -1 is greater than -2 and -3."
                    },
                    {
                        "username": "shubham_srivastav",
                        "content": "how can i conceder that the resultante subarray length i right?"
                    },
                    {
                        "username": "caroline_",
                        "content": "Hmm so in the case of test case [-1] apparently the optimal solution is -1 and not 0. This doesn\\'t seem right to me; a subarray of length 0 provides a higher sum technically, no?\\n\\nAnyway this is the type of thing one should ask the interviewer so I guess it doesn\\'t matter :)"
                    },
                    {
                        "username": "SmoothCriminalOww",
                        "content": "Largest sum right? why are we required to get a subarray with negative values for eg -1 in requirements?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The idea is to find the subarray that has the \"maximum sum\". In your example of an array with all negative values (e.g., [-1, -2, -3]), a subarray with a single element of -1 does provide the maximum sum. Although it\\'s a negative value, -1 is greater than -2 and -3. \\n\\nThe purpose of this requirement is to find the maximum sum of a continuous sub-sequence in the array, even if the maximum sum is negative. It adds more complexity to the problem as compared to simply discarding all negative numbers. \\n\\nSo even if the input array only has negative numbers, we don\\'t consider the maximum sum to be 0 by choosing an empty subarray; instead, we consider the maximum negative number as the maximum sum. If we allowed an empty subarray to be the maximum, then the solution for any input array with all negative numbers would be 0, which simplifies the problem and ignores the fact that a higher (less negative) number is actually \"greater\" than a lower (more negative) number."
                    },
                    {
                        "username": "daring-calf",
                        "content": "OMFG!!! After a year of leetcoding, I figured out the Kadane\\'s algorithm by myself in 2 hours!\\nI\\'m invincible now!!"
                    },
                    {
                        "username": "AssetDali",
                        "content": "Hint: if the the subarray has the largest sum, then the remaining elements have the minimum sum(either negative or no elements)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Actually, that hint isn\\'t entirely correct. It\\'s possible for a subarray with the maximum sum to not leave the remaining elements with the minimum sum. Consider the array [2, 1, -3, 4, -1, 2, 1, -5, 4]. The subarray with the largest sum is [4, -1, 2, 1] with a sum of 6. However, the remaining elements [2, 1, -3, -5, 4] don\\'t necessarily sum to the minimum possible sum in this array.\\n\\nWhat we can say is that if we\\'re trying to find the subarray with the maximum sum, it doesn\\'t make sense to include a prefix or suffix of negative numbers in that subarray. That\\'s because removing that prefix or suffix would lead to a higher sum.\\n\\nSo in the array [2, 1, -3, 4, -1, 2, 1, -5, 4], the subarray [4, -1, 2, 1] does not include the prefix [-3] or the suffix [-5], because doing so would lead to a smaller sum.\\n\\nA better hint might be: \\n\\nWhen examining the elements in the array, if the current element plus the running total (subarray sum up to this point) is less than the current element itself, then the running total should be discarded (set to zero) and start a new subarray from the current element. This is because a maximum subarray sum will never include a previous sum that is negative, it is better to start a new sum from the current element. This is the core idea behind Kadane\\'s algorithm."
                    }
                ]
            },
            {
                "id": 1859957,
                "content": [
                    {
                        "username": "london804",
                        "content": "Example 3:\nInput: nums = [5,4,-1,7,8]\nOutput: 23\nExplanation: The subarray [5,4,-1,7,8] has the largest sum 23. \nHow is Example 3 a subarray? Shouldn't the answer be 15"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of this problem, a \"subarray\" of an array is a contiguous portion of the array. A subarray could consist of any number of elements, from a single element up to the entire array. So, in Example 3, [5,4,-1,7,8] is considered a subarray of the original array [5,4,-1,7,8] -- in fact, it\\'s the entire array.\\n\\nThe subarray with the largest sum is [5,4,-1,7,8], and the sum of this subarray is 5+4+(-1)+7+8 = 23, not 15. The algorithm is trying to find the maximum sum that can be obtained from a subarray, not the maximum length or number of positive numbers in a subarray.\\n\\nSo the output 23 is correct for this example."
                    },
                    {
                        "username": "Asmodeus11",
                        "content": "I have question. the problem indicate the nums element constraint can be from -10^4 to 10^4 which means the whole array can be negative nums even tho there is not a single test case that all array contains negative nums"
                    },
                    {
                        "username": "bparanj",
                        "content": "Just because the constraints allow for elements to be in the range -10^4 to 10^4, it doesn\\'t mean that all the test cases will have all negative numbers. The constraints are there to provide the boundaries within which your solution must work, but the actual test cases used to evaluate your solution can be anything within those boundaries, including cases where all elements are negative, all elements are positive, or a mix of positive and negative elements.\\n\\nFor the Maximum Subarray problem, if all the elements in the input array are negative, then the maximum subarray is simply the element with the least negative value (i.e., the element closest to zero). This is because adding negative numbers together only makes the sum more negative.\\n\\nFor example, if you have an input array like `[-3, -2, -1]`, the maximum subarray is simply `[-1]`, and the maximum sum is `-1`.\\n"
                    },
                    {
                        "username": "jaweriazaman",
                        "content": "why we use vectors here"
                    },
                    {
                        "username": "kalasaniuday",
                        "content": "Here, what if all the integers are negative?\\nfor example, [-1,-9, -2,-5] then largest sum subarray might be [-1], but how can we assume empty subarray equals to zero."
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of the Maximum Subarray problem, an empty subarray is generally not considered, as the problem constraints specify that the size of the input array `nums` is at least 1. \\n\\nIf all the numbers in the array are negative, then the maximum subarray would be the subarray containing the single number with the least negative value (i.e., the number closest to zero). So, for the example `[-1,-9, -2,-5]`, the maximum subarray is indeed `[-1]`.\\n\\nThere\\'s no need to consider an empty subarray in this case, because an empty subarray would have a sum of zero, which would be less than any non-negative number and only more than negative numbers. Since the array always contains at least one number, the maximum subarray sum will always be at least as large as the maximum individual number.\\n\\nIf you are using Kadane\\'s algorithm to solve this problem, it essentially does the same thing - it maintains a running sum of the array, and if the sum becomes negative at any point, it resets the sum to zero (effectively \"discarding\" the previous numbers), because a negative sum would only decrease the total sum if we were to add more positive numbers to it. However, the algorithm also keeps track of the maximum sum it has seen so far, so even if all the numbers are negative, it will still return the least negative number as the maximum subarray sum.\\n\\nHere\\'s the algorithm for reference:\\n\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        max_sum = nums[0]\\n        curr_sum = 0\\n        for num in nums:\\n            if curr_sum < 0:\\n                curr_sum = 0\\n            curr_sum += num\\n            max_sum = max(max_sum, curr_sum)\\n        return max_sum\\n```\\nIn the case of all negative numbers, `curr_sum` would always be reset to 0, but `max_sum` would keep track of the maximum (least negative) number seen."
                    },
                    {
                        "username": "kuznetsov-m",
                        "content": "For example nums = [-1, -2, -3]\nWhy subarray can't be empty and maxSubArray = 0?"
                    },
                    {
                        "username": "bparanj",
                        "content": "In the context of the Maximum Subarray problem, the definition of a subarray typically requires that it contains at least one element. An empty set does not constitute a subarray as per this definition. Therefore, in the case of `nums = [-1, -2, -3]`, the maximum subarray cannot be empty and the maximum subarray sum cannot be 0.\\n\\nIf you consider an empty subarray as valid and having a sum of 0, then for any array that only has negative numbers, the maximum subarray would always be an empty set and the maximum sum would always be 0. But by requiring that a subarray contains at least one number, the problem becomes more interesting, as you then have to consider which number (or numbers) maximizes the sum.\\n\\nSo for `nums = [-1, -2, -3]`, the maximum subarray would be `[-1]`, and the maximum subarray sum would be -1, because -1 is greater than -2 and -3."
                    },
                    {
                        "username": "shubham_srivastav",
                        "content": "how can i conceder that the resultante subarray length i right?"
                    },
                    {
                        "username": "caroline_",
                        "content": "Hmm so in the case of test case [-1] apparently the optimal solution is -1 and not 0. This doesn\\'t seem right to me; a subarray of length 0 provides a higher sum technically, no?\\n\\nAnyway this is the type of thing one should ask the interviewer so I guess it doesn\\'t matter :)"
                    },
                    {
                        "username": "SmoothCriminalOww",
                        "content": "Largest sum right? why are we required to get a subarray with negative values for eg -1 in requirements?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The idea is to find the subarray that has the \"maximum sum\". In your example of an array with all negative values (e.g., [-1, -2, -3]), a subarray with a single element of -1 does provide the maximum sum. Although it\\'s a negative value, -1 is greater than -2 and -3. \\n\\nThe purpose of this requirement is to find the maximum sum of a continuous sub-sequence in the array, even if the maximum sum is negative. It adds more complexity to the problem as compared to simply discarding all negative numbers. \\n\\nSo even if the input array only has negative numbers, we don\\'t consider the maximum sum to be 0 by choosing an empty subarray; instead, we consider the maximum negative number as the maximum sum. If we allowed an empty subarray to be the maximum, then the solution for any input array with all negative numbers would be 0, which simplifies the problem and ignores the fact that a higher (less negative) number is actually \"greater\" than a lower (more negative) number."
                    },
                    {
                        "username": "daring-calf",
                        "content": "OMFG!!! After a year of leetcoding, I figured out the Kadane\\'s algorithm by myself in 2 hours!\\nI\\'m invincible now!!"
                    },
                    {
                        "username": "AssetDali",
                        "content": "Hint: if the the subarray has the largest sum, then the remaining elements have the minimum sum(either negative or no elements)."
                    },
                    {
                        "username": "bparanj",
                        "content": "Actually, that hint isn\\'t entirely correct. It\\'s possible for a subarray with the maximum sum to not leave the remaining elements with the minimum sum. Consider the array [2, 1, -3, 4, -1, 2, 1, -5, 4]. The subarray with the largest sum is [4, -1, 2, 1] with a sum of 6. However, the remaining elements [2, 1, -3, -5, 4] don\\'t necessarily sum to the minimum possible sum in this array.\\n\\nWhat we can say is that if we\\'re trying to find the subarray with the maximum sum, it doesn\\'t make sense to include a prefix or suffix of negative numbers in that subarray. That\\'s because removing that prefix or suffix would lead to a higher sum.\\n\\nSo in the array [2, 1, -3, 4, -1, 2, 1, -5, 4], the subarray [4, -1, 2, 1] does not include the prefix [-3] or the suffix [-5], because doing so would lead to a smaller sum.\\n\\nA better hint might be: \\n\\nWhen examining the elements in the array, if the current element plus the running total (subarray sum up to this point) is less than the current element itself, then the running total should be discarded (set to zero) and start a new subarray from the current element. This is because a maximum subarray sum will never include a previous sum that is negative, it is better to start a new sum from the current element. This is the core idea behind Kadane\\'s algorithm."
                    }
                ]
            },
            {
                "id": 1854476,
                "content": [
                    {
                        "username": "linedoestrolling",
                        "content": "what do you guys think of such an algorithm\\n1. condense the array(in the sense that you combine all contiguous positive and contiguous negative numbers together so that you end up with an array with alternating positive and negative numbers)\\n2. find the largest number in the condensed array\\n3. pair up positive and negative numbers together starting from the largest number and excluding the largest number(so if the largest number is index 3 in an array of length 7, index 2 and 1 will be paired, 0 will be alone, 4 and 5 will be paired, 6 will be alone.\\n4. recur over and over again until 2 end cases:\\na. length of the array becomes 2(guaranteed to be a positive and negative number, so just take the positive number)\\nb. length of array becomes 3(alternates between positive and negative number e.g. pos neg pos or neg pos neg, so just take the largest number of the 3)\\n\\nim not sure what the time complexity and space complexity of such an algorithm would be, would anyone be so kind as to critique such an algorithm thanks"
                    },
                    {
                        "username": "bparanj",
                        "content": "This is a very interesting approach to the problem. Here\\'s an analysis:\\n\\n1. Condensing the array: This step could be done in O(n), where n is the length of the original array, as you need to traverse the array only once. This operation won\\'t require any additional space (O(1)) because you can modify the original array.\\n\\n2. Finding the largest number: This operation also runs in O(n) time complexity as you have to traverse the entire condensed array. The space complexity is also O(1) as you only need to keep track of the current maximum.\\n\\n3. Pairing up positive and negative numbers: This operation might be quite complex to implement, and it seems like it could potentially result in a time complexity of O(n^2) because in the worst-case scenario, you would need to rearrange elements after each pairing. Also, it\\'s unclear how this step contributes to finding the maximum product subarray.\\n\\nAs for the recursion part, the time complexity could get high, especially with the pairings and rearrangements. Moreover, it\\'s not clear how these operations would help find the maximum product subarray, particularly in cases where negative numbers are involved.\\n\\nFor instance, consider the array [2, -3, 4, -5, -6]. After condensing, you get the same array. The largest number is 4, but the maximum product subarray is [2, -3, 4, -5, -6] with a product of 360. The proposed operations don\\'t seem to capture this.\\n\\nThis problem is best solved using a dynamic programming approach, where for each new element, you calculate the maximum and minimum product ending at that position (to account for potential negative numbers), and then update the global maximum product accordingly. This can be done in O(n) time and O(1) space."
                    },
                    {
                        "username": "fade_jc",
                        "content": "Kadane\\'s algorithm is probably the best way to solve this."
                    },
                    {
                        "username": "code_to_change",
                        "content": "class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int sum=0;\\n        int max_sum=0;\\n        for(int i=0;i<nums.size();i++){ \\n            if(sum+nums[i]>0){\\n                sum+=nums[i];\\n                max_sum=max(max_sum,sum);\\n            }\\n            else{\\n                sum=0;\\n            }\\n        }\\n        if(max_sum==0){\\n            return *max_element(nums.begin(),nums.end());\\n        }\\n        return max_sum;\\n    }\\n};"
                    },
                    {
                        "username": "pcRipper",
                        "content": "(186/210) [2,-1,-1,2,0,-3,3] with expected 3. So am i stupid? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The maximum subarray in your example [2,-1,-1,2,0,-3,3] is [2,-1,-1,2,0,-3,3] itself, and it sums to 3. Here\\'s how you calculate it:\\n\\n    2 - 1 - 1 + 2 + 0 - 3 + 3 = 2\\n\\nThe subarray sums up to 2, not 3. It seems there might be a mistake in the expected result. If the maximum subarray sum was indeed 3, then it seems the input array or expected result is not correct according to the rules of the maximum subarray problem."
                    },
                    {
                        "username": "Explaid",
                        "content": "Maybe subarray is just [3]?"
                    },
                    {
                        "username": "SuriyaT",
                        "content": "i want to know how we fiind a subarray .In my point of view positive to positve ex 4,-1,2,1  -> and one more example  nums = [5,4,-1,7,8] whole index ..Whether my understanding is right?..\\nplease let me know if anyone know this!..\\n "
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is partly right, but there\\'s more to the problem. We\\'re looking for a contiguous subarray (a sub-section of the array) with the largest sum. This doesn\\'t necessarily mean we only add the positive numbers. Negative numbers can also be part of the maximum subarray if they\\'re surrounded by large enough positive numbers. \\n\\nLet\\'s go through the array you provided to illustrate this:\\n\\nGiven array nums = [2,-1,-1,2,0,-3,3]\\n\\nWe start with the first number, 2. This is our current maximum.\\n\\nNext, we add -1, getting a sum of 1. Even though -1 is negative, adding it to our sum still results in a positive number, so we keep this subarray.\\n\\nThe next number is -1 again, our sum becomes 0. It\\'s not beneficial, but it\\'s not reducing our maximum found so far (2), so we keep going.\\n\\nThe next number is 2, so our sum is now 2. This is equal to our maximum found so far.\\n\\nThen we have 0, -3, and 3. Adding these, we end up with a sum of 2, which is equal to our maximum.\\n\\nThe maximum subarray can thus be [2, -1, -1, 2] or [2, -1, -1, 2, 0, -3, 3] both resulting in a sum of 2. \\n\\nYou can see that we have included negative numbers in our subarray because, even though they momentarily decrease the sum, they may be part of a larger sum subarray. The algorithm essentially tries different \"parts\" of the array to find the combination that yields the highest sum."
                    },
                    {
                        "username": "Yash_kumbhawat",
                        "content": "class Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum1=0;\\n        int sum = Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            sum1+= nums[i];\\n           sum = Math.max(sum,sum1);\\n            if(sum1<0){\\n                sum1=0;\\n            }\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "akshita79",
                        "content": "I\\'m new to divide and conquer can someone tell me where I am wrong in this code?\\n(maximum subarray problem )\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums,int s,int e) {\\n        int mid;\\n         s=nums.front();\\n         e=nums.back();\\n        if(s==e){\\n            return nums.at(s);\\n        }\\n         mid=e+(s-e)/2;\\n        int leftpart=maxSubArray(nums,s,mid);\\n        int rightpart=maxSubArray(nums,mid+1,e);\\n        int rmax=0;\\n        int lmax=0;\\n        int lsum=0;\\n        int rsum=0;\\n        for(int i=mid;i>=s;i--){\\n            lsum=lsum+nums[i];\\n            if(lsum>lmax){\\n                lmax=lsum;\\n            } \\n        }\\n        for(int i=mid+1;i<=e;i++){\\n            rsum=rsum+nums[i];\\n            if(rsum>rmax){\\n                rmax=rsum;\\n            }\\n        }\\n        int overlapping=rmax+lmax;\\n        int maxisubsum=max(max(rmax,lmax),overlapping);\\n        return maxisubsum;\\n\\n       \\n        \\n    }\\n};"
                    },
                    {
                        "username": "KritimPrasad",
                        "content": "Use sum as 0 and maximum as the first element of the array. use a for loop from 0 to last element of array and add it as sum + the element, and check whether the sum is greater than maximum or not if yes then maximum = sum and also check whether the sum is less than 0 or not if yes then sum =0 and return the maximum value;"
                    },
                    {
                        "username": "mayankindia0122",
                        "content": "I know kadane algo and solved but can anyone tell me if question was that print the maximum subarray it actuall subarray and return type is vector than what changes we need to made in this code\\n int maxSubArray(vector<int>& nums) {\\n       int ans=INT_MIN;\\n       int n=nums.size();\\n       int CS=0;\\n       for(int i=0; i<n; i++)\\n       {\\n           CS+=nums[i];\\n           ans=max(ans,CS);\\n           if(CS<0)\\n           CS=0;\\n       } \\n       return ans;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided finds the maximum subarray sum using Kadane\\'s algorithm, but doesn\\'t keep track of the indices where the maximum sum subarray starts and ends. \\nIf we modify your code to remember the beginning and ending indices of the maximum subarray, we can use those indices to return the maximum subarray itself. Here\\'s how you could do it:\\n\\n```cpp\\nvector<int> maxSubArray(vector<int>& nums) {\\n    int maxSum = INT_MIN, currSum = 0;\\n    int start = 0, end = 0, tempStart = 0;\\n    int n = nums.size();\\n\\n    for(int i = 0; i < n; i++) {\\n        currSum += nums[i];\\n\\n        // If new sum is greater, update maxSum and indices\\n        if (maxSum < currSum) {\\n            maxSum = currSum;\\n            start = tempStart;\\n            end = i;\\n        }\\n\\n        // If current sum is negative, start a new sum\\n        if (currSum < 0) {\\n            currSum = 0;\\n            tempStart = i + 1;\\n        }\\n    }\\n\\n    // Using the start and end indices, construct the max subarray\\n    vector<int> maxSub(nums.begin() + start, nums.begin() + end + 1);\\n\\n    return maxSub;\\n}\\n```\\n\\nIn this updated code, `tempStart` remembers the starting index of a potential maximum subarray. When we find a larger sum, we update `start` and `end` to be the current boundaries of the maximum subarray. After the loop, we use the `start` and `end` indices to create a new vector that contains the maximum subarray, and return that vector.\\n"
                    },
                    {
                        "username": "kaifistan",
                        "content": "int maxSubArray(vector<int>& nums) {\\n        long long sum = 0;\\n        long long maxSum = nums[0];\\n        for(auto itr : nums) {\\n            sum += itr;\\n            maxSum = max(sum, maxSum);\\n            if(sum < 0) sum = 0;\\n        }\\n        return maxSum;\\n    }\\n\\n\\n\\nkanade\\'s Algorithm"
                    }
                ]
            },
            {
                "id": 1848680,
                "content": [
                    {
                        "username": "linedoestrolling",
                        "content": "what do you guys think of such an algorithm\\n1. condense the array(in the sense that you combine all contiguous positive and contiguous negative numbers together so that you end up with an array with alternating positive and negative numbers)\\n2. find the largest number in the condensed array\\n3. pair up positive and negative numbers together starting from the largest number and excluding the largest number(so if the largest number is index 3 in an array of length 7, index 2 and 1 will be paired, 0 will be alone, 4 and 5 will be paired, 6 will be alone.\\n4. recur over and over again until 2 end cases:\\na. length of the array becomes 2(guaranteed to be a positive and negative number, so just take the positive number)\\nb. length of array becomes 3(alternates between positive and negative number e.g. pos neg pos or neg pos neg, so just take the largest number of the 3)\\n\\nim not sure what the time complexity and space complexity of such an algorithm would be, would anyone be so kind as to critique such an algorithm thanks"
                    },
                    {
                        "username": "bparanj",
                        "content": "This is a very interesting approach to the problem. Here\\'s an analysis:\\n\\n1. Condensing the array: This step could be done in O(n), where n is the length of the original array, as you need to traverse the array only once. This operation won\\'t require any additional space (O(1)) because you can modify the original array.\\n\\n2. Finding the largest number: This operation also runs in O(n) time complexity as you have to traverse the entire condensed array. The space complexity is also O(1) as you only need to keep track of the current maximum.\\n\\n3. Pairing up positive and negative numbers: This operation might be quite complex to implement, and it seems like it could potentially result in a time complexity of O(n^2) because in the worst-case scenario, you would need to rearrange elements after each pairing. Also, it\\'s unclear how this step contributes to finding the maximum product subarray.\\n\\nAs for the recursion part, the time complexity could get high, especially with the pairings and rearrangements. Moreover, it\\'s not clear how these operations would help find the maximum product subarray, particularly in cases where negative numbers are involved.\\n\\nFor instance, consider the array [2, -3, 4, -5, -6]. After condensing, you get the same array. The largest number is 4, but the maximum product subarray is [2, -3, 4, -5, -6] with a product of 360. The proposed operations don\\'t seem to capture this.\\n\\nThis problem is best solved using a dynamic programming approach, where for each new element, you calculate the maximum and minimum product ending at that position (to account for potential negative numbers), and then update the global maximum product accordingly. This can be done in O(n) time and O(1) space."
                    },
                    {
                        "username": "fade_jc",
                        "content": "Kadane\\'s algorithm is probably the best way to solve this."
                    },
                    {
                        "username": "code_to_change",
                        "content": "class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int sum=0;\\n        int max_sum=0;\\n        for(int i=0;i<nums.size();i++){ \\n            if(sum+nums[i]>0){\\n                sum+=nums[i];\\n                max_sum=max(max_sum,sum);\\n            }\\n            else{\\n                sum=0;\\n            }\\n        }\\n        if(max_sum==0){\\n            return *max_element(nums.begin(),nums.end());\\n        }\\n        return max_sum;\\n    }\\n};"
                    },
                    {
                        "username": "pcRipper",
                        "content": "(186/210) [2,-1,-1,2,0,-3,3] with expected 3. So am i stupid? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The maximum subarray in your example [2,-1,-1,2,0,-3,3] is [2,-1,-1,2,0,-3,3] itself, and it sums to 3. Here\\'s how you calculate it:\\n\\n    2 - 1 - 1 + 2 + 0 - 3 + 3 = 2\\n\\nThe subarray sums up to 2, not 3. It seems there might be a mistake in the expected result. If the maximum subarray sum was indeed 3, then it seems the input array or expected result is not correct according to the rules of the maximum subarray problem."
                    },
                    {
                        "username": "Explaid",
                        "content": "Maybe subarray is just [3]?"
                    },
                    {
                        "username": "SuriyaT",
                        "content": "i want to know how we fiind a subarray .In my point of view positive to positve ex 4,-1,2,1  -> and one more example  nums = [5,4,-1,7,8] whole index ..Whether my understanding is right?..\\nplease let me know if anyone know this!..\\n "
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is partly right, but there\\'s more to the problem. We\\'re looking for a contiguous subarray (a sub-section of the array) with the largest sum. This doesn\\'t necessarily mean we only add the positive numbers. Negative numbers can also be part of the maximum subarray if they\\'re surrounded by large enough positive numbers. \\n\\nLet\\'s go through the array you provided to illustrate this:\\n\\nGiven array nums = [2,-1,-1,2,0,-3,3]\\n\\nWe start with the first number, 2. This is our current maximum.\\n\\nNext, we add -1, getting a sum of 1. Even though -1 is negative, adding it to our sum still results in a positive number, so we keep this subarray.\\n\\nThe next number is -1 again, our sum becomes 0. It\\'s not beneficial, but it\\'s not reducing our maximum found so far (2), so we keep going.\\n\\nThe next number is 2, so our sum is now 2. This is equal to our maximum found so far.\\n\\nThen we have 0, -3, and 3. Adding these, we end up with a sum of 2, which is equal to our maximum.\\n\\nThe maximum subarray can thus be [2, -1, -1, 2] or [2, -1, -1, 2, 0, -3, 3] both resulting in a sum of 2. \\n\\nYou can see that we have included negative numbers in our subarray because, even though they momentarily decrease the sum, they may be part of a larger sum subarray. The algorithm essentially tries different \"parts\" of the array to find the combination that yields the highest sum."
                    },
                    {
                        "username": "Yash_kumbhawat",
                        "content": "class Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum1=0;\\n        int sum = Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            sum1+= nums[i];\\n           sum = Math.max(sum,sum1);\\n            if(sum1<0){\\n                sum1=0;\\n            }\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "akshita79",
                        "content": "I\\'m new to divide and conquer can someone tell me where I am wrong in this code?\\n(maximum subarray problem )\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums,int s,int e) {\\n        int mid;\\n         s=nums.front();\\n         e=nums.back();\\n        if(s==e){\\n            return nums.at(s);\\n        }\\n         mid=e+(s-e)/2;\\n        int leftpart=maxSubArray(nums,s,mid);\\n        int rightpart=maxSubArray(nums,mid+1,e);\\n        int rmax=0;\\n        int lmax=0;\\n        int lsum=0;\\n        int rsum=0;\\n        for(int i=mid;i>=s;i--){\\n            lsum=lsum+nums[i];\\n            if(lsum>lmax){\\n                lmax=lsum;\\n            } \\n        }\\n        for(int i=mid+1;i<=e;i++){\\n            rsum=rsum+nums[i];\\n            if(rsum>rmax){\\n                rmax=rsum;\\n            }\\n        }\\n        int overlapping=rmax+lmax;\\n        int maxisubsum=max(max(rmax,lmax),overlapping);\\n        return maxisubsum;\\n\\n       \\n        \\n    }\\n};"
                    },
                    {
                        "username": "KritimPrasad",
                        "content": "Use sum as 0 and maximum as the first element of the array. use a for loop from 0 to last element of array and add it as sum + the element, and check whether the sum is greater than maximum or not if yes then maximum = sum and also check whether the sum is less than 0 or not if yes then sum =0 and return the maximum value;"
                    },
                    {
                        "username": "mayankindia0122",
                        "content": "I know kadane algo and solved but can anyone tell me if question was that print the maximum subarray it actuall subarray and return type is vector than what changes we need to made in this code\\n int maxSubArray(vector<int>& nums) {\\n       int ans=INT_MIN;\\n       int n=nums.size();\\n       int CS=0;\\n       for(int i=0; i<n; i++)\\n       {\\n           CS+=nums[i];\\n           ans=max(ans,CS);\\n           if(CS<0)\\n           CS=0;\\n       } \\n       return ans;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided finds the maximum subarray sum using Kadane\\'s algorithm, but doesn\\'t keep track of the indices where the maximum sum subarray starts and ends. \\nIf we modify your code to remember the beginning and ending indices of the maximum subarray, we can use those indices to return the maximum subarray itself. Here\\'s how you could do it:\\n\\n```cpp\\nvector<int> maxSubArray(vector<int>& nums) {\\n    int maxSum = INT_MIN, currSum = 0;\\n    int start = 0, end = 0, tempStart = 0;\\n    int n = nums.size();\\n\\n    for(int i = 0; i < n; i++) {\\n        currSum += nums[i];\\n\\n        // If new sum is greater, update maxSum and indices\\n        if (maxSum < currSum) {\\n            maxSum = currSum;\\n            start = tempStart;\\n            end = i;\\n        }\\n\\n        // If current sum is negative, start a new sum\\n        if (currSum < 0) {\\n            currSum = 0;\\n            tempStart = i + 1;\\n        }\\n    }\\n\\n    // Using the start and end indices, construct the max subarray\\n    vector<int> maxSub(nums.begin() + start, nums.begin() + end + 1);\\n\\n    return maxSub;\\n}\\n```\\n\\nIn this updated code, `tempStart` remembers the starting index of a potential maximum subarray. When we find a larger sum, we update `start` and `end` to be the current boundaries of the maximum subarray. After the loop, we use the `start` and `end` indices to create a new vector that contains the maximum subarray, and return that vector.\\n"
                    },
                    {
                        "username": "kaifistan",
                        "content": "int maxSubArray(vector<int>& nums) {\\n        long long sum = 0;\\n        long long maxSum = nums[0];\\n        for(auto itr : nums) {\\n            sum += itr;\\n            maxSum = max(sum, maxSum);\\n            if(sum < 0) sum = 0;\\n        }\\n        return maxSum;\\n    }\\n\\n\\n\\nkanade\\'s Algorithm"
                    }
                ]
            },
            {
                "id": 1848532,
                "content": [
                    {
                        "username": "linedoestrolling",
                        "content": "what do you guys think of such an algorithm\\n1. condense the array(in the sense that you combine all contiguous positive and contiguous negative numbers together so that you end up with an array with alternating positive and negative numbers)\\n2. find the largest number in the condensed array\\n3. pair up positive and negative numbers together starting from the largest number and excluding the largest number(so if the largest number is index 3 in an array of length 7, index 2 and 1 will be paired, 0 will be alone, 4 and 5 will be paired, 6 will be alone.\\n4. recur over and over again until 2 end cases:\\na. length of the array becomes 2(guaranteed to be a positive and negative number, so just take the positive number)\\nb. length of array becomes 3(alternates between positive and negative number e.g. pos neg pos or neg pos neg, so just take the largest number of the 3)\\n\\nim not sure what the time complexity and space complexity of such an algorithm would be, would anyone be so kind as to critique such an algorithm thanks"
                    },
                    {
                        "username": "bparanj",
                        "content": "This is a very interesting approach to the problem. Here\\'s an analysis:\\n\\n1. Condensing the array: This step could be done in O(n), where n is the length of the original array, as you need to traverse the array only once. This operation won\\'t require any additional space (O(1)) because you can modify the original array.\\n\\n2. Finding the largest number: This operation also runs in O(n) time complexity as you have to traverse the entire condensed array. The space complexity is also O(1) as you only need to keep track of the current maximum.\\n\\n3. Pairing up positive and negative numbers: This operation might be quite complex to implement, and it seems like it could potentially result in a time complexity of O(n^2) because in the worst-case scenario, you would need to rearrange elements after each pairing. Also, it\\'s unclear how this step contributes to finding the maximum product subarray.\\n\\nAs for the recursion part, the time complexity could get high, especially with the pairings and rearrangements. Moreover, it\\'s not clear how these operations would help find the maximum product subarray, particularly in cases where negative numbers are involved.\\n\\nFor instance, consider the array [2, -3, 4, -5, -6]. After condensing, you get the same array. The largest number is 4, but the maximum product subarray is [2, -3, 4, -5, -6] with a product of 360. The proposed operations don\\'t seem to capture this.\\n\\nThis problem is best solved using a dynamic programming approach, where for each new element, you calculate the maximum and minimum product ending at that position (to account for potential negative numbers), and then update the global maximum product accordingly. This can be done in O(n) time and O(1) space."
                    },
                    {
                        "username": "fade_jc",
                        "content": "Kadane\\'s algorithm is probably the best way to solve this."
                    },
                    {
                        "username": "code_to_change",
                        "content": "class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int sum=0;\\n        int max_sum=0;\\n        for(int i=0;i<nums.size();i++){ \\n            if(sum+nums[i]>0){\\n                sum+=nums[i];\\n                max_sum=max(max_sum,sum);\\n            }\\n            else{\\n                sum=0;\\n            }\\n        }\\n        if(max_sum==0){\\n            return *max_element(nums.begin(),nums.end());\\n        }\\n        return max_sum;\\n    }\\n};"
                    },
                    {
                        "username": "pcRipper",
                        "content": "(186/210) [2,-1,-1,2,0,-3,3] with expected 3. So am i stupid? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The maximum subarray in your example [2,-1,-1,2,0,-3,3] is [2,-1,-1,2,0,-3,3] itself, and it sums to 3. Here\\'s how you calculate it:\\n\\n    2 - 1 - 1 + 2 + 0 - 3 + 3 = 2\\n\\nThe subarray sums up to 2, not 3. It seems there might be a mistake in the expected result. If the maximum subarray sum was indeed 3, then it seems the input array or expected result is not correct according to the rules of the maximum subarray problem."
                    },
                    {
                        "username": "Explaid",
                        "content": "Maybe subarray is just [3]?"
                    },
                    {
                        "username": "SuriyaT",
                        "content": "i want to know how we fiind a subarray .In my point of view positive to positve ex 4,-1,2,1  -> and one more example  nums = [5,4,-1,7,8] whole index ..Whether my understanding is right?..\\nplease let me know if anyone know this!..\\n "
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is partly right, but there\\'s more to the problem. We\\'re looking for a contiguous subarray (a sub-section of the array) with the largest sum. This doesn\\'t necessarily mean we only add the positive numbers. Negative numbers can also be part of the maximum subarray if they\\'re surrounded by large enough positive numbers. \\n\\nLet\\'s go through the array you provided to illustrate this:\\n\\nGiven array nums = [2,-1,-1,2,0,-3,3]\\n\\nWe start with the first number, 2. This is our current maximum.\\n\\nNext, we add -1, getting a sum of 1. Even though -1 is negative, adding it to our sum still results in a positive number, so we keep this subarray.\\n\\nThe next number is -1 again, our sum becomes 0. It\\'s not beneficial, but it\\'s not reducing our maximum found so far (2), so we keep going.\\n\\nThe next number is 2, so our sum is now 2. This is equal to our maximum found so far.\\n\\nThen we have 0, -3, and 3. Adding these, we end up with a sum of 2, which is equal to our maximum.\\n\\nThe maximum subarray can thus be [2, -1, -1, 2] or [2, -1, -1, 2, 0, -3, 3] both resulting in a sum of 2. \\n\\nYou can see that we have included negative numbers in our subarray because, even though they momentarily decrease the sum, they may be part of a larger sum subarray. The algorithm essentially tries different \"parts\" of the array to find the combination that yields the highest sum."
                    },
                    {
                        "username": "Yash_kumbhawat",
                        "content": "class Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum1=0;\\n        int sum = Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            sum1+= nums[i];\\n           sum = Math.max(sum,sum1);\\n            if(sum1<0){\\n                sum1=0;\\n            }\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "akshita79",
                        "content": "I\\'m new to divide and conquer can someone tell me where I am wrong in this code?\\n(maximum subarray problem )\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums,int s,int e) {\\n        int mid;\\n         s=nums.front();\\n         e=nums.back();\\n        if(s==e){\\n            return nums.at(s);\\n        }\\n         mid=e+(s-e)/2;\\n        int leftpart=maxSubArray(nums,s,mid);\\n        int rightpart=maxSubArray(nums,mid+1,e);\\n        int rmax=0;\\n        int lmax=0;\\n        int lsum=0;\\n        int rsum=0;\\n        for(int i=mid;i>=s;i--){\\n            lsum=lsum+nums[i];\\n            if(lsum>lmax){\\n                lmax=lsum;\\n            } \\n        }\\n        for(int i=mid+1;i<=e;i++){\\n            rsum=rsum+nums[i];\\n            if(rsum>rmax){\\n                rmax=rsum;\\n            }\\n        }\\n        int overlapping=rmax+lmax;\\n        int maxisubsum=max(max(rmax,lmax),overlapping);\\n        return maxisubsum;\\n\\n       \\n        \\n    }\\n};"
                    },
                    {
                        "username": "KritimPrasad",
                        "content": "Use sum as 0 and maximum as the first element of the array. use a for loop from 0 to last element of array and add it as sum + the element, and check whether the sum is greater than maximum or not if yes then maximum = sum and also check whether the sum is less than 0 or not if yes then sum =0 and return the maximum value;"
                    },
                    {
                        "username": "mayankindia0122",
                        "content": "I know kadane algo and solved but can anyone tell me if question was that print the maximum subarray it actuall subarray and return type is vector than what changes we need to made in this code\\n int maxSubArray(vector<int>& nums) {\\n       int ans=INT_MIN;\\n       int n=nums.size();\\n       int CS=0;\\n       for(int i=0; i<n; i++)\\n       {\\n           CS+=nums[i];\\n           ans=max(ans,CS);\\n           if(CS<0)\\n           CS=0;\\n       } \\n       return ans;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided finds the maximum subarray sum using Kadane\\'s algorithm, but doesn\\'t keep track of the indices where the maximum sum subarray starts and ends. \\nIf we modify your code to remember the beginning and ending indices of the maximum subarray, we can use those indices to return the maximum subarray itself. Here\\'s how you could do it:\\n\\n```cpp\\nvector<int> maxSubArray(vector<int>& nums) {\\n    int maxSum = INT_MIN, currSum = 0;\\n    int start = 0, end = 0, tempStart = 0;\\n    int n = nums.size();\\n\\n    for(int i = 0; i < n; i++) {\\n        currSum += nums[i];\\n\\n        // If new sum is greater, update maxSum and indices\\n        if (maxSum < currSum) {\\n            maxSum = currSum;\\n            start = tempStart;\\n            end = i;\\n        }\\n\\n        // If current sum is negative, start a new sum\\n        if (currSum < 0) {\\n            currSum = 0;\\n            tempStart = i + 1;\\n        }\\n    }\\n\\n    // Using the start and end indices, construct the max subarray\\n    vector<int> maxSub(nums.begin() + start, nums.begin() + end + 1);\\n\\n    return maxSub;\\n}\\n```\\n\\nIn this updated code, `tempStart` remembers the starting index of a potential maximum subarray. When we find a larger sum, we update `start` and `end` to be the current boundaries of the maximum subarray. After the loop, we use the `start` and `end` indices to create a new vector that contains the maximum subarray, and return that vector.\\n"
                    },
                    {
                        "username": "kaifistan",
                        "content": "int maxSubArray(vector<int>& nums) {\\n        long long sum = 0;\\n        long long maxSum = nums[0];\\n        for(auto itr : nums) {\\n            sum += itr;\\n            maxSum = max(sum, maxSum);\\n            if(sum < 0) sum = 0;\\n        }\\n        return maxSum;\\n    }\\n\\n\\n\\nkanade\\'s Algorithm"
                    }
                ]
            },
            {
                "id": 1840595,
                "content": [
                    {
                        "username": "linedoestrolling",
                        "content": "what do you guys think of such an algorithm\\n1. condense the array(in the sense that you combine all contiguous positive and contiguous negative numbers together so that you end up with an array with alternating positive and negative numbers)\\n2. find the largest number in the condensed array\\n3. pair up positive and negative numbers together starting from the largest number and excluding the largest number(so if the largest number is index 3 in an array of length 7, index 2 and 1 will be paired, 0 will be alone, 4 and 5 will be paired, 6 will be alone.\\n4. recur over and over again until 2 end cases:\\na. length of the array becomes 2(guaranteed to be a positive and negative number, so just take the positive number)\\nb. length of array becomes 3(alternates between positive and negative number e.g. pos neg pos or neg pos neg, so just take the largest number of the 3)\\n\\nim not sure what the time complexity and space complexity of such an algorithm would be, would anyone be so kind as to critique such an algorithm thanks"
                    },
                    {
                        "username": "bparanj",
                        "content": "This is a very interesting approach to the problem. Here\\'s an analysis:\\n\\n1. Condensing the array: This step could be done in O(n), where n is the length of the original array, as you need to traverse the array only once. This operation won\\'t require any additional space (O(1)) because you can modify the original array.\\n\\n2. Finding the largest number: This operation also runs in O(n) time complexity as you have to traverse the entire condensed array. The space complexity is also O(1) as you only need to keep track of the current maximum.\\n\\n3. Pairing up positive and negative numbers: This operation might be quite complex to implement, and it seems like it could potentially result in a time complexity of O(n^2) because in the worst-case scenario, you would need to rearrange elements after each pairing. Also, it\\'s unclear how this step contributes to finding the maximum product subarray.\\n\\nAs for the recursion part, the time complexity could get high, especially with the pairings and rearrangements. Moreover, it\\'s not clear how these operations would help find the maximum product subarray, particularly in cases where negative numbers are involved.\\n\\nFor instance, consider the array [2, -3, 4, -5, -6]. After condensing, you get the same array. The largest number is 4, but the maximum product subarray is [2, -3, 4, -5, -6] with a product of 360. The proposed operations don\\'t seem to capture this.\\n\\nThis problem is best solved using a dynamic programming approach, where for each new element, you calculate the maximum and minimum product ending at that position (to account for potential negative numbers), and then update the global maximum product accordingly. This can be done in O(n) time and O(1) space."
                    },
                    {
                        "username": "fade_jc",
                        "content": "Kadane\\'s algorithm is probably the best way to solve this."
                    },
                    {
                        "username": "code_to_change",
                        "content": "class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int sum=0;\\n        int max_sum=0;\\n        for(int i=0;i<nums.size();i++){ \\n            if(sum+nums[i]>0){\\n                sum+=nums[i];\\n                max_sum=max(max_sum,sum);\\n            }\\n            else{\\n                sum=0;\\n            }\\n        }\\n        if(max_sum==0){\\n            return *max_element(nums.begin(),nums.end());\\n        }\\n        return max_sum;\\n    }\\n};"
                    },
                    {
                        "username": "pcRipper",
                        "content": "(186/210) [2,-1,-1,2,0,-3,3] with expected 3. So am i stupid? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The maximum subarray in your example [2,-1,-1,2,0,-3,3] is [2,-1,-1,2,0,-3,3] itself, and it sums to 3. Here\\'s how you calculate it:\\n\\n    2 - 1 - 1 + 2 + 0 - 3 + 3 = 2\\n\\nThe subarray sums up to 2, not 3. It seems there might be a mistake in the expected result. If the maximum subarray sum was indeed 3, then it seems the input array or expected result is not correct according to the rules of the maximum subarray problem."
                    },
                    {
                        "username": "Explaid",
                        "content": "Maybe subarray is just [3]?"
                    },
                    {
                        "username": "SuriyaT",
                        "content": "i want to know how we fiind a subarray .In my point of view positive to positve ex 4,-1,2,1  -> and one more example  nums = [5,4,-1,7,8] whole index ..Whether my understanding is right?..\\nplease let me know if anyone know this!..\\n "
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is partly right, but there\\'s more to the problem. We\\'re looking for a contiguous subarray (a sub-section of the array) with the largest sum. This doesn\\'t necessarily mean we only add the positive numbers. Negative numbers can also be part of the maximum subarray if they\\'re surrounded by large enough positive numbers. \\n\\nLet\\'s go through the array you provided to illustrate this:\\n\\nGiven array nums = [2,-1,-1,2,0,-3,3]\\n\\nWe start with the first number, 2. This is our current maximum.\\n\\nNext, we add -1, getting a sum of 1. Even though -1 is negative, adding it to our sum still results in a positive number, so we keep this subarray.\\n\\nThe next number is -1 again, our sum becomes 0. It\\'s not beneficial, but it\\'s not reducing our maximum found so far (2), so we keep going.\\n\\nThe next number is 2, so our sum is now 2. This is equal to our maximum found so far.\\n\\nThen we have 0, -3, and 3. Adding these, we end up with a sum of 2, which is equal to our maximum.\\n\\nThe maximum subarray can thus be [2, -1, -1, 2] or [2, -1, -1, 2, 0, -3, 3] both resulting in a sum of 2. \\n\\nYou can see that we have included negative numbers in our subarray because, even though they momentarily decrease the sum, they may be part of a larger sum subarray. The algorithm essentially tries different \"parts\" of the array to find the combination that yields the highest sum."
                    },
                    {
                        "username": "Yash_kumbhawat",
                        "content": "class Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum1=0;\\n        int sum = Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            sum1+= nums[i];\\n           sum = Math.max(sum,sum1);\\n            if(sum1<0){\\n                sum1=0;\\n            }\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "akshita79",
                        "content": "I\\'m new to divide and conquer can someone tell me where I am wrong in this code?\\n(maximum subarray problem )\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums,int s,int e) {\\n        int mid;\\n         s=nums.front();\\n         e=nums.back();\\n        if(s==e){\\n            return nums.at(s);\\n        }\\n         mid=e+(s-e)/2;\\n        int leftpart=maxSubArray(nums,s,mid);\\n        int rightpart=maxSubArray(nums,mid+1,e);\\n        int rmax=0;\\n        int lmax=0;\\n        int lsum=0;\\n        int rsum=0;\\n        for(int i=mid;i>=s;i--){\\n            lsum=lsum+nums[i];\\n            if(lsum>lmax){\\n                lmax=lsum;\\n            } \\n        }\\n        for(int i=mid+1;i<=e;i++){\\n            rsum=rsum+nums[i];\\n            if(rsum>rmax){\\n                rmax=rsum;\\n            }\\n        }\\n        int overlapping=rmax+lmax;\\n        int maxisubsum=max(max(rmax,lmax),overlapping);\\n        return maxisubsum;\\n\\n       \\n        \\n    }\\n};"
                    },
                    {
                        "username": "KritimPrasad",
                        "content": "Use sum as 0 and maximum as the first element of the array. use a for loop from 0 to last element of array and add it as sum + the element, and check whether the sum is greater than maximum or not if yes then maximum = sum and also check whether the sum is less than 0 or not if yes then sum =0 and return the maximum value;"
                    },
                    {
                        "username": "mayankindia0122",
                        "content": "I know kadane algo and solved but can anyone tell me if question was that print the maximum subarray it actuall subarray and return type is vector than what changes we need to made in this code\\n int maxSubArray(vector<int>& nums) {\\n       int ans=INT_MIN;\\n       int n=nums.size();\\n       int CS=0;\\n       for(int i=0; i<n; i++)\\n       {\\n           CS+=nums[i];\\n           ans=max(ans,CS);\\n           if(CS<0)\\n           CS=0;\\n       } \\n       return ans;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided finds the maximum subarray sum using Kadane\\'s algorithm, but doesn\\'t keep track of the indices where the maximum sum subarray starts and ends. \\nIf we modify your code to remember the beginning and ending indices of the maximum subarray, we can use those indices to return the maximum subarray itself. Here\\'s how you could do it:\\n\\n```cpp\\nvector<int> maxSubArray(vector<int>& nums) {\\n    int maxSum = INT_MIN, currSum = 0;\\n    int start = 0, end = 0, tempStart = 0;\\n    int n = nums.size();\\n\\n    for(int i = 0; i < n; i++) {\\n        currSum += nums[i];\\n\\n        // If new sum is greater, update maxSum and indices\\n        if (maxSum < currSum) {\\n            maxSum = currSum;\\n            start = tempStart;\\n            end = i;\\n        }\\n\\n        // If current sum is negative, start a new sum\\n        if (currSum < 0) {\\n            currSum = 0;\\n            tempStart = i + 1;\\n        }\\n    }\\n\\n    // Using the start and end indices, construct the max subarray\\n    vector<int> maxSub(nums.begin() + start, nums.begin() + end + 1);\\n\\n    return maxSub;\\n}\\n```\\n\\nIn this updated code, `tempStart` remembers the starting index of a potential maximum subarray. When we find a larger sum, we update `start` and `end` to be the current boundaries of the maximum subarray. After the loop, we use the `start` and `end` indices to create a new vector that contains the maximum subarray, and return that vector.\\n"
                    },
                    {
                        "username": "kaifistan",
                        "content": "int maxSubArray(vector<int>& nums) {\\n        long long sum = 0;\\n        long long maxSum = nums[0];\\n        for(auto itr : nums) {\\n            sum += itr;\\n            maxSum = max(sum, maxSum);\\n            if(sum < 0) sum = 0;\\n        }\\n        return maxSum;\\n    }\\n\\n\\n\\nkanade\\'s Algorithm"
                    }
                ]
            },
            {
                "id": 1839347,
                "content": [
                    {
                        "username": "linedoestrolling",
                        "content": "what do you guys think of such an algorithm\\n1. condense the array(in the sense that you combine all contiguous positive and contiguous negative numbers together so that you end up with an array with alternating positive and negative numbers)\\n2. find the largest number in the condensed array\\n3. pair up positive and negative numbers together starting from the largest number and excluding the largest number(so if the largest number is index 3 in an array of length 7, index 2 and 1 will be paired, 0 will be alone, 4 and 5 will be paired, 6 will be alone.\\n4. recur over and over again until 2 end cases:\\na. length of the array becomes 2(guaranteed to be a positive and negative number, so just take the positive number)\\nb. length of array becomes 3(alternates between positive and negative number e.g. pos neg pos or neg pos neg, so just take the largest number of the 3)\\n\\nim not sure what the time complexity and space complexity of such an algorithm would be, would anyone be so kind as to critique such an algorithm thanks"
                    },
                    {
                        "username": "bparanj",
                        "content": "This is a very interesting approach to the problem. Here\\'s an analysis:\\n\\n1. Condensing the array: This step could be done in O(n), where n is the length of the original array, as you need to traverse the array only once. This operation won\\'t require any additional space (O(1)) because you can modify the original array.\\n\\n2. Finding the largest number: This operation also runs in O(n) time complexity as you have to traverse the entire condensed array. The space complexity is also O(1) as you only need to keep track of the current maximum.\\n\\n3. Pairing up positive and negative numbers: This operation might be quite complex to implement, and it seems like it could potentially result in a time complexity of O(n^2) because in the worst-case scenario, you would need to rearrange elements after each pairing. Also, it\\'s unclear how this step contributes to finding the maximum product subarray.\\n\\nAs for the recursion part, the time complexity could get high, especially with the pairings and rearrangements. Moreover, it\\'s not clear how these operations would help find the maximum product subarray, particularly in cases where negative numbers are involved.\\n\\nFor instance, consider the array [2, -3, 4, -5, -6]. After condensing, you get the same array. The largest number is 4, but the maximum product subarray is [2, -3, 4, -5, -6] with a product of 360. The proposed operations don\\'t seem to capture this.\\n\\nThis problem is best solved using a dynamic programming approach, where for each new element, you calculate the maximum and minimum product ending at that position (to account for potential negative numbers), and then update the global maximum product accordingly. This can be done in O(n) time and O(1) space."
                    },
                    {
                        "username": "fade_jc",
                        "content": "Kadane\\'s algorithm is probably the best way to solve this."
                    },
                    {
                        "username": "code_to_change",
                        "content": "class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int sum=0;\\n        int max_sum=0;\\n        for(int i=0;i<nums.size();i++){ \\n            if(sum+nums[i]>0){\\n                sum+=nums[i];\\n                max_sum=max(max_sum,sum);\\n            }\\n            else{\\n                sum=0;\\n            }\\n        }\\n        if(max_sum==0){\\n            return *max_element(nums.begin(),nums.end());\\n        }\\n        return max_sum;\\n    }\\n};"
                    },
                    {
                        "username": "pcRipper",
                        "content": "(186/210) [2,-1,-1,2,0,-3,3] with expected 3. So am i stupid? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The maximum subarray in your example [2,-1,-1,2,0,-3,3] is [2,-1,-1,2,0,-3,3] itself, and it sums to 3. Here\\'s how you calculate it:\\n\\n    2 - 1 - 1 + 2 + 0 - 3 + 3 = 2\\n\\nThe subarray sums up to 2, not 3. It seems there might be a mistake in the expected result. If the maximum subarray sum was indeed 3, then it seems the input array or expected result is not correct according to the rules of the maximum subarray problem."
                    },
                    {
                        "username": "Explaid",
                        "content": "Maybe subarray is just [3]?"
                    },
                    {
                        "username": "SuriyaT",
                        "content": "i want to know how we fiind a subarray .In my point of view positive to positve ex 4,-1,2,1  -> and one more example  nums = [5,4,-1,7,8] whole index ..Whether my understanding is right?..\\nplease let me know if anyone know this!..\\n "
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is partly right, but there\\'s more to the problem. We\\'re looking for a contiguous subarray (a sub-section of the array) with the largest sum. This doesn\\'t necessarily mean we only add the positive numbers. Negative numbers can also be part of the maximum subarray if they\\'re surrounded by large enough positive numbers. \\n\\nLet\\'s go through the array you provided to illustrate this:\\n\\nGiven array nums = [2,-1,-1,2,0,-3,3]\\n\\nWe start with the first number, 2. This is our current maximum.\\n\\nNext, we add -1, getting a sum of 1. Even though -1 is negative, adding it to our sum still results in a positive number, so we keep this subarray.\\n\\nThe next number is -1 again, our sum becomes 0. It\\'s not beneficial, but it\\'s not reducing our maximum found so far (2), so we keep going.\\n\\nThe next number is 2, so our sum is now 2. This is equal to our maximum found so far.\\n\\nThen we have 0, -3, and 3. Adding these, we end up with a sum of 2, which is equal to our maximum.\\n\\nThe maximum subarray can thus be [2, -1, -1, 2] or [2, -1, -1, 2, 0, -3, 3] both resulting in a sum of 2. \\n\\nYou can see that we have included negative numbers in our subarray because, even though they momentarily decrease the sum, they may be part of a larger sum subarray. The algorithm essentially tries different \"parts\" of the array to find the combination that yields the highest sum."
                    },
                    {
                        "username": "Yash_kumbhawat",
                        "content": "class Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum1=0;\\n        int sum = Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            sum1+= nums[i];\\n           sum = Math.max(sum,sum1);\\n            if(sum1<0){\\n                sum1=0;\\n            }\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "akshita79",
                        "content": "I\\'m new to divide and conquer can someone tell me where I am wrong in this code?\\n(maximum subarray problem )\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums,int s,int e) {\\n        int mid;\\n         s=nums.front();\\n         e=nums.back();\\n        if(s==e){\\n            return nums.at(s);\\n        }\\n         mid=e+(s-e)/2;\\n        int leftpart=maxSubArray(nums,s,mid);\\n        int rightpart=maxSubArray(nums,mid+1,e);\\n        int rmax=0;\\n        int lmax=0;\\n        int lsum=0;\\n        int rsum=0;\\n        for(int i=mid;i>=s;i--){\\n            lsum=lsum+nums[i];\\n            if(lsum>lmax){\\n                lmax=lsum;\\n            } \\n        }\\n        for(int i=mid+1;i<=e;i++){\\n            rsum=rsum+nums[i];\\n            if(rsum>rmax){\\n                rmax=rsum;\\n            }\\n        }\\n        int overlapping=rmax+lmax;\\n        int maxisubsum=max(max(rmax,lmax),overlapping);\\n        return maxisubsum;\\n\\n       \\n        \\n    }\\n};"
                    },
                    {
                        "username": "KritimPrasad",
                        "content": "Use sum as 0 and maximum as the first element of the array. use a for loop from 0 to last element of array and add it as sum + the element, and check whether the sum is greater than maximum or not if yes then maximum = sum and also check whether the sum is less than 0 or not if yes then sum =0 and return the maximum value;"
                    },
                    {
                        "username": "mayankindia0122",
                        "content": "I know kadane algo and solved but can anyone tell me if question was that print the maximum subarray it actuall subarray and return type is vector than what changes we need to made in this code\\n int maxSubArray(vector<int>& nums) {\\n       int ans=INT_MIN;\\n       int n=nums.size();\\n       int CS=0;\\n       for(int i=0; i<n; i++)\\n       {\\n           CS+=nums[i];\\n           ans=max(ans,CS);\\n           if(CS<0)\\n           CS=0;\\n       } \\n       return ans;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided finds the maximum subarray sum using Kadane\\'s algorithm, but doesn\\'t keep track of the indices where the maximum sum subarray starts and ends. \\nIf we modify your code to remember the beginning and ending indices of the maximum subarray, we can use those indices to return the maximum subarray itself. Here\\'s how you could do it:\\n\\n```cpp\\nvector<int> maxSubArray(vector<int>& nums) {\\n    int maxSum = INT_MIN, currSum = 0;\\n    int start = 0, end = 0, tempStart = 0;\\n    int n = nums.size();\\n\\n    for(int i = 0; i < n; i++) {\\n        currSum += nums[i];\\n\\n        // If new sum is greater, update maxSum and indices\\n        if (maxSum < currSum) {\\n            maxSum = currSum;\\n            start = tempStart;\\n            end = i;\\n        }\\n\\n        // If current sum is negative, start a new sum\\n        if (currSum < 0) {\\n            currSum = 0;\\n            tempStart = i + 1;\\n        }\\n    }\\n\\n    // Using the start and end indices, construct the max subarray\\n    vector<int> maxSub(nums.begin() + start, nums.begin() + end + 1);\\n\\n    return maxSub;\\n}\\n```\\n\\nIn this updated code, `tempStart` remembers the starting index of a potential maximum subarray. When we find a larger sum, we update `start` and `end` to be the current boundaries of the maximum subarray. After the loop, we use the `start` and `end` indices to create a new vector that contains the maximum subarray, and return that vector.\\n"
                    },
                    {
                        "username": "kaifistan",
                        "content": "int maxSubArray(vector<int>& nums) {\\n        long long sum = 0;\\n        long long maxSum = nums[0];\\n        for(auto itr : nums) {\\n            sum += itr;\\n            maxSum = max(sum, maxSum);\\n            if(sum < 0) sum = 0;\\n        }\\n        return maxSum;\\n    }\\n\\n\\n\\nkanade\\'s Algorithm"
                    }
                ]
            },
            {
                "id": 1805449,
                "content": [
                    {
                        "username": "linedoestrolling",
                        "content": "what do you guys think of such an algorithm\\n1. condense the array(in the sense that you combine all contiguous positive and contiguous negative numbers together so that you end up with an array with alternating positive and negative numbers)\\n2. find the largest number in the condensed array\\n3. pair up positive and negative numbers together starting from the largest number and excluding the largest number(so if the largest number is index 3 in an array of length 7, index 2 and 1 will be paired, 0 will be alone, 4 and 5 will be paired, 6 will be alone.\\n4. recur over and over again until 2 end cases:\\na. length of the array becomes 2(guaranteed to be a positive and negative number, so just take the positive number)\\nb. length of array becomes 3(alternates between positive and negative number e.g. pos neg pos or neg pos neg, so just take the largest number of the 3)\\n\\nim not sure what the time complexity and space complexity of such an algorithm would be, would anyone be so kind as to critique such an algorithm thanks"
                    },
                    {
                        "username": "bparanj",
                        "content": "This is a very interesting approach to the problem. Here\\'s an analysis:\\n\\n1. Condensing the array: This step could be done in O(n), where n is the length of the original array, as you need to traverse the array only once. This operation won\\'t require any additional space (O(1)) because you can modify the original array.\\n\\n2. Finding the largest number: This operation also runs in O(n) time complexity as you have to traverse the entire condensed array. The space complexity is also O(1) as you only need to keep track of the current maximum.\\n\\n3. Pairing up positive and negative numbers: This operation might be quite complex to implement, and it seems like it could potentially result in a time complexity of O(n^2) because in the worst-case scenario, you would need to rearrange elements after each pairing. Also, it\\'s unclear how this step contributes to finding the maximum product subarray.\\n\\nAs for the recursion part, the time complexity could get high, especially with the pairings and rearrangements. Moreover, it\\'s not clear how these operations would help find the maximum product subarray, particularly in cases where negative numbers are involved.\\n\\nFor instance, consider the array [2, -3, 4, -5, -6]. After condensing, you get the same array. The largest number is 4, but the maximum product subarray is [2, -3, 4, -5, -6] with a product of 360. The proposed operations don\\'t seem to capture this.\\n\\nThis problem is best solved using a dynamic programming approach, where for each new element, you calculate the maximum and minimum product ending at that position (to account for potential negative numbers), and then update the global maximum product accordingly. This can be done in O(n) time and O(1) space."
                    },
                    {
                        "username": "fade_jc",
                        "content": "Kadane\\'s algorithm is probably the best way to solve this."
                    },
                    {
                        "username": "code_to_change",
                        "content": "class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int sum=0;\\n        int max_sum=0;\\n        for(int i=0;i<nums.size();i++){ \\n            if(sum+nums[i]>0){\\n                sum+=nums[i];\\n                max_sum=max(max_sum,sum);\\n            }\\n            else{\\n                sum=0;\\n            }\\n        }\\n        if(max_sum==0){\\n            return *max_element(nums.begin(),nums.end());\\n        }\\n        return max_sum;\\n    }\\n};"
                    },
                    {
                        "username": "pcRipper",
                        "content": "(186/210) [2,-1,-1,2,0,-3,3] with expected 3. So am i stupid? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The maximum subarray in your example [2,-1,-1,2,0,-3,3] is [2,-1,-1,2,0,-3,3] itself, and it sums to 3. Here\\'s how you calculate it:\\n\\n    2 - 1 - 1 + 2 + 0 - 3 + 3 = 2\\n\\nThe subarray sums up to 2, not 3. It seems there might be a mistake in the expected result. If the maximum subarray sum was indeed 3, then it seems the input array or expected result is not correct according to the rules of the maximum subarray problem."
                    },
                    {
                        "username": "Explaid",
                        "content": "Maybe subarray is just [3]?"
                    },
                    {
                        "username": "SuriyaT",
                        "content": "i want to know how we fiind a subarray .In my point of view positive to positve ex 4,-1,2,1  -> and one more example  nums = [5,4,-1,7,8] whole index ..Whether my understanding is right?..\\nplease let me know if anyone know this!..\\n "
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is partly right, but there\\'s more to the problem. We\\'re looking for a contiguous subarray (a sub-section of the array) with the largest sum. This doesn\\'t necessarily mean we only add the positive numbers. Negative numbers can also be part of the maximum subarray if they\\'re surrounded by large enough positive numbers. \\n\\nLet\\'s go through the array you provided to illustrate this:\\n\\nGiven array nums = [2,-1,-1,2,0,-3,3]\\n\\nWe start with the first number, 2. This is our current maximum.\\n\\nNext, we add -1, getting a sum of 1. Even though -1 is negative, adding it to our sum still results in a positive number, so we keep this subarray.\\n\\nThe next number is -1 again, our sum becomes 0. It\\'s not beneficial, but it\\'s not reducing our maximum found so far (2), so we keep going.\\n\\nThe next number is 2, so our sum is now 2. This is equal to our maximum found so far.\\n\\nThen we have 0, -3, and 3. Adding these, we end up with a sum of 2, which is equal to our maximum.\\n\\nThe maximum subarray can thus be [2, -1, -1, 2] or [2, -1, -1, 2, 0, -3, 3] both resulting in a sum of 2. \\n\\nYou can see that we have included negative numbers in our subarray because, even though they momentarily decrease the sum, they may be part of a larger sum subarray. The algorithm essentially tries different \"parts\" of the array to find the combination that yields the highest sum."
                    },
                    {
                        "username": "Yash_kumbhawat",
                        "content": "class Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum1=0;\\n        int sum = Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            sum1+= nums[i];\\n           sum = Math.max(sum,sum1);\\n            if(sum1<0){\\n                sum1=0;\\n            }\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "akshita79",
                        "content": "I\\'m new to divide and conquer can someone tell me where I am wrong in this code?\\n(maximum subarray problem )\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums,int s,int e) {\\n        int mid;\\n         s=nums.front();\\n         e=nums.back();\\n        if(s==e){\\n            return nums.at(s);\\n        }\\n         mid=e+(s-e)/2;\\n        int leftpart=maxSubArray(nums,s,mid);\\n        int rightpart=maxSubArray(nums,mid+1,e);\\n        int rmax=0;\\n        int lmax=0;\\n        int lsum=0;\\n        int rsum=0;\\n        for(int i=mid;i>=s;i--){\\n            lsum=lsum+nums[i];\\n            if(lsum>lmax){\\n                lmax=lsum;\\n            } \\n        }\\n        for(int i=mid+1;i<=e;i++){\\n            rsum=rsum+nums[i];\\n            if(rsum>rmax){\\n                rmax=rsum;\\n            }\\n        }\\n        int overlapping=rmax+lmax;\\n        int maxisubsum=max(max(rmax,lmax),overlapping);\\n        return maxisubsum;\\n\\n       \\n        \\n    }\\n};"
                    },
                    {
                        "username": "KritimPrasad",
                        "content": "Use sum as 0 and maximum as the first element of the array. use a for loop from 0 to last element of array and add it as sum + the element, and check whether the sum is greater than maximum or not if yes then maximum = sum and also check whether the sum is less than 0 or not if yes then sum =0 and return the maximum value;"
                    },
                    {
                        "username": "mayankindia0122",
                        "content": "I know kadane algo and solved but can anyone tell me if question was that print the maximum subarray it actuall subarray and return type is vector than what changes we need to made in this code\\n int maxSubArray(vector<int>& nums) {\\n       int ans=INT_MIN;\\n       int n=nums.size();\\n       int CS=0;\\n       for(int i=0; i<n; i++)\\n       {\\n           CS+=nums[i];\\n           ans=max(ans,CS);\\n           if(CS<0)\\n           CS=0;\\n       } \\n       return ans;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided finds the maximum subarray sum using Kadane\\'s algorithm, but doesn\\'t keep track of the indices where the maximum sum subarray starts and ends. \\nIf we modify your code to remember the beginning and ending indices of the maximum subarray, we can use those indices to return the maximum subarray itself. Here\\'s how you could do it:\\n\\n```cpp\\nvector<int> maxSubArray(vector<int>& nums) {\\n    int maxSum = INT_MIN, currSum = 0;\\n    int start = 0, end = 0, tempStart = 0;\\n    int n = nums.size();\\n\\n    for(int i = 0; i < n; i++) {\\n        currSum += nums[i];\\n\\n        // If new sum is greater, update maxSum and indices\\n        if (maxSum < currSum) {\\n            maxSum = currSum;\\n            start = tempStart;\\n            end = i;\\n        }\\n\\n        // If current sum is negative, start a new sum\\n        if (currSum < 0) {\\n            currSum = 0;\\n            tempStart = i + 1;\\n        }\\n    }\\n\\n    // Using the start and end indices, construct the max subarray\\n    vector<int> maxSub(nums.begin() + start, nums.begin() + end + 1);\\n\\n    return maxSub;\\n}\\n```\\n\\nIn this updated code, `tempStart` remembers the starting index of a potential maximum subarray. When we find a larger sum, we update `start` and `end` to be the current boundaries of the maximum subarray. After the loop, we use the `start` and `end` indices to create a new vector that contains the maximum subarray, and return that vector.\\n"
                    },
                    {
                        "username": "kaifistan",
                        "content": "int maxSubArray(vector<int>& nums) {\\n        long long sum = 0;\\n        long long maxSum = nums[0];\\n        for(auto itr : nums) {\\n            sum += itr;\\n            maxSum = max(sum, maxSum);\\n            if(sum < 0) sum = 0;\\n        }\\n        return maxSum;\\n    }\\n\\n\\n\\nkanade\\'s Algorithm"
                    }
                ]
            },
            {
                "id": 1800502,
                "content": [
                    {
                        "username": "linedoestrolling",
                        "content": "what do you guys think of such an algorithm\\n1. condense the array(in the sense that you combine all contiguous positive and contiguous negative numbers together so that you end up with an array with alternating positive and negative numbers)\\n2. find the largest number in the condensed array\\n3. pair up positive and negative numbers together starting from the largest number and excluding the largest number(so if the largest number is index 3 in an array of length 7, index 2 and 1 will be paired, 0 will be alone, 4 and 5 will be paired, 6 will be alone.\\n4. recur over and over again until 2 end cases:\\na. length of the array becomes 2(guaranteed to be a positive and negative number, so just take the positive number)\\nb. length of array becomes 3(alternates between positive and negative number e.g. pos neg pos or neg pos neg, so just take the largest number of the 3)\\n\\nim not sure what the time complexity and space complexity of such an algorithm would be, would anyone be so kind as to critique such an algorithm thanks"
                    },
                    {
                        "username": "bparanj",
                        "content": "This is a very interesting approach to the problem. Here\\'s an analysis:\\n\\n1. Condensing the array: This step could be done in O(n), where n is the length of the original array, as you need to traverse the array only once. This operation won\\'t require any additional space (O(1)) because you can modify the original array.\\n\\n2. Finding the largest number: This operation also runs in O(n) time complexity as you have to traverse the entire condensed array. The space complexity is also O(1) as you only need to keep track of the current maximum.\\n\\n3. Pairing up positive and negative numbers: This operation might be quite complex to implement, and it seems like it could potentially result in a time complexity of O(n^2) because in the worst-case scenario, you would need to rearrange elements after each pairing. Also, it\\'s unclear how this step contributes to finding the maximum product subarray.\\n\\nAs for the recursion part, the time complexity could get high, especially with the pairings and rearrangements. Moreover, it\\'s not clear how these operations would help find the maximum product subarray, particularly in cases where negative numbers are involved.\\n\\nFor instance, consider the array [2, -3, 4, -5, -6]. After condensing, you get the same array. The largest number is 4, but the maximum product subarray is [2, -3, 4, -5, -6] with a product of 360. The proposed operations don\\'t seem to capture this.\\n\\nThis problem is best solved using a dynamic programming approach, where for each new element, you calculate the maximum and minimum product ending at that position (to account for potential negative numbers), and then update the global maximum product accordingly. This can be done in O(n) time and O(1) space."
                    },
                    {
                        "username": "fade_jc",
                        "content": "Kadane\\'s algorithm is probably the best way to solve this."
                    },
                    {
                        "username": "code_to_change",
                        "content": "class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int sum=0;\\n        int max_sum=0;\\n        for(int i=0;i<nums.size();i++){ \\n            if(sum+nums[i]>0){\\n                sum+=nums[i];\\n                max_sum=max(max_sum,sum);\\n            }\\n            else{\\n                sum=0;\\n            }\\n        }\\n        if(max_sum==0){\\n            return *max_element(nums.begin(),nums.end());\\n        }\\n        return max_sum;\\n    }\\n};"
                    },
                    {
                        "username": "pcRipper",
                        "content": "(186/210) [2,-1,-1,2,0,-3,3] with expected 3. So am i stupid? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The maximum subarray in your example [2,-1,-1,2,0,-3,3] is [2,-1,-1,2,0,-3,3] itself, and it sums to 3. Here\\'s how you calculate it:\\n\\n    2 - 1 - 1 + 2 + 0 - 3 + 3 = 2\\n\\nThe subarray sums up to 2, not 3. It seems there might be a mistake in the expected result. If the maximum subarray sum was indeed 3, then it seems the input array or expected result is not correct according to the rules of the maximum subarray problem."
                    },
                    {
                        "username": "Explaid",
                        "content": "Maybe subarray is just [3]?"
                    },
                    {
                        "username": "SuriyaT",
                        "content": "i want to know how we fiind a subarray .In my point of view positive to positve ex 4,-1,2,1  -> and one more example  nums = [5,4,-1,7,8] whole index ..Whether my understanding is right?..\\nplease let me know if anyone know this!..\\n "
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is partly right, but there\\'s more to the problem. We\\'re looking for a contiguous subarray (a sub-section of the array) with the largest sum. This doesn\\'t necessarily mean we only add the positive numbers. Negative numbers can also be part of the maximum subarray if they\\'re surrounded by large enough positive numbers. \\n\\nLet\\'s go through the array you provided to illustrate this:\\n\\nGiven array nums = [2,-1,-1,2,0,-3,3]\\n\\nWe start with the first number, 2. This is our current maximum.\\n\\nNext, we add -1, getting a sum of 1. Even though -1 is negative, adding it to our sum still results in a positive number, so we keep this subarray.\\n\\nThe next number is -1 again, our sum becomes 0. It\\'s not beneficial, but it\\'s not reducing our maximum found so far (2), so we keep going.\\n\\nThe next number is 2, so our sum is now 2. This is equal to our maximum found so far.\\n\\nThen we have 0, -3, and 3. Adding these, we end up with a sum of 2, which is equal to our maximum.\\n\\nThe maximum subarray can thus be [2, -1, -1, 2] or [2, -1, -1, 2, 0, -3, 3] both resulting in a sum of 2. \\n\\nYou can see that we have included negative numbers in our subarray because, even though they momentarily decrease the sum, they may be part of a larger sum subarray. The algorithm essentially tries different \"parts\" of the array to find the combination that yields the highest sum."
                    },
                    {
                        "username": "Yash_kumbhawat",
                        "content": "class Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum1=0;\\n        int sum = Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            sum1+= nums[i];\\n           sum = Math.max(sum,sum1);\\n            if(sum1<0){\\n                sum1=0;\\n            }\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "akshita79",
                        "content": "I\\'m new to divide and conquer can someone tell me where I am wrong in this code?\\n(maximum subarray problem )\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums,int s,int e) {\\n        int mid;\\n         s=nums.front();\\n         e=nums.back();\\n        if(s==e){\\n            return nums.at(s);\\n        }\\n         mid=e+(s-e)/2;\\n        int leftpart=maxSubArray(nums,s,mid);\\n        int rightpart=maxSubArray(nums,mid+1,e);\\n        int rmax=0;\\n        int lmax=0;\\n        int lsum=0;\\n        int rsum=0;\\n        for(int i=mid;i>=s;i--){\\n            lsum=lsum+nums[i];\\n            if(lsum>lmax){\\n                lmax=lsum;\\n            } \\n        }\\n        for(int i=mid+1;i<=e;i++){\\n            rsum=rsum+nums[i];\\n            if(rsum>rmax){\\n                rmax=rsum;\\n            }\\n        }\\n        int overlapping=rmax+lmax;\\n        int maxisubsum=max(max(rmax,lmax),overlapping);\\n        return maxisubsum;\\n\\n       \\n        \\n    }\\n};"
                    },
                    {
                        "username": "KritimPrasad",
                        "content": "Use sum as 0 and maximum as the first element of the array. use a for loop from 0 to last element of array and add it as sum + the element, and check whether the sum is greater than maximum or not if yes then maximum = sum and also check whether the sum is less than 0 or not if yes then sum =0 and return the maximum value;"
                    },
                    {
                        "username": "mayankindia0122",
                        "content": "I know kadane algo and solved but can anyone tell me if question was that print the maximum subarray it actuall subarray and return type is vector than what changes we need to made in this code\\n int maxSubArray(vector<int>& nums) {\\n       int ans=INT_MIN;\\n       int n=nums.size();\\n       int CS=0;\\n       for(int i=0; i<n; i++)\\n       {\\n           CS+=nums[i];\\n           ans=max(ans,CS);\\n           if(CS<0)\\n           CS=0;\\n       } \\n       return ans;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided finds the maximum subarray sum using Kadane\\'s algorithm, but doesn\\'t keep track of the indices where the maximum sum subarray starts and ends. \\nIf we modify your code to remember the beginning and ending indices of the maximum subarray, we can use those indices to return the maximum subarray itself. Here\\'s how you could do it:\\n\\n```cpp\\nvector<int> maxSubArray(vector<int>& nums) {\\n    int maxSum = INT_MIN, currSum = 0;\\n    int start = 0, end = 0, tempStart = 0;\\n    int n = nums.size();\\n\\n    for(int i = 0; i < n; i++) {\\n        currSum += nums[i];\\n\\n        // If new sum is greater, update maxSum and indices\\n        if (maxSum < currSum) {\\n            maxSum = currSum;\\n            start = tempStart;\\n            end = i;\\n        }\\n\\n        // If current sum is negative, start a new sum\\n        if (currSum < 0) {\\n            currSum = 0;\\n            tempStart = i + 1;\\n        }\\n    }\\n\\n    // Using the start and end indices, construct the max subarray\\n    vector<int> maxSub(nums.begin() + start, nums.begin() + end + 1);\\n\\n    return maxSub;\\n}\\n```\\n\\nIn this updated code, `tempStart` remembers the starting index of a potential maximum subarray. When we find a larger sum, we update `start` and `end` to be the current boundaries of the maximum subarray. After the loop, we use the `start` and `end` indices to create a new vector that contains the maximum subarray, and return that vector.\\n"
                    },
                    {
                        "username": "kaifistan",
                        "content": "int maxSubArray(vector<int>& nums) {\\n        long long sum = 0;\\n        long long maxSum = nums[0];\\n        for(auto itr : nums) {\\n            sum += itr;\\n            maxSum = max(sum, maxSum);\\n            if(sum < 0) sum = 0;\\n        }\\n        return maxSum;\\n    }\\n\\n\\n\\nkanade\\'s Algorithm"
                    }
                ]
            },
            {
                "id": 1798382,
                "content": [
                    {
                        "username": "linedoestrolling",
                        "content": "what do you guys think of such an algorithm\\n1. condense the array(in the sense that you combine all contiguous positive and contiguous negative numbers together so that you end up with an array with alternating positive and negative numbers)\\n2. find the largest number in the condensed array\\n3. pair up positive and negative numbers together starting from the largest number and excluding the largest number(so if the largest number is index 3 in an array of length 7, index 2 and 1 will be paired, 0 will be alone, 4 and 5 will be paired, 6 will be alone.\\n4. recur over and over again until 2 end cases:\\na. length of the array becomes 2(guaranteed to be a positive and negative number, so just take the positive number)\\nb. length of array becomes 3(alternates between positive and negative number e.g. pos neg pos or neg pos neg, so just take the largest number of the 3)\\n\\nim not sure what the time complexity and space complexity of such an algorithm would be, would anyone be so kind as to critique such an algorithm thanks"
                    },
                    {
                        "username": "bparanj",
                        "content": "This is a very interesting approach to the problem. Here\\'s an analysis:\\n\\n1. Condensing the array: This step could be done in O(n), where n is the length of the original array, as you need to traverse the array only once. This operation won\\'t require any additional space (O(1)) because you can modify the original array.\\n\\n2. Finding the largest number: This operation also runs in O(n) time complexity as you have to traverse the entire condensed array. The space complexity is also O(1) as you only need to keep track of the current maximum.\\n\\n3. Pairing up positive and negative numbers: This operation might be quite complex to implement, and it seems like it could potentially result in a time complexity of O(n^2) because in the worst-case scenario, you would need to rearrange elements after each pairing. Also, it\\'s unclear how this step contributes to finding the maximum product subarray.\\n\\nAs for the recursion part, the time complexity could get high, especially with the pairings and rearrangements. Moreover, it\\'s not clear how these operations would help find the maximum product subarray, particularly in cases where negative numbers are involved.\\n\\nFor instance, consider the array [2, -3, 4, -5, -6]. After condensing, you get the same array. The largest number is 4, but the maximum product subarray is [2, -3, 4, -5, -6] with a product of 360. The proposed operations don\\'t seem to capture this.\\n\\nThis problem is best solved using a dynamic programming approach, where for each new element, you calculate the maximum and minimum product ending at that position (to account for potential negative numbers), and then update the global maximum product accordingly. This can be done in O(n) time and O(1) space."
                    },
                    {
                        "username": "fade_jc",
                        "content": "Kadane\\'s algorithm is probably the best way to solve this."
                    },
                    {
                        "username": "code_to_change",
                        "content": "class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int sum=0;\\n        int max_sum=0;\\n        for(int i=0;i<nums.size();i++){ \\n            if(sum+nums[i]>0){\\n                sum+=nums[i];\\n                max_sum=max(max_sum,sum);\\n            }\\n            else{\\n                sum=0;\\n            }\\n        }\\n        if(max_sum==0){\\n            return *max_element(nums.begin(),nums.end());\\n        }\\n        return max_sum;\\n    }\\n};"
                    },
                    {
                        "username": "pcRipper",
                        "content": "(186/210) [2,-1,-1,2,0,-3,3] with expected 3. So am i stupid? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The maximum subarray in your example [2,-1,-1,2,0,-3,3] is [2,-1,-1,2,0,-3,3] itself, and it sums to 3. Here\\'s how you calculate it:\\n\\n    2 - 1 - 1 + 2 + 0 - 3 + 3 = 2\\n\\nThe subarray sums up to 2, not 3. It seems there might be a mistake in the expected result. If the maximum subarray sum was indeed 3, then it seems the input array or expected result is not correct according to the rules of the maximum subarray problem."
                    },
                    {
                        "username": "Explaid",
                        "content": "Maybe subarray is just [3]?"
                    },
                    {
                        "username": "SuriyaT",
                        "content": "i want to know how we fiind a subarray .In my point of view positive to positve ex 4,-1,2,1  -> and one more example  nums = [5,4,-1,7,8] whole index ..Whether my understanding is right?..\\nplease let me know if anyone know this!..\\n "
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is partly right, but there\\'s more to the problem. We\\'re looking for a contiguous subarray (a sub-section of the array) with the largest sum. This doesn\\'t necessarily mean we only add the positive numbers. Negative numbers can also be part of the maximum subarray if they\\'re surrounded by large enough positive numbers. \\n\\nLet\\'s go through the array you provided to illustrate this:\\n\\nGiven array nums = [2,-1,-1,2,0,-3,3]\\n\\nWe start with the first number, 2. This is our current maximum.\\n\\nNext, we add -1, getting a sum of 1. Even though -1 is negative, adding it to our sum still results in a positive number, so we keep this subarray.\\n\\nThe next number is -1 again, our sum becomes 0. It\\'s not beneficial, but it\\'s not reducing our maximum found so far (2), so we keep going.\\n\\nThe next number is 2, so our sum is now 2. This is equal to our maximum found so far.\\n\\nThen we have 0, -3, and 3. Adding these, we end up with a sum of 2, which is equal to our maximum.\\n\\nThe maximum subarray can thus be [2, -1, -1, 2] or [2, -1, -1, 2, 0, -3, 3] both resulting in a sum of 2. \\n\\nYou can see that we have included negative numbers in our subarray because, even though they momentarily decrease the sum, they may be part of a larger sum subarray. The algorithm essentially tries different \"parts\" of the array to find the combination that yields the highest sum."
                    },
                    {
                        "username": "Yash_kumbhawat",
                        "content": "class Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum1=0;\\n        int sum = Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            sum1+= nums[i];\\n           sum = Math.max(sum,sum1);\\n            if(sum1<0){\\n                sum1=0;\\n            }\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "akshita79",
                        "content": "I\\'m new to divide and conquer can someone tell me where I am wrong in this code?\\n(maximum subarray problem )\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums,int s,int e) {\\n        int mid;\\n         s=nums.front();\\n         e=nums.back();\\n        if(s==e){\\n            return nums.at(s);\\n        }\\n         mid=e+(s-e)/2;\\n        int leftpart=maxSubArray(nums,s,mid);\\n        int rightpart=maxSubArray(nums,mid+1,e);\\n        int rmax=0;\\n        int lmax=0;\\n        int lsum=0;\\n        int rsum=0;\\n        for(int i=mid;i>=s;i--){\\n            lsum=lsum+nums[i];\\n            if(lsum>lmax){\\n                lmax=lsum;\\n            } \\n        }\\n        for(int i=mid+1;i<=e;i++){\\n            rsum=rsum+nums[i];\\n            if(rsum>rmax){\\n                rmax=rsum;\\n            }\\n        }\\n        int overlapping=rmax+lmax;\\n        int maxisubsum=max(max(rmax,lmax),overlapping);\\n        return maxisubsum;\\n\\n       \\n        \\n    }\\n};"
                    },
                    {
                        "username": "KritimPrasad",
                        "content": "Use sum as 0 and maximum as the first element of the array. use a for loop from 0 to last element of array and add it as sum + the element, and check whether the sum is greater than maximum or not if yes then maximum = sum and also check whether the sum is less than 0 or not if yes then sum =0 and return the maximum value;"
                    },
                    {
                        "username": "mayankindia0122",
                        "content": "I know kadane algo and solved but can anyone tell me if question was that print the maximum subarray it actuall subarray and return type is vector than what changes we need to made in this code\\n int maxSubArray(vector<int>& nums) {\\n       int ans=INT_MIN;\\n       int n=nums.size();\\n       int CS=0;\\n       for(int i=0; i<n; i++)\\n       {\\n           CS+=nums[i];\\n           ans=max(ans,CS);\\n           if(CS<0)\\n           CS=0;\\n       } \\n       return ans;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided finds the maximum subarray sum using Kadane\\'s algorithm, but doesn\\'t keep track of the indices where the maximum sum subarray starts and ends. \\nIf we modify your code to remember the beginning and ending indices of the maximum subarray, we can use those indices to return the maximum subarray itself. Here\\'s how you could do it:\\n\\n```cpp\\nvector<int> maxSubArray(vector<int>& nums) {\\n    int maxSum = INT_MIN, currSum = 0;\\n    int start = 0, end = 0, tempStart = 0;\\n    int n = nums.size();\\n\\n    for(int i = 0; i < n; i++) {\\n        currSum += nums[i];\\n\\n        // If new sum is greater, update maxSum and indices\\n        if (maxSum < currSum) {\\n            maxSum = currSum;\\n            start = tempStart;\\n            end = i;\\n        }\\n\\n        // If current sum is negative, start a new sum\\n        if (currSum < 0) {\\n            currSum = 0;\\n            tempStart = i + 1;\\n        }\\n    }\\n\\n    // Using the start and end indices, construct the max subarray\\n    vector<int> maxSub(nums.begin() + start, nums.begin() + end + 1);\\n\\n    return maxSub;\\n}\\n```\\n\\nIn this updated code, `tempStart` remembers the starting index of a potential maximum subarray. When we find a larger sum, we update `start` and `end` to be the current boundaries of the maximum subarray. After the loop, we use the `start` and `end` indices to create a new vector that contains the maximum subarray, and return that vector.\\n"
                    },
                    {
                        "username": "kaifistan",
                        "content": "int maxSubArray(vector<int>& nums) {\\n        long long sum = 0;\\n        long long maxSum = nums[0];\\n        for(auto itr : nums) {\\n            sum += itr;\\n            maxSum = max(sum, maxSum);\\n            if(sum < 0) sum = 0;\\n        }\\n        return maxSum;\\n    }\\n\\n\\n\\nkanade\\'s Algorithm"
                    }
                ]
            },
            {
                "id": 1797071,
                "content": [
                    {
                        "username": "linedoestrolling",
                        "content": "what do you guys think of such an algorithm\\n1. condense the array(in the sense that you combine all contiguous positive and contiguous negative numbers together so that you end up with an array with alternating positive and negative numbers)\\n2. find the largest number in the condensed array\\n3. pair up positive and negative numbers together starting from the largest number and excluding the largest number(so if the largest number is index 3 in an array of length 7, index 2 and 1 will be paired, 0 will be alone, 4 and 5 will be paired, 6 will be alone.\\n4. recur over and over again until 2 end cases:\\na. length of the array becomes 2(guaranteed to be a positive and negative number, so just take the positive number)\\nb. length of array becomes 3(alternates between positive and negative number e.g. pos neg pos or neg pos neg, so just take the largest number of the 3)\\n\\nim not sure what the time complexity and space complexity of such an algorithm would be, would anyone be so kind as to critique such an algorithm thanks"
                    },
                    {
                        "username": "bparanj",
                        "content": "This is a very interesting approach to the problem. Here\\'s an analysis:\\n\\n1. Condensing the array: This step could be done in O(n), where n is the length of the original array, as you need to traverse the array only once. This operation won\\'t require any additional space (O(1)) because you can modify the original array.\\n\\n2. Finding the largest number: This operation also runs in O(n) time complexity as you have to traverse the entire condensed array. The space complexity is also O(1) as you only need to keep track of the current maximum.\\n\\n3. Pairing up positive and negative numbers: This operation might be quite complex to implement, and it seems like it could potentially result in a time complexity of O(n^2) because in the worst-case scenario, you would need to rearrange elements after each pairing. Also, it\\'s unclear how this step contributes to finding the maximum product subarray.\\n\\nAs for the recursion part, the time complexity could get high, especially with the pairings and rearrangements. Moreover, it\\'s not clear how these operations would help find the maximum product subarray, particularly in cases where negative numbers are involved.\\n\\nFor instance, consider the array [2, -3, 4, -5, -6]. After condensing, you get the same array. The largest number is 4, but the maximum product subarray is [2, -3, 4, -5, -6] with a product of 360. The proposed operations don\\'t seem to capture this.\\n\\nThis problem is best solved using a dynamic programming approach, where for each new element, you calculate the maximum and minimum product ending at that position (to account for potential negative numbers), and then update the global maximum product accordingly. This can be done in O(n) time and O(1) space."
                    },
                    {
                        "username": "fade_jc",
                        "content": "Kadane\\'s algorithm is probably the best way to solve this."
                    },
                    {
                        "username": "code_to_change",
                        "content": "class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int sum=0;\\n        int max_sum=0;\\n        for(int i=0;i<nums.size();i++){ \\n            if(sum+nums[i]>0){\\n                sum+=nums[i];\\n                max_sum=max(max_sum,sum);\\n            }\\n            else{\\n                sum=0;\\n            }\\n        }\\n        if(max_sum==0){\\n            return *max_element(nums.begin(),nums.end());\\n        }\\n        return max_sum;\\n    }\\n};"
                    },
                    {
                        "username": "pcRipper",
                        "content": "(186/210) [2,-1,-1,2,0,-3,3] with expected 3. So am i stupid? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The maximum subarray in your example [2,-1,-1,2,0,-3,3] is [2,-1,-1,2,0,-3,3] itself, and it sums to 3. Here\\'s how you calculate it:\\n\\n    2 - 1 - 1 + 2 + 0 - 3 + 3 = 2\\n\\nThe subarray sums up to 2, not 3. It seems there might be a mistake in the expected result. If the maximum subarray sum was indeed 3, then it seems the input array or expected result is not correct according to the rules of the maximum subarray problem."
                    },
                    {
                        "username": "Explaid",
                        "content": "Maybe subarray is just [3]?"
                    },
                    {
                        "username": "SuriyaT",
                        "content": "i want to know how we fiind a subarray .In my point of view positive to positve ex 4,-1,2,1  -> and one more example  nums = [5,4,-1,7,8] whole index ..Whether my understanding is right?..\\nplease let me know if anyone know this!..\\n "
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is partly right, but there\\'s more to the problem. We\\'re looking for a contiguous subarray (a sub-section of the array) with the largest sum. This doesn\\'t necessarily mean we only add the positive numbers. Negative numbers can also be part of the maximum subarray if they\\'re surrounded by large enough positive numbers. \\n\\nLet\\'s go through the array you provided to illustrate this:\\n\\nGiven array nums = [2,-1,-1,2,0,-3,3]\\n\\nWe start with the first number, 2. This is our current maximum.\\n\\nNext, we add -1, getting a sum of 1. Even though -1 is negative, adding it to our sum still results in a positive number, so we keep this subarray.\\n\\nThe next number is -1 again, our sum becomes 0. It\\'s not beneficial, but it\\'s not reducing our maximum found so far (2), so we keep going.\\n\\nThe next number is 2, so our sum is now 2. This is equal to our maximum found so far.\\n\\nThen we have 0, -3, and 3. Adding these, we end up with a sum of 2, which is equal to our maximum.\\n\\nThe maximum subarray can thus be [2, -1, -1, 2] or [2, -1, -1, 2, 0, -3, 3] both resulting in a sum of 2. \\n\\nYou can see that we have included negative numbers in our subarray because, even though they momentarily decrease the sum, they may be part of a larger sum subarray. The algorithm essentially tries different \"parts\" of the array to find the combination that yields the highest sum."
                    },
                    {
                        "username": "Yash_kumbhawat",
                        "content": "class Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum1=0;\\n        int sum = Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            sum1+= nums[i];\\n           sum = Math.max(sum,sum1);\\n            if(sum1<0){\\n                sum1=0;\\n            }\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "akshita79",
                        "content": "I\\'m new to divide and conquer can someone tell me where I am wrong in this code?\\n(maximum subarray problem )\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums,int s,int e) {\\n        int mid;\\n         s=nums.front();\\n         e=nums.back();\\n        if(s==e){\\n            return nums.at(s);\\n        }\\n         mid=e+(s-e)/2;\\n        int leftpart=maxSubArray(nums,s,mid);\\n        int rightpart=maxSubArray(nums,mid+1,e);\\n        int rmax=0;\\n        int lmax=0;\\n        int lsum=0;\\n        int rsum=0;\\n        for(int i=mid;i>=s;i--){\\n            lsum=lsum+nums[i];\\n            if(lsum>lmax){\\n                lmax=lsum;\\n            } \\n        }\\n        for(int i=mid+1;i<=e;i++){\\n            rsum=rsum+nums[i];\\n            if(rsum>rmax){\\n                rmax=rsum;\\n            }\\n        }\\n        int overlapping=rmax+lmax;\\n        int maxisubsum=max(max(rmax,lmax),overlapping);\\n        return maxisubsum;\\n\\n       \\n        \\n    }\\n};"
                    },
                    {
                        "username": "KritimPrasad",
                        "content": "Use sum as 0 and maximum as the first element of the array. use a for loop from 0 to last element of array and add it as sum + the element, and check whether the sum is greater than maximum or not if yes then maximum = sum and also check whether the sum is less than 0 or not if yes then sum =0 and return the maximum value;"
                    },
                    {
                        "username": "mayankindia0122",
                        "content": "I know kadane algo and solved but can anyone tell me if question was that print the maximum subarray it actuall subarray and return type is vector than what changes we need to made in this code\\n int maxSubArray(vector<int>& nums) {\\n       int ans=INT_MIN;\\n       int n=nums.size();\\n       int CS=0;\\n       for(int i=0; i<n; i++)\\n       {\\n           CS+=nums[i];\\n           ans=max(ans,CS);\\n           if(CS<0)\\n           CS=0;\\n       } \\n       return ans;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided finds the maximum subarray sum using Kadane\\'s algorithm, but doesn\\'t keep track of the indices where the maximum sum subarray starts and ends. \\nIf we modify your code to remember the beginning and ending indices of the maximum subarray, we can use those indices to return the maximum subarray itself. Here\\'s how you could do it:\\n\\n```cpp\\nvector<int> maxSubArray(vector<int>& nums) {\\n    int maxSum = INT_MIN, currSum = 0;\\n    int start = 0, end = 0, tempStart = 0;\\n    int n = nums.size();\\n\\n    for(int i = 0; i < n; i++) {\\n        currSum += nums[i];\\n\\n        // If new sum is greater, update maxSum and indices\\n        if (maxSum < currSum) {\\n            maxSum = currSum;\\n            start = tempStart;\\n            end = i;\\n        }\\n\\n        // If current sum is negative, start a new sum\\n        if (currSum < 0) {\\n            currSum = 0;\\n            tempStart = i + 1;\\n        }\\n    }\\n\\n    // Using the start and end indices, construct the max subarray\\n    vector<int> maxSub(nums.begin() + start, nums.begin() + end + 1);\\n\\n    return maxSub;\\n}\\n```\\n\\nIn this updated code, `tempStart` remembers the starting index of a potential maximum subarray. When we find a larger sum, we update `start` and `end` to be the current boundaries of the maximum subarray. After the loop, we use the `start` and `end` indices to create a new vector that contains the maximum subarray, and return that vector.\\n"
                    },
                    {
                        "username": "kaifistan",
                        "content": "int maxSubArray(vector<int>& nums) {\\n        long long sum = 0;\\n        long long maxSum = nums[0];\\n        for(auto itr : nums) {\\n            sum += itr;\\n            maxSum = max(sum, maxSum);\\n            if(sum < 0) sum = 0;\\n        }\\n        return maxSum;\\n    }\\n\\n\\n\\nkanade\\'s Algorithm"
                    }
                ]
            },
            {
                "id": 1790818,
                "content": [
                    {
                        "username": "linedoestrolling",
                        "content": "what do you guys think of such an algorithm\\n1. condense the array(in the sense that you combine all contiguous positive and contiguous negative numbers together so that you end up with an array with alternating positive and negative numbers)\\n2. find the largest number in the condensed array\\n3. pair up positive and negative numbers together starting from the largest number and excluding the largest number(so if the largest number is index 3 in an array of length 7, index 2 and 1 will be paired, 0 will be alone, 4 and 5 will be paired, 6 will be alone.\\n4. recur over and over again until 2 end cases:\\na. length of the array becomes 2(guaranteed to be a positive and negative number, so just take the positive number)\\nb. length of array becomes 3(alternates between positive and negative number e.g. pos neg pos or neg pos neg, so just take the largest number of the 3)\\n\\nim not sure what the time complexity and space complexity of such an algorithm would be, would anyone be so kind as to critique such an algorithm thanks"
                    },
                    {
                        "username": "bparanj",
                        "content": "This is a very interesting approach to the problem. Here\\'s an analysis:\\n\\n1. Condensing the array: This step could be done in O(n), where n is the length of the original array, as you need to traverse the array only once. This operation won\\'t require any additional space (O(1)) because you can modify the original array.\\n\\n2. Finding the largest number: This operation also runs in O(n) time complexity as you have to traverse the entire condensed array. The space complexity is also O(1) as you only need to keep track of the current maximum.\\n\\n3. Pairing up positive and negative numbers: This operation might be quite complex to implement, and it seems like it could potentially result in a time complexity of O(n^2) because in the worst-case scenario, you would need to rearrange elements after each pairing. Also, it\\'s unclear how this step contributes to finding the maximum product subarray.\\n\\nAs for the recursion part, the time complexity could get high, especially with the pairings and rearrangements. Moreover, it\\'s not clear how these operations would help find the maximum product subarray, particularly in cases where negative numbers are involved.\\n\\nFor instance, consider the array [2, -3, 4, -5, -6]. After condensing, you get the same array. The largest number is 4, but the maximum product subarray is [2, -3, 4, -5, -6] with a product of 360. The proposed operations don\\'t seem to capture this.\\n\\nThis problem is best solved using a dynamic programming approach, where for each new element, you calculate the maximum and minimum product ending at that position (to account for potential negative numbers), and then update the global maximum product accordingly. This can be done in O(n) time and O(1) space."
                    },
                    {
                        "username": "fade_jc",
                        "content": "Kadane\\'s algorithm is probably the best way to solve this."
                    },
                    {
                        "username": "code_to_change",
                        "content": "class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int sum=0;\\n        int max_sum=0;\\n        for(int i=0;i<nums.size();i++){ \\n            if(sum+nums[i]>0){\\n                sum+=nums[i];\\n                max_sum=max(max_sum,sum);\\n            }\\n            else{\\n                sum=0;\\n            }\\n        }\\n        if(max_sum==0){\\n            return *max_element(nums.begin(),nums.end());\\n        }\\n        return max_sum;\\n    }\\n};"
                    },
                    {
                        "username": "pcRipper",
                        "content": "(186/210) [2,-1,-1,2,0,-3,3] with expected 3. So am i stupid? "
                    },
                    {
                        "username": "bparanj",
                        "content": "The maximum subarray in your example [2,-1,-1,2,0,-3,3] is [2,-1,-1,2,0,-3,3] itself, and it sums to 3. Here\\'s how you calculate it:\\n\\n    2 - 1 - 1 + 2 + 0 - 3 + 3 = 2\\n\\nThe subarray sums up to 2, not 3. It seems there might be a mistake in the expected result. If the maximum subarray sum was indeed 3, then it seems the input array or expected result is not correct according to the rules of the maximum subarray problem."
                    },
                    {
                        "username": "Explaid",
                        "content": "Maybe subarray is just [3]?"
                    },
                    {
                        "username": "SuriyaT",
                        "content": "i want to know how we fiind a subarray .In my point of view positive to positve ex 4,-1,2,1  -> and one more example  nums = [5,4,-1,7,8] whole index ..Whether my understanding is right?..\\nplease let me know if anyone know this!..\\n "
                    },
                    {
                        "username": "bparanj",
                        "content": "Your understanding is partly right, but there\\'s more to the problem. We\\'re looking for a contiguous subarray (a sub-section of the array) with the largest sum. This doesn\\'t necessarily mean we only add the positive numbers. Negative numbers can also be part of the maximum subarray if they\\'re surrounded by large enough positive numbers. \\n\\nLet\\'s go through the array you provided to illustrate this:\\n\\nGiven array nums = [2,-1,-1,2,0,-3,3]\\n\\nWe start with the first number, 2. This is our current maximum.\\n\\nNext, we add -1, getting a sum of 1. Even though -1 is negative, adding it to our sum still results in a positive number, so we keep this subarray.\\n\\nThe next number is -1 again, our sum becomes 0. It\\'s not beneficial, but it\\'s not reducing our maximum found so far (2), so we keep going.\\n\\nThe next number is 2, so our sum is now 2. This is equal to our maximum found so far.\\n\\nThen we have 0, -3, and 3. Adding these, we end up with a sum of 2, which is equal to our maximum.\\n\\nThe maximum subarray can thus be [2, -1, -1, 2] or [2, -1, -1, 2, 0, -3, 3] both resulting in a sum of 2. \\n\\nYou can see that we have included negative numbers in our subarray because, even though they momentarily decrease the sum, they may be part of a larger sum subarray. The algorithm essentially tries different \"parts\" of the array to find the combination that yields the highest sum."
                    },
                    {
                        "username": "Yash_kumbhawat",
                        "content": "class Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum1=0;\\n        int sum = Integer.MIN_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            sum1+= nums[i];\\n           sum = Math.max(sum,sum1);\\n            if(sum1<0){\\n                sum1=0;\\n            }\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "akshita79",
                        "content": "I\\'m new to divide and conquer can someone tell me where I am wrong in this code?\\n(maximum subarray problem )\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums,int s,int e) {\\n        int mid;\\n         s=nums.front();\\n         e=nums.back();\\n        if(s==e){\\n            return nums.at(s);\\n        }\\n         mid=e+(s-e)/2;\\n        int leftpart=maxSubArray(nums,s,mid);\\n        int rightpart=maxSubArray(nums,mid+1,e);\\n        int rmax=0;\\n        int lmax=0;\\n        int lsum=0;\\n        int rsum=0;\\n        for(int i=mid;i>=s;i--){\\n            lsum=lsum+nums[i];\\n            if(lsum>lmax){\\n                lmax=lsum;\\n            } \\n        }\\n        for(int i=mid+1;i<=e;i++){\\n            rsum=rsum+nums[i];\\n            if(rsum>rmax){\\n                rmax=rsum;\\n            }\\n        }\\n        int overlapping=rmax+lmax;\\n        int maxisubsum=max(max(rmax,lmax),overlapping);\\n        return maxisubsum;\\n\\n       \\n        \\n    }\\n};"
                    },
                    {
                        "username": "KritimPrasad",
                        "content": "Use sum as 0 and maximum as the first element of the array. use a for loop from 0 to last element of array and add it as sum + the element, and check whether the sum is greater than maximum or not if yes then maximum = sum and also check whether the sum is less than 0 or not if yes then sum =0 and return the maximum value;"
                    },
                    {
                        "username": "mayankindia0122",
                        "content": "I know kadane algo and solved but can anyone tell me if question was that print the maximum subarray it actuall subarray and return type is vector than what changes we need to made in this code\\n int maxSubArray(vector<int>& nums) {\\n       int ans=INT_MIN;\\n       int n=nums.size();\\n       int CS=0;\\n       for(int i=0; i<n; i++)\\n       {\\n           CS+=nums[i];\\n           ans=max(ans,CS);\\n           if(CS<0)\\n           CS=0;\\n       } \\n       return ans;\\n    }"
                    },
                    {
                        "username": "bparanj",
                        "content": "The code you provided finds the maximum subarray sum using Kadane\\'s algorithm, but doesn\\'t keep track of the indices where the maximum sum subarray starts and ends. \\nIf we modify your code to remember the beginning and ending indices of the maximum subarray, we can use those indices to return the maximum subarray itself. Here\\'s how you could do it:\\n\\n```cpp\\nvector<int> maxSubArray(vector<int>& nums) {\\n    int maxSum = INT_MIN, currSum = 0;\\n    int start = 0, end = 0, tempStart = 0;\\n    int n = nums.size();\\n\\n    for(int i = 0; i < n; i++) {\\n        currSum += nums[i];\\n\\n        // If new sum is greater, update maxSum and indices\\n        if (maxSum < currSum) {\\n            maxSum = currSum;\\n            start = tempStart;\\n            end = i;\\n        }\\n\\n        // If current sum is negative, start a new sum\\n        if (currSum < 0) {\\n            currSum = 0;\\n            tempStart = i + 1;\\n        }\\n    }\\n\\n    // Using the start and end indices, construct the max subarray\\n    vector<int> maxSub(nums.begin() + start, nums.begin() + end + 1);\\n\\n    return maxSub;\\n}\\n```\\n\\nIn this updated code, `tempStart` remembers the starting index of a potential maximum subarray. When we find a larger sum, we update `start` and `end` to be the current boundaries of the maximum subarray. After the loop, we use the `start` and `end` indices to create a new vector that contains the maximum subarray, and return that vector.\\n"
                    },
                    {
                        "username": "kaifistan",
                        "content": "int maxSubArray(vector<int>& nums) {\\n        long long sum = 0;\\n        long long maxSum = nums[0];\\n        for(auto itr : nums) {\\n            sum += itr;\\n            maxSum = max(sum, maxSum);\\n            if(sum < 0) sum = 0;\\n        }\\n        return maxSum;\\n    }\\n\\n\\n\\nkanade\\'s Algorithm"
                    }
                ]
            },
            {
                "id": 1787843,
                "content": [
                    {
                        "username": "Mohan_66",
                        "content": "Just a normal problem but the way of approach for the first time is going to be touch..."
                    },
                    {
                        "username": "sthrizvi1990",
                        "content": "public int maxSubArray(int[] nums) {\\n        int cur_sum =  0;\\n        int max_sum= Integer.MIN_VALUE;\\n        if(nums.length ==1)\\n        {\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            cur_sum = cur_sum+nums[i];\\n            if(cur_sum>max_sum)\\n            {\\n                max_sum = cur_sum;\\n            }\\n\\n            if(cur_sum<0)\\n            {\\n                cur_sum = 0;\\n            }\\n        }\\n\\n        return max_sum;\\n    }"
                    },
                    {
                        "username": "srijan_soni",
                        "content": "i have solved this through Kadane\\'s algorithm ( 0(n) approach ), I wonder if any other 0(n) exist ;)"
                    },
                    {
                        "username": "jmeena660",
                        "content": "class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        vector<int>a(nums.size(),0);\\n        int n=nums.size();\\n        for(int i=1;i<n;i++){\\n            nums[i]=nums[i]+nums[n-i];\\n        }\\n        \\n        a=nums;\\n        for(int i=1;i<n;i++){\\n            a[i]=a[i]-a[n-1];\\n        }\\n        \\n            int max = a[0];\\n \\n\\n    for (int j = 1; j < n; j++)\\n        if (a[j] > max)\\n            max = a[j];\\n \\n    return max;\\n        \\n    }\\n};//im getting error is this write approach to do this problem "
                    },
                    {
                        "username": "bparanj",
                        "content": "There seem to be a few issues in the code you posted. \\n\\n1. Syntax Error: You need to declare the data type of your vector `a`. So, it should be `vector<int> a(nums.size(), 0);` instead of `vector a(nums.size(), 0);`.\\n\\n2. Invalid Indexing: The line `nums[i] = nums[i] + nums[n-i];` could result in accessing elements beyond the array when `i = 0`. Because `n-i` when `i = 0` would give `n`, and `nums[n]` is out of bounds.\\n\\n3. Incorrect Logic: The logic you are using doesn\\'t seem to follow the Kadane\\'s algorithm, which is the recommended approach for the maximum subarray problem. The operations you\\'re performing on the array don\\'t align with finding the maximum sum of a subarray. \\n\\nHere\\'s an example of a correct implementation using Kadane\\'s algorithm:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int max_sum = INT_MIN, curr_sum = 0;\\n        int n = nums.size();\\n\\n        for (int i = 0; i < n; i++) {\\n            curr_sum += nums[i];\\n            if (max_sum < curr_sum)\\n                max_sum = curr_sum;\\n            if (curr_sum < 0)\\n                curr_sum = 0;\\n        }\\n\\n        return max_sum;\\n    }\\n};\\n```\\n\\nThis implementation starts with `max_sum` set to the smallest possible integer and `curr_sum` set to 0. It iterates through the array, adding the current number to `curr_sum`. If `curr_sum` is larger than `max_sum`, `max_sum` is updated. If `curr_sum` becomes negative, it is reset to 0. At the end of the iteration, `max_sum` contains the maximum sum of a subarray in `nums`."
                    },
                    {
                        "username": "jenil252525",
                        "content": "solved\\n"
                    },
                    {
                        "username": "JyotiHariyale",
                        "content": "i found error when i used kadane algorithm"
                    },
                    {
                        "username": "saifmd538",
                        "content": "how could i solve this with divide and conquer?? if anyone know please explain it..."
                    },
                    {
                        "username": "bparanj",
                        "content": "The divide and conquer approach for the maximum subarray problem is a bit more complex than the iterative approach like Kadane\\'s algorithm. It is based on the principle of breaking down the problem into smaller subproblems, solving them, and combining their results to find the solution to the original problem. Here\\'s a step by step breakdown:\\n\\n1. Divide the given array in two halves.\\n2. Return the maximum of the following three:\\n   * Maximum subarray sum in the left half (recursive call).\\n   * Maximum subarray sum in the right half (recursive call).\\n   * Maximum subarray sum such that the subarray crosses the midpoint.\\n\\nThe third case is handled differently. We first find the maximum sum starting from the mid point and ending at some point on the left half, then find the maximum sum starting from mid + 1 and ending at some point on the right half and finally combine the two.\\n\\nHere\\'s the C++ code that implements this:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int crossSum(vector<int>& nums, int left, int right, int mid) {\\n        if (left == right) return nums[left];\\n\\n        int leftSubsum = INT_MIN;\\n        int currSum = 0;\\n        for (int i = mid; i > left - 1; --i) {\\n            currSum += nums[i];\\n            leftSubsum = max(leftSubsum, currSum);\\n        }\\n\\n        int rightSubsum = INT_MIN;\\n        currSum = 0;\\n        for (int i = mid + 1; i < right + 1; ++i) {\\n            currSum += nums[i];\\n            rightSubsum = max(rightSubsum, currSum);\\n        }\\n\\n        return leftSubsum + rightSubsum;\\n    }\\n\\n    int helper(vector<int>& nums, int left, int right) {\\n        if (left == right) return nums[left];\\n\\n        int mid = left + (right - left) / 2;\\n\\n        int leftSum = helper(nums, left, mid);\\n        int rightSum = helper(nums, mid + 1, right);\\n        int crossSum = this->crossSum(nums, left, right, mid);\\n\\n        return max(max(leftSum, rightSum), crossSum);\\n    }\\n\\n    int maxSubArray(vector<int>& nums) {\\n        return helper(nums, 0, nums.size() - 1);\\n    }\\n};\\n```\\nIn the code above, `crossSum` calculates the maximum subarray sum that crosses the midpoint, `helper` performs the recursive division of the array and calculates the maximum subarray sums, and `maxSubArray` is the main function that calls `helper` to start the recursion. The result of `maxSubArray` is the maximum subarray sum in the input array `nums`."
                    },
                    {
                        "username": "java_run",
                        "content": "For the test case {-1,-2} or any test cases containing all negative numbers , why is the expected ans not zero (coz we can always choose an empty sub array) , but the expected ans is -1 in case of (-1,-2) \n\nI tried the Kadane's approach before , but I was getting an error ,  "
                    },
                    {
                        "username": "6vedant",
                        "content": "Why my solution is beating only 41% of answers? Any help please to improve my working code.\\n\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int maxSoFar = Integer.MIN_VALUE;\\n        int maxTillYet = 0;\\n\\n        for(int i=0; i<nums.length; i++) {\\n            maxTillYet += nums[i];\\n            if (maxSoFar < maxTillYet) {\\n                maxSoFar = maxTillYet;\\n            }\\n            if (maxTillYet < 0) {\\n                maxTillYet = 0;\\n            }\\n        }\\n        return maxSoFar;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is using Kadane\\'s algorithm, which is the most optimal solution for the maximum subarray problem. It already runs in O(n) time complexity and uses O(1) space complexity, meaning you can\\'t really optimize it further from a time or space complexity standpoint.\\n\\nThe percentage you see on online judge platforms like LeetCode (41% in your case) is not entirely dependent on the efficiency of your algorithm. The speed of your solution can also be affected by factors that aren\\'t really related to the algorithm\\'s efficiency, like:\\n\\n- The programming language you use: Some languages are inherently faster than others. Solutions in languages like C or C++ often run faster than equivalent solutions in languages like Python or Java.\\n- System-level factors: These include things like the load on the online judge servers at the time of submission, the system\\'s I/O processing speed, etc.\\n\\nTherefore, while it\\'s always a good idea to aim for efficient code, don\\'t be too concerned about the percentage reported by the online judge system. It\\'s more important to make sure that your solution is correct, readable, and as efficient as it can be in terms of time and space complexity."
                    },
                    {
                        "username": "jokandre",
                        "content": "# Intuition behind kadane\\'s algo\\n\\nAt index ```i``` what it the max subarray sum?\\n- Can previous sum, nums[i-1], help maximize my current nums[i] \\n\\nGiven ```nums=[-2, 1] , i=1```\\n\\nRelationship between previous sum and current number: In order to maximize it\\n\\n| prev sum | cur  | max |  why  | \\n|---|---|---|-----|\\n| +1 | +1 |  1+1 |  prev+ cur   |\\n| -1 | +1 |  1 |  cur  |\\n| +1 | -1 | 0  |  prev+cur, cur must be included always!  |\\n| -1 | -1 | -1  |  cur |\\n\\nOptions:\\n- nums[i] is **positive**, then nums[i] is part of the solution\\n\\t- ```nums[i-1] + nums[i]``` : previous + i\\n\\t- ```nums[i]``` : previous discarted, perhaps sum to 0 or negative number\\n\\t\\n- nums[i] is **negative**\\n\\t- ```nums[i-1]+nums[i]```: previous being is positive will help increasing nums[i]\\n\\t- ```nums[i]```: if both previous is also negative it should not be added \\n\\nHope it helps\\n\\n\\n\\t"
                    }
                ]
            },
            {
                "id": 1786013,
                "content": [
                    {
                        "username": "Mohan_66",
                        "content": "Just a normal problem but the way of approach for the first time is going to be touch..."
                    },
                    {
                        "username": "sthrizvi1990",
                        "content": "public int maxSubArray(int[] nums) {\\n        int cur_sum =  0;\\n        int max_sum= Integer.MIN_VALUE;\\n        if(nums.length ==1)\\n        {\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            cur_sum = cur_sum+nums[i];\\n            if(cur_sum>max_sum)\\n            {\\n                max_sum = cur_sum;\\n            }\\n\\n            if(cur_sum<0)\\n            {\\n                cur_sum = 0;\\n            }\\n        }\\n\\n        return max_sum;\\n    }"
                    },
                    {
                        "username": "srijan_soni",
                        "content": "i have solved this through Kadane\\'s algorithm ( 0(n) approach ), I wonder if any other 0(n) exist ;)"
                    },
                    {
                        "username": "jmeena660",
                        "content": "class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        vector<int>a(nums.size(),0);\\n        int n=nums.size();\\n        for(int i=1;i<n;i++){\\n            nums[i]=nums[i]+nums[n-i];\\n        }\\n        \\n        a=nums;\\n        for(int i=1;i<n;i++){\\n            a[i]=a[i]-a[n-1];\\n        }\\n        \\n            int max = a[0];\\n \\n\\n    for (int j = 1; j < n; j++)\\n        if (a[j] > max)\\n            max = a[j];\\n \\n    return max;\\n        \\n    }\\n};//im getting error is this write approach to do this problem "
                    },
                    {
                        "username": "bparanj",
                        "content": "There seem to be a few issues in the code you posted. \\n\\n1. Syntax Error: You need to declare the data type of your vector `a`. So, it should be `vector<int> a(nums.size(), 0);` instead of `vector a(nums.size(), 0);`.\\n\\n2. Invalid Indexing: The line `nums[i] = nums[i] + nums[n-i];` could result in accessing elements beyond the array when `i = 0`. Because `n-i` when `i = 0` would give `n`, and `nums[n]` is out of bounds.\\n\\n3. Incorrect Logic: The logic you are using doesn\\'t seem to follow the Kadane\\'s algorithm, which is the recommended approach for the maximum subarray problem. The operations you\\'re performing on the array don\\'t align with finding the maximum sum of a subarray. \\n\\nHere\\'s an example of a correct implementation using Kadane\\'s algorithm:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int max_sum = INT_MIN, curr_sum = 0;\\n        int n = nums.size();\\n\\n        for (int i = 0; i < n; i++) {\\n            curr_sum += nums[i];\\n            if (max_sum < curr_sum)\\n                max_sum = curr_sum;\\n            if (curr_sum < 0)\\n                curr_sum = 0;\\n        }\\n\\n        return max_sum;\\n    }\\n};\\n```\\n\\nThis implementation starts with `max_sum` set to the smallest possible integer and `curr_sum` set to 0. It iterates through the array, adding the current number to `curr_sum`. If `curr_sum` is larger than `max_sum`, `max_sum` is updated. If `curr_sum` becomes negative, it is reset to 0. At the end of the iteration, `max_sum` contains the maximum sum of a subarray in `nums`."
                    },
                    {
                        "username": "jenil252525",
                        "content": "solved\\n"
                    },
                    {
                        "username": "JyotiHariyale",
                        "content": "i found error when i used kadane algorithm"
                    },
                    {
                        "username": "saifmd538",
                        "content": "how could i solve this with divide and conquer?? if anyone know please explain it..."
                    },
                    {
                        "username": "bparanj",
                        "content": "The divide and conquer approach for the maximum subarray problem is a bit more complex than the iterative approach like Kadane\\'s algorithm. It is based on the principle of breaking down the problem into smaller subproblems, solving them, and combining their results to find the solution to the original problem. Here\\'s a step by step breakdown:\\n\\n1. Divide the given array in two halves.\\n2. Return the maximum of the following three:\\n   * Maximum subarray sum in the left half (recursive call).\\n   * Maximum subarray sum in the right half (recursive call).\\n   * Maximum subarray sum such that the subarray crosses the midpoint.\\n\\nThe third case is handled differently. We first find the maximum sum starting from the mid point and ending at some point on the left half, then find the maximum sum starting from mid + 1 and ending at some point on the right half and finally combine the two.\\n\\nHere\\'s the C++ code that implements this:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int crossSum(vector<int>& nums, int left, int right, int mid) {\\n        if (left == right) return nums[left];\\n\\n        int leftSubsum = INT_MIN;\\n        int currSum = 0;\\n        for (int i = mid; i > left - 1; --i) {\\n            currSum += nums[i];\\n            leftSubsum = max(leftSubsum, currSum);\\n        }\\n\\n        int rightSubsum = INT_MIN;\\n        currSum = 0;\\n        for (int i = mid + 1; i < right + 1; ++i) {\\n            currSum += nums[i];\\n            rightSubsum = max(rightSubsum, currSum);\\n        }\\n\\n        return leftSubsum + rightSubsum;\\n    }\\n\\n    int helper(vector<int>& nums, int left, int right) {\\n        if (left == right) return nums[left];\\n\\n        int mid = left + (right - left) / 2;\\n\\n        int leftSum = helper(nums, left, mid);\\n        int rightSum = helper(nums, mid + 1, right);\\n        int crossSum = this->crossSum(nums, left, right, mid);\\n\\n        return max(max(leftSum, rightSum), crossSum);\\n    }\\n\\n    int maxSubArray(vector<int>& nums) {\\n        return helper(nums, 0, nums.size() - 1);\\n    }\\n};\\n```\\nIn the code above, `crossSum` calculates the maximum subarray sum that crosses the midpoint, `helper` performs the recursive division of the array and calculates the maximum subarray sums, and `maxSubArray` is the main function that calls `helper` to start the recursion. The result of `maxSubArray` is the maximum subarray sum in the input array `nums`."
                    },
                    {
                        "username": "java_run",
                        "content": "For the test case {-1,-2} or any test cases containing all negative numbers , why is the expected ans not zero (coz we can always choose an empty sub array) , but the expected ans is -1 in case of (-1,-2) \n\nI tried the Kadane's approach before , but I was getting an error ,  "
                    },
                    {
                        "username": "6vedant",
                        "content": "Why my solution is beating only 41% of answers? Any help please to improve my working code.\\n\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int maxSoFar = Integer.MIN_VALUE;\\n        int maxTillYet = 0;\\n\\n        for(int i=0; i<nums.length; i++) {\\n            maxTillYet += nums[i];\\n            if (maxSoFar < maxTillYet) {\\n                maxSoFar = maxTillYet;\\n            }\\n            if (maxTillYet < 0) {\\n                maxTillYet = 0;\\n            }\\n        }\\n        return maxSoFar;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is using Kadane\\'s algorithm, which is the most optimal solution for the maximum subarray problem. It already runs in O(n) time complexity and uses O(1) space complexity, meaning you can\\'t really optimize it further from a time or space complexity standpoint.\\n\\nThe percentage you see on online judge platforms like LeetCode (41% in your case) is not entirely dependent on the efficiency of your algorithm. The speed of your solution can also be affected by factors that aren\\'t really related to the algorithm\\'s efficiency, like:\\n\\n- The programming language you use: Some languages are inherently faster than others. Solutions in languages like C or C++ often run faster than equivalent solutions in languages like Python or Java.\\n- System-level factors: These include things like the load on the online judge servers at the time of submission, the system\\'s I/O processing speed, etc.\\n\\nTherefore, while it\\'s always a good idea to aim for efficient code, don\\'t be too concerned about the percentage reported by the online judge system. It\\'s more important to make sure that your solution is correct, readable, and as efficient as it can be in terms of time and space complexity."
                    },
                    {
                        "username": "jokandre",
                        "content": "# Intuition behind kadane\\'s algo\\n\\nAt index ```i``` what it the max subarray sum?\\n- Can previous sum, nums[i-1], help maximize my current nums[i] \\n\\nGiven ```nums=[-2, 1] , i=1```\\n\\nRelationship between previous sum and current number: In order to maximize it\\n\\n| prev sum | cur  | max |  why  | \\n|---|---|---|-----|\\n| +1 | +1 |  1+1 |  prev+ cur   |\\n| -1 | +1 |  1 |  cur  |\\n| +1 | -1 | 0  |  prev+cur, cur must be included always!  |\\n| -1 | -1 | -1  |  cur |\\n\\nOptions:\\n- nums[i] is **positive**, then nums[i] is part of the solution\\n\\t- ```nums[i-1] + nums[i]``` : previous + i\\n\\t- ```nums[i]``` : previous discarted, perhaps sum to 0 or negative number\\n\\t\\n- nums[i] is **negative**\\n\\t- ```nums[i-1]+nums[i]```: previous being is positive will help increasing nums[i]\\n\\t- ```nums[i]```: if both previous is also negative it should not be added \\n\\nHope it helps\\n\\n\\n\\t"
                    }
                ]
            },
            {
                "id": 1784392,
                "content": [
                    {
                        "username": "Mohan_66",
                        "content": "Just a normal problem but the way of approach for the first time is going to be touch..."
                    },
                    {
                        "username": "sthrizvi1990",
                        "content": "public int maxSubArray(int[] nums) {\\n        int cur_sum =  0;\\n        int max_sum= Integer.MIN_VALUE;\\n        if(nums.length ==1)\\n        {\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            cur_sum = cur_sum+nums[i];\\n            if(cur_sum>max_sum)\\n            {\\n                max_sum = cur_sum;\\n            }\\n\\n            if(cur_sum<0)\\n            {\\n                cur_sum = 0;\\n            }\\n        }\\n\\n        return max_sum;\\n    }"
                    },
                    {
                        "username": "srijan_soni",
                        "content": "i have solved this through Kadane\\'s algorithm ( 0(n) approach ), I wonder if any other 0(n) exist ;)"
                    },
                    {
                        "username": "jmeena660",
                        "content": "class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        vector<int>a(nums.size(),0);\\n        int n=nums.size();\\n        for(int i=1;i<n;i++){\\n            nums[i]=nums[i]+nums[n-i];\\n        }\\n        \\n        a=nums;\\n        for(int i=1;i<n;i++){\\n            a[i]=a[i]-a[n-1];\\n        }\\n        \\n            int max = a[0];\\n \\n\\n    for (int j = 1; j < n; j++)\\n        if (a[j] > max)\\n            max = a[j];\\n \\n    return max;\\n        \\n    }\\n};//im getting error is this write approach to do this problem "
                    },
                    {
                        "username": "bparanj",
                        "content": "There seem to be a few issues in the code you posted. \\n\\n1. Syntax Error: You need to declare the data type of your vector `a`. So, it should be `vector<int> a(nums.size(), 0);` instead of `vector a(nums.size(), 0);`.\\n\\n2. Invalid Indexing: The line `nums[i] = nums[i] + nums[n-i];` could result in accessing elements beyond the array when `i = 0`. Because `n-i` when `i = 0` would give `n`, and `nums[n]` is out of bounds.\\n\\n3. Incorrect Logic: The logic you are using doesn\\'t seem to follow the Kadane\\'s algorithm, which is the recommended approach for the maximum subarray problem. The operations you\\'re performing on the array don\\'t align with finding the maximum sum of a subarray. \\n\\nHere\\'s an example of a correct implementation using Kadane\\'s algorithm:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int max_sum = INT_MIN, curr_sum = 0;\\n        int n = nums.size();\\n\\n        for (int i = 0; i < n; i++) {\\n            curr_sum += nums[i];\\n            if (max_sum < curr_sum)\\n                max_sum = curr_sum;\\n            if (curr_sum < 0)\\n                curr_sum = 0;\\n        }\\n\\n        return max_sum;\\n    }\\n};\\n```\\n\\nThis implementation starts with `max_sum` set to the smallest possible integer and `curr_sum` set to 0. It iterates through the array, adding the current number to `curr_sum`. If `curr_sum` is larger than `max_sum`, `max_sum` is updated. If `curr_sum` becomes negative, it is reset to 0. At the end of the iteration, `max_sum` contains the maximum sum of a subarray in `nums`."
                    },
                    {
                        "username": "jenil252525",
                        "content": "solved\\n"
                    },
                    {
                        "username": "JyotiHariyale",
                        "content": "i found error when i used kadane algorithm"
                    },
                    {
                        "username": "saifmd538",
                        "content": "how could i solve this with divide and conquer?? if anyone know please explain it..."
                    },
                    {
                        "username": "bparanj",
                        "content": "The divide and conquer approach for the maximum subarray problem is a bit more complex than the iterative approach like Kadane\\'s algorithm. It is based on the principle of breaking down the problem into smaller subproblems, solving them, and combining their results to find the solution to the original problem. Here\\'s a step by step breakdown:\\n\\n1. Divide the given array in two halves.\\n2. Return the maximum of the following three:\\n   * Maximum subarray sum in the left half (recursive call).\\n   * Maximum subarray sum in the right half (recursive call).\\n   * Maximum subarray sum such that the subarray crosses the midpoint.\\n\\nThe third case is handled differently. We first find the maximum sum starting from the mid point and ending at some point on the left half, then find the maximum sum starting from mid + 1 and ending at some point on the right half and finally combine the two.\\n\\nHere\\'s the C++ code that implements this:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int crossSum(vector<int>& nums, int left, int right, int mid) {\\n        if (left == right) return nums[left];\\n\\n        int leftSubsum = INT_MIN;\\n        int currSum = 0;\\n        for (int i = mid; i > left - 1; --i) {\\n            currSum += nums[i];\\n            leftSubsum = max(leftSubsum, currSum);\\n        }\\n\\n        int rightSubsum = INT_MIN;\\n        currSum = 0;\\n        for (int i = mid + 1; i < right + 1; ++i) {\\n            currSum += nums[i];\\n            rightSubsum = max(rightSubsum, currSum);\\n        }\\n\\n        return leftSubsum + rightSubsum;\\n    }\\n\\n    int helper(vector<int>& nums, int left, int right) {\\n        if (left == right) return nums[left];\\n\\n        int mid = left + (right - left) / 2;\\n\\n        int leftSum = helper(nums, left, mid);\\n        int rightSum = helper(nums, mid + 1, right);\\n        int crossSum = this->crossSum(nums, left, right, mid);\\n\\n        return max(max(leftSum, rightSum), crossSum);\\n    }\\n\\n    int maxSubArray(vector<int>& nums) {\\n        return helper(nums, 0, nums.size() - 1);\\n    }\\n};\\n```\\nIn the code above, `crossSum` calculates the maximum subarray sum that crosses the midpoint, `helper` performs the recursive division of the array and calculates the maximum subarray sums, and `maxSubArray` is the main function that calls `helper` to start the recursion. The result of `maxSubArray` is the maximum subarray sum in the input array `nums`."
                    },
                    {
                        "username": "java_run",
                        "content": "For the test case {-1,-2} or any test cases containing all negative numbers , why is the expected ans not zero (coz we can always choose an empty sub array) , but the expected ans is -1 in case of (-1,-2) \n\nI tried the Kadane's approach before , but I was getting an error ,  "
                    },
                    {
                        "username": "6vedant",
                        "content": "Why my solution is beating only 41% of answers? Any help please to improve my working code.\\n\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int maxSoFar = Integer.MIN_VALUE;\\n        int maxTillYet = 0;\\n\\n        for(int i=0; i<nums.length; i++) {\\n            maxTillYet += nums[i];\\n            if (maxSoFar < maxTillYet) {\\n                maxSoFar = maxTillYet;\\n            }\\n            if (maxTillYet < 0) {\\n                maxTillYet = 0;\\n            }\\n        }\\n        return maxSoFar;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is using Kadane\\'s algorithm, which is the most optimal solution for the maximum subarray problem. It already runs in O(n) time complexity and uses O(1) space complexity, meaning you can\\'t really optimize it further from a time or space complexity standpoint.\\n\\nThe percentage you see on online judge platforms like LeetCode (41% in your case) is not entirely dependent on the efficiency of your algorithm. The speed of your solution can also be affected by factors that aren\\'t really related to the algorithm\\'s efficiency, like:\\n\\n- The programming language you use: Some languages are inherently faster than others. Solutions in languages like C or C++ often run faster than equivalent solutions in languages like Python or Java.\\n- System-level factors: These include things like the load on the online judge servers at the time of submission, the system\\'s I/O processing speed, etc.\\n\\nTherefore, while it\\'s always a good idea to aim for efficient code, don\\'t be too concerned about the percentage reported by the online judge system. It\\'s more important to make sure that your solution is correct, readable, and as efficient as it can be in terms of time and space complexity."
                    },
                    {
                        "username": "jokandre",
                        "content": "# Intuition behind kadane\\'s algo\\n\\nAt index ```i``` what it the max subarray sum?\\n- Can previous sum, nums[i-1], help maximize my current nums[i] \\n\\nGiven ```nums=[-2, 1] , i=1```\\n\\nRelationship between previous sum and current number: In order to maximize it\\n\\n| prev sum | cur  | max |  why  | \\n|---|---|---|-----|\\n| +1 | +1 |  1+1 |  prev+ cur   |\\n| -1 | +1 |  1 |  cur  |\\n| +1 | -1 | 0  |  prev+cur, cur must be included always!  |\\n| -1 | -1 | -1  |  cur |\\n\\nOptions:\\n- nums[i] is **positive**, then nums[i] is part of the solution\\n\\t- ```nums[i-1] + nums[i]``` : previous + i\\n\\t- ```nums[i]``` : previous discarted, perhaps sum to 0 or negative number\\n\\t\\n- nums[i] is **negative**\\n\\t- ```nums[i-1]+nums[i]```: previous being is positive will help increasing nums[i]\\n\\t- ```nums[i]```: if both previous is also negative it should not be added \\n\\nHope it helps\\n\\n\\n\\t"
                    }
                ]
            },
            {
                "id": 1783745,
                "content": [
                    {
                        "username": "Mohan_66",
                        "content": "Just a normal problem but the way of approach for the first time is going to be touch..."
                    },
                    {
                        "username": "sthrizvi1990",
                        "content": "public int maxSubArray(int[] nums) {\\n        int cur_sum =  0;\\n        int max_sum= Integer.MIN_VALUE;\\n        if(nums.length ==1)\\n        {\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            cur_sum = cur_sum+nums[i];\\n            if(cur_sum>max_sum)\\n            {\\n                max_sum = cur_sum;\\n            }\\n\\n            if(cur_sum<0)\\n            {\\n                cur_sum = 0;\\n            }\\n        }\\n\\n        return max_sum;\\n    }"
                    },
                    {
                        "username": "srijan_soni",
                        "content": "i have solved this through Kadane\\'s algorithm ( 0(n) approach ), I wonder if any other 0(n) exist ;)"
                    },
                    {
                        "username": "jmeena660",
                        "content": "class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        vector<int>a(nums.size(),0);\\n        int n=nums.size();\\n        for(int i=1;i<n;i++){\\n            nums[i]=nums[i]+nums[n-i];\\n        }\\n        \\n        a=nums;\\n        for(int i=1;i<n;i++){\\n            a[i]=a[i]-a[n-1];\\n        }\\n        \\n            int max = a[0];\\n \\n\\n    for (int j = 1; j < n; j++)\\n        if (a[j] > max)\\n            max = a[j];\\n \\n    return max;\\n        \\n    }\\n};//im getting error is this write approach to do this problem "
                    },
                    {
                        "username": "bparanj",
                        "content": "There seem to be a few issues in the code you posted. \\n\\n1. Syntax Error: You need to declare the data type of your vector `a`. So, it should be `vector<int> a(nums.size(), 0);` instead of `vector a(nums.size(), 0);`.\\n\\n2. Invalid Indexing: The line `nums[i] = nums[i] + nums[n-i];` could result in accessing elements beyond the array when `i = 0`. Because `n-i` when `i = 0` would give `n`, and `nums[n]` is out of bounds.\\n\\n3. Incorrect Logic: The logic you are using doesn\\'t seem to follow the Kadane\\'s algorithm, which is the recommended approach for the maximum subarray problem. The operations you\\'re performing on the array don\\'t align with finding the maximum sum of a subarray. \\n\\nHere\\'s an example of a correct implementation using Kadane\\'s algorithm:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int max_sum = INT_MIN, curr_sum = 0;\\n        int n = nums.size();\\n\\n        for (int i = 0; i < n; i++) {\\n            curr_sum += nums[i];\\n            if (max_sum < curr_sum)\\n                max_sum = curr_sum;\\n            if (curr_sum < 0)\\n                curr_sum = 0;\\n        }\\n\\n        return max_sum;\\n    }\\n};\\n```\\n\\nThis implementation starts with `max_sum` set to the smallest possible integer and `curr_sum` set to 0. It iterates through the array, adding the current number to `curr_sum`. If `curr_sum` is larger than `max_sum`, `max_sum` is updated. If `curr_sum` becomes negative, it is reset to 0. At the end of the iteration, `max_sum` contains the maximum sum of a subarray in `nums`."
                    },
                    {
                        "username": "jenil252525",
                        "content": "solved\\n"
                    },
                    {
                        "username": "JyotiHariyale",
                        "content": "i found error when i used kadane algorithm"
                    },
                    {
                        "username": "saifmd538",
                        "content": "how could i solve this with divide and conquer?? if anyone know please explain it..."
                    },
                    {
                        "username": "bparanj",
                        "content": "The divide and conquer approach for the maximum subarray problem is a bit more complex than the iterative approach like Kadane\\'s algorithm. It is based on the principle of breaking down the problem into smaller subproblems, solving them, and combining their results to find the solution to the original problem. Here\\'s a step by step breakdown:\\n\\n1. Divide the given array in two halves.\\n2. Return the maximum of the following three:\\n   * Maximum subarray sum in the left half (recursive call).\\n   * Maximum subarray sum in the right half (recursive call).\\n   * Maximum subarray sum such that the subarray crosses the midpoint.\\n\\nThe third case is handled differently. We first find the maximum sum starting from the mid point and ending at some point on the left half, then find the maximum sum starting from mid + 1 and ending at some point on the right half and finally combine the two.\\n\\nHere\\'s the C++ code that implements this:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int crossSum(vector<int>& nums, int left, int right, int mid) {\\n        if (left == right) return nums[left];\\n\\n        int leftSubsum = INT_MIN;\\n        int currSum = 0;\\n        for (int i = mid; i > left - 1; --i) {\\n            currSum += nums[i];\\n            leftSubsum = max(leftSubsum, currSum);\\n        }\\n\\n        int rightSubsum = INT_MIN;\\n        currSum = 0;\\n        for (int i = mid + 1; i < right + 1; ++i) {\\n            currSum += nums[i];\\n            rightSubsum = max(rightSubsum, currSum);\\n        }\\n\\n        return leftSubsum + rightSubsum;\\n    }\\n\\n    int helper(vector<int>& nums, int left, int right) {\\n        if (left == right) return nums[left];\\n\\n        int mid = left + (right - left) / 2;\\n\\n        int leftSum = helper(nums, left, mid);\\n        int rightSum = helper(nums, mid + 1, right);\\n        int crossSum = this->crossSum(nums, left, right, mid);\\n\\n        return max(max(leftSum, rightSum), crossSum);\\n    }\\n\\n    int maxSubArray(vector<int>& nums) {\\n        return helper(nums, 0, nums.size() - 1);\\n    }\\n};\\n```\\nIn the code above, `crossSum` calculates the maximum subarray sum that crosses the midpoint, `helper` performs the recursive division of the array and calculates the maximum subarray sums, and `maxSubArray` is the main function that calls `helper` to start the recursion. The result of `maxSubArray` is the maximum subarray sum in the input array `nums`."
                    },
                    {
                        "username": "java_run",
                        "content": "For the test case {-1,-2} or any test cases containing all negative numbers , why is the expected ans not zero (coz we can always choose an empty sub array) , but the expected ans is -1 in case of (-1,-2) \n\nI tried the Kadane's approach before , but I was getting an error ,  "
                    },
                    {
                        "username": "6vedant",
                        "content": "Why my solution is beating only 41% of answers? Any help please to improve my working code.\\n\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int maxSoFar = Integer.MIN_VALUE;\\n        int maxTillYet = 0;\\n\\n        for(int i=0; i<nums.length; i++) {\\n            maxTillYet += nums[i];\\n            if (maxSoFar < maxTillYet) {\\n                maxSoFar = maxTillYet;\\n            }\\n            if (maxTillYet < 0) {\\n                maxTillYet = 0;\\n            }\\n        }\\n        return maxSoFar;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is using Kadane\\'s algorithm, which is the most optimal solution for the maximum subarray problem. It already runs in O(n) time complexity and uses O(1) space complexity, meaning you can\\'t really optimize it further from a time or space complexity standpoint.\\n\\nThe percentage you see on online judge platforms like LeetCode (41% in your case) is not entirely dependent on the efficiency of your algorithm. The speed of your solution can also be affected by factors that aren\\'t really related to the algorithm\\'s efficiency, like:\\n\\n- The programming language you use: Some languages are inherently faster than others. Solutions in languages like C or C++ often run faster than equivalent solutions in languages like Python or Java.\\n- System-level factors: These include things like the load on the online judge servers at the time of submission, the system\\'s I/O processing speed, etc.\\n\\nTherefore, while it\\'s always a good idea to aim for efficient code, don\\'t be too concerned about the percentage reported by the online judge system. It\\'s more important to make sure that your solution is correct, readable, and as efficient as it can be in terms of time and space complexity."
                    },
                    {
                        "username": "jokandre",
                        "content": "# Intuition behind kadane\\'s algo\\n\\nAt index ```i``` what it the max subarray sum?\\n- Can previous sum, nums[i-1], help maximize my current nums[i] \\n\\nGiven ```nums=[-2, 1] , i=1```\\n\\nRelationship between previous sum and current number: In order to maximize it\\n\\n| prev sum | cur  | max |  why  | \\n|---|---|---|-----|\\n| +1 | +1 |  1+1 |  prev+ cur   |\\n| -1 | +1 |  1 |  cur  |\\n| +1 | -1 | 0  |  prev+cur, cur must be included always!  |\\n| -1 | -1 | -1  |  cur |\\n\\nOptions:\\n- nums[i] is **positive**, then nums[i] is part of the solution\\n\\t- ```nums[i-1] + nums[i]``` : previous + i\\n\\t- ```nums[i]``` : previous discarted, perhaps sum to 0 or negative number\\n\\t\\n- nums[i] is **negative**\\n\\t- ```nums[i-1]+nums[i]```: previous being is positive will help increasing nums[i]\\n\\t- ```nums[i]```: if both previous is also negative it should not be added \\n\\nHope it helps\\n\\n\\n\\t"
                    }
                ]
            },
            {
                "id": 1782108,
                "content": [
                    {
                        "username": "Mohan_66",
                        "content": "Just a normal problem but the way of approach for the first time is going to be touch..."
                    },
                    {
                        "username": "sthrizvi1990",
                        "content": "public int maxSubArray(int[] nums) {\\n        int cur_sum =  0;\\n        int max_sum= Integer.MIN_VALUE;\\n        if(nums.length ==1)\\n        {\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            cur_sum = cur_sum+nums[i];\\n            if(cur_sum>max_sum)\\n            {\\n                max_sum = cur_sum;\\n            }\\n\\n            if(cur_sum<0)\\n            {\\n                cur_sum = 0;\\n            }\\n        }\\n\\n        return max_sum;\\n    }"
                    },
                    {
                        "username": "srijan_soni",
                        "content": "i have solved this through Kadane\\'s algorithm ( 0(n) approach ), I wonder if any other 0(n) exist ;)"
                    },
                    {
                        "username": "jmeena660",
                        "content": "class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        vector<int>a(nums.size(),0);\\n        int n=nums.size();\\n        for(int i=1;i<n;i++){\\n            nums[i]=nums[i]+nums[n-i];\\n        }\\n        \\n        a=nums;\\n        for(int i=1;i<n;i++){\\n            a[i]=a[i]-a[n-1];\\n        }\\n        \\n            int max = a[0];\\n \\n\\n    for (int j = 1; j < n; j++)\\n        if (a[j] > max)\\n            max = a[j];\\n \\n    return max;\\n        \\n    }\\n};//im getting error is this write approach to do this problem "
                    },
                    {
                        "username": "bparanj",
                        "content": "There seem to be a few issues in the code you posted. \\n\\n1. Syntax Error: You need to declare the data type of your vector `a`. So, it should be `vector<int> a(nums.size(), 0);` instead of `vector a(nums.size(), 0);`.\\n\\n2. Invalid Indexing: The line `nums[i] = nums[i] + nums[n-i];` could result in accessing elements beyond the array when `i = 0`. Because `n-i` when `i = 0` would give `n`, and `nums[n]` is out of bounds.\\n\\n3. Incorrect Logic: The logic you are using doesn\\'t seem to follow the Kadane\\'s algorithm, which is the recommended approach for the maximum subarray problem. The operations you\\'re performing on the array don\\'t align with finding the maximum sum of a subarray. \\n\\nHere\\'s an example of a correct implementation using Kadane\\'s algorithm:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int max_sum = INT_MIN, curr_sum = 0;\\n        int n = nums.size();\\n\\n        for (int i = 0; i < n; i++) {\\n            curr_sum += nums[i];\\n            if (max_sum < curr_sum)\\n                max_sum = curr_sum;\\n            if (curr_sum < 0)\\n                curr_sum = 0;\\n        }\\n\\n        return max_sum;\\n    }\\n};\\n```\\n\\nThis implementation starts with `max_sum` set to the smallest possible integer and `curr_sum` set to 0. It iterates through the array, adding the current number to `curr_sum`. If `curr_sum` is larger than `max_sum`, `max_sum` is updated. If `curr_sum` becomes negative, it is reset to 0. At the end of the iteration, `max_sum` contains the maximum sum of a subarray in `nums`."
                    },
                    {
                        "username": "jenil252525",
                        "content": "solved\\n"
                    },
                    {
                        "username": "JyotiHariyale",
                        "content": "i found error when i used kadane algorithm"
                    },
                    {
                        "username": "saifmd538",
                        "content": "how could i solve this with divide and conquer?? if anyone know please explain it..."
                    },
                    {
                        "username": "bparanj",
                        "content": "The divide and conquer approach for the maximum subarray problem is a bit more complex than the iterative approach like Kadane\\'s algorithm. It is based on the principle of breaking down the problem into smaller subproblems, solving them, and combining their results to find the solution to the original problem. Here\\'s a step by step breakdown:\\n\\n1. Divide the given array in two halves.\\n2. Return the maximum of the following three:\\n   * Maximum subarray sum in the left half (recursive call).\\n   * Maximum subarray sum in the right half (recursive call).\\n   * Maximum subarray sum such that the subarray crosses the midpoint.\\n\\nThe third case is handled differently. We first find the maximum sum starting from the mid point and ending at some point on the left half, then find the maximum sum starting from mid + 1 and ending at some point on the right half and finally combine the two.\\n\\nHere\\'s the C++ code that implements this:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int crossSum(vector<int>& nums, int left, int right, int mid) {\\n        if (left == right) return nums[left];\\n\\n        int leftSubsum = INT_MIN;\\n        int currSum = 0;\\n        for (int i = mid; i > left - 1; --i) {\\n            currSum += nums[i];\\n            leftSubsum = max(leftSubsum, currSum);\\n        }\\n\\n        int rightSubsum = INT_MIN;\\n        currSum = 0;\\n        for (int i = mid + 1; i < right + 1; ++i) {\\n            currSum += nums[i];\\n            rightSubsum = max(rightSubsum, currSum);\\n        }\\n\\n        return leftSubsum + rightSubsum;\\n    }\\n\\n    int helper(vector<int>& nums, int left, int right) {\\n        if (left == right) return nums[left];\\n\\n        int mid = left + (right - left) / 2;\\n\\n        int leftSum = helper(nums, left, mid);\\n        int rightSum = helper(nums, mid + 1, right);\\n        int crossSum = this->crossSum(nums, left, right, mid);\\n\\n        return max(max(leftSum, rightSum), crossSum);\\n    }\\n\\n    int maxSubArray(vector<int>& nums) {\\n        return helper(nums, 0, nums.size() - 1);\\n    }\\n};\\n```\\nIn the code above, `crossSum` calculates the maximum subarray sum that crosses the midpoint, `helper` performs the recursive division of the array and calculates the maximum subarray sums, and `maxSubArray` is the main function that calls `helper` to start the recursion. The result of `maxSubArray` is the maximum subarray sum in the input array `nums`."
                    },
                    {
                        "username": "java_run",
                        "content": "For the test case {-1,-2} or any test cases containing all negative numbers , why is the expected ans not zero (coz we can always choose an empty sub array) , but the expected ans is -1 in case of (-1,-2) \n\nI tried the Kadane's approach before , but I was getting an error ,  "
                    },
                    {
                        "username": "6vedant",
                        "content": "Why my solution is beating only 41% of answers? Any help please to improve my working code.\\n\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int maxSoFar = Integer.MIN_VALUE;\\n        int maxTillYet = 0;\\n\\n        for(int i=0; i<nums.length; i++) {\\n            maxTillYet += nums[i];\\n            if (maxSoFar < maxTillYet) {\\n                maxSoFar = maxTillYet;\\n            }\\n            if (maxTillYet < 0) {\\n                maxTillYet = 0;\\n            }\\n        }\\n        return maxSoFar;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is using Kadane\\'s algorithm, which is the most optimal solution for the maximum subarray problem. It already runs in O(n) time complexity and uses O(1) space complexity, meaning you can\\'t really optimize it further from a time or space complexity standpoint.\\n\\nThe percentage you see on online judge platforms like LeetCode (41% in your case) is not entirely dependent on the efficiency of your algorithm. The speed of your solution can also be affected by factors that aren\\'t really related to the algorithm\\'s efficiency, like:\\n\\n- The programming language you use: Some languages are inherently faster than others. Solutions in languages like C or C++ often run faster than equivalent solutions in languages like Python or Java.\\n- System-level factors: These include things like the load on the online judge servers at the time of submission, the system\\'s I/O processing speed, etc.\\n\\nTherefore, while it\\'s always a good idea to aim for efficient code, don\\'t be too concerned about the percentage reported by the online judge system. It\\'s more important to make sure that your solution is correct, readable, and as efficient as it can be in terms of time and space complexity."
                    },
                    {
                        "username": "jokandre",
                        "content": "# Intuition behind kadane\\'s algo\\n\\nAt index ```i``` what it the max subarray sum?\\n- Can previous sum, nums[i-1], help maximize my current nums[i] \\n\\nGiven ```nums=[-2, 1] , i=1```\\n\\nRelationship between previous sum and current number: In order to maximize it\\n\\n| prev sum | cur  | max |  why  | \\n|---|---|---|-----|\\n| +1 | +1 |  1+1 |  prev+ cur   |\\n| -1 | +1 |  1 |  cur  |\\n| +1 | -1 | 0  |  prev+cur, cur must be included always!  |\\n| -1 | -1 | -1  |  cur |\\n\\nOptions:\\n- nums[i] is **positive**, then nums[i] is part of the solution\\n\\t- ```nums[i-1] + nums[i]``` : previous + i\\n\\t- ```nums[i]``` : previous discarted, perhaps sum to 0 or negative number\\n\\t\\n- nums[i] is **negative**\\n\\t- ```nums[i-1]+nums[i]```: previous being is positive will help increasing nums[i]\\n\\t- ```nums[i]```: if both previous is also negative it should not be added \\n\\nHope it helps\\n\\n\\n\\t"
                    }
                ]
            },
            {
                "id": 1777596,
                "content": [
                    {
                        "username": "Mohan_66",
                        "content": "Just a normal problem but the way of approach for the first time is going to be touch..."
                    },
                    {
                        "username": "sthrizvi1990",
                        "content": "public int maxSubArray(int[] nums) {\\n        int cur_sum =  0;\\n        int max_sum= Integer.MIN_VALUE;\\n        if(nums.length ==1)\\n        {\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            cur_sum = cur_sum+nums[i];\\n            if(cur_sum>max_sum)\\n            {\\n                max_sum = cur_sum;\\n            }\\n\\n            if(cur_sum<0)\\n            {\\n                cur_sum = 0;\\n            }\\n        }\\n\\n        return max_sum;\\n    }"
                    },
                    {
                        "username": "srijan_soni",
                        "content": "i have solved this through Kadane\\'s algorithm ( 0(n) approach ), I wonder if any other 0(n) exist ;)"
                    },
                    {
                        "username": "jmeena660",
                        "content": "class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        vector<int>a(nums.size(),0);\\n        int n=nums.size();\\n        for(int i=1;i<n;i++){\\n            nums[i]=nums[i]+nums[n-i];\\n        }\\n        \\n        a=nums;\\n        for(int i=1;i<n;i++){\\n            a[i]=a[i]-a[n-1];\\n        }\\n        \\n            int max = a[0];\\n \\n\\n    for (int j = 1; j < n; j++)\\n        if (a[j] > max)\\n            max = a[j];\\n \\n    return max;\\n        \\n    }\\n};//im getting error is this write approach to do this problem "
                    },
                    {
                        "username": "bparanj",
                        "content": "There seem to be a few issues in the code you posted. \\n\\n1. Syntax Error: You need to declare the data type of your vector `a`. So, it should be `vector<int> a(nums.size(), 0);` instead of `vector a(nums.size(), 0);`.\\n\\n2. Invalid Indexing: The line `nums[i] = nums[i] + nums[n-i];` could result in accessing elements beyond the array when `i = 0`. Because `n-i` when `i = 0` would give `n`, and `nums[n]` is out of bounds.\\n\\n3. Incorrect Logic: The logic you are using doesn\\'t seem to follow the Kadane\\'s algorithm, which is the recommended approach for the maximum subarray problem. The operations you\\'re performing on the array don\\'t align with finding the maximum sum of a subarray. \\n\\nHere\\'s an example of a correct implementation using Kadane\\'s algorithm:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int max_sum = INT_MIN, curr_sum = 0;\\n        int n = nums.size();\\n\\n        for (int i = 0; i < n; i++) {\\n            curr_sum += nums[i];\\n            if (max_sum < curr_sum)\\n                max_sum = curr_sum;\\n            if (curr_sum < 0)\\n                curr_sum = 0;\\n        }\\n\\n        return max_sum;\\n    }\\n};\\n```\\n\\nThis implementation starts with `max_sum` set to the smallest possible integer and `curr_sum` set to 0. It iterates through the array, adding the current number to `curr_sum`. If `curr_sum` is larger than `max_sum`, `max_sum` is updated. If `curr_sum` becomes negative, it is reset to 0. At the end of the iteration, `max_sum` contains the maximum sum of a subarray in `nums`."
                    },
                    {
                        "username": "jenil252525",
                        "content": "solved\\n"
                    },
                    {
                        "username": "JyotiHariyale",
                        "content": "i found error when i used kadane algorithm"
                    },
                    {
                        "username": "saifmd538",
                        "content": "how could i solve this with divide and conquer?? if anyone know please explain it..."
                    },
                    {
                        "username": "bparanj",
                        "content": "The divide and conquer approach for the maximum subarray problem is a bit more complex than the iterative approach like Kadane\\'s algorithm. It is based on the principle of breaking down the problem into smaller subproblems, solving them, and combining their results to find the solution to the original problem. Here\\'s a step by step breakdown:\\n\\n1. Divide the given array in two halves.\\n2. Return the maximum of the following three:\\n   * Maximum subarray sum in the left half (recursive call).\\n   * Maximum subarray sum in the right half (recursive call).\\n   * Maximum subarray sum such that the subarray crosses the midpoint.\\n\\nThe third case is handled differently. We first find the maximum sum starting from the mid point and ending at some point on the left half, then find the maximum sum starting from mid + 1 and ending at some point on the right half and finally combine the two.\\n\\nHere\\'s the C++ code that implements this:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int crossSum(vector<int>& nums, int left, int right, int mid) {\\n        if (left == right) return nums[left];\\n\\n        int leftSubsum = INT_MIN;\\n        int currSum = 0;\\n        for (int i = mid; i > left - 1; --i) {\\n            currSum += nums[i];\\n            leftSubsum = max(leftSubsum, currSum);\\n        }\\n\\n        int rightSubsum = INT_MIN;\\n        currSum = 0;\\n        for (int i = mid + 1; i < right + 1; ++i) {\\n            currSum += nums[i];\\n            rightSubsum = max(rightSubsum, currSum);\\n        }\\n\\n        return leftSubsum + rightSubsum;\\n    }\\n\\n    int helper(vector<int>& nums, int left, int right) {\\n        if (left == right) return nums[left];\\n\\n        int mid = left + (right - left) / 2;\\n\\n        int leftSum = helper(nums, left, mid);\\n        int rightSum = helper(nums, mid + 1, right);\\n        int crossSum = this->crossSum(nums, left, right, mid);\\n\\n        return max(max(leftSum, rightSum), crossSum);\\n    }\\n\\n    int maxSubArray(vector<int>& nums) {\\n        return helper(nums, 0, nums.size() - 1);\\n    }\\n};\\n```\\nIn the code above, `crossSum` calculates the maximum subarray sum that crosses the midpoint, `helper` performs the recursive division of the array and calculates the maximum subarray sums, and `maxSubArray` is the main function that calls `helper` to start the recursion. The result of `maxSubArray` is the maximum subarray sum in the input array `nums`."
                    },
                    {
                        "username": "java_run",
                        "content": "For the test case {-1,-2} or any test cases containing all negative numbers , why is the expected ans not zero (coz we can always choose an empty sub array) , but the expected ans is -1 in case of (-1,-2) \n\nI tried the Kadane's approach before , but I was getting an error ,  "
                    },
                    {
                        "username": "6vedant",
                        "content": "Why my solution is beating only 41% of answers? Any help please to improve my working code.\\n\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int maxSoFar = Integer.MIN_VALUE;\\n        int maxTillYet = 0;\\n\\n        for(int i=0; i<nums.length; i++) {\\n            maxTillYet += nums[i];\\n            if (maxSoFar < maxTillYet) {\\n                maxSoFar = maxTillYet;\\n            }\\n            if (maxTillYet < 0) {\\n                maxTillYet = 0;\\n            }\\n        }\\n        return maxSoFar;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is using Kadane\\'s algorithm, which is the most optimal solution for the maximum subarray problem. It already runs in O(n) time complexity and uses O(1) space complexity, meaning you can\\'t really optimize it further from a time or space complexity standpoint.\\n\\nThe percentage you see on online judge platforms like LeetCode (41% in your case) is not entirely dependent on the efficiency of your algorithm. The speed of your solution can also be affected by factors that aren\\'t really related to the algorithm\\'s efficiency, like:\\n\\n- The programming language you use: Some languages are inherently faster than others. Solutions in languages like C or C++ often run faster than equivalent solutions in languages like Python or Java.\\n- System-level factors: These include things like the load on the online judge servers at the time of submission, the system\\'s I/O processing speed, etc.\\n\\nTherefore, while it\\'s always a good idea to aim for efficient code, don\\'t be too concerned about the percentage reported by the online judge system. It\\'s more important to make sure that your solution is correct, readable, and as efficient as it can be in terms of time and space complexity."
                    },
                    {
                        "username": "jokandre",
                        "content": "# Intuition behind kadane\\'s algo\\n\\nAt index ```i``` what it the max subarray sum?\\n- Can previous sum, nums[i-1], help maximize my current nums[i] \\n\\nGiven ```nums=[-2, 1] , i=1```\\n\\nRelationship between previous sum and current number: In order to maximize it\\n\\n| prev sum | cur  | max |  why  | \\n|---|---|---|-----|\\n| +1 | +1 |  1+1 |  prev+ cur   |\\n| -1 | +1 |  1 |  cur  |\\n| +1 | -1 | 0  |  prev+cur, cur must be included always!  |\\n| -1 | -1 | -1  |  cur |\\n\\nOptions:\\n- nums[i] is **positive**, then nums[i] is part of the solution\\n\\t- ```nums[i-1] + nums[i]``` : previous + i\\n\\t- ```nums[i]``` : previous discarted, perhaps sum to 0 or negative number\\n\\t\\n- nums[i] is **negative**\\n\\t- ```nums[i-1]+nums[i]```: previous being is positive will help increasing nums[i]\\n\\t- ```nums[i]```: if both previous is also negative it should not be added \\n\\nHope it helps\\n\\n\\n\\t"
                    }
                ]
            },
            {
                "id": 1776296,
                "content": [
                    {
                        "username": "Mohan_66",
                        "content": "Just a normal problem but the way of approach for the first time is going to be touch..."
                    },
                    {
                        "username": "sthrizvi1990",
                        "content": "public int maxSubArray(int[] nums) {\\n        int cur_sum =  0;\\n        int max_sum= Integer.MIN_VALUE;\\n        if(nums.length ==1)\\n        {\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            cur_sum = cur_sum+nums[i];\\n            if(cur_sum>max_sum)\\n            {\\n                max_sum = cur_sum;\\n            }\\n\\n            if(cur_sum<0)\\n            {\\n                cur_sum = 0;\\n            }\\n        }\\n\\n        return max_sum;\\n    }"
                    },
                    {
                        "username": "srijan_soni",
                        "content": "i have solved this through Kadane\\'s algorithm ( 0(n) approach ), I wonder if any other 0(n) exist ;)"
                    },
                    {
                        "username": "jmeena660",
                        "content": "class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        vector<int>a(nums.size(),0);\\n        int n=nums.size();\\n        for(int i=1;i<n;i++){\\n            nums[i]=nums[i]+nums[n-i];\\n        }\\n        \\n        a=nums;\\n        for(int i=1;i<n;i++){\\n            a[i]=a[i]-a[n-1];\\n        }\\n        \\n            int max = a[0];\\n \\n\\n    for (int j = 1; j < n; j++)\\n        if (a[j] > max)\\n            max = a[j];\\n \\n    return max;\\n        \\n    }\\n};//im getting error is this write approach to do this problem "
                    },
                    {
                        "username": "bparanj",
                        "content": "There seem to be a few issues in the code you posted. \\n\\n1. Syntax Error: You need to declare the data type of your vector `a`. So, it should be `vector<int> a(nums.size(), 0);` instead of `vector a(nums.size(), 0);`.\\n\\n2. Invalid Indexing: The line `nums[i] = nums[i] + nums[n-i];` could result in accessing elements beyond the array when `i = 0`. Because `n-i` when `i = 0` would give `n`, and `nums[n]` is out of bounds.\\n\\n3. Incorrect Logic: The logic you are using doesn\\'t seem to follow the Kadane\\'s algorithm, which is the recommended approach for the maximum subarray problem. The operations you\\'re performing on the array don\\'t align with finding the maximum sum of a subarray. \\n\\nHere\\'s an example of a correct implementation using Kadane\\'s algorithm:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int max_sum = INT_MIN, curr_sum = 0;\\n        int n = nums.size();\\n\\n        for (int i = 0; i < n; i++) {\\n            curr_sum += nums[i];\\n            if (max_sum < curr_sum)\\n                max_sum = curr_sum;\\n            if (curr_sum < 0)\\n                curr_sum = 0;\\n        }\\n\\n        return max_sum;\\n    }\\n};\\n```\\n\\nThis implementation starts with `max_sum` set to the smallest possible integer and `curr_sum` set to 0. It iterates through the array, adding the current number to `curr_sum`. If `curr_sum` is larger than `max_sum`, `max_sum` is updated. If `curr_sum` becomes negative, it is reset to 0. At the end of the iteration, `max_sum` contains the maximum sum of a subarray in `nums`."
                    },
                    {
                        "username": "jenil252525",
                        "content": "solved\\n"
                    },
                    {
                        "username": "JyotiHariyale",
                        "content": "i found error when i used kadane algorithm"
                    },
                    {
                        "username": "saifmd538",
                        "content": "how could i solve this with divide and conquer?? if anyone know please explain it..."
                    },
                    {
                        "username": "bparanj",
                        "content": "The divide and conquer approach for the maximum subarray problem is a bit more complex than the iterative approach like Kadane\\'s algorithm. It is based on the principle of breaking down the problem into smaller subproblems, solving them, and combining their results to find the solution to the original problem. Here\\'s a step by step breakdown:\\n\\n1. Divide the given array in two halves.\\n2. Return the maximum of the following three:\\n   * Maximum subarray sum in the left half (recursive call).\\n   * Maximum subarray sum in the right half (recursive call).\\n   * Maximum subarray sum such that the subarray crosses the midpoint.\\n\\nThe third case is handled differently. We first find the maximum sum starting from the mid point and ending at some point on the left half, then find the maximum sum starting from mid + 1 and ending at some point on the right half and finally combine the two.\\n\\nHere\\'s the C++ code that implements this:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int crossSum(vector<int>& nums, int left, int right, int mid) {\\n        if (left == right) return nums[left];\\n\\n        int leftSubsum = INT_MIN;\\n        int currSum = 0;\\n        for (int i = mid; i > left - 1; --i) {\\n            currSum += nums[i];\\n            leftSubsum = max(leftSubsum, currSum);\\n        }\\n\\n        int rightSubsum = INT_MIN;\\n        currSum = 0;\\n        for (int i = mid + 1; i < right + 1; ++i) {\\n            currSum += nums[i];\\n            rightSubsum = max(rightSubsum, currSum);\\n        }\\n\\n        return leftSubsum + rightSubsum;\\n    }\\n\\n    int helper(vector<int>& nums, int left, int right) {\\n        if (left == right) return nums[left];\\n\\n        int mid = left + (right - left) / 2;\\n\\n        int leftSum = helper(nums, left, mid);\\n        int rightSum = helper(nums, mid + 1, right);\\n        int crossSum = this->crossSum(nums, left, right, mid);\\n\\n        return max(max(leftSum, rightSum), crossSum);\\n    }\\n\\n    int maxSubArray(vector<int>& nums) {\\n        return helper(nums, 0, nums.size() - 1);\\n    }\\n};\\n```\\nIn the code above, `crossSum` calculates the maximum subarray sum that crosses the midpoint, `helper` performs the recursive division of the array and calculates the maximum subarray sums, and `maxSubArray` is the main function that calls `helper` to start the recursion. The result of `maxSubArray` is the maximum subarray sum in the input array `nums`."
                    },
                    {
                        "username": "java_run",
                        "content": "For the test case {-1,-2} or any test cases containing all negative numbers , why is the expected ans not zero (coz we can always choose an empty sub array) , but the expected ans is -1 in case of (-1,-2) \n\nI tried the Kadane's approach before , but I was getting an error ,  "
                    },
                    {
                        "username": "6vedant",
                        "content": "Why my solution is beating only 41% of answers? Any help please to improve my working code.\\n\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int maxSoFar = Integer.MIN_VALUE;\\n        int maxTillYet = 0;\\n\\n        for(int i=0; i<nums.length; i++) {\\n            maxTillYet += nums[i];\\n            if (maxSoFar < maxTillYet) {\\n                maxSoFar = maxTillYet;\\n            }\\n            if (maxTillYet < 0) {\\n                maxTillYet = 0;\\n            }\\n        }\\n        return maxSoFar;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is using Kadane\\'s algorithm, which is the most optimal solution for the maximum subarray problem. It already runs in O(n) time complexity and uses O(1) space complexity, meaning you can\\'t really optimize it further from a time or space complexity standpoint.\\n\\nThe percentage you see on online judge platforms like LeetCode (41% in your case) is not entirely dependent on the efficiency of your algorithm. The speed of your solution can also be affected by factors that aren\\'t really related to the algorithm\\'s efficiency, like:\\n\\n- The programming language you use: Some languages are inherently faster than others. Solutions in languages like C or C++ often run faster than equivalent solutions in languages like Python or Java.\\n- System-level factors: These include things like the load on the online judge servers at the time of submission, the system\\'s I/O processing speed, etc.\\n\\nTherefore, while it\\'s always a good idea to aim for efficient code, don\\'t be too concerned about the percentage reported by the online judge system. It\\'s more important to make sure that your solution is correct, readable, and as efficient as it can be in terms of time and space complexity."
                    },
                    {
                        "username": "jokandre",
                        "content": "# Intuition behind kadane\\'s algo\\n\\nAt index ```i``` what it the max subarray sum?\\n- Can previous sum, nums[i-1], help maximize my current nums[i] \\n\\nGiven ```nums=[-2, 1] , i=1```\\n\\nRelationship between previous sum and current number: In order to maximize it\\n\\n| prev sum | cur  | max |  why  | \\n|---|---|---|-----|\\n| +1 | +1 |  1+1 |  prev+ cur   |\\n| -1 | +1 |  1 |  cur  |\\n| +1 | -1 | 0  |  prev+cur, cur must be included always!  |\\n| -1 | -1 | -1  |  cur |\\n\\nOptions:\\n- nums[i] is **positive**, then nums[i] is part of the solution\\n\\t- ```nums[i-1] + nums[i]``` : previous + i\\n\\t- ```nums[i]``` : previous discarted, perhaps sum to 0 or negative number\\n\\t\\n- nums[i] is **negative**\\n\\t- ```nums[i-1]+nums[i]```: previous being is positive will help increasing nums[i]\\n\\t- ```nums[i]```: if both previous is also negative it should not be added \\n\\nHope it helps\\n\\n\\n\\t"
                    }
                ]
            },
            {
                "id": 1774898,
                "content": [
                    {
                        "username": "Mohan_66",
                        "content": "Just a normal problem but the way of approach for the first time is going to be touch..."
                    },
                    {
                        "username": "sthrizvi1990",
                        "content": "public int maxSubArray(int[] nums) {\\n        int cur_sum =  0;\\n        int max_sum= Integer.MIN_VALUE;\\n        if(nums.length ==1)\\n        {\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            cur_sum = cur_sum+nums[i];\\n            if(cur_sum>max_sum)\\n            {\\n                max_sum = cur_sum;\\n            }\\n\\n            if(cur_sum<0)\\n            {\\n                cur_sum = 0;\\n            }\\n        }\\n\\n        return max_sum;\\n    }"
                    },
                    {
                        "username": "srijan_soni",
                        "content": "i have solved this through Kadane\\'s algorithm ( 0(n) approach ), I wonder if any other 0(n) exist ;)"
                    },
                    {
                        "username": "jmeena660",
                        "content": "class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        vector<int>a(nums.size(),0);\\n        int n=nums.size();\\n        for(int i=1;i<n;i++){\\n            nums[i]=nums[i]+nums[n-i];\\n        }\\n        \\n        a=nums;\\n        for(int i=1;i<n;i++){\\n            a[i]=a[i]-a[n-1];\\n        }\\n        \\n            int max = a[0];\\n \\n\\n    for (int j = 1; j < n; j++)\\n        if (a[j] > max)\\n            max = a[j];\\n \\n    return max;\\n        \\n    }\\n};//im getting error is this write approach to do this problem "
                    },
                    {
                        "username": "bparanj",
                        "content": "There seem to be a few issues in the code you posted. \\n\\n1. Syntax Error: You need to declare the data type of your vector `a`. So, it should be `vector<int> a(nums.size(), 0);` instead of `vector a(nums.size(), 0);`.\\n\\n2. Invalid Indexing: The line `nums[i] = nums[i] + nums[n-i];` could result in accessing elements beyond the array when `i = 0`. Because `n-i` when `i = 0` would give `n`, and `nums[n]` is out of bounds.\\n\\n3. Incorrect Logic: The logic you are using doesn\\'t seem to follow the Kadane\\'s algorithm, which is the recommended approach for the maximum subarray problem. The operations you\\'re performing on the array don\\'t align with finding the maximum sum of a subarray. \\n\\nHere\\'s an example of a correct implementation using Kadane\\'s algorithm:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int max_sum = INT_MIN, curr_sum = 0;\\n        int n = nums.size();\\n\\n        for (int i = 0; i < n; i++) {\\n            curr_sum += nums[i];\\n            if (max_sum < curr_sum)\\n                max_sum = curr_sum;\\n            if (curr_sum < 0)\\n                curr_sum = 0;\\n        }\\n\\n        return max_sum;\\n    }\\n};\\n```\\n\\nThis implementation starts with `max_sum` set to the smallest possible integer and `curr_sum` set to 0. It iterates through the array, adding the current number to `curr_sum`. If `curr_sum` is larger than `max_sum`, `max_sum` is updated. If `curr_sum` becomes negative, it is reset to 0. At the end of the iteration, `max_sum` contains the maximum sum of a subarray in `nums`."
                    },
                    {
                        "username": "jenil252525",
                        "content": "solved\\n"
                    },
                    {
                        "username": "JyotiHariyale",
                        "content": "i found error when i used kadane algorithm"
                    },
                    {
                        "username": "saifmd538",
                        "content": "how could i solve this with divide and conquer?? if anyone know please explain it..."
                    },
                    {
                        "username": "bparanj",
                        "content": "The divide and conquer approach for the maximum subarray problem is a bit more complex than the iterative approach like Kadane\\'s algorithm. It is based on the principle of breaking down the problem into smaller subproblems, solving them, and combining their results to find the solution to the original problem. Here\\'s a step by step breakdown:\\n\\n1. Divide the given array in two halves.\\n2. Return the maximum of the following three:\\n   * Maximum subarray sum in the left half (recursive call).\\n   * Maximum subarray sum in the right half (recursive call).\\n   * Maximum subarray sum such that the subarray crosses the midpoint.\\n\\nThe third case is handled differently. We first find the maximum sum starting from the mid point and ending at some point on the left half, then find the maximum sum starting from mid + 1 and ending at some point on the right half and finally combine the two.\\n\\nHere\\'s the C++ code that implements this:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int crossSum(vector<int>& nums, int left, int right, int mid) {\\n        if (left == right) return nums[left];\\n\\n        int leftSubsum = INT_MIN;\\n        int currSum = 0;\\n        for (int i = mid; i > left - 1; --i) {\\n            currSum += nums[i];\\n            leftSubsum = max(leftSubsum, currSum);\\n        }\\n\\n        int rightSubsum = INT_MIN;\\n        currSum = 0;\\n        for (int i = mid + 1; i < right + 1; ++i) {\\n            currSum += nums[i];\\n            rightSubsum = max(rightSubsum, currSum);\\n        }\\n\\n        return leftSubsum + rightSubsum;\\n    }\\n\\n    int helper(vector<int>& nums, int left, int right) {\\n        if (left == right) return nums[left];\\n\\n        int mid = left + (right - left) / 2;\\n\\n        int leftSum = helper(nums, left, mid);\\n        int rightSum = helper(nums, mid + 1, right);\\n        int crossSum = this->crossSum(nums, left, right, mid);\\n\\n        return max(max(leftSum, rightSum), crossSum);\\n    }\\n\\n    int maxSubArray(vector<int>& nums) {\\n        return helper(nums, 0, nums.size() - 1);\\n    }\\n};\\n```\\nIn the code above, `crossSum` calculates the maximum subarray sum that crosses the midpoint, `helper` performs the recursive division of the array and calculates the maximum subarray sums, and `maxSubArray` is the main function that calls `helper` to start the recursion. The result of `maxSubArray` is the maximum subarray sum in the input array `nums`."
                    },
                    {
                        "username": "java_run",
                        "content": "For the test case {-1,-2} or any test cases containing all negative numbers , why is the expected ans not zero (coz we can always choose an empty sub array) , but the expected ans is -1 in case of (-1,-2) \n\nI tried the Kadane's approach before , but I was getting an error ,  "
                    },
                    {
                        "username": "6vedant",
                        "content": "Why my solution is beating only 41% of answers? Any help please to improve my working code.\\n\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int maxSoFar = Integer.MIN_VALUE;\\n        int maxTillYet = 0;\\n\\n        for(int i=0; i<nums.length; i++) {\\n            maxTillYet += nums[i];\\n            if (maxSoFar < maxTillYet) {\\n                maxSoFar = maxTillYet;\\n            }\\n            if (maxTillYet < 0) {\\n                maxTillYet = 0;\\n            }\\n        }\\n        return maxSoFar;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is using Kadane\\'s algorithm, which is the most optimal solution for the maximum subarray problem. It already runs in O(n) time complexity and uses O(1) space complexity, meaning you can\\'t really optimize it further from a time or space complexity standpoint.\\n\\nThe percentage you see on online judge platforms like LeetCode (41% in your case) is not entirely dependent on the efficiency of your algorithm. The speed of your solution can also be affected by factors that aren\\'t really related to the algorithm\\'s efficiency, like:\\n\\n- The programming language you use: Some languages are inherently faster than others. Solutions in languages like C or C++ often run faster than equivalent solutions in languages like Python or Java.\\n- System-level factors: These include things like the load on the online judge servers at the time of submission, the system\\'s I/O processing speed, etc.\\n\\nTherefore, while it\\'s always a good idea to aim for efficient code, don\\'t be too concerned about the percentage reported by the online judge system. It\\'s more important to make sure that your solution is correct, readable, and as efficient as it can be in terms of time and space complexity."
                    },
                    {
                        "username": "jokandre",
                        "content": "# Intuition behind kadane\\'s algo\\n\\nAt index ```i``` what it the max subarray sum?\\n- Can previous sum, nums[i-1], help maximize my current nums[i] \\n\\nGiven ```nums=[-2, 1] , i=1```\\n\\nRelationship between previous sum and current number: In order to maximize it\\n\\n| prev sum | cur  | max |  why  | \\n|---|---|---|-----|\\n| +1 | +1 |  1+1 |  prev+ cur   |\\n| -1 | +1 |  1 |  cur  |\\n| +1 | -1 | 0  |  prev+cur, cur must be included always!  |\\n| -1 | -1 | -1  |  cur |\\n\\nOptions:\\n- nums[i] is **positive**, then nums[i] is part of the solution\\n\\t- ```nums[i-1] + nums[i]``` : previous + i\\n\\t- ```nums[i]``` : previous discarted, perhaps sum to 0 or negative number\\n\\t\\n- nums[i] is **negative**\\n\\t- ```nums[i-1]+nums[i]```: previous being is positive will help increasing nums[i]\\n\\t- ```nums[i]```: if both previous is also negative it should not be added \\n\\nHope it helps\\n\\n\\n\\t"
                    }
                ]
            },
            {
                "id": 1769442,
                "content": [
                    {
                        "username": "Mohan_66",
                        "content": "Just a normal problem but the way of approach for the first time is going to be touch..."
                    },
                    {
                        "username": "sthrizvi1990",
                        "content": "public int maxSubArray(int[] nums) {\\n        int cur_sum =  0;\\n        int max_sum= Integer.MIN_VALUE;\\n        if(nums.length ==1)\\n        {\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            cur_sum = cur_sum+nums[i];\\n            if(cur_sum>max_sum)\\n            {\\n                max_sum = cur_sum;\\n            }\\n\\n            if(cur_sum<0)\\n            {\\n                cur_sum = 0;\\n            }\\n        }\\n\\n        return max_sum;\\n    }"
                    },
                    {
                        "username": "srijan_soni",
                        "content": "i have solved this through Kadane\\'s algorithm ( 0(n) approach ), I wonder if any other 0(n) exist ;)"
                    },
                    {
                        "username": "jmeena660",
                        "content": "class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        vector<int>a(nums.size(),0);\\n        int n=nums.size();\\n        for(int i=1;i<n;i++){\\n            nums[i]=nums[i]+nums[n-i];\\n        }\\n        \\n        a=nums;\\n        for(int i=1;i<n;i++){\\n            a[i]=a[i]-a[n-1];\\n        }\\n        \\n            int max = a[0];\\n \\n\\n    for (int j = 1; j < n; j++)\\n        if (a[j] > max)\\n            max = a[j];\\n \\n    return max;\\n        \\n    }\\n};//im getting error is this write approach to do this problem "
                    },
                    {
                        "username": "bparanj",
                        "content": "There seem to be a few issues in the code you posted. \\n\\n1. Syntax Error: You need to declare the data type of your vector `a`. So, it should be `vector<int> a(nums.size(), 0);` instead of `vector a(nums.size(), 0);`.\\n\\n2. Invalid Indexing: The line `nums[i] = nums[i] + nums[n-i];` could result in accessing elements beyond the array when `i = 0`. Because `n-i` when `i = 0` would give `n`, and `nums[n]` is out of bounds.\\n\\n3. Incorrect Logic: The logic you are using doesn\\'t seem to follow the Kadane\\'s algorithm, which is the recommended approach for the maximum subarray problem. The operations you\\'re performing on the array don\\'t align with finding the maximum sum of a subarray. \\n\\nHere\\'s an example of a correct implementation using Kadane\\'s algorithm:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int max_sum = INT_MIN, curr_sum = 0;\\n        int n = nums.size();\\n\\n        for (int i = 0; i < n; i++) {\\n            curr_sum += nums[i];\\n            if (max_sum < curr_sum)\\n                max_sum = curr_sum;\\n            if (curr_sum < 0)\\n                curr_sum = 0;\\n        }\\n\\n        return max_sum;\\n    }\\n};\\n```\\n\\nThis implementation starts with `max_sum` set to the smallest possible integer and `curr_sum` set to 0. It iterates through the array, adding the current number to `curr_sum`. If `curr_sum` is larger than `max_sum`, `max_sum` is updated. If `curr_sum` becomes negative, it is reset to 0. At the end of the iteration, `max_sum` contains the maximum sum of a subarray in `nums`."
                    },
                    {
                        "username": "jenil252525",
                        "content": "solved\\n"
                    },
                    {
                        "username": "JyotiHariyale",
                        "content": "i found error when i used kadane algorithm"
                    },
                    {
                        "username": "saifmd538",
                        "content": "how could i solve this with divide and conquer?? if anyone know please explain it..."
                    },
                    {
                        "username": "bparanj",
                        "content": "The divide and conquer approach for the maximum subarray problem is a bit more complex than the iterative approach like Kadane\\'s algorithm. It is based on the principle of breaking down the problem into smaller subproblems, solving them, and combining their results to find the solution to the original problem. Here\\'s a step by step breakdown:\\n\\n1. Divide the given array in two halves.\\n2. Return the maximum of the following three:\\n   * Maximum subarray sum in the left half (recursive call).\\n   * Maximum subarray sum in the right half (recursive call).\\n   * Maximum subarray sum such that the subarray crosses the midpoint.\\n\\nThe third case is handled differently. We first find the maximum sum starting from the mid point and ending at some point on the left half, then find the maximum sum starting from mid + 1 and ending at some point on the right half and finally combine the two.\\n\\nHere\\'s the C++ code that implements this:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int crossSum(vector<int>& nums, int left, int right, int mid) {\\n        if (left == right) return nums[left];\\n\\n        int leftSubsum = INT_MIN;\\n        int currSum = 0;\\n        for (int i = mid; i > left - 1; --i) {\\n            currSum += nums[i];\\n            leftSubsum = max(leftSubsum, currSum);\\n        }\\n\\n        int rightSubsum = INT_MIN;\\n        currSum = 0;\\n        for (int i = mid + 1; i < right + 1; ++i) {\\n            currSum += nums[i];\\n            rightSubsum = max(rightSubsum, currSum);\\n        }\\n\\n        return leftSubsum + rightSubsum;\\n    }\\n\\n    int helper(vector<int>& nums, int left, int right) {\\n        if (left == right) return nums[left];\\n\\n        int mid = left + (right - left) / 2;\\n\\n        int leftSum = helper(nums, left, mid);\\n        int rightSum = helper(nums, mid + 1, right);\\n        int crossSum = this->crossSum(nums, left, right, mid);\\n\\n        return max(max(leftSum, rightSum), crossSum);\\n    }\\n\\n    int maxSubArray(vector<int>& nums) {\\n        return helper(nums, 0, nums.size() - 1);\\n    }\\n};\\n```\\nIn the code above, `crossSum` calculates the maximum subarray sum that crosses the midpoint, `helper` performs the recursive division of the array and calculates the maximum subarray sums, and `maxSubArray` is the main function that calls `helper` to start the recursion. The result of `maxSubArray` is the maximum subarray sum in the input array `nums`."
                    },
                    {
                        "username": "java_run",
                        "content": "For the test case {-1,-2} or any test cases containing all negative numbers , why is the expected ans not zero (coz we can always choose an empty sub array) , but the expected ans is -1 in case of (-1,-2) \n\nI tried the Kadane's approach before , but I was getting an error ,  "
                    },
                    {
                        "username": "6vedant",
                        "content": "Why my solution is beating only 41% of answers? Any help please to improve my working code.\\n\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int maxSoFar = Integer.MIN_VALUE;\\n        int maxTillYet = 0;\\n\\n        for(int i=0; i<nums.length; i++) {\\n            maxTillYet += nums[i];\\n            if (maxSoFar < maxTillYet) {\\n                maxSoFar = maxTillYet;\\n            }\\n            if (maxTillYet < 0) {\\n                maxTillYet = 0;\\n            }\\n        }\\n        return maxSoFar;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is using Kadane\\'s algorithm, which is the most optimal solution for the maximum subarray problem. It already runs in O(n) time complexity and uses O(1) space complexity, meaning you can\\'t really optimize it further from a time or space complexity standpoint.\\n\\nThe percentage you see on online judge platforms like LeetCode (41% in your case) is not entirely dependent on the efficiency of your algorithm. The speed of your solution can also be affected by factors that aren\\'t really related to the algorithm\\'s efficiency, like:\\n\\n- The programming language you use: Some languages are inherently faster than others. Solutions in languages like C or C++ often run faster than equivalent solutions in languages like Python or Java.\\n- System-level factors: These include things like the load on the online judge servers at the time of submission, the system\\'s I/O processing speed, etc.\\n\\nTherefore, while it\\'s always a good idea to aim for efficient code, don\\'t be too concerned about the percentage reported by the online judge system. It\\'s more important to make sure that your solution is correct, readable, and as efficient as it can be in terms of time and space complexity."
                    },
                    {
                        "username": "jokandre",
                        "content": "# Intuition behind kadane\\'s algo\\n\\nAt index ```i``` what it the max subarray sum?\\n- Can previous sum, nums[i-1], help maximize my current nums[i] \\n\\nGiven ```nums=[-2, 1] , i=1```\\n\\nRelationship between previous sum and current number: In order to maximize it\\n\\n| prev sum | cur  | max |  why  | \\n|---|---|---|-----|\\n| +1 | +1 |  1+1 |  prev+ cur   |\\n| -1 | +1 |  1 |  cur  |\\n| +1 | -1 | 0  |  prev+cur, cur must be included always!  |\\n| -1 | -1 | -1  |  cur |\\n\\nOptions:\\n- nums[i] is **positive**, then nums[i] is part of the solution\\n\\t- ```nums[i-1] + nums[i]``` : previous + i\\n\\t- ```nums[i]``` : previous discarted, perhaps sum to 0 or negative number\\n\\t\\n- nums[i] is **negative**\\n\\t- ```nums[i-1]+nums[i]```: previous being is positive will help increasing nums[i]\\n\\t- ```nums[i]```: if both previous is also negative it should not be added \\n\\nHope it helps\\n\\n\\n\\t"
                    }
                ]
            },
            {
                "id": 1767288,
                "content": [
                    {
                        "username": "Mohan_66",
                        "content": "Just a normal problem but the way of approach for the first time is going to be touch..."
                    },
                    {
                        "username": "sthrizvi1990",
                        "content": "public int maxSubArray(int[] nums) {\\n        int cur_sum =  0;\\n        int max_sum= Integer.MIN_VALUE;\\n        if(nums.length ==1)\\n        {\\n            return nums[0];\\n        }\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            cur_sum = cur_sum+nums[i];\\n            if(cur_sum>max_sum)\\n            {\\n                max_sum = cur_sum;\\n            }\\n\\n            if(cur_sum<0)\\n            {\\n                cur_sum = 0;\\n            }\\n        }\\n\\n        return max_sum;\\n    }"
                    },
                    {
                        "username": "srijan_soni",
                        "content": "i have solved this through Kadane\\'s algorithm ( 0(n) approach ), I wonder if any other 0(n) exist ;)"
                    },
                    {
                        "username": "jmeena660",
                        "content": "class Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        vector<int>a(nums.size(),0);\\n        int n=nums.size();\\n        for(int i=1;i<n;i++){\\n            nums[i]=nums[i]+nums[n-i];\\n        }\\n        \\n        a=nums;\\n        for(int i=1;i<n;i++){\\n            a[i]=a[i]-a[n-1];\\n        }\\n        \\n            int max = a[0];\\n \\n\\n    for (int j = 1; j < n; j++)\\n        if (a[j] > max)\\n            max = a[j];\\n \\n    return max;\\n        \\n    }\\n};//im getting error is this write approach to do this problem "
                    },
                    {
                        "username": "bparanj",
                        "content": "There seem to be a few issues in the code you posted. \\n\\n1. Syntax Error: You need to declare the data type of your vector `a`. So, it should be `vector<int> a(nums.size(), 0);` instead of `vector a(nums.size(), 0);`.\\n\\n2. Invalid Indexing: The line `nums[i] = nums[i] + nums[n-i];` could result in accessing elements beyond the array when `i = 0`. Because `n-i` when `i = 0` would give `n`, and `nums[n]` is out of bounds.\\n\\n3. Incorrect Logic: The logic you are using doesn\\'t seem to follow the Kadane\\'s algorithm, which is the recommended approach for the maximum subarray problem. The operations you\\'re performing on the array don\\'t align with finding the maximum sum of a subarray. \\n\\nHere\\'s an example of a correct implementation using Kadane\\'s algorithm:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int max_sum = INT_MIN, curr_sum = 0;\\n        int n = nums.size();\\n\\n        for (int i = 0; i < n; i++) {\\n            curr_sum += nums[i];\\n            if (max_sum < curr_sum)\\n                max_sum = curr_sum;\\n            if (curr_sum < 0)\\n                curr_sum = 0;\\n        }\\n\\n        return max_sum;\\n    }\\n};\\n```\\n\\nThis implementation starts with `max_sum` set to the smallest possible integer and `curr_sum` set to 0. It iterates through the array, adding the current number to `curr_sum`. If `curr_sum` is larger than `max_sum`, `max_sum` is updated. If `curr_sum` becomes negative, it is reset to 0. At the end of the iteration, `max_sum` contains the maximum sum of a subarray in `nums`."
                    },
                    {
                        "username": "jenil252525",
                        "content": "solved\\n"
                    },
                    {
                        "username": "JyotiHariyale",
                        "content": "i found error when i used kadane algorithm"
                    },
                    {
                        "username": "saifmd538",
                        "content": "how could i solve this with divide and conquer?? if anyone know please explain it..."
                    },
                    {
                        "username": "bparanj",
                        "content": "The divide and conquer approach for the maximum subarray problem is a bit more complex than the iterative approach like Kadane\\'s algorithm. It is based on the principle of breaking down the problem into smaller subproblems, solving them, and combining their results to find the solution to the original problem. Here\\'s a step by step breakdown:\\n\\n1. Divide the given array in two halves.\\n2. Return the maximum of the following three:\\n   * Maximum subarray sum in the left half (recursive call).\\n   * Maximum subarray sum in the right half (recursive call).\\n   * Maximum subarray sum such that the subarray crosses the midpoint.\\n\\nThe third case is handled differently. We first find the maximum sum starting from the mid point and ending at some point on the left half, then find the maximum sum starting from mid + 1 and ending at some point on the right half and finally combine the two.\\n\\nHere\\'s the C++ code that implements this:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int crossSum(vector<int>& nums, int left, int right, int mid) {\\n        if (left == right) return nums[left];\\n\\n        int leftSubsum = INT_MIN;\\n        int currSum = 0;\\n        for (int i = mid; i > left - 1; --i) {\\n            currSum += nums[i];\\n            leftSubsum = max(leftSubsum, currSum);\\n        }\\n\\n        int rightSubsum = INT_MIN;\\n        currSum = 0;\\n        for (int i = mid + 1; i < right + 1; ++i) {\\n            currSum += nums[i];\\n            rightSubsum = max(rightSubsum, currSum);\\n        }\\n\\n        return leftSubsum + rightSubsum;\\n    }\\n\\n    int helper(vector<int>& nums, int left, int right) {\\n        if (left == right) return nums[left];\\n\\n        int mid = left + (right - left) / 2;\\n\\n        int leftSum = helper(nums, left, mid);\\n        int rightSum = helper(nums, mid + 1, right);\\n        int crossSum = this->crossSum(nums, left, right, mid);\\n\\n        return max(max(leftSum, rightSum), crossSum);\\n    }\\n\\n    int maxSubArray(vector<int>& nums) {\\n        return helper(nums, 0, nums.size() - 1);\\n    }\\n};\\n```\\nIn the code above, `crossSum` calculates the maximum subarray sum that crosses the midpoint, `helper` performs the recursive division of the array and calculates the maximum subarray sums, and `maxSubArray` is the main function that calls `helper` to start the recursion. The result of `maxSubArray` is the maximum subarray sum in the input array `nums`."
                    },
                    {
                        "username": "java_run",
                        "content": "For the test case {-1,-2} or any test cases containing all negative numbers , why is the expected ans not zero (coz we can always choose an empty sub array) , but the expected ans is -1 in case of (-1,-2) \n\nI tried the Kadane's approach before , but I was getting an error ,  "
                    },
                    {
                        "username": "6vedant",
                        "content": "Why my solution is beating only 41% of answers? Any help please to improve my working code.\\n\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int maxSoFar = Integer.MIN_VALUE;\\n        int maxTillYet = 0;\\n\\n        for(int i=0; i<nums.length; i++) {\\n            maxTillYet += nums[i];\\n            if (maxSoFar < maxTillYet) {\\n                maxSoFar = maxTillYet;\\n            }\\n            if (maxTillYet < 0) {\\n                maxTillYet = 0;\\n            }\\n        }\\n        return maxSoFar;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your code is using Kadane\\'s algorithm, which is the most optimal solution for the maximum subarray problem. It already runs in O(n) time complexity and uses O(1) space complexity, meaning you can\\'t really optimize it further from a time or space complexity standpoint.\\n\\nThe percentage you see on online judge platforms like LeetCode (41% in your case) is not entirely dependent on the efficiency of your algorithm. The speed of your solution can also be affected by factors that aren\\'t really related to the algorithm\\'s efficiency, like:\\n\\n- The programming language you use: Some languages are inherently faster than others. Solutions in languages like C or C++ often run faster than equivalent solutions in languages like Python or Java.\\n- System-level factors: These include things like the load on the online judge servers at the time of submission, the system\\'s I/O processing speed, etc.\\n\\nTherefore, while it\\'s always a good idea to aim for efficient code, don\\'t be too concerned about the percentage reported by the online judge system. It\\'s more important to make sure that your solution is correct, readable, and as efficient as it can be in terms of time and space complexity."
                    },
                    {
                        "username": "jokandre",
                        "content": "# Intuition behind kadane\\'s algo\\n\\nAt index ```i``` what it the max subarray sum?\\n- Can previous sum, nums[i-1], help maximize my current nums[i] \\n\\nGiven ```nums=[-2, 1] , i=1```\\n\\nRelationship between previous sum and current number: In order to maximize it\\n\\n| prev sum | cur  | max |  why  | \\n|---|---|---|-----|\\n| +1 | +1 |  1+1 |  prev+ cur   |\\n| -1 | +1 |  1 |  cur  |\\n| +1 | -1 | 0  |  prev+cur, cur must be included always!  |\\n| -1 | -1 | -1  |  cur |\\n\\nOptions:\\n- nums[i] is **positive**, then nums[i] is part of the solution\\n\\t- ```nums[i-1] + nums[i]``` : previous + i\\n\\t- ```nums[i]``` : previous discarted, perhaps sum to 0 or negative number\\n\\t\\n- nums[i] is **negative**\\n\\t- ```nums[i-1]+nums[i]```: previous being is positive will help increasing nums[i]\\n\\t- ```nums[i]```: if both previous is also negative it should not be added \\n\\nHope it helps\\n\\n\\n\\t"
                    }
                ]
            },
            {
                "id": 1764472,
                "content": [
                    {
                        "username": "surendra_19",
                        "content": "In the problem they mentioned maximum sum of subarray\\nSo what If I add only positive numbers so that it will make maximum number..?\\nCan I do that Anyone clarify my doubt\\nThanks in advance...."
                    },
                    {
                        "username": "bparanj",
                        "content": "The Maximum Subarray problem asks for the maximum sum of a contiguous subarray, meaning the elements in the subarray have to be next to each other in the original array. This is different from simply adding up all the positive numbers in the array.\\n\\nFor example, consider an array like `[-2, -3, 4, -1, -2, 1, 5, -3]`. If you add up all the positive numbers, you\\'ll get `4 + 1 + 5 = 10`. However, the maximum sum of a contiguous subarray is `4 - 1 - 2 + 1 + 5 = 7`, which includes some negative numbers.\\n\\nAdding up all positive numbers in the array would not give you the correct answer to this problem, because it ignores the requirement that the subarray be contiguous. If the problem instead asked for the maximum sum of a non-contiguous subarray, then yes, simply adding up all the positive numbers would give you the correct answer. But in the Maximum Subarray problem, the subarray must be contiguous."
                    },
                    {
                        "username": "pravin0rat",
                        "content": "in the array [-1] max sum of sub array should be 0 but it gives me wrong answer"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Kadane Kadane everywhere \\uD83D\\uDD25\\nOne of the most important topics ever, bcoz the questions may twist your thinking abilities\\n"
                    },
                    {
                        "username": "SpectRotation",
                        "content": "The Divide and Conquer solution passes 205/210 tests and gives Time Limit Exceeded error. "
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "when testcase is nums=[0];\\nexcept every test case runs.\\n\\n"
                    },
                    {
                        "username": "Mdkhalid789",
                        "content": "this is my solution and pass the all test case but not pass the only nums[] = {-1} \\n\\nplease help anyone  ;\\n\\n\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int ms = Integer.MIN_VALUE ; \\n        int cs = 0 ; \\n        for(int i=0 ; i<nums.length; i++){\\n            cs  += nums[i] ; \\n            if(cs < 0){\\n                cs = 0 ;\\n            }\\n            ms =  Math.max(cs , ms) ;  \\n        }\\n          return ms ;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue with your code lies in the check `if(cs < 0)`, which resets the current sum `cs` to 0 if it falls below 0. This approach works fine for arrays that have at least one positive number, because the maximum sum will always be greater than 0. However, if the array contains only negative numbers (like in your case `nums[] = {-1}`), then the maximum sum will be the maximum (or least negative) number in the array.\\n\\nTo handle this case, you should check whether `cs` is greater than `ms` before resetting `cs` to 0. Here is the corrected code:\\n\\n```java\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int ms = Integer.MIN_VALUE ;\\n        int cs = 0 ;\\n        for(int i=0 ; i<nums.length; i++){\\n            cs += nums[i] ;\\n            ms = Math.max(cs , ms);\\n            if(cs < 0){\\n                cs = 0 ;\\n            }\\n        }\\n        return ms ;\\n    }\\n}\\n```\\n\\nThis code works by first updating `ms` with the maximum of `cs` and `ms`, and then checking if `cs` has fallen below 0. If it has, `cs` is reset to 0. By updating `ms` before the check, you ensure that `ms` receives the highest sum encountered, even if that sum is negative."
                    },
                    {
                        "username": "saikiranvbembalge",
                        "content": "To solve this problem in O(n) time complexity, you can imagine it by using the concept of sliding window."
                    },
                    {
                        "username": "bparanj",
                        "content": "In a sliding window problem, we are given an array or a list of elements, and a \"window\" of a fixed size is defined. The goal is often to find or calculate something in that window, and then the window \"slides\" over one or more places, and the calculation is repeated until the window reaches the end of the array.\\n\\nThe main characteristics of the sliding window problems are:\\n\\n1. The window size is defined and it either stays constant or changes according to certain conditions as we traverse the array.\\n2. There is often a condition that needs to be satisfied for all elements in the window (for example, the sum of elements in the window must be less than a given value).\\n\\nIn the maximum subarray problem:\\n\\n1. There is no fixed window size. Instead, we have a variable-length subarray that could include any number of contiguous elements from the array. \\n2. There is no condition that all elements in the subarray need to satisfy. Instead, we\\'re looking for the subarray (of any size) that has the maximum sum.\\n\\nSo, while you can solve the maximum subarray problem in O(n) time (which is common in sliding window problems), it\\'s not accurate to categorize it as a sliding window problem because it doesn\\'t have the key characteristics of a sliding window problem. Instead, it\\'s usually categorized as a dynamic programming problem, because it involves making an optimal decision at each step based on the decisions made in previous steps."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "anatagomez",
                        "content": "This YouTube video offers a great explanation for the solution of this problem\\nhttps://www.youtube.com/watch?v=2MmGzdiKR9Y"
                    },
                    {
                        "username": "sdwvit",
                        "content": "fast boi \n\n ```\nvar maxSubArray = function(nums) {\n    for (let i = 1; i < nums.length; i++) {\n        nums[i] = Math.max(nums[i] + nums[i-1], nums[i]);\n    }\n    return Math.max(...nums)\n};\n```"
                    }
                ]
            },
            {
                "id": 1762823,
                "content": [
                    {
                        "username": "surendra_19",
                        "content": "In the problem they mentioned maximum sum of subarray\\nSo what If I add only positive numbers so that it will make maximum number..?\\nCan I do that Anyone clarify my doubt\\nThanks in advance...."
                    },
                    {
                        "username": "bparanj",
                        "content": "The Maximum Subarray problem asks for the maximum sum of a contiguous subarray, meaning the elements in the subarray have to be next to each other in the original array. This is different from simply adding up all the positive numbers in the array.\\n\\nFor example, consider an array like `[-2, -3, 4, -1, -2, 1, 5, -3]`. If you add up all the positive numbers, you\\'ll get `4 + 1 + 5 = 10`. However, the maximum sum of a contiguous subarray is `4 - 1 - 2 + 1 + 5 = 7`, which includes some negative numbers.\\n\\nAdding up all positive numbers in the array would not give you the correct answer to this problem, because it ignores the requirement that the subarray be contiguous. If the problem instead asked for the maximum sum of a non-contiguous subarray, then yes, simply adding up all the positive numbers would give you the correct answer. But in the Maximum Subarray problem, the subarray must be contiguous."
                    },
                    {
                        "username": "pravin0rat",
                        "content": "in the array [-1] max sum of sub array should be 0 but it gives me wrong answer"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Kadane Kadane everywhere \\uD83D\\uDD25\\nOne of the most important topics ever, bcoz the questions may twist your thinking abilities\\n"
                    },
                    {
                        "username": "SpectRotation",
                        "content": "The Divide and Conquer solution passes 205/210 tests and gives Time Limit Exceeded error. "
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "when testcase is nums=[0];\\nexcept every test case runs.\\n\\n"
                    },
                    {
                        "username": "Mdkhalid789",
                        "content": "this is my solution and pass the all test case but not pass the only nums[] = {-1} \\n\\nplease help anyone  ;\\n\\n\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int ms = Integer.MIN_VALUE ; \\n        int cs = 0 ; \\n        for(int i=0 ; i<nums.length; i++){\\n            cs  += nums[i] ; \\n            if(cs < 0){\\n                cs = 0 ;\\n            }\\n            ms =  Math.max(cs , ms) ;  \\n        }\\n          return ms ;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue with your code lies in the check `if(cs < 0)`, which resets the current sum `cs` to 0 if it falls below 0. This approach works fine for arrays that have at least one positive number, because the maximum sum will always be greater than 0. However, if the array contains only negative numbers (like in your case `nums[] = {-1}`), then the maximum sum will be the maximum (or least negative) number in the array.\\n\\nTo handle this case, you should check whether `cs` is greater than `ms` before resetting `cs` to 0. Here is the corrected code:\\n\\n```java\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int ms = Integer.MIN_VALUE ;\\n        int cs = 0 ;\\n        for(int i=0 ; i<nums.length; i++){\\n            cs += nums[i] ;\\n            ms = Math.max(cs , ms);\\n            if(cs < 0){\\n                cs = 0 ;\\n            }\\n        }\\n        return ms ;\\n    }\\n}\\n```\\n\\nThis code works by first updating `ms` with the maximum of `cs` and `ms`, and then checking if `cs` has fallen below 0. If it has, `cs` is reset to 0. By updating `ms` before the check, you ensure that `ms` receives the highest sum encountered, even if that sum is negative."
                    },
                    {
                        "username": "saikiranvbembalge",
                        "content": "To solve this problem in O(n) time complexity, you can imagine it by using the concept of sliding window."
                    },
                    {
                        "username": "bparanj",
                        "content": "In a sliding window problem, we are given an array or a list of elements, and a \"window\" of a fixed size is defined. The goal is often to find or calculate something in that window, and then the window \"slides\" over one or more places, and the calculation is repeated until the window reaches the end of the array.\\n\\nThe main characteristics of the sliding window problems are:\\n\\n1. The window size is defined and it either stays constant or changes according to certain conditions as we traverse the array.\\n2. There is often a condition that needs to be satisfied for all elements in the window (for example, the sum of elements in the window must be less than a given value).\\n\\nIn the maximum subarray problem:\\n\\n1. There is no fixed window size. Instead, we have a variable-length subarray that could include any number of contiguous elements from the array. \\n2. There is no condition that all elements in the subarray need to satisfy. Instead, we\\'re looking for the subarray (of any size) that has the maximum sum.\\n\\nSo, while you can solve the maximum subarray problem in O(n) time (which is common in sliding window problems), it\\'s not accurate to categorize it as a sliding window problem because it doesn\\'t have the key characteristics of a sliding window problem. Instead, it\\'s usually categorized as a dynamic programming problem, because it involves making an optimal decision at each step based on the decisions made in previous steps."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "anatagomez",
                        "content": "This YouTube video offers a great explanation for the solution of this problem\\nhttps://www.youtube.com/watch?v=2MmGzdiKR9Y"
                    },
                    {
                        "username": "sdwvit",
                        "content": "fast boi \n\n ```\nvar maxSubArray = function(nums) {\n    for (let i = 1; i < nums.length; i++) {\n        nums[i] = Math.max(nums[i] + nums[i-1], nums[i]);\n    }\n    return Math.max(...nums)\n};\n```"
                    }
                ]
            },
            {
                "id": 1762711,
                "content": [
                    {
                        "username": "surendra_19",
                        "content": "In the problem they mentioned maximum sum of subarray\\nSo what If I add only positive numbers so that it will make maximum number..?\\nCan I do that Anyone clarify my doubt\\nThanks in advance...."
                    },
                    {
                        "username": "bparanj",
                        "content": "The Maximum Subarray problem asks for the maximum sum of a contiguous subarray, meaning the elements in the subarray have to be next to each other in the original array. This is different from simply adding up all the positive numbers in the array.\\n\\nFor example, consider an array like `[-2, -3, 4, -1, -2, 1, 5, -3]`. If you add up all the positive numbers, you\\'ll get `4 + 1 + 5 = 10`. However, the maximum sum of a contiguous subarray is `4 - 1 - 2 + 1 + 5 = 7`, which includes some negative numbers.\\n\\nAdding up all positive numbers in the array would not give you the correct answer to this problem, because it ignores the requirement that the subarray be contiguous. If the problem instead asked for the maximum sum of a non-contiguous subarray, then yes, simply adding up all the positive numbers would give you the correct answer. But in the Maximum Subarray problem, the subarray must be contiguous."
                    },
                    {
                        "username": "pravin0rat",
                        "content": "in the array [-1] max sum of sub array should be 0 but it gives me wrong answer"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Kadane Kadane everywhere \\uD83D\\uDD25\\nOne of the most important topics ever, bcoz the questions may twist your thinking abilities\\n"
                    },
                    {
                        "username": "SpectRotation",
                        "content": "The Divide and Conquer solution passes 205/210 tests and gives Time Limit Exceeded error. "
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "when testcase is nums=[0];\\nexcept every test case runs.\\n\\n"
                    },
                    {
                        "username": "Mdkhalid789",
                        "content": "this is my solution and pass the all test case but not pass the only nums[] = {-1} \\n\\nplease help anyone  ;\\n\\n\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int ms = Integer.MIN_VALUE ; \\n        int cs = 0 ; \\n        for(int i=0 ; i<nums.length; i++){\\n            cs  += nums[i] ; \\n            if(cs < 0){\\n                cs = 0 ;\\n            }\\n            ms =  Math.max(cs , ms) ;  \\n        }\\n          return ms ;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue with your code lies in the check `if(cs < 0)`, which resets the current sum `cs` to 0 if it falls below 0. This approach works fine for arrays that have at least one positive number, because the maximum sum will always be greater than 0. However, if the array contains only negative numbers (like in your case `nums[] = {-1}`), then the maximum sum will be the maximum (or least negative) number in the array.\\n\\nTo handle this case, you should check whether `cs` is greater than `ms` before resetting `cs` to 0. Here is the corrected code:\\n\\n```java\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int ms = Integer.MIN_VALUE ;\\n        int cs = 0 ;\\n        for(int i=0 ; i<nums.length; i++){\\n            cs += nums[i] ;\\n            ms = Math.max(cs , ms);\\n            if(cs < 0){\\n                cs = 0 ;\\n            }\\n        }\\n        return ms ;\\n    }\\n}\\n```\\n\\nThis code works by first updating `ms` with the maximum of `cs` and `ms`, and then checking if `cs` has fallen below 0. If it has, `cs` is reset to 0. By updating `ms` before the check, you ensure that `ms` receives the highest sum encountered, even if that sum is negative."
                    },
                    {
                        "username": "saikiranvbembalge",
                        "content": "To solve this problem in O(n) time complexity, you can imagine it by using the concept of sliding window."
                    },
                    {
                        "username": "bparanj",
                        "content": "In a sliding window problem, we are given an array or a list of elements, and a \"window\" of a fixed size is defined. The goal is often to find or calculate something in that window, and then the window \"slides\" over one or more places, and the calculation is repeated until the window reaches the end of the array.\\n\\nThe main characteristics of the sliding window problems are:\\n\\n1. The window size is defined and it either stays constant or changes according to certain conditions as we traverse the array.\\n2. There is often a condition that needs to be satisfied for all elements in the window (for example, the sum of elements in the window must be less than a given value).\\n\\nIn the maximum subarray problem:\\n\\n1. There is no fixed window size. Instead, we have a variable-length subarray that could include any number of contiguous elements from the array. \\n2. There is no condition that all elements in the subarray need to satisfy. Instead, we\\'re looking for the subarray (of any size) that has the maximum sum.\\n\\nSo, while you can solve the maximum subarray problem in O(n) time (which is common in sliding window problems), it\\'s not accurate to categorize it as a sliding window problem because it doesn\\'t have the key characteristics of a sliding window problem. Instead, it\\'s usually categorized as a dynamic programming problem, because it involves making an optimal decision at each step based on the decisions made in previous steps."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "anatagomez",
                        "content": "This YouTube video offers a great explanation for the solution of this problem\\nhttps://www.youtube.com/watch?v=2MmGzdiKR9Y"
                    },
                    {
                        "username": "sdwvit",
                        "content": "fast boi \n\n ```\nvar maxSubArray = function(nums) {\n    for (let i = 1; i < nums.length; i++) {\n        nums[i] = Math.max(nums[i] + nums[i-1], nums[i]);\n    }\n    return Math.max(...nums)\n};\n```"
                    }
                ]
            },
            {
                "id": 1761056,
                "content": [
                    {
                        "username": "surendra_19",
                        "content": "In the problem they mentioned maximum sum of subarray\\nSo what If I add only positive numbers so that it will make maximum number..?\\nCan I do that Anyone clarify my doubt\\nThanks in advance...."
                    },
                    {
                        "username": "bparanj",
                        "content": "The Maximum Subarray problem asks for the maximum sum of a contiguous subarray, meaning the elements in the subarray have to be next to each other in the original array. This is different from simply adding up all the positive numbers in the array.\\n\\nFor example, consider an array like `[-2, -3, 4, -1, -2, 1, 5, -3]`. If you add up all the positive numbers, you\\'ll get `4 + 1 + 5 = 10`. However, the maximum sum of a contiguous subarray is `4 - 1 - 2 + 1 + 5 = 7`, which includes some negative numbers.\\n\\nAdding up all positive numbers in the array would not give you the correct answer to this problem, because it ignores the requirement that the subarray be contiguous. If the problem instead asked for the maximum sum of a non-contiguous subarray, then yes, simply adding up all the positive numbers would give you the correct answer. But in the Maximum Subarray problem, the subarray must be contiguous."
                    },
                    {
                        "username": "pravin0rat",
                        "content": "in the array [-1] max sum of sub array should be 0 but it gives me wrong answer"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Kadane Kadane everywhere \\uD83D\\uDD25\\nOne of the most important topics ever, bcoz the questions may twist your thinking abilities\\n"
                    },
                    {
                        "username": "SpectRotation",
                        "content": "The Divide and Conquer solution passes 205/210 tests and gives Time Limit Exceeded error. "
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "when testcase is nums=[0];\\nexcept every test case runs.\\n\\n"
                    },
                    {
                        "username": "Mdkhalid789",
                        "content": "this is my solution and pass the all test case but not pass the only nums[] = {-1} \\n\\nplease help anyone  ;\\n\\n\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int ms = Integer.MIN_VALUE ; \\n        int cs = 0 ; \\n        for(int i=0 ; i<nums.length; i++){\\n            cs  += nums[i] ; \\n            if(cs < 0){\\n                cs = 0 ;\\n            }\\n            ms =  Math.max(cs , ms) ;  \\n        }\\n          return ms ;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue with your code lies in the check `if(cs < 0)`, which resets the current sum `cs` to 0 if it falls below 0. This approach works fine for arrays that have at least one positive number, because the maximum sum will always be greater than 0. However, if the array contains only negative numbers (like in your case `nums[] = {-1}`), then the maximum sum will be the maximum (or least negative) number in the array.\\n\\nTo handle this case, you should check whether `cs` is greater than `ms` before resetting `cs` to 0. Here is the corrected code:\\n\\n```java\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int ms = Integer.MIN_VALUE ;\\n        int cs = 0 ;\\n        for(int i=0 ; i<nums.length; i++){\\n            cs += nums[i] ;\\n            ms = Math.max(cs , ms);\\n            if(cs < 0){\\n                cs = 0 ;\\n            }\\n        }\\n        return ms ;\\n    }\\n}\\n```\\n\\nThis code works by first updating `ms` with the maximum of `cs` and `ms`, and then checking if `cs` has fallen below 0. If it has, `cs` is reset to 0. By updating `ms` before the check, you ensure that `ms` receives the highest sum encountered, even if that sum is negative."
                    },
                    {
                        "username": "saikiranvbembalge",
                        "content": "To solve this problem in O(n) time complexity, you can imagine it by using the concept of sliding window."
                    },
                    {
                        "username": "bparanj",
                        "content": "In a sliding window problem, we are given an array or a list of elements, and a \"window\" of a fixed size is defined. The goal is often to find or calculate something in that window, and then the window \"slides\" over one or more places, and the calculation is repeated until the window reaches the end of the array.\\n\\nThe main characteristics of the sliding window problems are:\\n\\n1. The window size is defined and it either stays constant or changes according to certain conditions as we traverse the array.\\n2. There is often a condition that needs to be satisfied for all elements in the window (for example, the sum of elements in the window must be less than a given value).\\n\\nIn the maximum subarray problem:\\n\\n1. There is no fixed window size. Instead, we have a variable-length subarray that could include any number of contiguous elements from the array. \\n2. There is no condition that all elements in the subarray need to satisfy. Instead, we\\'re looking for the subarray (of any size) that has the maximum sum.\\n\\nSo, while you can solve the maximum subarray problem in O(n) time (which is common in sliding window problems), it\\'s not accurate to categorize it as a sliding window problem because it doesn\\'t have the key characteristics of a sliding window problem. Instead, it\\'s usually categorized as a dynamic programming problem, because it involves making an optimal decision at each step based on the decisions made in previous steps."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "anatagomez",
                        "content": "This YouTube video offers a great explanation for the solution of this problem\\nhttps://www.youtube.com/watch?v=2MmGzdiKR9Y"
                    },
                    {
                        "username": "sdwvit",
                        "content": "fast boi \n\n ```\nvar maxSubArray = function(nums) {\n    for (let i = 1; i < nums.length; i++) {\n        nums[i] = Math.max(nums[i] + nums[i-1], nums[i]);\n    }\n    return Math.max(...nums)\n};\n```"
                    }
                ]
            },
            {
                "id": 1758381,
                "content": [
                    {
                        "username": "surendra_19",
                        "content": "In the problem they mentioned maximum sum of subarray\\nSo what If I add only positive numbers so that it will make maximum number..?\\nCan I do that Anyone clarify my doubt\\nThanks in advance...."
                    },
                    {
                        "username": "bparanj",
                        "content": "The Maximum Subarray problem asks for the maximum sum of a contiguous subarray, meaning the elements in the subarray have to be next to each other in the original array. This is different from simply adding up all the positive numbers in the array.\\n\\nFor example, consider an array like `[-2, -3, 4, -1, -2, 1, 5, -3]`. If you add up all the positive numbers, you\\'ll get `4 + 1 + 5 = 10`. However, the maximum sum of a contiguous subarray is `4 - 1 - 2 + 1 + 5 = 7`, which includes some negative numbers.\\n\\nAdding up all positive numbers in the array would not give you the correct answer to this problem, because it ignores the requirement that the subarray be contiguous. If the problem instead asked for the maximum sum of a non-contiguous subarray, then yes, simply adding up all the positive numbers would give you the correct answer. But in the Maximum Subarray problem, the subarray must be contiguous."
                    },
                    {
                        "username": "pravin0rat",
                        "content": "in the array [-1] max sum of sub array should be 0 but it gives me wrong answer"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Kadane Kadane everywhere \\uD83D\\uDD25\\nOne of the most important topics ever, bcoz the questions may twist your thinking abilities\\n"
                    },
                    {
                        "username": "SpectRotation",
                        "content": "The Divide and Conquer solution passes 205/210 tests and gives Time Limit Exceeded error. "
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "when testcase is nums=[0];\\nexcept every test case runs.\\n\\n"
                    },
                    {
                        "username": "Mdkhalid789",
                        "content": "this is my solution and pass the all test case but not pass the only nums[] = {-1} \\n\\nplease help anyone  ;\\n\\n\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int ms = Integer.MIN_VALUE ; \\n        int cs = 0 ; \\n        for(int i=0 ; i<nums.length; i++){\\n            cs  += nums[i] ; \\n            if(cs < 0){\\n                cs = 0 ;\\n            }\\n            ms =  Math.max(cs , ms) ;  \\n        }\\n          return ms ;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue with your code lies in the check `if(cs < 0)`, which resets the current sum `cs` to 0 if it falls below 0. This approach works fine for arrays that have at least one positive number, because the maximum sum will always be greater than 0. However, if the array contains only negative numbers (like in your case `nums[] = {-1}`), then the maximum sum will be the maximum (or least negative) number in the array.\\n\\nTo handle this case, you should check whether `cs` is greater than `ms` before resetting `cs` to 0. Here is the corrected code:\\n\\n```java\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int ms = Integer.MIN_VALUE ;\\n        int cs = 0 ;\\n        for(int i=0 ; i<nums.length; i++){\\n            cs += nums[i] ;\\n            ms = Math.max(cs , ms);\\n            if(cs < 0){\\n                cs = 0 ;\\n            }\\n        }\\n        return ms ;\\n    }\\n}\\n```\\n\\nThis code works by first updating `ms` with the maximum of `cs` and `ms`, and then checking if `cs` has fallen below 0. If it has, `cs` is reset to 0. By updating `ms` before the check, you ensure that `ms` receives the highest sum encountered, even if that sum is negative."
                    },
                    {
                        "username": "saikiranvbembalge",
                        "content": "To solve this problem in O(n) time complexity, you can imagine it by using the concept of sliding window."
                    },
                    {
                        "username": "bparanj",
                        "content": "In a sliding window problem, we are given an array or a list of elements, and a \"window\" of a fixed size is defined. The goal is often to find or calculate something in that window, and then the window \"slides\" over one or more places, and the calculation is repeated until the window reaches the end of the array.\\n\\nThe main characteristics of the sliding window problems are:\\n\\n1. The window size is defined and it either stays constant or changes according to certain conditions as we traverse the array.\\n2. There is often a condition that needs to be satisfied for all elements in the window (for example, the sum of elements in the window must be less than a given value).\\n\\nIn the maximum subarray problem:\\n\\n1. There is no fixed window size. Instead, we have a variable-length subarray that could include any number of contiguous elements from the array. \\n2. There is no condition that all elements in the subarray need to satisfy. Instead, we\\'re looking for the subarray (of any size) that has the maximum sum.\\n\\nSo, while you can solve the maximum subarray problem in O(n) time (which is common in sliding window problems), it\\'s not accurate to categorize it as a sliding window problem because it doesn\\'t have the key characteristics of a sliding window problem. Instead, it\\'s usually categorized as a dynamic programming problem, because it involves making an optimal decision at each step based on the decisions made in previous steps."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "anatagomez",
                        "content": "This YouTube video offers a great explanation for the solution of this problem\\nhttps://www.youtube.com/watch?v=2MmGzdiKR9Y"
                    },
                    {
                        "username": "sdwvit",
                        "content": "fast boi \n\n ```\nvar maxSubArray = function(nums) {\n    for (let i = 1; i < nums.length; i++) {\n        nums[i] = Math.max(nums[i] + nums[i-1], nums[i]);\n    }\n    return Math.max(...nums)\n};\n```"
                    }
                ]
            },
            {
                "id": 1756024,
                "content": [
                    {
                        "username": "surendra_19",
                        "content": "In the problem they mentioned maximum sum of subarray\\nSo what If I add only positive numbers so that it will make maximum number..?\\nCan I do that Anyone clarify my doubt\\nThanks in advance...."
                    },
                    {
                        "username": "bparanj",
                        "content": "The Maximum Subarray problem asks for the maximum sum of a contiguous subarray, meaning the elements in the subarray have to be next to each other in the original array. This is different from simply adding up all the positive numbers in the array.\\n\\nFor example, consider an array like `[-2, -3, 4, -1, -2, 1, 5, -3]`. If you add up all the positive numbers, you\\'ll get `4 + 1 + 5 = 10`. However, the maximum sum of a contiguous subarray is `4 - 1 - 2 + 1 + 5 = 7`, which includes some negative numbers.\\n\\nAdding up all positive numbers in the array would not give you the correct answer to this problem, because it ignores the requirement that the subarray be contiguous. If the problem instead asked for the maximum sum of a non-contiguous subarray, then yes, simply adding up all the positive numbers would give you the correct answer. But in the Maximum Subarray problem, the subarray must be contiguous."
                    },
                    {
                        "username": "pravin0rat",
                        "content": "in the array [-1] max sum of sub array should be 0 but it gives me wrong answer"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Kadane Kadane everywhere \\uD83D\\uDD25\\nOne of the most important topics ever, bcoz the questions may twist your thinking abilities\\n"
                    },
                    {
                        "username": "SpectRotation",
                        "content": "The Divide and Conquer solution passes 205/210 tests and gives Time Limit Exceeded error. "
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "when testcase is nums=[0];\\nexcept every test case runs.\\n\\n"
                    },
                    {
                        "username": "Mdkhalid789",
                        "content": "this is my solution and pass the all test case but not pass the only nums[] = {-1} \\n\\nplease help anyone  ;\\n\\n\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int ms = Integer.MIN_VALUE ; \\n        int cs = 0 ; \\n        for(int i=0 ; i<nums.length; i++){\\n            cs  += nums[i] ; \\n            if(cs < 0){\\n                cs = 0 ;\\n            }\\n            ms =  Math.max(cs , ms) ;  \\n        }\\n          return ms ;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue with your code lies in the check `if(cs < 0)`, which resets the current sum `cs` to 0 if it falls below 0. This approach works fine for arrays that have at least one positive number, because the maximum sum will always be greater than 0. However, if the array contains only negative numbers (like in your case `nums[] = {-1}`), then the maximum sum will be the maximum (or least negative) number in the array.\\n\\nTo handle this case, you should check whether `cs` is greater than `ms` before resetting `cs` to 0. Here is the corrected code:\\n\\n```java\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int ms = Integer.MIN_VALUE ;\\n        int cs = 0 ;\\n        for(int i=0 ; i<nums.length; i++){\\n            cs += nums[i] ;\\n            ms = Math.max(cs , ms);\\n            if(cs < 0){\\n                cs = 0 ;\\n            }\\n        }\\n        return ms ;\\n    }\\n}\\n```\\n\\nThis code works by first updating `ms` with the maximum of `cs` and `ms`, and then checking if `cs` has fallen below 0. If it has, `cs` is reset to 0. By updating `ms` before the check, you ensure that `ms` receives the highest sum encountered, even if that sum is negative."
                    },
                    {
                        "username": "saikiranvbembalge",
                        "content": "To solve this problem in O(n) time complexity, you can imagine it by using the concept of sliding window."
                    },
                    {
                        "username": "bparanj",
                        "content": "In a sliding window problem, we are given an array or a list of elements, and a \"window\" of a fixed size is defined. The goal is often to find or calculate something in that window, and then the window \"slides\" over one or more places, and the calculation is repeated until the window reaches the end of the array.\\n\\nThe main characteristics of the sliding window problems are:\\n\\n1. The window size is defined and it either stays constant or changes according to certain conditions as we traverse the array.\\n2. There is often a condition that needs to be satisfied for all elements in the window (for example, the sum of elements in the window must be less than a given value).\\n\\nIn the maximum subarray problem:\\n\\n1. There is no fixed window size. Instead, we have a variable-length subarray that could include any number of contiguous elements from the array. \\n2. There is no condition that all elements in the subarray need to satisfy. Instead, we\\'re looking for the subarray (of any size) that has the maximum sum.\\n\\nSo, while you can solve the maximum subarray problem in O(n) time (which is common in sliding window problems), it\\'s not accurate to categorize it as a sliding window problem because it doesn\\'t have the key characteristics of a sliding window problem. Instead, it\\'s usually categorized as a dynamic programming problem, because it involves making an optimal decision at each step based on the decisions made in previous steps."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "anatagomez",
                        "content": "This YouTube video offers a great explanation for the solution of this problem\\nhttps://www.youtube.com/watch?v=2MmGzdiKR9Y"
                    },
                    {
                        "username": "sdwvit",
                        "content": "fast boi \n\n ```\nvar maxSubArray = function(nums) {\n    for (let i = 1; i < nums.length; i++) {\n        nums[i] = Math.max(nums[i] + nums[i-1], nums[i]);\n    }\n    return Math.max(...nums)\n};\n```"
                    }
                ]
            },
            {
                "id": 1752678,
                "content": [
                    {
                        "username": "surendra_19",
                        "content": "In the problem they mentioned maximum sum of subarray\\nSo what If I add only positive numbers so that it will make maximum number..?\\nCan I do that Anyone clarify my doubt\\nThanks in advance...."
                    },
                    {
                        "username": "bparanj",
                        "content": "The Maximum Subarray problem asks for the maximum sum of a contiguous subarray, meaning the elements in the subarray have to be next to each other in the original array. This is different from simply adding up all the positive numbers in the array.\\n\\nFor example, consider an array like `[-2, -3, 4, -1, -2, 1, 5, -3]`. If you add up all the positive numbers, you\\'ll get `4 + 1 + 5 = 10`. However, the maximum sum of a contiguous subarray is `4 - 1 - 2 + 1 + 5 = 7`, which includes some negative numbers.\\n\\nAdding up all positive numbers in the array would not give you the correct answer to this problem, because it ignores the requirement that the subarray be contiguous. If the problem instead asked for the maximum sum of a non-contiguous subarray, then yes, simply adding up all the positive numbers would give you the correct answer. But in the Maximum Subarray problem, the subarray must be contiguous."
                    },
                    {
                        "username": "pravin0rat",
                        "content": "in the array [-1] max sum of sub array should be 0 but it gives me wrong answer"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Kadane Kadane everywhere \\uD83D\\uDD25\\nOne of the most important topics ever, bcoz the questions may twist your thinking abilities\\n"
                    },
                    {
                        "username": "SpectRotation",
                        "content": "The Divide and Conquer solution passes 205/210 tests and gives Time Limit Exceeded error. "
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "when testcase is nums=[0];\\nexcept every test case runs.\\n\\n"
                    },
                    {
                        "username": "Mdkhalid789",
                        "content": "this is my solution and pass the all test case but not pass the only nums[] = {-1} \\n\\nplease help anyone  ;\\n\\n\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int ms = Integer.MIN_VALUE ; \\n        int cs = 0 ; \\n        for(int i=0 ; i<nums.length; i++){\\n            cs  += nums[i] ; \\n            if(cs < 0){\\n                cs = 0 ;\\n            }\\n            ms =  Math.max(cs , ms) ;  \\n        }\\n          return ms ;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue with your code lies in the check `if(cs < 0)`, which resets the current sum `cs` to 0 if it falls below 0. This approach works fine for arrays that have at least one positive number, because the maximum sum will always be greater than 0. However, if the array contains only negative numbers (like in your case `nums[] = {-1}`), then the maximum sum will be the maximum (or least negative) number in the array.\\n\\nTo handle this case, you should check whether `cs` is greater than `ms` before resetting `cs` to 0. Here is the corrected code:\\n\\n```java\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int ms = Integer.MIN_VALUE ;\\n        int cs = 0 ;\\n        for(int i=0 ; i<nums.length; i++){\\n            cs += nums[i] ;\\n            ms = Math.max(cs , ms);\\n            if(cs < 0){\\n                cs = 0 ;\\n            }\\n        }\\n        return ms ;\\n    }\\n}\\n```\\n\\nThis code works by first updating `ms` with the maximum of `cs` and `ms`, and then checking if `cs` has fallen below 0. If it has, `cs` is reset to 0. By updating `ms` before the check, you ensure that `ms` receives the highest sum encountered, even if that sum is negative."
                    },
                    {
                        "username": "saikiranvbembalge",
                        "content": "To solve this problem in O(n) time complexity, you can imagine it by using the concept of sliding window."
                    },
                    {
                        "username": "bparanj",
                        "content": "In a sliding window problem, we are given an array or a list of elements, and a \"window\" of a fixed size is defined. The goal is often to find or calculate something in that window, and then the window \"slides\" over one or more places, and the calculation is repeated until the window reaches the end of the array.\\n\\nThe main characteristics of the sliding window problems are:\\n\\n1. The window size is defined and it either stays constant or changes according to certain conditions as we traverse the array.\\n2. There is often a condition that needs to be satisfied for all elements in the window (for example, the sum of elements in the window must be less than a given value).\\n\\nIn the maximum subarray problem:\\n\\n1. There is no fixed window size. Instead, we have a variable-length subarray that could include any number of contiguous elements from the array. \\n2. There is no condition that all elements in the subarray need to satisfy. Instead, we\\'re looking for the subarray (of any size) that has the maximum sum.\\n\\nSo, while you can solve the maximum subarray problem in O(n) time (which is common in sliding window problems), it\\'s not accurate to categorize it as a sliding window problem because it doesn\\'t have the key characteristics of a sliding window problem. Instead, it\\'s usually categorized as a dynamic programming problem, because it involves making an optimal decision at each step based on the decisions made in previous steps."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "anatagomez",
                        "content": "This YouTube video offers a great explanation for the solution of this problem\\nhttps://www.youtube.com/watch?v=2MmGzdiKR9Y"
                    },
                    {
                        "username": "sdwvit",
                        "content": "fast boi \n\n ```\nvar maxSubArray = function(nums) {\n    for (let i = 1; i < nums.length; i++) {\n        nums[i] = Math.max(nums[i] + nums[i-1], nums[i]);\n    }\n    return Math.max(...nums)\n};\n```"
                    }
                ]
            },
            {
                "id": 1752639,
                "content": [
                    {
                        "username": "surendra_19",
                        "content": "In the problem they mentioned maximum sum of subarray\\nSo what If I add only positive numbers so that it will make maximum number..?\\nCan I do that Anyone clarify my doubt\\nThanks in advance...."
                    },
                    {
                        "username": "bparanj",
                        "content": "The Maximum Subarray problem asks for the maximum sum of a contiguous subarray, meaning the elements in the subarray have to be next to each other in the original array. This is different from simply adding up all the positive numbers in the array.\\n\\nFor example, consider an array like `[-2, -3, 4, -1, -2, 1, 5, -3]`. If you add up all the positive numbers, you\\'ll get `4 + 1 + 5 = 10`. However, the maximum sum of a contiguous subarray is `4 - 1 - 2 + 1 + 5 = 7`, which includes some negative numbers.\\n\\nAdding up all positive numbers in the array would not give you the correct answer to this problem, because it ignores the requirement that the subarray be contiguous. If the problem instead asked for the maximum sum of a non-contiguous subarray, then yes, simply adding up all the positive numbers would give you the correct answer. But in the Maximum Subarray problem, the subarray must be contiguous."
                    },
                    {
                        "username": "pravin0rat",
                        "content": "in the array [-1] max sum of sub array should be 0 but it gives me wrong answer"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Kadane Kadane everywhere \\uD83D\\uDD25\\nOne of the most important topics ever, bcoz the questions may twist your thinking abilities\\n"
                    },
                    {
                        "username": "SpectRotation",
                        "content": "The Divide and Conquer solution passes 205/210 tests and gives Time Limit Exceeded error. "
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "when testcase is nums=[0];\\nexcept every test case runs.\\n\\n"
                    },
                    {
                        "username": "Mdkhalid789",
                        "content": "this is my solution and pass the all test case but not pass the only nums[] = {-1} \\n\\nplease help anyone  ;\\n\\n\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int ms = Integer.MIN_VALUE ; \\n        int cs = 0 ; \\n        for(int i=0 ; i<nums.length; i++){\\n            cs  += nums[i] ; \\n            if(cs < 0){\\n                cs = 0 ;\\n            }\\n            ms =  Math.max(cs , ms) ;  \\n        }\\n          return ms ;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue with your code lies in the check `if(cs < 0)`, which resets the current sum `cs` to 0 if it falls below 0. This approach works fine for arrays that have at least one positive number, because the maximum sum will always be greater than 0. However, if the array contains only negative numbers (like in your case `nums[] = {-1}`), then the maximum sum will be the maximum (or least negative) number in the array.\\n\\nTo handle this case, you should check whether `cs` is greater than `ms` before resetting `cs` to 0. Here is the corrected code:\\n\\n```java\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int ms = Integer.MIN_VALUE ;\\n        int cs = 0 ;\\n        for(int i=0 ; i<nums.length; i++){\\n            cs += nums[i] ;\\n            ms = Math.max(cs , ms);\\n            if(cs < 0){\\n                cs = 0 ;\\n            }\\n        }\\n        return ms ;\\n    }\\n}\\n```\\n\\nThis code works by first updating `ms` with the maximum of `cs` and `ms`, and then checking if `cs` has fallen below 0. If it has, `cs` is reset to 0. By updating `ms` before the check, you ensure that `ms` receives the highest sum encountered, even if that sum is negative."
                    },
                    {
                        "username": "saikiranvbembalge",
                        "content": "To solve this problem in O(n) time complexity, you can imagine it by using the concept of sliding window."
                    },
                    {
                        "username": "bparanj",
                        "content": "In a sliding window problem, we are given an array or a list of elements, and a \"window\" of a fixed size is defined. The goal is often to find or calculate something in that window, and then the window \"slides\" over one or more places, and the calculation is repeated until the window reaches the end of the array.\\n\\nThe main characteristics of the sliding window problems are:\\n\\n1. The window size is defined and it either stays constant or changes according to certain conditions as we traverse the array.\\n2. There is often a condition that needs to be satisfied for all elements in the window (for example, the sum of elements in the window must be less than a given value).\\n\\nIn the maximum subarray problem:\\n\\n1. There is no fixed window size. Instead, we have a variable-length subarray that could include any number of contiguous elements from the array. \\n2. There is no condition that all elements in the subarray need to satisfy. Instead, we\\'re looking for the subarray (of any size) that has the maximum sum.\\n\\nSo, while you can solve the maximum subarray problem in O(n) time (which is common in sliding window problems), it\\'s not accurate to categorize it as a sliding window problem because it doesn\\'t have the key characteristics of a sliding window problem. Instead, it\\'s usually categorized as a dynamic programming problem, because it involves making an optimal decision at each step based on the decisions made in previous steps."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "anatagomez",
                        "content": "This YouTube video offers a great explanation for the solution of this problem\\nhttps://www.youtube.com/watch?v=2MmGzdiKR9Y"
                    },
                    {
                        "username": "sdwvit",
                        "content": "fast boi \n\n ```\nvar maxSubArray = function(nums) {\n    for (let i = 1; i < nums.length; i++) {\n        nums[i] = Math.max(nums[i] + nums[i-1], nums[i]);\n    }\n    return Math.max(...nums)\n};\n```"
                    }
                ]
            },
            {
                "id": 1752561,
                "content": [
                    {
                        "username": "surendra_19",
                        "content": "In the problem they mentioned maximum sum of subarray\\nSo what If I add only positive numbers so that it will make maximum number..?\\nCan I do that Anyone clarify my doubt\\nThanks in advance...."
                    },
                    {
                        "username": "bparanj",
                        "content": "The Maximum Subarray problem asks for the maximum sum of a contiguous subarray, meaning the elements in the subarray have to be next to each other in the original array. This is different from simply adding up all the positive numbers in the array.\\n\\nFor example, consider an array like `[-2, -3, 4, -1, -2, 1, 5, -3]`. If you add up all the positive numbers, you\\'ll get `4 + 1 + 5 = 10`. However, the maximum sum of a contiguous subarray is `4 - 1 - 2 + 1 + 5 = 7`, which includes some negative numbers.\\n\\nAdding up all positive numbers in the array would not give you the correct answer to this problem, because it ignores the requirement that the subarray be contiguous. If the problem instead asked for the maximum sum of a non-contiguous subarray, then yes, simply adding up all the positive numbers would give you the correct answer. But in the Maximum Subarray problem, the subarray must be contiguous."
                    },
                    {
                        "username": "pravin0rat",
                        "content": "in the array [-1] max sum of sub array should be 0 but it gives me wrong answer"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Kadane Kadane everywhere \\uD83D\\uDD25\\nOne of the most important topics ever, bcoz the questions may twist your thinking abilities\\n"
                    },
                    {
                        "username": "SpectRotation",
                        "content": "The Divide and Conquer solution passes 205/210 tests and gives Time Limit Exceeded error. "
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "when testcase is nums=[0];\\nexcept every test case runs.\\n\\n"
                    },
                    {
                        "username": "Mdkhalid789",
                        "content": "this is my solution and pass the all test case but not pass the only nums[] = {-1} \\n\\nplease help anyone  ;\\n\\n\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int ms = Integer.MIN_VALUE ; \\n        int cs = 0 ; \\n        for(int i=0 ; i<nums.length; i++){\\n            cs  += nums[i] ; \\n            if(cs < 0){\\n                cs = 0 ;\\n            }\\n            ms =  Math.max(cs , ms) ;  \\n        }\\n          return ms ;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue with your code lies in the check `if(cs < 0)`, which resets the current sum `cs` to 0 if it falls below 0. This approach works fine for arrays that have at least one positive number, because the maximum sum will always be greater than 0. However, if the array contains only negative numbers (like in your case `nums[] = {-1}`), then the maximum sum will be the maximum (or least negative) number in the array.\\n\\nTo handle this case, you should check whether `cs` is greater than `ms` before resetting `cs` to 0. Here is the corrected code:\\n\\n```java\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int ms = Integer.MIN_VALUE ;\\n        int cs = 0 ;\\n        for(int i=0 ; i<nums.length; i++){\\n            cs += nums[i] ;\\n            ms = Math.max(cs , ms);\\n            if(cs < 0){\\n                cs = 0 ;\\n            }\\n        }\\n        return ms ;\\n    }\\n}\\n```\\n\\nThis code works by first updating `ms` with the maximum of `cs` and `ms`, and then checking if `cs` has fallen below 0. If it has, `cs` is reset to 0. By updating `ms` before the check, you ensure that `ms` receives the highest sum encountered, even if that sum is negative."
                    },
                    {
                        "username": "saikiranvbembalge",
                        "content": "To solve this problem in O(n) time complexity, you can imagine it by using the concept of sliding window."
                    },
                    {
                        "username": "bparanj",
                        "content": "In a sliding window problem, we are given an array or a list of elements, and a \"window\" of a fixed size is defined. The goal is often to find or calculate something in that window, and then the window \"slides\" over one or more places, and the calculation is repeated until the window reaches the end of the array.\\n\\nThe main characteristics of the sliding window problems are:\\n\\n1. The window size is defined and it either stays constant or changes according to certain conditions as we traverse the array.\\n2. There is often a condition that needs to be satisfied for all elements in the window (for example, the sum of elements in the window must be less than a given value).\\n\\nIn the maximum subarray problem:\\n\\n1. There is no fixed window size. Instead, we have a variable-length subarray that could include any number of contiguous elements from the array. \\n2. There is no condition that all elements in the subarray need to satisfy. Instead, we\\'re looking for the subarray (of any size) that has the maximum sum.\\n\\nSo, while you can solve the maximum subarray problem in O(n) time (which is common in sliding window problems), it\\'s not accurate to categorize it as a sliding window problem because it doesn\\'t have the key characteristics of a sliding window problem. Instead, it\\'s usually categorized as a dynamic programming problem, because it involves making an optimal decision at each step based on the decisions made in previous steps."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "anatagomez",
                        "content": "This YouTube video offers a great explanation for the solution of this problem\\nhttps://www.youtube.com/watch?v=2MmGzdiKR9Y"
                    },
                    {
                        "username": "sdwvit",
                        "content": "fast boi \n\n ```\nvar maxSubArray = function(nums) {\n    for (let i = 1; i < nums.length; i++) {\n        nums[i] = Math.max(nums[i] + nums[i-1], nums[i]);\n    }\n    return Math.max(...nums)\n};\n```"
                    }
                ]
            },
            {
                "id": 1751686,
                "content": [
                    {
                        "username": "surendra_19",
                        "content": "In the problem they mentioned maximum sum of subarray\\nSo what If I add only positive numbers so that it will make maximum number..?\\nCan I do that Anyone clarify my doubt\\nThanks in advance...."
                    },
                    {
                        "username": "bparanj",
                        "content": "The Maximum Subarray problem asks for the maximum sum of a contiguous subarray, meaning the elements in the subarray have to be next to each other in the original array. This is different from simply adding up all the positive numbers in the array.\\n\\nFor example, consider an array like `[-2, -3, 4, -1, -2, 1, 5, -3]`. If you add up all the positive numbers, you\\'ll get `4 + 1 + 5 = 10`. However, the maximum sum of a contiguous subarray is `4 - 1 - 2 + 1 + 5 = 7`, which includes some negative numbers.\\n\\nAdding up all positive numbers in the array would not give you the correct answer to this problem, because it ignores the requirement that the subarray be contiguous. If the problem instead asked for the maximum sum of a non-contiguous subarray, then yes, simply adding up all the positive numbers would give you the correct answer. But in the Maximum Subarray problem, the subarray must be contiguous."
                    },
                    {
                        "username": "pravin0rat",
                        "content": "in the array [-1] max sum of sub array should be 0 but it gives me wrong answer"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "Kadane Kadane everywhere \\uD83D\\uDD25\\nOne of the most important topics ever, bcoz the questions may twist your thinking abilities\\n"
                    },
                    {
                        "username": "SpectRotation",
                        "content": "The Divide and Conquer solution passes 205/210 tests and gives Time Limit Exceeded error. "
                    },
                    {
                        "username": "anuragdeshmukh9090",
                        "content": "when testcase is nums=[0];\\nexcept every test case runs.\\n\\n"
                    },
                    {
                        "username": "Mdkhalid789",
                        "content": "this is my solution and pass the all test case but not pass the only nums[] = {-1} \\n\\nplease help anyone  ;\\n\\n\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int ms = Integer.MIN_VALUE ; \\n        int cs = 0 ; \\n        for(int i=0 ; i<nums.length; i++){\\n            cs  += nums[i] ; \\n            if(cs < 0){\\n                cs = 0 ;\\n            }\\n            ms =  Math.max(cs , ms) ;  \\n        }\\n          return ms ;\\n    }\\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue with your code lies in the check `if(cs < 0)`, which resets the current sum `cs` to 0 if it falls below 0. This approach works fine for arrays that have at least one positive number, because the maximum sum will always be greater than 0. However, if the array contains only negative numbers (like in your case `nums[] = {-1}`), then the maximum sum will be the maximum (or least negative) number in the array.\\n\\nTo handle this case, you should check whether `cs` is greater than `ms` before resetting `cs` to 0. Here is the corrected code:\\n\\n```java\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int ms = Integer.MIN_VALUE ;\\n        int cs = 0 ;\\n        for(int i=0 ; i<nums.length; i++){\\n            cs += nums[i] ;\\n            ms = Math.max(cs , ms);\\n            if(cs < 0){\\n                cs = 0 ;\\n            }\\n        }\\n        return ms ;\\n    }\\n}\\n```\\n\\nThis code works by first updating `ms` with the maximum of `cs` and `ms`, and then checking if `cs` has fallen below 0. If it has, `cs` is reset to 0. By updating `ms` before the check, you ensure that `ms` receives the highest sum encountered, even if that sum is negative."
                    },
                    {
                        "username": "saikiranvbembalge",
                        "content": "To solve this problem in O(n) time complexity, you can imagine it by using the concept of sliding window."
                    },
                    {
                        "username": "bparanj",
                        "content": "In a sliding window problem, we are given an array or a list of elements, and a \"window\" of a fixed size is defined. The goal is often to find or calculate something in that window, and then the window \"slides\" over one or more places, and the calculation is repeated until the window reaches the end of the array.\\n\\nThe main characteristics of the sliding window problems are:\\n\\n1. The window size is defined and it either stays constant or changes according to certain conditions as we traverse the array.\\n2. There is often a condition that needs to be satisfied for all elements in the window (for example, the sum of elements in the window must be less than a given value).\\n\\nIn the maximum subarray problem:\\n\\n1. There is no fixed window size. Instead, we have a variable-length subarray that could include any number of contiguous elements from the array. \\n2. There is no condition that all elements in the subarray need to satisfy. Instead, we\\'re looking for the subarray (of any size) that has the maximum sum.\\n\\nSo, while you can solve the maximum subarray problem in O(n) time (which is common in sliding window problems), it\\'s not accurate to categorize it as a sliding window problem because it doesn\\'t have the key characteristics of a sliding window problem. Instead, it\\'s usually categorized as a dynamic programming problem, because it involves making an optimal decision at each step based on the decisions made in previous steps."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "anatagomez",
                        "content": "This YouTube video offers a great explanation for the solution of this problem\\nhttps://www.youtube.com/watch?v=2MmGzdiKR9Y"
                    },
                    {
                        "username": "sdwvit",
                        "content": "fast boi \n\n ```\nvar maxSubArray = function(nums) {\n    for (let i = 1; i < nums.length; i++) {\n        nums[i] = Math.max(nums[i] + nums[i-1], nums[i]);\n    }\n    return Math.max(...nums)\n};\n```"
                    }
                ]
            },
            {
                "id": 1743946,
                "content": [
                    {
                        "username": "wodxuming",
                        "content": "```\\n    int maxSubArray(vector<int>& nums) {\\n        const int size = nums.size();\\n        vector<int> dp(size, 0);        \\n        \\n        // dp[i+1] = dp[i] + max(nums[i+1],0) + min(0, nums[i])\\n        dp[0] = max(nums[0], 0);\\n        for(int i = 1; i < nums.size(); ++i) {\\n            dp[i] = dp[i-1] + max(nums[i-1], 0) + min(0, nums[i-1]);\\n        }\\n        \\n        return dp[size-1];\\n    }\\n```"
                    },
                    {
                        "username": "esnoopy888",
                        "content": "I think it\\'s worth mentioning that empty subarrays are not allowed in this problem"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 1ms || Beats 100% || Easy to Understand.\\n\\nhttps://leetcode.com/problems/maximum-subarray/solutions/2992938/simple-java-1ms-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "bitleakash6",
                        "content": "Here is my solution with O(n) tc but its wrong answer for one case that is {-1}.\\nif anyone know plz help me\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int maxsum = INT_MIN;\\n        int currsum = 0;\\n        \\n        for(int i = 0; i<nums.size(); i++){\\n            currsum += nums[i];\\n            \\n            if(currsum < 0){\\n                currsum = 0;\\n            }\\n            maxsum = max(maxsum, currsum);\\n        }\\n        return maxsum;\\n\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your solution is almost correct. The problem occurs when all the numbers in the array are negative. In this situation, your current implementation will return 0, because it resets `currsum` to 0 whenever `currsum` becomes negative. However, for an array of all negative numbers, the maximum subarray sum is the maximum (or least negative) number in the array.\\n\\nTo fix this, you should update `maxsum` before checking whether `currsum` is negative. Here is the corrected code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int maxsum = INT_MIN;\\n        int currsum = 0;\\n\\n        for(int i = 0; i<nums.size(); i++){\\n            currsum += nums[i];\\n            maxsum = max(maxsum, currsum);\\n\\n            if(currsum < 0){\\n                currsum = 0;\\n            }\\n        }\\n        return maxsum;\\n    }\\n};\\n```\\n\\nNow, `maxsum` is updated with the maximum sum found so far before `currsum` is reset to 0. This way, even if all numbers in the array are negative, `maxsum` will hold the maximum (least negative) number."
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "In the description you only mention the divide and conquer solution to be more subtle, not that it **will** be slower. I spent some extra time implementing it, only to finally look at the official solution, where you explain it\\'s slower. \\n\\nI did learn a lot anyways. Great problem!"
                    },
                    {
                        "username": "Pawan-choudhary",
                        "content": "Hey why it's not working\n\n\n\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n\n\n\n        max_sum = -float('inf')\n        sum_ = 0\n        start = 0\n        end = len(nums)-1\n        prefix_sum = [nums[0]]\n        for i in range(1,len(nums)):\n            prefix_sum.append(nums[i] + prefix_sum[-1])\n        for start in range(len(nums)):\n            if start==0:\n                sum_ = prefix_sum[end]\n            else:\n                sum_ = prefix_sum[end] - prefix_sum[start-1]\n\n            if sum_ > max_sum:\n                max_sum = sum_\n        return max_sum                \n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation does not correctly solve the problem, because it only calculates the sum from the beginning of the array to an `end` index, and it does not consider all possible subarrays. \\n\\nIn other words, your current implementation only calculates the prefix sum of the array and returns the maximum prefix sum. This is not the same as finding the maximum sum of any subarray, which could start and end anywhere in the array. \\n\\nFor example, consider the array `[-2,1,-3,4,-1,2,1,-5,4]`. The maximum sum of any subarray is `6`, from the subarray `[4,-1,2,1]`. However, your current implementation would return `7`, which is the sum of the entire array from the beginning to the second-to-last element.\\n\\nTo solve this problem, you could use Kadane\\'s algorithm, which involves keeping track of the current subarray sum and the maximum subarray sum seen so far:\\n\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        max_sum = nums[0]\\n        curr_sum = nums[0]\\n        for num in nums[1:]:\\n            curr_sum = max(num, curr_sum + num)\\n            max_sum = max(max_sum, curr_sum)\\n        return max_sum\\n```\\n\\nThis algorithm works by iterating through the array, and at each step, it decides whether to add the current element to the previous subarray or start a new subarray from the current element. It also keeps track of the maximum subarray sum seen so far."
                    },
                    {
                        "username": "RishabhParihar",
                        "content": "I have assigned max sum as the first value of the array. But as soon as the value is -ve, my code does not take the next +ve element as the largest value.\nCan someone help?\n\n// c_sum = current sum\n// max_sum = maximum sum\n\nclass Solution \n{\n    public int maxSubArray(int[] nums) \n    {\n       \n        int max_sum = nums[0];\n        int c_sum = nums[0];\n        for(int i=1;i<nums.length;i++)\n        {\n            \n            c_sum = c_sum + nums[i];\n\n            if(c_sum > max_sum)\n            {\n                max_sum = c_sum;\n            }\n\n            if(c_sum < 0)\n            {\n                c_sum = 0;\n            }\n\n        }\n        return max_sum;\n    }\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation is almost correct. However, the order of your conditions is causing the code to not consider a positive number immediately after the `c_sum` becomes negative. \\n\\nIn your implementation, you\\'re adding `nums[i]` to `c_sum` and then checking if `c_sum` is greater than `max_sum`. If `c_sum` becomes negative after the addition, you\\'re resetting `c_sum` to 0. But in the next iteration, you\\'re still adding `nums[i]` to `c_sum` before checking if `c_sum` is negative, which could cause you to miss a positive number.\\n\\nYou should first check if `c_sum` is negative, reset it if necessary, and then add `nums[i]` to `c_sum`. Here is the corrected code:\\n\\n```java\\nclass Solution\\n{\\n    public int maxSubArray(int[] nums)\\n    {\\n        int max_sum = nums[0];\\n        int c_sum = 0;\\n\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            if(c_sum < 0)\\n            {\\n                c_sum = 0;\\n            }\\n\\n            c_sum = c_sum + nums[i];\\n\\n            if(c_sum > max_sum)\\n            {\\n                max_sum = c_sum;\\n            }\\n        }\\n        return max_sum;\\n    }\\n}\\n```\\nNow, you\\'re correctly considering every positive number in the array. Also, by setting `c_sum = 0` before the loop, you no longer need to initialize `c_sum` to `nums[0]`, which makes the code slightly more efficient."
                    },
                    {
                        "username": "Sexy_Shreyansh",
                        "content": "Can someone help me with this. My code is working fine but consider a case of [-2,-1]. Since my maxSum is set to 0. My output is coming 0 instead of-1. How should I modify my code? \\n \\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum=0,maxSum=0, i=0;\\n            if(nums.length==1) return nums[0];\\n        for( i=0;i<nums.length-1;i++){\\n                sum+=nums[i];\\n            for(int j=i+1;j<nums.length;j++){\\n                        sum+=nums[j];\\n                if(sum>maxSum){\\n                    maxSum=sum;\\n                }\\n            }\\n            sum=0;\\n        }\\n        return (nums[i]>maxSum)?nums[i]:maxSum;\\n    }\\n} "
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation checks the sum of all subarrays in the array and it is not efficient as it runs in O(n^2) time complexity. A better way is to use Kadane\\'s algorithm as mentioned before.\\n\\nIn addition, your current approach uses `maxSum=0` as a starting value, which means it will not work correctly if all numbers in the array are negative, because the maximum sum would be less than zero. \\n\\nInstead of starting `maxSum` at `0`, you should start it at the smallest possible integer value, `Integer.MIN_VALUE`, which guarantees that any sum of subarray will be larger than the initial `maxSum`. Here\\'s how you can modify your code:\\n\\n```java\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum = 0;\\n        int maxSum = Integer.MIN_VALUE;\\n        for(int i = 0; i < nums.length; i++){\\n            sum += nums[i];\\n            if(sum > maxSum){\\n                maxSum = sum;\\n            }\\n            if(sum < 0){\\n                sum = 0;\\n            }\\n        }\\n        return maxSum;\\n    }\\n}\\n```\\n\\nThis code initializes `maxSum` to `Integer.MIN_VALUE` and updates `maxSum` whenever `sum` is greater than `maxSum`. If `sum` becomes negative, it resets `sum` to `0` because no max subarray sum would include a negative sum."
                    },
                    {
                        "username": "pandeyjicoading",
                        "content": "i jumped to solve this problem right when i saw then suddenly i realised if i take it with brute force which is n3 the time complexity will throw me error then i decided to go for n2 but when i clicked on the discussion i saw that it could be done in On so now i am curius and wanna see that "
                    },
                    {
                        "username": "TechFreak107",
                        "content": "Is empty subarray not considered a subarray?\nThe array [-1] has two subarrays - [] and [-1] and the subarray with maximum sum is [ ] with the sum being 0. The solution shows the answer as -1. Any given array's maximum sum will always be >= 0."
                    }
                ]
            },
            {
                "id": 1740886,
                "content": [
                    {
                        "username": "wodxuming",
                        "content": "```\\n    int maxSubArray(vector<int>& nums) {\\n        const int size = nums.size();\\n        vector<int> dp(size, 0);        \\n        \\n        // dp[i+1] = dp[i] + max(nums[i+1],0) + min(0, nums[i])\\n        dp[0] = max(nums[0], 0);\\n        for(int i = 1; i < nums.size(); ++i) {\\n            dp[i] = dp[i-1] + max(nums[i-1], 0) + min(0, nums[i-1]);\\n        }\\n        \\n        return dp[size-1];\\n    }\\n```"
                    },
                    {
                        "username": "esnoopy888",
                        "content": "I think it\\'s worth mentioning that empty subarrays are not allowed in this problem"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 1ms || Beats 100% || Easy to Understand.\\n\\nhttps://leetcode.com/problems/maximum-subarray/solutions/2992938/simple-java-1ms-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "bitleakash6",
                        "content": "Here is my solution with O(n) tc but its wrong answer for one case that is {-1}.\\nif anyone know plz help me\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int maxsum = INT_MIN;\\n        int currsum = 0;\\n        \\n        for(int i = 0; i<nums.size(); i++){\\n            currsum += nums[i];\\n            \\n            if(currsum < 0){\\n                currsum = 0;\\n            }\\n            maxsum = max(maxsum, currsum);\\n        }\\n        return maxsum;\\n\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your solution is almost correct. The problem occurs when all the numbers in the array are negative. In this situation, your current implementation will return 0, because it resets `currsum` to 0 whenever `currsum` becomes negative. However, for an array of all negative numbers, the maximum subarray sum is the maximum (or least negative) number in the array.\\n\\nTo fix this, you should update `maxsum` before checking whether `currsum` is negative. Here is the corrected code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int maxsum = INT_MIN;\\n        int currsum = 0;\\n\\n        for(int i = 0; i<nums.size(); i++){\\n            currsum += nums[i];\\n            maxsum = max(maxsum, currsum);\\n\\n            if(currsum < 0){\\n                currsum = 0;\\n            }\\n        }\\n        return maxsum;\\n    }\\n};\\n```\\n\\nNow, `maxsum` is updated with the maximum sum found so far before `currsum` is reset to 0. This way, even if all numbers in the array are negative, `maxsum` will hold the maximum (least negative) number."
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "In the description you only mention the divide and conquer solution to be more subtle, not that it **will** be slower. I spent some extra time implementing it, only to finally look at the official solution, where you explain it\\'s slower. \\n\\nI did learn a lot anyways. Great problem!"
                    },
                    {
                        "username": "Pawan-choudhary",
                        "content": "Hey why it's not working\n\n\n\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n\n\n\n        max_sum = -float('inf')\n        sum_ = 0\n        start = 0\n        end = len(nums)-1\n        prefix_sum = [nums[0]]\n        for i in range(1,len(nums)):\n            prefix_sum.append(nums[i] + prefix_sum[-1])\n        for start in range(len(nums)):\n            if start==0:\n                sum_ = prefix_sum[end]\n            else:\n                sum_ = prefix_sum[end] - prefix_sum[start-1]\n\n            if sum_ > max_sum:\n                max_sum = sum_\n        return max_sum                \n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation does not correctly solve the problem, because it only calculates the sum from the beginning of the array to an `end` index, and it does not consider all possible subarrays. \\n\\nIn other words, your current implementation only calculates the prefix sum of the array and returns the maximum prefix sum. This is not the same as finding the maximum sum of any subarray, which could start and end anywhere in the array. \\n\\nFor example, consider the array `[-2,1,-3,4,-1,2,1,-5,4]`. The maximum sum of any subarray is `6`, from the subarray `[4,-1,2,1]`. However, your current implementation would return `7`, which is the sum of the entire array from the beginning to the second-to-last element.\\n\\nTo solve this problem, you could use Kadane\\'s algorithm, which involves keeping track of the current subarray sum and the maximum subarray sum seen so far:\\n\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        max_sum = nums[0]\\n        curr_sum = nums[0]\\n        for num in nums[1:]:\\n            curr_sum = max(num, curr_sum + num)\\n            max_sum = max(max_sum, curr_sum)\\n        return max_sum\\n```\\n\\nThis algorithm works by iterating through the array, and at each step, it decides whether to add the current element to the previous subarray or start a new subarray from the current element. It also keeps track of the maximum subarray sum seen so far."
                    },
                    {
                        "username": "RishabhParihar",
                        "content": "I have assigned max sum as the first value of the array. But as soon as the value is -ve, my code does not take the next +ve element as the largest value.\nCan someone help?\n\n// c_sum = current sum\n// max_sum = maximum sum\n\nclass Solution \n{\n    public int maxSubArray(int[] nums) \n    {\n       \n        int max_sum = nums[0];\n        int c_sum = nums[0];\n        for(int i=1;i<nums.length;i++)\n        {\n            \n            c_sum = c_sum + nums[i];\n\n            if(c_sum > max_sum)\n            {\n                max_sum = c_sum;\n            }\n\n            if(c_sum < 0)\n            {\n                c_sum = 0;\n            }\n\n        }\n        return max_sum;\n    }\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation is almost correct. However, the order of your conditions is causing the code to not consider a positive number immediately after the `c_sum` becomes negative. \\n\\nIn your implementation, you\\'re adding `nums[i]` to `c_sum` and then checking if `c_sum` is greater than `max_sum`. If `c_sum` becomes negative after the addition, you\\'re resetting `c_sum` to 0. But in the next iteration, you\\'re still adding `nums[i]` to `c_sum` before checking if `c_sum` is negative, which could cause you to miss a positive number.\\n\\nYou should first check if `c_sum` is negative, reset it if necessary, and then add `nums[i]` to `c_sum`. Here is the corrected code:\\n\\n```java\\nclass Solution\\n{\\n    public int maxSubArray(int[] nums)\\n    {\\n        int max_sum = nums[0];\\n        int c_sum = 0;\\n\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            if(c_sum < 0)\\n            {\\n                c_sum = 0;\\n            }\\n\\n            c_sum = c_sum + nums[i];\\n\\n            if(c_sum > max_sum)\\n            {\\n                max_sum = c_sum;\\n            }\\n        }\\n        return max_sum;\\n    }\\n}\\n```\\nNow, you\\'re correctly considering every positive number in the array. Also, by setting `c_sum = 0` before the loop, you no longer need to initialize `c_sum` to `nums[0]`, which makes the code slightly more efficient."
                    },
                    {
                        "username": "Sexy_Shreyansh",
                        "content": "Can someone help me with this. My code is working fine but consider a case of [-2,-1]. Since my maxSum is set to 0. My output is coming 0 instead of-1. How should I modify my code? \\n \\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum=0,maxSum=0, i=0;\\n            if(nums.length==1) return nums[0];\\n        for( i=0;i<nums.length-1;i++){\\n                sum+=nums[i];\\n            for(int j=i+1;j<nums.length;j++){\\n                        sum+=nums[j];\\n                if(sum>maxSum){\\n                    maxSum=sum;\\n                }\\n            }\\n            sum=0;\\n        }\\n        return (nums[i]>maxSum)?nums[i]:maxSum;\\n    }\\n} "
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation checks the sum of all subarrays in the array and it is not efficient as it runs in O(n^2) time complexity. A better way is to use Kadane\\'s algorithm as mentioned before.\\n\\nIn addition, your current approach uses `maxSum=0` as a starting value, which means it will not work correctly if all numbers in the array are negative, because the maximum sum would be less than zero. \\n\\nInstead of starting `maxSum` at `0`, you should start it at the smallest possible integer value, `Integer.MIN_VALUE`, which guarantees that any sum of subarray will be larger than the initial `maxSum`. Here\\'s how you can modify your code:\\n\\n```java\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum = 0;\\n        int maxSum = Integer.MIN_VALUE;\\n        for(int i = 0; i < nums.length; i++){\\n            sum += nums[i];\\n            if(sum > maxSum){\\n                maxSum = sum;\\n            }\\n            if(sum < 0){\\n                sum = 0;\\n            }\\n        }\\n        return maxSum;\\n    }\\n}\\n```\\n\\nThis code initializes `maxSum` to `Integer.MIN_VALUE` and updates `maxSum` whenever `sum` is greater than `maxSum`. If `sum` becomes negative, it resets `sum` to `0` because no max subarray sum would include a negative sum."
                    },
                    {
                        "username": "pandeyjicoading",
                        "content": "i jumped to solve this problem right when i saw then suddenly i realised if i take it with brute force which is n3 the time complexity will throw me error then i decided to go for n2 but when i clicked on the discussion i saw that it could be done in On so now i am curius and wanna see that "
                    },
                    {
                        "username": "TechFreak107",
                        "content": "Is empty subarray not considered a subarray?\nThe array [-1] has two subarrays - [] and [-1] and the subarray with maximum sum is [ ] with the sum being 0. The solution shows the answer as -1. Any given array's maximum sum will always be >= 0."
                    }
                ]
            },
            {
                "id": 1739945,
                "content": [
                    {
                        "username": "wodxuming",
                        "content": "```\\n    int maxSubArray(vector<int>& nums) {\\n        const int size = nums.size();\\n        vector<int> dp(size, 0);        \\n        \\n        // dp[i+1] = dp[i] + max(nums[i+1],0) + min(0, nums[i])\\n        dp[0] = max(nums[0], 0);\\n        for(int i = 1; i < nums.size(); ++i) {\\n            dp[i] = dp[i-1] + max(nums[i-1], 0) + min(0, nums[i-1]);\\n        }\\n        \\n        return dp[size-1];\\n    }\\n```"
                    },
                    {
                        "username": "esnoopy888",
                        "content": "I think it\\'s worth mentioning that empty subarrays are not allowed in this problem"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 1ms || Beats 100% || Easy to Understand.\\n\\nhttps://leetcode.com/problems/maximum-subarray/solutions/2992938/simple-java-1ms-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "bitleakash6",
                        "content": "Here is my solution with O(n) tc but its wrong answer for one case that is {-1}.\\nif anyone know plz help me\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int maxsum = INT_MIN;\\n        int currsum = 0;\\n        \\n        for(int i = 0; i<nums.size(); i++){\\n            currsum += nums[i];\\n            \\n            if(currsum < 0){\\n                currsum = 0;\\n            }\\n            maxsum = max(maxsum, currsum);\\n        }\\n        return maxsum;\\n\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your solution is almost correct. The problem occurs when all the numbers in the array are negative. In this situation, your current implementation will return 0, because it resets `currsum` to 0 whenever `currsum` becomes negative. However, for an array of all negative numbers, the maximum subarray sum is the maximum (or least negative) number in the array.\\n\\nTo fix this, you should update `maxsum` before checking whether `currsum` is negative. Here is the corrected code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int maxsum = INT_MIN;\\n        int currsum = 0;\\n\\n        for(int i = 0; i<nums.size(); i++){\\n            currsum += nums[i];\\n            maxsum = max(maxsum, currsum);\\n\\n            if(currsum < 0){\\n                currsum = 0;\\n            }\\n        }\\n        return maxsum;\\n    }\\n};\\n```\\n\\nNow, `maxsum` is updated with the maximum sum found so far before `currsum` is reset to 0. This way, even if all numbers in the array are negative, `maxsum` will hold the maximum (least negative) number."
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "In the description you only mention the divide and conquer solution to be more subtle, not that it **will** be slower. I spent some extra time implementing it, only to finally look at the official solution, where you explain it\\'s slower. \\n\\nI did learn a lot anyways. Great problem!"
                    },
                    {
                        "username": "Pawan-choudhary",
                        "content": "Hey why it's not working\n\n\n\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n\n\n\n        max_sum = -float('inf')\n        sum_ = 0\n        start = 0\n        end = len(nums)-1\n        prefix_sum = [nums[0]]\n        for i in range(1,len(nums)):\n            prefix_sum.append(nums[i] + prefix_sum[-1])\n        for start in range(len(nums)):\n            if start==0:\n                sum_ = prefix_sum[end]\n            else:\n                sum_ = prefix_sum[end] - prefix_sum[start-1]\n\n            if sum_ > max_sum:\n                max_sum = sum_\n        return max_sum                \n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation does not correctly solve the problem, because it only calculates the sum from the beginning of the array to an `end` index, and it does not consider all possible subarrays. \\n\\nIn other words, your current implementation only calculates the prefix sum of the array and returns the maximum prefix sum. This is not the same as finding the maximum sum of any subarray, which could start and end anywhere in the array. \\n\\nFor example, consider the array `[-2,1,-3,4,-1,2,1,-5,4]`. The maximum sum of any subarray is `6`, from the subarray `[4,-1,2,1]`. However, your current implementation would return `7`, which is the sum of the entire array from the beginning to the second-to-last element.\\n\\nTo solve this problem, you could use Kadane\\'s algorithm, which involves keeping track of the current subarray sum and the maximum subarray sum seen so far:\\n\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        max_sum = nums[0]\\n        curr_sum = nums[0]\\n        for num in nums[1:]:\\n            curr_sum = max(num, curr_sum + num)\\n            max_sum = max(max_sum, curr_sum)\\n        return max_sum\\n```\\n\\nThis algorithm works by iterating through the array, and at each step, it decides whether to add the current element to the previous subarray or start a new subarray from the current element. It also keeps track of the maximum subarray sum seen so far."
                    },
                    {
                        "username": "RishabhParihar",
                        "content": "I have assigned max sum as the first value of the array. But as soon as the value is -ve, my code does not take the next +ve element as the largest value.\nCan someone help?\n\n// c_sum = current sum\n// max_sum = maximum sum\n\nclass Solution \n{\n    public int maxSubArray(int[] nums) \n    {\n       \n        int max_sum = nums[0];\n        int c_sum = nums[0];\n        for(int i=1;i<nums.length;i++)\n        {\n            \n            c_sum = c_sum + nums[i];\n\n            if(c_sum > max_sum)\n            {\n                max_sum = c_sum;\n            }\n\n            if(c_sum < 0)\n            {\n                c_sum = 0;\n            }\n\n        }\n        return max_sum;\n    }\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation is almost correct. However, the order of your conditions is causing the code to not consider a positive number immediately after the `c_sum` becomes negative. \\n\\nIn your implementation, you\\'re adding `nums[i]` to `c_sum` and then checking if `c_sum` is greater than `max_sum`. If `c_sum` becomes negative after the addition, you\\'re resetting `c_sum` to 0. But in the next iteration, you\\'re still adding `nums[i]` to `c_sum` before checking if `c_sum` is negative, which could cause you to miss a positive number.\\n\\nYou should first check if `c_sum` is negative, reset it if necessary, and then add `nums[i]` to `c_sum`. Here is the corrected code:\\n\\n```java\\nclass Solution\\n{\\n    public int maxSubArray(int[] nums)\\n    {\\n        int max_sum = nums[0];\\n        int c_sum = 0;\\n\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            if(c_sum < 0)\\n            {\\n                c_sum = 0;\\n            }\\n\\n            c_sum = c_sum + nums[i];\\n\\n            if(c_sum > max_sum)\\n            {\\n                max_sum = c_sum;\\n            }\\n        }\\n        return max_sum;\\n    }\\n}\\n```\\nNow, you\\'re correctly considering every positive number in the array. Also, by setting `c_sum = 0` before the loop, you no longer need to initialize `c_sum` to `nums[0]`, which makes the code slightly more efficient."
                    },
                    {
                        "username": "Sexy_Shreyansh",
                        "content": "Can someone help me with this. My code is working fine but consider a case of [-2,-1]. Since my maxSum is set to 0. My output is coming 0 instead of-1. How should I modify my code? \\n \\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum=0,maxSum=0, i=0;\\n            if(nums.length==1) return nums[0];\\n        for( i=0;i<nums.length-1;i++){\\n                sum+=nums[i];\\n            for(int j=i+1;j<nums.length;j++){\\n                        sum+=nums[j];\\n                if(sum>maxSum){\\n                    maxSum=sum;\\n                }\\n            }\\n            sum=0;\\n        }\\n        return (nums[i]>maxSum)?nums[i]:maxSum;\\n    }\\n} "
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation checks the sum of all subarrays in the array and it is not efficient as it runs in O(n^2) time complexity. A better way is to use Kadane\\'s algorithm as mentioned before.\\n\\nIn addition, your current approach uses `maxSum=0` as a starting value, which means it will not work correctly if all numbers in the array are negative, because the maximum sum would be less than zero. \\n\\nInstead of starting `maxSum` at `0`, you should start it at the smallest possible integer value, `Integer.MIN_VALUE`, which guarantees that any sum of subarray will be larger than the initial `maxSum`. Here\\'s how you can modify your code:\\n\\n```java\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum = 0;\\n        int maxSum = Integer.MIN_VALUE;\\n        for(int i = 0; i < nums.length; i++){\\n            sum += nums[i];\\n            if(sum > maxSum){\\n                maxSum = sum;\\n            }\\n            if(sum < 0){\\n                sum = 0;\\n            }\\n        }\\n        return maxSum;\\n    }\\n}\\n```\\n\\nThis code initializes `maxSum` to `Integer.MIN_VALUE` and updates `maxSum` whenever `sum` is greater than `maxSum`. If `sum` becomes negative, it resets `sum` to `0` because no max subarray sum would include a negative sum."
                    },
                    {
                        "username": "pandeyjicoading",
                        "content": "i jumped to solve this problem right when i saw then suddenly i realised if i take it with brute force which is n3 the time complexity will throw me error then i decided to go for n2 but when i clicked on the discussion i saw that it could be done in On so now i am curius and wanna see that "
                    },
                    {
                        "username": "TechFreak107",
                        "content": "Is empty subarray not considered a subarray?\nThe array [-1] has two subarrays - [] and [-1] and the subarray with maximum sum is [ ] with the sum being 0. The solution shows the answer as -1. Any given array's maximum sum will always be >= 0."
                    }
                ]
            },
            {
                "id": 1738123,
                "content": [
                    {
                        "username": "wodxuming",
                        "content": "```\\n    int maxSubArray(vector<int>& nums) {\\n        const int size = nums.size();\\n        vector<int> dp(size, 0);        \\n        \\n        // dp[i+1] = dp[i] + max(nums[i+1],0) + min(0, nums[i])\\n        dp[0] = max(nums[0], 0);\\n        for(int i = 1; i < nums.size(); ++i) {\\n            dp[i] = dp[i-1] + max(nums[i-1], 0) + min(0, nums[i-1]);\\n        }\\n        \\n        return dp[size-1];\\n    }\\n```"
                    },
                    {
                        "username": "esnoopy888",
                        "content": "I think it\\'s worth mentioning that empty subarrays are not allowed in this problem"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 1ms || Beats 100% || Easy to Understand.\\n\\nhttps://leetcode.com/problems/maximum-subarray/solutions/2992938/simple-java-1ms-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "bitleakash6",
                        "content": "Here is my solution with O(n) tc but its wrong answer for one case that is {-1}.\\nif anyone know plz help me\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int maxsum = INT_MIN;\\n        int currsum = 0;\\n        \\n        for(int i = 0; i<nums.size(); i++){\\n            currsum += nums[i];\\n            \\n            if(currsum < 0){\\n                currsum = 0;\\n            }\\n            maxsum = max(maxsum, currsum);\\n        }\\n        return maxsum;\\n\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your solution is almost correct. The problem occurs when all the numbers in the array are negative. In this situation, your current implementation will return 0, because it resets `currsum` to 0 whenever `currsum` becomes negative. However, for an array of all negative numbers, the maximum subarray sum is the maximum (or least negative) number in the array.\\n\\nTo fix this, you should update `maxsum` before checking whether `currsum` is negative. Here is the corrected code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int maxsum = INT_MIN;\\n        int currsum = 0;\\n\\n        for(int i = 0; i<nums.size(); i++){\\n            currsum += nums[i];\\n            maxsum = max(maxsum, currsum);\\n\\n            if(currsum < 0){\\n                currsum = 0;\\n            }\\n        }\\n        return maxsum;\\n    }\\n};\\n```\\n\\nNow, `maxsum` is updated with the maximum sum found so far before `currsum` is reset to 0. This way, even if all numbers in the array are negative, `maxsum` will hold the maximum (least negative) number."
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "In the description you only mention the divide and conquer solution to be more subtle, not that it **will** be slower. I spent some extra time implementing it, only to finally look at the official solution, where you explain it\\'s slower. \\n\\nI did learn a lot anyways. Great problem!"
                    },
                    {
                        "username": "Pawan-choudhary",
                        "content": "Hey why it's not working\n\n\n\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n\n\n\n        max_sum = -float('inf')\n        sum_ = 0\n        start = 0\n        end = len(nums)-1\n        prefix_sum = [nums[0]]\n        for i in range(1,len(nums)):\n            prefix_sum.append(nums[i] + prefix_sum[-1])\n        for start in range(len(nums)):\n            if start==0:\n                sum_ = prefix_sum[end]\n            else:\n                sum_ = prefix_sum[end] - prefix_sum[start-1]\n\n            if sum_ > max_sum:\n                max_sum = sum_\n        return max_sum                \n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation does not correctly solve the problem, because it only calculates the sum from the beginning of the array to an `end` index, and it does not consider all possible subarrays. \\n\\nIn other words, your current implementation only calculates the prefix sum of the array and returns the maximum prefix sum. This is not the same as finding the maximum sum of any subarray, which could start and end anywhere in the array. \\n\\nFor example, consider the array `[-2,1,-3,4,-1,2,1,-5,4]`. The maximum sum of any subarray is `6`, from the subarray `[4,-1,2,1]`. However, your current implementation would return `7`, which is the sum of the entire array from the beginning to the second-to-last element.\\n\\nTo solve this problem, you could use Kadane\\'s algorithm, which involves keeping track of the current subarray sum and the maximum subarray sum seen so far:\\n\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        max_sum = nums[0]\\n        curr_sum = nums[0]\\n        for num in nums[1:]:\\n            curr_sum = max(num, curr_sum + num)\\n            max_sum = max(max_sum, curr_sum)\\n        return max_sum\\n```\\n\\nThis algorithm works by iterating through the array, and at each step, it decides whether to add the current element to the previous subarray or start a new subarray from the current element. It also keeps track of the maximum subarray sum seen so far."
                    },
                    {
                        "username": "RishabhParihar",
                        "content": "I have assigned max sum as the first value of the array. But as soon as the value is -ve, my code does not take the next +ve element as the largest value.\nCan someone help?\n\n// c_sum = current sum\n// max_sum = maximum sum\n\nclass Solution \n{\n    public int maxSubArray(int[] nums) \n    {\n       \n        int max_sum = nums[0];\n        int c_sum = nums[0];\n        for(int i=1;i<nums.length;i++)\n        {\n            \n            c_sum = c_sum + nums[i];\n\n            if(c_sum > max_sum)\n            {\n                max_sum = c_sum;\n            }\n\n            if(c_sum < 0)\n            {\n                c_sum = 0;\n            }\n\n        }\n        return max_sum;\n    }\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation is almost correct. However, the order of your conditions is causing the code to not consider a positive number immediately after the `c_sum` becomes negative. \\n\\nIn your implementation, you\\'re adding `nums[i]` to `c_sum` and then checking if `c_sum` is greater than `max_sum`. If `c_sum` becomes negative after the addition, you\\'re resetting `c_sum` to 0. But in the next iteration, you\\'re still adding `nums[i]` to `c_sum` before checking if `c_sum` is negative, which could cause you to miss a positive number.\\n\\nYou should first check if `c_sum` is negative, reset it if necessary, and then add `nums[i]` to `c_sum`. Here is the corrected code:\\n\\n```java\\nclass Solution\\n{\\n    public int maxSubArray(int[] nums)\\n    {\\n        int max_sum = nums[0];\\n        int c_sum = 0;\\n\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            if(c_sum < 0)\\n            {\\n                c_sum = 0;\\n            }\\n\\n            c_sum = c_sum + nums[i];\\n\\n            if(c_sum > max_sum)\\n            {\\n                max_sum = c_sum;\\n            }\\n        }\\n        return max_sum;\\n    }\\n}\\n```\\nNow, you\\'re correctly considering every positive number in the array. Also, by setting `c_sum = 0` before the loop, you no longer need to initialize `c_sum` to `nums[0]`, which makes the code slightly more efficient."
                    },
                    {
                        "username": "Sexy_Shreyansh",
                        "content": "Can someone help me with this. My code is working fine but consider a case of [-2,-1]. Since my maxSum is set to 0. My output is coming 0 instead of-1. How should I modify my code? \\n \\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum=0,maxSum=0, i=0;\\n            if(nums.length==1) return nums[0];\\n        for( i=0;i<nums.length-1;i++){\\n                sum+=nums[i];\\n            for(int j=i+1;j<nums.length;j++){\\n                        sum+=nums[j];\\n                if(sum>maxSum){\\n                    maxSum=sum;\\n                }\\n            }\\n            sum=0;\\n        }\\n        return (nums[i]>maxSum)?nums[i]:maxSum;\\n    }\\n} "
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation checks the sum of all subarrays in the array and it is not efficient as it runs in O(n^2) time complexity. A better way is to use Kadane\\'s algorithm as mentioned before.\\n\\nIn addition, your current approach uses `maxSum=0` as a starting value, which means it will not work correctly if all numbers in the array are negative, because the maximum sum would be less than zero. \\n\\nInstead of starting `maxSum` at `0`, you should start it at the smallest possible integer value, `Integer.MIN_VALUE`, which guarantees that any sum of subarray will be larger than the initial `maxSum`. Here\\'s how you can modify your code:\\n\\n```java\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum = 0;\\n        int maxSum = Integer.MIN_VALUE;\\n        for(int i = 0; i < nums.length; i++){\\n            sum += nums[i];\\n            if(sum > maxSum){\\n                maxSum = sum;\\n            }\\n            if(sum < 0){\\n                sum = 0;\\n            }\\n        }\\n        return maxSum;\\n    }\\n}\\n```\\n\\nThis code initializes `maxSum` to `Integer.MIN_VALUE` and updates `maxSum` whenever `sum` is greater than `maxSum`. If `sum` becomes negative, it resets `sum` to `0` because no max subarray sum would include a negative sum."
                    },
                    {
                        "username": "pandeyjicoading",
                        "content": "i jumped to solve this problem right when i saw then suddenly i realised if i take it with brute force which is n3 the time complexity will throw me error then i decided to go for n2 but when i clicked on the discussion i saw that it could be done in On so now i am curius and wanna see that "
                    },
                    {
                        "username": "TechFreak107",
                        "content": "Is empty subarray not considered a subarray?\nThe array [-1] has two subarrays - [] and [-1] and the subarray with maximum sum is [ ] with the sum being 0. The solution shows the answer as -1. Any given array's maximum sum will always be >= 0."
                    }
                ]
            },
            {
                "id": 1735697,
                "content": [
                    {
                        "username": "wodxuming",
                        "content": "```\\n    int maxSubArray(vector<int>& nums) {\\n        const int size = nums.size();\\n        vector<int> dp(size, 0);        \\n        \\n        // dp[i+1] = dp[i] + max(nums[i+1],0) + min(0, nums[i])\\n        dp[0] = max(nums[0], 0);\\n        for(int i = 1; i < nums.size(); ++i) {\\n            dp[i] = dp[i-1] + max(nums[i-1], 0) + min(0, nums[i-1]);\\n        }\\n        \\n        return dp[size-1];\\n    }\\n```"
                    },
                    {
                        "username": "esnoopy888",
                        "content": "I think it\\'s worth mentioning that empty subarrays are not allowed in this problem"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 1ms || Beats 100% || Easy to Understand.\\n\\nhttps://leetcode.com/problems/maximum-subarray/solutions/2992938/simple-java-1ms-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "bitleakash6",
                        "content": "Here is my solution with O(n) tc but its wrong answer for one case that is {-1}.\\nif anyone know plz help me\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int maxsum = INT_MIN;\\n        int currsum = 0;\\n        \\n        for(int i = 0; i<nums.size(); i++){\\n            currsum += nums[i];\\n            \\n            if(currsum < 0){\\n                currsum = 0;\\n            }\\n            maxsum = max(maxsum, currsum);\\n        }\\n        return maxsum;\\n\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your solution is almost correct. The problem occurs when all the numbers in the array are negative. In this situation, your current implementation will return 0, because it resets `currsum` to 0 whenever `currsum` becomes negative. However, for an array of all negative numbers, the maximum subarray sum is the maximum (or least negative) number in the array.\\n\\nTo fix this, you should update `maxsum` before checking whether `currsum` is negative. Here is the corrected code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int maxsum = INT_MIN;\\n        int currsum = 0;\\n\\n        for(int i = 0; i<nums.size(); i++){\\n            currsum += nums[i];\\n            maxsum = max(maxsum, currsum);\\n\\n            if(currsum < 0){\\n                currsum = 0;\\n            }\\n        }\\n        return maxsum;\\n    }\\n};\\n```\\n\\nNow, `maxsum` is updated with the maximum sum found so far before `currsum` is reset to 0. This way, even if all numbers in the array are negative, `maxsum` will hold the maximum (least negative) number."
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "In the description you only mention the divide and conquer solution to be more subtle, not that it **will** be slower. I spent some extra time implementing it, only to finally look at the official solution, where you explain it\\'s slower. \\n\\nI did learn a lot anyways. Great problem!"
                    },
                    {
                        "username": "Pawan-choudhary",
                        "content": "Hey why it's not working\n\n\n\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n\n\n\n        max_sum = -float('inf')\n        sum_ = 0\n        start = 0\n        end = len(nums)-1\n        prefix_sum = [nums[0]]\n        for i in range(1,len(nums)):\n            prefix_sum.append(nums[i] + prefix_sum[-1])\n        for start in range(len(nums)):\n            if start==0:\n                sum_ = prefix_sum[end]\n            else:\n                sum_ = prefix_sum[end] - prefix_sum[start-1]\n\n            if sum_ > max_sum:\n                max_sum = sum_\n        return max_sum                \n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation does not correctly solve the problem, because it only calculates the sum from the beginning of the array to an `end` index, and it does not consider all possible subarrays. \\n\\nIn other words, your current implementation only calculates the prefix sum of the array and returns the maximum prefix sum. This is not the same as finding the maximum sum of any subarray, which could start and end anywhere in the array. \\n\\nFor example, consider the array `[-2,1,-3,4,-1,2,1,-5,4]`. The maximum sum of any subarray is `6`, from the subarray `[4,-1,2,1]`. However, your current implementation would return `7`, which is the sum of the entire array from the beginning to the second-to-last element.\\n\\nTo solve this problem, you could use Kadane\\'s algorithm, which involves keeping track of the current subarray sum and the maximum subarray sum seen so far:\\n\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        max_sum = nums[0]\\n        curr_sum = nums[0]\\n        for num in nums[1:]:\\n            curr_sum = max(num, curr_sum + num)\\n            max_sum = max(max_sum, curr_sum)\\n        return max_sum\\n```\\n\\nThis algorithm works by iterating through the array, and at each step, it decides whether to add the current element to the previous subarray or start a new subarray from the current element. It also keeps track of the maximum subarray sum seen so far."
                    },
                    {
                        "username": "RishabhParihar",
                        "content": "I have assigned max sum as the first value of the array. But as soon as the value is -ve, my code does not take the next +ve element as the largest value.\nCan someone help?\n\n// c_sum = current sum\n// max_sum = maximum sum\n\nclass Solution \n{\n    public int maxSubArray(int[] nums) \n    {\n       \n        int max_sum = nums[0];\n        int c_sum = nums[0];\n        for(int i=1;i<nums.length;i++)\n        {\n            \n            c_sum = c_sum + nums[i];\n\n            if(c_sum > max_sum)\n            {\n                max_sum = c_sum;\n            }\n\n            if(c_sum < 0)\n            {\n                c_sum = 0;\n            }\n\n        }\n        return max_sum;\n    }\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation is almost correct. However, the order of your conditions is causing the code to not consider a positive number immediately after the `c_sum` becomes negative. \\n\\nIn your implementation, you\\'re adding `nums[i]` to `c_sum` and then checking if `c_sum` is greater than `max_sum`. If `c_sum` becomes negative after the addition, you\\'re resetting `c_sum` to 0. But in the next iteration, you\\'re still adding `nums[i]` to `c_sum` before checking if `c_sum` is negative, which could cause you to miss a positive number.\\n\\nYou should first check if `c_sum` is negative, reset it if necessary, and then add `nums[i]` to `c_sum`. Here is the corrected code:\\n\\n```java\\nclass Solution\\n{\\n    public int maxSubArray(int[] nums)\\n    {\\n        int max_sum = nums[0];\\n        int c_sum = 0;\\n\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            if(c_sum < 0)\\n            {\\n                c_sum = 0;\\n            }\\n\\n            c_sum = c_sum + nums[i];\\n\\n            if(c_sum > max_sum)\\n            {\\n                max_sum = c_sum;\\n            }\\n        }\\n        return max_sum;\\n    }\\n}\\n```\\nNow, you\\'re correctly considering every positive number in the array. Also, by setting `c_sum = 0` before the loop, you no longer need to initialize `c_sum` to `nums[0]`, which makes the code slightly more efficient."
                    },
                    {
                        "username": "Sexy_Shreyansh",
                        "content": "Can someone help me with this. My code is working fine but consider a case of [-2,-1]. Since my maxSum is set to 0. My output is coming 0 instead of-1. How should I modify my code? \\n \\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum=0,maxSum=0, i=0;\\n            if(nums.length==1) return nums[0];\\n        for( i=0;i<nums.length-1;i++){\\n                sum+=nums[i];\\n            for(int j=i+1;j<nums.length;j++){\\n                        sum+=nums[j];\\n                if(sum>maxSum){\\n                    maxSum=sum;\\n                }\\n            }\\n            sum=0;\\n        }\\n        return (nums[i]>maxSum)?nums[i]:maxSum;\\n    }\\n} "
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation checks the sum of all subarrays in the array and it is not efficient as it runs in O(n^2) time complexity. A better way is to use Kadane\\'s algorithm as mentioned before.\\n\\nIn addition, your current approach uses `maxSum=0` as a starting value, which means it will not work correctly if all numbers in the array are negative, because the maximum sum would be less than zero. \\n\\nInstead of starting `maxSum` at `0`, you should start it at the smallest possible integer value, `Integer.MIN_VALUE`, which guarantees that any sum of subarray will be larger than the initial `maxSum`. Here\\'s how you can modify your code:\\n\\n```java\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum = 0;\\n        int maxSum = Integer.MIN_VALUE;\\n        for(int i = 0; i < nums.length; i++){\\n            sum += nums[i];\\n            if(sum > maxSum){\\n                maxSum = sum;\\n            }\\n            if(sum < 0){\\n                sum = 0;\\n            }\\n        }\\n        return maxSum;\\n    }\\n}\\n```\\n\\nThis code initializes `maxSum` to `Integer.MIN_VALUE` and updates `maxSum` whenever `sum` is greater than `maxSum`. If `sum` becomes negative, it resets `sum` to `0` because no max subarray sum would include a negative sum."
                    },
                    {
                        "username": "pandeyjicoading",
                        "content": "i jumped to solve this problem right when i saw then suddenly i realised if i take it with brute force which is n3 the time complexity will throw me error then i decided to go for n2 but when i clicked on the discussion i saw that it could be done in On so now i am curius and wanna see that "
                    },
                    {
                        "username": "TechFreak107",
                        "content": "Is empty subarray not considered a subarray?\nThe array [-1] has two subarrays - [] and [-1] and the subarray with maximum sum is [ ] with the sum being 0. The solution shows the answer as -1. Any given array's maximum sum will always be >= 0."
                    }
                ]
            },
            {
                "id": 1732940,
                "content": [
                    {
                        "username": "wodxuming",
                        "content": "```\\n    int maxSubArray(vector<int>& nums) {\\n        const int size = nums.size();\\n        vector<int> dp(size, 0);        \\n        \\n        // dp[i+1] = dp[i] + max(nums[i+1],0) + min(0, nums[i])\\n        dp[0] = max(nums[0], 0);\\n        for(int i = 1; i < nums.size(); ++i) {\\n            dp[i] = dp[i-1] + max(nums[i-1], 0) + min(0, nums[i-1]);\\n        }\\n        \\n        return dp[size-1];\\n    }\\n```"
                    },
                    {
                        "username": "esnoopy888",
                        "content": "I think it\\'s worth mentioning that empty subarrays are not allowed in this problem"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 1ms || Beats 100% || Easy to Understand.\\n\\nhttps://leetcode.com/problems/maximum-subarray/solutions/2992938/simple-java-1ms-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "bitleakash6",
                        "content": "Here is my solution with O(n) tc but its wrong answer for one case that is {-1}.\\nif anyone know plz help me\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int maxsum = INT_MIN;\\n        int currsum = 0;\\n        \\n        for(int i = 0; i<nums.size(); i++){\\n            currsum += nums[i];\\n            \\n            if(currsum < 0){\\n                currsum = 0;\\n            }\\n            maxsum = max(maxsum, currsum);\\n        }\\n        return maxsum;\\n\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your solution is almost correct. The problem occurs when all the numbers in the array are negative. In this situation, your current implementation will return 0, because it resets `currsum` to 0 whenever `currsum` becomes negative. However, for an array of all negative numbers, the maximum subarray sum is the maximum (or least negative) number in the array.\\n\\nTo fix this, you should update `maxsum` before checking whether `currsum` is negative. Here is the corrected code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int maxsum = INT_MIN;\\n        int currsum = 0;\\n\\n        for(int i = 0; i<nums.size(); i++){\\n            currsum += nums[i];\\n            maxsum = max(maxsum, currsum);\\n\\n            if(currsum < 0){\\n                currsum = 0;\\n            }\\n        }\\n        return maxsum;\\n    }\\n};\\n```\\n\\nNow, `maxsum` is updated with the maximum sum found so far before `currsum` is reset to 0. This way, even if all numbers in the array are negative, `maxsum` will hold the maximum (least negative) number."
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "In the description you only mention the divide and conquer solution to be more subtle, not that it **will** be slower. I spent some extra time implementing it, only to finally look at the official solution, where you explain it\\'s slower. \\n\\nI did learn a lot anyways. Great problem!"
                    },
                    {
                        "username": "Pawan-choudhary",
                        "content": "Hey why it's not working\n\n\n\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n\n\n\n        max_sum = -float('inf')\n        sum_ = 0\n        start = 0\n        end = len(nums)-1\n        prefix_sum = [nums[0]]\n        for i in range(1,len(nums)):\n            prefix_sum.append(nums[i] + prefix_sum[-1])\n        for start in range(len(nums)):\n            if start==0:\n                sum_ = prefix_sum[end]\n            else:\n                sum_ = prefix_sum[end] - prefix_sum[start-1]\n\n            if sum_ > max_sum:\n                max_sum = sum_\n        return max_sum                \n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation does not correctly solve the problem, because it only calculates the sum from the beginning of the array to an `end` index, and it does not consider all possible subarrays. \\n\\nIn other words, your current implementation only calculates the prefix sum of the array and returns the maximum prefix sum. This is not the same as finding the maximum sum of any subarray, which could start and end anywhere in the array. \\n\\nFor example, consider the array `[-2,1,-3,4,-1,2,1,-5,4]`. The maximum sum of any subarray is `6`, from the subarray `[4,-1,2,1]`. However, your current implementation would return `7`, which is the sum of the entire array from the beginning to the second-to-last element.\\n\\nTo solve this problem, you could use Kadane\\'s algorithm, which involves keeping track of the current subarray sum and the maximum subarray sum seen so far:\\n\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        max_sum = nums[0]\\n        curr_sum = nums[0]\\n        for num in nums[1:]:\\n            curr_sum = max(num, curr_sum + num)\\n            max_sum = max(max_sum, curr_sum)\\n        return max_sum\\n```\\n\\nThis algorithm works by iterating through the array, and at each step, it decides whether to add the current element to the previous subarray or start a new subarray from the current element. It also keeps track of the maximum subarray sum seen so far."
                    },
                    {
                        "username": "RishabhParihar",
                        "content": "I have assigned max sum as the first value of the array. But as soon as the value is -ve, my code does not take the next +ve element as the largest value.\nCan someone help?\n\n// c_sum = current sum\n// max_sum = maximum sum\n\nclass Solution \n{\n    public int maxSubArray(int[] nums) \n    {\n       \n        int max_sum = nums[0];\n        int c_sum = nums[0];\n        for(int i=1;i<nums.length;i++)\n        {\n            \n            c_sum = c_sum + nums[i];\n\n            if(c_sum > max_sum)\n            {\n                max_sum = c_sum;\n            }\n\n            if(c_sum < 0)\n            {\n                c_sum = 0;\n            }\n\n        }\n        return max_sum;\n    }\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation is almost correct. However, the order of your conditions is causing the code to not consider a positive number immediately after the `c_sum` becomes negative. \\n\\nIn your implementation, you\\'re adding `nums[i]` to `c_sum` and then checking if `c_sum` is greater than `max_sum`. If `c_sum` becomes negative after the addition, you\\'re resetting `c_sum` to 0. But in the next iteration, you\\'re still adding `nums[i]` to `c_sum` before checking if `c_sum` is negative, which could cause you to miss a positive number.\\n\\nYou should first check if `c_sum` is negative, reset it if necessary, and then add `nums[i]` to `c_sum`. Here is the corrected code:\\n\\n```java\\nclass Solution\\n{\\n    public int maxSubArray(int[] nums)\\n    {\\n        int max_sum = nums[0];\\n        int c_sum = 0;\\n\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            if(c_sum < 0)\\n            {\\n                c_sum = 0;\\n            }\\n\\n            c_sum = c_sum + nums[i];\\n\\n            if(c_sum > max_sum)\\n            {\\n                max_sum = c_sum;\\n            }\\n        }\\n        return max_sum;\\n    }\\n}\\n```\\nNow, you\\'re correctly considering every positive number in the array. Also, by setting `c_sum = 0` before the loop, you no longer need to initialize `c_sum` to `nums[0]`, which makes the code slightly more efficient."
                    },
                    {
                        "username": "Sexy_Shreyansh",
                        "content": "Can someone help me with this. My code is working fine but consider a case of [-2,-1]. Since my maxSum is set to 0. My output is coming 0 instead of-1. How should I modify my code? \\n \\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum=0,maxSum=0, i=0;\\n            if(nums.length==1) return nums[0];\\n        for( i=0;i<nums.length-1;i++){\\n                sum+=nums[i];\\n            for(int j=i+1;j<nums.length;j++){\\n                        sum+=nums[j];\\n                if(sum>maxSum){\\n                    maxSum=sum;\\n                }\\n            }\\n            sum=0;\\n        }\\n        return (nums[i]>maxSum)?nums[i]:maxSum;\\n    }\\n} "
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation checks the sum of all subarrays in the array and it is not efficient as it runs in O(n^2) time complexity. A better way is to use Kadane\\'s algorithm as mentioned before.\\n\\nIn addition, your current approach uses `maxSum=0` as a starting value, which means it will not work correctly if all numbers in the array are negative, because the maximum sum would be less than zero. \\n\\nInstead of starting `maxSum` at `0`, you should start it at the smallest possible integer value, `Integer.MIN_VALUE`, which guarantees that any sum of subarray will be larger than the initial `maxSum`. Here\\'s how you can modify your code:\\n\\n```java\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum = 0;\\n        int maxSum = Integer.MIN_VALUE;\\n        for(int i = 0; i < nums.length; i++){\\n            sum += nums[i];\\n            if(sum > maxSum){\\n                maxSum = sum;\\n            }\\n            if(sum < 0){\\n                sum = 0;\\n            }\\n        }\\n        return maxSum;\\n    }\\n}\\n```\\n\\nThis code initializes `maxSum` to `Integer.MIN_VALUE` and updates `maxSum` whenever `sum` is greater than `maxSum`. If `sum` becomes negative, it resets `sum` to `0` because no max subarray sum would include a negative sum."
                    },
                    {
                        "username": "pandeyjicoading",
                        "content": "i jumped to solve this problem right when i saw then suddenly i realised if i take it with brute force which is n3 the time complexity will throw me error then i decided to go for n2 but when i clicked on the discussion i saw that it could be done in On so now i am curius and wanna see that "
                    },
                    {
                        "username": "TechFreak107",
                        "content": "Is empty subarray not considered a subarray?\nThe array [-1] has two subarrays - [] and [-1] and the subarray with maximum sum is [ ] with the sum being 0. The solution shows the answer as -1. Any given array's maximum sum will always be >= 0."
                    }
                ]
            },
            {
                "id": 1732126,
                "content": [
                    {
                        "username": "wodxuming",
                        "content": "```\\n    int maxSubArray(vector<int>& nums) {\\n        const int size = nums.size();\\n        vector<int> dp(size, 0);        \\n        \\n        // dp[i+1] = dp[i] + max(nums[i+1],0) + min(0, nums[i])\\n        dp[0] = max(nums[0], 0);\\n        for(int i = 1; i < nums.size(); ++i) {\\n            dp[i] = dp[i-1] + max(nums[i-1], 0) + min(0, nums[i-1]);\\n        }\\n        \\n        return dp[size-1];\\n    }\\n```"
                    },
                    {
                        "username": "esnoopy888",
                        "content": "I think it\\'s worth mentioning that empty subarrays are not allowed in this problem"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 1ms || Beats 100% || Easy to Understand.\\n\\nhttps://leetcode.com/problems/maximum-subarray/solutions/2992938/simple-java-1ms-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "bitleakash6",
                        "content": "Here is my solution with O(n) tc but its wrong answer for one case that is {-1}.\\nif anyone know plz help me\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int maxsum = INT_MIN;\\n        int currsum = 0;\\n        \\n        for(int i = 0; i<nums.size(); i++){\\n            currsum += nums[i];\\n            \\n            if(currsum < 0){\\n                currsum = 0;\\n            }\\n            maxsum = max(maxsum, currsum);\\n        }\\n        return maxsum;\\n\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your solution is almost correct. The problem occurs when all the numbers in the array are negative. In this situation, your current implementation will return 0, because it resets `currsum` to 0 whenever `currsum` becomes negative. However, for an array of all negative numbers, the maximum subarray sum is the maximum (or least negative) number in the array.\\n\\nTo fix this, you should update `maxsum` before checking whether `currsum` is negative. Here is the corrected code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int maxsum = INT_MIN;\\n        int currsum = 0;\\n\\n        for(int i = 0; i<nums.size(); i++){\\n            currsum += nums[i];\\n            maxsum = max(maxsum, currsum);\\n\\n            if(currsum < 0){\\n                currsum = 0;\\n            }\\n        }\\n        return maxsum;\\n    }\\n};\\n```\\n\\nNow, `maxsum` is updated with the maximum sum found so far before `currsum` is reset to 0. This way, even if all numbers in the array are negative, `maxsum` will hold the maximum (least negative) number."
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "In the description you only mention the divide and conquer solution to be more subtle, not that it **will** be slower. I spent some extra time implementing it, only to finally look at the official solution, where you explain it\\'s slower. \\n\\nI did learn a lot anyways. Great problem!"
                    },
                    {
                        "username": "Pawan-choudhary",
                        "content": "Hey why it's not working\n\n\n\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n\n\n\n        max_sum = -float('inf')\n        sum_ = 0\n        start = 0\n        end = len(nums)-1\n        prefix_sum = [nums[0]]\n        for i in range(1,len(nums)):\n            prefix_sum.append(nums[i] + prefix_sum[-1])\n        for start in range(len(nums)):\n            if start==0:\n                sum_ = prefix_sum[end]\n            else:\n                sum_ = prefix_sum[end] - prefix_sum[start-1]\n\n            if sum_ > max_sum:\n                max_sum = sum_\n        return max_sum                \n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation does not correctly solve the problem, because it only calculates the sum from the beginning of the array to an `end` index, and it does not consider all possible subarrays. \\n\\nIn other words, your current implementation only calculates the prefix sum of the array and returns the maximum prefix sum. This is not the same as finding the maximum sum of any subarray, which could start and end anywhere in the array. \\n\\nFor example, consider the array `[-2,1,-3,4,-1,2,1,-5,4]`. The maximum sum of any subarray is `6`, from the subarray `[4,-1,2,1]`. However, your current implementation would return `7`, which is the sum of the entire array from the beginning to the second-to-last element.\\n\\nTo solve this problem, you could use Kadane\\'s algorithm, which involves keeping track of the current subarray sum and the maximum subarray sum seen so far:\\n\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        max_sum = nums[0]\\n        curr_sum = nums[0]\\n        for num in nums[1:]:\\n            curr_sum = max(num, curr_sum + num)\\n            max_sum = max(max_sum, curr_sum)\\n        return max_sum\\n```\\n\\nThis algorithm works by iterating through the array, and at each step, it decides whether to add the current element to the previous subarray or start a new subarray from the current element. It also keeps track of the maximum subarray sum seen so far."
                    },
                    {
                        "username": "RishabhParihar",
                        "content": "I have assigned max sum as the first value of the array. But as soon as the value is -ve, my code does not take the next +ve element as the largest value.\nCan someone help?\n\n// c_sum = current sum\n// max_sum = maximum sum\n\nclass Solution \n{\n    public int maxSubArray(int[] nums) \n    {\n       \n        int max_sum = nums[0];\n        int c_sum = nums[0];\n        for(int i=1;i<nums.length;i++)\n        {\n            \n            c_sum = c_sum + nums[i];\n\n            if(c_sum > max_sum)\n            {\n                max_sum = c_sum;\n            }\n\n            if(c_sum < 0)\n            {\n                c_sum = 0;\n            }\n\n        }\n        return max_sum;\n    }\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation is almost correct. However, the order of your conditions is causing the code to not consider a positive number immediately after the `c_sum` becomes negative. \\n\\nIn your implementation, you\\'re adding `nums[i]` to `c_sum` and then checking if `c_sum` is greater than `max_sum`. If `c_sum` becomes negative after the addition, you\\'re resetting `c_sum` to 0. But in the next iteration, you\\'re still adding `nums[i]` to `c_sum` before checking if `c_sum` is negative, which could cause you to miss a positive number.\\n\\nYou should first check if `c_sum` is negative, reset it if necessary, and then add `nums[i]` to `c_sum`. Here is the corrected code:\\n\\n```java\\nclass Solution\\n{\\n    public int maxSubArray(int[] nums)\\n    {\\n        int max_sum = nums[0];\\n        int c_sum = 0;\\n\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            if(c_sum < 0)\\n            {\\n                c_sum = 0;\\n            }\\n\\n            c_sum = c_sum + nums[i];\\n\\n            if(c_sum > max_sum)\\n            {\\n                max_sum = c_sum;\\n            }\\n        }\\n        return max_sum;\\n    }\\n}\\n```\\nNow, you\\'re correctly considering every positive number in the array. Also, by setting `c_sum = 0` before the loop, you no longer need to initialize `c_sum` to `nums[0]`, which makes the code slightly more efficient."
                    },
                    {
                        "username": "Sexy_Shreyansh",
                        "content": "Can someone help me with this. My code is working fine but consider a case of [-2,-1]. Since my maxSum is set to 0. My output is coming 0 instead of-1. How should I modify my code? \\n \\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum=0,maxSum=0, i=0;\\n            if(nums.length==1) return nums[0];\\n        for( i=0;i<nums.length-1;i++){\\n                sum+=nums[i];\\n            for(int j=i+1;j<nums.length;j++){\\n                        sum+=nums[j];\\n                if(sum>maxSum){\\n                    maxSum=sum;\\n                }\\n            }\\n            sum=0;\\n        }\\n        return (nums[i]>maxSum)?nums[i]:maxSum;\\n    }\\n} "
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation checks the sum of all subarrays in the array and it is not efficient as it runs in O(n^2) time complexity. A better way is to use Kadane\\'s algorithm as mentioned before.\\n\\nIn addition, your current approach uses `maxSum=0` as a starting value, which means it will not work correctly if all numbers in the array are negative, because the maximum sum would be less than zero. \\n\\nInstead of starting `maxSum` at `0`, you should start it at the smallest possible integer value, `Integer.MIN_VALUE`, which guarantees that any sum of subarray will be larger than the initial `maxSum`. Here\\'s how you can modify your code:\\n\\n```java\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum = 0;\\n        int maxSum = Integer.MIN_VALUE;\\n        for(int i = 0; i < nums.length; i++){\\n            sum += nums[i];\\n            if(sum > maxSum){\\n                maxSum = sum;\\n            }\\n            if(sum < 0){\\n                sum = 0;\\n            }\\n        }\\n        return maxSum;\\n    }\\n}\\n```\\n\\nThis code initializes `maxSum` to `Integer.MIN_VALUE` and updates `maxSum` whenever `sum` is greater than `maxSum`. If `sum` becomes negative, it resets `sum` to `0` because no max subarray sum would include a negative sum."
                    },
                    {
                        "username": "pandeyjicoading",
                        "content": "i jumped to solve this problem right when i saw then suddenly i realised if i take it with brute force which is n3 the time complexity will throw me error then i decided to go for n2 but when i clicked on the discussion i saw that it could be done in On so now i am curius and wanna see that "
                    },
                    {
                        "username": "TechFreak107",
                        "content": "Is empty subarray not considered a subarray?\nThe array [-1] has two subarrays - [] and [-1] and the subarray with maximum sum is [ ] with the sum being 0. The solution shows the answer as -1. Any given array's maximum sum will always be >= 0."
                    }
                ]
            },
            {
                "id": 1731229,
                "content": [
                    {
                        "username": "wodxuming",
                        "content": "```\\n    int maxSubArray(vector<int>& nums) {\\n        const int size = nums.size();\\n        vector<int> dp(size, 0);        \\n        \\n        // dp[i+1] = dp[i] + max(nums[i+1],0) + min(0, nums[i])\\n        dp[0] = max(nums[0], 0);\\n        for(int i = 1; i < nums.size(); ++i) {\\n            dp[i] = dp[i-1] + max(nums[i-1], 0) + min(0, nums[i-1]);\\n        }\\n        \\n        return dp[size-1];\\n    }\\n```"
                    },
                    {
                        "username": "esnoopy888",
                        "content": "I think it\\'s worth mentioning that empty subarrays are not allowed in this problem"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 1ms || Beats 100% || Easy to Understand.\\n\\nhttps://leetcode.com/problems/maximum-subarray/solutions/2992938/simple-java-1ms-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "bitleakash6",
                        "content": "Here is my solution with O(n) tc but its wrong answer for one case that is {-1}.\\nif anyone know plz help me\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int maxsum = INT_MIN;\\n        int currsum = 0;\\n        \\n        for(int i = 0; i<nums.size(); i++){\\n            currsum += nums[i];\\n            \\n            if(currsum < 0){\\n                currsum = 0;\\n            }\\n            maxsum = max(maxsum, currsum);\\n        }\\n        return maxsum;\\n\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your solution is almost correct. The problem occurs when all the numbers in the array are negative. In this situation, your current implementation will return 0, because it resets `currsum` to 0 whenever `currsum` becomes negative. However, for an array of all negative numbers, the maximum subarray sum is the maximum (or least negative) number in the array.\\n\\nTo fix this, you should update `maxsum` before checking whether `currsum` is negative. Here is the corrected code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int maxsum = INT_MIN;\\n        int currsum = 0;\\n\\n        for(int i = 0; i<nums.size(); i++){\\n            currsum += nums[i];\\n            maxsum = max(maxsum, currsum);\\n\\n            if(currsum < 0){\\n                currsum = 0;\\n            }\\n        }\\n        return maxsum;\\n    }\\n};\\n```\\n\\nNow, `maxsum` is updated with the maximum sum found so far before `currsum` is reset to 0. This way, even if all numbers in the array are negative, `maxsum` will hold the maximum (least negative) number."
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "In the description you only mention the divide and conquer solution to be more subtle, not that it **will** be slower. I spent some extra time implementing it, only to finally look at the official solution, where you explain it\\'s slower. \\n\\nI did learn a lot anyways. Great problem!"
                    },
                    {
                        "username": "Pawan-choudhary",
                        "content": "Hey why it's not working\n\n\n\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n\n\n\n        max_sum = -float('inf')\n        sum_ = 0\n        start = 0\n        end = len(nums)-1\n        prefix_sum = [nums[0]]\n        for i in range(1,len(nums)):\n            prefix_sum.append(nums[i] + prefix_sum[-1])\n        for start in range(len(nums)):\n            if start==0:\n                sum_ = prefix_sum[end]\n            else:\n                sum_ = prefix_sum[end] - prefix_sum[start-1]\n\n            if sum_ > max_sum:\n                max_sum = sum_\n        return max_sum                \n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation does not correctly solve the problem, because it only calculates the sum from the beginning of the array to an `end` index, and it does not consider all possible subarrays. \\n\\nIn other words, your current implementation only calculates the prefix sum of the array and returns the maximum prefix sum. This is not the same as finding the maximum sum of any subarray, which could start and end anywhere in the array. \\n\\nFor example, consider the array `[-2,1,-3,4,-1,2,1,-5,4]`. The maximum sum of any subarray is `6`, from the subarray `[4,-1,2,1]`. However, your current implementation would return `7`, which is the sum of the entire array from the beginning to the second-to-last element.\\n\\nTo solve this problem, you could use Kadane\\'s algorithm, which involves keeping track of the current subarray sum and the maximum subarray sum seen so far:\\n\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        max_sum = nums[0]\\n        curr_sum = nums[0]\\n        for num in nums[1:]:\\n            curr_sum = max(num, curr_sum + num)\\n            max_sum = max(max_sum, curr_sum)\\n        return max_sum\\n```\\n\\nThis algorithm works by iterating through the array, and at each step, it decides whether to add the current element to the previous subarray or start a new subarray from the current element. It also keeps track of the maximum subarray sum seen so far."
                    },
                    {
                        "username": "RishabhParihar",
                        "content": "I have assigned max sum as the first value of the array. But as soon as the value is -ve, my code does not take the next +ve element as the largest value.\nCan someone help?\n\n// c_sum = current sum\n// max_sum = maximum sum\n\nclass Solution \n{\n    public int maxSubArray(int[] nums) \n    {\n       \n        int max_sum = nums[0];\n        int c_sum = nums[0];\n        for(int i=1;i<nums.length;i++)\n        {\n            \n            c_sum = c_sum + nums[i];\n\n            if(c_sum > max_sum)\n            {\n                max_sum = c_sum;\n            }\n\n            if(c_sum < 0)\n            {\n                c_sum = 0;\n            }\n\n        }\n        return max_sum;\n    }\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation is almost correct. However, the order of your conditions is causing the code to not consider a positive number immediately after the `c_sum` becomes negative. \\n\\nIn your implementation, you\\'re adding `nums[i]` to `c_sum` and then checking if `c_sum` is greater than `max_sum`. If `c_sum` becomes negative after the addition, you\\'re resetting `c_sum` to 0. But in the next iteration, you\\'re still adding `nums[i]` to `c_sum` before checking if `c_sum` is negative, which could cause you to miss a positive number.\\n\\nYou should first check if `c_sum` is negative, reset it if necessary, and then add `nums[i]` to `c_sum`. Here is the corrected code:\\n\\n```java\\nclass Solution\\n{\\n    public int maxSubArray(int[] nums)\\n    {\\n        int max_sum = nums[0];\\n        int c_sum = 0;\\n\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            if(c_sum < 0)\\n            {\\n                c_sum = 0;\\n            }\\n\\n            c_sum = c_sum + nums[i];\\n\\n            if(c_sum > max_sum)\\n            {\\n                max_sum = c_sum;\\n            }\\n        }\\n        return max_sum;\\n    }\\n}\\n```\\nNow, you\\'re correctly considering every positive number in the array. Also, by setting `c_sum = 0` before the loop, you no longer need to initialize `c_sum` to `nums[0]`, which makes the code slightly more efficient."
                    },
                    {
                        "username": "Sexy_Shreyansh",
                        "content": "Can someone help me with this. My code is working fine but consider a case of [-2,-1]. Since my maxSum is set to 0. My output is coming 0 instead of-1. How should I modify my code? \\n \\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum=0,maxSum=0, i=0;\\n            if(nums.length==1) return nums[0];\\n        for( i=0;i<nums.length-1;i++){\\n                sum+=nums[i];\\n            for(int j=i+1;j<nums.length;j++){\\n                        sum+=nums[j];\\n                if(sum>maxSum){\\n                    maxSum=sum;\\n                }\\n            }\\n            sum=0;\\n        }\\n        return (nums[i]>maxSum)?nums[i]:maxSum;\\n    }\\n} "
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation checks the sum of all subarrays in the array and it is not efficient as it runs in O(n^2) time complexity. A better way is to use Kadane\\'s algorithm as mentioned before.\\n\\nIn addition, your current approach uses `maxSum=0` as a starting value, which means it will not work correctly if all numbers in the array are negative, because the maximum sum would be less than zero. \\n\\nInstead of starting `maxSum` at `0`, you should start it at the smallest possible integer value, `Integer.MIN_VALUE`, which guarantees that any sum of subarray will be larger than the initial `maxSum`. Here\\'s how you can modify your code:\\n\\n```java\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum = 0;\\n        int maxSum = Integer.MIN_VALUE;\\n        for(int i = 0; i < nums.length; i++){\\n            sum += nums[i];\\n            if(sum > maxSum){\\n                maxSum = sum;\\n            }\\n            if(sum < 0){\\n                sum = 0;\\n            }\\n        }\\n        return maxSum;\\n    }\\n}\\n```\\n\\nThis code initializes `maxSum` to `Integer.MIN_VALUE` and updates `maxSum` whenever `sum` is greater than `maxSum`. If `sum` becomes negative, it resets `sum` to `0` because no max subarray sum would include a negative sum."
                    },
                    {
                        "username": "pandeyjicoading",
                        "content": "i jumped to solve this problem right when i saw then suddenly i realised if i take it with brute force which is n3 the time complexity will throw me error then i decided to go for n2 but when i clicked on the discussion i saw that it could be done in On so now i am curius and wanna see that "
                    },
                    {
                        "username": "TechFreak107",
                        "content": "Is empty subarray not considered a subarray?\nThe array [-1] has two subarrays - [] and [-1] and the subarray with maximum sum is [ ] with the sum being 0. The solution shows the answer as -1. Any given array's maximum sum will always be >= 0."
                    }
                ]
            },
            {
                "id": 1729317,
                "content": [
                    {
                        "username": "wodxuming",
                        "content": "```\\n    int maxSubArray(vector<int>& nums) {\\n        const int size = nums.size();\\n        vector<int> dp(size, 0);        \\n        \\n        // dp[i+1] = dp[i] + max(nums[i+1],0) + min(0, nums[i])\\n        dp[0] = max(nums[0], 0);\\n        for(int i = 1; i < nums.size(); ++i) {\\n            dp[i] = dp[i-1] + max(nums[i-1], 0) + min(0, nums[i-1]);\\n        }\\n        \\n        return dp[size-1];\\n    }\\n```"
                    },
                    {
                        "username": "esnoopy888",
                        "content": "I think it\\'s worth mentioning that empty subarrays are not allowed in this problem"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 1ms || Beats 100% || Easy to Understand.\\n\\nhttps://leetcode.com/problems/maximum-subarray/solutions/2992938/simple-java-1ms-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "bitleakash6",
                        "content": "Here is my solution with O(n) tc but its wrong answer for one case that is {-1}.\\nif anyone know plz help me\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int maxsum = INT_MIN;\\n        int currsum = 0;\\n        \\n        for(int i = 0; i<nums.size(); i++){\\n            currsum += nums[i];\\n            \\n            if(currsum < 0){\\n                currsum = 0;\\n            }\\n            maxsum = max(maxsum, currsum);\\n        }\\n        return maxsum;\\n\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your solution is almost correct. The problem occurs when all the numbers in the array are negative. In this situation, your current implementation will return 0, because it resets `currsum` to 0 whenever `currsum` becomes negative. However, for an array of all negative numbers, the maximum subarray sum is the maximum (or least negative) number in the array.\\n\\nTo fix this, you should update `maxsum` before checking whether `currsum` is negative. Here is the corrected code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int maxsum = INT_MIN;\\n        int currsum = 0;\\n\\n        for(int i = 0; i<nums.size(); i++){\\n            currsum += nums[i];\\n            maxsum = max(maxsum, currsum);\\n\\n            if(currsum < 0){\\n                currsum = 0;\\n            }\\n        }\\n        return maxsum;\\n    }\\n};\\n```\\n\\nNow, `maxsum` is updated with the maximum sum found so far before `currsum` is reset to 0. This way, even if all numbers in the array are negative, `maxsum` will hold the maximum (least negative) number."
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "In the description you only mention the divide and conquer solution to be more subtle, not that it **will** be slower. I spent some extra time implementing it, only to finally look at the official solution, where you explain it\\'s slower. \\n\\nI did learn a lot anyways. Great problem!"
                    },
                    {
                        "username": "Pawan-choudhary",
                        "content": "Hey why it's not working\n\n\n\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n\n\n\n        max_sum = -float('inf')\n        sum_ = 0\n        start = 0\n        end = len(nums)-1\n        prefix_sum = [nums[0]]\n        for i in range(1,len(nums)):\n            prefix_sum.append(nums[i] + prefix_sum[-1])\n        for start in range(len(nums)):\n            if start==0:\n                sum_ = prefix_sum[end]\n            else:\n                sum_ = prefix_sum[end] - prefix_sum[start-1]\n\n            if sum_ > max_sum:\n                max_sum = sum_\n        return max_sum                \n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation does not correctly solve the problem, because it only calculates the sum from the beginning of the array to an `end` index, and it does not consider all possible subarrays. \\n\\nIn other words, your current implementation only calculates the prefix sum of the array and returns the maximum prefix sum. This is not the same as finding the maximum sum of any subarray, which could start and end anywhere in the array. \\n\\nFor example, consider the array `[-2,1,-3,4,-1,2,1,-5,4]`. The maximum sum of any subarray is `6`, from the subarray `[4,-1,2,1]`. However, your current implementation would return `7`, which is the sum of the entire array from the beginning to the second-to-last element.\\n\\nTo solve this problem, you could use Kadane\\'s algorithm, which involves keeping track of the current subarray sum and the maximum subarray sum seen so far:\\n\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        max_sum = nums[0]\\n        curr_sum = nums[0]\\n        for num in nums[1:]:\\n            curr_sum = max(num, curr_sum + num)\\n            max_sum = max(max_sum, curr_sum)\\n        return max_sum\\n```\\n\\nThis algorithm works by iterating through the array, and at each step, it decides whether to add the current element to the previous subarray or start a new subarray from the current element. It also keeps track of the maximum subarray sum seen so far."
                    },
                    {
                        "username": "RishabhParihar",
                        "content": "I have assigned max sum as the first value of the array. But as soon as the value is -ve, my code does not take the next +ve element as the largest value.\nCan someone help?\n\n// c_sum = current sum\n// max_sum = maximum sum\n\nclass Solution \n{\n    public int maxSubArray(int[] nums) \n    {\n       \n        int max_sum = nums[0];\n        int c_sum = nums[0];\n        for(int i=1;i<nums.length;i++)\n        {\n            \n            c_sum = c_sum + nums[i];\n\n            if(c_sum > max_sum)\n            {\n                max_sum = c_sum;\n            }\n\n            if(c_sum < 0)\n            {\n                c_sum = 0;\n            }\n\n        }\n        return max_sum;\n    }\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation is almost correct. However, the order of your conditions is causing the code to not consider a positive number immediately after the `c_sum` becomes negative. \\n\\nIn your implementation, you\\'re adding `nums[i]` to `c_sum` and then checking if `c_sum` is greater than `max_sum`. If `c_sum` becomes negative after the addition, you\\'re resetting `c_sum` to 0. But in the next iteration, you\\'re still adding `nums[i]` to `c_sum` before checking if `c_sum` is negative, which could cause you to miss a positive number.\\n\\nYou should first check if `c_sum` is negative, reset it if necessary, and then add `nums[i]` to `c_sum`. Here is the corrected code:\\n\\n```java\\nclass Solution\\n{\\n    public int maxSubArray(int[] nums)\\n    {\\n        int max_sum = nums[0];\\n        int c_sum = 0;\\n\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            if(c_sum < 0)\\n            {\\n                c_sum = 0;\\n            }\\n\\n            c_sum = c_sum + nums[i];\\n\\n            if(c_sum > max_sum)\\n            {\\n                max_sum = c_sum;\\n            }\\n        }\\n        return max_sum;\\n    }\\n}\\n```\\nNow, you\\'re correctly considering every positive number in the array. Also, by setting `c_sum = 0` before the loop, you no longer need to initialize `c_sum` to `nums[0]`, which makes the code slightly more efficient."
                    },
                    {
                        "username": "Sexy_Shreyansh",
                        "content": "Can someone help me with this. My code is working fine but consider a case of [-2,-1]. Since my maxSum is set to 0. My output is coming 0 instead of-1. How should I modify my code? \\n \\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum=0,maxSum=0, i=0;\\n            if(nums.length==1) return nums[0];\\n        for( i=0;i<nums.length-1;i++){\\n                sum+=nums[i];\\n            for(int j=i+1;j<nums.length;j++){\\n                        sum+=nums[j];\\n                if(sum>maxSum){\\n                    maxSum=sum;\\n                }\\n            }\\n            sum=0;\\n        }\\n        return (nums[i]>maxSum)?nums[i]:maxSum;\\n    }\\n} "
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation checks the sum of all subarrays in the array and it is not efficient as it runs in O(n^2) time complexity. A better way is to use Kadane\\'s algorithm as mentioned before.\\n\\nIn addition, your current approach uses `maxSum=0` as a starting value, which means it will not work correctly if all numbers in the array are negative, because the maximum sum would be less than zero. \\n\\nInstead of starting `maxSum` at `0`, you should start it at the smallest possible integer value, `Integer.MIN_VALUE`, which guarantees that any sum of subarray will be larger than the initial `maxSum`. Here\\'s how you can modify your code:\\n\\n```java\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum = 0;\\n        int maxSum = Integer.MIN_VALUE;\\n        for(int i = 0; i < nums.length; i++){\\n            sum += nums[i];\\n            if(sum > maxSum){\\n                maxSum = sum;\\n            }\\n            if(sum < 0){\\n                sum = 0;\\n            }\\n        }\\n        return maxSum;\\n    }\\n}\\n```\\n\\nThis code initializes `maxSum` to `Integer.MIN_VALUE` and updates `maxSum` whenever `sum` is greater than `maxSum`. If `sum` becomes negative, it resets `sum` to `0` because no max subarray sum would include a negative sum."
                    },
                    {
                        "username": "pandeyjicoading",
                        "content": "i jumped to solve this problem right when i saw then suddenly i realised if i take it with brute force which is n3 the time complexity will throw me error then i decided to go for n2 but when i clicked on the discussion i saw that it could be done in On so now i am curius and wanna see that "
                    },
                    {
                        "username": "TechFreak107",
                        "content": "Is empty subarray not considered a subarray?\nThe array [-1] has two subarrays - [] and [-1] and the subarray with maximum sum is [ ] with the sum being 0. The solution shows the answer as -1. Any given array's maximum sum will always be >= 0."
                    }
                ]
            },
            {
                "id": 1726426,
                "content": [
                    {
                        "username": "wodxuming",
                        "content": "```\\n    int maxSubArray(vector<int>& nums) {\\n        const int size = nums.size();\\n        vector<int> dp(size, 0);        \\n        \\n        // dp[i+1] = dp[i] + max(nums[i+1],0) + min(0, nums[i])\\n        dp[0] = max(nums[0], 0);\\n        for(int i = 1; i < nums.size(); ++i) {\\n            dp[i] = dp[i-1] + max(nums[i-1], 0) + min(0, nums[i-1]);\\n        }\\n        \\n        return dp[size-1];\\n    }\\n```"
                    },
                    {
                        "username": "esnoopy888",
                        "content": "I think it\\'s worth mentioning that empty subarrays are not allowed in this problem"
                    },
                    {
                        "username": "Pratik-Shrivastava",
                        "content": "\\u2705Simple || Java || 1ms || Beats 100% || Easy to Understand.\\n\\nhttps://leetcode.com/problems/maximum-subarray/solutions/2992938/simple-java-1ms-beats-100-easy-to-understand/"
                    },
                    {
                        "username": "bitleakash6",
                        "content": "Here is my solution with O(n) tc but its wrong answer for one case that is {-1}.\\nif anyone know plz help me\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int maxsum = INT_MIN;\\n        int currsum = 0;\\n        \\n        for(int i = 0; i<nums.size(); i++){\\n            currsum += nums[i];\\n            \\n            if(currsum < 0){\\n                currsum = 0;\\n            }\\n            maxsum = max(maxsum, currsum);\\n        }\\n        return maxsum;\\n\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your solution is almost correct. The problem occurs when all the numbers in the array are negative. In this situation, your current implementation will return 0, because it resets `currsum` to 0 whenever `currsum` becomes negative. However, for an array of all negative numbers, the maximum subarray sum is the maximum (or least negative) number in the array.\\n\\nTo fix this, you should update `maxsum` before checking whether `currsum` is negative. Here is the corrected code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n        int maxsum = INT_MIN;\\n        int currsum = 0;\\n\\n        for(int i = 0; i<nums.size(); i++){\\n            currsum += nums[i];\\n            maxsum = max(maxsum, currsum);\\n\\n            if(currsum < 0){\\n                currsum = 0;\\n            }\\n        }\\n        return maxsum;\\n    }\\n};\\n```\\n\\nNow, `maxsum` is updated with the maximum sum found so far before `currsum` is reset to 0. This way, even if all numbers in the array are negative, `maxsum` will hold the maximum (least negative) number."
                    },
                    {
                        "username": "NeonRayTracer",
                        "content": "In the description you only mention the divide and conquer solution to be more subtle, not that it **will** be slower. I spent some extra time implementing it, only to finally look at the official solution, where you explain it\\'s slower. \\n\\nI did learn a lot anyways. Great problem!"
                    },
                    {
                        "username": "Pawan-choudhary",
                        "content": "Hey why it's not working\n\n\n\nclass Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n\n\n\n        max_sum = -float('inf')\n        sum_ = 0\n        start = 0\n        end = len(nums)-1\n        prefix_sum = [nums[0]]\n        for i in range(1,len(nums)):\n            prefix_sum.append(nums[i] + prefix_sum[-1])\n        for start in range(len(nums)):\n            if start==0:\n                sum_ = prefix_sum[end]\n            else:\n                sum_ = prefix_sum[end] - prefix_sum[start-1]\n\n            if sum_ > max_sum:\n                max_sum = sum_\n        return max_sum                \n\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation does not correctly solve the problem, because it only calculates the sum from the beginning of the array to an `end` index, and it does not consider all possible subarrays. \\n\\nIn other words, your current implementation only calculates the prefix sum of the array and returns the maximum prefix sum. This is not the same as finding the maximum sum of any subarray, which could start and end anywhere in the array. \\n\\nFor example, consider the array `[-2,1,-3,4,-1,2,1,-5,4]`. The maximum sum of any subarray is `6`, from the subarray `[4,-1,2,1]`. However, your current implementation would return `7`, which is the sum of the entire array from the beginning to the second-to-last element.\\n\\nTo solve this problem, you could use Kadane\\'s algorithm, which involves keeping track of the current subarray sum and the maximum subarray sum seen so far:\\n\\n```python\\nclass Solution:\\n    def maxSubArray(self, nums: List[int]) -> int:\\n        max_sum = nums[0]\\n        curr_sum = nums[0]\\n        for num in nums[1:]:\\n            curr_sum = max(num, curr_sum + num)\\n            max_sum = max(max_sum, curr_sum)\\n        return max_sum\\n```\\n\\nThis algorithm works by iterating through the array, and at each step, it decides whether to add the current element to the previous subarray or start a new subarray from the current element. It also keeps track of the maximum subarray sum seen so far."
                    },
                    {
                        "username": "RishabhParihar",
                        "content": "I have assigned max sum as the first value of the array. But as soon as the value is -ve, my code does not take the next +ve element as the largest value.\nCan someone help?\n\n// c_sum = current sum\n// max_sum = maximum sum\n\nclass Solution \n{\n    public int maxSubArray(int[] nums) \n    {\n       \n        int max_sum = nums[0];\n        int c_sum = nums[0];\n        for(int i=1;i<nums.length;i++)\n        {\n            \n            c_sum = c_sum + nums[i];\n\n            if(c_sum > max_sum)\n            {\n                max_sum = c_sum;\n            }\n\n            if(c_sum < 0)\n            {\n                c_sum = 0;\n            }\n\n        }\n        return max_sum;\n    }\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation is almost correct. However, the order of your conditions is causing the code to not consider a positive number immediately after the `c_sum` becomes negative. \\n\\nIn your implementation, you\\'re adding `nums[i]` to `c_sum` and then checking if `c_sum` is greater than `max_sum`. If `c_sum` becomes negative after the addition, you\\'re resetting `c_sum` to 0. But in the next iteration, you\\'re still adding `nums[i]` to `c_sum` before checking if `c_sum` is negative, which could cause you to miss a positive number.\\n\\nYou should first check if `c_sum` is negative, reset it if necessary, and then add `nums[i]` to `c_sum`. Here is the corrected code:\\n\\n```java\\nclass Solution\\n{\\n    public int maxSubArray(int[] nums)\\n    {\\n        int max_sum = nums[0];\\n        int c_sum = 0;\\n\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            if(c_sum < 0)\\n            {\\n                c_sum = 0;\\n            }\\n\\n            c_sum = c_sum + nums[i];\\n\\n            if(c_sum > max_sum)\\n            {\\n                max_sum = c_sum;\\n            }\\n        }\\n        return max_sum;\\n    }\\n}\\n```\\nNow, you\\'re correctly considering every positive number in the array. Also, by setting `c_sum = 0` before the loop, you no longer need to initialize `c_sum` to `nums[0]`, which makes the code slightly more efficient."
                    },
                    {
                        "username": "Sexy_Shreyansh",
                        "content": "Can someone help me with this. My code is working fine but consider a case of [-2,-1]. Since my maxSum is set to 0. My output is coming 0 instead of-1. How should I modify my code? \\n \\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum=0,maxSum=0, i=0;\\n            if(nums.length==1) return nums[0];\\n        for( i=0;i<nums.length-1;i++){\\n                sum+=nums[i];\\n            for(int j=i+1;j<nums.length;j++){\\n                        sum+=nums[j];\\n                if(sum>maxSum){\\n                    maxSum=sum;\\n                }\\n            }\\n            sum=0;\\n        }\\n        return (nums[i]>maxSum)?nums[i]:maxSum;\\n    }\\n} "
                    },
                    {
                        "username": "bparanj",
                        "content": "Your current implementation checks the sum of all subarrays in the array and it is not efficient as it runs in O(n^2) time complexity. A better way is to use Kadane\\'s algorithm as mentioned before.\\n\\nIn addition, your current approach uses `maxSum=0` as a starting value, which means it will not work correctly if all numbers in the array are negative, because the maximum sum would be less than zero. \\n\\nInstead of starting `maxSum` at `0`, you should start it at the smallest possible integer value, `Integer.MIN_VALUE`, which guarantees that any sum of subarray will be larger than the initial `maxSum`. Here\\'s how you can modify your code:\\n\\n```java\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum = 0;\\n        int maxSum = Integer.MIN_VALUE;\\n        for(int i = 0; i < nums.length; i++){\\n            sum += nums[i];\\n            if(sum > maxSum){\\n                maxSum = sum;\\n            }\\n            if(sum < 0){\\n                sum = 0;\\n            }\\n        }\\n        return maxSum;\\n    }\\n}\\n```\\n\\nThis code initializes `maxSum` to `Integer.MIN_VALUE` and updates `maxSum` whenever `sum` is greater than `maxSum`. If `sum` becomes negative, it resets `sum` to `0` because no max subarray sum would include a negative sum."
                    },
                    {
                        "username": "pandeyjicoading",
                        "content": "i jumped to solve this problem right when i saw then suddenly i realised if i take it with brute force which is n3 the time complexity will throw me error then i decided to go for n2 but when i clicked on the discussion i saw that it could be done in On so now i am curius and wanna see that "
                    },
                    {
                        "username": "TechFreak107",
                        "content": "Is empty subarray not considered a subarray?\nThe array [-1] has two subarrays - [] and [-1] and the subarray with maximum sum is [ ] with the sum being 0. The solution shows the answer as -1. Any given array's maximum sum will always be >= 0."
                    }
                ]
            },
            {
                "id": 1726360,
                "content": [
                    {
                        "username": "set_mik",
                        "content": "is a list of one element considered to be a subarray? E.g. for [-1, 100, -1] will a correct answer be sum([100])==100 or sum([-1,100])==99?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a list with just one element is considered a subarray. In your example, the subarray with the maximum sum would indeed be [100], which results in a sum of 100. \\n\\nThe term \"subarray\" just means a contiguous (i.e., unbroken, with no gaps) subset of the array. It doesn\\'t specify a minimum or maximum size. So a subarray could have as few as one element or as many as the entire array. \\n\\nSo in your example, both [100] and [-1, 100] are valid subarrays, but the one with the maximum sum is [100]."
                    },
                    {
                        "username": "sainiashish459",
                        "content": "divide and conquer\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    //[-2,1,-3,4,-1,2,1,-5,4]\\n    // 0, 1, 2, 3, 4, 5, 6\\n    // 0, 1,\\n    //\\n    //\\n    int maxSubArray(vector<int>& nums) {\\n        const int size = nums.size();\\n        vector<int> dp(size, 0);        \\n        // recrrence relation\\n        // dp[i+1] = dp[i] + max(nums[i+1],0) + min(0, nums[i])\\n        dp[0] = max(nums[0], 0);\\n        for(int i = 1; i < nums.size(); ++i) {\\n            dp[i] = dp[i-1] + max(nums[i-1], 0) + min(0, nums[i-1]);\\n        }\\n        \\n        return dp[size-1];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/53_max_subarray.cpp"
                    },
                    {
                        "username": "saurabh2003",
                        "content": "class Solution {\\npublic:\\n\\n    int maxSubArray(vector<int>& nums) {\\n       int  maxsum= INT_MIN;\\n\\n       int currsum=0;\\n\\n      for(int i=0;i<nums.size();i++)\\n\\n    {\\n\\n       currsum=currsum+nums[i];\\n\\n       if(currsum>maxsum)\\n\\n       {\\n\\n           maxsum=currsum;\\n\\n       }\\n\\n       if(currsum<0)\\n\\n       {\\n\\n           currsum=0;\\n\\n       }\\n\\n   }\\n\\n   return maxsum;\\n    }\\n  \\n\\n        \\n    \\n}; "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "There is no need to find the subarray we can just traverse the original array and find the maximum sum of any subpart. "
                    },
                    {
                        "username": "gitsejal",
                        "content": "This problem was really challenging . i hope i am not the only one?\\n"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "here is my simple iterative solution of o(n) time complexity :\\n\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int max_sum=INT_MIN ;\\n        int sum=0 ;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            if(sum<0){\\n              \\n                if(sum>max_sum){\\n                    max_sum=sum ;\\n\\n                }\\n                sum=0 ;\\n            }\\n            else if(sum>=0 and max_sum<sum){\\n                max_sum=sum;\\n            }\\n        }\\n        return max_sum ;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "pstrait",
                        "content": "I submitted the same solution three times in a row. One time it took 372ms, another 119ms, another 223ms.  The random variance is larger than the systemic variance--at this point, they probably shouldn't even measure runtime."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Kadane\\'s algorithm | Maximum subarray | O(n) complexity |\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum = 0;\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0; i < nums.length; i++){\\n            sum += nums[i];\\n            if(max < sum)\\n                max = sum;\\n            if(sum < 0)\\n                sum = 0;\\n        }\\n        return max;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1726268,
                "content": [
                    {
                        "username": "set_mik",
                        "content": "is a list of one element considered to be a subarray? E.g. for [-1, 100, -1] will a correct answer be sum([100])==100 or sum([-1,100])==99?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a list with just one element is considered a subarray. In your example, the subarray with the maximum sum would indeed be [100], which results in a sum of 100. \\n\\nThe term \"subarray\" just means a contiguous (i.e., unbroken, with no gaps) subset of the array. It doesn\\'t specify a minimum or maximum size. So a subarray could have as few as one element or as many as the entire array. \\n\\nSo in your example, both [100] and [-1, 100] are valid subarrays, but the one with the maximum sum is [100]."
                    },
                    {
                        "username": "sainiashish459",
                        "content": "divide and conquer\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    //[-2,1,-3,4,-1,2,1,-5,4]\\n    // 0, 1, 2, 3, 4, 5, 6\\n    // 0, 1,\\n    //\\n    //\\n    int maxSubArray(vector<int>& nums) {\\n        const int size = nums.size();\\n        vector<int> dp(size, 0);        \\n        // recrrence relation\\n        // dp[i+1] = dp[i] + max(nums[i+1],0) + min(0, nums[i])\\n        dp[0] = max(nums[0], 0);\\n        for(int i = 1; i < nums.size(); ++i) {\\n            dp[i] = dp[i-1] + max(nums[i-1], 0) + min(0, nums[i-1]);\\n        }\\n        \\n        return dp[size-1];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/53_max_subarray.cpp"
                    },
                    {
                        "username": "saurabh2003",
                        "content": "class Solution {\\npublic:\\n\\n    int maxSubArray(vector<int>& nums) {\\n       int  maxsum= INT_MIN;\\n\\n       int currsum=0;\\n\\n      for(int i=0;i<nums.size();i++)\\n\\n    {\\n\\n       currsum=currsum+nums[i];\\n\\n       if(currsum>maxsum)\\n\\n       {\\n\\n           maxsum=currsum;\\n\\n       }\\n\\n       if(currsum<0)\\n\\n       {\\n\\n           currsum=0;\\n\\n       }\\n\\n   }\\n\\n   return maxsum;\\n    }\\n  \\n\\n        \\n    \\n}; "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "There is no need to find the subarray we can just traverse the original array and find the maximum sum of any subpart. "
                    },
                    {
                        "username": "gitsejal",
                        "content": "This problem was really challenging . i hope i am not the only one?\\n"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "here is my simple iterative solution of o(n) time complexity :\\n\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int max_sum=INT_MIN ;\\n        int sum=0 ;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            if(sum<0){\\n              \\n                if(sum>max_sum){\\n                    max_sum=sum ;\\n\\n                }\\n                sum=0 ;\\n            }\\n            else if(sum>=0 and max_sum<sum){\\n                max_sum=sum;\\n            }\\n        }\\n        return max_sum ;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "pstrait",
                        "content": "I submitted the same solution three times in a row. One time it took 372ms, another 119ms, another 223ms.  The random variance is larger than the systemic variance--at this point, they probably shouldn't even measure runtime."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Kadane\\'s algorithm | Maximum subarray | O(n) complexity |\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum = 0;\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0; i < nums.length; i++){\\n            sum += nums[i];\\n            if(max < sum)\\n                max = sum;\\n            if(sum < 0)\\n                sum = 0;\\n        }\\n        return max;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1724067,
                "content": [
                    {
                        "username": "set_mik",
                        "content": "is a list of one element considered to be a subarray? E.g. for [-1, 100, -1] will a correct answer be sum([100])==100 or sum([-1,100])==99?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a list with just one element is considered a subarray. In your example, the subarray with the maximum sum would indeed be [100], which results in a sum of 100. \\n\\nThe term \"subarray\" just means a contiguous (i.e., unbroken, with no gaps) subset of the array. It doesn\\'t specify a minimum or maximum size. So a subarray could have as few as one element or as many as the entire array. \\n\\nSo in your example, both [100] and [-1, 100] are valid subarrays, but the one with the maximum sum is [100]."
                    },
                    {
                        "username": "sainiashish459",
                        "content": "divide and conquer\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    //[-2,1,-3,4,-1,2,1,-5,4]\\n    // 0, 1, 2, 3, 4, 5, 6\\n    // 0, 1,\\n    //\\n    //\\n    int maxSubArray(vector<int>& nums) {\\n        const int size = nums.size();\\n        vector<int> dp(size, 0);        \\n        // recrrence relation\\n        // dp[i+1] = dp[i] + max(nums[i+1],0) + min(0, nums[i])\\n        dp[0] = max(nums[0], 0);\\n        for(int i = 1; i < nums.size(); ++i) {\\n            dp[i] = dp[i-1] + max(nums[i-1], 0) + min(0, nums[i-1]);\\n        }\\n        \\n        return dp[size-1];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/53_max_subarray.cpp"
                    },
                    {
                        "username": "saurabh2003",
                        "content": "class Solution {\\npublic:\\n\\n    int maxSubArray(vector<int>& nums) {\\n       int  maxsum= INT_MIN;\\n\\n       int currsum=0;\\n\\n      for(int i=0;i<nums.size();i++)\\n\\n    {\\n\\n       currsum=currsum+nums[i];\\n\\n       if(currsum>maxsum)\\n\\n       {\\n\\n           maxsum=currsum;\\n\\n       }\\n\\n       if(currsum<0)\\n\\n       {\\n\\n           currsum=0;\\n\\n       }\\n\\n   }\\n\\n   return maxsum;\\n    }\\n  \\n\\n        \\n    \\n}; "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "There is no need to find the subarray we can just traverse the original array and find the maximum sum of any subpart. "
                    },
                    {
                        "username": "gitsejal",
                        "content": "This problem was really challenging . i hope i am not the only one?\\n"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "here is my simple iterative solution of o(n) time complexity :\\n\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int max_sum=INT_MIN ;\\n        int sum=0 ;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            if(sum<0){\\n              \\n                if(sum>max_sum){\\n                    max_sum=sum ;\\n\\n                }\\n                sum=0 ;\\n            }\\n            else if(sum>=0 and max_sum<sum){\\n                max_sum=sum;\\n            }\\n        }\\n        return max_sum ;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "pstrait",
                        "content": "I submitted the same solution three times in a row. One time it took 372ms, another 119ms, another 223ms.  The random variance is larger than the systemic variance--at this point, they probably shouldn't even measure runtime."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Kadane\\'s algorithm | Maximum subarray | O(n) complexity |\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum = 0;\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0; i < nums.length; i++){\\n            sum += nums[i];\\n            if(max < sum)\\n                max = sum;\\n            if(sum < 0)\\n                sum = 0;\\n        }\\n        return max;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1723734,
                "content": [
                    {
                        "username": "set_mik",
                        "content": "is a list of one element considered to be a subarray? E.g. for [-1, 100, -1] will a correct answer be sum([100])==100 or sum([-1,100])==99?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a list with just one element is considered a subarray. In your example, the subarray with the maximum sum would indeed be [100], which results in a sum of 100. \\n\\nThe term \"subarray\" just means a contiguous (i.e., unbroken, with no gaps) subset of the array. It doesn\\'t specify a minimum or maximum size. So a subarray could have as few as one element or as many as the entire array. \\n\\nSo in your example, both [100] and [-1, 100] are valid subarrays, but the one with the maximum sum is [100]."
                    },
                    {
                        "username": "sainiashish459",
                        "content": "divide and conquer\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    //[-2,1,-3,4,-1,2,1,-5,4]\\n    // 0, 1, 2, 3, 4, 5, 6\\n    // 0, 1,\\n    //\\n    //\\n    int maxSubArray(vector<int>& nums) {\\n        const int size = nums.size();\\n        vector<int> dp(size, 0);        \\n        // recrrence relation\\n        // dp[i+1] = dp[i] + max(nums[i+1],0) + min(0, nums[i])\\n        dp[0] = max(nums[0], 0);\\n        for(int i = 1; i < nums.size(); ++i) {\\n            dp[i] = dp[i-1] + max(nums[i-1], 0) + min(0, nums[i-1]);\\n        }\\n        \\n        return dp[size-1];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/53_max_subarray.cpp"
                    },
                    {
                        "username": "saurabh2003",
                        "content": "class Solution {\\npublic:\\n\\n    int maxSubArray(vector<int>& nums) {\\n       int  maxsum= INT_MIN;\\n\\n       int currsum=0;\\n\\n      for(int i=0;i<nums.size();i++)\\n\\n    {\\n\\n       currsum=currsum+nums[i];\\n\\n       if(currsum>maxsum)\\n\\n       {\\n\\n           maxsum=currsum;\\n\\n       }\\n\\n       if(currsum<0)\\n\\n       {\\n\\n           currsum=0;\\n\\n       }\\n\\n   }\\n\\n   return maxsum;\\n    }\\n  \\n\\n        \\n    \\n}; "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "There is no need to find the subarray we can just traverse the original array and find the maximum sum of any subpart. "
                    },
                    {
                        "username": "gitsejal",
                        "content": "This problem was really challenging . i hope i am not the only one?\\n"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "here is my simple iterative solution of o(n) time complexity :\\n\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int max_sum=INT_MIN ;\\n        int sum=0 ;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            if(sum<0){\\n              \\n                if(sum>max_sum){\\n                    max_sum=sum ;\\n\\n                }\\n                sum=0 ;\\n            }\\n            else if(sum>=0 and max_sum<sum){\\n                max_sum=sum;\\n            }\\n        }\\n        return max_sum ;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "pstrait",
                        "content": "I submitted the same solution three times in a row. One time it took 372ms, another 119ms, another 223ms.  The random variance is larger than the systemic variance--at this point, they probably shouldn't even measure runtime."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Kadane\\'s algorithm | Maximum subarray | O(n) complexity |\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum = 0;\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0; i < nums.length; i++){\\n            sum += nums[i];\\n            if(max < sum)\\n                max = sum;\\n            if(sum < 0)\\n                sum = 0;\\n        }\\n        return max;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1722832,
                "content": [
                    {
                        "username": "set_mik",
                        "content": "is a list of one element considered to be a subarray? E.g. for [-1, 100, -1] will a correct answer be sum([100])==100 or sum([-1,100])==99?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a list with just one element is considered a subarray. In your example, the subarray with the maximum sum would indeed be [100], which results in a sum of 100. \\n\\nThe term \"subarray\" just means a contiguous (i.e., unbroken, with no gaps) subset of the array. It doesn\\'t specify a minimum or maximum size. So a subarray could have as few as one element or as many as the entire array. \\n\\nSo in your example, both [100] and [-1, 100] are valid subarrays, but the one with the maximum sum is [100]."
                    },
                    {
                        "username": "sainiashish459",
                        "content": "divide and conquer\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    //[-2,1,-3,4,-1,2,1,-5,4]\\n    // 0, 1, 2, 3, 4, 5, 6\\n    // 0, 1,\\n    //\\n    //\\n    int maxSubArray(vector<int>& nums) {\\n        const int size = nums.size();\\n        vector<int> dp(size, 0);        \\n        // recrrence relation\\n        // dp[i+1] = dp[i] + max(nums[i+1],0) + min(0, nums[i])\\n        dp[0] = max(nums[0], 0);\\n        for(int i = 1; i < nums.size(); ++i) {\\n            dp[i] = dp[i-1] + max(nums[i-1], 0) + min(0, nums[i-1]);\\n        }\\n        \\n        return dp[size-1];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/53_max_subarray.cpp"
                    },
                    {
                        "username": "saurabh2003",
                        "content": "class Solution {\\npublic:\\n\\n    int maxSubArray(vector<int>& nums) {\\n       int  maxsum= INT_MIN;\\n\\n       int currsum=0;\\n\\n      for(int i=0;i<nums.size();i++)\\n\\n    {\\n\\n       currsum=currsum+nums[i];\\n\\n       if(currsum>maxsum)\\n\\n       {\\n\\n           maxsum=currsum;\\n\\n       }\\n\\n       if(currsum<0)\\n\\n       {\\n\\n           currsum=0;\\n\\n       }\\n\\n   }\\n\\n   return maxsum;\\n    }\\n  \\n\\n        \\n    \\n}; "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "There is no need to find the subarray we can just traverse the original array and find the maximum sum of any subpart. "
                    },
                    {
                        "username": "gitsejal",
                        "content": "This problem was really challenging . i hope i am not the only one?\\n"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "here is my simple iterative solution of o(n) time complexity :\\n\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int max_sum=INT_MIN ;\\n        int sum=0 ;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            if(sum<0){\\n              \\n                if(sum>max_sum){\\n                    max_sum=sum ;\\n\\n                }\\n                sum=0 ;\\n            }\\n            else if(sum>=0 and max_sum<sum){\\n                max_sum=sum;\\n            }\\n        }\\n        return max_sum ;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "pstrait",
                        "content": "I submitted the same solution three times in a row. One time it took 372ms, another 119ms, another 223ms.  The random variance is larger than the systemic variance--at this point, they probably shouldn't even measure runtime."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Kadane\\'s algorithm | Maximum subarray | O(n) complexity |\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum = 0;\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0; i < nums.length; i++){\\n            sum += nums[i];\\n            if(max < sum)\\n                max = sum;\\n            if(sum < 0)\\n                sum = 0;\\n        }\\n        return max;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1716318,
                "content": [
                    {
                        "username": "set_mik",
                        "content": "is a list of one element considered to be a subarray? E.g. for [-1, 100, -1] will a correct answer be sum([100])==100 or sum([-1,100])==99?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a list with just one element is considered a subarray. In your example, the subarray with the maximum sum would indeed be [100], which results in a sum of 100. \\n\\nThe term \"subarray\" just means a contiguous (i.e., unbroken, with no gaps) subset of the array. It doesn\\'t specify a minimum or maximum size. So a subarray could have as few as one element or as many as the entire array. \\n\\nSo in your example, both [100] and [-1, 100] are valid subarrays, but the one with the maximum sum is [100]."
                    },
                    {
                        "username": "sainiashish459",
                        "content": "divide and conquer\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    //[-2,1,-3,4,-1,2,1,-5,4]\\n    // 0, 1, 2, 3, 4, 5, 6\\n    // 0, 1,\\n    //\\n    //\\n    int maxSubArray(vector<int>& nums) {\\n        const int size = nums.size();\\n        vector<int> dp(size, 0);        \\n        // recrrence relation\\n        // dp[i+1] = dp[i] + max(nums[i+1],0) + min(0, nums[i])\\n        dp[0] = max(nums[0], 0);\\n        for(int i = 1; i < nums.size(); ++i) {\\n            dp[i] = dp[i-1] + max(nums[i-1], 0) + min(0, nums[i-1]);\\n        }\\n        \\n        return dp[size-1];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/53_max_subarray.cpp"
                    },
                    {
                        "username": "saurabh2003",
                        "content": "class Solution {\\npublic:\\n\\n    int maxSubArray(vector<int>& nums) {\\n       int  maxsum= INT_MIN;\\n\\n       int currsum=0;\\n\\n      for(int i=0;i<nums.size();i++)\\n\\n    {\\n\\n       currsum=currsum+nums[i];\\n\\n       if(currsum>maxsum)\\n\\n       {\\n\\n           maxsum=currsum;\\n\\n       }\\n\\n       if(currsum<0)\\n\\n       {\\n\\n           currsum=0;\\n\\n       }\\n\\n   }\\n\\n   return maxsum;\\n    }\\n  \\n\\n        \\n    \\n}; "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "There is no need to find the subarray we can just traverse the original array and find the maximum sum of any subpart. "
                    },
                    {
                        "username": "gitsejal",
                        "content": "This problem was really challenging . i hope i am not the only one?\\n"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "here is my simple iterative solution of o(n) time complexity :\\n\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int max_sum=INT_MIN ;\\n        int sum=0 ;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            if(sum<0){\\n              \\n                if(sum>max_sum){\\n                    max_sum=sum ;\\n\\n                }\\n                sum=0 ;\\n            }\\n            else if(sum>=0 and max_sum<sum){\\n                max_sum=sum;\\n            }\\n        }\\n        return max_sum ;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "pstrait",
                        "content": "I submitted the same solution three times in a row. One time it took 372ms, another 119ms, another 223ms.  The random variance is larger than the systemic variance--at this point, they probably shouldn't even measure runtime."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Kadane\\'s algorithm | Maximum subarray | O(n) complexity |\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum = 0;\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0; i < nums.length; i++){\\n            sum += nums[i];\\n            if(max < sum)\\n                max = sum;\\n            if(sum < 0)\\n                sum = 0;\\n        }\\n        return max;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1710408,
                "content": [
                    {
                        "username": "set_mik",
                        "content": "is a list of one element considered to be a subarray? E.g. for [-1, 100, -1] will a correct answer be sum([100])==100 or sum([-1,100])==99?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a list with just one element is considered a subarray. In your example, the subarray with the maximum sum would indeed be [100], which results in a sum of 100. \\n\\nThe term \"subarray\" just means a contiguous (i.e., unbroken, with no gaps) subset of the array. It doesn\\'t specify a minimum or maximum size. So a subarray could have as few as one element or as many as the entire array. \\n\\nSo in your example, both [100] and [-1, 100] are valid subarrays, but the one with the maximum sum is [100]."
                    },
                    {
                        "username": "sainiashish459",
                        "content": "divide and conquer\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    //[-2,1,-3,4,-1,2,1,-5,4]\\n    // 0, 1, 2, 3, 4, 5, 6\\n    // 0, 1,\\n    //\\n    //\\n    int maxSubArray(vector<int>& nums) {\\n        const int size = nums.size();\\n        vector<int> dp(size, 0);        \\n        // recrrence relation\\n        // dp[i+1] = dp[i] + max(nums[i+1],0) + min(0, nums[i])\\n        dp[0] = max(nums[0], 0);\\n        for(int i = 1; i < nums.size(); ++i) {\\n            dp[i] = dp[i-1] + max(nums[i-1], 0) + min(0, nums[i-1]);\\n        }\\n        \\n        return dp[size-1];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/53_max_subarray.cpp"
                    },
                    {
                        "username": "saurabh2003",
                        "content": "class Solution {\\npublic:\\n\\n    int maxSubArray(vector<int>& nums) {\\n       int  maxsum= INT_MIN;\\n\\n       int currsum=0;\\n\\n      for(int i=0;i<nums.size();i++)\\n\\n    {\\n\\n       currsum=currsum+nums[i];\\n\\n       if(currsum>maxsum)\\n\\n       {\\n\\n           maxsum=currsum;\\n\\n       }\\n\\n       if(currsum<0)\\n\\n       {\\n\\n           currsum=0;\\n\\n       }\\n\\n   }\\n\\n   return maxsum;\\n    }\\n  \\n\\n        \\n    \\n}; "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "There is no need to find the subarray we can just traverse the original array and find the maximum sum of any subpart. "
                    },
                    {
                        "username": "gitsejal",
                        "content": "This problem was really challenging . i hope i am not the only one?\\n"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "here is my simple iterative solution of o(n) time complexity :\\n\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int max_sum=INT_MIN ;\\n        int sum=0 ;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            if(sum<0){\\n              \\n                if(sum>max_sum){\\n                    max_sum=sum ;\\n\\n                }\\n                sum=0 ;\\n            }\\n            else if(sum>=0 and max_sum<sum){\\n                max_sum=sum;\\n            }\\n        }\\n        return max_sum ;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "pstrait",
                        "content": "I submitted the same solution three times in a row. One time it took 372ms, another 119ms, another 223ms.  The random variance is larger than the systemic variance--at this point, they probably shouldn't even measure runtime."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Kadane\\'s algorithm | Maximum subarray | O(n) complexity |\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum = 0;\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0; i < nums.length; i++){\\n            sum += nums[i];\\n            if(max < sum)\\n                max = sum;\\n            if(sum < 0)\\n                sum = 0;\\n        }\\n        return max;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1709681,
                "content": [
                    {
                        "username": "set_mik",
                        "content": "is a list of one element considered to be a subarray? E.g. for [-1, 100, -1] will a correct answer be sum([100])==100 or sum([-1,100])==99?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a list with just one element is considered a subarray. In your example, the subarray with the maximum sum would indeed be [100], which results in a sum of 100. \\n\\nThe term \"subarray\" just means a contiguous (i.e., unbroken, with no gaps) subset of the array. It doesn\\'t specify a minimum or maximum size. So a subarray could have as few as one element or as many as the entire array. \\n\\nSo in your example, both [100] and [-1, 100] are valid subarrays, but the one with the maximum sum is [100]."
                    },
                    {
                        "username": "sainiashish459",
                        "content": "divide and conquer\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    //[-2,1,-3,4,-1,2,1,-5,4]\\n    // 0, 1, 2, 3, 4, 5, 6\\n    // 0, 1,\\n    //\\n    //\\n    int maxSubArray(vector<int>& nums) {\\n        const int size = nums.size();\\n        vector<int> dp(size, 0);        \\n        // recrrence relation\\n        // dp[i+1] = dp[i] + max(nums[i+1],0) + min(0, nums[i])\\n        dp[0] = max(nums[0], 0);\\n        for(int i = 1; i < nums.size(); ++i) {\\n            dp[i] = dp[i-1] + max(nums[i-1], 0) + min(0, nums[i-1]);\\n        }\\n        \\n        return dp[size-1];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/53_max_subarray.cpp"
                    },
                    {
                        "username": "saurabh2003",
                        "content": "class Solution {\\npublic:\\n\\n    int maxSubArray(vector<int>& nums) {\\n       int  maxsum= INT_MIN;\\n\\n       int currsum=0;\\n\\n      for(int i=0;i<nums.size();i++)\\n\\n    {\\n\\n       currsum=currsum+nums[i];\\n\\n       if(currsum>maxsum)\\n\\n       {\\n\\n           maxsum=currsum;\\n\\n       }\\n\\n       if(currsum<0)\\n\\n       {\\n\\n           currsum=0;\\n\\n       }\\n\\n   }\\n\\n   return maxsum;\\n    }\\n  \\n\\n        \\n    \\n}; "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "There is no need to find the subarray we can just traverse the original array and find the maximum sum of any subpart. "
                    },
                    {
                        "username": "gitsejal",
                        "content": "This problem was really challenging . i hope i am not the only one?\\n"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "here is my simple iterative solution of o(n) time complexity :\\n\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int max_sum=INT_MIN ;\\n        int sum=0 ;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            if(sum<0){\\n              \\n                if(sum>max_sum){\\n                    max_sum=sum ;\\n\\n                }\\n                sum=0 ;\\n            }\\n            else if(sum>=0 and max_sum<sum){\\n                max_sum=sum;\\n            }\\n        }\\n        return max_sum ;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "pstrait",
                        "content": "I submitted the same solution three times in a row. One time it took 372ms, another 119ms, another 223ms.  The random variance is larger than the systemic variance--at this point, they probably shouldn't even measure runtime."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Kadane\\'s algorithm | Maximum subarray | O(n) complexity |\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum = 0;\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0; i < nums.length; i++){\\n            sum += nums[i];\\n            if(max < sum)\\n                max = sum;\\n            if(sum < 0)\\n                sum = 0;\\n        }\\n        return max;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1704485,
                "content": [
                    {
                        "username": "set_mik",
                        "content": "is a list of one element considered to be a subarray? E.g. for [-1, 100, -1] will a correct answer be sum([100])==100 or sum([-1,100])==99?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a list with just one element is considered a subarray. In your example, the subarray with the maximum sum would indeed be [100], which results in a sum of 100. \\n\\nThe term \"subarray\" just means a contiguous (i.e., unbroken, with no gaps) subset of the array. It doesn\\'t specify a minimum or maximum size. So a subarray could have as few as one element or as many as the entire array. \\n\\nSo in your example, both [100] and [-1, 100] are valid subarrays, but the one with the maximum sum is [100]."
                    },
                    {
                        "username": "sainiashish459",
                        "content": "divide and conquer\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    //[-2,1,-3,4,-1,2,1,-5,4]\\n    // 0, 1, 2, 3, 4, 5, 6\\n    // 0, 1,\\n    //\\n    //\\n    int maxSubArray(vector<int>& nums) {\\n        const int size = nums.size();\\n        vector<int> dp(size, 0);        \\n        // recrrence relation\\n        // dp[i+1] = dp[i] + max(nums[i+1],0) + min(0, nums[i])\\n        dp[0] = max(nums[0], 0);\\n        for(int i = 1; i < nums.size(); ++i) {\\n            dp[i] = dp[i-1] + max(nums[i-1], 0) + min(0, nums[i-1]);\\n        }\\n        \\n        return dp[size-1];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/53_max_subarray.cpp"
                    },
                    {
                        "username": "saurabh2003",
                        "content": "class Solution {\\npublic:\\n\\n    int maxSubArray(vector<int>& nums) {\\n       int  maxsum= INT_MIN;\\n\\n       int currsum=0;\\n\\n      for(int i=0;i<nums.size();i++)\\n\\n    {\\n\\n       currsum=currsum+nums[i];\\n\\n       if(currsum>maxsum)\\n\\n       {\\n\\n           maxsum=currsum;\\n\\n       }\\n\\n       if(currsum<0)\\n\\n       {\\n\\n           currsum=0;\\n\\n       }\\n\\n   }\\n\\n   return maxsum;\\n    }\\n  \\n\\n        \\n    \\n}; "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "There is no need to find the subarray we can just traverse the original array and find the maximum sum of any subpart. "
                    },
                    {
                        "username": "gitsejal",
                        "content": "This problem was really challenging . i hope i am not the only one?\\n"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "here is my simple iterative solution of o(n) time complexity :\\n\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int max_sum=INT_MIN ;\\n        int sum=0 ;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            if(sum<0){\\n              \\n                if(sum>max_sum){\\n                    max_sum=sum ;\\n\\n                }\\n                sum=0 ;\\n            }\\n            else if(sum>=0 and max_sum<sum){\\n                max_sum=sum;\\n            }\\n        }\\n        return max_sum ;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "pstrait",
                        "content": "I submitted the same solution three times in a row. One time it took 372ms, another 119ms, another 223ms.  The random variance is larger than the systemic variance--at this point, they probably shouldn't even measure runtime."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Kadane\\'s algorithm | Maximum subarray | O(n) complexity |\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum = 0;\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0; i < nums.length; i++){\\n            sum += nums[i];\\n            if(max < sum)\\n                max = sum;\\n            if(sum < 0)\\n                sum = 0;\\n        }\\n        return max;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1695088,
                "content": [
                    {
                        "username": "set_mik",
                        "content": "is a list of one element considered to be a subarray? E.g. for [-1, 100, -1] will a correct answer be sum([100])==100 or sum([-1,100])==99?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, a list with just one element is considered a subarray. In your example, the subarray with the maximum sum would indeed be [100], which results in a sum of 100. \\n\\nThe term \"subarray\" just means a contiguous (i.e., unbroken, with no gaps) subset of the array. It doesn\\'t specify a minimum or maximum size. So a subarray could have as few as one element or as many as the entire array. \\n\\nSo in your example, both [100] and [-1, 100] are valid subarrays, but the one with the maximum sum is [100]."
                    },
                    {
                        "username": "sainiashish459",
                        "content": "divide and conquer\\n"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\npublic:\\n    //[-2,1,-3,4,-1,2,1,-5,4]\\n    // 0, 1, 2, 3, 4, 5, 6\\n    // 0, 1,\\n    //\\n    //\\n    int maxSubArray(vector<int>& nums) {\\n        const int size = nums.size();\\n        vector<int> dp(size, 0);        \\n        // recrrence relation\\n        // dp[i+1] = dp[i] + max(nums[i+1],0) + min(0, nums[i])\\n        dp[0] = max(nums[0], 0);\\n        for(int i = 1; i < nums.size(); ++i) {\\n            dp[i] = dp[i-1] + max(nums[i-1], 0) + min(0, nums[i-1]);\\n        }\\n        \\n        return dp[size-1];\\n    }\\n};\\n```"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/53_max_subarray.cpp"
                    },
                    {
                        "username": "saurabh2003",
                        "content": "class Solution {\\npublic:\\n\\n    int maxSubArray(vector<int>& nums) {\\n       int  maxsum= INT_MIN;\\n\\n       int currsum=0;\\n\\n      for(int i=0;i<nums.size();i++)\\n\\n    {\\n\\n       currsum=currsum+nums[i];\\n\\n       if(currsum>maxsum)\\n\\n       {\\n\\n           maxsum=currsum;\\n\\n       }\\n\\n       if(currsum<0)\\n\\n       {\\n\\n           currsum=0;\\n\\n       }\\n\\n   }\\n\\n   return maxsum;\\n    }\\n  \\n\\n        \\n    \\n}; "
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "There is no need to find the subarray we can just traverse the original array and find the maximum sum of any subpart. "
                    },
                    {
                        "username": "gitsejal",
                        "content": "This problem was really challenging . i hope i am not the only one?\\n"
                    },
                    {
                        "username": "JGarima2843",
                        "content": "here is my simple iterative solution of o(n) time complexity :\\n\\nclass Solution {\\npublic:\\n    int maxSubArray(vector<int>& nums) {\\n\\n        int max_sum=INT_MIN ;\\n        int sum=0 ;\\n        for(int i=0;i<nums.size();i++){\\n            sum+=nums[i];\\n            if(sum<0){\\n              \\n                if(sum>max_sum){\\n                    max_sum=sum ;\\n\\n                }\\n                sum=0 ;\\n            }\\n            else if(sum>=0 and max_sum<sum){\\n                max_sum=sum;\\n            }\\n        }\\n        return max_sum ;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "pstrait",
                        "content": "I submitted the same solution three times in a row. One time it took 372ms, another 119ms, another 223ms.  The random variance is larger than the systemic variance--at this point, they probably shouldn't even measure runtime."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "Kadane\\'s algorithm | Maximum subarray | O(n) complexity |\\nclass Solution {\\n    public int maxSubArray(int[] nums) {\\n        int sum = 0;\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0; i < nums.length; i++){\\n            sum += nums[i];\\n            if(max < sum)\\n                max = sum;\\n            if(sum < 0)\\n                sum = 0;\\n        }\\n        return max;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1689647,
                "content": [
                    {
                        "username": "Deepanshudangi",
                        "content": "Why everytime leetcode shows \"Time Limit Exceeded\"?"
                    },
                    {
                        "username": "MatthewGehring",
                        "content": "Are we to assume an empty array is an allowed sub array? "
                    },
                    {
                        "username": "sild",
                        "content": "Why solution for [-1] input is -1 instead of 0?\nEmpty subarray with sum 0 seems like a correct solution"
                    },
                    {
                        "username": "learningplatform",
                        "content": "I\\'m not sure I understand the question; it requires us to find the largest sum, correct? So we can basically ignore all of the negative figures and add up all of the positive ones? However, the example given is not exactly the same as what I had in mind."
                    },
                    {
                        "username": "abdulsami2",
                        "content": "What if there are only negatives in the array? "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I believe the regular Kadane\\'s Algorithm will take care of it if we initialize the maxSum variable correctly. By this I mean, for Python, I did `maxSum = -float(\\'inf\\')`. Even if all the values are negative, this still works.\\n\\nIf you want to look at the whole code:\\nhttps://leetcode.com/problems/maximum-subarray/submissions/840570081/"
                    },
                    {
                        "username": "Sayali_Berde",
                        "content": "What should be the length of the sub array which has largest sum?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The length of the subarray with the largest sum could be any length between 1 (if a single element is the maximum sum) and the length of the entire array (if all elements contribute to a maximum sum). It\\'s entirely dependent on the array and isn\\'t a fixed length. \\n\\nFor example, consider the array [5, -2, 3]. Here, the subarray with the maximum sum is [5, -2, 3], which has a length of 3. \\n\\nNow, consider the array [-2, 1, -3, 4, -1, 2, 1, -5, 4]. Here, the subarray with the maximum sum is [4, -1, 2, 1], which has a length of 4. \\n\\nIn other words, the subarray with the maximum sum isn\\'t determined by length, but by the sum of its elements."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The idea in simple words:\n\n1. loop through the array and take a note of the **current sum** and the **max sum** so far\n\n2. if the current sum becomes negative, make it 0 and continue to the next iteration\n\n\n**Why make it zero?**\nIf the sum of some numbers becomes negative, no matter how much you keep adding in that sum, it will still be reduced because of that negative effect. Think about what your sum would be if you had no negatives?\n\n**Its kind of tricky to think about this, lets try an example**\n\nAssume your current sum is -3, and you add 500 (the next number in the array) in it. It becomes 497. Not bad! But, what if you ignored that -3? It would be 500 right? And 500 > 497 ;) "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714 GOOGLE\\uD83D\\uDE28 Interview clean code\\uD83E\\uDD73O(n)\\n\\n##### Optimized Kadane\\'s Algorithm considering if all the elements of the array are negative , positive or a mix of both !\\nhttps://leetcode.com/problems/maximum-subarray/solutions/2320036/google-interview-clean-codeon/"
                    },
                    {
                        "username": "Gudun",
                        "content": " int maxSubArray(vector<int>& nums) {\\n        \\n        int currsum=0;\\n        int maxSum=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n            currsum+=nums[i];\\n            maxSum=max(maxSum,currsum);\\n            if(currsum<0){\\n                currsum=0;\\n            }\\n        }\\n        \\n        return maxSum;\\n    }"
                    },
                    {
                        "username": "user6314wG",
                        "content": "Shouldn\\'t this say \"contiguous subarray\"? "
                    },
                    {
                        "username": "AssetDali",
                        "content": "Lol, where did you see not continues array?"
                    }
                ]
            },
            {
                "id": 1688787,
                "content": [
                    {
                        "username": "Deepanshudangi",
                        "content": "Why everytime leetcode shows \"Time Limit Exceeded\"?"
                    },
                    {
                        "username": "MatthewGehring",
                        "content": "Are we to assume an empty array is an allowed sub array? "
                    },
                    {
                        "username": "sild",
                        "content": "Why solution for [-1] input is -1 instead of 0?\nEmpty subarray with sum 0 seems like a correct solution"
                    },
                    {
                        "username": "learningplatform",
                        "content": "I\\'m not sure I understand the question; it requires us to find the largest sum, correct? So we can basically ignore all of the negative figures and add up all of the positive ones? However, the example given is not exactly the same as what I had in mind."
                    },
                    {
                        "username": "abdulsami2",
                        "content": "What if there are only negatives in the array? "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I believe the regular Kadane\\'s Algorithm will take care of it if we initialize the maxSum variable correctly. By this I mean, for Python, I did `maxSum = -float(\\'inf\\')`. Even if all the values are negative, this still works.\\n\\nIf you want to look at the whole code:\\nhttps://leetcode.com/problems/maximum-subarray/submissions/840570081/"
                    },
                    {
                        "username": "Sayali_Berde",
                        "content": "What should be the length of the sub array which has largest sum?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The length of the subarray with the largest sum could be any length between 1 (if a single element is the maximum sum) and the length of the entire array (if all elements contribute to a maximum sum). It\\'s entirely dependent on the array and isn\\'t a fixed length. \\n\\nFor example, consider the array [5, -2, 3]. Here, the subarray with the maximum sum is [5, -2, 3], which has a length of 3. \\n\\nNow, consider the array [-2, 1, -3, 4, -1, 2, 1, -5, 4]. Here, the subarray with the maximum sum is [4, -1, 2, 1], which has a length of 4. \\n\\nIn other words, the subarray with the maximum sum isn\\'t determined by length, but by the sum of its elements."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The idea in simple words:\n\n1. loop through the array and take a note of the **current sum** and the **max sum** so far\n\n2. if the current sum becomes negative, make it 0 and continue to the next iteration\n\n\n**Why make it zero?**\nIf the sum of some numbers becomes negative, no matter how much you keep adding in that sum, it will still be reduced because of that negative effect. Think about what your sum would be if you had no negatives?\n\n**Its kind of tricky to think about this, lets try an example**\n\nAssume your current sum is -3, and you add 500 (the next number in the array) in it. It becomes 497. Not bad! But, what if you ignored that -3? It would be 500 right? And 500 > 497 ;) "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714 GOOGLE\\uD83D\\uDE28 Interview clean code\\uD83E\\uDD73O(n)\\n\\n##### Optimized Kadane\\'s Algorithm considering if all the elements of the array are negative , positive or a mix of both !\\nhttps://leetcode.com/problems/maximum-subarray/solutions/2320036/google-interview-clean-codeon/"
                    },
                    {
                        "username": "Gudun",
                        "content": " int maxSubArray(vector<int>& nums) {\\n        \\n        int currsum=0;\\n        int maxSum=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n            currsum+=nums[i];\\n            maxSum=max(maxSum,currsum);\\n            if(currsum<0){\\n                currsum=0;\\n            }\\n        }\\n        \\n        return maxSum;\\n    }"
                    },
                    {
                        "username": "user6314wG",
                        "content": "Shouldn\\'t this say \"contiguous subarray\"? "
                    },
                    {
                        "username": "AssetDali",
                        "content": "Lol, where did you see not continues array?"
                    }
                ]
            },
            {
                "id": 1687649,
                "content": [
                    {
                        "username": "Deepanshudangi",
                        "content": "Why everytime leetcode shows \"Time Limit Exceeded\"?"
                    },
                    {
                        "username": "MatthewGehring",
                        "content": "Are we to assume an empty array is an allowed sub array? "
                    },
                    {
                        "username": "sild",
                        "content": "Why solution for [-1] input is -1 instead of 0?\nEmpty subarray with sum 0 seems like a correct solution"
                    },
                    {
                        "username": "learningplatform",
                        "content": "I\\'m not sure I understand the question; it requires us to find the largest sum, correct? So we can basically ignore all of the negative figures and add up all of the positive ones? However, the example given is not exactly the same as what I had in mind."
                    },
                    {
                        "username": "abdulsami2",
                        "content": "What if there are only negatives in the array? "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I believe the regular Kadane\\'s Algorithm will take care of it if we initialize the maxSum variable correctly. By this I mean, for Python, I did `maxSum = -float(\\'inf\\')`. Even if all the values are negative, this still works.\\n\\nIf you want to look at the whole code:\\nhttps://leetcode.com/problems/maximum-subarray/submissions/840570081/"
                    },
                    {
                        "username": "Sayali_Berde",
                        "content": "What should be the length of the sub array which has largest sum?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The length of the subarray with the largest sum could be any length between 1 (if a single element is the maximum sum) and the length of the entire array (if all elements contribute to a maximum sum). It\\'s entirely dependent on the array and isn\\'t a fixed length. \\n\\nFor example, consider the array [5, -2, 3]. Here, the subarray with the maximum sum is [5, -2, 3], which has a length of 3. \\n\\nNow, consider the array [-2, 1, -3, 4, -1, 2, 1, -5, 4]. Here, the subarray with the maximum sum is [4, -1, 2, 1], which has a length of 4. \\n\\nIn other words, the subarray with the maximum sum isn\\'t determined by length, but by the sum of its elements."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The idea in simple words:\n\n1. loop through the array and take a note of the **current sum** and the **max sum** so far\n\n2. if the current sum becomes negative, make it 0 and continue to the next iteration\n\n\n**Why make it zero?**\nIf the sum of some numbers becomes negative, no matter how much you keep adding in that sum, it will still be reduced because of that negative effect. Think about what your sum would be if you had no negatives?\n\n**Its kind of tricky to think about this, lets try an example**\n\nAssume your current sum is -3, and you add 500 (the next number in the array) in it. It becomes 497. Not bad! But, what if you ignored that -3? It would be 500 right? And 500 > 497 ;) "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714 GOOGLE\\uD83D\\uDE28 Interview clean code\\uD83E\\uDD73O(n)\\n\\n##### Optimized Kadane\\'s Algorithm considering if all the elements of the array are negative , positive or a mix of both !\\nhttps://leetcode.com/problems/maximum-subarray/solutions/2320036/google-interview-clean-codeon/"
                    },
                    {
                        "username": "Gudun",
                        "content": " int maxSubArray(vector<int>& nums) {\\n        \\n        int currsum=0;\\n        int maxSum=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n            currsum+=nums[i];\\n            maxSum=max(maxSum,currsum);\\n            if(currsum<0){\\n                currsum=0;\\n            }\\n        }\\n        \\n        return maxSum;\\n    }"
                    },
                    {
                        "username": "user6314wG",
                        "content": "Shouldn\\'t this say \"contiguous subarray\"? "
                    },
                    {
                        "username": "AssetDali",
                        "content": "Lol, where did you see not continues array?"
                    }
                ]
            },
            {
                "id": 1687028,
                "content": [
                    {
                        "username": "Deepanshudangi",
                        "content": "Why everytime leetcode shows \"Time Limit Exceeded\"?"
                    },
                    {
                        "username": "MatthewGehring",
                        "content": "Are we to assume an empty array is an allowed sub array? "
                    },
                    {
                        "username": "sild",
                        "content": "Why solution for [-1] input is -1 instead of 0?\nEmpty subarray with sum 0 seems like a correct solution"
                    },
                    {
                        "username": "learningplatform",
                        "content": "I\\'m not sure I understand the question; it requires us to find the largest sum, correct? So we can basically ignore all of the negative figures and add up all of the positive ones? However, the example given is not exactly the same as what I had in mind."
                    },
                    {
                        "username": "abdulsami2",
                        "content": "What if there are only negatives in the array? "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I believe the regular Kadane\\'s Algorithm will take care of it if we initialize the maxSum variable correctly. By this I mean, for Python, I did `maxSum = -float(\\'inf\\')`. Even if all the values are negative, this still works.\\n\\nIf you want to look at the whole code:\\nhttps://leetcode.com/problems/maximum-subarray/submissions/840570081/"
                    },
                    {
                        "username": "Sayali_Berde",
                        "content": "What should be the length of the sub array which has largest sum?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The length of the subarray with the largest sum could be any length between 1 (if a single element is the maximum sum) and the length of the entire array (if all elements contribute to a maximum sum). It\\'s entirely dependent on the array and isn\\'t a fixed length. \\n\\nFor example, consider the array [5, -2, 3]. Here, the subarray with the maximum sum is [5, -2, 3], which has a length of 3. \\n\\nNow, consider the array [-2, 1, -3, 4, -1, 2, 1, -5, 4]. Here, the subarray with the maximum sum is [4, -1, 2, 1], which has a length of 4. \\n\\nIn other words, the subarray with the maximum sum isn\\'t determined by length, but by the sum of its elements."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The idea in simple words:\n\n1. loop through the array and take a note of the **current sum** and the **max sum** so far\n\n2. if the current sum becomes negative, make it 0 and continue to the next iteration\n\n\n**Why make it zero?**\nIf the sum of some numbers becomes negative, no matter how much you keep adding in that sum, it will still be reduced because of that negative effect. Think about what your sum would be if you had no negatives?\n\n**Its kind of tricky to think about this, lets try an example**\n\nAssume your current sum is -3, and you add 500 (the next number in the array) in it. It becomes 497. Not bad! But, what if you ignored that -3? It would be 500 right? And 500 > 497 ;) "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714 GOOGLE\\uD83D\\uDE28 Interview clean code\\uD83E\\uDD73O(n)\\n\\n##### Optimized Kadane\\'s Algorithm considering if all the elements of the array are negative , positive or a mix of both !\\nhttps://leetcode.com/problems/maximum-subarray/solutions/2320036/google-interview-clean-codeon/"
                    },
                    {
                        "username": "Gudun",
                        "content": " int maxSubArray(vector<int>& nums) {\\n        \\n        int currsum=0;\\n        int maxSum=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n            currsum+=nums[i];\\n            maxSum=max(maxSum,currsum);\\n            if(currsum<0){\\n                currsum=0;\\n            }\\n        }\\n        \\n        return maxSum;\\n    }"
                    },
                    {
                        "username": "user6314wG",
                        "content": "Shouldn\\'t this say \"contiguous subarray\"? "
                    },
                    {
                        "username": "AssetDali",
                        "content": "Lol, where did you see not continues array?"
                    }
                ]
            },
            {
                "id": 1677997,
                "content": [
                    {
                        "username": "Deepanshudangi",
                        "content": "Why everytime leetcode shows \"Time Limit Exceeded\"?"
                    },
                    {
                        "username": "MatthewGehring",
                        "content": "Are we to assume an empty array is an allowed sub array? "
                    },
                    {
                        "username": "sild",
                        "content": "Why solution for [-1] input is -1 instead of 0?\nEmpty subarray with sum 0 seems like a correct solution"
                    },
                    {
                        "username": "learningplatform",
                        "content": "I\\'m not sure I understand the question; it requires us to find the largest sum, correct? So we can basically ignore all of the negative figures and add up all of the positive ones? However, the example given is not exactly the same as what I had in mind."
                    },
                    {
                        "username": "abdulsami2",
                        "content": "What if there are only negatives in the array? "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I believe the regular Kadane\\'s Algorithm will take care of it if we initialize the maxSum variable correctly. By this I mean, for Python, I did `maxSum = -float(\\'inf\\')`. Even if all the values are negative, this still works.\\n\\nIf you want to look at the whole code:\\nhttps://leetcode.com/problems/maximum-subarray/submissions/840570081/"
                    },
                    {
                        "username": "Sayali_Berde",
                        "content": "What should be the length of the sub array which has largest sum?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The length of the subarray with the largest sum could be any length between 1 (if a single element is the maximum sum) and the length of the entire array (if all elements contribute to a maximum sum). It\\'s entirely dependent on the array and isn\\'t a fixed length. \\n\\nFor example, consider the array [5, -2, 3]. Here, the subarray with the maximum sum is [5, -2, 3], which has a length of 3. \\n\\nNow, consider the array [-2, 1, -3, 4, -1, 2, 1, -5, 4]. Here, the subarray with the maximum sum is [4, -1, 2, 1], which has a length of 4. \\n\\nIn other words, the subarray with the maximum sum isn\\'t determined by length, but by the sum of its elements."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The idea in simple words:\n\n1. loop through the array and take a note of the **current sum** and the **max sum** so far\n\n2. if the current sum becomes negative, make it 0 and continue to the next iteration\n\n\n**Why make it zero?**\nIf the sum of some numbers becomes negative, no matter how much you keep adding in that sum, it will still be reduced because of that negative effect. Think about what your sum would be if you had no negatives?\n\n**Its kind of tricky to think about this, lets try an example**\n\nAssume your current sum is -3, and you add 500 (the next number in the array) in it. It becomes 497. Not bad! But, what if you ignored that -3? It would be 500 right? And 500 > 497 ;) "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714 GOOGLE\\uD83D\\uDE28 Interview clean code\\uD83E\\uDD73O(n)\\n\\n##### Optimized Kadane\\'s Algorithm considering if all the elements of the array are negative , positive or a mix of both !\\nhttps://leetcode.com/problems/maximum-subarray/solutions/2320036/google-interview-clean-codeon/"
                    },
                    {
                        "username": "Gudun",
                        "content": " int maxSubArray(vector<int>& nums) {\\n        \\n        int currsum=0;\\n        int maxSum=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n            currsum+=nums[i];\\n            maxSum=max(maxSum,currsum);\\n            if(currsum<0){\\n                currsum=0;\\n            }\\n        }\\n        \\n        return maxSum;\\n    }"
                    },
                    {
                        "username": "user6314wG",
                        "content": "Shouldn\\'t this say \"contiguous subarray\"? "
                    },
                    {
                        "username": "AssetDali",
                        "content": "Lol, where did you see not continues array?"
                    }
                ]
            },
            {
                "id": 1675185,
                "content": [
                    {
                        "username": "Deepanshudangi",
                        "content": "Why everytime leetcode shows \"Time Limit Exceeded\"?"
                    },
                    {
                        "username": "MatthewGehring",
                        "content": "Are we to assume an empty array is an allowed sub array? "
                    },
                    {
                        "username": "sild",
                        "content": "Why solution for [-1] input is -1 instead of 0?\nEmpty subarray with sum 0 seems like a correct solution"
                    },
                    {
                        "username": "learningplatform",
                        "content": "I\\'m not sure I understand the question; it requires us to find the largest sum, correct? So we can basically ignore all of the negative figures and add up all of the positive ones? However, the example given is not exactly the same as what I had in mind."
                    },
                    {
                        "username": "abdulsami2",
                        "content": "What if there are only negatives in the array? "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I believe the regular Kadane\\'s Algorithm will take care of it if we initialize the maxSum variable correctly. By this I mean, for Python, I did `maxSum = -float(\\'inf\\')`. Even if all the values are negative, this still works.\\n\\nIf you want to look at the whole code:\\nhttps://leetcode.com/problems/maximum-subarray/submissions/840570081/"
                    },
                    {
                        "username": "Sayali_Berde",
                        "content": "What should be the length of the sub array which has largest sum?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The length of the subarray with the largest sum could be any length between 1 (if a single element is the maximum sum) and the length of the entire array (if all elements contribute to a maximum sum). It\\'s entirely dependent on the array and isn\\'t a fixed length. \\n\\nFor example, consider the array [5, -2, 3]. Here, the subarray with the maximum sum is [5, -2, 3], which has a length of 3. \\n\\nNow, consider the array [-2, 1, -3, 4, -1, 2, 1, -5, 4]. Here, the subarray with the maximum sum is [4, -1, 2, 1], which has a length of 4. \\n\\nIn other words, the subarray with the maximum sum isn\\'t determined by length, but by the sum of its elements."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The idea in simple words:\n\n1. loop through the array and take a note of the **current sum** and the **max sum** so far\n\n2. if the current sum becomes negative, make it 0 and continue to the next iteration\n\n\n**Why make it zero?**\nIf the sum of some numbers becomes negative, no matter how much you keep adding in that sum, it will still be reduced because of that negative effect. Think about what your sum would be if you had no negatives?\n\n**Its kind of tricky to think about this, lets try an example**\n\nAssume your current sum is -3, and you add 500 (the next number in the array) in it. It becomes 497. Not bad! But, what if you ignored that -3? It would be 500 right? And 500 > 497 ;) "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714 GOOGLE\\uD83D\\uDE28 Interview clean code\\uD83E\\uDD73O(n)\\n\\n##### Optimized Kadane\\'s Algorithm considering if all the elements of the array are negative , positive or a mix of both !\\nhttps://leetcode.com/problems/maximum-subarray/solutions/2320036/google-interview-clean-codeon/"
                    },
                    {
                        "username": "Gudun",
                        "content": " int maxSubArray(vector<int>& nums) {\\n        \\n        int currsum=0;\\n        int maxSum=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n            currsum+=nums[i];\\n            maxSum=max(maxSum,currsum);\\n            if(currsum<0){\\n                currsum=0;\\n            }\\n        }\\n        \\n        return maxSum;\\n    }"
                    },
                    {
                        "username": "user6314wG",
                        "content": "Shouldn\\'t this say \"contiguous subarray\"? "
                    },
                    {
                        "username": "AssetDali",
                        "content": "Lol, where did you see not continues array?"
                    }
                ]
            },
            {
                "id": 1674645,
                "content": [
                    {
                        "username": "Deepanshudangi",
                        "content": "Why everytime leetcode shows \"Time Limit Exceeded\"?"
                    },
                    {
                        "username": "MatthewGehring",
                        "content": "Are we to assume an empty array is an allowed sub array? "
                    },
                    {
                        "username": "sild",
                        "content": "Why solution for [-1] input is -1 instead of 0?\nEmpty subarray with sum 0 seems like a correct solution"
                    },
                    {
                        "username": "learningplatform",
                        "content": "I\\'m not sure I understand the question; it requires us to find the largest sum, correct? So we can basically ignore all of the negative figures and add up all of the positive ones? However, the example given is not exactly the same as what I had in mind."
                    },
                    {
                        "username": "abdulsami2",
                        "content": "What if there are only negatives in the array? "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I believe the regular Kadane\\'s Algorithm will take care of it if we initialize the maxSum variable correctly. By this I mean, for Python, I did `maxSum = -float(\\'inf\\')`. Even if all the values are negative, this still works.\\n\\nIf you want to look at the whole code:\\nhttps://leetcode.com/problems/maximum-subarray/submissions/840570081/"
                    },
                    {
                        "username": "Sayali_Berde",
                        "content": "What should be the length of the sub array which has largest sum?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The length of the subarray with the largest sum could be any length between 1 (if a single element is the maximum sum) and the length of the entire array (if all elements contribute to a maximum sum). It\\'s entirely dependent on the array and isn\\'t a fixed length. \\n\\nFor example, consider the array [5, -2, 3]. Here, the subarray with the maximum sum is [5, -2, 3], which has a length of 3. \\n\\nNow, consider the array [-2, 1, -3, 4, -1, 2, 1, -5, 4]. Here, the subarray with the maximum sum is [4, -1, 2, 1], which has a length of 4. \\n\\nIn other words, the subarray with the maximum sum isn\\'t determined by length, but by the sum of its elements."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The idea in simple words:\n\n1. loop through the array and take a note of the **current sum** and the **max sum** so far\n\n2. if the current sum becomes negative, make it 0 and continue to the next iteration\n\n\n**Why make it zero?**\nIf the sum of some numbers becomes negative, no matter how much you keep adding in that sum, it will still be reduced because of that negative effect. Think about what your sum would be if you had no negatives?\n\n**Its kind of tricky to think about this, lets try an example**\n\nAssume your current sum is -3, and you add 500 (the next number in the array) in it. It becomes 497. Not bad! But, what if you ignored that -3? It would be 500 right? And 500 > 497 ;) "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714 GOOGLE\\uD83D\\uDE28 Interview clean code\\uD83E\\uDD73O(n)\\n\\n##### Optimized Kadane\\'s Algorithm considering if all the elements of the array are negative , positive or a mix of both !\\nhttps://leetcode.com/problems/maximum-subarray/solutions/2320036/google-interview-clean-codeon/"
                    },
                    {
                        "username": "Gudun",
                        "content": " int maxSubArray(vector<int>& nums) {\\n        \\n        int currsum=0;\\n        int maxSum=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n            currsum+=nums[i];\\n            maxSum=max(maxSum,currsum);\\n            if(currsum<0){\\n                currsum=0;\\n            }\\n        }\\n        \\n        return maxSum;\\n    }"
                    },
                    {
                        "username": "user6314wG",
                        "content": "Shouldn\\'t this say \"contiguous subarray\"? "
                    },
                    {
                        "username": "AssetDali",
                        "content": "Lol, where did you see not continues array?"
                    }
                ]
            },
            {
                "id": 1672938,
                "content": [
                    {
                        "username": "Deepanshudangi",
                        "content": "Why everytime leetcode shows \"Time Limit Exceeded\"?"
                    },
                    {
                        "username": "MatthewGehring",
                        "content": "Are we to assume an empty array is an allowed sub array? "
                    },
                    {
                        "username": "sild",
                        "content": "Why solution for [-1] input is -1 instead of 0?\nEmpty subarray with sum 0 seems like a correct solution"
                    },
                    {
                        "username": "learningplatform",
                        "content": "I\\'m not sure I understand the question; it requires us to find the largest sum, correct? So we can basically ignore all of the negative figures and add up all of the positive ones? However, the example given is not exactly the same as what I had in mind."
                    },
                    {
                        "username": "abdulsami2",
                        "content": "What if there are only negatives in the array? "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I believe the regular Kadane\\'s Algorithm will take care of it if we initialize the maxSum variable correctly. By this I mean, for Python, I did `maxSum = -float(\\'inf\\')`. Even if all the values are negative, this still works.\\n\\nIf you want to look at the whole code:\\nhttps://leetcode.com/problems/maximum-subarray/submissions/840570081/"
                    },
                    {
                        "username": "Sayali_Berde",
                        "content": "What should be the length of the sub array which has largest sum?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The length of the subarray with the largest sum could be any length between 1 (if a single element is the maximum sum) and the length of the entire array (if all elements contribute to a maximum sum). It\\'s entirely dependent on the array and isn\\'t a fixed length. \\n\\nFor example, consider the array [5, -2, 3]. Here, the subarray with the maximum sum is [5, -2, 3], which has a length of 3. \\n\\nNow, consider the array [-2, 1, -3, 4, -1, 2, 1, -5, 4]. Here, the subarray with the maximum sum is [4, -1, 2, 1], which has a length of 4. \\n\\nIn other words, the subarray with the maximum sum isn\\'t determined by length, but by the sum of its elements."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The idea in simple words:\n\n1. loop through the array and take a note of the **current sum** and the **max sum** so far\n\n2. if the current sum becomes negative, make it 0 and continue to the next iteration\n\n\n**Why make it zero?**\nIf the sum of some numbers becomes negative, no matter how much you keep adding in that sum, it will still be reduced because of that negative effect. Think about what your sum would be if you had no negatives?\n\n**Its kind of tricky to think about this, lets try an example**\n\nAssume your current sum is -3, and you add 500 (the next number in the array) in it. It becomes 497. Not bad! But, what if you ignored that -3? It would be 500 right? And 500 > 497 ;) "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714 GOOGLE\\uD83D\\uDE28 Interview clean code\\uD83E\\uDD73O(n)\\n\\n##### Optimized Kadane\\'s Algorithm considering if all the elements of the array are negative , positive or a mix of both !\\nhttps://leetcode.com/problems/maximum-subarray/solutions/2320036/google-interview-clean-codeon/"
                    },
                    {
                        "username": "Gudun",
                        "content": " int maxSubArray(vector<int>& nums) {\\n        \\n        int currsum=0;\\n        int maxSum=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n            currsum+=nums[i];\\n            maxSum=max(maxSum,currsum);\\n            if(currsum<0){\\n                currsum=0;\\n            }\\n        }\\n        \\n        return maxSum;\\n    }"
                    },
                    {
                        "username": "user6314wG",
                        "content": "Shouldn\\'t this say \"contiguous subarray\"? "
                    },
                    {
                        "username": "AssetDali",
                        "content": "Lol, where did you see not continues array?"
                    }
                ]
            },
            {
                "id": 1671186,
                "content": [
                    {
                        "username": "Deepanshudangi",
                        "content": "Why everytime leetcode shows \"Time Limit Exceeded\"?"
                    },
                    {
                        "username": "MatthewGehring",
                        "content": "Are we to assume an empty array is an allowed sub array? "
                    },
                    {
                        "username": "sild",
                        "content": "Why solution for [-1] input is -1 instead of 0?\nEmpty subarray with sum 0 seems like a correct solution"
                    },
                    {
                        "username": "learningplatform",
                        "content": "I\\'m not sure I understand the question; it requires us to find the largest sum, correct? So we can basically ignore all of the negative figures and add up all of the positive ones? However, the example given is not exactly the same as what I had in mind."
                    },
                    {
                        "username": "abdulsami2",
                        "content": "What if there are only negatives in the array? "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I believe the regular Kadane\\'s Algorithm will take care of it if we initialize the maxSum variable correctly. By this I mean, for Python, I did `maxSum = -float(\\'inf\\')`. Even if all the values are negative, this still works.\\n\\nIf you want to look at the whole code:\\nhttps://leetcode.com/problems/maximum-subarray/submissions/840570081/"
                    },
                    {
                        "username": "Sayali_Berde",
                        "content": "What should be the length of the sub array which has largest sum?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The length of the subarray with the largest sum could be any length between 1 (if a single element is the maximum sum) and the length of the entire array (if all elements contribute to a maximum sum). It\\'s entirely dependent on the array and isn\\'t a fixed length. \\n\\nFor example, consider the array [5, -2, 3]. Here, the subarray with the maximum sum is [5, -2, 3], which has a length of 3. \\n\\nNow, consider the array [-2, 1, -3, 4, -1, 2, 1, -5, 4]. Here, the subarray with the maximum sum is [4, -1, 2, 1], which has a length of 4. \\n\\nIn other words, the subarray with the maximum sum isn\\'t determined by length, but by the sum of its elements."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The idea in simple words:\n\n1. loop through the array and take a note of the **current sum** and the **max sum** so far\n\n2. if the current sum becomes negative, make it 0 and continue to the next iteration\n\n\n**Why make it zero?**\nIf the sum of some numbers becomes negative, no matter how much you keep adding in that sum, it will still be reduced because of that negative effect. Think about what your sum would be if you had no negatives?\n\n**Its kind of tricky to think about this, lets try an example**\n\nAssume your current sum is -3, and you add 500 (the next number in the array) in it. It becomes 497. Not bad! But, what if you ignored that -3? It would be 500 right? And 500 > 497 ;) "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714 GOOGLE\\uD83D\\uDE28 Interview clean code\\uD83E\\uDD73O(n)\\n\\n##### Optimized Kadane\\'s Algorithm considering if all the elements of the array are negative , positive or a mix of both !\\nhttps://leetcode.com/problems/maximum-subarray/solutions/2320036/google-interview-clean-codeon/"
                    },
                    {
                        "username": "Gudun",
                        "content": " int maxSubArray(vector<int>& nums) {\\n        \\n        int currsum=0;\\n        int maxSum=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n            currsum+=nums[i];\\n            maxSum=max(maxSum,currsum);\\n            if(currsum<0){\\n                currsum=0;\\n            }\\n        }\\n        \\n        return maxSum;\\n    }"
                    },
                    {
                        "username": "user6314wG",
                        "content": "Shouldn\\'t this say \"contiguous subarray\"? "
                    },
                    {
                        "username": "AssetDali",
                        "content": "Lol, where did you see not continues array?"
                    }
                ]
            },
            {
                "id": 1668150,
                "content": [
                    {
                        "username": "Deepanshudangi",
                        "content": "Why everytime leetcode shows \"Time Limit Exceeded\"?"
                    },
                    {
                        "username": "MatthewGehring",
                        "content": "Are we to assume an empty array is an allowed sub array? "
                    },
                    {
                        "username": "sild",
                        "content": "Why solution for [-1] input is -1 instead of 0?\nEmpty subarray with sum 0 seems like a correct solution"
                    },
                    {
                        "username": "learningplatform",
                        "content": "I\\'m not sure I understand the question; it requires us to find the largest sum, correct? So we can basically ignore all of the negative figures and add up all of the positive ones? However, the example given is not exactly the same as what I had in mind."
                    },
                    {
                        "username": "abdulsami2",
                        "content": "What if there are only negatives in the array? "
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I believe the regular Kadane\\'s Algorithm will take care of it if we initialize the maxSum variable correctly. By this I mean, for Python, I did `maxSum = -float(\\'inf\\')`. Even if all the values are negative, this still works.\\n\\nIf you want to look at the whole code:\\nhttps://leetcode.com/problems/maximum-subarray/submissions/840570081/"
                    },
                    {
                        "username": "Sayali_Berde",
                        "content": "What should be the length of the sub array which has largest sum?"
                    },
                    {
                        "username": "bparanj",
                        "content": "The length of the subarray with the largest sum could be any length between 1 (if a single element is the maximum sum) and the length of the entire array (if all elements contribute to a maximum sum). It\\'s entirely dependent on the array and isn\\'t a fixed length. \\n\\nFor example, consider the array [5, -2, 3]. Here, the subarray with the maximum sum is [5, -2, 3], which has a length of 3. \\n\\nNow, consider the array [-2, 1, -3, 4, -1, 2, 1, -5, 4]. Here, the subarray with the maximum sum is [4, -1, 2, 1], which has a length of 4. \\n\\nIn other words, the subarray with the maximum sum isn\\'t determined by length, but by the sum of its elements."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "The idea in simple words:\n\n1. loop through the array and take a note of the **current sum** and the **max sum** so far\n\n2. if the current sum becomes negative, make it 0 and continue to the next iteration\n\n\n**Why make it zero?**\nIf the sum of some numbers becomes negative, no matter how much you keep adding in that sum, it will still be reduced because of that negative effect. Think about what your sum would be if you had no negatives?\n\n**Its kind of tricky to think about this, lets try an example**\n\nAssume your current sum is -3, and you add 500 (the next number in the array) in it. It becomes 497. Not bad! But, what if you ignored that -3? It would be 500 right? And 500 > 497 ;) "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2714 GOOGLE\\uD83D\\uDE28 Interview clean code\\uD83E\\uDD73O(n)\\n\\n##### Optimized Kadane\\'s Algorithm considering if all the elements of the array are negative , positive or a mix of both !\\nhttps://leetcode.com/problems/maximum-subarray/solutions/2320036/google-interview-clean-codeon/"
                    },
                    {
                        "username": "Gudun",
                        "content": " int maxSubArray(vector<int>& nums) {\\n        \\n        int currsum=0;\\n        int maxSum=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n            currsum+=nums[i];\\n            maxSum=max(maxSum,currsum);\\n            if(currsum<0){\\n                currsum=0;\\n            }\\n        }\\n        \\n        return maxSum;\\n    }"
                    },
                    {
                        "username": "user6314wG",
                        "content": "Shouldn\\'t this say \"contiguous subarray\"? "
                    },
                    {
                        "username": "AssetDali",
                        "content": "Lol, where did you see not continues array?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Find Minimum in Rotated Sorted Array",
        "question_content": "<p>Suppose an array of length <code>n</code> sorted in ascending order is <strong>rotated</strong> between <code>1</code> and <code>n</code> times. For example, the array <code>nums = [0,1,2,4,5,6,7]</code> might become:</p>\n\n<ul>\n\t<li><code>[4,5,6,7,0,1,2]</code> if it was rotated <code>4</code> times.</li>\n\t<li><code>[0,1,2,4,5,6,7]</code> if it was rotated <code>7</code> times.</li>\n</ul>\n\n<p>Notice that <strong>rotating</strong> an array <code>[a[0], a[1], a[2], ..., a[n-1]]</code> 1 time results in the array <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code>.</p>\n\n<p>Given the sorted rotated array <code>nums</code> of <strong>unique</strong> elements, return <em>the minimum element of this array</em>.</p>\n\n<p>You must write an algorithm that runs in&nbsp;<code>O(log n) time.</code></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,4,5,1,2]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The original array was [1,2,3,4,5] rotated 3 times.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [4,5,6,7,0,1,2]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [11,13,15,17]\n<strong>Output:</strong> 11\n<strong>Explanation:</strong> The original array was [11,13,15,17] and it was rotated 4 times. \n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 5000</code></li>\n\t<li><code>-5000 &lt;= nums[i] &lt;= 5000</code></li>\n\t<li>All the integers of <code>nums</code> are <strong>unique</strong>.</li>\n\t<li><code>nums</code> is sorted and rotated between <code>1</code> and <code>n</code> times.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 158940,
                "title": "beat-100-very-simple-python-very-detailed-explanation",
                "content": "```\\nclass Solution:\\n    def findMin(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # set left and right bounds\\n        left, right = 0, len(nums)-1\\n                \\n        # left and right both converge to the minimum index;\\n        # DO NOT use left <= right because that would loop forever\\n        while left < right:\\n            # find the middle value between the left and right bounds (their average);\\n\\t\\t\\t# can equivalently do: mid = left + (right - left) // 2,\\n\\t\\t\\t# if we are concerned left + right would cause overflow (which would occur\\n\\t\\t\\t# if we are searching a massive array using a language like Java or C that has\\n\\t\\t\\t# fixed size integer types)\\n            mid = (left + right) // 2\\n                        \\n            # the main idea for our checks is to converge the left and right bounds on the start\\n            # of the pivot, and never disqualify the index for a possible minimum value.\\n\\n            # in normal binary search, we have a target to match exactly,\\n            # and would have a specific branch for if nums[mid] == target.\\n            # we do not have a specific target here, so we just have simple if/else.\\n                        \\n            if nums[mid] > nums[right]:\\n                # we KNOW the pivot must be to the right of the middle:\\n                # if nums[mid] > nums[right], we KNOW that the\\n                # pivot/minimum value must have occurred somewhere to the right\\n                # of mid, which is why the values wrapped around and became smaller.\\n\\n                # example:  [3,4,5,6,7,8,9,1,2] \\n                # in the first iteration, when we start with mid index = 4, right index = 9.\\n                # if nums[mid] > nums[right], we know that at some point to the right of mid,\\n                # the pivot must have occurred, which is why the values wrapped around\\n                # so that nums[right] is less then nums[mid]\\n\\n                # we know that the number at mid is greater than at least\\n                # one number to the right, so we can use mid + 1 and\\n                # never consider mid again; we know there is at least\\n                # one value smaller than it on the right\\n                left = mid + 1\\n\\n            else:\\n                # here, nums[mid] <= nums[right]:\\n                # we KNOW the pivot must be at mid or to the left of mid:\\n                # if nums[mid] <= nums[right], we KNOW that the pivot was not encountered\\n                # to the right of middle, because that means the values would wrap around\\n                # and become smaller (which is caught in the above if statement).\\n                # this leaves the possible pivot point to be at index <= mid.\\n                            \\n                # example: [8,9,1,2,3,4,5,6,7]\\n                # in the first iteration, when we start with mid index = 4, right index = 9.\\n                # if nums[mid] <= nums[right], we know the numbers continued increasing to\\n                # the right of mid, so they never reached the pivot and wrapped around.\\n                # therefore, we know the pivot must be at index <= mid.\\n\\n                # we know that nums[mid] <= nums[right].\\n                # therefore, we know it is possible for the mid index to store a smaller\\n                # value than at least one other index in the list (at right), so we do\\n                # not discard it by doing right = mid - 1. it still might have the minimum value.\\n                right = mid\\n                \\n        # at this point, left and right converge to a single index (for minimum value) since\\n        # our if/else forces the bounds of left/right to shrink each iteration:\\n\\n        # when left bound increases, it does not disqualify a value\\n        # that could be smaller than something else (we know nums[mid] > nums[right],\\n        # so nums[right] wins and we ignore mid and everything to the left of mid).\\n\\n        # when right bound decreases, it also does not disqualify a\\n        # value that could be smaller than something else (we know nums[mid] <= nums[right],\\n        # so nums[mid] wins and we keep it for now).\\n\\n        # so we shrink the left/right bounds to one value,\\n        # without ever disqualifying a possible minimum\\n        return nums[left]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findMin(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # set left and right bounds\\n        left, right = 0, len(nums)-1\\n                \\n        # left and right both converge to the minimum index;\\n        # DO NOT use left <= right because that would loop forever\\n        while left < right:\\n            # find the middle value between the left and right bounds (their average);\\n\\t\\t\\t# can equivalently do: mid = left + (right - left) // 2,\\n\\t\\t\\t# if we are concerned left + right would cause overflow (which would occur\\n\\t\\t\\t# if we are searching a massive array using a language like Java or C that has\\n\\t\\t\\t# fixed size integer types)\\n            mid = (left + right) // 2\\n                        \\n            # the main idea for our checks is to converge the left and right bounds on the start\\n            # of the pivot, and never disqualify the index for a possible minimum value.\\n\\n            # in normal binary search, we have a target to match exactly,\\n            # and would have a specific branch for if nums[mid] == target.\\n            # we do not have a specific target here, so we just have simple if/else.\\n                        \\n            if nums[mid] > nums[right]:\\n                # we KNOW the pivot must be to the right of the middle:\\n                # if nums[mid] > nums[right], we KNOW that the\\n                # pivot/minimum value must have occurred somewhere to the right\\n                # of mid, which is why the values wrapped around and became smaller.\\n\\n                # example:  [3,4,5,6,7,8,9,1,2] \\n                # in the first iteration, when we start with mid index = 4, right index = 9.\\n                # if nums[mid] > nums[right], we know that at some point to the right of mid,\\n                # the pivot must have occurred, which is why the values wrapped around\\n                # so that nums[right] is less then nums[mid]\\n\\n                # we know that the number at mid is greater than at least\\n                # one number to the right, so we can use mid + 1 and\\n                # never consider mid again; we know there is at least\\n                # one value smaller than it on the right\\n                left = mid + 1\\n\\n            else:\\n                # here, nums[mid] <= nums[right]:\\n                # we KNOW the pivot must be at mid or to the left of mid:\\n                # if nums[mid] <= nums[right], we KNOW that the pivot was not encountered\\n                # to the right of middle, because that means the values would wrap around\\n                # and become smaller (which is caught in the above if statement).\\n                # this leaves the possible pivot point to be at index <= mid.\\n                            \\n                # example: [8,9,1,2,3,4,5,6,7]\\n                # in the first iteration, when we start with mid index = 4, right index = 9.\\n                # if nums[mid] <= nums[right], we know the numbers continued increasing to\\n                # the right of mid, so they never reached the pivot and wrapped around.\\n                # therefore, we know the pivot must be at index <= mid.\\n\\n                # we know that nums[mid] <= nums[right].\\n                # therefore, we know it is possible for the mid index to store a smaller\\n                # value than at least one other index in the list (at right), so we do\\n                # not discard it by doing right = mid - 1. it still might have the minimum value.\\n                right = mid\\n                \\n        # at this point, left and right converge to a single index (for minimum value) since\\n        # our if/else forces the bounds of left/right to shrink each iteration:\\n\\n        # when left bound increases, it does not disqualify a value\\n        # that could be smaller than something else (we know nums[mid] > nums[right],\\n        # so nums[right] wins and we ignore mid and everything to the left of mid).\\n\\n        # when right bound decreases, it also does not disqualify a\\n        # value that could be smaller than something else (we know nums[mid] <= nums[right],\\n        # so nums[mid] wins and we keep it for now).\\n\\n        # so we shrink the left/right bounds to one value,\\n        # without ever disqualifying a possible minimum\\n        return nums[left]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 48493,
                "title": "compact-and-clean-c-solution",
                "content": "Classic binary search problem. \\n\\nLooking at subarray with index [start,end]. We can find out that if the first member is less than the last member, there's no rotation in the array. So we could directly return the first element in this subarray.\\n\\nIf the first element is larger than the last one, then we compute the element in the middle, and compare it with the first element. If  value of the element in the middle is larger than the first element, we know the rotation is at the second half of this array. Else, it is in the first half in the array.\\n \\nWelcome to put your comments and suggestions.\\n \\n\\n     int findMin(vector<int> &num) {\\n            int start=0,end=num.size()-1;\\n            \\n            while (start<end) {\\n                if (num[start]<num[end])\\n                    return num[start];\\n                \\n                int mid = (start+end)/2;\\n                \\n                if (num[mid]>=num[start]) {\\n                    start = mid+1;\\n                } else {\\n                    end = mid;\\n                }\\n            }\\n            \\n            return num[start];\\n        }\\n\\nSome corner cases will be discussed  [here][1]\\n\\n\\n \\n\\n\\n  [1]: http://changhaz.wordpress.com/2014/10/15/leetcode-find-minimum-in-rotated-sorted-array/",
                "solutionTags": [],
                "code": "Classic binary search problem. \\n\\nLooking at subarray with index [start,end]. We can find out that if the first member is less than the last member, there's no rotation in the array. So we could directly return the first element in this subarray.\\n\\nIf the first element is larger than the last one, then we compute the element in the middle, and compare it with the first element. If  value of the element in the middle is larger than the first element, we know the rotation is at the second half of this array. Else, it is in the first half in the array.\\n \\nWelcome to put your comments and suggestions.\\n \\n\\n     int findMin(vector<int> &num) {\\n            int start=0,end=num.size()-1;\\n            \\n            while (start<end) {\\n                if (num[start]<num[end])\\n                    return num[start];\\n                \\n                int mid = (start+end)/2;\\n                \\n                if (num[mid]>=num[start]) {\\n                    start = mid+1;\\n                } else {\\n                    end = mid;\\n                }\\n            }\\n            \\n            return num[start];\\n        }\\n\\nSome corner cases will be discussed  [here][1]\\n\\n\\n \\n\\n\\n  [1]: http://changhaz.wordpress.com/2014/10/15/leetcode-find-minimum-in-rotated-sorted-array/",
                "codeTag": "Unknown"
            },
            {
                "id": 48484,
                "title": "a-concise-solution-with-proof-in-the-comment",
                "content": "    class Solution {\\n    public:\\n        int findMin(vector<int> &num) {\\n            int low = 0, high = num.size() - 1;\\n            // loop invariant: 1. low < high\\n            //                 2. mid != high and thus A[mid] != A[high] (no duplicate exists)\\n            //                 3. minimum is between [low, high]\\n            // The proof that the loop will exit: after each iteration either the 'high' decreases\\n            // or the 'low' increases, so the interval [low, high] will always shrink.\\n            while (low < high) {\\n                auto mid = low + (high - low) / 2;\\n                if (num[mid] < num[high])\\n                    // the mininum is in the left part\\n                    high = mid;\\n                else if (num[mid] > num[high])\\n                    // the mininum is in the right part\\n                    low = mid + 1;\\n            }\\n    \\n            return num[low];\\n        }\\n    };",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public:\\n        int findMin(vector<int> &num) {\\n            int low = 0, high = num.size() - 1;\\n            // loop invariant: 1. low < high\\n            //                 2. mid != high and thus A[mid] != A[high] (no duplicate exists)\\n            //                 3. minimum is between [low, high]\\n            // The proof that the loop will exit: after each iteration either the 'high' decreases\\n            // or the 'low' increases, so the interval [low, high] will always shrink.\\n            while (low < high) {\\n                auto mid = low + (high - low) / 2;\\n                if (num[mid] < num[high])\\n                    // the mininum is in the left part\\n                    high = mid;\\n                else if (num[mid] > num[high])\\n                    // the mininum is in the right part\\n                    low = mid + 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3176170,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n = nums.size();\\n        int low=0, high=n-1;\\n        \\n        while(low<high){\\n            if(nums[low] <= nums[high]) return nums[low];\\n            int mid = low + (high-low)/2;\\n            if(nums[low] > nums[mid]){\\n                high=mid;\\n            } else if(nums[mid] > nums[high]) {\\n                low=mid+1;\\n            } \\n        }\\n        if(nums[low] <= nums[high]) return nums[low];\\n        return -1;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        l, r = 0, len(nums) - 1\\n\\n        while l < r:\\n            m = l + (r - l)\\n\\n            if nums[m] > nums[r]:\\n                l = m + 1\\n             \\n            else:\\n                 r = m \\n\\n        return nums[l]    \\n```\\n\\n```Java []\\nclass Solution {\\n  public int findMin(int[] nums) {\\n    int l = 0;\\n    int r = nums.length - 1;\\n\\n    while (l < r) {\\n      final int m = (l + r) / 2;\\n      if (nums[m] < nums[r])\\n        r = m;\\n      else\\n        l = m + 1;\\n    }\\n\\n    return nums[l];\\n  }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n = nums.size();\\n        int low=0, high=n-1;\\n        \\n        while(low<high){\\n            if(nums[low] <= nums[high]) return nums[low];\\n            int mid = low + (high-low)/2;\\n            if(nums[low] > nums[mid]){\\n                high=mid;\\n            } else if(nums[mid] > nums[high]) {\\n                low=mid+1;\\n            } \\n        }\\n        if(nums[low] <= nums[high]) return nums[low];\\n        return -1;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        l, r = 0, len(nums) - 1\\n\\n        while l < r:\\n            m = l + (r - l)\\n\\n            if nums[m] > nums[r]:\\n                l = m + 1\\n             \\n            else:\\n                 r = m \\n\\n        return nums[l]    \\n```\n```Java []\\nclass Solution {\\n  public int findMin(int[] nums) {\\n    int l = 0;\\n    int r = nums.length - 1;\\n\\n    while (l < r) {\\n      final int m = (l + r) / 2;\\n      if (nums[m] < nums[r])\\n        r = m;\\n      else\\n        l = m + 1;\\n    }\\n\\n    return nums[l];\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 48487,
                "title": "java-solution-with-binary-search",
                "content": "The minimum element must satisfy one of two conditions: 1) If rotate, A[min] < A[min - 1]; 2) If not, A[0]. Therefore, we can use binary search: check the middle element, if it is less than previous one, then it is minimum. If not, there are 2 conditions as well: If it is greater than both left and right element, then minimum element should be on its right, otherwise on its left.\\n\\n    public class Solution {\\n        public int findMin(int[] num) {\\n            if (num == null || num.length == 0) {\\n                return 0;\\n            }\\n            if (num.length == 1) {\\n                return num[0];\\n            }\\n            int start = 0, end = num.length - 1;\\n            while (start < end) {\\n                int mid = (start + end) / 2;\\n                if (mid > 0 && num[mid] < num[mid - 1]) {\\n                    return num[mid];\\n                }\\n                if (num[start] <= num[mid] && num[mid] > num[end]) {\\n                    start = mid + 1;\\n                } else {\\n                    end = mid - 1;\\n                }\\n            }\\n            return num[start];\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n        public int findMin(int[] num) {\\n            if (num == null || num.length == 0) {\\n                return 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 48499,
                "title": "4ms-simple-c-code-with-explanation",
                "content": "In this problem, we have only three cases. \\n\\nCase 1. The leftmost value is less than the rightmost value in the list: This means that the list is not rotated. \\ne.g>  [1 2 3 4 5 6 7 ]\\n\\nCase 2. The value in the middle of the list is greater than the leftmost and rightmost values in the list. \\ne.g>  [ 4 5 6 7 0 1 2 3 ]\\n\\nCase 3. The value in the middle of the list is less than the leftmost and rightmost values in the list. \\ne.g>  [ 5 6 7 0 1 2 3 4 ]\\n\\nAs you see in the examples above, if we have case 1, we just return the leftmost value in the list. If we have case 2, we just move to the right side of the list. If we have case 3 we need to move to the left side of the list. \\n\\nFollowing is the code that implements the concept described above.\\n\\n    int findMin(vector<int>& nums) {\\n        int left = 0,  right = nums.size() - 1;\\n        while(left < right) {\\n            if(nums[left] < nums[right]) \\n                return nums[left];\\n                \\n            int mid = (left + right)/2;\\n            if(nums[mid] > nums[right])\\n                left = mid + 1;\\n            else\\n                right = mid;\\n        }\\n        \\n        return nums[left];\\n    }",
                "solutionTags": [],
                "code": "In this problem, we have only three cases. \\n\\nCase 1. The leftmost value is less than the rightmost value in the list: This means that the list is not rotated. \\ne.g>  [1 2 3 4 5 6 7 ]\\n\\nCase 2. The value in the middle of the list is greater than the leftmost and rightmost values in the list. \\ne.g>  [ 4 5 6 7 0 1 2 3 ]\\n\\nCase 3. The value in the middle of the list is less than the leftmost and rightmost values in the list. \\ne.g>  [ 5 6 7 0 1 2 3 4 ]\\n\\nAs you see in the examples above, if we have case 1, we just return the leftmost value in the list. If we have case 2, we just move to the right side of the list. If we have case 3 we need to move to the left side of the list. \\n\\nFollowing is the code that implements the concept described above.\\n\\n    int findMin(vector<int>& nums) {\\n        int left = 0,  right = nums.size() - 1;\\n        while(left < right) {\\n            if(nums[left] < nums[right]) \\n                return nums[left];\\n                \\n            int mid = (left + right)/2;\\n            if(nums[mid] > nums[right])\\n                left = mid + 1;\\n            else\\n                right = mid;\\n        }\\n        \\n        return nums[left];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1436502,
                "title": "python-binary-search-with-picture-clean-concise",
                "content": "**Idea**\\n- This is a simple version of this problem [33. Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/).\\n- Firstly, we check edge cases (when index of the minimum number is 0):\\n\\t- If len(nums) == 1 return nums[0]\\n\\t- If nums[0] < nums[n-1] return nums[0]\\n- Binary search, left = 0, right = n-1\\n\\t- mid = (left + right) / 2\\n\\t- If nums[mid-1] > nums[mid] then nums[mid] is the minimum\\n\\t- If nums[mid] > nums[right] then search on the right side, because smaller elements are in the right side\\n\\t- Else search on the left side.\\n\\n![image](https://assets.leetcode.com/users/images/be120c8c-0619-4bbb-86bc-4327d2443d22_1630412938.9456122.png)\\n\\n\\n```python\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        if len(nums) == 1 or nums[0] < nums[-1]:\\n            return nums[0]\\n\\n        left, right = 0, len(nums) - 1\\n        while left <= right:\\n            mid = left + (right - left) // 2\\n            if mid > 0 and nums[mid - 1] > nums[mid]:  # The nums[mid] is the minimum number\\n                return nums[mid]\\n            if nums[mid] > nums[right]:  # search on the right side, because smaller elements are in the right side\\n                left = mid + 1\\n            else:\\n                right = mid - 1  # search the minimum in the left side\\n```\\nComplexity:\\n- Time: `O(logN)`\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        if len(nums) == 1 or nums[0] < nums[-1]:\\n            return nums[0]\\n\\n        left, right = 0, len(nums) - 1\\n        while left <= right:\\n            mid = left + (right - left) // 2\\n            if mid > 0 and nums[mid - 1] > nums[mid]:  # The nums[mid] is the minimum number\\n                return nums[mid]\\n            if nums[mid] > nums[right]:  # search on the right side, because smaller elements are in the right side\\n                left = mid + 1\\n            else:\\n                right = mid - 1  # search the minimum in the left side\\n```",
                "codeTag": "Java"
            },
            {
                "id": 48619,
                "title": "9-line-python-clean-code",
                "content": "Just use binary search\\n\\n    class Solution(object):\\n        def findMin(self, nums):\\n            \"\"\"\\n            :type nums: List[int]\\n            :rtype: int\\n            \"\"\"\\n            i = 0\\n            j = len(nums) - 1\\n            while i < j:\\n                m = i + (j - i) / 2\\n                if nums[m] > nums[j]:\\n                    i = m + 1\\n                else:\\n                    j = m\\n            return nums[i]",
                "solutionTags": [],
                "code": "Just use binary search\\n\\n    class Solution(object):\\n        def findMin(self, nums):\\n            \"\"\"\\n            :type nums: List[int]\\n            :rtype: int\\n            \"\"\"\\n            i = 0\\n            j = len(nums) - 1\\n            while i < j:\\n                m = i + (j - i) / 2\\n                if nums[m] > nums[j]:\\n                    i = m + 1\\n                else:\\n                    j = m\\n            return nums[i]",
                "codeTag": "Java"
            },
            {
                "id": 48486,
                "title": "simplest-and-fastest-c-solution-o-lg-n-you-can-t-beat-this",
                "content": "Binary search: basically eliminate the impossible elements by half each time by exploiting the sorted property.\\n\\n        int findMin(vector<int> &num) {\\n            int lo =0, hi = num.size()-1;\\n            while(lo<hi){\\n                  int mid=(lo+hi)/2;\\n                  if(num[mid]>num[hi]) lo=mid+1;\\n                  else hi=mid;\\n            }\\n            return num[lo];\\n        }",
                "solutionTags": [],
                "code": "Binary search: basically eliminate the impossible elements by half each time by exploiting the sorted property.\\n\\n        int findMin(vector<int> &num) {\\n            int lo =0, hi = num.size()-1;\\n            while(lo<hi){\\n                  int mid=(lo+hi)/2;\\n                  if(num[mid]>num[hi]) lo=mid+1;\\n                  else hi=mid;\\n            }\\n            return num[lo];\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 403413,
                "title": "clean-javascript-solution",
                "content": "```\\nconst findMin = (nums) => {\\n  let l = 0;\\n  let r = nums.length - 1;\\n  while (l < r) {\\n    const m = ~~((l + r) / 2);\\n    if (nums[m] > nums[r]) l = m + 1;\\n    else r = m;\\n  }\\n  return nums[l];\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\nconst findMin = (nums) => {\\n  let l = 0;\\n  let r = nums.length - 1;\\n  while (l < r) {\\n    const m = ~~((l + r) / 2);\\n    if (nums[m] > nums[r]) l = m + 1;\\n    else r = m;\\n  }\\n  return nums[l];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 48589,
                "title": "9-line-java-code-beats-95-14-run-times",
                "content": "if the array is indeed rotated by some pivot, there are only 2 possibilities\\n\\n> 1. a[mid] > a[left] && a[mid] > a[right], meaning we are on the bigger part, the smaller part is on our right, so go right\\n\\n> 2. a[mid] < a[left] && a[mid] < a[right], meaning we are on the smaller part, to find the smallest element, go left\\n\\nif the array is not rotated (actually one rotating cycle completed), we just need to go left, in this case a[mid] < a[right] always holds.\\n\\ncombining the cases above, we conclude that\\n> if a[mid] > a[right], go right; if a[mid] < a[right], go left.\\n\\n    public class Solution {\\n        public int findMin(int[] nums) {\\n            if (nums==null || nums.length==0) { return Integer.MIN_VALUE; } \\n            int left = 0, right = nums.length-1;\\n            while (left < right-1) {  // while (left < right-1) is a useful technique\\n                int mid = left + (right-left)/2;\\n                if (nums[mid] > nums[right]) { left = mid; }\\n                else { right = mid; }\\n            }\\n            if (nums[left] > nums[right]) { return nums[right]; }\\n            return nums[left];\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int findMin(int[] nums) {\\n            if (nums==null || nums.length==0) { return Integer.MIN_VALUE; }",
                "codeTag": "Java"
            },
            {
                "id": 48491,
                "title": "1-2-lines-ruby-python",
                "content": "Use binary search to find the first number that's less than or equal to the last.\\n\\n---\\n\\n**Ruby**\\n\\nDirect translation of the above sentence into Ruby.\\n\\n    def find_min(nums)\\n      nums.bsearch { |num| num <= nums.last }\\n    end\\n\\n---\\n\\n**Python**\\n\\nA little hack.\\n\\n    class Solution:\\n        def findMin(self, nums):\\n            self.__getitem__ = lambda i: nums[i] <= nums[-1]\\n            return nums[bisect.bisect(self, False, 0, len(nums))]",
                "solutionTags": [
                    "Python",
                    "Ruby"
                ],
                "code": "Use binary search to find the first number that's less than or equal to the last.\\n\\n---\\n\\n**Ruby**\\n\\nDirect translation of the above sentence into Ruby.\\n\\n    def find_min(nums)\\n      nums.bsearch { |num| num <= nums.last }\\n    end\\n\\n---\\n\\n**Python**\\n\\nA little hack.\\n\\n    class Solution:\\n        def findMin(self, nums):\\n            self.__getitem__ = lambda i: nums[i] <= nums[-1]\\n            return nums[bisect.bisect(self, False, 0, len(nums))]",
                "codeTag": "Java"
            },
            {
                "id": 48749,
                "title": "my-binary-search-solution-in-python-with-disscussing",
                "content": "    class Solution:\\n        # @param num, a list of integer\\n        # @return an integer\\n        def findMin(self, num):\\n            first, last = 0, len(num) - 1\\n            while first < last:\\n                midpoint = (first + last) // 2\\n                if num[midpoint] > num[last]:\\n                    first = midpoint + 1\\n                else:\\n                    last = midpoint\\n            return num[first]\\n\\nThis solution has a time complexity of O(log(n)) and takes about 50 ms to run.\\nIn python, things are little bit different from the ones in C++ or Java. I am told that each python statement will be translated into one or several c function invocations. So less statements almost always means higher performance. I tried the one line solution \"return min(num)\" in this subject. It is really a system cheating and has a complexity of O(n). But it yields the identical running time as the binary-search solution. I am not sure about the test inputs. However I think we should have some large ones to make the difference (O(n) VS O(log(n))) visible. I guess we need some inputs which have 100 k or even more numbers.",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "    class Solution:\\n        # @param num, a list of integer\\n        # @return an integer\\n        def findMin(self, num):\\n            first, last = 0, len(num) - 1\\n            while first < last:\\n                midpoint = (first + last) // 2\\n                if num[midpoint] > num[last]:\\n                    first = midpoint + 1\\n                else:\\n                    last = midpoint\\n            return num[first]\\n\\nThis solution has a time complexity of O(log(n)) and takes about 50 ms to run.\\nIn python, things are little bit different from the ones in C++ or Java. I am told that each python statement will be translated into one or several c function invocations. So less statements almost always means higher performance. I tried the one line solution \"return min(num)\" in this subject. It is really a system cheating and has a complexity of O(n). But it yields the identical running time as the binary-search solution. I am not sure about the test inputs. However I think we should have some large ones to make the difference (O(n) VS O(log(n))) visible. I guess we need some inputs which have 100 k or even more numbers.",
                "codeTag": "Java"
            },
            {
                "id": 1598369,
                "title": "javascript-solution-using-binary-search-in-o-logn-time-w-explanation",
                "content": "## Explanation\\nMy solution for this problem utilises **Binary Search**. The reason I chose binary search was that the question mentioned that the solution has to have a time complexity of O(logn). The naive method of iterating through the array and updating a variable to keep track of the minimum would be linear, O(n). Since binary search is known to have a time complexity of O(logn) I decided to go down that route.\\n\\nBut how do we use binary search for this problem? Here are the brief steps to my solution:\\n\\n1. Left and right are 2 pointers that keep track of the start and end of the subarray that we are currently searching.\\n\\n2. Within the loop, a mid pointer is calculated to be half the sum of left and right. We then start to compare the value at the mid pointer and the value at the right pointer. From here, there can only be 2 case:\\n\\n\\t(a) nums[mid] > nums[right]\\n\\tFor an un-rotated sorted array, we can easily understand that there can never be a case where nums[mid] would ever be greater than nums[right]. However, this condition can happen in a rotated array if the mid pointer is residing on the left side of the rotated array. Once we know that the mid pointer is at the left side of the array, we can start to cut down our search to only the right side since we know that the minimum value can never be in the left side. Hence, we update the left pointer to be mid + 1, indicating that we are now searching the right side.\\n\\t\\n\\t(b) nums[mid] <= nums[right]\\n\\tThis condition will tell us that the subarray that we are currently searching is now a properly sorted array which is un-rotated. To get the minimum value of this subarray, we simply have to keep adjusting the right pointer to the left by setting the mid pointer as the right pointer, cutting down our serach to only the left half of this subarray. Eventually, we will reach the left most element of this subarray.\\n\\t\\n\\t***Note:*\\n\\t*For a sorted array of [4,5,6,7,0,1,2], the left side refers to the portion of the array on the left of the minimum value [4,5,6,7] and the right side refers to the portion of the array from the minimum value onwards [0,1,2].***\\n\\t\\n3. Lastly, the while loop only ceases once the search is complete (the right and left pointer passes each other). At this point, the answer that we want will lie in nums[left].\\n\\t\\n## Performance\\n\\nThe time complexity of this solution is, **O(logn)**, since at every stage of binary search, we are splitting the array into half.\\n\\nHere are the details of my submission:\\nRuntime: 80 ms, faster than 42.33% \\nMemory Usage: 39.2 MB, less than 29.36% \\n\\n## Code\\n\\n```\\nvar findMin = function(nums) {\\n    var left = 0,\\n        right = nums.length - 1\\n    \\n    while (left < right){\\n        var mid = Math.floor((left + right)/2)\\n        if (nums[mid] > nums[right]) left = mid + 1\\n        else right = mid\\n    }\\n    return nums[left]\\n};\\n```\\n\\nI hope this helps! Do let me know if there are any lapses in my explanation and/or if my solution can be improved in any way :)",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\nvar findMin = function(nums) {\\n    var left = 0,\\n        right = nums.length - 1\\n    \\n    while (left < right){\\n        var mid = Math.floor((left + right)/2)\\n        if (nums[mid] > nums[right]) left = mid + 1\\n        else right = mid\\n    }\\n    return nums[left]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1436293,
                "title": "c-c-simple-and-clean-solution-o-logn-with-comments",
                "content": "**C++:**\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int r = nums.size()-1, l = 0, mid;\\n        if (!r) return nums[0]; // only one element\\n\\n        while (l < r)\\n        {\\n            mid = l + (r - l) / 2;\\n\\n            // got a part that is not rotated\\n            if (nums[l] < nums[r]) return nums[l]; \\n\\n            // mid is larger than right - min is in right side\\n            else if (nums[mid] > nums[r]) l = mid + 1;\\n\\n            // mid is smaller than right - min is in left side (including mid)\\n            else r = mid;\\n        }\\n        return nums[l];\\n    }\\n};\\n```\\n****\\n**C:**\\n```\\nint findMin(int* nums, int numsSize){\\n    int r = numsSize-1, l = 0, mid;\\n    if (!r) return nums[0]; // only one element\\n\\n    while (l < r)\\n    {\\n        mid = l + (r - l) / 2;\\n\\n        // got a part that is not rotated\\n        if (nums[l] < nums[r]) return nums[l]; \\n\\n        // mid is larger than right - min is in right side\\n        else if (nums[mid] > nums[r]) l = mid + 1;\\n\\n        // mid is smaller than right - min is in left side (including mid)\\n        else r = mid;\\n    }\\n    return nums[l];\\n}\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int r = nums.size()-1, l = 0, mid;\\n        if (!r) return nums[0]; // only one element\\n\\n        while (l < r)\\n        {\\n            mid = l + (r - l) / 2;\\n\\n            // got a part that is not rotated\\n            if (nums[l] < nums[r]) return nums[l]; \\n\\n            // mid is larger than right - min is in right side\\n            else if (nums[mid] > nums[r]) l = mid + 1;\\n\\n            // mid is smaller than right - min is in left side (including mid)\\n            else r = mid;\\n        }\\n        return nums[l];\\n    }\\n};\\n```\n```\\nint findMin(int* nums, int numsSize){\\n    int r = numsSize-1, l = 0, mid;\\n    if (!r) return nums[0]; // only one element\\n\\n    while (l < r)\\n    {\\n        mid = l + (r - l) / 2;\\n\\n        // got a part that is not rotated\\n        if (nums[l] < nums[r]) return nums[l]; \\n\\n        // mid is larger than right - min is in right side\\n        else if (nums[mid] > nums[r]) l = mid + 1;\\n\\n        // mid is smaller than right - min is in left side (including mid)\\n        else r = mid;\\n    }\\n    return nums[l];\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1436306,
                "title": "python-recursive-binary-search-explained",
                "content": "In fact this problem is very similar to problem **0033**, but here we need to find not target element, but minimum. We can use exactly the same logic:\\n\\n1. `if nums[end] < nums[mid]`, this means that minimum we are looking for is situated in the right half.\\n2. `elif nums[end] > nums[mid]` means that minimum we are looking for is situated in the left half.\\n3. `if end - start <=  1` means that we have interval of length `1` or `2`, so we can directly check minimum.\\n\\nAlso here I did it in recursive, not iterative way just for the purpose of exercise.\\n\\n#### Complexity\\nIt is `O(log n)` for time and space.\\n\\n#### Code\\n```python\\nclass Solution:    \\n    def findMin(self, nums):\\n        def dfs(start, end):\\n            if end - start <=  1:\\n                return min(nums[start], nums[end])\\n\\n            mid = (start + end)//2\\n            if nums[end] < nums[mid]:\\n                return dfs(mid + 1, end)\\n            elif nums[end] > nums[mid]:\\n                return dfs(start, mid)\\n\\n        return dfs(0, len(nums) - 1)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```python\\nclass Solution:    \\n    def findMin(self, nums):\\n        def dfs(start, end):\\n            if end - start <=  1:\\n                return min(nums[start], nums[end])\\n\\n            mid = (start + end)//2\\n            if nums[end] < nums[mid]:\\n                return dfs(mid + 1, end)\\n            elif nums[end] > nums[mid]:\\n                return dfs(start, mid)\\n\\n        return dfs(0, len(nums) - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 48748,
                "title": "very-simple-java-binary-search",
                "content": "    public class Solution {\\n    public int findMin(int[] num) {\\n        int low = 0;\\n        int high = num.length - 1;\\n        while(low < high){\\n            int mid = (low + high) / 2;\\n            if(num[high] < num[mid]){\\n                low = mid + 1;\\n            } else {\\n                high = mid;\\n            }\\n        }\\n        return num[high];\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public int findMin(int[] num) {\\n        int low = 0;\\n        int high = num.length - 1;\\n        while(low < high){\\n            int mid = (low + high) / 2;\\n            if(num[high] < num[mid]){\\n                low = mid + 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3417980,
                "title": "without-min-comparison-detailed-explanation",
                "content": "# Intuition\\nGiven that we should **us**e **bi**nary **se**arch to **fi**nd **th**e **mi**nimum **el**ement in the **ro**tated **so**rted **ar**ray.\\nAs all binary search problems, we have **tw**o **po**inters: \\'low\\' and \\'high\\', and we find \\'mid\\' using \\'low\\' and \\'high\\'.\\n\\nOur **main objective** here is to find the direction of traversal since we do not have an idea on the number of rotations. \\n\\n# Approach\\n1. Initialize `low = 0 and high = len(nums) - 1`.\\n2. Iterate until `low <= high`.\\n3.  We can find whether the array has been rotated or not using\\n    `nums[low] <= nums[high]` <br>\\nFor example, here the `array is not rotated` and hence nums[low] < nums[high]\\n![Screenshot 2023-04-14 at 9.17.53 PM.png](https://assets.leetcode.com/users/images/61b1d8a3-27fb-4ad1-86fe-08792b9f82a6_1681521526.6889758.png)\\nHere, we see that nums[low] > nums[high]. Therefore, the `array is rotated`.\\n![Screenshot 2023-04-14 at 9.17.59 PM.png](https://assets.leetcode.com/users/images/21248ae2-d8a4-4670-a261-ecce68e9ba17_1681521508.3837793.png)\\n\\n4. If the **ar**ray is **not rotated**, `return nums[low]`.\\n5. If the **ar**ray is **rotated**, we will have to now **fi**nd the **di**rection of **tr**aversal from \\'mid\\'.\\n6. Calculate `mid = (low + high)//2`\\n7. Based on the **c**omparison **be**tween **nums[low]** and **nums[mid]**, we can determine whether we have to move left or right from mid.\\n![Screenshot 2023-04-14 at 9.39.31 PM.png](https://assets.leetcode.com/users/images/e677f3c5-110d-412f-b77e-5197e1579659_1681522824.6154144.png)\\n8. If `nums[low] > nums[mid]: high = mid`\\n9. Else ` low = mid + 1`\\n\\n\\n# Complexity\\n- Time complexity: O(logN)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n\\n        # Initialize low and high\\n        low, high = 0, len(nums) - 1\\n\\n        # Iterate until low <= high\\n        while low <= high:\\n\\n            # Check if the array is not rotated\\n            if nums[low] <= nums[high]:\\n                # Return nums[low] when the array is not rotated\\n                return nums[low]\\n\\n            # Initialize mid if the array is rotated\\n            mid = (low + high)//2\\n\\n            # Check the direction of traversal, \\n            # refer the image for explanation\\n            if nums[low] > nums[mid]:\\n                high = mid\\n            else:\\n                low = mid + 1\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n\\n        # Initialize low and high\\n        low, high = 0, len(nums) - 1\\n\\n        # Iterate until low <= high\\n        while low <= high:\\n\\n            # Check if the array is not rotated\\n            if nums[low] <= nums[high]:\\n                # Return nums[low] when the array is not rotated\\n                return nums[low]\\n\\n            # Initialize mid if the array is rotated\\n            mid = (low + high)//2\\n\\n            # Check the direction of traversal, \\n            # refer the image for explanation\\n            if nums[low] > nums[mid]:\\n                high = mid\\n            else:\\n                low = mid + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1381096,
                "title": "easiest-solution-valid-for-both-duplicate-and-non-duplicate",
                "content": "Time complexity: O(log(n))\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& n) {\\n        int s=0,l=n.size();\\n        int e =l-1;\\n        while(s<e){\\n            int m = s+(e-s)/2;\\n            if(n[m] > n[e]) s=m+1;          // left side has small values (rotated array)\\n            else if(n[m] < n[e]) e=m;       // right side has small value (not rotated)\\n            else e--;                       // mid value equal to end move towards small\\n        }\\n        return n[s];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& n) {\\n        int s=0,l=n.size();\\n        int e =l-1;\\n        while(s<e){\\n            int m = s+(e-s)/2;\\n            if(n[m] > n[e]) s=m+1;          // left side has small values (rotated array)\\n            else if(n[m] < n[e]) e=m;       // right side has small value (not rotated)\\n            else e--;                       // mid value equal to end move towards small\\n        }\\n        return n[s];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 48718,
                "title": "7-line-o-logn-solution",
                "content": "    public int FindMin(int[] nums) {\\n        int left = 0, right = nums.Length - 1, mid = 0;\\n        while(left < right){\\n            mid = (left + right) >> 1;\\n            if(nums[mid] > nums[right]) left = mid + 1;\\n            else right = mid;\\n        }\\n        return nums[right];\\n    }",
                "solutionTags": [
                    "Divide and Conquer"
                ],
                "code": "    public int FindMin(int[] nums) {\\n        int left = 0, right = nums.Length - 1, mid = 0;\\n        while(left < right){\\n            mid = (left + right) >> 1;\\n            if(nums[mid] > nums[right]) left = mid + 1;\\n            else right = mid;\\n        }\\n        return nums[right];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 396767,
                "title": "simple-binary-search",
                "content": "```\\n    def findMin(self, nums: List[int]) -> int:\\n        lo, hi = 0, len(nums)-1\\n        while lo < hi:\\n            mid = (lo+hi)//2\\n            if nums[mid] > nums[hi]:\\n                lo = mid+1\\n            else:\\n                hi = mid\\n        return nums[lo]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def findMin(self, nums: List[int]) -> int:\\n        lo, hi = 0, len(nums)-1\\n        while lo < hi:\\n            mid = (lo+hi)//2\\n            if nums[mid] > nums[hi]:\\n                lo = mid+1\\n            else:\\n                hi = mid\\n        return nums[lo]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 582964,
                "title": "4-solutions-including-divide-and-conquer-binary-search-follow-up",
                "content": "Solutions for 153 (no duplicate): [link](https://www.junhaow.com/lc/problems/binary-search/rotated-sorted-array/153_find-minimum-in-rotated-sorted-array.html)\\n\\nReference: [LeetCode](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/)\\nDifficulty: <span class=\"red\">Hard</span>\\n\\n## Problem\\n\\n> Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.\\n\\n> (i.e., `[0,1,2,4,5,6,7]` might become  `[4,5,6,7,0,1,2]`).\\n\\n> Find the minimum element.\\n\\n> You may assume duplicate exists in the array.\\n\\n**Example:** \\n\\n```cpp\\nInput: [3,4,5,1,2] \\nOutput: 1\\n\\nInput: [2,2,2,0,1]\\nOutput: 0\\n\\nInput: [3,3,3,3]\\nOutput: 3\\n\\nInput: [3,6,3]\\nOutput: 3\\n\\nInput: [3,1,3]\\nOutput: 1\\n```\\n\\n**Follow-up Questions:**\\n\\n- Would allow duplicates affect the run-time complexity? How and why?\\n\\n\\n## Analysis\\n\\nSorting & Brute-Force as in 153.\\n\\n### Divide & Conquer\\n\\nReference: [Huahua](https://www.youtube.com/watch?v=P4r7mF1Jd50&list=PLLuMmzMTgVK5DkeNodml9CHCW4BGxpci7&index=11&t=0s)\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/lw8rc.png)\\n\\nIn the `mid3` case, the result could be calculated in `O(1)`.\\n\\n**Note:** Duplicates affect the run-time complexity. Consider the following case:\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/ogdgx.png)\\n\\n```cpp\\npublic:\\n  int findMin(vector<int>& nums)\\n  {\\n    return findMin(nums, 0, nums.size() - 1);\\n  }\\n\\nprivate:\\n  int findMin(const vector<int>& nums, int lo, int hi)\\n  {\\n    // only one element\\n    if (lo == hi) \\n      return nums[lo];\\n\\n    if (isSorted(nums, lo, hi)) \\n      return nums[lo];\\n    \\n    int mid = lo + (hi - lo) / 2;\\n    int left = findMin(nums, lo, mid);\\n    int right = findMin(nums, mid + 1, hi);\\n    return min(left, right);\\n  }\\n\\n  bool isSorted(const vector<int>& nums, int lo, int hi)\\n  {\\n    return nums[lo] < nums[hi];  // must be < (<= will fail in the case [3, 1, 3])\\n  }\\n```\\n\\n**Time:** `O(\\\\log{N})`\\n- False: `T(N) = 2T(N/2) = O(N)` \\u274C\\n  - At each level, at least one side could be done in `O(1)`.\\n- True: `T(N) = O(1) + T(N/2) = O(\\\\log{N})`\\n\\n**Space:** `O(\\\\log{N})`\\n\\n\\n\\n### Binary Search\\n\\n\\nThe basic idea is that if `nums[mid] >= nums[lo]` we assure that the inflection point is on the right part.\\n\\nHowever, unlike the solution in 153, we need 3 cases:\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/hd1z3.png)\\n\\nRecursion:\\n\\n```cpp\\npublic:\\n  int findMin(vector<int>& nums)\\n  {\\n    return findMin(nums, 0, nums.size() - 1);\\n  }\\n\\nprivate:\\n  int findMin(const vector<int>& nums, int lo, int hi)\\n  {\\n    // only one element\\n    if (lo == hi) \\n      return nums[lo];\\n    \\n    // the subarray is sorted\\n    if (nums[lo] < nums[hi])\\n      return nums[lo];\\n    \\n    int mid = lo + (hi - lo) / 2;\\n\\n    // changes here --> 3 cases\\n    if (nums[mid] > nums[lo])\\n    {\\n      return findMin(nums, mid + 1, hi);\\n    }\\n    else if (nums[mid] < nums[lo])\\n    {\\n      return findMin(nums, lo, mid);\\n    }\\n    else  // nums[mid] == nums[lo]\\n    {\\n      return min(findMin(nums, mid + 1, hi), findMin(nums, lo, mid));\\n    }\\n  }\\n```\\n\\nIteration:\\n\\nInvalid!\\n\\n```cpp\\npublic:\\n  int findMin(vector<int>& nums)\\n  {\\n    int lo = 0;\\n    int hi = nums.size() - 1;\\n    // stops when there is only one element\\n    // in other words, it makes sure that there are at least 2 elements\\n    while (lo < hi)\\n    {\\n      if (nums[lo] < nums[hi]) return nums[lo];\\n      \\n      int mid = lo + (hi - lo) / 2;\\n      if (nums[mid] > nums[lo])\\n      {\\n        lo = mid + 1;\\n      }\\n      else if (nums[mid] > nums[lo])\\n      {\\n        hi = mid;\\n      }\\n      else\\n      {\\n        // ???\\n      }\\n    }\\n    return nums[lo];\\n  }\\n```\\n\\n**Time:** `O(\\\\log{N})`\\n- In the worst case scenario it would become `O(N)`.\\n\\n**Space:** `O(\\\\log{N})`\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Divide and Conquer",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```cpp\\nInput: [3,4,5,1,2] \\nOutput: 1\\n\\nInput: [2,2,2,0,1]\\nOutput: 0\\n\\nInput: [3,3,3,3]\\nOutput: 3\\n\\nInput: [3,6,3]\\nOutput: 3\\n\\nInput: [3,1,3]\\nOutput: 1\\n```\n```cpp\\npublic:\\n  int findMin(vector<int>& nums)\\n  {\\n    return findMin(nums, 0, nums.size() - 1);\\n  }\\n\\nprivate:\\n  int findMin(const vector<int>& nums, int lo, int hi)\\n  {\\n    // only one element\\n    if (lo == hi) \\n      return nums[lo];\\n\\n    if (isSorted(nums, lo, hi)) \\n      return nums[lo];\\n    \\n    int mid = lo + (hi - lo) / 2;\\n    int left = findMin(nums, lo, mid);\\n    int right = findMin(nums, mid + 1, hi);\\n    return min(left, right);\\n  }\\n\\n  bool isSorted(const vector<int>& nums, int lo, int hi)\\n  {\\n    return nums[lo] < nums[hi];  // must be < (<= will fail in the case [3, 1, 3])\\n  }\\n```\n```cpp\\npublic:\\n  int findMin(vector<int>& nums)\\n  {\\n    return findMin(nums, 0, nums.size() - 1);\\n  }\\n\\nprivate:\\n  int findMin(const vector<int>& nums, int lo, int hi)\\n  {\\n    // only one element\\n    if (lo == hi) \\n      return nums[lo];\\n    \\n    // the subarray is sorted\\n    if (nums[lo] < nums[hi])\\n      return nums[lo];\\n    \\n    int mid = lo + (hi - lo) / 2;\\n\\n    // changes here --> 3 cases\\n    if (nums[mid] > nums[lo])\\n    {\\n      return findMin(nums, mid + 1, hi);\\n    }\\n    else if (nums[mid] < nums[lo])\\n    {\\n      return findMin(nums, lo, mid);\\n    }\\n    else  // nums[mid] == nums[lo]\\n    {\\n      return min(findMin(nums, mid + 1, hi), findMin(nums, lo, mid));\\n    }\\n  }\\n```\n```cpp\\npublic:\\n  int findMin(vector<int>& nums)\\n  {\\n    int lo = 0;\\n    int hi = nums.size() - 1;\\n    // stops when there is only one element\\n    // in other words, it makes sure that there are at least 2 elements\\n    while (lo < hi)\\n    {\\n      if (nums[lo] < nums[hi]) return nums[lo];\\n      \\n      int mid = lo + (hi - lo) / 2;\\n      if (nums[mid] > nums[lo])\\n      {\\n        lo = mid + 1;\\n      }\\n      else if (nums[mid] > nums[lo])\\n      {\\n        hi = mid;\\n      }\\n      else\\n      {\\n        // ???\\n      }\\n    }\\n    return nums[lo];\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1536170,
                "title": "beginner-friendly-c-binary-search-solution-o-logn",
                "content": "* Sorted array after rotation will have 2 parts , both sorted in ascending order.\\n   For eg: [1,2,3,4,5] after rotating 2 times will become [4,5,1,2,3].  Here first part is [4,5] and second       part is [1,2,3]. \\n* Basically we have to find first element of second part. \\n* It might also be possible that after several rotations we might get sorted array again. To handle this we\\'ll first check if first element is samller than the last element. If it is so then the array is sorted and will return first element.\\n* We can apply modified version of binary search to solve this question.\\n* We will first find mid , which is (start+end)/2. Then we\\'ll check whether our mid lies in the first part or second.\\n* If nums[mid] >= nums[0] then mid lies in first part otherwise in second part.\\n* If our mid lies in first part then we will make start = mid +1 (since our ans always lies in second part).\\n* If it lies in second part then will update our ans and make end = mid - 1.\\n\\n```\\nint findMin(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n\\t\\t//if size of array is one\\n        if(n==1)\\n            return nums[0];\\n        \\n        //if array is sorted then first element is smallest\\n        if(nums[0] < nums[n-1])\\n            return nums[0];\\n        \\n        int start = 0;\\n        int end = n-1;\\n        \\n        int ans = INT_MAX;\\n        while(start <= end){\\n            \\n            int mid = (start + end) / 2;\\n\\t\\t\\t\\n\\t\\t\\t//if mid is in first part of array\\n            if(nums[mid] >= nums[0])\\n                start = mid +1;\\n            \\n            else\\n            {\\n                ans = min(ans , nums[mid]);\\n                end = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\nTime Complexity : O(logn)\\n\\n***If you like the solution please upvote!***",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nint findMin(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n\\t\\t//if size of array is one\\n        if(n==1)\\n            return nums[0];\\n        \\n        //if array is sorted then first element is smallest\\n        if(nums[0] < nums[n-1])\\n            return nums[0];\\n        \\n        int start = 0;\\n        int end = n-1;\\n        \\n        int ans = INT_MAX;\\n        while(start <= end){\\n            \\n            int mid = (start + end) / 2;\\n\\t\\t\\t\\n\\t\\t\\t//if mid is in first part of array\\n            if(nums[mid] >= nums[0])\\n                start = mid +1;\\n            \\n            else\\n            {\\n                ans = min(ans , nums[mid]);\\n                end = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1529313,
                "title": "java-tc-o-logn-sc-o-1-optimal-binary-search-with-early-exit",
                "content": "```java\\n/**\\n * Modified Binary Search\\n *\\n * Time Complexity: O(log N)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of the input array.\\n */\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        if (nums == null || nums.length == 0) {\\n            throw new IllegalArgumentException(\"Input is invalid\");\\n        }\\n\\n        int len = nums.length;\\n        if (len == 1 || nums[0] < nums[len - 1]) {\\n            return nums[0];\\n        }\\n        if (len == 2) {\\n            return Math.min(nums[0], nums[1]);\\n        }\\n\\n        int start = 0;\\n        int end = len - 1;\\n\\n        while (start < end) {\\n            if (nums[start] < nums[end]) {\\n                return nums[start];\\n            }\\n\\n            int mid = start + (end - start) / 2;\\n            if (nums[mid] <= nums[end]) {\\n                end = mid;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n\\n        return nums[start];\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other Rotated Sorted Array questions on LeetCode:\\n- [33. Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/discuss/1529302/Java-or-TC:-O(logN)-or-SC:-O(1)-or-Modified-Binary-Search-optimal-solution)\\n- [81. Search in Rotated Sorted Array II](https://leetcode.com/problems/search-in-rotated-sorted-array-ii/discuss/1529305/Java-or-TC:-O(N2)-or-SC:-O(1)-or-Modified-Binary-Search-optimal-solution)\\n- [154. Find Minimum in Rotated Sorted Array II + FollowUp](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/discuss/1529323/Java-or-TC:-O(N2)-or-SC:-O(1)-or-Optimal-Binary-Search-w-Early-Exit-and-FollowUp)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Tree"
                ],
                "code": "```java\\n/**\\n * Modified Binary Search\\n *\\n * Time Complexity: O(log N)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of the input array.\\n */\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        if (nums == null || nums.length == 0) {\\n            throw new IllegalArgumentException(\"Input is invalid\");\\n        }\\n\\n        int len = nums.length;\\n        if (len == 1 || nums[0] < nums[len - 1]) {\\n            return nums[0];\\n        }\\n        if (len == 2) {\\n            return Math.min(nums[0], nums[1]);\\n        }\\n\\n        int start = 0;\\n        int end = len - 1;\\n\\n        while (start < end) {\\n            if (nums[start] < nums[end]) {\\n                return nums[start];\\n            }\\n\\n            int mid = start + (end - start) / 2;\\n            if (nums[mid] <= nums[end]) {\\n                end = mid;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n\\n        return nums[start];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1145816,
                "title": "c-binary-search-sol",
                "content": "```\\n      \\n       int findMin(vector<int>& nums) {\\n        \\n        int l = 0,r=nums.size()-1,n=nums.size();\\n        int mid,prev,next;\\n        \\n        while(l<=r){\\n            \\n            mid = l + (r-l)/2;\\n            prev = (mid + n - 1)%n;\\n            next = (mid+1)%n;\\n            \\n            if(nums[mid]<=nums[prev] && nums[mid]<=nums[next])\\n                return nums[mid];\\n            else if(nums[mid]>nums[r])\\n                l = mid+1;\\n            else\\n                r = mid-1;\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\n      \\n       int findMin(vector<int>& nums) {\\n        \\n        int l = 0,r=nums.size()-1,n=nums.size();\\n        int mid,prev,next;\\n        \\n        while(l<=r){\\n            \\n            mid = l + (r-l)/2;\\n            prev = (mid + n - 1)%n;\\n            next = (mid+1)%n;\\n            \\n            if(nums[mid]<=nums[prev] && nums[mid]<=nums[next])\\n                return nums[mid];\\n            else if(nums[mid]>nums[r])\\n                l = mid+1;\\n            else\\n                r = mid-1;\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3348001,
                "title": "100-beats-optimized-java-solutions-clean-and-easy-to-understand-code-look-at-once",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n# ***simple binary search***\\n# Complexity\\n- Time complexity:  O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n\\n        int start = 0, end = nums.length-1;\\n\\n        while(start < end){\\n\\n          int  mid = (start+end) / 2;\\n            if(mid > 0 && nums[mid] < nums[mid-1])\\n             return nums[mid];\\n            if(nums[start] <= nums[mid] && nums[mid] > nums[end])\\n             start = mid + 1;\\n            else\\n             end = mid - 1;\\n        }\\n        return nums[start];\\n    }\\n}\\n```\\nplease upvote this for better solution of other questions![download.jfif](https://assets.leetcode.com/users/images/bf5cd63c-9675-4342-9274-d78b9df40867_1679927428.7317824.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n\\n        int start = 0, end = nums.length-1;\\n\\n        while(start < end){\\n\\n          int  mid = (start+end) / 2;\\n            if(mid > 0 && nums[mid] < nums[mid-1])\\n             return nums[mid];\\n            if(nums[start] <= nums[mid] && nums[mid] > nums[end])\\n             start = mid + 1;\\n            else\\n             end = mid - 1;\\n        }\\n        return nums[start];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2186260,
                "title": "c-no-tension-pure-standard-binary-search-most-intuitive-very-clean",
                "content": "**Runtime : 7ms**\\nClean and very simple \\n\\n**Explanation :** \\n1. If the `nums[mid]` is in the **left hand side**,  then it must be greater than the smallest number in the left hand side, i.e. `nums[0]`. That is `nums[0] <= nums[mid]`. Then we know the minimum number must in the `right side` of mid. So move `low` to `mid + 1`\\n\\n2. If the `nums[mid]` is in the **right hand side**, then it must be no greater than the smallest number in the left hand side, i.e. `nums[0]`. That is `nums[0] > nums[mid]`. Then we know the minimum number must in the `left side of mid`. So move `high` to `mid-1`.\\n\\n**Dry run on below 2 test cases, after this you will be crystal clear with my approach**\\nEx.1\\n`Input: nums = [4,5,6,7,0,1,2]`\\n`Output: 0`\\n\\nEx.2\\n`Input: nums = [2,1]`\\n`Output: 1`\\n\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        \\n\\t\\t// corner case\\n\\t\\tif(nums.size()==1) return nums[0];\\n\\t\\n        // If the array is already sorted then return first element\\n        if(nums[0] < nums[nums.size()-1])\\n            return nums[0];\\n        \\n       // Find the Pivot element\\n        int low=0;\\n        int high=nums.size()-1;\\n        \\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(nums[0] <= nums[mid]) \\n            {\\n                low=mid+1;\\n            }\\n            else\\n            {\\n                high=mid-1;\\n            }\\n        }\\n        return nums[low];\\n    }\\n};\\n```\\n*Thanks for upvoting !*",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        \\n\\t\\t// corner case\\n\\t\\tif(nums.size()==1) return nums[0];\\n\\t\\n        // If the array is already sorted then return first element\\n        if(nums[0] < nums[nums.size()-1])\\n            return nums[0];\\n        \\n       // Find the Pivot element\\n        int low=0;\\n        int high=nums.size()-1;\\n        \\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(nums[0] <= nums[mid]) \\n            {\\n                low=mid+1;\\n            }\\n            else\\n            {\\n                high=mid-1;\\n            }\\n        }\\n        return nums[low];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 895189,
                "title": "python-o-logn-detailed-explanation",
                "content": "#### Idea:\\n\\nWe have an array that have been sorted at some index unknown to us, let\\'s call this index the `inflection point (IP)`.\\n**Side note: You can solve all the rotated array questions using inflection point technique... good for interviews, I\\'ve been asked this question in an onsite interview**\\n\\nWe can identify the IP as: **The only place where arr[IP] > arr[IP + 1] and arr[IP] > arr[IP - 1]**. Basically the only element which is bigger than both left and right elements.\\nLet\\'s take the following array as an example:\\n`[4, 5, 0, 1, 2, 3]`.\\n\\nBased on the characteristics above, we can conclude that `5` is the IP.\\nIn addition, we can see that elements from index `0...IP [0, IP]` and `[IP + 1, n ]` are always increasing, from this we can infer that is it enough for us to compare `min(arr[0], arr[IP + 1])` for our answer.\\n\\n**Edge case**: no inflection point, IP will be the last index. So if IP == n - 1 just return arr[0]\\n\\n#### Algorithm:\\n\\n```\\nclass Solution:\\n    def get_inflection_point(self, A):\\n        n = len(A)\\n        left, right = 0, n - 1\\n        \\n        while left <= right:\\n            mid = left + (right - left) // 2\\n            if mid == n - 1  or A[mid] > A[mid + 1]:\\n                return mid\\n            \\n            # inflection point to right\\n            if A[mid] >= A[left]:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n                \\n        return left\\n        \\n    def findMin(self, A: List[int]) -> int:\\n        n = len(A)\\n        IP = self.get_inflection_point(A)\\n        if IP == n - 1:\\n            return A[0]\\n        \\n        return min(A[0], A[IP + 1])\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def get_inflection_point(self, A):\\n        n = len(A)\\n        left, right = 0, n - 1\\n        \\n        while left <= right:\\n            mid = left + (right - left) // 2\\n            if mid == n - 1  or A[mid] > A[mid + 1]:\\n                return mid\\n            \\n            # inflection point to right\\n            if A[mid] >= A[left]:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n                \\n        return left\\n        \\n    def findMin(self, A: List[int]) -> int:\\n        n = len(A)\\n        IP = self.get_inflection_point(A)\\n        if IP == n - 1:\\n            return A[0]\\n        \\n        return min(A[0], A[IP + 1])\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545223,
                "title": "c-java-python-javascript-time-o-log-n-space-o-1-simple-code-with-explanation",
                "content": "# **Intuition:**\\nThe code aims to find the minimum element in a rotated sorted array. It utilizes the binary search algorithm to efficiently narrow down the search space and locate the minimum element.\\n\\n# **Approach:**\\n1. Initialize two pointers, `left` and `right`, representing the start and end indices of the search space.\\n2. Enter a while loop as long as `left` is less than `right`.\\n3. Calculate the midpoint `mid` using the formula `mid = left + (right - left) / 2`.\\n4. Compare the value at index `mid` with the value at index `right` to determine which half of the array contains the minimum element.\\n   - If `nums[mid] > nums[right]`, it means the minimum element lies in the right half of the array. Update `left = mid + 1` to search in the right half.\\n   - Otherwise, the minimum element lies in the left half of the array, including the `mid` index. Update `right = mid` to search in the left half.\\n5. Repeat steps 3-4 until the search space is narrowed down to a single element, i.e., `left >= right`.\\n6. Return the value at `nums[left]` as the minimum element.\\n\\n# **Complexity:**\\n- Time Complexity: The binary search approach has a time complexity of O(log n), where n is the size of the input array `nums`. The search space is halved in each iteration, leading to efficient searching.\\n- Space Complexity: The code has a space complexity of O(1) as it uses a constant amount of extra space for the variables `left`, `right`, and `mid`. No additional data structures are used that scale with the input size.\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int left = 0;\\n        int right = nums.size() - 1;\\n\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n\\n            if (nums[mid] > nums[right]) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n\\n        return nums[left];\\n    }\\n};\\n\\n```\\n# Java\\n```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        int left = 0;\\n        int right = nums.length - 1;\\n\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n\\n            if (nums[mid] > nums[right]) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n\\n        return nums[left];\\n    }\\n}\\n```\\n# Python\\n```\\nclass Solution(object):\\n    def findMin(self, nums):\\n        left = 0\\n        right = len(nums) - 1\\n\\n        while left < right:\\n            mid = left + (right - left) / 2\\n\\n            if nums[mid] > nums[right]:\\n                left = mid + 1\\n            else:\\n                right = mid\\n\\n        return nums[left]\\n\\n\\n```\\n# JavaScript\\n```\\nvar findMin = function(nums) {\\n    let left = 0;\\n    let right = nums.length - 1;\\n\\n    while (left < right) {\\n        let mid = left + Math.floor((right - left) / 2);\\n\\n        if (nums[mid] > nums[right]) {\\n            left = mid + 1;\\n        } else {\\n            right = mid;\\n        }\\n    }\\n\\n    return nums[left];\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int left = 0;\\n        int right = nums.size() - 1;\\n\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n\\n            if (nums[mid] > nums[right]) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n\\n        return nums[left];\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        int left = 0;\\n        int right = nums.length - 1;\\n\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n\\n            if (nums[mid] > nums[right]) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n\\n        return nums[left];\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def findMin(self, nums):\\n        left = 0\\n        right = len(nums) - 1\\n\\n        while left < right:\\n            mid = left + (right - left) / 2\\n\\n            if nums[mid] > nums[right]:\\n                left = mid + 1\\n            else:\\n                right = mid\\n\\n        return nums[left]\\n\\n\\n```\n```\\nvar findMin = function(nums) {\\n    let left = 0;\\n    let right = nums.length - 1;\\n\\n    while (left < right) {\\n        let mid = left + Math.floor((right - left) / 2);\\n\\n        if (nums[mid] > nums[right]) {\\n            left = mid + 1;\\n        } else {\\n            right = mid;\\n        }\\n    }\\n\\n    return nums[left];\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782169,
                "title": "binary-search-template-solution-intuition-explained-in-detail-video-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhey every one i, have made video playlist for binary search where i discuss a template solution and intuition behind it, this template solution will be very useful as this will help you solve many other questions in binary search this question is the part of that playlist:\\n\\nVideo link for question: https://youtu.be/PJpYFuUVI48\\n\\nPlaylist ink: \\nhttps://youtube.com/playlist?list=PLICVjZ3X1AcYYdde4GTp79zfdp_VACSkX\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int left=0;\\n        int right=nums.size()-1;\\n        while(left<right){\\n            int mid= left + (right-left)/2;\\n            if(nums[mid]<= nums[right]){\\n                right=mid;\\n            }\\n            else{\\n                left=mid+1;\\n            }\\n        }\\n        return nums[left];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int left=0;\\n        int right=nums.size()-1;\\n        while(left<right){\\n            int mid= left + (right-left)/2;\\n            if(nums[mid]<= nums[right]){\\n                right=mid;\\n            }\\n            else{\\n                left=mid+1;\\n            }\\n        }\\n        return nums[left];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3276974,
                "title": "accepted-beats-100-java-c-solution",
                "content": "# Complexity\\n- Time complexity: **O(log n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n````\\n   code in JAVA and C :-\\n````\\n\\n# JAVA :-\\n -- | Details | --\\n--- | --- | ---:\\n**Runtime** | 1ms | Beats **100%**\\n**Memory** | 40MB | Beats **20%**\\n```\\nclass Solution {\\n        public int findMin(int[] A) {\\n        final int N = A.length;\\n        if(N == 1) return A[0];\\n        int start = 0, end = N-1, mid;\\n        while(start < end){\\n            mid = (start+end) / 2;\\n            if(mid > 0 && A[mid] < A[mid-1]) return A[mid];\\n            if(A[start] <= A[mid] && A[mid] > A[end]) start = mid + 1;\\n            else end = mid - 1;\\n        }\\n        return A[start];\\n    }\\n}\\n```\\n# C :-\\n -- | Details | --\\n--- | --- | ---:\\n**Runtime** | 1ms | Beats **100%**\\n**Memory** | 6MB | Beats **30%**\\n```\\nint findMin(int* A, int N){\\n    if(N == 1) return A[0];\\n    int start = 0, end = N-1, mid;\\n    while(start < end){\\n        mid = (start+end) / 2;\\n        if(mid > 0 && A[mid] < A[mid-1]) return A[mid];\\n        if(A[start] <= A[mid] && A[mid] > A[end]) start = mid + 1;\\n        else end = mid - 1;\\n    }\\n    return A[start];\\n}\\n```\\n## Please UPVOTE : |\\n![waiting-tom-and-jerry.gif](https://assets.leetcode.com/users/images/4f0cc754-71e1-4cfc-816b-36a94c20b17f_1678366238.9546802.gif)",
                "solutionTags": [
                    "Java",
                    "C",
                    "Array",
                    "Binary Search"
                ],
                "code": "````\\n   code in JAVA and C :-\\n```\n```\\nclass Solution {\\n        public int findMin(int[] A) {\\n        final int N = A.length;\\n        if(N == 1) return A[0];\\n        int start = 0, end = N-1, mid;\\n        while(start < end){\\n            mid = (start+end) / 2;\\n            if(mid > 0 && A[mid] < A[mid-1]) return A[mid];\\n            if(A[start] <= A[mid] && A[mid] > A[end]) start = mid + 1;\\n            else end = mid - 1;\\n        }\\n        return A[start];\\n    }\\n}\\n```\n```\\nint findMin(int* A, int N){\\n    if(N == 1) return A[0];\\n    int start = 0, end = N-1, mid;\\n    while(start < end){\\n        mid = (start+end) / 2;\\n        if(mid > 0 && A[mid] < A[mid-1]) return A[mid];\\n        if(A[start] <= A[mid] && A[mid] > A[end]) start = mid + 1;\\n        else end = mid - 1;\\n    }\\n    return A[start];\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2939435,
                "title": "binary-search-java-0ms-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        int start = 0, end = nums.length - 1;\\n        while(start < end)\\n        {\\n          int mid = start + (end -start) / 2;\\n          if(nums[mid] > nums[end])\\n          start = mid + 1 ;\\n          \\n          if(nums[mid] < nums[end])\\n          end = mid ;\\n        }\\n        return nums[start];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        int start = 0, end = nums.length - 1;\\n        while(start < end)\\n        {\\n          int mid = start + (end -start) / 2;\\n          if(nums[mid] > nums[end])\\n          start = mid + 1 ;\\n          \\n          if(nums[mid] < nums[end])\\n          end = mid ;\\n        }\\n        return nums[start];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1765455,
                "title": "easy-c-solution",
                "content": "Considering the first element of the vector as the minimum value, we start the binary search.\\nNow, if ```v[mid] < min``` it means the right side of ```mid``` is sorted and the minimum value must be at the left side or ```mid``` is the minimum value. So we set ```min = v[mid];``` and continue searching on the left side.\\nAnd if not then it means the left side of  ```mid``` is sorted and we need to search on the rights side.\\n\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& v) \\n    {\\n        int min = v[0];\\n        int low = 0;\\n        int high = v.size() - 1;\\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            if(v[mid] < min)\\n            {\\n                min = v[mid];\\n                high = mid - 1;\\n            }\\n            else\\n                low = mid + 1;    \\n        }\\n        return min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```v[mid] < min```\n```mid```\n```mid```\n```min = v[mid];```\n```mid```\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& v) \\n    {\\n        int min = v[0];\\n        int low = 0;\\n        int high = v.size() - 1;\\n        while(low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            if(v[mid] < min)\\n            {\\n                min = v[mid];\\n                high = mid - 1;\\n            }\\n            else\\n                low = mid + 1;    \\n        }\\n        return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1600529,
                "title": "153-find-minimum-in-rotated-sorted-array",
                "content": "![image](https://assets.leetcode.com/users/images/e29110cd-d07c-4691-8e4b-7d457bd57413_1638089867.2077987.png)\\n\\n       int lo = 0, hi = nums.size() - 1; \\n\\t   int Mn = 1e5;\\n        while (lo <= hi)\\n        {\\n            int m = lo + (hi - lo) / 2;\\n\\n            if(nums[0] > nums[nums.size()-1]){\\n                if(nums[m] >= nums[0]){\\n                    lo = m + 1;\\n                }\\n                else\\n                {\\n                    hi = m - 1;\\n                }\\n                Mn = min(Mn, nums[m]);\\n            }\\n            else\\n            { // when array  is sorted in increasing order\\n                return nums[0];\\n            }\\n        }\\n\\n        return Mn;\\n    }",
                "solutionTags": [
                    "Array",
                    "Binary Tree"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/e29110cd-d07c-4691-8e4b-7d457bd57413_1638089867.2077987.png)\\n\\n       int lo = 0, hi = nums.size() - 1; \\n\\t   int Mn = 1e5;\\n        while (lo <= hi)\\n        {\\n            int m = lo + (hi - lo) / 2;\\n\\n            if(nums[0] > nums[nums.size()-1]){\\n                if(nums[m] >= nums[0]){\\n                    lo = m + 1;\\n                }\\n                else\\n                {\\n                    hi = m - 1;\\n                }\\n                Mn = min(Mn, nums[m]);\\n            }\\n            else\\n            { // when array  is sorted in increasing order\\n                return nums[0];\\n            }\\n        }\\n\\n        return Mn;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2681335,
                "title": "java-solution-fastest-and-easiest-solution-on-the-internet",
                "content": "\\'\\'\\'\\n\\t\\t\\n\\tclass Solution {\\n\\t\\tpublic int findMin(int[] nums) {\\n       \\n\\t\\tint start = 0;\\n        int end = nums.length -1;\\n        \\n            while (start <= end) {\\n                int mid = start + (end - start)/2;\\n\\t\\t\\t\\t\\n                if (mid < end && nums[mid] > nums[mid + 1])\\n                    return nums[mid + 1];     // greater index holds the min element in the array\\n                if (start < mid && nums[mid - 1] > nums[mid] )\\n                    return nums[mid];     //  greater index holds the min element in the array\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\tif (nums[start] > nums[mid])    // search in the left half \\n                    end = mid - 1;\\n                else    // search in the right half\\n                    start = mid + 1;\\n            } \\n        return nums[0];\\n\\t\\t}\\n\\t}\\n\\'\\'\\'\\t\\n*Logic : Return nums[pivot + 1] or return nums[0] if array is sorted.*\\n\\nTime complexity - O(logn)\\nSpace complexity - O(1)\\n\\n\\n1. Apply Binary Search for best time complexity of O(logn).\\n2. Find and return nums[pivot + 1]\\n3. If no pivot exists, array is sorted, simply return the first element of the array.\\n\\n\\nWhat is this pivot?\\nIt is the index where the existing element and the next element do not follow the order of the array, if its ascending then the element at pivot index and pivot + 1 index will be descending and vice versa.\\n\\nIt is usually the index of the largest element in asc rotated sorted array and index of the smallest number in desc rotated sorted array.\\nFor example in\\n\\'\\'\\'\\n\\t\\t\\n\\t\\t// rotated asc array\\n\\t\\tarrary1 = {3, 4, 5, 1, 2} \\n\\t\\t// pivot index is 3 where the largest element lies.\\n\\t\\t\\n\\t\\t// rotated desc array\\n\\t\\tarray2 = {7, 6, 10, 9, 8}\\n\\t\\t// pivot index is 1 where the smallest element lies.\\n\\'\\'\\'\\nConsider a given array\\n\\'\\'\\'\\n\\t\\t\\t\\n\\tint arr[] = {4,5,6,7,0,1,2}\\n\\t// here pivot is the 3rd index\\n\\t// the minimum element is next the pivot index i.e 4th index and element is 0 which is the minimum\\n\\tint arr2[] = {1, 2, 3, 4, 5}\\n\\t// here we do not have a pivot, array is sorted just return the first element i.e. 1 which is the minimum.\\n\\'\\'\\'\\n\\nNow lets find the pivot and return the next element after the pivot index as this will be the minimum element in the array.\\n\\n4 Cases to find pivot index\\n\\n\\'\\'\\'\\n\\t\\t\\t\\n\\tif nums[mid] > nums[mid +1]\\n\\t\\treturn nums[mid + 1]; // since nums[pivot + 1] is the minimum element in the array\\n\\tif nums[mid - 1] > nums[mid]\\n\\t\\treturn nums[mid];\\n\\tif nums[start] > nums[mid] // search in the left half\\n\\t\\tend = mid - 1;\\n\\telse // search in the right half\\n\\t\\tstart = mid + 1;\\n\\'\\'\\'\\n\\nWe can solve this question even in linear time, there is no harm in giving it a try.\\nNote ** Linear Search vs Binary Search-\\n\\n**For every million comparisions in linear search there is only 19 comparisions in binary search in worst case senarios. Binary Search is very efficient specially with greater i/p size.**\\n\\n\\'\\'\\'\\n\\t\\n\\tpublic class Main{\\n\\t\\tpublic int findMin(int[] nums) {\\n\\t\\t\\t\\n\\t\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\t\\tif (nums[i] > nums[i+1]) {  // checking for flaws ie different order.\\n\\t\\t\\t\\t\\treturn nums[i+1];     // min element lie after the max element\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn nums[0];     // if array is not rotated\\n\\t\\t}\\n\\t}\\n\\t\\n\\'\\'\\'\\n\\n*Logic - Iterate through the array try to find an anomaly and return the i + 1 index which holds the min element in the array.*\\nTime Complexity - O(n)\\nSpace Complexity - O(1)\\n**********************************************\\n\\nConsider to upvote, if you found it helpful :}**\\n\\nHappy Coding!!\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n\\t\\tpublic int findMin(int[] nums) {\\n       \\n\\t\\tint start = 0;\\n        int end = nums.length -1;\\n        \\n            while (start <= end) {\\n                int mid = start + (end - start)/2;\\n\\t\\t\\t\\t\\n                if (mid < end && nums[mid] > nums[mid + 1])\\n                    return nums[mid + 1];     // greater index holds the min element in the array\\n                if (start < mid && nums[mid - 1] > nums[mid] )\\n                    return nums[mid];     //  greater index holds the min element in the array\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\tif (nums[start] > nums[mid])    // search in the left half \\n                    end = mid - 1;\\n                else    // search in the right half\\n                    start = mid + 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2374842,
                "title": "c-4-ms-easy-solution-explained-by-aditya-verma-ji",
                "content": "\\n    \\n\\t\\n\\t/*Solution explained by aditya verma:\\n\\tCode explanation:\\n\\tSince our aim is to find the element in a rotated sorted array... the code when done by \\n\\tsorting and returning the first element will also get accepted or traversing the vector and \\n\\treturning the minimum will also get accepted but the complexities will be O(nlogn) and \\n\\tO(n) respectively. But we have to write a solution of O(logn) time complexity....\\n\\tSo here we are comparing the mid with its previous and next element (so when a element with \\n\\tminimum value should be less than both the next and previous if that is the case we will return \\n\\tthe mid or else as we can see in video we have to move to unsorted side so compare the mid with \\n\\tits start if nums[start]<=nums[mid] we will move to the other side or else if \\n\\tnums[mid]<=nums[end]  so move to the area of [start.....mid-1].\\n\\t*/\\n\\t/*****but aditya ji forgot to mention this point that is if nums[start]<nums[end] that is vector\\n\\tis already sorted we return the first element as it will be the minimum.***/\\n\\t/*So when this condition is added the solution will get accepted and its time complexity will be\\n\\tO(logn)*/\\n\\t\\n\\tint n=nums.size();\\n        int start=0;\\n        int end=n-1;\\t\\n        while(start<=end){\\n            if(nums[start]<nums[end]) return nums[start];\\n            int mid=start+(end-start)/2;\\n            int next=(mid+1)%n;\\n            int prev=(mid-1+n)%n;\\n            if(nums[mid]<=nums[end] && nums[mid]<=nums[prev]){\\n                return nums[mid];\\n            }\\n             if(nums[start]<=nums[mid]){\\n                start=mid+1;\\n            }\\n            if(nums[mid]<=nums[end]){\\n                end=mid-1;\\n            }\\n        }\\n        return 0;\\n            \\n            /*THANKS FOR YOUR VIEW*/",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "\\n    \\n\\t\\n\\t/*Solution explained by aditya verma:\\n\\tCode explanation:\\n\\tSince our aim is to find the element in a rotated sorted array... the code when done by \\n\\tsorting and returning the first element will also get accepted or traversing the vector and \\n\\treturning the minimum will also get accepted but the complexities will be O(nlogn) and \\n\\tO(n) respectively. But we have to write a solution of O(logn) time complexity....\\n\\tSo here we are comparing the mid with its previous and next element (so when a element with \\n\\tminimum value should be less than both the next and previous if that is the case we will return \\n\\tthe mid or else as we can see in video we have to move to unsorted side so compare the mid with \\n\\tits start if nums[start]<=nums[mid] we will move to the other side or else if \\n\\tnums[mid]<=nums[end]  so move to the area of [start.....mid-1].\\n\\t*/\\n\\t/*****but aditya ji forgot to mention this point that is if nums[start]<nums[end] that is vector\\n\\tis already sorted we return the first element as it will be the minimum.***/\\n\\t/*So when this condition is added the solution will get accepted and its time complexity will be\\n\\tO(logn)*/\\n\\t\\n\\tint n=nums.size();\\n        int start=0;\\n        int end=n-1;\\t\\n        while(start<=end){\\n            if(nums[start]<nums[end]) return nums[start];\\n            int mid=start+(end-start)/2;\\n            int next=(mid+1)%n;\\n            int prev=(mid-1+n)%n;\\n            if(nums[mid]<=nums[end] && nums[mid]<=nums[prev]){\\n                return nums[mid];\\n            }\\n             if(nums[start]<=nums[mid]){\\n                start=mid+1;\\n            }\\n            if(nums[mid]<=nums[end]){\\n                end=mid-1;\\n            }\\n        }\\n        return 0;\\n            \\n            /*THANKS FOR YOUR VIEW*/",
                "codeTag": "Unknown"
            },
            {
                "id": 48663,
                "title": "c-two-pointer-solution",
                "content": "\\n    int findMin(vector<int>& nums) {\\n        int l = 0, r = nums.size()-1;\\n        while (l < r) {\\n            int mid = (r-l)/2 + l;\\n            if (nums[mid] < nums[r])\\n                r = mid;\\n            else\\n                l = mid + 1;\\n        }\\n        return nums[l];\\n    }",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "\\n    int findMin(vector<int>& nums) {\\n        int l = 0, r = nums.size()-1;\\n        while (l < r) {\\n            int mid = (r-l)/2 + l;\\n            if (nums[mid] < nums[r])\\n                r = mid;\\n            else\\n                l = mid + 1;\\n        }\\n        return nums[l];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3208253,
                "title": "153-beats-91-70-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis solution also uses binary search to find the minimum element in the rotated sorted array. It initializes two pointers, left and right, to the beginning and end of the array, respectively. It then repeatedly compares the element at the midpoint of the array to the element at the end of the array, and updates the pointers accordingly until the minimum element is found.\\n\\nThe time complexity of this solution is O(log n), since binary search is used. The space complexity is O(1), since only constant space is used.\\n\\n# Complexity\\n- Time complexity:\\nBeats\\nBeats\\n55.81%\\n\\n- Space complexity:\\nBeats\\n55.81%\\n\\n# Code\\n```\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        left, right = 0, len(nums) - 1\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if nums[mid] > nums[right]:\\n                left = mid + 1\\n            else:\\n                right = mid\\n        return nums[left]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        left, right = 0, len(nums) - 1\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if nums[mid] > nums[right]:\\n                left = mid + 1\\n            else:\\n                right = mid\\n        return nums[left]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3102007,
                "title": "best-o-logn-solution",
                "content": "# Approach 1\\nSorting\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        sort (nums.begin(), nums.end());\\n        return nums[0];\\n    }\\n};\\n```\\n# Approach 2\\nLinear Search\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int minVal = nums[0];\\n        for (int i = 1; i < nums.size(); i++)\\n            minVal = min (nums[i], minVal);\\n        return minVal;\\n    }\\n};\\n```\\n\\n# Approach 3\\nBinary Search\\n\\n# Complexity\\n- Time complexity:\\n$$O(logn)$$\\n\\n- Space complexity:\\n$$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1)\\n            return nums[0];\\n        if (nums[0] < nums[n - 1])\\n            return nums[0];\\n        int low = 0, high = n - 1;\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n            if (nums[mid] > nums[mid + 1])\\n                return nums[mid + 1];\\n            if (nums[mid] < nums[mid - 1])\\n                return nums[mid];   \\n            if (nums[low] < nums[mid])\\n                low = mid + 1;\\n            else if (nums[high] > nums[mid])\\n                high = mid - 1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        sort (nums.begin(), nums.end());\\n        return nums[0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int minVal = nums[0];\\n        for (int i = 1; i < nums.size(); i++)\\n            minVal = min (nums[i], minVal);\\n        return minVal;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n == 1)\\n            return nums[0];\\n        if (nums[0] < nums[n - 1])\\n            return nums[0];\\n        int low = 0, high = n - 1;\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n            if (nums[mid] > nums[mid + 1])\\n                return nums[mid + 1];\\n            if (nums[mid] < nums[mid - 1])\\n                return nums[mid];   \\n            if (nums[low] < nums[mid])\\n                low = mid + 1;\\n            else if (nums[high] > nums[mid])\\n                high = mid - 1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1436580,
                "title": "java-binary-search-easy-to-understand-faster-than-100",
                "content": "**Solution  1:**\\n```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n         int low = 0;\\n        int high = nums.length-1;\\n       \\n        while(low < high){\\n          \\n          int mid = low + (high-low) / 2;\\n          if(nums[mid] < nums[high])\\n              high = mid;\\n          else  \\n              low = mid+1;\\n        \\n        }\\n      return nums[low];\\n    }\\n}\\n```\\n\\n**Solution 2 :**\\n\\n```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        int low=0;\\n        int high=nums.length-1;\\n        while(low < high)\\n       {\\n            int mid = low + (high - low) / 2;\\n            if (nums[mid] ==nums[high])\\n                high--;\\n\\n            else if(nums[mid] > nums[high])\\n                low = mid + 1;\\n            else\\n                high = mid;\\n         }\\n        return nums[high];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n         int low = 0;\\n        int high = nums.length-1;\\n       \\n        while(low < high){\\n          \\n          int mid = low + (high-low) / 2;\\n          if(nums[mid] < nums[high])\\n              high = mid;\\n          else  \\n              low = mid+1;\\n        \\n        }\\n      return nums[low];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        int low=0;\\n        int high=nums.length-1;\\n        while(low < high)\\n       {\\n            int mid = low + (high - low) / 2;\\n            if (nums[mid] ==nums[high])\\n                high--;\\n\\n            else if(nums[mid] > nums[high])\\n                low = mid + 1;\\n            else\\n                high = mid;\\n         }\\n        return nums[high];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 48646,
                "title": "5-lines-c-implementation",
                "content": "    class Solution {\\n    public:\\n        int findMin(vector<int>& nums) {\\n            int start=0, end=nums.size()-1;\\n            while(end>start){\\n                int mid=start+(end-start)/2;\\n                if(nums[mid]<nums[end]) end=mid;\\n                else start=mid+1;\\n            }\\n            return nums[start];\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int findMin(vector<int>& nums) {\\n            int start=0, end=nums.size()-1;\\n            while(end>start){\\n                int mid=start+(end-start)/2;\\n                if(nums[mid]<nums[end]) end=mid;\\n                else start=mid+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3142831,
                "title": "easy-c-solution-binary-search-linear-search-brute-force-optimize",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can Solved this question using Two approach.\\n\\n1. Using Linear Search (Brute Force).\\n2. Using Binary Search (Optimize).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the All the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N),  because we traversed over all the elements in the array, which has allowed us to\\n    achieve a linear time complexity.\\n\\n    Space Complexity : O(1), the algorithm itself takes constant space but the program as a whole takes linear\\n    space because of storing the input array.\\n\\n    Using Array + Linear Search. \\n\\n*/\\n\\n\\n/***************************************** Approach 1 First Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n = nums.size();\\n        int minimum = nums[0];\\n        for(int i=1; i<n; i++){\\n            minimum = min(nums[i], minimum);\\n        }\\n        return minimum;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/***************************************** Approach 1 Second Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n = nums.size();\\n        for(int i=0; i<n-1; i++){\\n            if(nums[i] > nums[i+1]){\\n                return nums[i+1];\\n            }\\n        }\\n        return nums[0];\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(log N) where N is the number of elements in the input array. Here we used binary search\\n    which takes logarithmic time complexity. All of this possible because the array was initially sorted.\\n\\n    Space Complexity : O(1), this approach takes also constant time but the program as a whole takes O(N) space\\n    because of the space required to store the input.\\n\\n    Using Array + Binary Search.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 First Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int low = 0;\\n        int high = nums.size()-1;\\n        while(low < high){\\n            int mid = low + (high-low)/2;\\n            if(nums[mid] < nums[high]){\\n                high = mid;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n        return nums[low];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N),  because we traversed over all the elements in the array, which has allowed us to\\n    achieve a linear time complexity.\\n\\n    Space Complexity : O(1), the algorithm itself takes constant space but the program as a whole takes linear\\n    space because of storing the input array.\\n\\n    Using Array + Linear Search. \\n\\n*/\\n\\n\\n/***************************************** Approach 1 First Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n = nums.size();\\n        int minimum = nums[0];\\n        for(int i=1; i<n; i++){\\n            minimum = min(nums[i], minimum);\\n        }\\n        return minimum;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/***************************************** Approach 1 Second Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n = nums.size();\\n        for(int i=0; i<n-1; i++){\\n            if(nums[i] > nums[i+1]){\\n                return nums[i+1];\\n            }\\n        }\\n        return nums[0];\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(log N) where N is the number of elements in the input array. Here we used binary search\\n    which takes logarithmic time complexity. All of this possible because the array was initially sorted.\\n\\n    Space Complexity : O(1), this approach takes also constant time but the program as a whole takes O(N) space\\n    because of the space required to store the input.\\n\\n    Using Array + Binary Search.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 First Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int low = 0;\\n        int high = nums.size()-1;\\n        while(low < high){\\n            int mid = low + (high-low)/2;\\n            if(nums[mid] < nums[high]){\\n                high = mid;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n        return nums[low];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629626,
                "title": "java-binary-search",
                "content": "```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        int n = nums.length;\\n        int start = 0;\\n        int end = n-1;\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            if(nums[mid]<nums[end]){\\n                end = mid;\\n            }else{\\n                start = mid+1;\\n            }\\n        }\\n        return nums[end];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        int n = nums.length;\\n        int start = 0;\\n        int end = n-1;\\n        while(start<=end){\\n            int mid = start + (end-start)/2;\\n            if(nums[mid]<nums[end]){\\n                end = mid;\\n            }else{\\n                start = mid+1;\\n            }\\n        }\\n        return nums[end];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1399277,
                "title": "c-binary-search-100-faster",
                "content": "Please upvote if it helped you.\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint findMin(vector<int>& nums) {\\n\\n\\t\\t\\tint first = 0; \\n\\t\\t\\tint last = nums.size() - 1; \\n\\t\\t\\tint ans = INT_MAX; \\n\\n\\t\\t\\twhile(first <= last){\\n\\n\\t\\t\\t\\tint mid = first + (last - first) / 2; \\n\\n\\t\\t\\t\\tif(ans >= nums[mid])  ans = nums[mid]; \\n\\n\\t\\t\\t\\tif(nums[mid] > nums[last]) first = mid + 1; \\n\\n\\t\\t\\t\\telse last = mid - 1; \\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans; \\n\\t\\t}\\n\\t};\\nThank You !!",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint findMin(vector<int>& nums) {\\n\\n\\t\\t\\tint first = 0; \\n\\t\\t\\tint last = nums.size() - 1; \\n\\t\\t\\tint ans = INT_MAX; \\n\\n\\t\\t\\twhile(first <= last){\\n\\n\\t\\t\\t\\tint mid = first + (last - first) / 2; \\n\\n\\t\\t\\t\\tif(ans >= nums[mid])  ans = nums[mid]; \\n\\n\\t\\t\\t\\tif(nums[mid] > nums[last]) first = mid + 1; \\n\\n\\t\\t\\t\\telse last = mid - 1; \\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1208648,
                "title": "easiest-and-best-c-solution-beats-100-submissions",
                "content": "```\\n int findMin(vector<int>& nums) {\\n        int s = 0;\\n        int e = nums.size()-1;\\n        int mid;\\n        \\n        while(s<=e){\\n            mid = (s+e)/2;\\n            \\n            if(nums[mid] >= nums[e]){\\n                s = mid+1;\\n            }\\n            else{\\n                e = mid;\\n            }\\n        }\\n        return nums[mid];\\n        \\n    }\\n```\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n int findMin(vector<int>& nums) {\\n        int s = 0;\\n        int e = nums.size()-1;\\n        int mid;\\n        \\n        while(s<=e){\\n            mid = (s+e)/2;\\n            \\n            if(nums[mid] >= nums[e]){\\n                s = mid+1;\\n            }\\n            else{\\n                e = mid;\\n            }\\n        }\\n        return nums[mid];\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 758289,
                "title": "clear-python-3-solution-faster-than-93",
                "content": "```\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        low = 0\\n        high = len(nums) - 1\\n        while low <= high:\\n            mid = low + (high - low) // 2\\n            ele = nums[mid]\\n            if ele > nums[high]:\\n                low = mid + 1\\n            elif mid == 0 or nums[mid - 1] > nums[mid]:\\n                return nums[mid]\\n            else:\\n                high = mid - 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        low = 0\\n        high = len(nums) - 1\\n        while low <= high:\\n            mid = low + (high - low) // 2\\n            ele = nums[mid]\\n            if ele > nums[high]:\\n                low = mid + 1\\n            elif mid == 0 or nums[mid - 1] > nums[mid]:\\n                return nums[mid]\\n            else:\\n                high = mid - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 167985,
                "title": "binary-search",
                "content": "```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        int left = 0, right = nums.length - 1;\\n        while (left < right) {\\n            if (nums[left] < nums[right]) { // Sorted as a whole\\n                return nums[left];\\n            }\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] > nums[right]) { // Unsorted right half\\n                left = mid + 1;\\n            } else { // Unsorted left half\\n                left++;\\n                right = mid;\\n            }\\n        }\\n        return nums[left];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        int left = 0, right = nums.length - 1;\\n        while (left < right) {\\n            if (nums[left] < nums[right]) { // Sorted as a whole\\n                return nums[left];\\n            }\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] > nums[right]) { // Unsorted right half\\n                left = mid + 1;\\n            } else { // Unsorted left half\\n                left++;\\n                right = mid;\\n            }\\n        }\\n        return nums[left];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 48735,
                "title": "4ms-c-binary-search-solution-with-short-explanation",
                "content": "The idea is to binary search for the minimum. If the midpoint of an interval is larger than the right endpoint, the minimum must be in the right half of the interval. If not, the minimum is in the left half, but may be the midpoint itself (so we keep the midpoint in the active search interval in this case).\\n\\n    class Solution {\\n    public:\\n        int findMin(vector<int> &num) {\\n            int L = 0, U = num.size() - 1;\\n            while (L < U) {\\n                int M = L + (U - L) / 2;\\n                if (num[M] > num[U]) {\\n                    L = M + 1;\\n                } else {\\n                    U = M;\\n                }\\n            }\\n            return num[L];\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int findMin(vector<int> &num) {\\n            int L = 0, U = num.size() - 1;\\n            while (L < U) {\\n                int M = L + (U - L) / 2;\\n                if (num[M] > num[U]) {\\n                    L = M + 1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3870799,
                "title": "most-optimal-solution-using-binary-search-c-and-java-code",
                "content": "\\n\\n# Approach\\nIdentify the sorted half from the array, pickup the smallest element from that half, update the answer if it is smaller than the answer, then eliminate that half. Repeat this until the search space gets exhausted.\\n\\n# Complexity\\n- Time complexity:\\nO(log(n))\\n\\n- Space complexity:\\nO(1)\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int low = 0, high = nums.size()-1, ans = INT_MAX;\\n        while(low<=high) {\\n            int mid = (low+high)/2;\\n            if(nums[low]<=nums[mid]) {\\n                ans = min(ans, nums[low]);\\n                low = mid+1;\\n            } else {\\n                ans = min(ans, nums[mid]);\\n                high = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# JAVA Code\\n```\\npublic class Solution {\\n    public int findMin(int[] nums) {\\n        int low = 0, high = nums.length - 1, ans = Integer.MAX_VALUE;\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n            if (nums[low] <= nums[mid]) {\\n                ans = Math.min(ans, nums[low]);\\n                low = mid + 1;\\n            } else {\\n                ans = Math.min(ans, nums[mid]);\\n                high = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int low = 0, high = nums.size()-1, ans = INT_MAX;\\n        while(low<=high) {\\n            int mid = (low+high)/2;\\n            if(nums[low]<=nums[mid]) {\\n                ans = min(ans, nums[low]);\\n                low = mid+1;\\n            } else {\\n                ans = min(ans, nums[mid]);\\n                high = mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\npublic class Solution {\\n    public int findMin(int[] nums) {\\n        int low = 0, high = nums.length - 1, ans = Integer.MAX_VALUE;\\n        while (low <= high) {\\n            int mid = (low + high) / 2;\\n            if (nums[low] <= nums[mid]) {\\n                ans = Math.min(ans, nums[low]);\\n                low = mid + 1;\\n            } else {\\n                ans = Math.min(ans, nums[mid]);\\n                high = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2751424,
                "title": "0-ms-simple-6-lines-c-code-beats-100",
                "content": "**\\u2764\\uFE0FUPVOTE!**\\n# Complexity\\n- Time complexity: O(LogN)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int start = 0,end = nums.size()-1; \\n        while(start<end)\\n        { \\n            int mid = (start + end)/2;\\n            if(nums[mid]>nums[end]) start = mid+1; \\n            else end = mid; \\n        } \\n        return nums[start];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int start = 0,end = nums.size()-1; \\n        while(start<end)\\n        { \\n            int mid = (start + end)/2;\\n            if(nums[mid]>nums[end]) start = mid+1; \\n            else end = mid; \\n        } \\n        return nums[start];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2211586,
                "title": "python3-simple-naive-solution-with-binary-search",
                "content": "```\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        start = 0\\n        end = len(nums) - 1\\n        \\n        if(nums[start] <= nums[end]):\\n            return nums[0]\\n        \\n        while start <= end:\\n            mid = (start + end) // 2\\n            \\n            if(nums[mid] > nums[mid+1]):\\n                return nums[mid+1]\\n            \\n            if(nums[mid-1] > nums[mid]):\\n                return nums[mid]\\n            \\n            if(nums[mid] > nums[0]):\\n                start = mid + 1\\n            else:\\n                end = mid - 1\\n                \\n        return nums[start]\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        start = 0\\n        end = len(nums) - 1\\n        \\n        if(nums[start] <= nums[end]):\\n            return nums[0]\\n        \\n        while start <= end:\\n            mid = (start + end) // 2\\n            \\n            if(nums[mid] > nums[mid+1]):\\n                return nums[mid+1]\\n            \\n            if(nums[mid-1] > nums[mid]):\\n                return nums[mid]\\n            \\n            if(nums[mid] > nums[0]):\\n                start = mid + 1\\n            else:\\n                end = mid - 1\\n                \\n        return nums[start]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2108094,
                "title": "c-4-solutions-t-c-o-logn-s-c-o-1",
                "content": "* \\u2705 ***APPROACH 1:***\\n\\n**1.  TIME COMPLEXITY : O(logn)\\n2.  SPACE COMPLEXITY : O(1)**\\n\\n# **BINARY SEARCH SOLUTION**\\n\\n```\\nint findMin(vector<int>& nums) {\\n        int left=0,right=nums.size()-1;\\n        \\n        while(left<right){\\n            int mid=left+(right-left)/2;\\n\\n            if(nums[mid]>nums[right])left=mid+1;              // in this case we assure the minimum is in the right side\\n            else right=mid;                                  // in this case we assure the minimum is in the left side\\n        }\\n        return nums[left];\\n    }\\n```\\n\\n* ***\\u2705 APPROACH 2 :***\\n\\n**1.  TIME COMPLEXITY : O(n)\\n2.  SPACE COMPLEXITY : O(1)**\\n\\n# **SIMPLE TRAVERSAL**\\n\\n```\\nint findMin(vector<int>& nums) {\\n        int ans=INT_MAX;\\n        for(int i=0;i<nums.size();i++){\\n            ans=min(ans,nums[i]);\\n        }\\n        return ans;\\n    }\\n```\\n\\n* ***\\u2705APPROACH 3 :***\\n\\n**1.  TIME COMPLEXITY : O(n)\\n2.  SPACE COMPLEXITY : O(1)**\\n\\n# **TRAVERSE FROM END**\\n\\n```\\nint findMin(vector<int>& nums) {\\n        \\n        for(int i=nums.size()-1;i>0;i--){\\n            if(nums[i]<nums[i-1])return nums[i];\\n        }\\n        return nums[0];\\n    }\\n```\\n\\n* ***\\u2705APPROACH 4 :***\\n\\n**1.  TIME COMPLEXITY : O(nlogn)\\n2.  SPACE COMPLEXITY : O(1)**\\n\\n# **SORTING**\\n\\n```\\nint findMin(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        return nums[0];\\n    }\\n```\\n\\n![image](https://assets.leetcode.com/users/images/d0bc009b-5bb4-4333-a525-1e366d34ba75_1654317187.9661255.png)\\n\\n\\n\\uD83D\\uDE4C\\uD83D\\uDE4C HAPPY CODING !!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nint findMin(vector<int>& nums) {\\n        int left=0,right=nums.size()-1;\\n        \\n        while(left<right){\\n            int mid=left+(right-left)/2;\\n\\n            if(nums[mid]>nums[right])left=mid+1;              // in this case we assure the minimum is in the right side\\n            else right=mid;                                  // in this case we assure the minimum is in the left side\\n        }\\n        return nums[left];\\n    }\\n```\n```\\nint findMin(vector<int>& nums) {\\n        int ans=INT_MAX;\\n        for(int i=0;i<nums.size();i++){\\n            ans=min(ans,nums[i]);\\n        }\\n        return ans;\\n    }\\n```\n```\\nint findMin(vector<int>& nums) {\\n        \\n        for(int i=nums.size()-1;i>0;i--){\\n            if(nums[i]<nums[i-1])return nums[i];\\n        }\\n        return nums[0];\\n    }\\n```\n```\\nint findMin(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        return nums[0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2010104,
                "title": "binary-search-o-log-n-runtime-o-1-space",
                "content": "```\\nclass Solution {\\n      /**\\n       * find the pivot in the sorted array. Find the middle index of the array. We can compare the\\n       * middle index element with either the previous element and next element and see if the pivot is\\n       * present there. If mid is greater than next, mid is the pivot. If the prev is greater than mid,\\n       * prev is the pivot.\\n       * <p>\\n       * If both cases are failed, the pivot will either be in the left half or the right half. Compare\\n       * the leftmost element in the partition with the mid-element. If mid is greater, the first half\\n       * is in ascending order and the pivot will be in the latter half. So, ignore the first and\\n       * consider just the latter half. Else, vice versa\\n       */\\n    public int findMin(int[] nums) {\\n        int pivot = findPivot(nums, 0, nums.length - 1);\\n        return pivot == -1 ? nums[0] : nums[pivot + 1];\\n    }\\n    \\n    private int findPivot(int[] nums, int left, int right) {\\n        if (left > right) return -1;\\n        int mid = (left + right) / 2;\\n        if (mid < right && nums[mid] > nums[mid + 1])\\n            return mid;\\n        else if (mid > left && nums[mid - 1] > nums[mid])\\n            return mid - 1;\\n        \\n        if (nums[left] > nums[mid])\\n            return findPivot(nums, left, mid - 1);\\n        else\\n            return findPivot(nums, mid + 1, right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n      /**\\n       * find the pivot in the sorted array. Find the middle index of the array. We can compare the\\n       * middle index element with either the previous element and next element and see if the pivot is\\n       * present there. If mid is greater than next, mid is the pivot. If the prev is greater than mid,\\n       * prev is the pivot.\\n       * <p>\\n       * If both cases are failed, the pivot will either be in the left half or the right half. Compare\\n       * the leftmost element in the partition with the mid-element. If mid is greater, the first half\\n       * is in ascending order and the pivot will be in the latter half. So, ignore the first and\\n       * consider just the latter half. Else, vice versa\\n       */\\n    public int findMin(int[] nums) {\\n        int pivot = findPivot(nums, 0, nums.length - 1);\\n        return pivot == -1 ? nums[0] : nums[pivot + 1];\\n    }\\n    \\n    private int findPivot(int[] nums, int left, int right) {\\n        if (left > right) return -1;\\n        int mid = (left + right) / 2;\\n        if (mid < right && nums[mid] > nums[mid + 1])\\n            return mid;\\n        else if (mid > left && nums[mid - 1] > nums[mid])\\n            return mid - 1;\\n        \\n        if (nums[left] > nums[mid])\\n            return findPivot(nums, left, mid - 1);\\n        else\\n            return findPivot(nums, mid + 1, right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1437460,
                "title": "go-binary-search-solution",
                "content": "```\\nfunc findMin(nums []int) int {\\n\\tleft, right := 0, len(nums)-1\\n\\tfor left < right {\\n\\t\\tmid := (left + right) / 2\\n\\t\\tif nums[mid] > nums[right] {\\n\\t\\t\\tleft = mid + 1\\n\\t\\t} else {\\n\\t\\t\\tright = mid\\n\\t\\t}\\n\\t}\\n\\n\\treturn nums[left]\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc findMin(nums []int) int {\\n\\tleft, right := 0, len(nums)-1\\n\\tfor left < right {\\n\\t\\tmid := (left + right) / 2\\n\\t\\tif nums[mid] > nums[right] {\\n\\t\\t\\tleft = mid + 1\\n\\t\\t} else {\\n\\t\\t\\tright = mid\\n\\t\\t}\\n\\t}\\n\\n\\treturn nums[left]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1436643,
                "title": "short-and-clear-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int l = 0,r = nums.size()-1;\\n        while(l<=r){\\n            int mid = (l+r)/2;\\n            if((mid-1<0 or nums[mid-1]>nums[mid]) and (mid+1==nums.size() or nums[mid]<nums[mid+1]))\\n                return nums[mid];\\n            if(nums[mid]>nums.back())\\n                l = mid + 1;\\n            else\\n                r = mid - 1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int l = 0,r = nums.size()-1;\\n        while(l<=r){\\n            int mid = (l+r)/2;\\n            if((mid-1<0 or nums[mid-1]>nums[mid]) and (mid+1==nums.size() or nums[mid]<nums[mid+1]))\\n                return nums[mid];\\n            if(nums[mid]>nums.back())\\n                l = mid + 1;\\n            else\\n                r = mid - 1;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 974928,
                "title": "javascript-using-binary-search-easy-to-understand",
                "content": "Before we go forward, this is what we know:\\n- The array is rotated, and it could be rotated in a way it does not look rotated at all (smallest value on left, largest value on right)\\n- If the array is shifted, there will be ONE occurance where\\n\\n`a[mid - 1] > a[mid]`\\n\\nYou see this in `[4,5,1,2,3]`. There\\'s only one time where the mid - 1 value is greater than mid value. That\\'s a key to finding the solution.\\n\\nI wrote all of the if/else if statements with these tests. It\\'s all you need! \\n\\n[1,2,3,4,5]\\n[5,1,2,3,4]\\n[4,5,1,2,3]\\n[3,4,5,1,2]\\n[2,3,4,5,1]\\n\\nThis helps us with edge cases like \"what if the array is regularly sorted\" or \"what if the values is all the way on the right? The `[5,1,2,3,4]` needs a special case just for itself (a[mid] < a[left] && a[mid] < a[right]).\\n\\n**Space Complexity**: O(1)\\n**Time Complexity** : O(log n)\\n\\n```\\nconst findMin = (a) => {\\n\\tif (!a || a.length === 0) return null;\\n\\n\\tlet left = 0,\\n\\t\\tright = a.length - 1;\\n\\n\\twhile (left < right) {\\n\\t\\tlet mid = (left + (right - left) / 2) | 0; // This helps avoid overflows with large data sets\\n\\t\\t\\n\\t\\t// The one instance I mentioned above\\n\\t\\tif (mid > 0 && a[mid - 1] > a[mid]) return a[mid];\\n\\t\\telse if (a[mid] >= a[left] && a[mid] < a[right]) right = mid - 1;\\n\\t\\telse if (a[mid] >= a[left] && a[mid] > a[right]) left = mid + 1;\\n\\t\\telse if (a[mid] < a[left] && a[mid] < a[right]) right = mid - 1;\\n\\t}\\n\\n\\treturn a[left];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search"
                ],
                "code": "```\\nconst findMin = (a) => {\\n\\tif (!a || a.length === 0) return null;\\n\\n\\tlet left = 0,\\n\\t\\tright = a.length - 1;\\n\\n\\twhile (left < right) {\\n\\t\\tlet mid = (left + (right - left) / 2) | 0; // This helps avoid overflows with large data sets\\n\\t\\t\\n\\t\\t// The one instance I mentioned above\\n\\t\\tif (mid > 0 && a[mid - 1] > a[mid]) return a[mid];\\n\\t\\telse if (a[mid] >= a[left] && a[mid] < a[right]) right = mid - 1;\\n\\t\\telse if (a[mid] >= a[left] && a[mid] > a[right]) left = mid + 1;\\n\\t\\telse if (a[mid] < a[left] && a[mid] < a[right]) right = mid - 1;\\n\\t}\\n\\n\\treturn a[left];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 624237,
                "title": "come-and-see-binary-search-but-logic-is-different-natural-and-intuitive",
                "content": "**My Comment**\\nI see lots of posts solving this problem using binary search, but I **cannot agree with** their logic of binary search... Their logic is comparing the `num[mid]` with `nums[left/start]`, I would say **it is vague, and hard to understand...**\\nI use binary search as well, but I always compare with `nums[n - 1]` which is easier. Please take a look at my logic and explanations\\n\\n---\\n**Algorithm**\\nBinary Search as you know\\n\\n---\\n**Explanation**\\nSince the original array is sorted in ascending order, `nums[0] < nums[n - 1]`\\nIt would be like below:\\n```\\n\\t\\t /\\t\\n\\t    /\\n\\t   /\\n      /\\n\\t /\\n    /\\n   /\\n```\\nAfter rotated, think about how it would be like?\\n```\\n\\t\\t /\\t\\n\\t    /\\n<--\\t   /\\n      /\\n------------------\\n\\t/\\n   /\\n  /\\n\\nIt becomes like below:\\n  \\n\\t/\\t\\n   /\\n  /\\n /\\n------------------\\n\\t\\t/\\n\\t   /\\n\\t  / \\n\\n```\\n\\nWe can notice that from the pivot, **all the elements in the left hand side `>` all the elements in the right hand side**. And the largest number in the right hand side is `nums[n - 1]`\\n\\nWhen comes to binary search, 2 cases:\\n1. If the `nums[mid]` is in the left hand side, look at the graph below, then it must be **greater than** the largest number in the right hand side, i.e. `nums[n - 1]`. That is **\\'nums[mid] > nums[n - 1]\\'**. Then we know the minimum number must in the right side of `mid`. So move `left` to `mid + 1`\\n\\t```\\n\\t   | /\\t\\n\\t   |/\\n\\t   |\\n\\t  /|\\n\\t / |\\n\\t------------------\\n\\t\\t\\t/\\n\\t\\t   /\\n\\t\\t  / \\n\\t```\\n2. If the `nums[mid]` is in the right hand side, look at the graph below, then it must be **no greater than** the largest number in the right hand side, i.e. `nums[n - 1]`. That is **\\'nums[mid] <= nums[n - 1]\\'**. Then we know the minimum number must in the left side of `mid`. So move `right` to `mid`. (Why `mid` not `mid - 1`? Because `num[mid]` can be the minimum number which is the result, we cannot rule out the `mid`)\\n\\t```\\n\\t\\t/\\t\\n\\t   /\\n\\t  /\\n\\t /\\n\\t------------------\\n\\t\\t   | /\\n\\t\\t   |/\\n\\t\\t   |\\n\\t\\t  /| \\n\\t```\\n\\nSo the difference with other solutions is: **we always compares the `nums[mid]` with `nums[n - 1]`.** Unlike other solutions comparing `nums[mid]` with `nums[left]` or `nums[right]`, the logic is vague, right???\\n\\n---\\n**Final Code**\\n```java\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        // corner case\\n        if(nums == null || nums.length == 0) return -1;\\n        if(nums.length == 1) return nums[0];\\n        \\n        // if the array is not rotated\\n        int n = nums.length;\\n        if(nums[0] < nums[n - 1]) return nums[0];\\n        \\n        // get to business: find min if array is rotated\\n        int left = 0;\\n        int right = n - 1;\\n        while(left < right - 1){\\n            int mid = left + (right - left)/2;\\n            if(nums[mid] <= nums[n - 1]){\\n                right = mid;\\n            }else{\\n                left = mid + 1;\\n            }\\n        }\\n        \\n        return Math.min(nums[left], nums[right]);\\n    }\\n}\\n```\\n\\n---\\n**Complexity Analysis**\\nTC(Time Complexity): O(logn), since we are using binary search\\nSC(Space Complexity): O(1)\\n",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\n\\t\\t /\\t\\n\\t    /\\n\\t   /\\n      /\\n\\t /\\n    /\\n   /\\n```\n```\\n\\t\\t /\\t\\n\\t    /\\n<--\\t   /\\n      /\\n------------------\\n\\t/\\n   /\\n  /\\n\\nIt becomes like below:\\n  \\n\\t/\\t\\n   /\\n  /\\n /\\n------------------\\n\\t\\t/\\n\\t   /\\n\\t  / \\n\\n```\n```\\n\\t   | /\\t\\n\\t   |/\\n\\t   |\\n\\t  /|\\n\\t / |\\n\\t------------------\\n\\t\\t\\t/\\n\\t\\t   /\\n\\t\\t  / \\n\\t```\n```\\n\\t\\t/\\t\\n\\t   /\\n\\t  /\\n\\t /\\n\\t------------------\\n\\t\\t   | /\\n\\t\\t   |/\\n\\t\\t   |\\n\\t\\t  /| \\n\\t```\n```java\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        // corner case\\n        if(nums == null || nums.length == 0) return -1;\\n        if(nums.length == 1) return nums[0];\\n        \\n        // if the array is not rotated\\n        int n = nums.length;\\n        if(nums[0] < nums[n - 1]) return nums[0];\\n        \\n        // get to business: find min if array is rotated\\n        int left = 0;\\n        int right = n - 1;\\n        while(left < right - 1){\\n            int mid = left + (right - left)/2;\\n            if(nums[mid] <= nums[n - 1]){\\n                right = mid;\\n            }else{\\n                left = mid + 1;\\n            }\\n        }\\n        \\n        return Math.min(nums[left], nums[right]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 154530,
                "title": "simple-c-solution-beats-100-cartoon-included",
                "content": "There are a lot of binary search solutions. However, I found that a simple linear search solution seems to be just as fast for the given test cases. Logic is as follows:\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/hckrtst/image_1532817694.png)\\n\\n\\nCode below:\\n\\n```cpp\\nint findMin(vector<int>& nums) {\\n    int min = nums[0];\\n    for (int i = 0; i < nums.size(); i++) {\\n        if ((i < nums.size() - 1) &&\\n            nums[i] > nums[i+1]) {\\n                min = nums[i+1];\\n                break;\\n            }  \\n    }\\n    return min;        \\n}\\n\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint findMin(vector<int>& nums) {\\n    int min = nums[0];\\n    for (int i = 0; i < nums.size(); i++) {\\n        if ((i < nums.size() - 1) &&\\n            nums[i] > nums[i+1]) {\\n                min = nums[i+1];\\n                break;\\n            }  \\n    }\\n    return min;        \\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 48548,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Find Minimum in Rotated Sorted Array** https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/\\n\\nKey insight is that if an array is rotated, then between the two sub-arrays around the mid point, the lowest element lies in the array which is out of order.  Now there are three possibilities which are shown in the figures below. We observe that lowest element is the first element when all elements are sorted. Otherwise it is in the segment about the mid element which is unsorted.\\nhttps://goo.gl/photos/3CJrFiV72te92xC88\\nhttps://postimg.org/image/asbbeo2c9/.\\n\\n**What is a single condition that can discriminate between the three cases? **\\n* if nums[mid] > nums[high] then minimum number is in right half, otherwise it is in left half (first two)\\n* if minimum number must be in the right half, then we must do low = mid+1. Doing low = mid will result in infinite loop. Case: [2,1]\\n```\\nclass Solution(object):\\n    def findMin(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        low,high = 0, len(nums)-1\\n        while low < high:\\n            mid = low + (high-low)//2\\n            if nums[mid] > nums[high]:\\n                low = mid + 1 # Note that mid+1 is important.\\n            else:\\n                high = mid\\n        return nums[low]\\n```\\n\\n**What if we used nums[low] < nums[mid] as the discriminating condition?**\\n* Note that this only helps distinguish 2 and 3 (from figure) and we need a special condition for case 1 when rotation is zero.\\n* Note that we dont do low = mid+1. Case [2,1]\\n* The stopping condition is again an array of length 2.\\n```\\nclass Solution(object):\\n    def findMin(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        low,high = 0, len(nums)-1\\n        if nums[low] <= nums[high]:\\n            return nums[low]\\n        while low < high:\\n            mid = low + (high-low)//2\\n            if nums[low] < nums[mid]:\\n                low = mid\\n            else:\\n                high = mid\\n        return nums[low+1]\\n```\\n\\n**Another Approach**\\nWe apply binary search and out stopping condition is an out of order array of length 2. The smallest element is then nums[high]. Do not forget to test for boundary condition that array is in order already.\\n```\\nclass Solution(object):\\n    def findMin(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        low,high = 0, len(nums)-1\\n        if nums[low] <= nums[high]:\\n            return nums[low]\\n        while high-low != 1:\\n            mid = low + (high-low)//2\\n            if nums[low] < nums[mid]:\\n                low = mid\\n            else:\\n                high = mid\\n        return nums[high]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findMin(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        low,high = 0, len(nums)-1\\n        while low < high:\\n            mid = low + (high-low)//2\\n            if nums[mid] > nums[high]:\\n                low = mid + 1 # Note that mid+1 is important.\\n            else:\\n                high = mid\\n        return nums[low]\\n```\n```\\nclass Solution(object):\\n    def findMin(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        low,high = 0, len(nums)-1\\n        if nums[low] <= nums[high]:\\n            return nums[low]\\n        while low < high:\\n            mid = low + (high-low)//2\\n            if nums[low] < nums[mid]:\\n                low = mid\\n            else:\\n                high = mid\\n        return nums[low+1]\\n```\n```\\nclass Solution(object):\\n    def findMin(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        low,high = 0, len(nums)-1\\n        if nums[low] <= nums[high]:\\n            return nums[low]\\n        while high-low != 1:\\n            mid = low + (high-low)//2\\n            if nums[low] < nums[mid]:\\n                low = mid\\n            else:\\n                high = mid\\n        return nums[high]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 48697,
                "title": "simple-java-solution",
                "content": "    public int findMin(int[] nums) {\\n        \\n        \\tint start = 0, end = nums.length - 1, mid;\\n        \\twhile (start  <  end) {\\n        \\t\\tmid = (start + end) / 2;\\n        \\t\\tif (nums[mid]  > nums[end])\\n        \\t\\t\\tstart = mid + 1;\\n        \\t\\telse\\n        \\t\\t\\tend = mid;\\n        \\t}\\n        \\treturn nums[start];\\n    }",
                "solutionTags": [],
                "code": "    public int findMin(int[] nums) {\\n        \\n        \\tint start = 0, end = nums.length - 1, mid;\\n        \\twhile (start  <  end) {\\n        \\t\\tmid = (start + end) / 2;\\n        \\t\\tif (nums[mid]  > nums[end])\\n        \\t\\t\\tstart = mid + 1;\\n        \\t\\telse\\n        \\t\\t\\tend = mid;\\n        \\t}\\n        \\treturn nums[start];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3464165,
                "title": "c-solution-binary-search-log-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(log n)\\n\\n- Space complexity:\\nO(1)\\n![IMG_9181.jpg](https://assets.leetcode.com/users/images/11ba6d96-e074-4947-b06a-308c2a1e6c2e_1682703362.935578.jpeg)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int i=0;\\n        int j=nums.size()-1;\\n        while(i<j){\\n            int mid = (i+j)/2;\\n            if(nums[mid] > nums[j]) i = mid+1;\\n            else j=mid;\\n        }\\n        return nums[i];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int i=0;\\n        int j=nums.size()-1;\\n        while(i<j){\\n            int mid = (i+j)/2;\\n            if(nums[mid] > nums[j]) i = mid+1;\\n            else j=mid;\\n        }\\n        return nums[i];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3374843,
                "title": "easiest-solution-in-leetcode-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        low=0\\n        high=len(nums)-1\\n        while low<high:\\n            mid=(low+high)//2\\n            if nums[mid]>nums[high]:\\n                low=mid+1\\n            else:\\n                high=mid\\n        return nums[low]\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        low=0\\n        high=len(nums)-1\\n        while low<high:\\n            mid=(low+high)//2\\n            if nums[mid]>nums[high]:\\n                low=mid+1\\n            else:\\n                high=mid\\n        return nums[low]\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094739,
                "title": "easy-to-understand-o-log-n-time-o-1-space",
                "content": "# Intuition\\nWe want to search for the minimum of the array.And it\\'s pretty obvious the minimum of the array would lie as the first element of the non rotated or non shifted part of the array.So we try to reach to the non shifted part of the array.\\n\\nEx:- Consider the array (4,5,1,2,3)\\nHere (4,5) represents the rotated part of array and (1,2,3) represents the non rotated part of the array.\\n\\n# Approach\\n1)Keep two pointers low and high.Whenever mid element is higher than low element it means that we are still in the rotated part of the array.So we Shift your low 1 place ahead of the mid element.\\n\\n2)Else if that is not the case,it means we are already in the non rotated part of the array but in the farther right side,so we shift the high 1 place behind the mid.We do this to reach that part of the non rotated array which has lesser value elements.\\n\\n3)Each time during the search we take a mini variable which stores the minimum between mid element,low element and mini in mini.\\n\\n# Complexity\\n- Time complexity:\\nO(log(n))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& arr) {\\n        int n=arr.size();\\n        int l=0;\\n        int h=n-1;\\n        int mini=INT_MAX;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            mini=min(mini,arr[mid]);\\n            mini=min(mini,arr[l]);\\n            if(arr[mid]>=arr[l]){\\n                l=mid+1;\\n            }\\n            else{\\n                h=mid-1;\\n            }\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& arr) {\\n        int n=arr.size();\\n        int l=0;\\n        int h=n-1;\\n        int mini=INT_MAX;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            mini=min(mini,arr[mid]);\\n            mini=min(mini,arr[l]);\\n            if(arr[mid]>=arr[l]){\\n                l=mid+1;\\n            }\\n            else{\\n                h=mid-1;\\n            }\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2931918,
                "title": "java-binary-search-with-little-twist",
                "content": "# Intuition\\nBy $$O(logn)$$ we know it is only possible via binary search.\\n\\n# Approach\\nIt is quite similar to - https://leetcode.com/problems/search-in-rotated-sorted-array/solutions/1566310/simple-java-solution-with-explaination-0-ms-binary-search-logn/?envType=study-plan&id=algorithm-ii&orderBy=most_votes\\n\\nIn binary search check-> if right boundary element is greater than mid. in such case mid could be the answeer or elements to the left of mid could be the answer. but we are sure right elements will be greater. hence do \\nr=m\\nelse do l=m+1\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n $$O(logn)$$ \\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n\\t\\tint l = 0;\\n\\t\\tint r = nums.length - 1;\\n\\t\\tint m;\\n\\t\\twhile (l < r) {\\n\\t\\t\\tm = (l + r) / 2;\\n\\t\\t\\tif (nums[m] < nums[r]) {\\n\\t\\t\\t\\tr=m;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tl=m+1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn nums[l];\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n\\t\\tint l = 0;\\n\\t\\tint r = nums.length - 1;\\n\\t\\tint m;\\n\\t\\twhile (l < r) {\\n\\t\\t\\tm = (l + r) / 2;\\n\\t\\t\\tif (nums[m] < nums[r]) {\\n\\t\\t\\t\\tr=m;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tl=m+1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn nums[l];\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2692319,
                "title": "100-faster-0ms-optimal-approach",
                "content": "![image](https://assets.leetcode.com/users/images/b0ff0d83-2079-47f2-a568-3dd71a271a4f_1665532212.5354164.png)\\n![image](https://assets.leetcode.com/users/images/777aed88-e46f-467b-8350-5c8ca8882cc1_1665532229.7139807.gif)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& arr) {\\n        int n = arr.size();\\n        int mini = INT_MAX;\\n        int low = 0, high = n-1;\\n        while(low <= high){\\n            long int mid = low + (high-low)/2;\\n            if(arr[mid] >= arr[low]){\\n                mini = min(mini, arr[low]);\\n                low = mid+1;\\n            }\\n            else{\\n                mini = min(mini, arr[mid]);\\n                high = mid-1;\\n            }\\n        }\\n        return mini;\\n    }\\n};\\n/* If you like it please upvote */\\n```\\n\\nIf you like it please upvote",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& arr) {\\n        int n = arr.size();\\n        int mini = INT_MAX;\\n        int low = 0, high = n-1;\\n        while(low <= high){\\n            long int mid = low + (high-low)/2;\\n            if(arr[mid] >= arr[low]){\\n                mini = min(mini, arr[low]);\\n                low = mid+1;\\n            }\\n            else{\\n                mini = min(mini, arr[mid]);\\n                high = mid-1;\\n            }\\n        }\\n        return mini;\\n    }\\n};\\n/* If you like it please upvote */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2597833,
                "title": "python-explained-steps-clean-code-best-method",
                "content": "Hello!\\n\\nTo solve this problem we have to do **binary search**, but we compare current element with the **second one** and then with the **last one**.\\n\\n1. If our current element is greater than the next one, then it means that next element is our **result** (because it means it is rotation point)\\n2. If our current element is greater than the last element, then it means that we have to move **start** index (because on the left we won\\'t find the target).\\n3. If those statements are not true, then we change **end** index.\\n\\nFor example: [4, 5, 1, 2, 3],  target = 5\\nOur mid point is value **1**. It is not greater than **2**, so it is not the target. It is not greater than the last value, so we know, that we won\\'t find the target on the right, so we decrease **end** index.\\n\\nNow we consider subarray [4, 5] etc.\\n\\nCode:\\n```\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        if len(nums) == 1:\\n            return nums[0]\\n        \\n        start = 0\\n        end = len(nums)-1\\n        \\n        while start <= end:\\n            mid = (start + end) // 2\\n            \\n            if nums[mid] > nums[mid+1]:\\n                return nums[mid+1]\\n            elif nums[mid] > nums[-1]:\\n                start = mid + 1\\n            else:\\n                end = mid - 1\\n        \\n        return nums[0]\\n```\\n\\nPlease upvote if it was helpful :))",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        if len(nums) == 1:\\n            return nums[0]\\n        \\n        start = 0\\n        end = len(nums)-1\\n        \\n        while start <= end:\\n            mid = (start + end) // 2\\n            \\n            if nums[mid] > nums[mid+1]:\\n                return nums[mid+1]\\n            elif nums[mid] > nums[-1]:\\n                start = mid + 1\\n            else:\\n                end = mid - 1\\n        \\n        return nums[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2485387,
                "title": "beats-100-c-solution",
                "content": "**thanks to love babbar**\\n\\n\\n\\n\\tint findMin(vector<int>& nums) {\\n        int s = 0;\\n        int e = nums.size()-1;\\n        while(s < e)\\n        {\\n            int m = s + (e-s)/2;\\n            if(nums[m] > nums[e])\\n            {\\n                s = m +1;\\n            }\\n            else{\\n                e = m;\\n            }\\n        }\\n        return nums[s];\\n    }\\n\\n\\n**hope u find it helpfull : - )  dont forgot to upvote**\\n",
                "solutionTags": [],
                "code": "**thanks to love babbar**\\n\\n\\n\\n\\tint findMin(vector<int>& nums) {\\n        int s = 0;\\n        int e = nums.size()-1;\\n        while(s < e)\\n        {\\n            int m = s + (e-s)/2;\\n            if(nums[m] > nums[e])\\n            {\\n                s = m +1;\\n            }\\n            else{\\n                e = m;\\n            }\\n        }\\n        return nums[s];\\n    }\\n\\n\\n**hope u find it helpfull : - )  dont forgot to upvote**\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2355276,
                "title": "c-multiple-solutions-diffrent-approaches",
                "content": "**Codes are available in comments**",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1889381,
                "title": "using-binary-search-simple-easy-to-understand-c",
                "content": "Implementation\\n\\n**Time Complexity: O(LogN)\\nSpace Complexity: O(1)**\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int left = 0, right = nums.size()-1, minVal = INT_MAX;\\n        \\n        while(left <= right){\\n            int mid = left + (right - left)/2;\\n            \\n            if(nums[left] <= nums[mid]){\\n                minVal = min(minVal, nums[left]);\\n                left = mid+1;\\n            }\\n            else{\\n                minVal = min(minVal, nums[mid]);\\n                right = mid-1;\\n            }\\n        }\\n        \\n        return minVal;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int left = 0, right = nums.size()-1, minVal = INT_MAX;\\n        \\n        while(left <= right){\\n            int mid = left + (right - left)/2;\\n            \\n            if(nums[left] <= nums[mid]){\\n                minVal = min(minVal, nums[left]);\\n                left = mid+1;\\n            }\\n            else{\\n                minVal = min(minVal, nums[mid]);\\n                right = mid-1;\\n            }\\n        }\\n        \\n        return minVal;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589933,
                "title": "faster-than-100-users-c-time-o-logn-space-o-1",
                "content": "I have just have used simple binary search with a little bit of modification as I have checked last element with the mid one so that I can swap change left right accordingly.  \\n\\t  \\n\\t  \\n\\t  int findMin(vector<int>& nums) {\\n        int left=0,right=nums.size()-1;\\n        while(left<right)\\n        {\\n            int mid = (left+right)/2;\\n            if(nums[mid]<nums[mid+1])\\n            {\\n                if(nums[mid]>nums[right])\\n                {\\n                    left=mid+1;\\n                }\\n                else\\n                    right=mid;\\n            }\\n            else\\n                left=mid+1;\\n        }\\n        return nums[left];\\n    }",
                "solutionTags": [],
                "code": "I have just have used simple binary search with a little bit of modification as I have checked last element with the mid one so that I can swap change left right accordingly.  \\n\\t  \\n\\t  \\n\\t  int findMin(vector<int>& nums) {\\n        int left=0,right=nums.size()-1;\\n        while(left<right)\\n        {\\n            int mid = (left+right)/2;\\n            if(nums[mid]<nums[mid+1])\\n            {\\n                if(nums[mid]>nums[right])\\n                {\\n                    left=mid+1;\\n                }\\n                else\\n                    right=mid;\\n            }\\n            else\\n                left=mid+1;\\n        }\\n        return nums[left];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1535809,
                "title": "typescript-javascript-binary-search",
                "content": "Since we\\'re dealing with a sorted array problem and the description explicitly tells us to solve in O(logn) time, we should immediately think of trying to use binary search. The trick is we need to modify binary search since in this case we\\'re not looking for a specific target.\\n\\nKnowing that modified binary search is a possible solution, we can use a small example such as [2,3,1] and see what information we can gain from the mid point. In this case, we see that the array has been rotated twice and the midpoint value is three. From this, we can see that if the midpoint is greater than the value at the rightPointer, then the array has been rotated with the minimum value somewhere to the right of the mid point. So we can update left to equal mid + 1, since we no longer want to consider the mid point and want to look on the right half of the array. If however we have the example [3, 1, 2], our mid point value is 1 which is less than the rightPointer, so the right side of the array is properly sorted and the mid point value is the minimum of the right side of the array, so we want to keep it in the solution space as a possible minimum value. Therefore we set the right equal to mid. When we break out of this loop, the left index will point to the minimum value. \\n```\\nfunction findMin(nums: number[]): number {\\n    if(nums.length === 1){\\n        return nums[0];\\n    }\\n    \\n    let left = 0;\\n    let right = nums.length - 1;\\n    \\n    while(left < right){\\n        const mid = left + Math.floor((right - left) / 2);\\n        \\n        if(nums[mid] > nums[right]){\\n            left = mid + 1;\\n        }\\n        else {\\n            right = mid;\\n        }\\n    }\\n    \\n    return nums[left];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Binary Search"
                ],
                "code": "```\\nfunction findMin(nums: number[]): number {\\n    if(nums.length === 1){\\n        return nums[0];\\n    }\\n    \\n    let left = 0;\\n    let right = nums.length - 1;\\n    \\n    while(left < right){\\n        const mid = left + Math.floor((right - left) / 2);\\n        \\n        if(nums[mid] > nums[right]){\\n            left = mid + 1;\\n        }\\n        else {\\n            right = mid;\\n        }\\n    }\\n    \\n    return nums[left];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1022263,
                "title": "divide-conquer-explanation-visual-python",
                "content": "***TLDR(expalanation + visual below code snippet)*** This problem can be solved by using divide and conquer strategy. We repeatedly divide the problem into subproblems on the basis of whether or not ```arr[low] <= arr[high]``` (whether or not array is sorted) until subporblems become small. Then we solve them directly.  we begin combining solutions to subproblems by taking the minimum of the left and right subproblem solutions.\\n\\n```python\\ndef findMin(self, nums: List[int]) -> int:\\n    return self.find_min(nums, 0, len(nums) - 1)\\n\\t\\ndef find_min(self, nums, lo, hi):\\n\\tif lo >= hi: return nums[lo]\\n\\tif nums[lo] <= nums[hi]: return nums[lo]\\n\\tmid = (lo + hi)//2\\n\\n\\tleft = self.find_min(nums, lo, mid)\\n\\tright = self.find_min(nums, mid + 1, hi)\\n\\treturn min(left, right);\\n\\n```\\n* * * \\n### Divide & Conquer Strategy \\n* * * \\n\\nDivide & Conquer is a strategy for a solving a problem. \\n\\nWe take a large problem and ***divide*** it into subproblems until the subproblems become ***small*** (we define the meaning of small). Once we have small subproblemsm we can solve them directly because the answer is trivial. Once we start getting solutions to small subproblems we can start to ***combine*** or ***conquer***  these solutions, to get solutions to larger subproblems eventually solving the our intial large problem.  \\n\\nThis figure denotes a general way to approach ***Divide & Conquer*** \\n![image](https://assets.leetcode.com/users/images/d24f02b7-1a45-4899-a908-e5fe584bf29a_1610922746.512331.png)\\n\\n* * * \\n### Why Divide & Conquer ?\\n* * * \\n\\nIn this problem we are given a ***sorted*** array of ***unqiue*** elements that has been rotated and we are asked to find the ***minimum element****. \\n\\nin general when given a ***sorted array*** and asked to find an element. ***binary search*** is applicable. Binary search is an algorithm that uses the ***divide and conquer*** strategy. \\n\\nTechnically this array is not perfectly sorted and becuase the array has been rotated. However the relative ordering of the elements is still preserved after rotation.\\n\\nThus it still may be possible to modify the original binary search algorithm and/or use a ***divide an conquer strategy***.\\n\\n* * * \\n### Applying Divide & Conquer Strategy\\n* * * \\nwe need to find the minimum in a sorted array that has been rotated zero or more times. \\n\\nRecall, we say a problem is large when it cannot be solved directly, and the problem is small when it can be solved directly.\\n\\nWhen the array is sorted, the problem is small because we can solve the problem directly by taking the first element of the array. \\n\\n![image](https://assets.leetcode.com/users/images/e4ca6343-2e17-4cb6-b3ed-9612a6a7a935_1610931992.3232388.png)\\n* * * \\nif the array is not completely sorted (in our case rotated 1 or more  times) we cannot solve the problem directly, thus the problem is large. \\n\\n* * * \\n***The question now becomes how do we solve large problems?***\\n* * * \\n\\nObserve a rotated array , notice the relative order of the elements is still preserved leaving sections of the array still sorted. \\n\\n* * * \\n![image](https://assets.leetcode.com/users/images/19285d72-c4f1-491f-8b00-00be7a513840_1610932157.6701047.png)\\n\\nThe goal is in the example above is to find sorted arrays so we can solve the problem directly. This entire block is not sorted, but if we cut the array in half we are left with 2 sorted pieces.we can solve each peice directly. \\n\\nin other words if he problem is large (array not sorted) we can divide the problem into subproblems (smaller arrays) until we get small problems (sorted arrrays) and then solve them directly. \\n\\n![image](https://assets.leetcode.com/users/images/b6d57473-54b0-4d99-b01f-25553a255063_1610932628.1464949.png)\\n\\nwe know the ***right*** array is sorted because ```arr[4] < arr[6]```so we could solve for the minimum directly \\n\\nhowever notice the ***left*** array is also sorted because ```arr[0] < arr[3]``` so can also solve directly and we get a minimum of ```4```\\n\\nour original problem can only have one solution. How do we ensure we choose the correct value? we take the minimum ```min(4, 0) = 0```. in otherwords we combine or conquer subproblems by  taking the minimum of solutions to our subproblems. \\n\\n* * * \\nat each stage we decide if the problem is ***large (not a sorted array)***  if it is ***large***, we break the problem into smaller subproblems (cut the array in half by a midpoint) otherwise the problem is ***small (sorted array***) so we solve the problem ***directly (take first value block of sorted elements)*** when we have found the solution for both the left and right havles of a subproblem we ***combine or conquer*** the solutions ***by taking the minimum of both solutions***.\\n\\nThis approach becomes clear on a larger example. \\n\\n![image](https://assets.leetcode.com/users/images/de35a51d-4cd5-49c4-8909-d34f1b23dd37_1610921714.4782262.png)\\n\\n```python\\ndef findMin(self, nums: List[int]) -> int:\\n    return self.find_min(nums, 0, len(nums) - 1)\\n\\t\\ndef find_min(self, nums, lo, hi):\\n\\tif lo >= hi: return nums[lo]\\n\\tif nums[lo] <= nums[hi]: return nums[lo]\\n\\tmid = (lo + hi)//2\\n\\n\\tleft = self.find_min(nums, lo, mid)\\n\\tright = self.find_min(nums, mid + 1, hi)\\n\\treturn min(left, right)\\n```\\n\\ncode courtesy of [junhaowanggg](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/discuss/582964/4-Solutions-Including-Divide-and-Conquer-Binary-Search-(%2B-Follow-Up))\\n\\n",
                "solutionTags": [
                    "Divide and Conquer",
                    "Binary Tree"
                ],
                "code": "```arr[low] <= arr[high]```\n```python\\ndef findMin(self, nums: List[int]) -> int:\\n    return self.find_min(nums, 0, len(nums) - 1)\\n\\t\\ndef find_min(self, nums, lo, hi):\\n\\tif lo >= hi: return nums[lo]\\n\\tif nums[lo] <= nums[hi]: return nums[lo]\\n\\tmid = (lo + hi)//2\\n\\n\\tleft = self.find_min(nums, lo, mid)\\n\\tright = self.find_min(nums, mid + 1, hi)\\n\\treturn min(left, right);\\n\\n```\n```arr[4] < arr[6]```\n```arr[0] < arr[3]```\n```4```\n```min(4, 0) = 0```\n```python\\ndef findMin(self, nums: List[int]) -> int:\\n    return self.find_min(nums, 0, len(nums) - 1)\\n\\t\\ndef find_min(self, nums, lo, hi):\\n\\tif lo >= hi: return nums[lo]\\n\\tif nums[lo] <= nums[hi]: return nums[lo]\\n\\tmid = (lo + hi)//2\\n\\n\\tleft = self.find_min(nums, lo, mid)\\n\\tright = self.find_min(nums, mid + 1, hi)\\n\\treturn min(left, right)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 795316,
                "title": "runtime-beats-94-57-memory-usage-beats-94-67-best-easy-c",
                "content": "\\n      class Solution {\\n      public:\\n          int findMin(vector<int>& nums) {\\n              int start=0,end=nums.size()-1;\\n              while(start<end){\\n                  int mid=(start+end)/2;\\n                  if(nums[mid]<nums[end])\\n                      end=mid;\\n                  else\\n                      start=mid+1;\\n              }\\n              return nums[end];\\n          }\\n      };\\n\\t  \\n**Feel free to ask any question in the comment section.\\nIf you like this solution, do UPVOTE.\\nHappy Coding :)**\\n\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n      public:\\n          int findMin(vector<int>& nums) {\\n              int start=0,end=nums.size()-1;\\n              while(start<end){\\n                  int mid=(start+end)/2;\\n                  if(nums[mid]<nums[end])\\n                      end=mid;\\n                  else\\n                      start=mid+1;\\n              }",
                "codeTag": "Java"
            },
            {
                "id": 566768,
                "title": "intuitive-javascript-solution",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findMin = function(nums) {\\n    let left = 0;\\n    let right = nums.length - 1;\\n    // the goal is to use `left` to point at the minimn number    \\n    while (left < right) {\\n        const mid = Math.floor((left + right) / 2);\\n        if (nums[mid] > nums[right]) {\\n          left = mid + 1;\\n        } else {\\n          right = mid;\\n        }\\n    }\\n\\n    return nums[left];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findMin = function(nums) {\\n    let left = 0;\\n    let right = nums.length - 1;\\n    // the goal is to use `left` to point at the minimn number    \\n    while (left < right) {\\n        const mid = Math.floor((left + right) / 2);\\n        if (nums[mid] > nums[right]) {\\n          left = mid + 1;\\n        } else {\\n          right = mid;\\n        }\\n    }\\n\\n    return nums[left];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 373755,
                "title": "python-binary-search-compare-to-154",
                "content": "The problem 154 is harder than 153. \\n\\nAt first , we need to solve 153 ( no duplicate exists in the array )\\n\\n153.Find Minimum in Rotated Sorted Array:\\n\\nThese problems give no clear target , we can use ```nums[r]``` as judgement condition  \\nIt is very easy to find\\uFF1A\\n>if nums[mid] > nums[r]: # [3,4,5,1,2]\\n>l = mid+1 # min exist on the right side of the middle value\\n\\n>if nums[mid] < nums[r]: # [1,2,3,4,5] ,[4,5,1,2,3]\\n>r = mid # min exist on the left side of the middle value ( inclue middle value)\\n\\n>if nums[mid] == nums[r]: # Invalid\\n\\nCombining these conditions\\uFF1A\\n```python\\n# 153. Find Minimum in Rotated Sorted Array\\ndef findMin(self, nums: List[int]) -> int:\\n    l, r = 0, len(nums)-1\\n    while l < r:\\n        mid = (l+r)//2\\n        if nums[mid] > nums[r]:\\n            l = mid+1\\n        else:\\n            r = mid\\n    return nums[l]\\n```\\n\\n---------------------------------------\\n\\n154.Find Minimum in Rotated Sorted Array II:\\n\\nSame idea with 153\\n\\nIt is very easy to find\\uFF1A\\n>if nums[mid] > nums[r]: # [3,4,5,1,2]\\n>l = mid+1 # min exists on the right side of the middle value\\n\\n>if nums[mid] < nums[r]: # [1,2,3,4,5] ,[4,5,1,2,3]\\n>r = mid # min exists on the left side of the middle value ( inclue middle value)\\n\\nHere are the different parts\\uFF1A\\n\\n```python\\nif nums[mid] == nums[r]: # valid\\n\\tif nums[mid] == nums[l]: # [10, 5, 10, 10, 10] or [10, 10, 10, 5, 10] \\n\\t\\tl = l+1 # or r = r-1 # min could be on either side\\uFF0Cwe just narrow the interval\\n\\telif nums[l] < nums[mid]:  # [1, 5, 10, 10, 10]  \\n\\t\\tr = mid-1\\n\\telse:# [20, 5, 10, 10, 10]  or [20, 10, 10, 10, 10]\\n\\t\\tr = mid\\n```\\n\\nCombining these conditions\\uFF1A\\n```python\\n\\t# 154. Find Minimum in Rotated Sorted Array II\\n    def findMin(self, nums: List[int]) -> int:\\n        l, r = 0, len(nums)-1\\n        while l < r:\\n            mid = (l+r)//2\\n\\t\\t\\t# condition for 154\\n            if nums[mid] == nums[r]:\\n                if nums[mid] == nums[l]:\\n                    l = l+1 # or r = r-1\\n                elif nums[l] < nums[mid] :  \\n\\t                r = mid-1\\n                else:\\n                    r = mid\\n\\t\\t\\t# same as 153\\n            elif nums[mid] > nums[r]:\\n                l = mid+1\\n            else:\\n                r = mid\\n        return nums[l]\\n```\\n\\nWe can combine the judgment conditions in the loop, and choose a larger interval when we combine\\n\\n```python\\n\\t# 154. Find Minimum in Rotated Sorted Array II\\n    def findMin(self, nums: List[int]) -> int:\\n        l, r = 0, len(nums)-1\\n        while l < r:\\n            mid = (l+r)//2\\n            if nums[mid] == nums[r]:\\n                if nums[mid] == nums[l]:\\n                    l = l+1 # or r = r-1\\n                else:\\n                    r = mid\\n            elif nums[mid] > nums[r]:\\n                l = mid+1\\n            else:\\n                r = mid\\n        return nums[l]\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```nums[r]```\n```python\\n# 153. Find Minimum in Rotated Sorted Array\\ndef findMin(self, nums: List[int]) -> int:\\n    l, r = 0, len(nums)-1\\n    while l < r:\\n        mid = (l+r)//2\\n        if nums[mid] > nums[r]:\\n            l = mid+1\\n        else:\\n            r = mid\\n    return nums[l]\\n```\n```python\\nif nums[mid] == nums[r]: # valid\\n\\tif nums[mid] == nums[l]: # [10, 5, 10, 10, 10] or [10, 10, 10, 5, 10] \\n\\t\\tl = l+1 # or r = r-1 # min could be on either side\\uFF0Cwe just narrow the interval\\n\\telif nums[l] < nums[mid]:  # [1, 5, 10, 10, 10]  \\n\\t\\tr = mid-1\\n\\telse:# [20, 5, 10, 10, 10]  or [20, 10, 10, 10, 10]\\n\\t\\tr = mid\\n```\n```python\\n\\t# 154. Find Minimum in Rotated Sorted Array II\\n    def findMin(self, nums: List[int]) -> int:\\n        l, r = 0, len(nums)-1\\n        while l < r:\\n            mid = (l+r)//2\\n\\t\\t\\t# condition for 154\\n            if nums[mid] == nums[r]:\\n                if nums[mid] == nums[l]:\\n                    l = l+1 # or r = r-1\\n                elif nums[l] < nums[mid] :  \\n\\t                r = mid-1\\n                else:\\n                    r = mid\\n\\t\\t\\t# same as 153\\n            elif nums[mid] > nums[r]:\\n                l = mid+1\\n            else:\\n                r = mid\\n        return nums[l]\\n```\n```python\\n\\t# 154. Find Minimum in Rotated Sorted Array II\\n    def findMin(self, nums: List[int]) -> int:\\n        l, r = 0, len(nums)-1\\n        while l < r:\\n            mid = (l+r)//2\\n            if nums[mid] == nums[r]:\\n                if nums[mid] == nums[l]:\\n                    l = l+1 # or r = r-1\\n                else:\\n                    r = mid\\n            elif nums[mid] > nums[r]:\\n                l = mid+1\\n            else:\\n                r = mid\\n        return nums[l]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 48475,
                "title": "binary-search-solution",
                "content": "```\\npublic int findMin(int[] nums) {\\n    int lo = 0, hi = nums.length - 1;\\n    while (lo < hi) {\\n        int mid = lo + (hi - lo) / 2;\\n            \\n        if (nums[mid] < nums[hi]) {\\n            hi = mid;    \\n        } else {\\n            lo = mid + 1; \\n        }\\n    }\\n    return nums[lo];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int findMin(int[] nums) {\\n    int lo = 0, hi = nums.length - 1;\\n    while (lo < hi) {\\n        int mid = lo + (hi - lo) / 2;\\n            \\n        if (nums[mid] < nums[hi]) {\\n            hi = mid;    \\n        } else {\\n            lo = mid + 1; \\n        }\\n    }\\n    return nums[lo];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 48521,
                "title": "swift-solution-binary-search",
                "content": "```\\nclass Solution {\\n    func findMin(_ nums: [Int]) -> Int {\\n        if nums.count == 0 {\\n            return 0\\n        }\\n        \\n        var left = 0\\n        var right = nums.count - 1\\n        var middle = 0\\n        \\n        while left < right {\\n            middle = (left + right) / 2\\n            if nums[middle] > nums[right] {\\n                left = middle + 1\\n            } else {\\n                right = middle\\n            }\\n        }\\n        \\n        return nums[left]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    func findMin(_ nums: [Int]) -> Int {\\n        if nums.count == 0 {\\n            return 0\\n        }\\n        \\n        var left = 0\\n        var right = nums.count - 1\\n        var middle = 0\\n        \\n        while left < right {\\n            middle = (left + right) / 2\\n            if nums[middle] > nums[right] {\\n                left = middle + 1\\n            } else {\\n                right = middle\\n            }\\n        }\\n        \\n        return nums[left]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 48579,
                "title": "simple-java-recursive",
                "content": "```\\n public int findMin(int[] nums) {\\n        return findMin(nums, 0, nums.length-1);\\n    }\\n    \\n    public int findMin(int[] nums, int l, int h) {\\n        if (l >= h) {\\n            return nums[l];\\n        }\\n        \\n        int mid = (h+l)/2;\\n        if (nums[mid] > nums[h]) {\\n            return findMin(nums, mid+1, h);\\n        }\\n        return findMin(nums, l, mid);\\n    }",
                "solutionTags": [],
                "code": "```\\n public int findMin(int[] nums) {\\n        return findMin(nums, 0, nums.length-1);\\n    }\\n    \\n    public int findMin(int[] nums, int l, int h) {\\n        if (l >= h) {\\n            return nums[l];\\n        }\\n        \\n        int mid = (h+l)/2;\\n        if (nums[mid] > nums[h]) {\\n            return findMin(nums, mid+1, h);\\n        }\\n        return findMin(nums, l, mid);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3707687,
                "title": "beats-100-easy-binary-search-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        //using log n algo(binary search)\\n\\n        int low=0;\\n        int high=nums.size()-1;\\n        int ans=INT_MAX;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(nums[mid]>=nums[low]){// means left half is sorted\\n                ans=min(ans,nums[low]);  //storing the minimum \\n                low=mid+1; //eleminating left half\\n            }\\n            else{ //else right half is sorted\\n                ans=min(ans,nums[mid]);// storing the minimum\\n                high=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        //using log n algo(binary search)\\n\\n        int low=0;\\n        int high=nums.size()-1;\\n        int ans=INT_MAX;\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(nums[mid]>=nums[low]){// means left half is sorted\\n                ans=min(ans,nums[low]);  //storing the minimum \\n                low=mid+1; //eleminating left half\\n            }\\n            else{ //else right half is sorted\\n                ans=min(ans,nums[mid]);// storing the minimum\\n                high=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687520,
                "title": "binary-search-super-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        int l=0;\\n        int h=nums.length-1;\\n        while(l<h){\\n            int mid=l+(h-l)/2;\\n            if(nums[mid]>nums[h]){\\n                l=mid+1;\\n            }\\n            else{\\n                h=mid;\\n            }\\n        }\\n        return nums[h];\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        int l=0;\\n        int h=nums.length-1;\\n        while(l<h){\\n            int mid=l+(h-l)/2;\\n            if(nums[mid]>nums[h]){\\n                l=mid+1;\\n            }\\n            else{\\n                h=mid;\\n            }\\n        }\\n        return nums[h];\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531454,
                "title": "java-easy-solution-binary-search-runtime-0ms-beat-100",
                "content": "\\n# Binary Search Code\\n```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n\\n        int start = 0, end = nums.length - 1;\\n        while(start < end)\\n        {\\n          int mid = start + (end -start) / 2;\\n          if(nums[mid] > nums[end])\\n          start = mid + 1 ;\\n          \\n          if(nums[mid] < nums[end])\\n          end = mid ;\\n        }\\n        return nums[start];\\n    }\\n}\\n```\\n\\n# Simple Program Code\\n```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        \\n         int min=Integer. MAX_VALUE;\\n         for(int i=0;i<nums.length;i++)\\n             min =Math.min(nums[i],min);\\n         return min;\\n    }\\n}\\n```\\n# Please Upvote if you find this helpful",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n\\n        int start = 0, end = nums.length - 1;\\n        while(start < end)\\n        {\\n          int mid = start + (end -start) / 2;\\n          if(nums[mid] > nums[end])\\n          start = mid + 1 ;\\n          \\n          if(nums[mid] < nums[end])\\n          end = mid ;\\n        }\\n        return nums[start];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        \\n         int min=Integer. MAX_VALUE;\\n         for(int i=0;i<nums.length;i++)\\n             min =Math.min(nums[i],min);\\n         return min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451246,
                "title": "simple-java-solution-beats-100-please-upvote-if-you-find-it-helpful-3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach \\n- Binary search \\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: log(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n      int start = 0;\\n        int end = nums.length - 1;\\n        while (start < end) {\\n            int mid = start + (end - start) / 2;\\n            if (nums[mid] < nums[end]) {\\n                end = mid;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n        return nums[start];\\n//Do upvote please\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n      int start = 0;\\n        int end = nums.length - 1;\\n        while (start < end) {\\n            int mid = start + (end - start) / 2;\\n            if (nums[mid] < nums[end]) {\\n                end = mid;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n        return nums[start];\\n//Do upvote please\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3391933,
                "title": "simple-javascript-easy-explanation-tutorial-o-logn-time-97-48-beats-47ms",
                "content": "![Screenshot 2023-04-08 at 01.33.37.png](https://assets.leetcode.com/users/images/4afa4390-9539-4cc8-bf7e-68948645cc30_1680910457.323517.png)\\n\\n\\n# How code works:\\n```\\n          /-----------------------------\\\\\\n          |                             |\\nInput: [4, 5, 6, 7, 0, 1, 2, 3]\\n        |                             |\\n        \\\\-----------------------------/\\n        \\n      /-----------------------------\\\\\\n      |                             |\\nleft: 0                           right: 7\\n      |                             |\\n      \\\\-----------------------------/\\n      \\n         /---------------------\\\\\\n         |                     |\\nmid: 3                     nums[mid]: 7\\n         |                     |\\n         \\\\---------------------/\\n         \\nSince nums[mid] > nums[right], we move left pointer to mid+1\\n       \\n          /-----------------------------\\\\\\n          |                             |\\nInput: [4, 5, 6, 7, 0, 1, 2, 3]\\n                      |              |\\n                      \\\\--------------/\\n        \\n      /-----------------------------\\\\\\n      |                             |\\nleft: 4                           right: 7\\n      |                             |\\n      \\\\-----------------------------/\\n      \\n         /---------------------\\\\\\n         |                     |\\nmid: 5                    nums[mid]: 1\\n         |                     |\\n         \\\\---------------------/\\n         \\nSince nums[mid] < nums[right], we move right pointer to mid\\n\\n          /-----------------------------\\\\\\n          |                             |\\nInput: [4, 5, 6, 7, 0, 1, 2, 3]\\n                      |        |\\n                      \\\\--------/\\n        \\n      /-----------------------------\\\\\\n      |                             |\\nleft: 4                           right: 5\\n      |                             |\\n      \\\\-----------------------------/\\n      \\n         /---------------------\\\\\\n         |                     |\\nmid: 4                    nums[mid]: 0\\n         |                     |\\n         \\\\---------------------/\\n         \\nSince nums[mid] < nums[right], we move right pointer to mid\\n\\n          /-----------------------------\\\\\\n          |                             |\\nInput: [4, 5, 6, 7, 0, 1, 2, 3]\\n                      |  |\\n                      \\\\--/\\n        \\n      /-----------------------------\\\\\\n      |                             |\\nleft: 4                           right: 4\\n      |                             |\\n      \\\\-----------------------------/\\n      \\nSince left === right, we have found the minimum element: nums[left] (which is 0 in this case)\\n\\n```\\n# Explanation\\n1. It initializes two pointers left and right to the first and last indices of the array, respectively.\\n\\n2. The function enters a while loop that runs as long as left is less than right.\\n\\n3. Inside the while loop, the function calculates the middle index of the current range using the formula mid = Math.floor((left + right) / 2).\\n\\n4. The function checks whether the value at the middle index nums[mid] is greater than the value at the right index nums[right].\\n\\n5. If the value at the middle index is greater than the value at the right index, then the minimum element must be in the right half of the current range, so the left pointer is updated to mid + 1.\\n\\n6. If the value at the middle index is not greater than the value at the right index, then the minimum element must be in the left half of the current range, so the right pointer is updated to mid.\\n\\n7. The while loop continues until the range is reduced to a single element, at which point left and right point to the same index, and the minimum element is simply nums[left].\\n\\n8. Finally, the function returns the minimum element of the array.\\n# Complexity\\n- Time complexity:\\nIt is O(log N), where N is the number of elements in the input array. This is because at each step of the binary search, the size of the search space is halved.\\n\\n- Space complexity:\\nIt is O(1), which means that the amount of memory used by the algorithm is constant and does not depend on the size of the input array. This is because the algorithm only uses a few variables to keep track of the search space and does not create any additional data structures.\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findMin = function (nums) {\\n  let left = 0,\\n    right = nums.length - 1;\\n\\n  while (left < right) {\\n    let mid = Math.floor((left + right) / 2);\\n    if (nums[mid] > nums[right]) left = mid + 1;\\n    else right = mid;\\n  }\\n  return nums[left];\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n          /-----------------------------\\\\\\n          |                             |\\nInput: [4, 5, 6, 7, 0, 1, 2, 3]\\n        |                             |\\n        \\\\-----------------------------/\\n        \\n      /-----------------------------\\\\\\n      |                             |\\nleft: 0                           right: 7\\n      |                             |\\n      \\\\-----------------------------/\\n      \\n         /---------------------\\\\\\n         |                     |\\nmid: 3                     nums[mid]: 7\\n         |                     |\\n         \\\\---------------------/\\n         \\nSince nums[mid] > nums[right], we move left pointer to mid+1\\n       \\n          /-----------------------------\\\\\\n          |                             |\\nInput: [4, 5, 6, 7, 0, 1, 2, 3]\\n                      |              |\\n                      \\\\--------------/\\n        \\n      /-----------------------------\\\\\\n      |                             |\\nleft: 4                           right: 7\\n      |                             |\\n      \\\\-----------------------------/\\n      \\n         /---------------------\\\\\\n         |                     |\\nmid: 5                    nums[mid]: 1\\n         |                     |\\n         \\\\---------------------/\\n         \\nSince nums[mid] < nums[right], we move right pointer to mid\\n\\n          /-----------------------------\\\\\\n          |                             |\\nInput: [4, 5, 6, 7, 0, 1, 2, 3]\\n                      |        |\\n                      \\\\--------/\\n        \\n      /-----------------------------\\\\\\n      |                             |\\nleft: 4                           right: 5\\n      |                             |\\n      \\\\-----------------------------/\\n      \\n         /---------------------\\\\\\n         |                     |\\nmid: 4                    nums[mid]: 0\\n         |                     |\\n         \\\\---------------------/\\n         \\nSince nums[mid] < nums[right], we move right pointer to mid\\n\\n          /-----------------------------\\\\\\n          |                             |\\nInput: [4, 5, 6, 7, 0, 1, 2, 3]\\n                      |  |\\n                      \\\\--/\\n        \\n      /-----------------------------\\\\\\n      |                             |\\nleft: 4                           right: 4\\n      |                             |\\n      \\\\-----------------------------/\\n      \\nSince left === right, we have found the minimum element: nums[left] (which is 0 in this case)\\n\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar findMin = function (nums) {\\n  let left = 0,\\n    right = nums.length - 1;\\n\\n  while (left < right) {\\n    let mid = Math.floor((left + right) / 2);\\n    if (nums[mid] > nums[right]) left = mid + 1;\\n    else right = mid;\\n  }\\n  return nums[left];\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3171445,
                "title": "find-minimum-in-rotated-sorted-array-brute-force-optimized-o-log-n-c-python",
                "content": "# Intuition\\n\\nThis seems like an easy problem if we want to brute force it. But given it is a rotated \"sorted\" array, we can think about optimizing the solution. Algorithms with ```log N``` approach comes to mind and Binary search seems like a good candidate given the nature of the problem wherein we have to incrementally prune some sample space to get closer to our result.\\n\\nThe array in question looks something like below.\\n\\n![SmartSelect_20230211_152712_Samsung Notes.jpg](https://assets.leetcode.com/users/images/20894a32-4a98-4c03-bdd7-41b3830fdd5a_1676109667.668417.jpeg)\\n\\n\\n\\nIt is clear that we can apply some form of pruning on the array space to narrow down the result. Then it becomes a classic binary search problem with minor changes in logic for boundary and mid pointers.\\n\\n----------------\\n\\n# Approach 1 - Brute Force (Accepted)\\n\\nThe simplest approach that comes to mind after reading the problem is brute forcing through the array space and returning the minimum element among all candidates.\\n\\n## Complexity\\n- Time complexity:\\n```O(n)``` as we are traversing all the elements to arrive at the result.\\n\\n- Space complexity:\\n```O(1)``` as we are not using any extra container / array etc. to store intermediate results to arrive at the solution.\\n\\n## Code\\n```cpp []\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int min_ele = INT_MAX; // Assign min as INT_MAX\\n        for(int i = 0; i < nums.size(); ++i) {\\n            if(nums[i] < min_ele) {\\n                min_ele = nums[i]; // Check if cur element less than min and update\\n            }\\n        }\\n        return min_ele;\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        # Keeping it simple, no fancy lamda\\'s here for now\\n        min = 1e9\\n        for num in nums:\\n            if num < min:\\n                min = num\\n\\n        return min\\n```\\n\\n--------------\\n\\n# Approach 2 - Optimized ( Binary Search )\\n\\nAs mentioned above, we are given in the problem statement that the array is a rotated form of its sorted version, so binary search comes to mind. We can prune the search space according to the condition in hand and proceed further. Compare the mid element with the last element and if its larger, prune the left side as minimum will lie on right side. Similarly, follow this for left side conversions.\\n\\n\\n## Code\\n```cpp []\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        // Assign l and r as array boundaries for initial search space\\n        int l = 0,r = nums.size() - 1;\\n        // Binary search loop\\n        while(l < r) {\\n            int m = (l + r) / 2; // Or use l + (r - l) / 2 for overflows\\n            if(nums[m] > nums[r]) l = m + 1;  // Prune the left space as min lie in right\\n            else r = m; // Prune the right space, m can be min also\\n        }\\n        return nums[l]; // Return the min i.e. l index\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        # Keeping it simple, no fancy lamda\\'s here for now\\n        # Assign l and r as array boundaries for initial search space\\n        l, r = 0, len(nums) - 1\\n\\n        # Binary search loop\\n        while l < r:\\n\\n            m = (l + r) // 2  # Or use l + (r - l) / 2 for overflows\\n            if nums[m] > nums[r]: l = m + 1  # Prune the left space as min lie in right\\n            else: r = m  # Prune the right space, m can be min also\\n        \\n        return nums[l]  # Return the min i.e. l index\\n```\\n\\n## Algorithm\\n\\nWe will look at the algorithm using an example array ```[4, 5, 6, 7, 0, 1, 2]```.\\n\\n1. *Iteration 1*: ```m = (l + r) / 2``` which gives ```m = 3```. Now clearly ```nums[m] > nums[r]```, hence we can prune the left portion as minimum can\\'t lie in this range. So, ```l = m + 1``` and ```r``` will remain unchanged.\\n\\n![SmartSelect_20230211_152407_Samsung Notes.jpg](https://assets.leetcode.com/users/images/303fba0d-0dea-4d94-ae19-968cf08d7c16_1676109720.698023.jpeg)\\n\\n\\n\\n2. *Iteration 2*: ```m = (l + r) / 2``` which gives ```m = 5```. Now, code will go into the else condition as ```nums[m] < nums[r]```. This means result should lie in left portion ( It can be mid as well ). Hence, ```r = m``` and ```l``` remains unchanged.\\n\\n![SmartSelect_20230211_152355_Samsung Notes.jpg](https://assets.leetcode.com/users/images/c1283262-ea27-4516-995e-dabfea92aaad_1676109733.7054012.jpeg)\\n\\n\\n\\n\\n3. *Iteration 3*: ```m = (l + r) / 2``` which gives ```m = 4```. Now, code will go into the else condition as ```nums[m] < nums[r]```. This means result should lie in left portion ( It can be mid as well ). Hence, ```r = m = 4``` and ```l = 4``` as well (unchanged).\\n\\n![SmartSelect_20230211_152334_Samsung Notes.jpg](https://assets.leetcode.com/users/images/5ef33a0e-5d5b-4d64-8690-56b71501fb65_1676109749.5078168.jpeg)\\n\\n\\n4. Iteration 4: Here, ```l(4)``` not less than ```r(4)```, hence the loop will break and we will return ```nums[l]``` i.e. 0 as our result.\\n\\n\\nWe can quickly look at some corner case as well ( e.g. ```[5, 4]```. This will return after setting ```l``` to index ```1``` as ```arr[m] > arr[r]```). You can dry run on some other cases to have a better understanding / visualisation.\\n\\n\\n\\n\\n## Complexity\\n- Time complexity:\\n```O(log N)``` similar to Binary Search algorithm\\n\\n- Space complexity:\\n```O(1)``` similar to Binary Search as we are not using any extra space.\\n",
                "solutionTags": [
                    "C++",
                    "Python"
                ],
                "code": "```log N```\n```O(n)```\n```O(1)```\n```cpp []\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int min_ele = INT_MAX; // Assign min as INT_MAX\\n        for(int i = 0; i < nums.size(); ++i) {\\n            if(nums[i] < min_ele) {\\n                min_ele = nums[i]; // Check if cur element less than min and update\\n            }\\n        }\\n        return min_ele;\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        # Keeping it simple, no fancy lamda\\'s here for now\\n        min = 1e9\\n        for num in nums:\\n            if num < min:\\n                min = num\\n\\n        return min\\n```\n```cpp []\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        // Assign l and r as array boundaries for initial search space\\n        int l = 0,r = nums.size() - 1;\\n        // Binary search loop\\n        while(l < r) {\\n            int m = (l + r) / 2; // Or use l + (r - l) / 2 for overflows\\n            if(nums[m] > nums[r]) l = m + 1;  // Prune the left space as min lie in right\\n            else r = m; // Prune the right space, m can be min also\\n        }\\n        return nums[l]; // Return the min i.e. l index\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        # Keeping it simple, no fancy lamda\\'s here for now\\n        # Assign l and r as array boundaries for initial search space\\n        l, r = 0, len(nums) - 1\\n\\n        # Binary search loop\\n        while l < r:\\n\\n            m = (l + r) // 2  # Or use l + (r - l) / 2 for overflows\\n            if nums[m] > nums[r]: l = m + 1  # Prune the left space as min lie in right\\n            else: r = m  # Prune the right space, m can be min also\\n        \\n        return nums[l]  # Return the min i.e. l index\\n```\n```[4, 5, 6, 7, 0, 1, 2]```\n```m = (l + r) / 2```\n```m = 3```\n```nums[m] > nums[r]```\n```l = m + 1```\n```r```\n```m = (l + r) / 2```\n```m = 5```\n```nums[m] < nums[r]```\n```r = m```\n```l```\n```m = (l + r) / 2```\n```m = 4```\n```nums[m] < nums[r]```\n```r = m = 4```\n```l = 4```\n```l(4)```\n```r(4)```\n```nums[l]```\n```[5, 4]```\n```l```\n```1```\n```arr[m] > arr[r]```\n```O(log N)```\n```O(1)```",
                "codeTag": "Java"
            },
            {
                "id": 3109620,
                "title": "efficient-way-to-approach-runtime-0ms-tc-o-logn",
                "content": "# Intuition\\nBy using binary search approach\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(logn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& arr) \\n    {\\n       int low = 0;\\n       int high = arr.size()-1;\\n       if(arr.size() == 1)\\n       {\\n           return arr[0];\\n       }\\n       while(low<high)\\n       {\\n           int mid = (low+high)/2;\\n           if(arr[low]< arr[low+1] && arr[low]<arr[high])\\n           {\\n               return arr[low];\\n           }\\n           if(arr[mid]<arr[mid+1] && arr[mid]<arr[mid-1])\\n           {\\n               return arr[mid];\\n           }\\n           if(arr[mid] > arr[mid+1] && arr[mid]> arr[mid]-1)\\n           {\\n               return arr[mid+1];\\n           }\\n           if(arr[mid]<arr[low])\\n           {\\n               high = mid-1;\\n           }\\n           else if(arr[mid]>arr[low])\\n           {\\n               low = mid+1;\\n           }\\n       }\\n       return -1;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& arr) \\n    {\\n       int low = 0;\\n       int high = arr.size()-1;\\n       if(arr.size() == 1)\\n       {\\n           return arr[0];\\n       }\\n       while(low<high)\\n       {\\n           int mid = (low+high)/2;\\n           if(arr[low]< arr[low+1] && arr[low]<arr[high])\\n           {\\n               return arr[low];\\n           }\\n           if(arr[mid]<arr[mid+1] && arr[mid]<arr[mid-1])\\n           {\\n               return arr[mid];\\n           }\\n           if(arr[mid] > arr[mid+1] && arr[mid]> arr[mid]-1)\\n           {\\n               return arr[mid+1];\\n           }\\n           if(arr[mid]<arr[low])\\n           {\\n               high = mid-1;\\n           }\\n           else if(arr[mid]>arr[low])\\n           {\\n               low = mid+1;\\n           }\\n       }\\n       return -1;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3063682,
                "title": "easily-explained-java-sol-0ms-100-beats-o-log-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach: Binary Search\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n      int low=0,high = nums.length-1;\\n      while(low<=high){\\n      int mid = low + (high-low)/2;\\n      \\n      if(nums[low]<=nums[high]){\\n      //if given array is sorted then then returning 1\\'st element.\\n          return nums[0];  \\n      }\\n      if(nums[mid]>nums[mid+1]){\\n      //if nums[mid] is greater then its next element the it means it is the breakpoint and nums[mid] is largest element and its next is lowest.  \\n          return nums[mid+1];\\n      }\\n      else if(nums[mid]<nums[mid-1]){\\n      //Since the array is sorted and rotated so if an element is smaller than its previous element then that element is lowest of all.\\n          return nums[mid];\\n      }\\n      else if(nums[mid]>=nums[low]){\\n      //This portion of the array is sorted and we won\\'t find smallest element here so we move our low to mid+1.\\n          low = mid+1;\\n      }else if(nums[mid]<=nums[high]){\\n      //This portion of the array is sorted and we won\\'t find smallest element here so we move our high to mid-1.  \\n          high = mid-1;\\n      }\\n      }  return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n      int low=0,high = nums.length-1;\\n      while(low<=high){\\n      int mid = low + (high-low)/2;\\n      \\n      if(nums[low]<=nums[high]){\\n      //if given array is sorted then then returning 1\\'st element.\\n          return nums[0];  \\n      }\\n      if(nums[mid]>nums[mid+1]){\\n      //if nums[mid] is greater then its next element the it means it is the breakpoint and nums[mid] is largest element and its next is lowest.  \\n          return nums[mid+1];\\n      }\\n      else if(nums[mid]<nums[mid-1]){\\n      //Since the array is sorted and rotated so if an element is smaller than its previous element then that element is lowest of all.\\n          return nums[mid];\\n      }\\n      else if(nums[mid]>=nums[low]){\\n      //This portion of the array is sorted and we won\\'t find smallest element here so we move our low to mid+1.\\n          low = mid+1;\\n      }else if(nums[mid]<=nums[high]){\\n      //This portion of the array is sorted and we won\\'t find smallest element here so we move our high to mid-1.  \\n          high = mid-1;\\n      }\\n      }  return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2938014,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1)\\n        return nums[0];\\n        if(n==2)\\n        return min(nums[0], nums[1]);\\n        int l=0, h=n-1;\\n        while(l<=h)\\n        {\\n            int m=(l+h)/2;\\n            if(m==0 && nums[m]<nums[m+1])\\n            return nums[m];\\n            if(m==n-1 && nums[m]<nums[m-1])\\n            return nums[m];\\n            if(m!=0 && m!=n-1 && nums[m]<nums[m-1] && nums[m]<nums[m+1])\\n            return nums[m];\\n            if(nums[h]>nums[m])\\n            h=m-1;\\n            else\\n            l=m+1;\\n            cout<<l<<\" \"<<h<<\"\\\\n\";\\n        }\\n        return -1;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1)\\n        return nums[0];\\n        if(n==2)\\n        return min(nums[0], nums[1]);\\n        int l=0, h=n-1;\\n        while(l<=h)\\n        {\\n            int m=(l+h)/2;\\n            if(m==0 && nums[m]<nums[m+1])\\n            return nums[m];\\n            if(m==n-1 && nums[m]<nums[m-1])\\n            return nums[m];\\n            if(m!=0 && m!=n-1 && nums[m]<nums[m-1] && nums[m]<nums[m+1])\\n            return nums[m];\\n            if(nums[h]>nums[m])\\n            h=m-1;\\n            else\\n            l=m+1;\\n            cout<<l<<\" \"<<h<<\"\\\\n\";\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2934986,
                "title": "simple-java-sol",
                "content": "\\n# Approach\\n<!-- In rotated array either half of the array will be sorted. -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        int left = 0, right = nums.length - 1;\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] > nums[right]) left = mid + 1;\\n            else right = mid;\\n        }\\n     \\n        return nums[left];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        int left = 0, right = nums.length - 1;\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] > nums[right]) left = mid + 1;\\n            else right = mid;\\n        }\\n     \\n        return nums[left];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2720999,
                "title": "c-java-python3-javascript-solution",
                "content": "**\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-153-find-minimum-in-rotated-sorted-array-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-153-find-minimum-in-rotated-sorted-array-solution-and-explanation-en/)\\u2B50**\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know (leave comment or messenger me).\\n\\n**Example : C# Solution(\\u2B06To see other languages \\u2B06)**\\n```\\npublic class Solution {\\n    public int FindMin(int[] nums) {\\n        int li = 0;             //low index\\n        int hi = nums.Length-1; //high index\\n      \\n        while(hi>li)\\n        {\\n            int midi = li+(hi-li)/2;\\n            \\n            if (nums[midi] < nums[hi]) \\n            {\\n                hi = midi;\\n            } \\n            else \\n            {\\n                li = midi+1;\\n            }\\n        }\\n        \\n        return nums[li];\\n    }\\n}\\n```\\nTime Complexity : O(log n)\\n\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to let me know.  Thanks!\\n\\nYou can find out other LeetCode problems solution\\u2B07\\n**\\u2B50[Zyrastory - Food & Code Research Center](https://zyrastory.com/en/category/coding-en/leetcode-en/)\\u2B50**",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\npublic class Solution {\\n    public int FindMin(int[] nums) {\\n        int li = 0;             //low index\\n        int hi = nums.Length-1; //high index\\n      \\n        while(hi>li)\\n        {\\n            int midi = li+(hi-li)/2;\\n            \\n            if (nums[midi] < nums[hi]) \\n            {\\n                hi = midi;\\n            } \\n            else \\n            {\\n                li = midi+1;\\n            }\\n        }\\n        \\n        return nums[li];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2616422,
                "title": "java-100-faster-binary-search-easy-solution",
                "content": "```\\nint k=nums[0],i=0,j=nums.length-1;\\nif(nums[i]<=nums[j])                            //checks if array is rotated or not\\n\\treturn nums[i];\\nwhile(i!=j){\\n\\tif(k>nums[(i+j)/2])                         //binary search operation type\\n\\t\\tj = (i+j)/2;\\n\\telse if(k<=nums[(i+j)/2]){\\n\\t\\tif(nums[(i+j)/2]>nums[(i+j)/2+1])\\n\\t\\t\\treturn nums[(i+j)/2+1];\\n\\t\\tk=nums[(i+j)/2];\\n\\t\\ti=(i+j)/2;\\n\\t}\\n}\\nreturn nums[(i+j)/2];\\n```\\n**If you have any question, feel free to ask. If you like the solution or the explanation, Please UPVOTE !**\\n",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nint k=nums[0],i=0,j=nums.length-1;\\nif(nums[i]<=nums[j])                            //checks if array is rotated or not\\n\\treturn nums[i];\\nwhile(i!=j){\\n\\tif(k>nums[(i+j)/2])                         //binary search operation type\\n\\t\\tj = (i+j)/2;\\n\\telse if(k<=nums[(i+j)/2]){\\n\\t\\tif(nums[(i+j)/2]>nums[(i+j)/2+1])\\n\\t\\t\\treturn nums[(i+j)/2+1];\\n\\t\\tk=nums[(i+j)/2];\\n\\t\\ti=(i+j)/2;\\n\\t}\\n}\\nreturn nums[(i+j)/2];\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2204855,
                "title": "java-simple-solution-binary-search-0ms",
                "content": "```\\nclass Solution {\\n    public int findMin(int[] arr) {\\n        int lo=0, hi=arr.length-1;\\n        while(lo<hi) {\\n          int mid = (lo+hi)/2;\\n          if(arr[mid]<arr[hi]) \\n            hi=mid;\\n          else \\n            lo=mid+1;\\n        }\\n        return arr[lo];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int findMin(int[] arr) {\\n        int lo=0, hi=arr.length-1;\\n        while(lo<hi) {\\n          int mid = (lo+hi)/2;\\n          if(arr[mid]<arr[hi]) \\n            hi=mid;\\n          else \\n            lo=mid+1;\\n        }\\n        return arr[lo];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2163713,
                "title": "easiest-code-java-0ms-o-logn-time-complexity",
                "content": "```\\nclass Solution {\\n    public int findMin(int[] arr) {\\n        int n = arr.length;\\n        int low = 0;\\n        int high = n - 1;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            int prev = (mid - 1 + n) % n;\\n            int next = (mid + 1) % n;\\n            if (arr[mid] <= arr[prev]\\n                    && arr[mid] <= arr[next])\\n                return arr[mid];\\n            else if (arr[mid] <= arr[high])\\n                high = mid - 1;\\n            else if (arr[low]<=arr[mid])\\n                low = mid + 1;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int findMin(int[] arr) {\\n        int n = arr.length;\\n        int low = 0;\\n        int high = n - 1;\\n        while (low <= high) {\\n            int mid = low + (high - low) / 2;\\n            int prev = (mid - 1 + n) % n;\\n            int next = (mid + 1) % n;\\n            if (arr[mid] <= arr[prev]\\n                    && arr[mid] <= arr[next])\\n                return arr[mid];\\n            else if (arr[mid] <= arr[high])\\n                high = mid - 1;\\n            else if (arr[low]<=arr[mid])\\n                low = mid + 1;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846880,
                "title": "o-logn-100-faster-binary-search-step-by-step-explanation-c",
                "content": "Seeing the complexity, the most traditional way that comes in mind is binary search. Although as the array is rotated, we cannot apply binary search just like that but we can surely take advantage as the array rotated was sorted initially. \\n\\nLet\\'s see how we can approach the problem.\\n\\n* The first thing that will be checked is if the array is already sorted i.e. given array is not rotated. This can simply be checked by comparing the first and the last element of the array. \\n```\\nif(nums[0] < nums[n-1]) return nums[0];\\n```\\n* Now when the array is rotated, let\\'s understand using an example.\\nLet\\'s say we are given an array as: \\n```\\n[5, 6, 7, 8, 1, 2, 3, 4]\\n```\\nClearly, the array is rotated 4 times. We want to find the minimum element (in this case \"1\").\\nNow, we\\'ll start applying BS. So the first thing that we need to find is mid. \\n```\\nmid = start + (end - start) / 2;\\n```\\nWhen we find the mid element we analyse whether the calculated mid element answers our question. If yes, how do we check the same in this question?\\nThat can simply be checked by comparing it with its adjacent elements, as minimum element is asked that means when the elements adjacent to mid are both greater than it, we can return mid.\\n```\\nif( nums[mid] < prev && nums[mid] < nex) return nums[mid];\\n```\\n* The next task is to analyse which half should be considered for further evaluation and which half to discard.\\nIf you work out the example given you\\'ll notice that the first part of the array is sorted while the second part is not after calculating mid (in this case \"5\") and that is where our minimum element lies. So basically we need to apply a condition to move to the unsorted part of the array.\\n```\\nif(nums[mid] > nums[end]) start=mid+1;\\nelse end=mid-1;\\n```\\nBy using above three conditions, we can simply answer the question, but the challenge here is when our mid becomes the first or last element in that case if we compare as-\\n```\\nif(nums[mid] < nums[mid+1] && nums[mid] < nums[mid-1]) \\n```\\nWe\\'ll be going out of bound of array index. To fix this, we can declare 2 variables as-\\n```\\nint prev= (mid+n-1)%n, nex=(mid+1)%n; // n=size of the array\\n```\\nThis way our array will become circular, and we will not be going out of bounds.\\n\\nAfter going through this, you\\'ll get sufficient hints and will be able to code it yourself. \\uD83D\\uDE0A\\nDo upvote, if you liked the solution.",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nif(nums[0] < nums[n-1]) return nums[0];\\n```\n```\\n[5, 6, 7, 8, 1, 2, 3, 4]\\n```\n```\\nmid = start + (end - start) / 2;\\n```\n```\\nif( nums[mid] < prev && nums[mid] < nex) return nums[mid];\\n```\n```\\nif(nums[mid] > nums[end]) start=mid+1;\\nelse end=mid-1;\\n```\n```\\nif(nums[mid] < nums[mid+1] && nums[mid] < nums[mid-1]) \\n```\n```\\nint prev= (mid+n-1)%n, nex=(mid+1)%n; // n=size of the array\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1840289,
                "title": "c-binary-search-pivot-element",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        \\n        // Checking if the array is sorted or not\\n        \\n        // If the array is already sorted ..just retuen the first element\\n        \\n        if(nums[0]<nums[nums.size()-1])\\n        {\\n            return nums[0];\\n        }\\n        \\n        \\n        \\n       // Find the Pivot element\\n        \\n        int low=0;\\n        int high=nums.size()-1;\\n        \\n        while(low<high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(nums[mid]>=nums[0])\\n            {\\n                low=mid+1;\\n            }\\n            else\\n            {\\n                high=mid;\\n            }\\n        }\\n        return nums[high];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        \\n        // Checking if the array is sorted or not\\n        \\n        // If the array is already sorted ..just retuen the first element\\n        \\n        if(nums[0]<nums[nums.size()-1])\\n        {\\n            return nums[0];\\n        }\\n        \\n        \\n        \\n       // Find the Pivot element\\n        \\n        int low=0;\\n        int high=nums.size()-1;\\n        \\n        while(low<high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(nums[mid]>=nums[0])\\n            {\\n                low=mid+1;\\n            }\\n            else\\n            {\\n                high=mid;\\n            }\\n        }\\n        return nums[high];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1796347,
                "title": "java-aditya-verma-binary-search-explained-0ms-100",
                "content": "Please Upvote if you find this useful (< : \\n```\\nclass Solution {\\n    public int findMin(int[] arr) {\\n        \\n        int n = arr.length;\\n        int lo=0, hi=n-1;\\n        \\n        \\n        while(lo<=hi)\\n        {\\n            int mid = lo + ((hi-lo)>>1);\\n            int next = (mid+1)%n;\\n            int prev = (mid-1+n)%n;\\n            //1.This is for checking if the subarray is already sorted.\\n            if(arr[mid]<=arr[hi] && arr[mid]>=arr[lo])\\n            {\\n                return arr[lo];\\n            }\\n            //rest code is same as told by sir Aditya verma.\\n            if(arr[mid]<=arr[next] && arr[mid]<=arr[prev])\\n            {\\n                return arr[mid];\\n            }\\n            \\n            else if(arr[mid]>=arr[lo])\\n            {\\n                lo=mid+1;\\n            }\\n            else if(arr[mid]<=arr[hi])\\n            {\\n                hi=mid-1;\\n            }\\n        }\\n        return arr[0];\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int findMin(int[] arr) {\\n        \\n        int n = arr.length;\\n        int lo=0, hi=n-1;\\n        \\n        \\n        while(lo<=hi)\\n        {\\n            int mid = lo + ((hi-lo)>>1);\\n            int next = (mid+1)%n;\\n            int prev = (mid-1+n)%n;\\n            //1.This is for checking if the subarray is already sorted.\\n            if(arr[mid]<=arr[hi] && arr[mid]>=arr[lo])\\n            {\\n                return arr[lo];\\n            }\\n            //rest code is same as told by sir Aditya verma.\\n            if(arr[mid]<=arr[next] && arr[mid]<=arr[prev])\\n            {\\n                return arr[mid];\\n            }\\n            \\n            else if(arr[mid]>=arr[lo])\\n            {\\n                lo=mid+1;\\n            }\\n            else if(arr[mid]<=arr[hi])\\n            {\\n                hi=mid-1;\\n            }\\n        }\\n        return arr[0];\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1788136,
                "title": "c-solution",
                "content": "Binary Search is used to find the target in Time Complexity O(log(N)) and Space Complexity O(1) here.\\n**Note**: When we take a middle element at least one of it\\'s side is sorted.\\nThis approach revolves around finding the sorted side, then taking the least element (*which is the left-most in the sorted side*) and comparing it with the minimum yet(*smallest variable here*).\\n**Points to take care of:**\\n* Left side should be checked first always because if both sides were to be sorted (*meaning the whole array is sorted*) then the answer would be the first element of the left sorted side.\\n* End variable after updation should also be checked if it was the smallest because it is not included in the right sorted list (*e = mid - 1*) and could as well be the minimum element.\\n\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        if (nums.size() == 1) return nums[0];\\n        int s = 0, e = nums.size() - 1;\\n        \\n        int smallest = nums[0];\\n        while (s <= e) {\\n            int mid = s + (e - s)/2;\\n            // left sorted\\n            if (nums[mid] >= nums[s]){\\n                smallest = min(smallest, min(nums[e], nums[s]));\\n                s = mid + 1;\\n            }\\n            // right sorted\\n            else {\\n                smallest = min(smallest, nums[mid]);\\n                e = mid - 1;\\n            }\\n        }\\n        return smallest;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        if (nums.size() == 1) return nums[0];\\n        int s = 0, e = nums.size() - 1;\\n        \\n        int smallest = nums[0];\\n        while (s <= e) {\\n            int mid = s + (e - s)/2;\\n            // left sorted\\n            if (nums[mid] >= nums[s]){\\n                smallest = min(smallest, min(nums[e], nums[s]));\\n                s = mid + 1;\\n            }\\n            // right sorted\\n            else {\\n                smallest = min(smallest, nums[mid]);\\n                e = mid - 1;\\n            }\\n        }\\n        return smallest;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678019,
                "title": "python-solution-o-logn-using-binary-search",
                "content": "```\\nclass Solution:\\n    def findMin(self, a: List[int]) -> int:\\n        left, right = 0,len(a)-1\\n        \\n        while(left<right):\\n            mid = left + (right-left)//2\\n            \\n            if(a[mid]>=a[right]):\\n                left = mid+1\\n                \\n            elif(a[mid]<=a[right]):\\n                right = mid\\n                \\n        return a[right]\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def findMin(self, a: List[int]) -> int:\\n        left, right = 0,len(a)-1\\n        \\n        while(left<right):\\n            mid = left + (right-left)//2\\n            \\n            if(a[mid]>=a[right]):\\n                left = mid+1\\n                \\n            elif(a[mid]<=a[right]):\\n                right = mid\\n                \\n        return a[right]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1672487,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int left = 0, right = nums.size() - 1, mid;\\n        while(left < right) {        \\n            mid = left + (right - left)/2;\\n            \\n            \\n            if(nums[mid] < nums[right]) {\\n                // [left.........mid............right]\\n                // --------------<----sorted part---->                \\n                right = mid;\\n            } else {\\n                // [left.............mid........right]\\n                // <----sorted part---->--------------\\n                left = mid+1;\\n            }\\n        }\\n        return nums[left];\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int left = 0, right = nums.size() - 1, mid;\\n        while(left < right) {        \\n            mid = left + (right - left)/2;\\n            \\n            \\n            if(nums[mid] < nums[right]) {\\n                // [left.........mid............right]\\n                // --------------<----sorted part---->                \\n                right = mid;\\n            } else {\\n                // [left.............mid........right]\\n                // <----sorted part---->--------------\\n                left = mid+1;\\n            }\\n        }\\n        return nums[left];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1660776,
                "title": "c-easy-solution-with-explanation-beats-100",
                "content": "__*Please draw out sample test cases and dry run the program along these steps to get a better intuition*__\\n\\nHere are a few sample cases for your convenience : \\n*  Input : [3,4,5,1,2],  Output : 1\\n*  Input : [4,5,6,7,0,1,2] , Output : 0\\n*  Input : [11,13,15,17], Ouput : 11\\n\\n*If you like this explanation, please upvote\\nComment down below in case you have some suggestion/doubt*\\n\\n__Approach :__\\n\\n1. We will manage 2 pointers (index pointers) - __low__ and __high__\\n2. Initially low will point to 0 index of array, high will point to n-1 index of the array\\n3. while __low<=high__ we will calculate mid\\n4. If __nums[mid] is smaller than nums[high]__ it means that the lowest number cannot be in __[mid,high]__ and it must be in __[low,mid]__ therefore set __high = mid__\\n5. if __nums[mid]__ is greater than __nums[high]__ it means that the lowest number cannot be in __[low,mid]__ and must be in __[mid,high]__ therefore set __low = mid+1__\\n6. Finally, when __low>high__ the loop will break and we can guarantee that __high and mid__ will both be containing the index of the lowest element.\\n7. return __nums[mid]__\\n\\n__Code :__\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int low = 0;\\n        int high = nums.size() - 1;\\n        int mid;\\n        while(low<=high){\\n            mid = (low+high) / 2;\\n            if(nums[mid]<nums[high]){\\n                high = mid;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n        return nums[mid];\\n    }\\n};\\n```\\n\\n__Complexity :__\\n\\n\\nTime : O(logn) [Modified binary search]\\nSpace : O(1) [Only mid, low, high i.e. 3\\\\*integer_size]\\n\\n__Thanks for reading__",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int low = 0;\\n        int high = nums.size() - 1;\\n        int mid;\\n        while(low<=high){\\n            mid = (low+high) / 2;\\n            if(nums[mid]<nums[high]){\\n                high = mid;\\n            }\\n            else{\\n                low = mid+1;\\n            }\\n        }\\n        return nums[mid];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1627332,
                "title": "binary-search",
                "content": "Solution courtesy: Aditya Verma\\n\\n```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        \\n        int l =0, len = nums.length, r = len-1;\\n        int res = nums[l];\\n        int prev, next;\\n        while(l<=r){\\n            //when array is already sorted \\n            if(nums[l] <= nums[r]){\\n                return nums[l];\\n            }\\n            \\n            int mid= l+ (r-l)/2;\\n            prev = (mid+len-1)%len;\\n            next = (mid+1)%len;\\n            \\n            //mid is less then the prev and the next element\\n            if(nums[mid]<= nums[prev] && nums[mid] <= nums[next]){\\n                return nums[mid];\\n            }\\n            else if(nums[mid] >= nums[l]){\\n                l = mid+1;\\n            }\\n            else {\\n                r= mid-1;\\n            }\\n            \\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        \\n        int l =0, len = nums.length, r = len-1;\\n        int res = nums[l];\\n        int prev, next;\\n        while(l<=r){\\n            //when array is already sorted \\n            if(nums[l] <= nums[r]){\\n                return nums[l];\\n            }\\n            \\n            int mid= l+ (r-l)/2;\\n            prev = (mid+len-1)%len;\\n            next = (mid+1)%len;\\n            \\n            //mid is less then the prev and the next element\\n            if(nums[mid]<= nums[prev] && nums[mid] <= nums[next]){\\n                return nums[mid];\\n            }\\n            else if(nums[mid] >= nums[l]){\\n                l = mid+1;\\n            }\\n            else {\\n                r= mid-1;\\n            }\\n            \\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1436769,
                "title": "find-minimum-in-rotated-sorted-array-w-approach-c-java-python",
                "content": "**Idea**\\n\\n* We basically need to find the smallest element\\nWe can do that by binary search as follows:\\n* Binary search, left (Starting) = 0, right (Last element) = n-1\\n* `mid = left + (right - left) / 2 // Or (Left + Right)/2` \\n* If `nums[left] > nums[right]`, then `nums[left]` is the minimum (Basically, after completing the iteration or on not fullfillment of the condition, we will reach here. Else we continue traversing)\\n* Else, traverse\\n\\t* If `nums[mid] > nums[right]` then search on the right side, because smaller elements are in the right side\\n\\t* Else search on the left side.\\n\\n**SOLUTION**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int left = 0 , right = nums.size()-1 ;\\n        if (!right)  // Case of single element\\n            return nums[0] ;\\n        while (left < right)\\n        {\\n            int mid = left + (right - left) / 2;\\n            if (nums[left] < nums[right]) \\n                return nums[left];  // Smaller element\\n            else if (nums[mid] > nums[right]) \\n                left = mid + 1;  // Check on right\\n            else \\n                right = mid; // Check on left\\n        }\\n        return nums[left];\\n    }\\n};\\n```\\n`In JAVA`\\n```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        int left = 0;\\n        int right = nums.length - 1;\\n        \\n        while(left < right){\\n            int mid = left + (right - left) /2;\\n            \\n            if(nums[mid] > nums[right])\\n            {\\n                left = mid + 1;\\n            }\\n            else if(nums[mid] < nums[right])\\n            {\\n                right = mid;\\n            }\\n            else\\n            {\\n                return nums[right];\\n            }\\n        }\\n        return nums[left];\\n    }\\n}\\n```\\n`In Python`\\n```\\nclass Solution(object):\\n    def findMin(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        left, right = 0, len(nums)-1\\n        while left < right:\\n            mid = (left + right) // 2\\n            if nums[mid] > nums[right]:\\n                left = mid + 1\\n            else:\\n                right = mid\\n        return nums[left]\\n```\\n**TIME COMPLEXITY - O(logN)**\\nIf you want to try a harder problem of a similar type, try out [33. Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/).",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int left = 0 , right = nums.size()-1 ;\\n        if (!right)  // Case of single element\\n            return nums[0] ;\\n        while (left < right)\\n        {\\n            int mid = left + (right - left) / 2;\\n            if (nums[left] < nums[right]) \\n                return nums[left];  // Smaller element\\n            else if (nums[mid] > nums[right]) \\n                left = mid + 1;  // Check on right\\n            else \\n                right = mid; // Check on left\\n        }\\n        return nums[left];\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        int left = 0;\\n        int right = nums.length - 1;\\n        \\n        while(left < right){\\n            int mid = left + (right - left) /2;\\n            \\n            if(nums[mid] > nums[right])\\n            {\\n                left = mid + 1;\\n            }\\n            else if(nums[mid] < nums[right])\\n            {\\n                right = mid;\\n            }\\n            else\\n            {\\n                return nums[right];\\n            }\\n        }\\n        return nums[left];\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def findMin(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        left, right = 0, len(nums)-1\\n        while left < right:\\n            mid = (left + right) // 2\\n            if nums[mid] > nums[right]:\\n                left = mid + 1\\n            else:\\n                right = mid\\n        return nums[left]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1436589,
                "title": "easy-c-binary-search-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n = nums.size();\\n        int left = 0, right = n-1;\\n        if(nums[right] > nums[left]) return nums[left];\\n        while(left < right){\\n            int mid = left + (right-left)/2;\\n            if(nums[mid] < nums[right]) right=mid;\\n            else left = mid+1;\\n        }\\n        return nums[left];\\n    }\\n};\\n```\\n**Time complexity:** O(logN) where N is the size of array.\\n**Space complexity:** O(1)\\n**Questions/ Discussions are welcome.**",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n = nums.size();\\n        int left = 0, right = n-1;\\n        if(nums[right] > nums[left]) return nums[left];\\n        while(left < right){\\n            int mid = left + (right-left)/2;\\n            if(nums[mid] < nums[right]) right=mid;\\n            else left = mid+1;\\n        }\\n        return nums[left];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1320815,
                "title": "python-o-logn-solution-using-binary-search",
                "content": "```\\n\\'\\'\\'\\n    Time Complexity: O(log n)\\n    Space Complexity: O(1)\\n\\'\\'\\'\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        low, high = 0, len(nums) - 1\\n\\n        while low < high:\\n            mid = low + (high - low) // 2\\n            if nums[mid] > nums[high]:\\n                low = mid + 1\\n            elif nums[mid] < nums[high]:\\n                high = mid\\n        return nums[low]\\n```\\n**PS: Please upvote if you liked the solution.**",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\n\\'\\'\\'\\n    Time Complexity: O(log n)\\n    Space Complexity: O(1)\\n\\'\\'\\'\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        low, high = 0, len(nums) - 1\\n\\n        while low < high:\\n            mid = low + (high - low) // 2\\n            if nums[mid] > nums[high]:\\n                low = mid + 1\\n            elif nums[mid] < nums[high]:\\n                high = mid\\n        return nums[low]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1304178,
                "title": "easiest-solution-with-binary-search",
                "content": "\\n public int findMin(int[] nums) {\\n \\n\\t\\t //taking start and end as first and last index \\n\\t\\tint start =0,next,prev;\\n       int end = nums.length -1;\\n\\t   \\n       //finding the length of nums array\\n\\t   int n =nums.length;\\n\\t\\t\\n        //This is where result stored\\n\\t\\tint res =-1;\\n       \\n\\t   while(start<=end)\\n       {\\n         //If the array is sorted then we just need to return the first index element that is minimum element\\n\\t\\t if(nums[start]<=nums[end])\\n           {\\n               res = nums[start];\\n               break;\\n           }\\n\\t\\t\\t\\n\\t\\t\\n           int mid  = (start +end)/2;\\n            \\n\\t\\t\\t//next and prev is for storing next index and previous index if suppose we are at i so it will be (i+1) and (i-1) \\n\\t\\t\\t\\n           next  = (mid+1)%n;\\n           prev = (mid-1+n)%n;\\n           \\n\\t\\t   //If our mid element is less than both prev and next element then the mid element is minimum element\\n\\t\\t   \\n           if((nums[mid]<=nums[prev])&&(nums[mid]<=nums[next]))\\n           {\\n               res = nums[mid];\\n               break;\\n           }\\n         \\n\\t\\t //If the first half array is already sorted then we will get minimum element in next half array\\n           if(nums[start]<=nums[mid])\\n               start =mid+1;\\n            \\n           else if(nums[mid]<=nums[end])\\n               end =mid-1;\\n               \\n       }\\n        return res;\\n    }\\n\\t//**Please upvote me **",
                "solutionTags": [],
                "code": "\\n public int findMin(int[] nums) {\\n \\n\\t\\t //taking start and end as first and last index \\n\\t\\tint start =0,next,prev;\\n       int end = nums.length -1;\\n\\t   \\n       //finding the length of nums array\\n\\t   int n =nums.length;\\n\\t\\t\\n        //This is where result stored\\n\\t\\tint res =-1;\\n       \\n\\t   while(start<=end)\\n       {\\n         //If the array is sorted then we just need to return the first index element that is minimum element\\n\\t\\t if(nums[start]<=nums[end])\\n           {\\n               res = nums[start];\\n               break;\\n           }\\n\\t\\t\\t\\n\\t\\t\\n           int mid  = (start +end)/2;\\n            \\n\\t\\t\\t//next and prev is for storing next index and previous index if suppose we are at i so it will be (i+1) and (i-1) \\n\\t\\t\\t\\n           next  = (mid+1)%n;\\n           prev = (mid-1+n)%n;\\n           \\n\\t\\t   //If our mid element is less than both prev and next element then the mid element is minimum element\\n\\t\\t   \\n           if((nums[mid]<=nums[prev])&&(nums[mid]<=nums[next]))\\n           {\\n               res = nums[mid];\\n               break;\\n           }\\n         \\n\\t\\t //If the first half array is already sorted then we will get minimum element in next half array\\n           if(nums[start]<=nums[mid])\\n               start =mid+1;\\n            \\n           else if(nums[mid]<=nums[end])\\n               end =mid-1;\\n               \\n       }\\n        return res;\\n    }\\n\\t//**Please upvote me **",
                "codeTag": "Unknown"
            },
            {
                "id": 1290361,
                "title": "easy-range-wise-binary-search",
                "content": "```\\npublic:\\n    int findMin(vector<int>& nums) {\\n        \\n        int low=0,high=nums.size()-1, ans=nums[nums.size()-1];\\n        while(low<high){\\n            int mid=low+(high-low)/2;\\n            if(nums[mid]>nums[high]){\\n                low=mid+1;\\n            }else{\\n                ans=nums[mid];\\n                high=mid;\\n            }\\n        }\\n        if(high==low){\\n            ans=nums[low];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\npublic:\\n    int findMin(vector<int>& nums) {\\n        \\n        int low=0,high=nums.size()-1, ans=nums[nums.size()-1];\\n        while(low<high){\\n            int mid=low+(high-low)/2;\\n            if(nums[mid]>nums[high]){\\n                low=mid+1;\\n            }else{\\n                ans=nums[mid];\\n                high=mid;\\n            }\\n        }\\n        if(high==low){\\n            ans=nums[low];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1012636,
                "title": "javascript",
                "content": "```\\n// Brute force O(N)\\n// const findMin = function(nums) {\\n//     let currentMin = nums[0];\\n//     for(let i = 1; i < nums.length; i++) {\\n//       currentMin = Math.min(currentMin, nums[i]);\\n//     }\\n//   return currentMin;\\n// };\\n\\n\\n// Optimized: O(logN) MODIFIED Binary Search\\nconst findMin = (nums) => {\\n  \\n    let low = 0;\\n    let high = nums.length - 1;\\n  \\n    while (low < high) {\\n        let mid = Math.floor(low + (high - low) / 2);\\n        // Found the pivot point where the rotation began\\n        if (nums[mid] > nums[high]) {\\n            low = mid + 1;\\n        } else {\\n            high = mid;\\n        }\\n    }\\n    return nums[low];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// Brute force O(N)\\n// const findMin = function(nums) {\\n//     let currentMin = nums[0];\\n//     for(let i = 1; i < nums.length; i++) {\\n//       currentMin = Math.min(currentMin, nums[i]);\\n//     }\\n//   return currentMin;\\n// };\\n\\n\\n// Optimized: O(logN) MODIFIED Binary Search\\nconst findMin = (nums) => {\\n  \\n    let low = 0;\\n    let high = nums.length - 1;\\n  \\n    while (low < high) {\\n        let mid = Math.floor(low + (high - low) / 2);\\n        // Found the pivot point where the rotation began\\n        if (nums[mid] > nums[high]) {\\n            low = mid + 1;\\n        } else {\\n            high = mid;\\n        }\\n    }\\n    return nums[low];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 770305,
                "title": "standard-java-solution",
                "content": "### Theory\\nNotice how we have two sorted subarrays within the complete array of `nums`. We have a left and right pointer. Our goal is to make the left pointer point to the start of the smaller subarray, and the right pointer end either at the end of the array, or the inflection point. If you ever see a `Rotated` array problem, just know that the optimal solution is a binary seach, you just have to figure out your conditions where you either go left or right, or return. And that is the hardest part.\\n\\nCredit: https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/discuss/48487/Java-solution-with-binary-search/48575\\n\\n### Solution\\n```\\n    public int findMin(int[] nums) {\\n        int left = 0, right = nums.length - 1;\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] > nums[right]) left = mid + 1;\\n            else right = mid;\\n        }\\n     \\n        return nums[left];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int findMin(int[] nums) {\\n        int left = 0, right = nums.length - 1;\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] > nums[right]) left = mid + 1;\\n            else right = mid;\\n        }\\n     \\n        return nums[left];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 768963,
                "title": "c-o-log-n-solution",
                "content": "```\\nint findMin(int* nums, int numsSize){\\n    int r = numsSize-1, l=0, mid = r/2;\\n    if (numsSize == 1) // only one element\\n        return nums[0];\\n    \\n    while (l <= r)\\n    {\\n        mid = l+(r-l)/2;\\n        if (mid == 0) // if mid is the first - must be that there are only two elements\\n            return nums[0] < nums[1] ? nums[0]:nums[1];\\n        \\n        if (nums[l] < nums[r]) // got a part that is not rotated\\n            return nums[l];\\n            \\n        else if (nums[mid] < nums[mid-1]) // the element in the left is larger - we got to the minimum\\n            return nums[mid];\\n\\n        else if (nums[mid] > nums[r]) // mid is larger than right - min is in right side\\n            l = mid+1;\\n        \\n        else if (nums[mid] < nums[l]) // mid is smaller than left - min is in left side\\n            r = mid-1;\\n    }\\n    return nums[0];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint findMin(int* nums, int numsSize){\\n    int r = numsSize-1, l=0, mid = r/2;\\n    if (numsSize == 1) // only one element\\n        return nums[0];\\n    \\n    while (l <= r)\\n    {\\n        mid = l+(r-l)/2;\\n        if (mid == 0) // if mid is the first - must be that there are only two elements\\n            return nums[0] < nums[1] ? nums[0]:nums[1];\\n        \\n        if (nums[l] < nums[r]) // got a part that is not rotated\\n            return nums[l];\\n            \\n        else if (nums[mid] < nums[mid-1]) // the element in the left is larger - we got to the minimum\\n            return nums[mid];\\n\\n        else if (nums[mid] > nums[r]) // mid is larger than right - min is in right side\\n            l = mid+1;\\n        \\n        else if (nums[mid] < nums[l]) // mid is smaller than left - min is in left side\\n            r = mid-1;\\n    }\\n    return nums[0];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 643667,
                "title": "python-bin-search",
                "content": "``` python\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        if not nums: \\n            return 0\\n        \\n        lo = 0\\n        hi = len(nums)-1\\n        while nums[lo] > nums[hi]:\\n            mid = (lo+hi)//2\\n            if nums[mid] < nums[hi]:\\n                # notice it\\'s not mid-1\\n                hi = mid\\n            else:\\n                lo = mid+1\\n        return nums[lo]                \\n            \\n",
                "solutionTags": [],
                "code": "``` python\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        if not nums: \\n            return 0\\n        \\n        lo = 0\\n        hi = len(nums)-1\\n        while nums[lo] > nums[hi]:\\n            mid = (lo+hi)//2\\n            if nums[mid] < nums[hi]:\\n                # notice it\\'s not mid-1\\n                hi = mid\\n            else:\\n                lo = mid+1\\n        return nums[lo]                \\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 364268,
                "title": "c-binary-search",
                "content": "```\\npublic class Solution {\\n    public int FindMin(int[] nums) {\\n        var n = nums.Length;\\n\\n        var left = 0;\\n        var right = n - 1;\\n\\n        var globalMin = int.MaxValue;\\n\\n        while (left <= right) {\\n            var mid = left + (right - left) / 2;\\n            if (nums[mid] < nums[right]) {\\n                globalMin = Math.Min(globalMin, nums[mid]);\\n                right = mid - 1;\\n            } else {\\n                globalMin = Math.Min(globalMin, nums[left]);\\n                left = mid + 1;\\n            }\\n        }\\n\\n        return globalMin;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int FindMin(int[] nums) {\\n        var n = nums.Length;\\n\\n        var left = 0;\\n        var right = n - 1;\\n\\n        var globalMin = int.MaxValue;\\n\\n        while (left <= right) {\\n            var mid = left + (right - left) / 2;\\n            if (nums[mid] < nums[right]) {\\n                globalMin = Math.Min(globalMin, nums[mid]);\\n                right = mid - 1;\\n            } else {\\n                globalMin = Math.Min(globalMin, nums[left]);\\n                left = mid + 1;\\n            }\\n        }\\n\\n        return globalMin;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 329614,
                "title": "c-o-log-n-binary-search-koderz-kamp-lewptie-lewpz",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        \\n        if (nums.size() <= 0) { return 0; }\\n        \\n        int aLo = 0;\\n        int aHi = nums.size() - 1;\\n        int aMid = 0;\\n        \\n        while (aLo < aHi) {\\n            aMid = (aLo + aHi) / 2;\\n            if (nums[aMid] > nums[aHi]) {\\n                //Top is definitely rotated.\\n                aLo = aMid + 1;\\n            } else {\\n                //Bottom might be rotated.\\n                aHi = aMid;\\n            }    \\n        }\\n        \\n        return nums[aLo];\\n    }\\n};\\n```\\n\\nThe important thing to notice about the architecture of this loop is that mid could equal lo, but mid will always be less than hi.\\n\\nConsider the following incorrect code:\\n\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        \\n        if (nums.size() <= 0) { return 0; }\\n        \\n        int aLo = 0;\\n        int aHi = nums.size() - 1;\\n        int aMid = 0;\\n        \\n        while (aLo <= aHi) {\\n            aMid = (aLo + aHi) / 2;\\n            if (nums[aMid] > nums[aHi]) {\\n                aLo = aMid + 1;\\n            } else {\\n                aHi = aMid - 1;\\n            }    \\n        }\\n        \\n        return nums[aLo];\\n    }\\n};\\n```\\n\\nIf this was ran against the following input:\\n[3,4,0,1,2]\\n\\nOn the first iteration, we would have this.\\nLo:0  Mid:2  Hi:4 \\n\\nSince nums[aMid] > nums[aHi] is not true, we know the top half of the array is not rotated.\\n\\nWhat that means is either:\\n1.) The bottom half of the array is rotated.\\n2.) The top half of the array BEGINS the rotation.\\n\\nSince case 2 is correct in this instance, we would need to check mid again.\\n\\nBut we would end up with this on our 2nd iteration:\\nLo 0 Hi 1 Mid 0\\n\\nTry the version of this problem with duplicated - then you will know how well you really grasp the concept.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        \\n        if (nums.size() <= 0) { return 0; }\\n        \\n        int aLo = 0;\\n        int aHi = nums.size() - 1;\\n        int aMid = 0;\\n        \\n        while (aLo < aHi) {\\n            aMid = (aLo + aHi) / 2;\\n            if (nums[aMid] > nums[aHi]) {\\n                //Top is definitely rotated.\\n                aLo = aMid + 1;\\n            } else {\\n                //Bottom might be rotated.\\n                aHi = aMid;\\n            }    \\n        }\\n        \\n        return nums[aLo];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        \\n        if (nums.size() <= 0) { return 0; }\\n        \\n        int aLo = 0;\\n        int aHi = nums.size() - 1;\\n        int aMid = 0;\\n        \\n        while (aLo <= aHi) {\\n            aMid = (aLo + aHi) / 2;\\n            if (nums[aMid] > nums[aHi]) {\\n                aLo = aMid + 1;\\n            } else {\\n                aHi = aMid - 1;\\n            }    \\n        }\\n        \\n        return nums[aLo];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 328703,
                "title": "c-log-n-binary-search-solution-applied-to-all-languages",
                "content": "```\\n[0,1,2,3,4,5,6]\\n ^           ^\\n l           r\\n```\\n\\ncompare the first(`l`) and the last(`r`). if the `l` is smaller than `r`, there is no rotation. Then the minimum number is `nums[l]`.\\n\\n```\\n[3,4,5,6,0,1,2]\\n ^           ^\\n l           r\\n```\\n\\nIf `l` is larget than `r`, the array must be rotated. Apply binary search here to find the rotation point faster. \\n\\n```\\n[3,4,5,6,0,1,2]\\n ^     ^     ^\\n l     m     r\\n```\\nCompare `l` and `r` against `m`, and then:\\n- move `l` to `m+1` if `r` is smaller than `m`\\n- more `r` to `m` if `l` is larger than `m`\\n```\\n[3,4,5,6,0,1,2]\\n         ^ ^ ^\\n         l m r\\n```\\nrepeat until `nums[l]` is smaller than `nums[r]`, then eventually `l` will be the index of the smallest number. \\n\\n\\nCode:\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int l = 0, r = nums.size()-1;\\n        while(nums[l] > nums[r]) {\\n            int m = (l + r) / 2;\\n            if (nums[l] > nums[m]) {\\n                r = m;\\n            } else {\\n                l = m + 1;\\n            }\\n        }\\n        return nums[l];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n[0,1,2,3,4,5,6]\\n ^           ^\\n l           r\\n```\n```\\n[3,4,5,6,0,1,2]\\n ^           ^\\n l           r\\n```\n```\\n[3,4,5,6,0,1,2]\\n ^     ^     ^\\n l     m     r\\n```\n```\\n[3,4,5,6,0,1,2]\\n         ^ ^ ^\\n         l m r\\n```\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int l = 0, r = nums.size()-1;\\n        while(nums[l] > nums[r]) {\\n            int m = (l + r) / 2;\\n            if (nums[l] > nums[m]) {\\n                r = m;\\n            } else {\\n                l = m + 1;\\n            }\\n        }\\n        return nums[l];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 48612,
                "title": "c-4ms-binary-search-with-some-comments",
                "content": "    // Lets represent rotated array 4567890123 as:\\n    //             9\\n    //           8    <--- top middle\\n    //         7         \\n    //       6\\n    //     5\\n    //   4\\n    //  -0-1-2-3-4-5-6-7-8-9- [index] in array  \\n    //                     3\\n    //                   2\\n    //                 1    <--- bottom middle\\n    //               0\\n    // When you do binary search your middle index is either on the \"top\" or \"bottom\" index\\n    // when l == 0 and r == 9 then mid == 4, mid_number == nums[mid] == 8 \\n    // I call it \"top middle\", since it always > than both nums[l] and nums[r] (4 < 8 > 3)\\n    // so the min value is on the right side of it\\n    // when l == 4 and r == 9 then mid == 7, mid_number == nums[mid] == 1 \\n    // I call it \"bottom middle\" since it always < than both nums[l] and nums[r] (8 > 1 < 3)\\n    // so the min value is somewhere on the left side of it\\n    int findMin(vector<int>& nums) \\n    {\\n       int l = 0, r = nums.size() - 1;\\n       while(r - l > 1)\\n       {\\n           int mid = (l + r) / 2;\\n           if(nums[l] < nums[mid] && nums[mid] > nums[r])\\n           {\\n               l = mid; // top middle, min value is somewhere on the right\\n           }\\n           else\\n           {\\n               r = mid; // bottom middle, min value is somewhere on the left\\n           }\\n       }\\n       \\n       return min(nums[l], nums[r]);\\n    }",
                "solutionTags": [],
                "code": "    // Lets represent rotated array 4567890123 as:\\n    //             9\\n    //           8    <--- top middle\\n    //         7         \\n    //       6\\n    //     5\\n    //   4\\n    //  -0-1-2-3-4-5-6-7-8-9- [index] in array  \\n    //                     3\\n    //                   2\\n    //                 1    <--- bottom middle\\n    //               0\\n    // When you do binary search your middle index is either on the \"top\" or \"bottom\" index\\n    // when l == 0 and r == 9 then mid == 4, mid_number == nums[mid] == 8 \\n    // I call it \"top middle\", since it always > than both nums[l] and nums[r] (4 < 8 > 3)\\n    // so the min value is on the right side of it\\n    // when l == 4 and r == 9 then mid == 7, mid_number == nums[mid] == 1 \\n    // I call it \"bottom middle\" since it always < than both nums[l] and nums[r] (8 > 1 < 3)\\n    // so the min value is somewhere on the left side of it\\n    int findMin(vector<int>& nums) \\n    {\\n       int l = 0, r = nums.size() - 1;\\n       while(r - l > 1)\\n       {\\n           int mid = (l + r) / 2;\\n           if(nums[l] < nums[mid] && nums[mid] > nums[r])\\n           {\\n               l = mid; // top middle, min value is somewhere on the right\\n           }\\n           else\\n           {\\n               r = mid; // bottom middle, min value is somewhere on the left\\n           }\\n       }\\n       \\n       return min(nums[l], nums[r]);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 48734,
                "title": "python-binary-search-solution-o-logn-36ms",
                "content": "    class Solution:\\n        # @param {integer[]} nums\\n        # @return {integer}\\n        def findMin(self, nums):\\n            if not nums:\\n                return -1\\n    \\n            low, high = 0, len(nums) - 1\\n            mid = (low + high) / 2\\n    \\n            while low < high:\\n                if nums[mid] > nums[mid + 1]:\\n                    return nums[mid + 1]\\n                elif nums[mid] > nums[high]:\\n                    low = mid + 1\\n                else:\\n                    high = mid\\n                mid = (low + high) / 2\\n    \\n            return nums[mid]",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "class Solution:\\n        # @param {integer[]}",
                "codeTag": "Java"
            },
            {
                "id": 48778,
                "title": "java-version-bisearch-solution",
                "content": "       \\n    //This is my Bisearch solution in java.\\n    \\n     public class Solution {\\n            public int findMin(int[] num) {\\n                int left = 0, right = num.length - 1;\\n                while(left < right){\\n                    int mid = (left + right) / 2;\\n                    if(num[left] > num[right]){\\n                        if(num[left] <= num[mid]){\\n                            left = mid + 1;\\n                        }else{\\n                            right = mid;\\n                        }\\n                    }else{\\n                        return num[left];\\n                    }\\n                }\\n                return num[left];\\n            }\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n            public int findMin(int[] num) {\\n                int left = 0, right = num.length - 1;\\n                while(left < right){\\n                    int mid = (left + right) / 2;\\n                    if(num[left] > num[right]){\\n                        if(num[left] <= num[mid]){\\n                            left = mid + 1;\\n                        }",
                "codeTag": "Java"
            },
            {
                "id": 48788,
                "title": "my-java-solution-logn",
                "content": "    public int findMin(int[] num) {\\n        int i = 0;\\n        int j = num.length - 1;\\n        \\n        int res = 0;\\n        \\n        while (j >= i) {\\n            \\n            if (num[i] <= num[j]) {\\n                res = num[i];\\n                break;\\n            }\\n            \\n            int m = i + (j - i) / 2;\\n            \\n            if (num[i] <= num[m]) {\\n                i = m + 1;\\n            }\\n            else {\\n                j = m;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n\\nJust use binary search. When found the subarray is from low to high, simply return the first value.\\n\\nIf the length of the array is 0, the return value is 0 or we can set any value we want to res.",
                "solutionTags": [],
                "code": "    public int findMin(int[] num) {\\n        int i = 0;\\n        int j = num.length - 1;\\n        \\n        int res = 0;\\n        \\n        while (j >= i) {\\n            \\n            if (num[i] <= num[j]) {\\n                res = num[i];\\n                break;\\n            }\\n            \\n            int m = i + (j - i) / 2;\\n            \\n            if (num[i] <= num[m]) {\\n                i = m + 1;\\n            }\\n            else {\\n                j = m;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n\\nJust use binary search. When found the subarray is from low to high, simply return the first value.\\n\\nIf the length of the array is 0, the return value is 0 or we can set any value we want to res.",
                "codeTag": "Unknown"
            },
            {
                "id": 4062870,
                "title": "easy-code-fuck-that-algorithms-do-as-u-like",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def findMin(self, nums):\\n        nums.sort()\\n        return(nums[0])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def findMin(self, nums):\\n        nums.sort()\\n        return(nums[0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991933,
                "title": "c-4-approach-brute-better-optimize-binary-search",
                "content": "Brute Force -Method 1a\\nTime Complexity -O(nlogn)\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        return nums[0];\\n    }\\n};\\n```\\nUsing Priority_queue -Method 1b\\nTime Complexity -O(nlogn)\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int> &nums){\\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        for(auto x:nums){\\n            pq.push(x);\\n        }\\n        return pq.top();\\n    }\\n};\\n```\\nSimple -Method 2\\nTime Complexity -O(n)\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int ans=INT_MAX;\\n        for(int i=0;i<nums.size();i++){\\n            ans=min(ans,nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nBinary Search -Method 3\\nTime Complexity -O(logn)\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int l = 0;\\n        int r = nums.size() - 1;\\n        int ans = nums[0]; // Initialize ans with the first element\\n\\n        while (l <= r) {\\n            int mid = (l + r) / 2;\\n\\n            if (nums[mid] >= nums[l]) {\\n                // The mini must be on the right side\\n                ans = min(ans, nums[l]); // Update ans\\n                l = mid + 1;\\n            } else {\\n                // The mini must be on the left side\\n                ans = min(ans, nums[mid]); // Update ans \\n                r = mid - 1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/744f0b10-e99d-4ef3-9d83-2998f5d1db70_1693652111.0961695.webp)\\n",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        return nums[0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int> &nums){\\n        priority_queue<int,vector<int>,greater<int>> pq;\\n        for(auto x:nums){\\n            pq.push(x);\\n        }\\n        return pq.top();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int ans=INT_MAX;\\n        for(int i=0;i<nums.size();i++){\\n            ans=min(ans,nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int l = 0;\\n        int r = nums.size() - 1;\\n        int ans = nums[0]; // Initialize ans with the first element\\n\\n        while (l <= r) {\\n            int mid = (l + r) / 2;\\n\\n            if (nums[mid] >= nums[l]) {\\n                // The mini must be on the right side\\n                ans = min(ans, nums[l]); // Update ans\\n                l = mid + 1;\\n            } else {\\n                // The mini must be on the left side\\n                ans = min(ans, nums[mid]); // Update ans \\n                r = mid - 1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3925393,
                "title": "best-binary-search-solution",
                "content": "# **PLS UPVOTE MY SOLUTION IF YOU LIKE IT AND COMMENT FOR ANY DOUBTS**\\n# Approach\\nMain Function findMin:\\n\\nInitialize mini to a large value (INT_MAX). This will be used to track the minimum element.\\nInitialize low to 0 and high to the last index of the nums array.\\nLoop:\\n\\nUse a while loop to perform binary search on the rotated sorted array.\\nSorted Sub-array Check:\\n\\nAt the start of each iteration, check if the sub-array from low to high is sorted. If it is, then the minimum element in this sub-array is the current element at index low. Set mini to the minimum of mini and nums[low] and break out of the loop.\\nFinding Midpoint:\\n\\nCalculate the midpoint mid using the formula low + (high - low) / 2.\\nComparisons and Updates:\\n\\nCompare the element at index low with the element at index mid. If nums[low] <= nums[mid], it means the lower half of the sub-array is sorted. In this case, update mini with the minimum of mini and nums[low], and adjust the search range by updating low to mid + 1.\\n\\nIf the above condition is not met (i.e., nums[mid] <= nums[high]), it indicates that the upper half of the sub-array is sorted. In this case, update mini with the minimum of mini and nums[mid], and adjust the search range by updating high to mid - 1.\\n\\nReturning the Result:\\n\\nOnce the loop finishes, the mini value will hold the minimum element in the rotated sorted array. Return mini as the result.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int mini = INT_MAX;\\n        int low = 0;\\n        int high = nums.size() - 1;\\n        while (low <= high) {\\n            if (nums[low] <= nums[high]) {\\n                mini = min(mini, nums[low]);\\n                break;\\n            }\\n            int mid = low + (high - low) / 2;\\n            if (nums[low] <= nums[mid]) {\\n                mini = min(mini, nums[low]);\\n                low = mid + 1;\\n            } else if (nums[mid] <= nums[high]) {\\n                mini = min(mini, nums[mid]);\\n                high = mid - 1;\\n            }\\n        }\\n        return mini;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int mini = INT_MAX;\\n        int low = 0;\\n        int high = nums.size() - 1;\\n        while (low <= high) {\\n            if (nums[low] <= nums[high]) {\\n                mini = min(mini, nums[low]);\\n                break;\\n            }\\n            int mid = low + (high - low) / 2;\\n            if (nums[low] <= nums[mid]) {\\n                mini = min(mini, nums[low]);\\n                low = mid + 1;\\n            } else if (nums[mid] <= nums[high]) {\\n                mini = min(mini, nums[mid]);\\n                high = mid - 1;\\n            }\\n        }\\n        return mini;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3791821,
                "title": "find-pivot-minimum-element-in-sorted-rotated-array-optimised-o-log-n-beats-100-t-c-wise",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        \\n        int start = 0, end = nums.length-1;\\n        int mid;\\n\\n        if(nums[start] <= nums[end]) {\\n            return nums[start];\\n        }\\n\\n        while(start < end) {\\n            mid = start + (end-start)/2;\\n            if(nums[mid] >= nums[0]) {\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid;\\n            }\\n        }\\n\\n        return nums[start];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        \\n        int start = 0, end = nums.length-1;\\n        int mid;\\n\\n        if(nums[start] <= nums[end]) {\\n            return nums[start];\\n        }\\n\\n        while(start < end) {\\n            mid = start + (end-start)/2;\\n            if(nums[mid] >= nums[0]) {\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid;\\n            }\\n        }\\n\\n        return nums[start];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752655,
                "title": "easiest-c-solution-simple-binary-search-approach-beats-90",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int start = 0, end = nums.size()-1, ans = nums[0]; // Store ans = nums[0] for the case when rotated array is same as sorted array\\n        while(start<=end){\\n            int mid = start+(end-start)/2;\\n            if(nums[mid]>=nums[0])\\n                start = mid+1;\\n            else\\n                ans = nums[mid], end = mid-1; // Update ans if there is an element smaller than nums[0], i.e. there is rotation\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int start = 0, end = nums.size()-1, ans = nums[0]; // Store ans = nums[0] for the case when rotated array is same as sorted array\\n        while(start<=end){\\n            int mid = start+(end-start)/2;\\n            if(nums[mid]>=nums[0])\\n                start = mid+1;\\n            else\\n                ans = nums[mid], end = mid-1; // Update ans if there is an element smaller than nums[0], i.e. there is rotation\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3515923,
                "title": "js-simple-solution",
                "content": "\\n# Code\\n```\\nvar findMin = function(nums) {\\n    \\n    let st=0, en = nums.length - 1;\\n    while(st<=en){\\n        if(nums[st] <= nums[en]) break;\\n        let mid = Math.floor(st + (en-st)/2);\\n        if(nums[st]<=nums[mid]){\\n            st = mid+1;\\n        }\\n        else{\\n            en = mid;\\n        }\\n    }\\n    return nums[st];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findMin = function(nums) {\\n    \\n    let st=0, en = nums.length - 1;\\n    while(st<=en){\\n        if(nums[st] <= nums[en]) break;\\n        let mid = Math.floor(st + (en-st)/2);\\n        if(nums[st]<=nums[mid]){\\n            st = mid+1;\\n        }\\n        else{\\n            en = mid;\\n        }\\n    }\\n    return nums[st];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3506948,
                "title": "java-solution-for-find-minimum-in-rotated-sorted-array-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given code aims to find the minimum element in a rotated sorted array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Check if the length of the array \"nums\" is 1. If true, return the single element as the minimum.\\n- Initialize two pointers: \"left\" pointing to the start of the array and \"right\" pointing to the end of the array.\\n- Check if the array is not rotated, i.e., the element at the leftmost index is less than the element at the rightmost index. If true, return the element at the leftmost index as the minimum.\\n- Enter a while loop while the \"left\" pointer is less than or equal to the \"right\" pointer.\\n- Inside the loop, check if the subarray between \"left\" and \"right\" has only two elements. If true, return the element at the \"right\" index as the minimum.\\n- Calculate the middle index \"m\" using binary search formula (left + (right - left) / 2).\\n- Compare the element at index \"m\" with the element at the \"right\" index.\\n1. If nums[m] > nums[right], it means the minimum element lies to the right of \"m\". Update the \"left\" pointer to \"m\".\\n2. Otherwise, the minimum element lies to the left of \"m\" or is equal to \"m\". Update the \"right\" pointer to \"m\".\\n- Repeat steps 6-7 until the minimum element is found.\\n- Finally, return the element at the \"left\" index as the minimum.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this solution is O(log n) because it uses binary search to find the minimum element. The array is divided in half at each step, reducing the search space.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(1) because the algorithm uses a constant amount of additional space to store the pointers and variables, regardless of the size of the input array.\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        if(nums.length==1)\\n            return nums[0];\\n        int left=0;\\n        int right=nums.length-1;\\n        //not rotated\\n        if(nums[left]<nums[right])\\n            return nums[left];\\n        while(left <= right)\\n        {\\n            if(right-left==1)\\n            {\\n                return nums[right];\\n            }\\n            int m = left + (right-left)/2;\\n            if(nums[m] > nums[right])\\n                left = m;\\n            else\\n                right = m;\\n        }\\n        return nums[left];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        if(nums.length==1)\\n            return nums[0];\\n        int left=0;\\n        int right=nums.length-1;\\n        //not rotated\\n        if(nums[left]<nums[right])\\n            return nums[left];\\n        while(left <= right)\\n        {\\n            if(right-left==1)\\n            {\\n                return nums[right];\\n            }\\n            int m = left + (right-left)/2;\\n            if(nums[m] > nums[right])\\n                left = m;\\n            else\\n                right = m;\\n        }\\n        return nums[left];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456863,
                "title": "python3-with-explanation-quibler7",
                "content": "# Code\\n```\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        l, r = 0, len(nums)-1\\n        while l < r:\\n            m = l + (r-l) // 2\\n            # if mid is greater than r then right part is rotated so search for\\n            # min in right part\\n            if nums[m] > nums[r]:l = m +1\\n            # mid is small than rightmost ele so min should be in left part\\n            #search in left part for min element \\n            else: r = m \\n        #return leftmost min number \\n        return nums[l]    \\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        l, r = 0, len(nums)-1\\n        while l < r:\\n            m = l + (r-l) // 2\\n            # if mid is greater than r then right part is rotated so search for\\n            # min in right part\\n            if nums[m] > nums[r]:l = m +1\\n            # mid is small than rightmost ele so min should be in left part\\n            #search in left part for min element \\n            else: r = m \\n        #return leftmost min number \\n        return nums[l]    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3356428,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Binary Search\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(logN)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int> &nums) {\\n        int l = 0, r = nums.size() - 1;\\n        while(l < r) {\\n            int mid = (l + r) / 2 ;\\n            if(nums[mid] > nums[r]) l = mid + 1;\\n            else r = mid;\\n        }\\n        return nums[l];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int> &nums) {\\n        int l = 0, r = nums.size() - 1;\\n        while(l < r) {\\n            int mid = (l + r) / 2 ;\\n            if(nums[mid] > nums[r]) l = mid + 1;\\n            else r = mid;\\n        }\\n        return nums[l];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3318129,
                "title": "10-lines-solution-go",
                "content": "1. Binary Search\\n2. If nums[mid] > nums[high], the minimum must be in the right half\\n3. If nums[mid] < nums[high], the minimum must be in the left half\\n4. If nums[mid] == nums[high], the minimum must be in the left half\\n5. The loop will end when low == high\\n6. Return nums[low]\\n\\n# Code\\n```\\nfunc findMin(nums []int) int {\\n    n := len(nums)\\n    low, high := 0, n - 1\\n    for low < high {\\n        mid := (low + high) / 2\\n        if nums[mid] > nums[high] {\\n            low = mid + 1\\n        } else {\\n            high = mid\\n        }\\n    }\\n    return nums[low]\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Binary Search"
                ],
                "code": "```\\nfunc findMin(nums []int) int {\\n    n := len(nums)\\n    low, high := 0, n - 1\\n    for low < high {\\n        mid := (low + high) / 2\\n        if nums[mid] > nums[high] {\\n            low = mid + 1\\n        } else {\\n            high = mid\\n        }\\n    }\\n    return nums[low]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3256646,
                "title": "c-2-solutions-one-liner-binary-search",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUse *`*min_element`* function of Algorithm library, which returns the minimum element in a container.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        return *min_element(nums.begin(), nums.end()) ; \\n    }\\n};\\n```\\n---\\n# Complexity\\n- Time complexity:$$O(logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code \\n```C++ []\\nclass Solution {\\npublic:\\n     int findMin(vector<int> &num) {\\n        int start = 0 ;\\n        int end = num.size() - 1 ;\\n        \\n        while(start < end) \\n        {\\n            // if start is less than end means array not rotated so first element is the minimum \\n            if (num[start] < num[end])\\n            {\\n                return num[start] ;\\n            }\\n            int mid = (start+end) / 2 ;\\n            if (num[mid] >= num[start]) \\n            {\\n                start = mid + 1 ;\\n            }\\n            else\\n            {\\n                end = mid ;\\n            }\\n        }\\n        return num[start] ;\\n    }\\n};\\n```\\n![815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023.png](https://assets.leetcode.com/users/images/5c852e10-a396-462e-ace5-bb3e94c7bcac_1677948564.8946593.png)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        return *min_element(nums.begin(), nums.end()) ; \\n    }\\n};\\n```\n```C++ []\\nclass Solution {\\npublic:\\n     int findMin(vector<int> &num) {\\n        int start = 0 ;\\n        int end = num.size() - 1 ;\\n        \\n        while(start < end) \\n        {\\n            // if start is less than end means array not rotated so first element is the minimum \\n            if (num[start] < num[end])\\n            {\\n                return num[start] ;\\n            }\\n            int mid = (start+end) / 2 ;\\n            if (num[mid] >= num[start]) \\n            {\\n                start = mid + 1 ;\\n            }\\n            else\\n            {\\n                end = mid ;\\n            }\\n        }\\n        return num[start] ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3170327,
                "title": "simplest-c-code-in-log-n-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n\\n        return findMin(nums,0,nums.size()-1);}\\n\\n        bool alreadySorted(vector<int>& nums,int l,int r ){return nums[l]<nums[r];}\\n\\n        private:\\n           int findMin(vector<int>& nums,int l,int r){\\n               if(l==r || alreadySorted(nums,l,r)) return nums[l];\\n               int m=l+(r-l)/2;\\n               int left=findMin(nums,l,m);\\n               int right=findMin(nums,m+1,r);\\n               return min(left,right);\\n        }\\n        \\n       };\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n\\n        return findMin(nums,0,nums.size()-1);}\\n\\n        bool alreadySorted(vector<int>& nums,int l,int r ){return nums[l]<nums[r];}\\n\\n        private:\\n           int findMin(vector<int>& nums,int l,int r){\\n               if(l==r || alreadySorted(nums,l,r)) return nums[l];\\n               int m=l+(r-l)/2;\\n               int left=findMin(nums,l,m);\\n               int right=findMin(nums,m+1,r);\\n               return min(left,right);\\n        }\\n        \\n       };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163312,
                "title": "using-binary-search-method-cpp",
                "content": "# Intuition\\nWe will use binary search because the time complexity should be O(log n)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFind mid and compare it with the first element of the array . If it\\'s greater than first element shift the start pointer to the position next to mid else move the end pointer to position of mid.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        //using binary search method\\n         \\n        int s = 0;\\n        int e = nums.size()-1;\\n        \\n        while(s<e){\\n            //find mid\\n            int mid = s + (e-s)/2;\\n            //condition for already sorted array but not rotated\\n            if(nums[s]<nums[e]){\\n            return nums[s];\\n            }\\n            //conditions for rotated sorted array\\n            if(nums[mid]>=nums[0]){\\n                s = mid+1;\\n            }\\n            else{\\n                e = mid;\\n            }\\n            \\n        }\\n        return nums[s];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        //using binary search method\\n         \\n        int s = 0;\\n        int e = nums.size()-1;\\n        \\n        while(s<e){\\n            //find mid\\n            int mid = s + (e-s)/2;\\n            //condition for already sorted array but not rotated\\n            if(nums[s]<nums[e]){\\n            return nums[s];\\n            }\\n            //conditions for rotated sorted array\\n            if(nums[mid]>=nums[0]){\\n                s = mid+1;\\n            }\\n            else{\\n                e = mid;\\n            }\\n            \\n        }\\n        return nums[s];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3105153,
                "title": "not-a-binary-search-but-a-take-away-for-beginners",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int id=0;\\n        for(int i=0;i<nums.size();++i){\\n            if(i+1==nums.size()){\\n                if(nums[i]>nums[0])\\n                    id=0;\\n                    break;\\n            }\\n            else if(nums[i]>nums[i+1]){\\n                id=i+1;\\n                break;\\n            }\\n        }\\n        return nums[id];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int id=0;\\n        for(int i=0;i<nums.size();++i){\\n            if(i+1==nums.size()){\\n                if(nums[i]>nums[0])\\n                    id=0;\\n                    break;\\n            }\\n            else if(nums[i]>nums[i+1]){\\n                id=i+1;\\n                break;\\n            }\\n        }\\n        return nums[id];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3026673,
                "title": "python-99-77-better-binary-search-solution-easy-to-understand",
                "content": "\\n\\n# Simple answer \\uD83D\\uDE04\\uD83D\\uDE04\\uD83D\\uDE04\\n```\\nclass Solution:\\n    def findMin(self, nums: list[int]) -> int:\\n        return min(nums)\\n```\\n\\n# Binary search\\n```\\nclass Solution:\\n    def findMin(self, nums: list[int]) -> int:\\n        if nums[0] <= nums[-1]:\\n            return nums[0]\\n        l, r = 0, len(nums)-1\\n        while l <= r:\\n            m = (l + r) // 2\\n            if nums[m] < nums[0] <= nums[m - 1]::\\n                return nums[m]\\n            elif nums[m] < nums[0]:\\n                r = m - 1\\n            else:\\n                l = m + 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def findMin(self, nums: list[int]) -> int:\\n        return min(nums)\\n```\n```\\nclass Solution:\\n    def findMin(self, nums: list[int]) -> int:\\n        if nums[0] <= nums[-1]:\\n            return nums[0]\\n        l, r = 0, len(nums)-1\\n        while l <= r:\\n            m = (l + r) // 2\\n            if nums[m] < nums[0] <= nums[m - 1]::\\n                return nums[m]\\n            elif nums[m] < nums[0]:\\n                r = m - 1\\n            else:\\n                l = m + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2919006,
                "title": "binary-search-to-find-the-pivot-element-beats-100-runtime-and-93-33-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince the Array is Sorted, the first thought that came to my mind was to apply **Binary Search** to search for the minimum. We have to find minimum of the array, this means that the value at the index from where the array is rotated.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can find the Pivot of the Array(the index from which the Array is Rotated). To find the pivot, we would apply Binary Search in which there are **mainly four cases**:\\n1. if(mid < end && arr[mid] > arr[mid + 1]){\\n        return mid;\\n    }\\n2. if(mid > start && arr[mid] < arr[mid - 1]){\\n        return mid - 1;\\n    }\\n3. if(arr[mid] <= arr[start]){\\n        end = mid - 1;\\n    }\\n4. else{\\n        start = mid + 1;\\n    }\\n\\nIf all the four cases Fail, this means that the Array is not rotated at all. It will return -1.\\nIf pivot is -1, this means that the Array is not rotated and First element is the smallest element.\\nElse we will return element at pivot + 1 index.\\n\\n# Complexity\\n- Time complexity: O(log n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        int pivot = findPivot(nums);\\n        // If you did not find a pivot, it means the array is not rotated\\n        if (pivot == -1){\\n            return nums[0];\\n        }\\n        return nums[pivot + 1];\\n    }\\n    // This will not work for duplicate values\\n    int findPivot(int[] arr) {\\n        int start = 0;\\n        int end = arr.length - 1;\\n        while (start <= end) {\\n            int mid = start + (end - start) / 2;\\n            // 4 cases over here\\n            if (mid < end && arr[mid] > arr[mid + 1]){\\n                return mid;\\n            }\\n            if (mid > start && arr[mid] < arr[mid - 1]){\\n                return mid - 1;\\n            }\\n            if (arr[mid] <= arr[start]){\\n                end = mid - 1;\\n            }\\n            else{\\n                start = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        int pivot = findPivot(nums);\\n        // If you did not find a pivot, it means the array is not rotated\\n        if (pivot == -1){\\n            return nums[0];\\n        }\\n        return nums[pivot + 1];\\n    }\\n    // This will not work for duplicate values\\n    int findPivot(int[] arr) {\\n        int start = 0;\\n        int end = arr.length - 1;\\n        while (start <= end) {\\n            int mid = start + (end - start) / 2;\\n            // 4 cases over here\\n            if (mid < end && arr[mid] > arr[mid + 1]){\\n                return mid;\\n            }\\n            if (mid > start && arr[mid] < arr[mid - 1]){\\n                return mid - 1;\\n            }\\n            if (arr[mid] <= arr[start]){\\n                end = mid - 1;\\n            }\\n            else{\\n                start = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2839257,
                "title": "find-minimum-in-rotated-sorted-array-java-solution",
                "content": "With the help of while loop\\n```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        int i=0;\\n        while(i!=(nums.length-1))\\n        {\\n            if(nums[i]>nums[i+1])\\n                return nums[i+1];  \\n            i++;\\n        }\\n        return nums[0];\\n    }\\n}\\n```\\n\\nWith help of for loop\\n```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            if(nums[i]>nums[i+1])\\n                return nums[i+1];\\n                \\n        }\\n        return nums[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        int i=0;\\n        while(i!=(nums.length-1))\\n        {\\n            if(nums[i]>nums[i+1])\\n                return nums[i+1];  \\n            i++;\\n        }\\n        return nums[0];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            if(nums[i]>nums[i+1])\\n                return nums[i+1];\\n                \\n        }\\n        return nums[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779546,
                "title": "intuitive-binary-search-in-python",
                "content": "# Intuition\\nThe input array is monotonically increasing until it drops, then it continues to monotonically increase. We want to find the point where it drops (since the smallest element is located there).\\n\\nIf there is no drop, then the first element is the lowest.\\n\\n# Approach\\n1. Initialize exactly the same way as vanilla binary search.\\n2. **Key insight:** If $nums[lo] > nums[mid]$ the drop must be to the right\\n    a. So $hi = mid$ \\n3. Otherwise the drop must be to the left\\n    a. so $lo = mid$\\n4. When $hi$ and $lo$ are adjacent, $hi$ is either the smallest value or the largest value. If $nums[lo] < nums[hi]$, then the array is sorted and we didn\\'t find a drop. So return the first element. Else, $nums[hi]$ is the smallest number.\\n\\n# Complexity\\n- Time complexity: $O(log(n))$\\n\\n- Space complexity: $O(1)$\\n\\n# Code\\n```python\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        hi, lo = len(nums) - 1, 0\\n        while hi - 1 > lo:\\n            mid = (hi + lo)//2\\n            if nums[lo] > nums[mid]: \\n                hi = mid\\n            else: # drop must be to the left\\n                lo = mid\\n\\n        if nums[hi] > nums[lo]:\\n            return nums[0]\\n        return nums[hi]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        hi, lo = len(nums) - 1, 0\\n        while hi - 1 > lo:\\n            mid = (hi + lo)//2\\n            if nums[lo] > nums[mid]: \\n                hi = mid\\n            else: # drop must be to the left\\n                lo = mid\\n\\n        if nums[hi] > nums[lo]:\\n            return nums[0]\\n        return nums[hi]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2731933,
                "title": "clean-c-solution",
                "content": "```\\nint findMin(vector<int>& nums)\\n{\\n    int start=0,end=nums.size()-1;\\n    while(start<end)\\n    {\\n        int mid=(start+end)/2;\\n        nums[mid]>nums[end]?start=mid+1:end=mid;\\n    }\\n    return nums[start];\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint findMin(vector<int>& nums)\\n{\\n    int start=0,end=nums.size()-1;\\n    while(start<end)\\n    {\\n        int mid=(start+end)/2;\\n        nums[mid]>nums[end]?start=mid+1:end=mid;\\n    }\\n    return nums[start];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2683187,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int start  = 0;\\n        int end = nums.size() - 1;\\n        while (start < end) {\\n            int mid = start + (end - start)/2;\\n            // right side is rotated, expecting smallest number between mid + 1 <=  end;\\n            if (nums[mid] > nums[end]) {\\n                start = mid + 1;\\t\\t\\t\\n            } else {\\n\\t\\t\\t\\t// Right side is sequential, which  implies\\n\\t\\t\\t\\t// left is either sequential or rotated. Either case, we can find minimum from values at between start <= mid index.\\n\\t\\t\\t\\t// e.g.\\n\\t\\t\\t\\t// 1 2 3 4  5 6 7   ( 4 is mid)\\n\\t\\t\\t\\t// 8  9 4 5 6 7     (say 4 is mid)\\n\\t\\t\\t\\t// 8 9 1 4 5 6 7\\n                end = mid;\\n            }\\n        }\\n        return nums[start];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int start  = 0;\\n        int end = nums.size() - 1;\\n        while (start < end) {\\n            int mid = start + (end - start)/2;\\n            // right side is rotated, expecting smallest number between mid + 1 <=  end;\\n            if (nums[mid] > nums[end]) {\\n                start = mid + 1;\\t\\t\\t\\n            } else {\\n\\t\\t\\t\\t// Right side is sequential, which  implies\\n\\t\\t\\t\\t// left is either sequential or rotated. Either case, we can find minimum from values at between start <= mid index.\\n\\t\\t\\t\\t// e.g.\\n\\t\\t\\t\\t// 1 2 3 4  5 6 7   ( 4 is mid)\\n\\t\\t\\t\\t// 8  9 4 5 6 7     (say 4 is mid)\\n\\t\\t\\t\\t// 8 9 1 4 5 6 7\\n                end = mid;\\n            }\\n        }\\n        return nums[start];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2594461,
                "title": "beats-100-0-ms-c-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) \\n    {\\n        int lo = 0;\\n        int hi = nums.size()-1;\\n        \\n        //wrote code thinking of following cases:\\n        //[1]\\n        //[2,1]        \\n        //[1,2]       -> shifted 0 times (even len)\\n        //[1,2,3]     -> shifted 0 times (odd len)\\n        //[3,1,2]     -> shifted 1 times \\n        //[3,4,5,6,1] -> shifted 1 times\\n        //[6,1,2,3,4] -> shifted n-1 times\\n        int ans = INT_MAX;\\n        while(hi >= lo)\\n        {\\n            int mid = (lo+hi)/2;\\n            \\n            //means, mid lies in greater portion of sorted array \\n            if(nums[mid] > nums[hi])\\n            {\\n                lo = mid+1;\\n            }\\n            else\\n            {\\n                // wanted to just have ans = nums[mid]\\n                // but failed at [3,2,1]\\n                // hence had to add this check\\n                ans = min(ans, nums[mid]);\\n                hi = mid-1;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/96fa2e6e-6712-46bd-889c-a04a064e1614_1663532248.8305306.jpeg)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) \\n    {\\n        int lo = 0;\\n        int hi = nums.size()-1;\\n        \\n        //wrote code thinking of following cases:\\n        //[1]\\n        //[2,1]        \\n        //[1,2]       -> shifted 0 times (even len)\\n        //[1,2,3]     -> shifted 0 times (odd len)\\n        //[3,1,2]     -> shifted 1 times \\n        //[3,4,5,6,1] -> shifted 1 times\\n        //[6,1,2,3,4] -> shifted n-1 times\\n        int ans = INT_MAX;\\n        while(hi >= lo)\\n        {\\n            int mid = (lo+hi)/2;\\n            \\n            //means, mid lies in greater portion of sorted array \\n            if(nums[mid] > nums[hi])\\n            {\\n                lo = mid+1;\\n            }\\n            else\\n            {\\n                // wanted to just have ans = nums[mid]\\n                // but failed at [3,2,1]\\n                // hence had to add this check\\n                ans = min(ans, nums[mid]);\\n                hi = mid-1;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2075624,
                "title": "o-logn-solution-in-cpp-using-binary-search",
                "content": "The idea here is similar... we use the binary approach as we used to do in sorted array...\\nWe stop when we reach an element such that the element before it is greater than itself (point of rotation)\\nTo traverse only in half of the array, we check which half is not sorted... since the least element will be there only in not sorted half...\\n\\n**Pls upvote if you found this code helpful**\\n\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int low=0, high=nums.size()-1;\\n        while(low<high) {\\n            int mid=(low+high)/2;\\n            if(mid!=0 && nums[mid]<nums[mid-1]) return nums[mid];\\n            else if(nums[low]<=nums[mid] && nums[mid]>nums[high]) low=mid+1;\\n            else high=mid-1;\\n        }\\n        \\n        return nums[low];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int low=0, high=nums.size()-1;\\n        while(low<high) {\\n            int mid=(low+high)/2;\\n            if(mid!=0 && nums[mid]<nums[mid-1]) return nums[mid];\\n            else if(nums[low]<=nums[mid] && nums[mid]>nums[high]) low=mid+1;\\n            else high=mid-1;\\n        }\\n        \\n        return nums[low];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2037287,
                "title": "c-aditya-verma-solution-o-log-n",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        int findMin(vector<int> &nums)\\n        {\\n            int start = 0;\\n            int size = nums.size();\\n            int end = nums.size() - 1;\\n            if (nums[end] >= nums[start])\\n            {\\n                return nums[0];\\n            }\\n            else\\n            {\\n                while (end >= start)\\n                {\\n                    int mid = (end + start) / 2;\\n                    int prev = (mid + nums.size() - 1) % size;\\n                    int next = (mid + 1) % size;\\n\\n                    if (nums[mid] <= nums[prev] && nums[mid] <= nums[next])\\n                    {\\n                        return nums[mid];\\n                    }\\n                    else if (nums[mid] > nums[end])\\n                    {\\n                        start = mid + 1;\\n                    }\\n                    else\\n                    {\\n                        end = mid;\\n                    }\\n                }\\n            }\\n            return -1;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        int findMin(vector<int> &nums)\\n        {\\n            int start = 0;\\n            int size = nums.size();\\n            int end = nums.size() - 1;\\n            if (nums[end] >= nums[start])\\n            {\\n                return nums[0];\\n            }\\n            else\\n            {\\n                while (end >= start)\\n                {\\n                    int mid = (end + start) / 2;\\n                    int prev = (mid + nums.size() - 1) % size;\\n                    int next = (mid + 1) % size;\\n\\n                    if (nums[mid] <= nums[prev] && nums[mid] <= nums[next])\\n                    {\\n                        return nums[mid];\\n                    }\\n                    else if (nums[mid] > nums[end])\\n                    {\\n                        start = mid + 1;\\n                    }\\n                    else\\n                    {\\n                        end = mid;\\n                    }\\n                }\\n            }\\n            return -1;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2006471,
                "title": "c-concise-code-both-linear-and-binary-search",
                "content": "1) The solution is based on the algorithm of LINEAR SEARCH , where we traverse each element and compare with a maximum element (mn) .\\nT.C. -> O(N) #Not recommended in this question .\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int mn=INT_MAX;\\n        for(int i=0;i<nums.size();i++)\\n\\n        {\\n            mn=min(mn,nums[i]);\\n}\\n    return mn;\\n    }\\n};\\n\\n```\\n2) Solution is based on the algorithm of BINARY SEARCH , this is an extended version of binary search where we check at first if the first element is lesser than last element then it is obvious that full arrray is sorted and first element is minimum , if mid element is greater than equal to lower element then first half is surely sorted so we do l=m+1  if lower element is greater than middle element then second half is sorted , so we do h=m. At last we return lower element as it points to the minimum .\\nT.C. -> O(log N) #highly recommended for this question \\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& a) {\\n        int l=0,h=a.size()-1;\\n        while(l<h)\\n        {\\n            \\n            \\n            if(a[l]<a[h])\\n                return a[l];\\n            int m=l+(h-l)/2;\\n            if(a[l]<=a[m])\\n                l=m+1;\\n            else\\n                h=m;\\n        }\\n        return a[l];\\n    }\\n};\\n```\\n\\nENJOY <3",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int mn=INT_MAX;\\n        for(int i=0;i<nums.size();i++)\\n\\n        {\\n            mn=min(mn,nums[i]);\\n}\\n    return mn;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& a) {\\n        int l=0,h=a.size()-1;\\n        while(l<h)\\n        {\\n            \\n            \\n            if(a[l]<a[h])\\n                return a[l];\\n            int m=l+(h-l)/2;\\n            if(a[l]<=a[m])\\n                l=m+1;\\n            else\\n                h=m;\\n        }\\n        return a[l];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1829214,
                "title": "c-solution-with-and-without-using-binary-search-approach-o-n-o-logn",
                "content": "**Approach**\\n\\n1) Firstly we find that how many time\\'s the array is rotated by simply using a for loop and iterating till the peak element.\\n2) Secondly we use a mathematical approach  ***a[i] = a[(i+k)%n]\\u3164*** to return the smallest element\\n\\n***If you like this explanation, please upvote\\nComment down below in case you have some suggestion***\\n\\n**C++** :\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int k = 1;\\n        for(int i = 0;i<nums.size()-1;i++){\\n            if(nums[i]<nums[i+1]) k++;\\n            else break;\\n        }\\n          return nums[(0+k)%nums.size()];\\n    }\\n};\\n```\\n\\n**Time Complexity**  : O(n).\\n\\n**Space Complexity**: O(1).\\n\\n\\n\\n\\n--> **2nd Approach.**\\n\\n**Binary Search**\\n\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n      int start =0, end = nums.size()-1;\\n        while(start<end){\\n            if (nums[start]<nums[end])\\n                return nums[start];\\n            \\n              int mid=(start+end)/2;\\n              if(nums[mid]>=nums[start]) start=mid+1;\\n              else end=mid;\\n        }\\n        return nums[start];\\n    }\\n};\\n```\\n\\n**Time Complexity**  : O(logn).\\n\\n**Space Complexity**: O(1).\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int k = 1;\\n        for(int i = 0;i<nums.size()-1;i++){\\n            if(nums[i]<nums[i+1]) k++;\\n            else break;\\n        }\\n          return nums[(0+k)%nums.size()];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n      int start =0, end = nums.size()-1;\\n        while(start<end){\\n            if (nums[start]<nums[end])\\n                return nums[start];\\n            \\n              int mid=(start+end)/2;\\n              if(nums[mid]>=nums[start]) start=mid+1;\\n              else end=mid;\\n        }\\n        return nums[start];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1793240,
                "title": "simple-solution-faster-than-100-java-binary-search",
                "content": "```\\npublic int findMin(int[] nums) {\\n        int left = 0, right = nums.length - 1;\\n\\n        int mid = -1;\\n\\n        while(left < right){\\n            mid = left + (right - left) / 2;\\n\\n            if(nums[mid] > nums[right]){\\n                left = mid + 1;\\n            }\\n            else{\\n                right = mid;\\n            }\\n        }\\n\\n        return Math.min(nums[0], nums[left]);\\n    }\\n\\t\\t",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\npublic int findMin(int[] nums) {\\n        int left = 0, right = nums.length - 1;\\n\\n        int mid = -1;\\n\\n        while(left < right){\\n            mid = left + (right - left) / 2;\\n\\n            if(nums[mid] > nums[right]){\\n                left = mid + 1;\\n            }\\n            else{\\n                right = mid;\\n            }\\n        }\\n\\n        return Math.min(nums[0], nums[left]);\\n    }\\n\\t\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1752177,
                "title": "clean-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n = nums.size();\\n        int l = 0; int h = n-1;\\n        while(l < h) {\\n            int mid = l + (h-l)/2;\\n            if(nums[mid] > nums[h]) {\\n                l = mid+1;\\n            } else {\\n                h = mid;\\n            }\\n        }\\n        return nums[l];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n = nums.size();\\n        int l = 0; int h = n-1;\\n        while(l < h) {\\n            int mid = l + (h-l)/2;\\n            if(nums[mid] > nums[h]) {\\n                l = mid+1;\\n            } else {\\n                h = mid;\\n            }\\n        }\\n        return nums[l];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1741722,
                "title": "how-would-you-explain-it-to-an-interviewer",
                "content": "**INTUITION** :  here, this is pretty easy, we are getting a k sorted array,i.e.  partially sorted we can apply binary search.\\n Now, to apply binary search, we need a binary criteria to divide our search space into 2 parts, which we can understand by looking at the graph below.\\n ![image](https://assets.leetcode.com/users/images/f5b9ef72-66b8-4bcc-9d78-a2ce3e87220b_1643886247.7863996.png)\\n 1. Our goal is to reach the valley.\\n 2. If we are at any point between [ 4 ,7], we need to move right to reach the valley.\\n 3. If we are [1, 2], we need to go towards the left to reach the valley.\\n Now, how do we figure out which part of the graph, our curr value lies in.\\n 4. If `curr value <nums[0]` , we lie in the [0,2] portion, else we move right.\\n **Edge case:**\\n In the second case, when we reach the peak, start becomes n, which means the array is not rotated, it is in a monotone unlike case 1.\\n**Code:**\\n  \\n ```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n=nums.size();\\n        int start=0,end=n-1,mid=(start+end)/2;\\n        while(start<=end)\\n        {  \\n           \\n           if(nums[mid]>=nums[0])\\n               start=mid+1;         //go right\\n            else\\n              end=mid-1;          // go left.\\n             \\n            mid=(start+end)/2;\\n        }\\n        if(start==n)\\n            return nums[0];\\n        return nums[start];\\n        \\n    }\\n};\\n```\\n\\n**Please upvote, if you like it!!!**\\n \\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n=nums.size();\\n        int start=0,end=n-1,mid=(start+end)/2;\\n        while(start<=end)\\n        {  \\n           \\n           if(nums[mid]>=nums[0])\\n               start=mid+1;         //go right\\n            else\\n              end=mid-1;          // go left.\\n             \\n            mid=(start+end)/2;\\n        }\\n        if(start==n)\\n            return nums[0];\\n        return nums[start];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1739125,
                "title": "c-binary-search-o-log-n-approach",
                "content": "Kindly **upvote**, if you find it helpful : )\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n = nums.size();\\n        int s = 0;\\n        int e = n-1;\\n        int m = s + (e-s)/2;\\n        if(nums[s]<nums[e]){\\n            return nums[s];\\n        }\\n        while(s < e){\\n            if(nums[m] >= nums[0]){\\n                s = m+1;\\n            }\\n            else{\\n                e = m;\\n            }\\n            m = s + (e-s)/2;\\n        }\\n        return nums[s];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n = nums.size();\\n        int s = 0;\\n        int e = n-1;\\n        int m = s + (e-s)/2;\\n        if(nums[s]<nums[e]){\\n            return nums[s];\\n        }\\n        while(s < e){\\n            if(nums[m] >= nums[0]){\\n                s = m+1;\\n            }\\n            else{\\n                e = m;\\n            }\\n            m = s + (e-s)/2;\\n        }\\n        return nums[s];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1438086,
                "title": "c-simple-binary-search-extension-beats-100-of-c-submissions",
                "content": "Simple Binary Search Extension (Time Complexity : O(logn))\\nI highly recommend solving the question below before attempting the current question. Anyways the code is given down below (100% faster than all other C++ codes).\\nTry this question : \\n[https://leetcode.com/problems/search-in-rotated-sorted-array/](http://)\\n\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int low = 0;\\n        int high = nums.size() - 1;\\n        \\n        while(low < high){\\n            int mid = (low + high)/2;\\n            if(nums[low] <= nums[mid] && nums[high] >= nums[mid])\\n                high = mid - 1;\\n            else if(nums[low] <= nums[mid] && nums[high] <= nums[mid])\\n                low = mid + 1;\\n            else if(nums[mid] <= nums[low])\\n                high = mid;\\n        }\\n        return nums[low];\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/91a705d3-90a8-4952-b877-c9fb9ee78d53_1630477085.976078.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int low = 0;\\n        int high = nums.size() - 1;\\n        \\n        while(low < high){\\n            int mid = (low + high)/2;\\n            if(nums[low] <= nums[mid] && nums[high] >= nums[mid])\\n                high = mid - 1;\\n            else if(nums[low] <= nums[mid] && nums[high] <= nums[mid])\\n                low = mid + 1;\\n            else if(nums[mid] <= nums[low])\\n                high = mid;\\n        }\\n        return nums[low];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1436343,
                "title": "python-3-one-line-o-log-n",
                "content": "The idea is to \"convert\" the array to 0\\'s and 1\\'s and binary search for the first 1.\\n\\n```\\n[4,5,6,7,0,1,2]\\n->\\n 0 0 0 0 1 1 1\\n```\\nand\\n```\\n[0,1,2,4,5,6,7]\\n->\\n 1 1 1 1 1 1 1\\n```\\n\\nSo how can we do this? The ith value will be `1 if A[i] <= A[-1] else 0`.\\n\\nSo we can now binary search given the formula for the ith value.\\n\\n```python\\nclass Solution:\\n  def findMin(self, A: List[int]) -> int:\\n    class Wrapper:\\n      def __getitem__(self, i):\\n        return A[i] <= A[-1]\\n    return A[bisect_left(Wrapper(), 1, 0, len(A))]\\n```\\n\\nOr in one line:\\n```python\\nclass Solution:\\n  def findMin(self, A: List[int]) -> int:\\n    return A[bisect_left(type(\\'\\', (), {\\'__getitem__\\': lambda _,i: A[i] <= A[-1]})(), 1, 0, len(A))]\\n```\\n\\n--- \\n\\nAnd of course here\\'s the cheesy O(n) solution that you\\'re not supposed to give:\\n\\n```\\nclass Solution: findMin = min\\n```",
                "solutionTags": [],
                "code": "```\\n[4,5,6,7,0,1,2]\\n->\\n 0 0 0 0 1 1 1\\n```\n```\\n[0,1,2,4,5,6,7]\\n->\\n 1 1 1 1 1 1 1\\n```\n```python\\nclass Solution:\\n  def findMin(self, A: List[int]) -> int:\\n    class Wrapper:\\n      def __getitem__(self, i):\\n        return A[i] <= A[-1]\\n    return A[bisect_left(Wrapper(), 1, 0, len(A))]\\n```\n```python\\nclass Solution:\\n  def findMin(self, A: List[int]) -> int:\\n    return A[bisect_left(type(\\'\\', (), {\\'__getitem__\\': lambda _,i: A[i] <= A[-1]})(), 1, 0, len(A))]\\n```\n```\\nclass Solution: findMin = min\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1420223,
                "title": "clean-c-solution-beats-100",
                "content": "**Upvotes would be appreciated !**\\n```\\nclass Solution {\\npublic:\\n    int findMin(const vector<int>& nums) {\\n        int start = 0, end = nums.size()-1;\\n        while(start<end){\\n            int mid = (start+end)/2;\\n            if(nums[mid]>nums[end]) start = mid+1;\\n            else end = mid;\\n        }\\n        return nums[start];\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int findMin(const vector<int>& nums) {\\n        int start = 0, end = nums.size()-1;\\n        while(start<end){\\n            int mid = (start+end)/2;\\n            if(nums[mid]>nums[end]) start = mid+1;\\n            else end = mid;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1343570,
                "title": "c-solution-with-comments-100-faster",
                "content": "**Time complexity - O(logn)\\nSpace complexity - O(1)**\\n\\n```\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        //using binary search\\n        int low = 0;\\n        int high = nums.size()-1;\\n        //if the array is rotated n times\\n        if(nums[low] <= nums[high]) return nums[low];\\n        while(low <= high){\\n            int mid = (low+high)/2;\\n            // check on right element\\n            if(nums[mid]  > nums[mid+1])return nums[mid+1];\\n            //check on left element\\n            else if(nums[mid] < nums[mid-1]) return nums[mid];\\n            //discard the sorted array and shift low or high\\n            else if(nums[low]<= nums[mid]) low = mid+1;\\n            else if(nums[mid]<= nums[high]) high = mid-1;\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        //using binary search\\n        int low = 0;\\n        int high = nums.size()-1;\\n        //if the array is rotated n times\\n        if(nums[low] <= nums[high]) return nums[low];\\n        while(low <= high){\\n            int mid = (low+high)/2;\\n            // check on right element\\n            if(nums[mid]  > nums[mid+1])return nums[mid+1];\\n            //check on left element\\n            else if(nums[mid] < nums[mid-1]) return nums[mid];\\n            //discard the sorted array and shift low or high\\n            else if(nums[low]<= nums[mid]) low = mid+1;\\n            else if(nums[mid]<= nums[high]) high = mid-1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1240459,
                "title": "beats-100-cpp-explanation-binary-search",
                "content": "Here this problem is given then it is sorted in ascending order taking advantage of this information.\\n\\nStep 1 : If anyhow we can find the peak element in the array then we can move forward as it is in ascending order and sorted so that will be decreasing slope.\\nHang on a while lets take an example to understand :\\n\\n``` arr = [4,5,6,7,0,1,2] ```  here we can see the peak element is. ``` 7 ``` and after that it has a decerasing slope this is what i was talking about a few seconds ago ``` peak element```  and then its simple we can traverse the whole arr. starting from the peak element to the end of the array \\n\\nThere are some edge cases we need to consider like what if array has only 1 element .\\n\\n**If you liked it click on the** ``` UPVOTE BUTTON ``` \\n\\n``` \\n if(nums.size() == 1) return nums[0];\\n        int start = 0;\\n        int end = nums.size() - 1;\\n        int ans = INT_MAX;\\n        while(start < end){\\n            int mid = start + (end-start) / 2;\\n            if(nums[mid] < nums[mid+1])\\n                end = mid - 1;\\n            else\\n                start = mid + 1;\\n        }\\n\\t\\t// here start will give me the peak element index \\n        end = nums.size() - 1; // reintialize the end as it got changed above\\n        \\n        while(start <= end){\\n            ans = min(ans , nums[start]);\\n            start++;\\n        }\\n        return ans;\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "``` arr = [4,5,6,7,0,1,2] ```\n``` 7 ```\n``` peak element```\n``` UPVOTE BUTTON ```\n``` \\n if(nums.size() == 1) return nums[0];\\n        int start = 0;\\n        int end = nums.size() - 1;\\n        int ans = INT_MAX;\\n        while(start < end){\\n            int mid = start + (end-start) / 2;\\n            if(nums[mid] < nums[mid+1])\\n                end = mid - 1;\\n            else\\n                start = mid + 1;\\n        }\\n\\t\\t// here start will give me the peak element index \\n        end = nums.size() - 1; // reintialize the end as it got changed above\\n        \\n        while(start <= end){\\n            ans = min(ans , nums[start]);\\n            start++;\\n        }\\n        return ans;\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1575700,
                "content": [
                    {
                        "username": "inomag",
                        "content": "The main idea is, the element is said to be minimum in the rotated sorted array if the previous element to it is greater than it or there is no previous element(i.e. no rotation). We can do this using Binary search\\n1. Find the mid element i.e. mid = (low+high)/2\\n2. If the (mid+1)th element is less than mid element then return (mid+1)th element\\n3. If the mid element is less than (mid-1)th element then return the mid element\\n4. If the last element is greater than mid element then search in left half\\n5. If the last element is less than mid element then search in right half\\n\\n**Time Complexity: O(logn)**\\n**Space Complexity: O(1)**\\n\\n*Solution is in the comments.*\\n\\n"
                    },
                    {
                        "username": "paawan3000",
                        "content": "ans"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Please, do not post answers in discussions.\\nPeople try to find tips here, not spoilers."
                    },
                    {
                        "username": "cagils",
                        "content": "We only need to compare mid with right one in the binary search. This will automatically handle the edge case of already sorted array.\\n\\n```\\n4 5 6 7 8 9 0 1 2 3\\nl       m         r\\nm > r => l = m + 1\\n4 5 6 7 8 9 0 1 2 3\\n          l   m   r\\nm < r => r = m\\n4 5 6 7 8 9 0 1 2 3\\n          l m r\\nm < r => r = m\\n4 5 6 7 8 9 0 1 2 3\\n          l r\\nm > r => l = m + 1\\n7 8 0 1 2 3 4 5 6\\n            lr\\nr >= l => return l\\n\\n7 8 0 1 2 3 4 5 6\\nl       m       r\\nm < r => r = m\\n7 8 0 1 2 3 4 5 6\\nl m     m\\nm > r => l = m + 1\\n7 8 0 1 2 3 4 5 6\\n    l m r\\nm < l => r = m\\n7 8 0 1 2 3 4 5 6\\n    l r\\nm < r => r = m\\n7 8 0 1 2 3 4 5 6\\n    lr\\nr >= l => return l\\n\\n8 0 1 2 3 4 5 6 7\\nl       m       r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl   m   r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl m r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl r\\nm > r => l = m + 1\\n8 0 1 2 3 4 5 6 7\\n  lr\\nr >=l => return l\\n\\n0 1 2 3 4\\nl   m   r\\nm < r => r = m\\n0 1 2 3 4\\nl m r\\nm < r => r = m\\n0 1 2 3 4\\nl r\\nm < r => r = m\\n0 1 2 3 4\\nlr\\nr >= l => return l\\n```"
                    },
                    {
                        "username": "akshaydusad",
                        "content": "Thanks a lot for this explanation, I was so confused as to why the mid was only being compared to the right."
                    },
                    {
                        "username": "punit_gautam",
                        "content": "return min(nums)"
                    },
                    {
                        "username": "aphamdd",
                        "content": "obviously this is a joke guys"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "OK.\\nNow show it during an interview :)"
                    },
                    {
                        "username": "InvaderTim1",
                        "content": "[@angeldimitrov](/angeldimitrov) I really hate the test cases on this one, they\\'re so small I couldn\\'t even visualize the while loop in action. I had to go make my own tests in VsCode."
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "[@Sarichi](/Sarichi) this solution with Python runs at \\'70% faster\\' than remainder of solutions, at the time of writing this. Sure, binary search may be more optimal in edge cases but it does not seem that the test cases reflect this. The point of leetcode is supposed to be to include test cases that include incredibly complex edge cases."
                    },
                    {
                        "username": "Sarichi",
                        "content": "It must run in O(log N) not an O(N). If we were just asked to solve it, it would have been tagged as easy. They want us to implement using a binary search."
                    },
                    {
                        "username": "GTXFORCE",
                        "content": "My code just: \"sort(nums.begin(),nums.end()); return nums[0]\". It beats 100% in CPP.\\n\\nThe key is when an array is pre-sorted, sort algorithm can almost reach its best case, no longer NlogN !!\\n\\nSame story in problem when they ask you to Merage K sorted array, Instead of using priority queue, just concatenate them and do a fast sort, and that beats 92.26% cpp files. In addition, let say those K array are in extremely bad case, where K is huge, each array only has 1 or 2 elements and the arrays are put into worst order. The performance of concatenating and sorting of course will drop a lot yet so will priority queue, and you need a lot of extra memory to keep your queue alive as well.\\n\\n\\n\\n"
                    },
                    {
                        "username": "bulgarmarc",
                        "content": "[@abzelmes](/abzelmes) it is stated that you should solve it in O(logn) which implies to not sort the list, because sorting the list takes O(nlogn) "
                    },
                    {
                        "username": "kanishk82",
                        "content": "Clearly, fastest sorting algo is O(nlogn) which is greater than a liner search O(n), but for binary search it\\'s O(logn), which is the smallest. So better use a binary search"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@abzelmes](/abzelmes) The problem requires O(log n) time so that already precludes sorting."
                    },
                    {
                        "username": "HitenTandon",
                        "content": "best case sorting time is still O(N) so you\\'re still better of just finding the smallest element linearly"
                    },
                    {
                        "username": "abzelmes",
                        "content": "Obviously this is the best solution, but I found it fun to actually try to do it without sorting. I think they need to add this to the problems requirements. That you shouldn\\'t sort the array.\\nBecause otherwise it would be an easy problem"
                    },
                    {
                        "username": "arnavk09",
                        "content": "This problem in particular is one of those rare cases when the most intuitive solution (that seems like brute force in the beginning) is the one that gives the best answer somehow"
                    },
                    {
                        "username": "faux_hubris",
                        "content": "Use Binary Search to find the largest element i.e. the pivot. The element in the array after the pivot i.e. nums[pivot + 1] is your answer. If mums[nums.Length] > nums[0], then you know it can be considered as a sorted array without rotation. In that case, simply return nums[0]."
                    },
                    {
                        "username": "jayanta1250",
                        "content": "This is not a leetcode medium question if you think. There is nothing to worry about how many times the array is rotated . you have to just find the pivot using binary search. And think in a rotated array pivot is the largest number and next after pivot is the smallest . If the array in not rotated just you have to return the 1st element because that it is the smallest element. Easy thinking. Have a good day best of luck"
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. If array is rotated, it will have two halves : increasing and decreasing. So we can compare mid and mid + 1. If mid > mid + 1, we know this is the tipping point so return mid + 1. \\n\\nThis is because if an array is not rotated, mid > mid + 1 will never occur"
                    },
                    {
                        "username": "jamshidyuldashev7799",
                        "content": "Hi, it is very good.  "
                    },
                    {
                        "username": "tatkal",
                        "content": "Please change the difficulty tag to medium."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Use binary search to find the minimum element in the rotated sorted array. Check if the middle element is smaller than the element before it. If yes, then the minimum element is found. Otherwise, the check if the middle element is smaller than the last element of the array. If yes, then the search is narrowed down to the elements before the middle element. Otherwise, the search is narrowed down to the elements after the middle element. Return the first element of the array as the minimum element, since the first element will not have an element before it."
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(153)Find%20Minimum%20in%20Rotated%20sorted%20Array"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Carry3236](/Carry3236) Actually, the provided solution also works correctly for monotonically increasing arrays (a type of sorted array with no rotations). Let\\'s look at an example:\\n\\nSuppose we have the array `nums = [1,2,3,4,5]`.\\n\\nAt the beginning, `l = 0`, `r = 4`, so `mid = 2`. `nums[mid] = 3` and `nums[r] = 5`. Since `nums[mid]` is not greater than `nums[r]`, we move `r` to `mid`, which is `2`.\\n\\nIn the next iteration, `l = 0`, `r = 2`, so `mid = 1`. `nums[mid] = 2` and `nums[r] = 3`. Again, `nums[mid]` is not greater than `nums[r]`, so we move `r` to `mid`, which is `1`.\\n\\nIn the final iteration, `l = 0`, `r = 1`, so `mid = 0`. `nums[mid] = 1` and `nums[r] = 2`. `nums[mid]` is not greater than `nums[r]`, so we move `r` to `mid`, which is `0`.\\n\\nNow `l` and `r` both point to `0`, and the loop ends. We return `nums[l]`, which is `1` \\u2014 the minimum element in the array.\\n\\nThis confirms that the code does work for monotonically increasing arrays. It always finds the pivot point where the array is \"rotated\" (which, in the case of a monotonically increasing array, is the first element)."
                    },
                    {
                        "username": "Carry3236",
                        "content": "this fails in case of monotonic array ."
                    }
                ]
            },
            {
                "id": 1876714,
                "content": [
                    {
                        "username": "inomag",
                        "content": "The main idea is, the element is said to be minimum in the rotated sorted array if the previous element to it is greater than it or there is no previous element(i.e. no rotation). We can do this using Binary search\\n1. Find the mid element i.e. mid = (low+high)/2\\n2. If the (mid+1)th element is less than mid element then return (mid+1)th element\\n3. If the mid element is less than (mid-1)th element then return the mid element\\n4. If the last element is greater than mid element then search in left half\\n5. If the last element is less than mid element then search in right half\\n\\n**Time Complexity: O(logn)**\\n**Space Complexity: O(1)**\\n\\n*Solution is in the comments.*\\n\\n"
                    },
                    {
                        "username": "paawan3000",
                        "content": "ans"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Please, do not post answers in discussions.\\nPeople try to find tips here, not spoilers."
                    },
                    {
                        "username": "cagils",
                        "content": "We only need to compare mid with right one in the binary search. This will automatically handle the edge case of already sorted array.\\n\\n```\\n4 5 6 7 8 9 0 1 2 3\\nl       m         r\\nm > r => l = m + 1\\n4 5 6 7 8 9 0 1 2 3\\n          l   m   r\\nm < r => r = m\\n4 5 6 7 8 9 0 1 2 3\\n          l m r\\nm < r => r = m\\n4 5 6 7 8 9 0 1 2 3\\n          l r\\nm > r => l = m + 1\\n7 8 0 1 2 3 4 5 6\\n            lr\\nr >= l => return l\\n\\n7 8 0 1 2 3 4 5 6\\nl       m       r\\nm < r => r = m\\n7 8 0 1 2 3 4 5 6\\nl m     m\\nm > r => l = m + 1\\n7 8 0 1 2 3 4 5 6\\n    l m r\\nm < l => r = m\\n7 8 0 1 2 3 4 5 6\\n    l r\\nm < r => r = m\\n7 8 0 1 2 3 4 5 6\\n    lr\\nr >= l => return l\\n\\n8 0 1 2 3 4 5 6 7\\nl       m       r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl   m   r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl m r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl r\\nm > r => l = m + 1\\n8 0 1 2 3 4 5 6 7\\n  lr\\nr >=l => return l\\n\\n0 1 2 3 4\\nl   m   r\\nm < r => r = m\\n0 1 2 3 4\\nl m r\\nm < r => r = m\\n0 1 2 3 4\\nl r\\nm < r => r = m\\n0 1 2 3 4\\nlr\\nr >= l => return l\\n```"
                    },
                    {
                        "username": "akshaydusad",
                        "content": "Thanks a lot for this explanation, I was so confused as to why the mid was only being compared to the right."
                    },
                    {
                        "username": "punit_gautam",
                        "content": "return min(nums)"
                    },
                    {
                        "username": "aphamdd",
                        "content": "obviously this is a joke guys"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "OK.\\nNow show it during an interview :)"
                    },
                    {
                        "username": "InvaderTim1",
                        "content": "[@angeldimitrov](/angeldimitrov) I really hate the test cases on this one, they\\'re so small I couldn\\'t even visualize the while loop in action. I had to go make my own tests in VsCode."
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "[@Sarichi](/Sarichi) this solution with Python runs at \\'70% faster\\' than remainder of solutions, at the time of writing this. Sure, binary search may be more optimal in edge cases but it does not seem that the test cases reflect this. The point of leetcode is supposed to be to include test cases that include incredibly complex edge cases."
                    },
                    {
                        "username": "Sarichi",
                        "content": "It must run in O(log N) not an O(N). If we were just asked to solve it, it would have been tagged as easy. They want us to implement using a binary search."
                    },
                    {
                        "username": "GTXFORCE",
                        "content": "My code just: \"sort(nums.begin(),nums.end()); return nums[0]\". It beats 100% in CPP.\\n\\nThe key is when an array is pre-sorted, sort algorithm can almost reach its best case, no longer NlogN !!\\n\\nSame story in problem when they ask you to Merage K sorted array, Instead of using priority queue, just concatenate them and do a fast sort, and that beats 92.26% cpp files. In addition, let say those K array are in extremely bad case, where K is huge, each array only has 1 or 2 elements and the arrays are put into worst order. The performance of concatenating and sorting of course will drop a lot yet so will priority queue, and you need a lot of extra memory to keep your queue alive as well.\\n\\n\\n\\n"
                    },
                    {
                        "username": "bulgarmarc",
                        "content": "[@abzelmes](/abzelmes) it is stated that you should solve it in O(logn) which implies to not sort the list, because sorting the list takes O(nlogn) "
                    },
                    {
                        "username": "kanishk82",
                        "content": "Clearly, fastest sorting algo is O(nlogn) which is greater than a liner search O(n), but for binary search it\\'s O(logn), which is the smallest. So better use a binary search"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@abzelmes](/abzelmes) The problem requires O(log n) time so that already precludes sorting."
                    },
                    {
                        "username": "HitenTandon",
                        "content": "best case sorting time is still O(N) so you\\'re still better of just finding the smallest element linearly"
                    },
                    {
                        "username": "abzelmes",
                        "content": "Obviously this is the best solution, but I found it fun to actually try to do it without sorting. I think they need to add this to the problems requirements. That you shouldn\\'t sort the array.\\nBecause otherwise it would be an easy problem"
                    },
                    {
                        "username": "arnavk09",
                        "content": "This problem in particular is one of those rare cases when the most intuitive solution (that seems like brute force in the beginning) is the one that gives the best answer somehow"
                    },
                    {
                        "username": "faux_hubris",
                        "content": "Use Binary Search to find the largest element i.e. the pivot. The element in the array after the pivot i.e. nums[pivot + 1] is your answer. If mums[nums.Length] > nums[0], then you know it can be considered as a sorted array without rotation. In that case, simply return nums[0]."
                    },
                    {
                        "username": "jayanta1250",
                        "content": "This is not a leetcode medium question if you think. There is nothing to worry about how many times the array is rotated . you have to just find the pivot using binary search. And think in a rotated array pivot is the largest number and next after pivot is the smallest . If the array in not rotated just you have to return the 1st element because that it is the smallest element. Easy thinking. Have a good day best of luck"
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. If array is rotated, it will have two halves : increasing and decreasing. So we can compare mid and mid + 1. If mid > mid + 1, we know this is the tipping point so return mid + 1. \\n\\nThis is because if an array is not rotated, mid > mid + 1 will never occur"
                    },
                    {
                        "username": "jamshidyuldashev7799",
                        "content": "Hi, it is very good.  "
                    },
                    {
                        "username": "tatkal",
                        "content": "Please change the difficulty tag to medium."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Use binary search to find the minimum element in the rotated sorted array. Check if the middle element is smaller than the element before it. If yes, then the minimum element is found. Otherwise, the check if the middle element is smaller than the last element of the array. If yes, then the search is narrowed down to the elements before the middle element. Otherwise, the search is narrowed down to the elements after the middle element. Return the first element of the array as the minimum element, since the first element will not have an element before it."
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(153)Find%20Minimum%20in%20Rotated%20sorted%20Array"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Carry3236](/Carry3236) Actually, the provided solution also works correctly for monotonically increasing arrays (a type of sorted array with no rotations). Let\\'s look at an example:\\n\\nSuppose we have the array `nums = [1,2,3,4,5]`.\\n\\nAt the beginning, `l = 0`, `r = 4`, so `mid = 2`. `nums[mid] = 3` and `nums[r] = 5`. Since `nums[mid]` is not greater than `nums[r]`, we move `r` to `mid`, which is `2`.\\n\\nIn the next iteration, `l = 0`, `r = 2`, so `mid = 1`. `nums[mid] = 2` and `nums[r] = 3`. Again, `nums[mid]` is not greater than `nums[r]`, so we move `r` to `mid`, which is `1`.\\n\\nIn the final iteration, `l = 0`, `r = 1`, so `mid = 0`. `nums[mid] = 1` and `nums[r] = 2`. `nums[mid]` is not greater than `nums[r]`, so we move `r` to `mid`, which is `0`.\\n\\nNow `l` and `r` both point to `0`, and the loop ends. We return `nums[l]`, which is `1` \\u2014 the minimum element in the array.\\n\\nThis confirms that the code does work for monotonically increasing arrays. It always finds the pivot point where the array is \"rotated\" (which, in the case of a monotonically increasing array, is the first element)."
                    },
                    {
                        "username": "Carry3236",
                        "content": "this fails in case of monotonic array ."
                    }
                ]
            },
            {
                "id": 1819476,
                "content": [
                    {
                        "username": "inomag",
                        "content": "The main idea is, the element is said to be minimum in the rotated sorted array if the previous element to it is greater than it or there is no previous element(i.e. no rotation). We can do this using Binary search\\n1. Find the mid element i.e. mid = (low+high)/2\\n2. If the (mid+1)th element is less than mid element then return (mid+1)th element\\n3. If the mid element is less than (mid-1)th element then return the mid element\\n4. If the last element is greater than mid element then search in left half\\n5. If the last element is less than mid element then search in right half\\n\\n**Time Complexity: O(logn)**\\n**Space Complexity: O(1)**\\n\\n*Solution is in the comments.*\\n\\n"
                    },
                    {
                        "username": "paawan3000",
                        "content": "ans"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Please, do not post answers in discussions.\\nPeople try to find tips here, not spoilers."
                    },
                    {
                        "username": "cagils",
                        "content": "We only need to compare mid with right one in the binary search. This will automatically handle the edge case of already sorted array.\\n\\n```\\n4 5 6 7 8 9 0 1 2 3\\nl       m         r\\nm > r => l = m + 1\\n4 5 6 7 8 9 0 1 2 3\\n          l   m   r\\nm < r => r = m\\n4 5 6 7 8 9 0 1 2 3\\n          l m r\\nm < r => r = m\\n4 5 6 7 8 9 0 1 2 3\\n          l r\\nm > r => l = m + 1\\n7 8 0 1 2 3 4 5 6\\n            lr\\nr >= l => return l\\n\\n7 8 0 1 2 3 4 5 6\\nl       m       r\\nm < r => r = m\\n7 8 0 1 2 3 4 5 6\\nl m     m\\nm > r => l = m + 1\\n7 8 0 1 2 3 4 5 6\\n    l m r\\nm < l => r = m\\n7 8 0 1 2 3 4 5 6\\n    l r\\nm < r => r = m\\n7 8 0 1 2 3 4 5 6\\n    lr\\nr >= l => return l\\n\\n8 0 1 2 3 4 5 6 7\\nl       m       r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl   m   r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl m r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl r\\nm > r => l = m + 1\\n8 0 1 2 3 4 5 6 7\\n  lr\\nr >=l => return l\\n\\n0 1 2 3 4\\nl   m   r\\nm < r => r = m\\n0 1 2 3 4\\nl m r\\nm < r => r = m\\n0 1 2 3 4\\nl r\\nm < r => r = m\\n0 1 2 3 4\\nlr\\nr >= l => return l\\n```"
                    },
                    {
                        "username": "akshaydusad",
                        "content": "Thanks a lot for this explanation, I was so confused as to why the mid was only being compared to the right."
                    },
                    {
                        "username": "punit_gautam",
                        "content": "return min(nums)"
                    },
                    {
                        "username": "aphamdd",
                        "content": "obviously this is a joke guys"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "OK.\\nNow show it during an interview :)"
                    },
                    {
                        "username": "InvaderTim1",
                        "content": "[@angeldimitrov](/angeldimitrov) I really hate the test cases on this one, they\\'re so small I couldn\\'t even visualize the while loop in action. I had to go make my own tests in VsCode."
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "[@Sarichi](/Sarichi) this solution with Python runs at \\'70% faster\\' than remainder of solutions, at the time of writing this. Sure, binary search may be more optimal in edge cases but it does not seem that the test cases reflect this. The point of leetcode is supposed to be to include test cases that include incredibly complex edge cases."
                    },
                    {
                        "username": "Sarichi",
                        "content": "It must run in O(log N) not an O(N). If we were just asked to solve it, it would have been tagged as easy. They want us to implement using a binary search."
                    },
                    {
                        "username": "GTXFORCE",
                        "content": "My code just: \"sort(nums.begin(),nums.end()); return nums[0]\". It beats 100% in CPP.\\n\\nThe key is when an array is pre-sorted, sort algorithm can almost reach its best case, no longer NlogN !!\\n\\nSame story in problem when they ask you to Merage K sorted array, Instead of using priority queue, just concatenate them and do a fast sort, and that beats 92.26% cpp files. In addition, let say those K array are in extremely bad case, where K is huge, each array only has 1 or 2 elements and the arrays are put into worst order. The performance of concatenating and sorting of course will drop a lot yet so will priority queue, and you need a lot of extra memory to keep your queue alive as well.\\n\\n\\n\\n"
                    },
                    {
                        "username": "bulgarmarc",
                        "content": "[@abzelmes](/abzelmes) it is stated that you should solve it in O(logn) which implies to not sort the list, because sorting the list takes O(nlogn) "
                    },
                    {
                        "username": "kanishk82",
                        "content": "Clearly, fastest sorting algo is O(nlogn) which is greater than a liner search O(n), but for binary search it\\'s O(logn), which is the smallest. So better use a binary search"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@abzelmes](/abzelmes) The problem requires O(log n) time so that already precludes sorting."
                    },
                    {
                        "username": "HitenTandon",
                        "content": "best case sorting time is still O(N) so you\\'re still better of just finding the smallest element linearly"
                    },
                    {
                        "username": "abzelmes",
                        "content": "Obviously this is the best solution, but I found it fun to actually try to do it without sorting. I think they need to add this to the problems requirements. That you shouldn\\'t sort the array.\\nBecause otherwise it would be an easy problem"
                    },
                    {
                        "username": "arnavk09",
                        "content": "This problem in particular is one of those rare cases when the most intuitive solution (that seems like brute force in the beginning) is the one that gives the best answer somehow"
                    },
                    {
                        "username": "faux_hubris",
                        "content": "Use Binary Search to find the largest element i.e. the pivot. The element in the array after the pivot i.e. nums[pivot + 1] is your answer. If mums[nums.Length] > nums[0], then you know it can be considered as a sorted array without rotation. In that case, simply return nums[0]."
                    },
                    {
                        "username": "jayanta1250",
                        "content": "This is not a leetcode medium question if you think. There is nothing to worry about how many times the array is rotated . you have to just find the pivot using binary search. And think in a rotated array pivot is the largest number and next after pivot is the smallest . If the array in not rotated just you have to return the 1st element because that it is the smallest element. Easy thinking. Have a good day best of luck"
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. If array is rotated, it will have two halves : increasing and decreasing. So we can compare mid and mid + 1. If mid > mid + 1, we know this is the tipping point so return mid + 1. \\n\\nThis is because if an array is not rotated, mid > mid + 1 will never occur"
                    },
                    {
                        "username": "jamshidyuldashev7799",
                        "content": "Hi, it is very good.  "
                    },
                    {
                        "username": "tatkal",
                        "content": "Please change the difficulty tag to medium."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Use binary search to find the minimum element in the rotated sorted array. Check if the middle element is smaller than the element before it. If yes, then the minimum element is found. Otherwise, the check if the middle element is smaller than the last element of the array. If yes, then the search is narrowed down to the elements before the middle element. Otherwise, the search is narrowed down to the elements after the middle element. Return the first element of the array as the minimum element, since the first element will not have an element before it."
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(153)Find%20Minimum%20in%20Rotated%20sorted%20Array"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Carry3236](/Carry3236) Actually, the provided solution also works correctly for monotonically increasing arrays (a type of sorted array with no rotations). Let\\'s look at an example:\\n\\nSuppose we have the array `nums = [1,2,3,4,5]`.\\n\\nAt the beginning, `l = 0`, `r = 4`, so `mid = 2`. `nums[mid] = 3` and `nums[r] = 5`. Since `nums[mid]` is not greater than `nums[r]`, we move `r` to `mid`, which is `2`.\\n\\nIn the next iteration, `l = 0`, `r = 2`, so `mid = 1`. `nums[mid] = 2` and `nums[r] = 3`. Again, `nums[mid]` is not greater than `nums[r]`, so we move `r` to `mid`, which is `1`.\\n\\nIn the final iteration, `l = 0`, `r = 1`, so `mid = 0`. `nums[mid] = 1` and `nums[r] = 2`. `nums[mid]` is not greater than `nums[r]`, so we move `r` to `mid`, which is `0`.\\n\\nNow `l` and `r` both point to `0`, and the loop ends. We return `nums[l]`, which is `1` \\u2014 the minimum element in the array.\\n\\nThis confirms that the code does work for monotonically increasing arrays. It always finds the pivot point where the array is \"rotated\" (which, in the case of a monotonically increasing array, is the first element)."
                    },
                    {
                        "username": "Carry3236",
                        "content": "this fails in case of monotonic array ."
                    }
                ]
            },
            {
                "id": 1575355,
                "content": [
                    {
                        "username": "inomag",
                        "content": "The main idea is, the element is said to be minimum in the rotated sorted array if the previous element to it is greater than it or there is no previous element(i.e. no rotation). We can do this using Binary search\\n1. Find the mid element i.e. mid = (low+high)/2\\n2. If the (mid+1)th element is less than mid element then return (mid+1)th element\\n3. If the mid element is less than (mid-1)th element then return the mid element\\n4. If the last element is greater than mid element then search in left half\\n5. If the last element is less than mid element then search in right half\\n\\n**Time Complexity: O(logn)**\\n**Space Complexity: O(1)**\\n\\n*Solution is in the comments.*\\n\\n"
                    },
                    {
                        "username": "paawan3000",
                        "content": "ans"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Please, do not post answers in discussions.\\nPeople try to find tips here, not spoilers."
                    },
                    {
                        "username": "cagils",
                        "content": "We only need to compare mid with right one in the binary search. This will automatically handle the edge case of already sorted array.\\n\\n```\\n4 5 6 7 8 9 0 1 2 3\\nl       m         r\\nm > r => l = m + 1\\n4 5 6 7 8 9 0 1 2 3\\n          l   m   r\\nm < r => r = m\\n4 5 6 7 8 9 0 1 2 3\\n          l m r\\nm < r => r = m\\n4 5 6 7 8 9 0 1 2 3\\n          l r\\nm > r => l = m + 1\\n7 8 0 1 2 3 4 5 6\\n            lr\\nr >= l => return l\\n\\n7 8 0 1 2 3 4 5 6\\nl       m       r\\nm < r => r = m\\n7 8 0 1 2 3 4 5 6\\nl m     m\\nm > r => l = m + 1\\n7 8 0 1 2 3 4 5 6\\n    l m r\\nm < l => r = m\\n7 8 0 1 2 3 4 5 6\\n    l r\\nm < r => r = m\\n7 8 0 1 2 3 4 5 6\\n    lr\\nr >= l => return l\\n\\n8 0 1 2 3 4 5 6 7\\nl       m       r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl   m   r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl m r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl r\\nm > r => l = m + 1\\n8 0 1 2 3 4 5 6 7\\n  lr\\nr >=l => return l\\n\\n0 1 2 3 4\\nl   m   r\\nm < r => r = m\\n0 1 2 3 4\\nl m r\\nm < r => r = m\\n0 1 2 3 4\\nl r\\nm < r => r = m\\n0 1 2 3 4\\nlr\\nr >= l => return l\\n```"
                    },
                    {
                        "username": "akshaydusad",
                        "content": "Thanks a lot for this explanation, I was so confused as to why the mid was only being compared to the right."
                    },
                    {
                        "username": "punit_gautam",
                        "content": "return min(nums)"
                    },
                    {
                        "username": "aphamdd",
                        "content": "obviously this is a joke guys"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "OK.\\nNow show it during an interview :)"
                    },
                    {
                        "username": "InvaderTim1",
                        "content": "[@angeldimitrov](/angeldimitrov) I really hate the test cases on this one, they\\'re so small I couldn\\'t even visualize the while loop in action. I had to go make my own tests in VsCode."
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "[@Sarichi](/Sarichi) this solution with Python runs at \\'70% faster\\' than remainder of solutions, at the time of writing this. Sure, binary search may be more optimal in edge cases but it does not seem that the test cases reflect this. The point of leetcode is supposed to be to include test cases that include incredibly complex edge cases."
                    },
                    {
                        "username": "Sarichi",
                        "content": "It must run in O(log N) not an O(N). If we were just asked to solve it, it would have been tagged as easy. They want us to implement using a binary search."
                    },
                    {
                        "username": "GTXFORCE",
                        "content": "My code just: \"sort(nums.begin(),nums.end()); return nums[0]\". It beats 100% in CPP.\\n\\nThe key is when an array is pre-sorted, sort algorithm can almost reach its best case, no longer NlogN !!\\n\\nSame story in problem when they ask you to Merage K sorted array, Instead of using priority queue, just concatenate them and do a fast sort, and that beats 92.26% cpp files. In addition, let say those K array are in extremely bad case, where K is huge, each array only has 1 or 2 elements and the arrays are put into worst order. The performance of concatenating and sorting of course will drop a lot yet so will priority queue, and you need a lot of extra memory to keep your queue alive as well.\\n\\n\\n\\n"
                    },
                    {
                        "username": "bulgarmarc",
                        "content": "[@abzelmes](/abzelmes) it is stated that you should solve it in O(logn) which implies to not sort the list, because sorting the list takes O(nlogn) "
                    },
                    {
                        "username": "kanishk82",
                        "content": "Clearly, fastest sorting algo is O(nlogn) which is greater than a liner search O(n), but for binary search it\\'s O(logn), which is the smallest. So better use a binary search"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@abzelmes](/abzelmes) The problem requires O(log n) time so that already precludes sorting."
                    },
                    {
                        "username": "HitenTandon",
                        "content": "best case sorting time is still O(N) so you\\'re still better of just finding the smallest element linearly"
                    },
                    {
                        "username": "abzelmes",
                        "content": "Obviously this is the best solution, but I found it fun to actually try to do it without sorting. I think they need to add this to the problems requirements. That you shouldn\\'t sort the array.\\nBecause otherwise it would be an easy problem"
                    },
                    {
                        "username": "arnavk09",
                        "content": "This problem in particular is one of those rare cases when the most intuitive solution (that seems like brute force in the beginning) is the one that gives the best answer somehow"
                    },
                    {
                        "username": "faux_hubris",
                        "content": "Use Binary Search to find the largest element i.e. the pivot. The element in the array after the pivot i.e. nums[pivot + 1] is your answer. If mums[nums.Length] > nums[0], then you know it can be considered as a sorted array without rotation. In that case, simply return nums[0]."
                    },
                    {
                        "username": "jayanta1250",
                        "content": "This is not a leetcode medium question if you think. There is nothing to worry about how many times the array is rotated . you have to just find the pivot using binary search. And think in a rotated array pivot is the largest number and next after pivot is the smallest . If the array in not rotated just you have to return the 1st element because that it is the smallest element. Easy thinking. Have a good day best of luck"
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. If array is rotated, it will have two halves : increasing and decreasing. So we can compare mid and mid + 1. If mid > mid + 1, we know this is the tipping point so return mid + 1. \\n\\nThis is because if an array is not rotated, mid > mid + 1 will never occur"
                    },
                    {
                        "username": "jamshidyuldashev7799",
                        "content": "Hi, it is very good.  "
                    },
                    {
                        "username": "tatkal",
                        "content": "Please change the difficulty tag to medium."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Use binary search to find the minimum element in the rotated sorted array. Check if the middle element is smaller than the element before it. If yes, then the minimum element is found. Otherwise, the check if the middle element is smaller than the last element of the array. If yes, then the search is narrowed down to the elements before the middle element. Otherwise, the search is narrowed down to the elements after the middle element. Return the first element of the array as the minimum element, since the first element will not have an element before it."
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(153)Find%20Minimum%20in%20Rotated%20sorted%20Array"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Carry3236](/Carry3236) Actually, the provided solution also works correctly for monotonically increasing arrays (a type of sorted array with no rotations). Let\\'s look at an example:\\n\\nSuppose we have the array `nums = [1,2,3,4,5]`.\\n\\nAt the beginning, `l = 0`, `r = 4`, so `mid = 2`. `nums[mid] = 3` and `nums[r] = 5`. Since `nums[mid]` is not greater than `nums[r]`, we move `r` to `mid`, which is `2`.\\n\\nIn the next iteration, `l = 0`, `r = 2`, so `mid = 1`. `nums[mid] = 2` and `nums[r] = 3`. Again, `nums[mid]` is not greater than `nums[r]`, so we move `r` to `mid`, which is `1`.\\n\\nIn the final iteration, `l = 0`, `r = 1`, so `mid = 0`. `nums[mid] = 1` and `nums[r] = 2`. `nums[mid]` is not greater than `nums[r]`, so we move `r` to `mid`, which is `0`.\\n\\nNow `l` and `r` both point to `0`, and the loop ends. We return `nums[l]`, which is `1` \\u2014 the minimum element in the array.\\n\\nThis confirms that the code does work for monotonically increasing arrays. It always finds the pivot point where the array is \"rotated\" (which, in the case of a monotonically increasing array, is the first element)."
                    },
                    {
                        "username": "Carry3236",
                        "content": "this fails in case of monotonic array ."
                    }
                ]
            },
            {
                "id": 1572020,
                "content": [
                    {
                        "username": "inomag",
                        "content": "The main idea is, the element is said to be minimum in the rotated sorted array if the previous element to it is greater than it or there is no previous element(i.e. no rotation). We can do this using Binary search\\n1. Find the mid element i.e. mid = (low+high)/2\\n2. If the (mid+1)th element is less than mid element then return (mid+1)th element\\n3. If the mid element is less than (mid-1)th element then return the mid element\\n4. If the last element is greater than mid element then search in left half\\n5. If the last element is less than mid element then search in right half\\n\\n**Time Complexity: O(logn)**\\n**Space Complexity: O(1)**\\n\\n*Solution is in the comments.*\\n\\n"
                    },
                    {
                        "username": "paawan3000",
                        "content": "ans"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Please, do not post answers in discussions.\\nPeople try to find tips here, not spoilers."
                    },
                    {
                        "username": "cagils",
                        "content": "We only need to compare mid with right one in the binary search. This will automatically handle the edge case of already sorted array.\\n\\n```\\n4 5 6 7 8 9 0 1 2 3\\nl       m         r\\nm > r => l = m + 1\\n4 5 6 7 8 9 0 1 2 3\\n          l   m   r\\nm < r => r = m\\n4 5 6 7 8 9 0 1 2 3\\n          l m r\\nm < r => r = m\\n4 5 6 7 8 9 0 1 2 3\\n          l r\\nm > r => l = m + 1\\n7 8 0 1 2 3 4 5 6\\n            lr\\nr >= l => return l\\n\\n7 8 0 1 2 3 4 5 6\\nl       m       r\\nm < r => r = m\\n7 8 0 1 2 3 4 5 6\\nl m     m\\nm > r => l = m + 1\\n7 8 0 1 2 3 4 5 6\\n    l m r\\nm < l => r = m\\n7 8 0 1 2 3 4 5 6\\n    l r\\nm < r => r = m\\n7 8 0 1 2 3 4 5 6\\n    lr\\nr >= l => return l\\n\\n8 0 1 2 3 4 5 6 7\\nl       m       r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl   m   r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl m r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl r\\nm > r => l = m + 1\\n8 0 1 2 3 4 5 6 7\\n  lr\\nr >=l => return l\\n\\n0 1 2 3 4\\nl   m   r\\nm < r => r = m\\n0 1 2 3 4\\nl m r\\nm < r => r = m\\n0 1 2 3 4\\nl r\\nm < r => r = m\\n0 1 2 3 4\\nlr\\nr >= l => return l\\n```"
                    },
                    {
                        "username": "akshaydusad",
                        "content": "Thanks a lot for this explanation, I was so confused as to why the mid was only being compared to the right."
                    },
                    {
                        "username": "punit_gautam",
                        "content": "return min(nums)"
                    },
                    {
                        "username": "aphamdd",
                        "content": "obviously this is a joke guys"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "OK.\\nNow show it during an interview :)"
                    },
                    {
                        "username": "InvaderTim1",
                        "content": "[@angeldimitrov](/angeldimitrov) I really hate the test cases on this one, they\\'re so small I couldn\\'t even visualize the while loop in action. I had to go make my own tests in VsCode."
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "[@Sarichi](/Sarichi) this solution with Python runs at \\'70% faster\\' than remainder of solutions, at the time of writing this. Sure, binary search may be more optimal in edge cases but it does not seem that the test cases reflect this. The point of leetcode is supposed to be to include test cases that include incredibly complex edge cases."
                    },
                    {
                        "username": "Sarichi",
                        "content": "It must run in O(log N) not an O(N). If we were just asked to solve it, it would have been tagged as easy. They want us to implement using a binary search."
                    },
                    {
                        "username": "GTXFORCE",
                        "content": "My code just: \"sort(nums.begin(),nums.end()); return nums[0]\". It beats 100% in CPP.\\n\\nThe key is when an array is pre-sorted, sort algorithm can almost reach its best case, no longer NlogN !!\\n\\nSame story in problem when they ask you to Merage K sorted array, Instead of using priority queue, just concatenate them and do a fast sort, and that beats 92.26% cpp files. In addition, let say those K array are in extremely bad case, where K is huge, each array only has 1 or 2 elements and the arrays are put into worst order. The performance of concatenating and sorting of course will drop a lot yet so will priority queue, and you need a lot of extra memory to keep your queue alive as well.\\n\\n\\n\\n"
                    },
                    {
                        "username": "bulgarmarc",
                        "content": "[@abzelmes](/abzelmes) it is stated that you should solve it in O(logn) which implies to not sort the list, because sorting the list takes O(nlogn) "
                    },
                    {
                        "username": "kanishk82",
                        "content": "Clearly, fastest sorting algo is O(nlogn) which is greater than a liner search O(n), but for binary search it\\'s O(logn), which is the smallest. So better use a binary search"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@abzelmes](/abzelmes) The problem requires O(log n) time so that already precludes sorting."
                    },
                    {
                        "username": "HitenTandon",
                        "content": "best case sorting time is still O(N) so you\\'re still better of just finding the smallest element linearly"
                    },
                    {
                        "username": "abzelmes",
                        "content": "Obviously this is the best solution, but I found it fun to actually try to do it without sorting. I think they need to add this to the problems requirements. That you shouldn\\'t sort the array.\\nBecause otherwise it would be an easy problem"
                    },
                    {
                        "username": "arnavk09",
                        "content": "This problem in particular is one of those rare cases when the most intuitive solution (that seems like brute force in the beginning) is the one that gives the best answer somehow"
                    },
                    {
                        "username": "faux_hubris",
                        "content": "Use Binary Search to find the largest element i.e. the pivot. The element in the array after the pivot i.e. nums[pivot + 1] is your answer. If mums[nums.Length] > nums[0], then you know it can be considered as a sorted array without rotation. In that case, simply return nums[0]."
                    },
                    {
                        "username": "jayanta1250",
                        "content": "This is not a leetcode medium question if you think. There is nothing to worry about how many times the array is rotated . you have to just find the pivot using binary search. And think in a rotated array pivot is the largest number and next after pivot is the smallest . If the array in not rotated just you have to return the 1st element because that it is the smallest element. Easy thinking. Have a good day best of luck"
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. If array is rotated, it will have two halves : increasing and decreasing. So we can compare mid and mid + 1. If mid > mid + 1, we know this is the tipping point so return mid + 1. \\n\\nThis is because if an array is not rotated, mid > mid + 1 will never occur"
                    },
                    {
                        "username": "jamshidyuldashev7799",
                        "content": "Hi, it is very good.  "
                    },
                    {
                        "username": "tatkal",
                        "content": "Please change the difficulty tag to medium."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Use binary search to find the minimum element in the rotated sorted array. Check if the middle element is smaller than the element before it. If yes, then the minimum element is found. Otherwise, the check if the middle element is smaller than the last element of the array. If yes, then the search is narrowed down to the elements before the middle element. Otherwise, the search is narrowed down to the elements after the middle element. Return the first element of the array as the minimum element, since the first element will not have an element before it."
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(153)Find%20Minimum%20in%20Rotated%20sorted%20Array"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Carry3236](/Carry3236) Actually, the provided solution also works correctly for monotonically increasing arrays (a type of sorted array with no rotations). Let\\'s look at an example:\\n\\nSuppose we have the array `nums = [1,2,3,4,5]`.\\n\\nAt the beginning, `l = 0`, `r = 4`, so `mid = 2`. `nums[mid] = 3` and `nums[r] = 5`. Since `nums[mid]` is not greater than `nums[r]`, we move `r` to `mid`, which is `2`.\\n\\nIn the next iteration, `l = 0`, `r = 2`, so `mid = 1`. `nums[mid] = 2` and `nums[r] = 3`. Again, `nums[mid]` is not greater than `nums[r]`, so we move `r` to `mid`, which is `1`.\\n\\nIn the final iteration, `l = 0`, `r = 1`, so `mid = 0`. `nums[mid] = 1` and `nums[r] = 2`. `nums[mid]` is not greater than `nums[r]`, so we move `r` to `mid`, which is `0`.\\n\\nNow `l` and `r` both point to `0`, and the loop ends. We return `nums[l]`, which is `1` \\u2014 the minimum element in the array.\\n\\nThis confirms that the code does work for monotonically increasing arrays. It always finds the pivot point where the array is \"rotated\" (which, in the case of a monotonically increasing array, is the first element)."
                    },
                    {
                        "username": "Carry3236",
                        "content": "this fails in case of monotonic array ."
                    }
                ]
            },
            {
                "id": 1676329,
                "content": [
                    {
                        "username": "inomag",
                        "content": "The main idea is, the element is said to be minimum in the rotated sorted array if the previous element to it is greater than it or there is no previous element(i.e. no rotation). We can do this using Binary search\\n1. Find the mid element i.e. mid = (low+high)/2\\n2. If the (mid+1)th element is less than mid element then return (mid+1)th element\\n3. If the mid element is less than (mid-1)th element then return the mid element\\n4. If the last element is greater than mid element then search in left half\\n5. If the last element is less than mid element then search in right half\\n\\n**Time Complexity: O(logn)**\\n**Space Complexity: O(1)**\\n\\n*Solution is in the comments.*\\n\\n"
                    },
                    {
                        "username": "paawan3000",
                        "content": "ans"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Please, do not post answers in discussions.\\nPeople try to find tips here, not spoilers."
                    },
                    {
                        "username": "cagils",
                        "content": "We only need to compare mid with right one in the binary search. This will automatically handle the edge case of already sorted array.\\n\\n```\\n4 5 6 7 8 9 0 1 2 3\\nl       m         r\\nm > r => l = m + 1\\n4 5 6 7 8 9 0 1 2 3\\n          l   m   r\\nm < r => r = m\\n4 5 6 7 8 9 0 1 2 3\\n          l m r\\nm < r => r = m\\n4 5 6 7 8 9 0 1 2 3\\n          l r\\nm > r => l = m + 1\\n7 8 0 1 2 3 4 5 6\\n            lr\\nr >= l => return l\\n\\n7 8 0 1 2 3 4 5 6\\nl       m       r\\nm < r => r = m\\n7 8 0 1 2 3 4 5 6\\nl m     m\\nm > r => l = m + 1\\n7 8 0 1 2 3 4 5 6\\n    l m r\\nm < l => r = m\\n7 8 0 1 2 3 4 5 6\\n    l r\\nm < r => r = m\\n7 8 0 1 2 3 4 5 6\\n    lr\\nr >= l => return l\\n\\n8 0 1 2 3 4 5 6 7\\nl       m       r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl   m   r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl m r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl r\\nm > r => l = m + 1\\n8 0 1 2 3 4 5 6 7\\n  lr\\nr >=l => return l\\n\\n0 1 2 3 4\\nl   m   r\\nm < r => r = m\\n0 1 2 3 4\\nl m r\\nm < r => r = m\\n0 1 2 3 4\\nl r\\nm < r => r = m\\n0 1 2 3 4\\nlr\\nr >= l => return l\\n```"
                    },
                    {
                        "username": "akshaydusad",
                        "content": "Thanks a lot for this explanation, I was so confused as to why the mid was only being compared to the right."
                    },
                    {
                        "username": "punit_gautam",
                        "content": "return min(nums)"
                    },
                    {
                        "username": "aphamdd",
                        "content": "obviously this is a joke guys"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "OK.\\nNow show it during an interview :)"
                    },
                    {
                        "username": "InvaderTim1",
                        "content": "[@angeldimitrov](/angeldimitrov) I really hate the test cases on this one, they\\'re so small I couldn\\'t even visualize the while loop in action. I had to go make my own tests in VsCode."
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "[@Sarichi](/Sarichi) this solution with Python runs at \\'70% faster\\' than remainder of solutions, at the time of writing this. Sure, binary search may be more optimal in edge cases but it does not seem that the test cases reflect this. The point of leetcode is supposed to be to include test cases that include incredibly complex edge cases."
                    },
                    {
                        "username": "Sarichi",
                        "content": "It must run in O(log N) not an O(N). If we were just asked to solve it, it would have been tagged as easy. They want us to implement using a binary search."
                    },
                    {
                        "username": "GTXFORCE",
                        "content": "My code just: \"sort(nums.begin(),nums.end()); return nums[0]\". It beats 100% in CPP.\\n\\nThe key is when an array is pre-sorted, sort algorithm can almost reach its best case, no longer NlogN !!\\n\\nSame story in problem when they ask you to Merage K sorted array, Instead of using priority queue, just concatenate them and do a fast sort, and that beats 92.26% cpp files. In addition, let say those K array are in extremely bad case, where K is huge, each array only has 1 or 2 elements and the arrays are put into worst order. The performance of concatenating and sorting of course will drop a lot yet so will priority queue, and you need a lot of extra memory to keep your queue alive as well.\\n\\n\\n\\n"
                    },
                    {
                        "username": "bulgarmarc",
                        "content": "[@abzelmes](/abzelmes) it is stated that you should solve it in O(logn) which implies to not sort the list, because sorting the list takes O(nlogn) "
                    },
                    {
                        "username": "kanishk82",
                        "content": "Clearly, fastest sorting algo is O(nlogn) which is greater than a liner search O(n), but for binary search it\\'s O(logn), which is the smallest. So better use a binary search"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@abzelmes](/abzelmes) The problem requires O(log n) time so that already precludes sorting."
                    },
                    {
                        "username": "HitenTandon",
                        "content": "best case sorting time is still O(N) so you\\'re still better of just finding the smallest element linearly"
                    },
                    {
                        "username": "abzelmes",
                        "content": "Obviously this is the best solution, but I found it fun to actually try to do it without sorting. I think they need to add this to the problems requirements. That you shouldn\\'t sort the array.\\nBecause otherwise it would be an easy problem"
                    },
                    {
                        "username": "arnavk09",
                        "content": "This problem in particular is one of those rare cases when the most intuitive solution (that seems like brute force in the beginning) is the one that gives the best answer somehow"
                    },
                    {
                        "username": "faux_hubris",
                        "content": "Use Binary Search to find the largest element i.e. the pivot. The element in the array after the pivot i.e. nums[pivot + 1] is your answer. If mums[nums.Length] > nums[0], then you know it can be considered as a sorted array without rotation. In that case, simply return nums[0]."
                    },
                    {
                        "username": "jayanta1250",
                        "content": "This is not a leetcode medium question if you think. There is nothing to worry about how many times the array is rotated . you have to just find the pivot using binary search. And think in a rotated array pivot is the largest number and next after pivot is the smallest . If the array in not rotated just you have to return the 1st element because that it is the smallest element. Easy thinking. Have a good day best of luck"
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. If array is rotated, it will have two halves : increasing and decreasing. So we can compare mid and mid + 1. If mid > mid + 1, we know this is the tipping point so return mid + 1. \\n\\nThis is because if an array is not rotated, mid > mid + 1 will never occur"
                    },
                    {
                        "username": "jamshidyuldashev7799",
                        "content": "Hi, it is very good.  "
                    },
                    {
                        "username": "tatkal",
                        "content": "Please change the difficulty tag to medium."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Use binary search to find the minimum element in the rotated sorted array. Check if the middle element is smaller than the element before it. If yes, then the minimum element is found. Otherwise, the check if the middle element is smaller than the last element of the array. If yes, then the search is narrowed down to the elements before the middle element. Otherwise, the search is narrowed down to the elements after the middle element. Return the first element of the array as the minimum element, since the first element will not have an element before it."
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(153)Find%20Minimum%20in%20Rotated%20sorted%20Array"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Carry3236](/Carry3236) Actually, the provided solution also works correctly for monotonically increasing arrays (a type of sorted array with no rotations). Let\\'s look at an example:\\n\\nSuppose we have the array `nums = [1,2,3,4,5]`.\\n\\nAt the beginning, `l = 0`, `r = 4`, so `mid = 2`. `nums[mid] = 3` and `nums[r] = 5`. Since `nums[mid]` is not greater than `nums[r]`, we move `r` to `mid`, which is `2`.\\n\\nIn the next iteration, `l = 0`, `r = 2`, so `mid = 1`. `nums[mid] = 2` and `nums[r] = 3`. Again, `nums[mid]` is not greater than `nums[r]`, so we move `r` to `mid`, which is `1`.\\n\\nIn the final iteration, `l = 0`, `r = 1`, so `mid = 0`. `nums[mid] = 1` and `nums[r] = 2`. `nums[mid]` is not greater than `nums[r]`, so we move `r` to `mid`, which is `0`.\\n\\nNow `l` and `r` both point to `0`, and the loop ends. We return `nums[l]`, which is `1` \\u2014 the minimum element in the array.\\n\\nThis confirms that the code does work for monotonically increasing arrays. It always finds the pivot point where the array is \"rotated\" (which, in the case of a monotonically increasing array, is the first element)."
                    },
                    {
                        "username": "Carry3236",
                        "content": "this fails in case of monotonic array ."
                    }
                ]
            },
            {
                "id": 1896652,
                "content": [
                    {
                        "username": "inomag",
                        "content": "The main idea is, the element is said to be minimum in the rotated sorted array if the previous element to it is greater than it or there is no previous element(i.e. no rotation). We can do this using Binary search\\n1. Find the mid element i.e. mid = (low+high)/2\\n2. If the (mid+1)th element is less than mid element then return (mid+1)th element\\n3. If the mid element is less than (mid-1)th element then return the mid element\\n4. If the last element is greater than mid element then search in left half\\n5. If the last element is less than mid element then search in right half\\n\\n**Time Complexity: O(logn)**\\n**Space Complexity: O(1)**\\n\\n*Solution is in the comments.*\\n\\n"
                    },
                    {
                        "username": "paawan3000",
                        "content": "ans"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Please, do not post answers in discussions.\\nPeople try to find tips here, not spoilers."
                    },
                    {
                        "username": "cagils",
                        "content": "We only need to compare mid with right one in the binary search. This will automatically handle the edge case of already sorted array.\\n\\n```\\n4 5 6 7 8 9 0 1 2 3\\nl       m         r\\nm > r => l = m + 1\\n4 5 6 7 8 9 0 1 2 3\\n          l   m   r\\nm < r => r = m\\n4 5 6 7 8 9 0 1 2 3\\n          l m r\\nm < r => r = m\\n4 5 6 7 8 9 0 1 2 3\\n          l r\\nm > r => l = m + 1\\n7 8 0 1 2 3 4 5 6\\n            lr\\nr >= l => return l\\n\\n7 8 0 1 2 3 4 5 6\\nl       m       r\\nm < r => r = m\\n7 8 0 1 2 3 4 5 6\\nl m     m\\nm > r => l = m + 1\\n7 8 0 1 2 3 4 5 6\\n    l m r\\nm < l => r = m\\n7 8 0 1 2 3 4 5 6\\n    l r\\nm < r => r = m\\n7 8 0 1 2 3 4 5 6\\n    lr\\nr >= l => return l\\n\\n8 0 1 2 3 4 5 6 7\\nl       m       r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl   m   r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl m r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl r\\nm > r => l = m + 1\\n8 0 1 2 3 4 5 6 7\\n  lr\\nr >=l => return l\\n\\n0 1 2 3 4\\nl   m   r\\nm < r => r = m\\n0 1 2 3 4\\nl m r\\nm < r => r = m\\n0 1 2 3 4\\nl r\\nm < r => r = m\\n0 1 2 3 4\\nlr\\nr >= l => return l\\n```"
                    },
                    {
                        "username": "akshaydusad",
                        "content": "Thanks a lot for this explanation, I was so confused as to why the mid was only being compared to the right."
                    },
                    {
                        "username": "punit_gautam",
                        "content": "return min(nums)"
                    },
                    {
                        "username": "aphamdd",
                        "content": "obviously this is a joke guys"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "OK.\\nNow show it during an interview :)"
                    },
                    {
                        "username": "InvaderTim1",
                        "content": "[@angeldimitrov](/angeldimitrov) I really hate the test cases on this one, they\\'re so small I couldn\\'t even visualize the while loop in action. I had to go make my own tests in VsCode."
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "[@Sarichi](/Sarichi) this solution with Python runs at \\'70% faster\\' than remainder of solutions, at the time of writing this. Sure, binary search may be more optimal in edge cases but it does not seem that the test cases reflect this. The point of leetcode is supposed to be to include test cases that include incredibly complex edge cases."
                    },
                    {
                        "username": "Sarichi",
                        "content": "It must run in O(log N) not an O(N). If we were just asked to solve it, it would have been tagged as easy. They want us to implement using a binary search."
                    },
                    {
                        "username": "GTXFORCE",
                        "content": "My code just: \"sort(nums.begin(),nums.end()); return nums[0]\". It beats 100% in CPP.\\n\\nThe key is when an array is pre-sorted, sort algorithm can almost reach its best case, no longer NlogN !!\\n\\nSame story in problem when they ask you to Merage K sorted array, Instead of using priority queue, just concatenate them and do a fast sort, and that beats 92.26% cpp files. In addition, let say those K array are in extremely bad case, where K is huge, each array only has 1 or 2 elements and the arrays are put into worst order. The performance of concatenating and sorting of course will drop a lot yet so will priority queue, and you need a lot of extra memory to keep your queue alive as well.\\n\\n\\n\\n"
                    },
                    {
                        "username": "bulgarmarc",
                        "content": "[@abzelmes](/abzelmes) it is stated that you should solve it in O(logn) which implies to not sort the list, because sorting the list takes O(nlogn) "
                    },
                    {
                        "username": "kanishk82",
                        "content": "Clearly, fastest sorting algo is O(nlogn) which is greater than a liner search O(n), but for binary search it\\'s O(logn), which is the smallest. So better use a binary search"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@abzelmes](/abzelmes) The problem requires O(log n) time so that already precludes sorting."
                    },
                    {
                        "username": "HitenTandon",
                        "content": "best case sorting time is still O(N) so you\\'re still better of just finding the smallest element linearly"
                    },
                    {
                        "username": "abzelmes",
                        "content": "Obviously this is the best solution, but I found it fun to actually try to do it without sorting. I think they need to add this to the problems requirements. That you shouldn\\'t sort the array.\\nBecause otherwise it would be an easy problem"
                    },
                    {
                        "username": "arnavk09",
                        "content": "This problem in particular is one of those rare cases when the most intuitive solution (that seems like brute force in the beginning) is the one that gives the best answer somehow"
                    },
                    {
                        "username": "faux_hubris",
                        "content": "Use Binary Search to find the largest element i.e. the pivot. The element in the array after the pivot i.e. nums[pivot + 1] is your answer. If mums[nums.Length] > nums[0], then you know it can be considered as a sorted array without rotation. In that case, simply return nums[0]."
                    },
                    {
                        "username": "jayanta1250",
                        "content": "This is not a leetcode medium question if you think. There is nothing to worry about how many times the array is rotated . you have to just find the pivot using binary search. And think in a rotated array pivot is the largest number and next after pivot is the smallest . If the array in not rotated just you have to return the 1st element because that it is the smallest element. Easy thinking. Have a good day best of luck"
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. If array is rotated, it will have two halves : increasing and decreasing. So we can compare mid and mid + 1. If mid > mid + 1, we know this is the tipping point so return mid + 1. \\n\\nThis is because if an array is not rotated, mid > mid + 1 will never occur"
                    },
                    {
                        "username": "jamshidyuldashev7799",
                        "content": "Hi, it is very good.  "
                    },
                    {
                        "username": "tatkal",
                        "content": "Please change the difficulty tag to medium."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Use binary search to find the minimum element in the rotated sorted array. Check if the middle element is smaller than the element before it. If yes, then the minimum element is found. Otherwise, the check if the middle element is smaller than the last element of the array. If yes, then the search is narrowed down to the elements before the middle element. Otherwise, the search is narrowed down to the elements after the middle element. Return the first element of the array as the minimum element, since the first element will not have an element before it."
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(153)Find%20Minimum%20in%20Rotated%20sorted%20Array"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Carry3236](/Carry3236) Actually, the provided solution also works correctly for monotonically increasing arrays (a type of sorted array with no rotations). Let\\'s look at an example:\\n\\nSuppose we have the array `nums = [1,2,3,4,5]`.\\n\\nAt the beginning, `l = 0`, `r = 4`, so `mid = 2`. `nums[mid] = 3` and `nums[r] = 5`. Since `nums[mid]` is not greater than `nums[r]`, we move `r` to `mid`, which is `2`.\\n\\nIn the next iteration, `l = 0`, `r = 2`, so `mid = 1`. `nums[mid] = 2` and `nums[r] = 3`. Again, `nums[mid]` is not greater than `nums[r]`, so we move `r` to `mid`, which is `1`.\\n\\nIn the final iteration, `l = 0`, `r = 1`, so `mid = 0`. `nums[mid] = 1` and `nums[r] = 2`. `nums[mid]` is not greater than `nums[r]`, so we move `r` to `mid`, which is `0`.\\n\\nNow `l` and `r` both point to `0`, and the loop ends. We return `nums[l]`, which is `1` \\u2014 the minimum element in the array.\\n\\nThis confirms that the code does work for monotonically increasing arrays. It always finds the pivot point where the array is \"rotated\" (which, in the case of a monotonically increasing array, is the first element)."
                    },
                    {
                        "username": "Carry3236",
                        "content": "this fails in case of monotonic array ."
                    }
                ]
            },
            {
                "id": 1574706,
                "content": [
                    {
                        "username": "inomag",
                        "content": "The main idea is, the element is said to be minimum in the rotated sorted array if the previous element to it is greater than it or there is no previous element(i.e. no rotation). We can do this using Binary search\\n1. Find the mid element i.e. mid = (low+high)/2\\n2. If the (mid+1)th element is less than mid element then return (mid+1)th element\\n3. If the mid element is less than (mid-1)th element then return the mid element\\n4. If the last element is greater than mid element then search in left half\\n5. If the last element is less than mid element then search in right half\\n\\n**Time Complexity: O(logn)**\\n**Space Complexity: O(1)**\\n\\n*Solution is in the comments.*\\n\\n"
                    },
                    {
                        "username": "paawan3000",
                        "content": "ans"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Please, do not post answers in discussions.\\nPeople try to find tips here, not spoilers."
                    },
                    {
                        "username": "cagils",
                        "content": "We only need to compare mid with right one in the binary search. This will automatically handle the edge case of already sorted array.\\n\\n```\\n4 5 6 7 8 9 0 1 2 3\\nl       m         r\\nm > r => l = m + 1\\n4 5 6 7 8 9 0 1 2 3\\n          l   m   r\\nm < r => r = m\\n4 5 6 7 8 9 0 1 2 3\\n          l m r\\nm < r => r = m\\n4 5 6 7 8 9 0 1 2 3\\n          l r\\nm > r => l = m + 1\\n7 8 0 1 2 3 4 5 6\\n            lr\\nr >= l => return l\\n\\n7 8 0 1 2 3 4 5 6\\nl       m       r\\nm < r => r = m\\n7 8 0 1 2 3 4 5 6\\nl m     m\\nm > r => l = m + 1\\n7 8 0 1 2 3 4 5 6\\n    l m r\\nm < l => r = m\\n7 8 0 1 2 3 4 5 6\\n    l r\\nm < r => r = m\\n7 8 0 1 2 3 4 5 6\\n    lr\\nr >= l => return l\\n\\n8 0 1 2 3 4 5 6 7\\nl       m       r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl   m   r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl m r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl r\\nm > r => l = m + 1\\n8 0 1 2 3 4 5 6 7\\n  lr\\nr >=l => return l\\n\\n0 1 2 3 4\\nl   m   r\\nm < r => r = m\\n0 1 2 3 4\\nl m r\\nm < r => r = m\\n0 1 2 3 4\\nl r\\nm < r => r = m\\n0 1 2 3 4\\nlr\\nr >= l => return l\\n```"
                    },
                    {
                        "username": "akshaydusad",
                        "content": "Thanks a lot for this explanation, I was so confused as to why the mid was only being compared to the right."
                    },
                    {
                        "username": "punit_gautam",
                        "content": "return min(nums)"
                    },
                    {
                        "username": "aphamdd",
                        "content": "obviously this is a joke guys"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "OK.\\nNow show it during an interview :)"
                    },
                    {
                        "username": "InvaderTim1",
                        "content": "[@angeldimitrov](/angeldimitrov) I really hate the test cases on this one, they\\'re so small I couldn\\'t even visualize the while loop in action. I had to go make my own tests in VsCode."
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "[@Sarichi](/Sarichi) this solution with Python runs at \\'70% faster\\' than remainder of solutions, at the time of writing this. Sure, binary search may be more optimal in edge cases but it does not seem that the test cases reflect this. The point of leetcode is supposed to be to include test cases that include incredibly complex edge cases."
                    },
                    {
                        "username": "Sarichi",
                        "content": "It must run in O(log N) not an O(N). If we were just asked to solve it, it would have been tagged as easy. They want us to implement using a binary search."
                    },
                    {
                        "username": "GTXFORCE",
                        "content": "My code just: \"sort(nums.begin(),nums.end()); return nums[0]\". It beats 100% in CPP.\\n\\nThe key is when an array is pre-sorted, sort algorithm can almost reach its best case, no longer NlogN !!\\n\\nSame story in problem when they ask you to Merage K sorted array, Instead of using priority queue, just concatenate them and do a fast sort, and that beats 92.26% cpp files. In addition, let say those K array are in extremely bad case, where K is huge, each array only has 1 or 2 elements and the arrays are put into worst order. The performance of concatenating and sorting of course will drop a lot yet so will priority queue, and you need a lot of extra memory to keep your queue alive as well.\\n\\n\\n\\n"
                    },
                    {
                        "username": "bulgarmarc",
                        "content": "[@abzelmes](/abzelmes) it is stated that you should solve it in O(logn) which implies to not sort the list, because sorting the list takes O(nlogn) "
                    },
                    {
                        "username": "kanishk82",
                        "content": "Clearly, fastest sorting algo is O(nlogn) which is greater than a liner search O(n), but for binary search it\\'s O(logn), which is the smallest. So better use a binary search"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@abzelmes](/abzelmes) The problem requires O(log n) time so that already precludes sorting."
                    },
                    {
                        "username": "HitenTandon",
                        "content": "best case sorting time is still O(N) so you\\'re still better of just finding the smallest element linearly"
                    },
                    {
                        "username": "abzelmes",
                        "content": "Obviously this is the best solution, but I found it fun to actually try to do it without sorting. I think they need to add this to the problems requirements. That you shouldn\\'t sort the array.\\nBecause otherwise it would be an easy problem"
                    },
                    {
                        "username": "arnavk09",
                        "content": "This problem in particular is one of those rare cases when the most intuitive solution (that seems like brute force in the beginning) is the one that gives the best answer somehow"
                    },
                    {
                        "username": "faux_hubris",
                        "content": "Use Binary Search to find the largest element i.e. the pivot. The element in the array after the pivot i.e. nums[pivot + 1] is your answer. If mums[nums.Length] > nums[0], then you know it can be considered as a sorted array without rotation. In that case, simply return nums[0]."
                    },
                    {
                        "username": "jayanta1250",
                        "content": "This is not a leetcode medium question if you think. There is nothing to worry about how many times the array is rotated . you have to just find the pivot using binary search. And think in a rotated array pivot is the largest number and next after pivot is the smallest . If the array in not rotated just you have to return the 1st element because that it is the smallest element. Easy thinking. Have a good day best of luck"
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. If array is rotated, it will have two halves : increasing and decreasing. So we can compare mid and mid + 1. If mid > mid + 1, we know this is the tipping point so return mid + 1. \\n\\nThis is because if an array is not rotated, mid > mid + 1 will never occur"
                    },
                    {
                        "username": "jamshidyuldashev7799",
                        "content": "Hi, it is very good.  "
                    },
                    {
                        "username": "tatkal",
                        "content": "Please change the difficulty tag to medium."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Use binary search to find the minimum element in the rotated sorted array. Check if the middle element is smaller than the element before it. If yes, then the minimum element is found. Otherwise, the check if the middle element is smaller than the last element of the array. If yes, then the search is narrowed down to the elements before the middle element. Otherwise, the search is narrowed down to the elements after the middle element. Return the first element of the array as the minimum element, since the first element will not have an element before it."
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(153)Find%20Minimum%20in%20Rotated%20sorted%20Array"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Carry3236](/Carry3236) Actually, the provided solution also works correctly for monotonically increasing arrays (a type of sorted array with no rotations). Let\\'s look at an example:\\n\\nSuppose we have the array `nums = [1,2,3,4,5]`.\\n\\nAt the beginning, `l = 0`, `r = 4`, so `mid = 2`. `nums[mid] = 3` and `nums[r] = 5`. Since `nums[mid]` is not greater than `nums[r]`, we move `r` to `mid`, which is `2`.\\n\\nIn the next iteration, `l = 0`, `r = 2`, so `mid = 1`. `nums[mid] = 2` and `nums[r] = 3`. Again, `nums[mid]` is not greater than `nums[r]`, so we move `r` to `mid`, which is `1`.\\n\\nIn the final iteration, `l = 0`, `r = 1`, so `mid = 0`. `nums[mid] = 1` and `nums[r] = 2`. `nums[mid]` is not greater than `nums[r]`, so we move `r` to `mid`, which is `0`.\\n\\nNow `l` and `r` both point to `0`, and the loop ends. We return `nums[l]`, which is `1` \\u2014 the minimum element in the array.\\n\\nThis confirms that the code does work for monotonically increasing arrays. It always finds the pivot point where the array is \"rotated\" (which, in the case of a monotonically increasing array, is the first element)."
                    },
                    {
                        "username": "Carry3236",
                        "content": "this fails in case of monotonic array ."
                    }
                ]
            },
            {
                "id": 1974186,
                "content": [
                    {
                        "username": "inomag",
                        "content": "The main idea is, the element is said to be minimum in the rotated sorted array if the previous element to it is greater than it or there is no previous element(i.e. no rotation). We can do this using Binary search\\n1. Find the mid element i.e. mid = (low+high)/2\\n2. If the (mid+1)th element is less than mid element then return (mid+1)th element\\n3. If the mid element is less than (mid-1)th element then return the mid element\\n4. If the last element is greater than mid element then search in left half\\n5. If the last element is less than mid element then search in right half\\n\\n**Time Complexity: O(logn)**\\n**Space Complexity: O(1)**\\n\\n*Solution is in the comments.*\\n\\n"
                    },
                    {
                        "username": "paawan3000",
                        "content": "ans"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Please, do not post answers in discussions.\\nPeople try to find tips here, not spoilers."
                    },
                    {
                        "username": "cagils",
                        "content": "We only need to compare mid with right one in the binary search. This will automatically handle the edge case of already sorted array.\\n\\n```\\n4 5 6 7 8 9 0 1 2 3\\nl       m         r\\nm > r => l = m + 1\\n4 5 6 7 8 9 0 1 2 3\\n          l   m   r\\nm < r => r = m\\n4 5 6 7 8 9 0 1 2 3\\n          l m r\\nm < r => r = m\\n4 5 6 7 8 9 0 1 2 3\\n          l r\\nm > r => l = m + 1\\n7 8 0 1 2 3 4 5 6\\n            lr\\nr >= l => return l\\n\\n7 8 0 1 2 3 4 5 6\\nl       m       r\\nm < r => r = m\\n7 8 0 1 2 3 4 5 6\\nl m     m\\nm > r => l = m + 1\\n7 8 0 1 2 3 4 5 6\\n    l m r\\nm < l => r = m\\n7 8 0 1 2 3 4 5 6\\n    l r\\nm < r => r = m\\n7 8 0 1 2 3 4 5 6\\n    lr\\nr >= l => return l\\n\\n8 0 1 2 3 4 5 6 7\\nl       m       r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl   m   r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl m r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl r\\nm > r => l = m + 1\\n8 0 1 2 3 4 5 6 7\\n  lr\\nr >=l => return l\\n\\n0 1 2 3 4\\nl   m   r\\nm < r => r = m\\n0 1 2 3 4\\nl m r\\nm < r => r = m\\n0 1 2 3 4\\nl r\\nm < r => r = m\\n0 1 2 3 4\\nlr\\nr >= l => return l\\n```"
                    },
                    {
                        "username": "akshaydusad",
                        "content": "Thanks a lot for this explanation, I was so confused as to why the mid was only being compared to the right."
                    },
                    {
                        "username": "punit_gautam",
                        "content": "return min(nums)"
                    },
                    {
                        "username": "aphamdd",
                        "content": "obviously this is a joke guys"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "OK.\\nNow show it during an interview :)"
                    },
                    {
                        "username": "InvaderTim1",
                        "content": "[@angeldimitrov](/angeldimitrov) I really hate the test cases on this one, they\\'re so small I couldn\\'t even visualize the while loop in action. I had to go make my own tests in VsCode."
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "[@Sarichi](/Sarichi) this solution with Python runs at \\'70% faster\\' than remainder of solutions, at the time of writing this. Sure, binary search may be more optimal in edge cases but it does not seem that the test cases reflect this. The point of leetcode is supposed to be to include test cases that include incredibly complex edge cases."
                    },
                    {
                        "username": "Sarichi",
                        "content": "It must run in O(log N) not an O(N). If we were just asked to solve it, it would have been tagged as easy. They want us to implement using a binary search."
                    },
                    {
                        "username": "GTXFORCE",
                        "content": "My code just: \"sort(nums.begin(),nums.end()); return nums[0]\". It beats 100% in CPP.\\n\\nThe key is when an array is pre-sorted, sort algorithm can almost reach its best case, no longer NlogN !!\\n\\nSame story in problem when they ask you to Merage K sorted array, Instead of using priority queue, just concatenate them and do a fast sort, and that beats 92.26% cpp files. In addition, let say those K array are in extremely bad case, where K is huge, each array only has 1 or 2 elements and the arrays are put into worst order. The performance of concatenating and sorting of course will drop a lot yet so will priority queue, and you need a lot of extra memory to keep your queue alive as well.\\n\\n\\n\\n"
                    },
                    {
                        "username": "bulgarmarc",
                        "content": "[@abzelmes](/abzelmes) it is stated that you should solve it in O(logn) which implies to not sort the list, because sorting the list takes O(nlogn) "
                    },
                    {
                        "username": "kanishk82",
                        "content": "Clearly, fastest sorting algo is O(nlogn) which is greater than a liner search O(n), but for binary search it\\'s O(logn), which is the smallest. So better use a binary search"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@abzelmes](/abzelmes) The problem requires O(log n) time so that already precludes sorting."
                    },
                    {
                        "username": "HitenTandon",
                        "content": "best case sorting time is still O(N) so you\\'re still better of just finding the smallest element linearly"
                    },
                    {
                        "username": "abzelmes",
                        "content": "Obviously this is the best solution, but I found it fun to actually try to do it without sorting. I think they need to add this to the problems requirements. That you shouldn\\'t sort the array.\\nBecause otherwise it would be an easy problem"
                    },
                    {
                        "username": "arnavk09",
                        "content": "This problem in particular is one of those rare cases when the most intuitive solution (that seems like brute force in the beginning) is the one that gives the best answer somehow"
                    },
                    {
                        "username": "faux_hubris",
                        "content": "Use Binary Search to find the largest element i.e. the pivot. The element in the array after the pivot i.e. nums[pivot + 1] is your answer. If mums[nums.Length] > nums[0], then you know it can be considered as a sorted array without rotation. In that case, simply return nums[0]."
                    },
                    {
                        "username": "jayanta1250",
                        "content": "This is not a leetcode medium question if you think. There is nothing to worry about how many times the array is rotated . you have to just find the pivot using binary search. And think in a rotated array pivot is the largest number and next after pivot is the smallest . If the array in not rotated just you have to return the 1st element because that it is the smallest element. Easy thinking. Have a good day best of luck"
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. If array is rotated, it will have two halves : increasing and decreasing. So we can compare mid and mid + 1. If mid > mid + 1, we know this is the tipping point so return mid + 1. \\n\\nThis is because if an array is not rotated, mid > mid + 1 will never occur"
                    },
                    {
                        "username": "jamshidyuldashev7799",
                        "content": "Hi, it is very good.  "
                    },
                    {
                        "username": "tatkal",
                        "content": "Please change the difficulty tag to medium."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Use binary search to find the minimum element in the rotated sorted array. Check if the middle element is smaller than the element before it. If yes, then the minimum element is found. Otherwise, the check if the middle element is smaller than the last element of the array. If yes, then the search is narrowed down to the elements before the middle element. Otherwise, the search is narrowed down to the elements after the middle element. Return the first element of the array as the minimum element, since the first element will not have an element before it."
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(153)Find%20Minimum%20in%20Rotated%20sorted%20Array"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Carry3236](/Carry3236) Actually, the provided solution also works correctly for monotonically increasing arrays (a type of sorted array with no rotations). Let\\'s look at an example:\\n\\nSuppose we have the array `nums = [1,2,3,4,5]`.\\n\\nAt the beginning, `l = 0`, `r = 4`, so `mid = 2`. `nums[mid] = 3` and `nums[r] = 5`. Since `nums[mid]` is not greater than `nums[r]`, we move `r` to `mid`, which is `2`.\\n\\nIn the next iteration, `l = 0`, `r = 2`, so `mid = 1`. `nums[mid] = 2` and `nums[r] = 3`. Again, `nums[mid]` is not greater than `nums[r]`, so we move `r` to `mid`, which is `1`.\\n\\nIn the final iteration, `l = 0`, `r = 1`, so `mid = 0`. `nums[mid] = 1` and `nums[r] = 2`. `nums[mid]` is not greater than `nums[r]`, so we move `r` to `mid`, which is `0`.\\n\\nNow `l` and `r` both point to `0`, and the loop ends. We return `nums[l]`, which is `1` \\u2014 the minimum element in the array.\\n\\nThis confirms that the code does work for monotonically increasing arrays. It always finds the pivot point where the array is \"rotated\" (which, in the case of a monotonically increasing array, is the first element)."
                    },
                    {
                        "username": "Carry3236",
                        "content": "this fails in case of monotonic array ."
                    }
                ]
            },
            {
                "id": 1575090,
                "content": [
                    {
                        "username": "inomag",
                        "content": "The main idea is, the element is said to be minimum in the rotated sorted array if the previous element to it is greater than it or there is no previous element(i.e. no rotation). We can do this using Binary search\\n1. Find the mid element i.e. mid = (low+high)/2\\n2. If the (mid+1)th element is less than mid element then return (mid+1)th element\\n3. If the mid element is less than (mid-1)th element then return the mid element\\n4. If the last element is greater than mid element then search in left half\\n5. If the last element is less than mid element then search in right half\\n\\n**Time Complexity: O(logn)**\\n**Space Complexity: O(1)**\\n\\n*Solution is in the comments.*\\n\\n"
                    },
                    {
                        "username": "paawan3000",
                        "content": "ans"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Please, do not post answers in discussions.\\nPeople try to find tips here, not spoilers."
                    },
                    {
                        "username": "cagils",
                        "content": "We only need to compare mid with right one in the binary search. This will automatically handle the edge case of already sorted array.\\n\\n```\\n4 5 6 7 8 9 0 1 2 3\\nl       m         r\\nm > r => l = m + 1\\n4 5 6 7 8 9 0 1 2 3\\n          l   m   r\\nm < r => r = m\\n4 5 6 7 8 9 0 1 2 3\\n          l m r\\nm < r => r = m\\n4 5 6 7 8 9 0 1 2 3\\n          l r\\nm > r => l = m + 1\\n7 8 0 1 2 3 4 5 6\\n            lr\\nr >= l => return l\\n\\n7 8 0 1 2 3 4 5 6\\nl       m       r\\nm < r => r = m\\n7 8 0 1 2 3 4 5 6\\nl m     m\\nm > r => l = m + 1\\n7 8 0 1 2 3 4 5 6\\n    l m r\\nm < l => r = m\\n7 8 0 1 2 3 4 5 6\\n    l r\\nm < r => r = m\\n7 8 0 1 2 3 4 5 6\\n    lr\\nr >= l => return l\\n\\n8 0 1 2 3 4 5 6 7\\nl       m       r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl   m   r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl m r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl r\\nm > r => l = m + 1\\n8 0 1 2 3 4 5 6 7\\n  lr\\nr >=l => return l\\n\\n0 1 2 3 4\\nl   m   r\\nm < r => r = m\\n0 1 2 3 4\\nl m r\\nm < r => r = m\\n0 1 2 3 4\\nl r\\nm < r => r = m\\n0 1 2 3 4\\nlr\\nr >= l => return l\\n```"
                    },
                    {
                        "username": "akshaydusad",
                        "content": "Thanks a lot for this explanation, I was so confused as to why the mid was only being compared to the right."
                    },
                    {
                        "username": "punit_gautam",
                        "content": "return min(nums)"
                    },
                    {
                        "username": "aphamdd",
                        "content": "obviously this is a joke guys"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "OK.\\nNow show it during an interview :)"
                    },
                    {
                        "username": "InvaderTim1",
                        "content": "[@angeldimitrov](/angeldimitrov) I really hate the test cases on this one, they\\'re so small I couldn\\'t even visualize the while loop in action. I had to go make my own tests in VsCode."
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "[@Sarichi](/Sarichi) this solution with Python runs at \\'70% faster\\' than remainder of solutions, at the time of writing this. Sure, binary search may be more optimal in edge cases but it does not seem that the test cases reflect this. The point of leetcode is supposed to be to include test cases that include incredibly complex edge cases."
                    },
                    {
                        "username": "Sarichi",
                        "content": "It must run in O(log N) not an O(N). If we were just asked to solve it, it would have been tagged as easy. They want us to implement using a binary search."
                    },
                    {
                        "username": "GTXFORCE",
                        "content": "My code just: \"sort(nums.begin(),nums.end()); return nums[0]\". It beats 100% in CPP.\\n\\nThe key is when an array is pre-sorted, sort algorithm can almost reach its best case, no longer NlogN !!\\n\\nSame story in problem when they ask you to Merage K sorted array, Instead of using priority queue, just concatenate them and do a fast sort, and that beats 92.26% cpp files. In addition, let say those K array are in extremely bad case, where K is huge, each array only has 1 or 2 elements and the arrays are put into worst order. The performance of concatenating and sorting of course will drop a lot yet so will priority queue, and you need a lot of extra memory to keep your queue alive as well.\\n\\n\\n\\n"
                    },
                    {
                        "username": "bulgarmarc",
                        "content": "[@abzelmes](/abzelmes) it is stated that you should solve it in O(logn) which implies to not sort the list, because sorting the list takes O(nlogn) "
                    },
                    {
                        "username": "kanishk82",
                        "content": "Clearly, fastest sorting algo is O(nlogn) which is greater than a liner search O(n), but for binary search it\\'s O(logn), which is the smallest. So better use a binary search"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@abzelmes](/abzelmes) The problem requires O(log n) time so that already precludes sorting."
                    },
                    {
                        "username": "HitenTandon",
                        "content": "best case sorting time is still O(N) so you\\'re still better of just finding the smallest element linearly"
                    },
                    {
                        "username": "abzelmes",
                        "content": "Obviously this is the best solution, but I found it fun to actually try to do it without sorting. I think they need to add this to the problems requirements. That you shouldn\\'t sort the array.\\nBecause otherwise it would be an easy problem"
                    },
                    {
                        "username": "arnavk09",
                        "content": "This problem in particular is one of those rare cases when the most intuitive solution (that seems like brute force in the beginning) is the one that gives the best answer somehow"
                    },
                    {
                        "username": "faux_hubris",
                        "content": "Use Binary Search to find the largest element i.e. the pivot. The element in the array after the pivot i.e. nums[pivot + 1] is your answer. If mums[nums.Length] > nums[0], then you know it can be considered as a sorted array without rotation. In that case, simply return nums[0]."
                    },
                    {
                        "username": "jayanta1250",
                        "content": "This is not a leetcode medium question if you think. There is nothing to worry about how many times the array is rotated . you have to just find the pivot using binary search. And think in a rotated array pivot is the largest number and next after pivot is the smallest . If the array in not rotated just you have to return the 1st element because that it is the smallest element. Easy thinking. Have a good day best of luck"
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. If array is rotated, it will have two halves : increasing and decreasing. So we can compare mid and mid + 1. If mid > mid + 1, we know this is the tipping point so return mid + 1. \\n\\nThis is because if an array is not rotated, mid > mid + 1 will never occur"
                    },
                    {
                        "username": "jamshidyuldashev7799",
                        "content": "Hi, it is very good.  "
                    },
                    {
                        "username": "tatkal",
                        "content": "Please change the difficulty tag to medium."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Use binary search to find the minimum element in the rotated sorted array. Check if the middle element is smaller than the element before it. If yes, then the minimum element is found. Otherwise, the check if the middle element is smaller than the last element of the array. If yes, then the search is narrowed down to the elements before the middle element. Otherwise, the search is narrowed down to the elements after the middle element. Return the first element of the array as the minimum element, since the first element will not have an element before it."
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(153)Find%20Minimum%20in%20Rotated%20sorted%20Array"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Carry3236](/Carry3236) Actually, the provided solution also works correctly for monotonically increasing arrays (a type of sorted array with no rotations). Let\\'s look at an example:\\n\\nSuppose we have the array `nums = [1,2,3,4,5]`.\\n\\nAt the beginning, `l = 0`, `r = 4`, so `mid = 2`. `nums[mid] = 3` and `nums[r] = 5`. Since `nums[mid]` is not greater than `nums[r]`, we move `r` to `mid`, which is `2`.\\n\\nIn the next iteration, `l = 0`, `r = 2`, so `mid = 1`. `nums[mid] = 2` and `nums[r] = 3`. Again, `nums[mid]` is not greater than `nums[r]`, so we move `r` to `mid`, which is `1`.\\n\\nIn the final iteration, `l = 0`, `r = 1`, so `mid = 0`. `nums[mid] = 1` and `nums[r] = 2`. `nums[mid]` is not greater than `nums[r]`, so we move `r` to `mid`, which is `0`.\\n\\nNow `l` and `r` both point to `0`, and the loop ends. We return `nums[l]`, which is `1` \\u2014 the minimum element in the array.\\n\\nThis confirms that the code does work for monotonically increasing arrays. It always finds the pivot point where the array is \"rotated\" (which, in the case of a monotonically increasing array, is the first element)."
                    },
                    {
                        "username": "Carry3236",
                        "content": "this fails in case of monotonic array ."
                    }
                ]
            },
            {
                "id": 1575700,
                "content": [
                    {
                        "username": "inomag",
                        "content": "The main idea is, the element is said to be minimum in the rotated sorted array if the previous element to it is greater than it or there is no previous element(i.e. no rotation). We can do this using Binary search\\n1. Find the mid element i.e. mid = (low+high)/2\\n2. If the (mid+1)th element is less than mid element then return (mid+1)th element\\n3. If the mid element is less than (mid-1)th element then return the mid element\\n4. If the last element is greater than mid element then search in left half\\n5. If the last element is less than mid element then search in right half\\n\\n**Time Complexity: O(logn)**\\n**Space Complexity: O(1)**\\n\\n*Solution is in the comments.*\\n\\n"
                    },
                    {
                        "username": "paawan3000",
                        "content": "ans"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Please, do not post answers in discussions.\\nPeople try to find tips here, not spoilers."
                    },
                    {
                        "username": "cagils",
                        "content": "We only need to compare mid with right one in the binary search. This will automatically handle the edge case of already sorted array.\\n\\n```\\n4 5 6 7 8 9 0 1 2 3\\nl       m         r\\nm > r => l = m + 1\\n4 5 6 7 8 9 0 1 2 3\\n          l   m   r\\nm < r => r = m\\n4 5 6 7 8 9 0 1 2 3\\n          l m r\\nm < r => r = m\\n4 5 6 7 8 9 0 1 2 3\\n          l r\\nm > r => l = m + 1\\n7 8 0 1 2 3 4 5 6\\n            lr\\nr >= l => return l\\n\\n7 8 0 1 2 3 4 5 6\\nl       m       r\\nm < r => r = m\\n7 8 0 1 2 3 4 5 6\\nl m     m\\nm > r => l = m + 1\\n7 8 0 1 2 3 4 5 6\\n    l m r\\nm < l => r = m\\n7 8 0 1 2 3 4 5 6\\n    l r\\nm < r => r = m\\n7 8 0 1 2 3 4 5 6\\n    lr\\nr >= l => return l\\n\\n8 0 1 2 3 4 5 6 7\\nl       m       r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl   m   r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl m r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl r\\nm > r => l = m + 1\\n8 0 1 2 3 4 5 6 7\\n  lr\\nr >=l => return l\\n\\n0 1 2 3 4\\nl   m   r\\nm < r => r = m\\n0 1 2 3 4\\nl m r\\nm < r => r = m\\n0 1 2 3 4\\nl r\\nm < r => r = m\\n0 1 2 3 4\\nlr\\nr >= l => return l\\n```"
                    },
                    {
                        "username": "akshaydusad",
                        "content": "Thanks a lot for this explanation, I was so confused as to why the mid was only being compared to the right."
                    },
                    {
                        "username": "punit_gautam",
                        "content": "return min(nums)"
                    },
                    {
                        "username": "aphamdd",
                        "content": "obviously this is a joke guys"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "OK.\\nNow show it during an interview :)"
                    },
                    {
                        "username": "InvaderTim1",
                        "content": "[@angeldimitrov](/angeldimitrov) I really hate the test cases on this one, they\\'re so small I couldn\\'t even visualize the while loop in action. I had to go make my own tests in VsCode."
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "[@Sarichi](/Sarichi) this solution with Python runs at \\'70% faster\\' than remainder of solutions, at the time of writing this. Sure, binary search may be more optimal in edge cases but it does not seem that the test cases reflect this. The point of leetcode is supposed to be to include test cases that include incredibly complex edge cases."
                    },
                    {
                        "username": "Sarichi",
                        "content": "It must run in O(log N) not an O(N). If we were just asked to solve it, it would have been tagged as easy. They want us to implement using a binary search."
                    },
                    {
                        "username": "GTXFORCE",
                        "content": "My code just: \"sort(nums.begin(),nums.end()); return nums[0]\". It beats 100% in CPP.\\n\\nThe key is when an array is pre-sorted, sort algorithm can almost reach its best case, no longer NlogN !!\\n\\nSame story in problem when they ask you to Merage K sorted array, Instead of using priority queue, just concatenate them and do a fast sort, and that beats 92.26% cpp files. In addition, let say those K array are in extremely bad case, where K is huge, each array only has 1 or 2 elements and the arrays are put into worst order. The performance of concatenating and sorting of course will drop a lot yet so will priority queue, and you need a lot of extra memory to keep your queue alive as well.\\n\\n\\n\\n"
                    },
                    {
                        "username": "bulgarmarc",
                        "content": "[@abzelmes](/abzelmes) it is stated that you should solve it in O(logn) which implies to not sort the list, because sorting the list takes O(nlogn) "
                    },
                    {
                        "username": "kanishk82",
                        "content": "Clearly, fastest sorting algo is O(nlogn) which is greater than a liner search O(n), but for binary search it\\'s O(logn), which is the smallest. So better use a binary search"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@abzelmes](/abzelmes) The problem requires O(log n) time so that already precludes sorting."
                    },
                    {
                        "username": "HitenTandon",
                        "content": "best case sorting time is still O(N) so you\\'re still better of just finding the smallest element linearly"
                    },
                    {
                        "username": "abzelmes",
                        "content": "Obviously this is the best solution, but I found it fun to actually try to do it without sorting. I think they need to add this to the problems requirements. That you shouldn\\'t sort the array.\\nBecause otherwise it would be an easy problem"
                    },
                    {
                        "username": "arnavk09",
                        "content": "This problem in particular is one of those rare cases when the most intuitive solution (that seems like brute force in the beginning) is the one that gives the best answer somehow"
                    },
                    {
                        "username": "faux_hubris",
                        "content": "Use Binary Search to find the largest element i.e. the pivot. The element in the array after the pivot i.e. nums[pivot + 1] is your answer. If mums[nums.Length] > nums[0], then you know it can be considered as a sorted array without rotation. In that case, simply return nums[0]."
                    },
                    {
                        "username": "jayanta1250",
                        "content": "This is not a leetcode medium question if you think. There is nothing to worry about how many times the array is rotated . you have to just find the pivot using binary search. And think in a rotated array pivot is the largest number and next after pivot is the smallest . If the array in not rotated just you have to return the 1st element because that it is the smallest element. Easy thinking. Have a good day best of luck"
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. If array is rotated, it will have two halves : increasing and decreasing. So we can compare mid and mid + 1. If mid > mid + 1, we know this is the tipping point so return mid + 1. \\n\\nThis is because if an array is not rotated, mid > mid + 1 will never occur"
                    },
                    {
                        "username": "jamshidyuldashev7799",
                        "content": "Hi, it is very good.  "
                    },
                    {
                        "username": "tatkal",
                        "content": "Please change the difficulty tag to medium."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Use binary search to find the minimum element in the rotated sorted array. Check if the middle element is smaller than the element before it. If yes, then the minimum element is found. Otherwise, the check if the middle element is smaller than the last element of the array. If yes, then the search is narrowed down to the elements before the middle element. Otherwise, the search is narrowed down to the elements after the middle element. Return the first element of the array as the minimum element, since the first element will not have an element before it."
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(153)Find%20Minimum%20in%20Rotated%20sorted%20Array"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Carry3236](/Carry3236) Actually, the provided solution also works correctly for monotonically increasing arrays (a type of sorted array with no rotations). Let\\'s look at an example:\\n\\nSuppose we have the array `nums = [1,2,3,4,5]`.\\n\\nAt the beginning, `l = 0`, `r = 4`, so `mid = 2`. `nums[mid] = 3` and `nums[r] = 5`. Since `nums[mid]` is not greater than `nums[r]`, we move `r` to `mid`, which is `2`.\\n\\nIn the next iteration, `l = 0`, `r = 2`, so `mid = 1`. `nums[mid] = 2` and `nums[r] = 3`. Again, `nums[mid]` is not greater than `nums[r]`, so we move `r` to `mid`, which is `1`.\\n\\nIn the final iteration, `l = 0`, `r = 1`, so `mid = 0`. `nums[mid] = 1` and `nums[r] = 2`. `nums[mid]` is not greater than `nums[r]`, so we move `r` to `mid`, which is `0`.\\n\\nNow `l` and `r` both point to `0`, and the loop ends. We return `nums[l]`, which is `1` \\u2014 the minimum element in the array.\\n\\nThis confirms that the code does work for monotonically increasing arrays. It always finds the pivot point where the array is \"rotated\" (which, in the case of a monotonically increasing array, is the first element)."
                    },
                    {
                        "username": "Carry3236",
                        "content": "this fails in case of monotonic array ."
                    }
                ]
            },
            {
                "id": 1876714,
                "content": [
                    {
                        "username": "inomag",
                        "content": "The main idea is, the element is said to be minimum in the rotated sorted array if the previous element to it is greater than it or there is no previous element(i.e. no rotation). We can do this using Binary search\\n1. Find the mid element i.e. mid = (low+high)/2\\n2. If the (mid+1)th element is less than mid element then return (mid+1)th element\\n3. If the mid element is less than (mid-1)th element then return the mid element\\n4. If the last element is greater than mid element then search in left half\\n5. If the last element is less than mid element then search in right half\\n\\n**Time Complexity: O(logn)**\\n**Space Complexity: O(1)**\\n\\n*Solution is in the comments.*\\n\\n"
                    },
                    {
                        "username": "paawan3000",
                        "content": "ans"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Please, do not post answers in discussions.\\nPeople try to find tips here, not spoilers."
                    },
                    {
                        "username": "cagils",
                        "content": "We only need to compare mid with right one in the binary search. This will automatically handle the edge case of already sorted array.\\n\\n```\\n4 5 6 7 8 9 0 1 2 3\\nl       m         r\\nm > r => l = m + 1\\n4 5 6 7 8 9 0 1 2 3\\n          l   m   r\\nm < r => r = m\\n4 5 6 7 8 9 0 1 2 3\\n          l m r\\nm < r => r = m\\n4 5 6 7 8 9 0 1 2 3\\n          l r\\nm > r => l = m + 1\\n7 8 0 1 2 3 4 5 6\\n            lr\\nr >= l => return l\\n\\n7 8 0 1 2 3 4 5 6\\nl       m       r\\nm < r => r = m\\n7 8 0 1 2 3 4 5 6\\nl m     m\\nm > r => l = m + 1\\n7 8 0 1 2 3 4 5 6\\n    l m r\\nm < l => r = m\\n7 8 0 1 2 3 4 5 6\\n    l r\\nm < r => r = m\\n7 8 0 1 2 3 4 5 6\\n    lr\\nr >= l => return l\\n\\n8 0 1 2 3 4 5 6 7\\nl       m       r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl   m   r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl m r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl r\\nm > r => l = m + 1\\n8 0 1 2 3 4 5 6 7\\n  lr\\nr >=l => return l\\n\\n0 1 2 3 4\\nl   m   r\\nm < r => r = m\\n0 1 2 3 4\\nl m r\\nm < r => r = m\\n0 1 2 3 4\\nl r\\nm < r => r = m\\n0 1 2 3 4\\nlr\\nr >= l => return l\\n```"
                    },
                    {
                        "username": "akshaydusad",
                        "content": "Thanks a lot for this explanation, I was so confused as to why the mid was only being compared to the right."
                    },
                    {
                        "username": "punit_gautam",
                        "content": "return min(nums)"
                    },
                    {
                        "username": "aphamdd",
                        "content": "obviously this is a joke guys"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "OK.\\nNow show it during an interview :)"
                    },
                    {
                        "username": "InvaderTim1",
                        "content": "[@angeldimitrov](/angeldimitrov) I really hate the test cases on this one, they\\'re so small I couldn\\'t even visualize the while loop in action. I had to go make my own tests in VsCode."
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "[@Sarichi](/Sarichi) this solution with Python runs at \\'70% faster\\' than remainder of solutions, at the time of writing this. Sure, binary search may be more optimal in edge cases but it does not seem that the test cases reflect this. The point of leetcode is supposed to be to include test cases that include incredibly complex edge cases."
                    },
                    {
                        "username": "Sarichi",
                        "content": "It must run in O(log N) not an O(N). If we were just asked to solve it, it would have been tagged as easy. They want us to implement using a binary search."
                    },
                    {
                        "username": "GTXFORCE",
                        "content": "My code just: \"sort(nums.begin(),nums.end()); return nums[0]\". It beats 100% in CPP.\\n\\nThe key is when an array is pre-sorted, sort algorithm can almost reach its best case, no longer NlogN !!\\n\\nSame story in problem when they ask you to Merage K sorted array, Instead of using priority queue, just concatenate them and do a fast sort, and that beats 92.26% cpp files. In addition, let say those K array are in extremely bad case, where K is huge, each array only has 1 or 2 elements and the arrays are put into worst order. The performance of concatenating and sorting of course will drop a lot yet so will priority queue, and you need a lot of extra memory to keep your queue alive as well.\\n\\n\\n\\n"
                    },
                    {
                        "username": "bulgarmarc",
                        "content": "[@abzelmes](/abzelmes) it is stated that you should solve it in O(logn) which implies to not sort the list, because sorting the list takes O(nlogn) "
                    },
                    {
                        "username": "kanishk82",
                        "content": "Clearly, fastest sorting algo is O(nlogn) which is greater than a liner search O(n), but for binary search it\\'s O(logn), which is the smallest. So better use a binary search"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@abzelmes](/abzelmes) The problem requires O(log n) time so that already precludes sorting."
                    },
                    {
                        "username": "HitenTandon",
                        "content": "best case sorting time is still O(N) so you\\'re still better of just finding the smallest element linearly"
                    },
                    {
                        "username": "abzelmes",
                        "content": "Obviously this is the best solution, but I found it fun to actually try to do it without sorting. I think they need to add this to the problems requirements. That you shouldn\\'t sort the array.\\nBecause otherwise it would be an easy problem"
                    },
                    {
                        "username": "arnavk09",
                        "content": "This problem in particular is one of those rare cases when the most intuitive solution (that seems like brute force in the beginning) is the one that gives the best answer somehow"
                    },
                    {
                        "username": "faux_hubris",
                        "content": "Use Binary Search to find the largest element i.e. the pivot. The element in the array after the pivot i.e. nums[pivot + 1] is your answer. If mums[nums.Length] > nums[0], then you know it can be considered as a sorted array without rotation. In that case, simply return nums[0]."
                    },
                    {
                        "username": "jayanta1250",
                        "content": "This is not a leetcode medium question if you think. There is nothing to worry about how many times the array is rotated . you have to just find the pivot using binary search. And think in a rotated array pivot is the largest number and next after pivot is the smallest . If the array in not rotated just you have to return the 1st element because that it is the smallest element. Easy thinking. Have a good day best of luck"
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. If array is rotated, it will have two halves : increasing and decreasing. So we can compare mid and mid + 1. If mid > mid + 1, we know this is the tipping point so return mid + 1. \\n\\nThis is because if an array is not rotated, mid > mid + 1 will never occur"
                    },
                    {
                        "username": "jamshidyuldashev7799",
                        "content": "Hi, it is very good.  "
                    },
                    {
                        "username": "tatkal",
                        "content": "Please change the difficulty tag to medium."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Use binary search to find the minimum element in the rotated sorted array. Check if the middle element is smaller than the element before it. If yes, then the minimum element is found. Otherwise, the check if the middle element is smaller than the last element of the array. If yes, then the search is narrowed down to the elements before the middle element. Otherwise, the search is narrowed down to the elements after the middle element. Return the first element of the array as the minimum element, since the first element will not have an element before it."
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(153)Find%20Minimum%20in%20Rotated%20sorted%20Array"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Carry3236](/Carry3236) Actually, the provided solution also works correctly for monotonically increasing arrays (a type of sorted array with no rotations). Let\\'s look at an example:\\n\\nSuppose we have the array `nums = [1,2,3,4,5]`.\\n\\nAt the beginning, `l = 0`, `r = 4`, so `mid = 2`. `nums[mid] = 3` and `nums[r] = 5`. Since `nums[mid]` is not greater than `nums[r]`, we move `r` to `mid`, which is `2`.\\n\\nIn the next iteration, `l = 0`, `r = 2`, so `mid = 1`. `nums[mid] = 2` and `nums[r] = 3`. Again, `nums[mid]` is not greater than `nums[r]`, so we move `r` to `mid`, which is `1`.\\n\\nIn the final iteration, `l = 0`, `r = 1`, so `mid = 0`. `nums[mid] = 1` and `nums[r] = 2`. `nums[mid]` is not greater than `nums[r]`, so we move `r` to `mid`, which is `0`.\\n\\nNow `l` and `r` both point to `0`, and the loop ends. We return `nums[l]`, which is `1` \\u2014 the minimum element in the array.\\n\\nThis confirms that the code does work for monotonically increasing arrays. It always finds the pivot point where the array is \"rotated\" (which, in the case of a monotonically increasing array, is the first element)."
                    },
                    {
                        "username": "Carry3236",
                        "content": "this fails in case of monotonic array ."
                    }
                ]
            },
            {
                "id": 1819476,
                "content": [
                    {
                        "username": "inomag",
                        "content": "The main idea is, the element is said to be minimum in the rotated sorted array if the previous element to it is greater than it or there is no previous element(i.e. no rotation). We can do this using Binary search\\n1. Find the mid element i.e. mid = (low+high)/2\\n2. If the (mid+1)th element is less than mid element then return (mid+1)th element\\n3. If the mid element is less than (mid-1)th element then return the mid element\\n4. If the last element is greater than mid element then search in left half\\n5. If the last element is less than mid element then search in right half\\n\\n**Time Complexity: O(logn)**\\n**Space Complexity: O(1)**\\n\\n*Solution is in the comments.*\\n\\n"
                    },
                    {
                        "username": "paawan3000",
                        "content": "ans"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Please, do not post answers in discussions.\\nPeople try to find tips here, not spoilers."
                    },
                    {
                        "username": "cagils",
                        "content": "We only need to compare mid with right one in the binary search. This will automatically handle the edge case of already sorted array.\\n\\n```\\n4 5 6 7 8 9 0 1 2 3\\nl       m         r\\nm > r => l = m + 1\\n4 5 6 7 8 9 0 1 2 3\\n          l   m   r\\nm < r => r = m\\n4 5 6 7 8 9 0 1 2 3\\n          l m r\\nm < r => r = m\\n4 5 6 7 8 9 0 1 2 3\\n          l r\\nm > r => l = m + 1\\n7 8 0 1 2 3 4 5 6\\n            lr\\nr >= l => return l\\n\\n7 8 0 1 2 3 4 5 6\\nl       m       r\\nm < r => r = m\\n7 8 0 1 2 3 4 5 6\\nl m     m\\nm > r => l = m + 1\\n7 8 0 1 2 3 4 5 6\\n    l m r\\nm < l => r = m\\n7 8 0 1 2 3 4 5 6\\n    l r\\nm < r => r = m\\n7 8 0 1 2 3 4 5 6\\n    lr\\nr >= l => return l\\n\\n8 0 1 2 3 4 5 6 7\\nl       m       r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl   m   r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl m r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl r\\nm > r => l = m + 1\\n8 0 1 2 3 4 5 6 7\\n  lr\\nr >=l => return l\\n\\n0 1 2 3 4\\nl   m   r\\nm < r => r = m\\n0 1 2 3 4\\nl m r\\nm < r => r = m\\n0 1 2 3 4\\nl r\\nm < r => r = m\\n0 1 2 3 4\\nlr\\nr >= l => return l\\n```"
                    },
                    {
                        "username": "akshaydusad",
                        "content": "Thanks a lot for this explanation, I was so confused as to why the mid was only being compared to the right."
                    },
                    {
                        "username": "punit_gautam",
                        "content": "return min(nums)"
                    },
                    {
                        "username": "aphamdd",
                        "content": "obviously this is a joke guys"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "OK.\\nNow show it during an interview :)"
                    },
                    {
                        "username": "InvaderTim1",
                        "content": "[@angeldimitrov](/angeldimitrov) I really hate the test cases on this one, they\\'re so small I couldn\\'t even visualize the while loop in action. I had to go make my own tests in VsCode."
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "[@Sarichi](/Sarichi) this solution with Python runs at \\'70% faster\\' than remainder of solutions, at the time of writing this. Sure, binary search may be more optimal in edge cases but it does not seem that the test cases reflect this. The point of leetcode is supposed to be to include test cases that include incredibly complex edge cases."
                    },
                    {
                        "username": "Sarichi",
                        "content": "It must run in O(log N) not an O(N). If we were just asked to solve it, it would have been tagged as easy. They want us to implement using a binary search."
                    },
                    {
                        "username": "GTXFORCE",
                        "content": "My code just: \"sort(nums.begin(),nums.end()); return nums[0]\". It beats 100% in CPP.\\n\\nThe key is when an array is pre-sorted, sort algorithm can almost reach its best case, no longer NlogN !!\\n\\nSame story in problem when they ask you to Merage K sorted array, Instead of using priority queue, just concatenate them and do a fast sort, and that beats 92.26% cpp files. In addition, let say those K array are in extremely bad case, where K is huge, each array only has 1 or 2 elements and the arrays are put into worst order. The performance of concatenating and sorting of course will drop a lot yet so will priority queue, and you need a lot of extra memory to keep your queue alive as well.\\n\\n\\n\\n"
                    },
                    {
                        "username": "bulgarmarc",
                        "content": "[@abzelmes](/abzelmes) it is stated that you should solve it in O(logn) which implies to not sort the list, because sorting the list takes O(nlogn) "
                    },
                    {
                        "username": "kanishk82",
                        "content": "Clearly, fastest sorting algo is O(nlogn) which is greater than a liner search O(n), but for binary search it\\'s O(logn), which is the smallest. So better use a binary search"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@abzelmes](/abzelmes) The problem requires O(log n) time so that already precludes sorting."
                    },
                    {
                        "username": "HitenTandon",
                        "content": "best case sorting time is still O(N) so you\\'re still better of just finding the smallest element linearly"
                    },
                    {
                        "username": "abzelmes",
                        "content": "Obviously this is the best solution, but I found it fun to actually try to do it without sorting. I think they need to add this to the problems requirements. That you shouldn\\'t sort the array.\\nBecause otherwise it would be an easy problem"
                    },
                    {
                        "username": "arnavk09",
                        "content": "This problem in particular is one of those rare cases when the most intuitive solution (that seems like brute force in the beginning) is the one that gives the best answer somehow"
                    },
                    {
                        "username": "faux_hubris",
                        "content": "Use Binary Search to find the largest element i.e. the pivot. The element in the array after the pivot i.e. nums[pivot + 1] is your answer. If mums[nums.Length] > nums[0], then you know it can be considered as a sorted array without rotation. In that case, simply return nums[0]."
                    },
                    {
                        "username": "jayanta1250",
                        "content": "This is not a leetcode medium question if you think. There is nothing to worry about how many times the array is rotated . you have to just find the pivot using binary search. And think in a rotated array pivot is the largest number and next after pivot is the smallest . If the array in not rotated just you have to return the 1st element because that it is the smallest element. Easy thinking. Have a good day best of luck"
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. If array is rotated, it will have two halves : increasing and decreasing. So we can compare mid and mid + 1. If mid > mid + 1, we know this is the tipping point so return mid + 1. \\n\\nThis is because if an array is not rotated, mid > mid + 1 will never occur"
                    },
                    {
                        "username": "jamshidyuldashev7799",
                        "content": "Hi, it is very good.  "
                    },
                    {
                        "username": "tatkal",
                        "content": "Please change the difficulty tag to medium."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Use binary search to find the minimum element in the rotated sorted array. Check if the middle element is smaller than the element before it. If yes, then the minimum element is found. Otherwise, the check if the middle element is smaller than the last element of the array. If yes, then the search is narrowed down to the elements before the middle element. Otherwise, the search is narrowed down to the elements after the middle element. Return the first element of the array as the minimum element, since the first element will not have an element before it."
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(153)Find%20Minimum%20in%20Rotated%20sorted%20Array"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Carry3236](/Carry3236) Actually, the provided solution also works correctly for monotonically increasing arrays (a type of sorted array with no rotations). Let\\'s look at an example:\\n\\nSuppose we have the array `nums = [1,2,3,4,5]`.\\n\\nAt the beginning, `l = 0`, `r = 4`, so `mid = 2`. `nums[mid] = 3` and `nums[r] = 5`. Since `nums[mid]` is not greater than `nums[r]`, we move `r` to `mid`, which is `2`.\\n\\nIn the next iteration, `l = 0`, `r = 2`, so `mid = 1`. `nums[mid] = 2` and `nums[r] = 3`. Again, `nums[mid]` is not greater than `nums[r]`, so we move `r` to `mid`, which is `1`.\\n\\nIn the final iteration, `l = 0`, `r = 1`, so `mid = 0`. `nums[mid] = 1` and `nums[r] = 2`. `nums[mid]` is not greater than `nums[r]`, so we move `r` to `mid`, which is `0`.\\n\\nNow `l` and `r` both point to `0`, and the loop ends. We return `nums[l]`, which is `1` \\u2014 the minimum element in the array.\\n\\nThis confirms that the code does work for monotonically increasing arrays. It always finds the pivot point where the array is \"rotated\" (which, in the case of a monotonically increasing array, is the first element)."
                    },
                    {
                        "username": "Carry3236",
                        "content": "this fails in case of monotonic array ."
                    }
                ]
            },
            {
                "id": 1575355,
                "content": [
                    {
                        "username": "inomag",
                        "content": "The main idea is, the element is said to be minimum in the rotated sorted array if the previous element to it is greater than it or there is no previous element(i.e. no rotation). We can do this using Binary search\\n1. Find the mid element i.e. mid = (low+high)/2\\n2. If the (mid+1)th element is less than mid element then return (mid+1)th element\\n3. If the mid element is less than (mid-1)th element then return the mid element\\n4. If the last element is greater than mid element then search in left half\\n5. If the last element is less than mid element then search in right half\\n\\n**Time Complexity: O(logn)**\\n**Space Complexity: O(1)**\\n\\n*Solution is in the comments.*\\n\\n"
                    },
                    {
                        "username": "paawan3000",
                        "content": "ans"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Please, do not post answers in discussions.\\nPeople try to find tips here, not spoilers."
                    },
                    {
                        "username": "cagils",
                        "content": "We only need to compare mid with right one in the binary search. This will automatically handle the edge case of already sorted array.\\n\\n```\\n4 5 6 7 8 9 0 1 2 3\\nl       m         r\\nm > r => l = m + 1\\n4 5 6 7 8 9 0 1 2 3\\n          l   m   r\\nm < r => r = m\\n4 5 6 7 8 9 0 1 2 3\\n          l m r\\nm < r => r = m\\n4 5 6 7 8 9 0 1 2 3\\n          l r\\nm > r => l = m + 1\\n7 8 0 1 2 3 4 5 6\\n            lr\\nr >= l => return l\\n\\n7 8 0 1 2 3 4 5 6\\nl       m       r\\nm < r => r = m\\n7 8 0 1 2 3 4 5 6\\nl m     m\\nm > r => l = m + 1\\n7 8 0 1 2 3 4 5 6\\n    l m r\\nm < l => r = m\\n7 8 0 1 2 3 4 5 6\\n    l r\\nm < r => r = m\\n7 8 0 1 2 3 4 5 6\\n    lr\\nr >= l => return l\\n\\n8 0 1 2 3 4 5 6 7\\nl       m       r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl   m   r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl m r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl r\\nm > r => l = m + 1\\n8 0 1 2 3 4 5 6 7\\n  lr\\nr >=l => return l\\n\\n0 1 2 3 4\\nl   m   r\\nm < r => r = m\\n0 1 2 3 4\\nl m r\\nm < r => r = m\\n0 1 2 3 4\\nl r\\nm < r => r = m\\n0 1 2 3 4\\nlr\\nr >= l => return l\\n```"
                    },
                    {
                        "username": "akshaydusad",
                        "content": "Thanks a lot for this explanation, I was so confused as to why the mid was only being compared to the right."
                    },
                    {
                        "username": "punit_gautam",
                        "content": "return min(nums)"
                    },
                    {
                        "username": "aphamdd",
                        "content": "obviously this is a joke guys"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "OK.\\nNow show it during an interview :)"
                    },
                    {
                        "username": "InvaderTim1",
                        "content": "[@angeldimitrov](/angeldimitrov) I really hate the test cases on this one, they\\'re so small I couldn\\'t even visualize the while loop in action. I had to go make my own tests in VsCode."
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "[@Sarichi](/Sarichi) this solution with Python runs at \\'70% faster\\' than remainder of solutions, at the time of writing this. Sure, binary search may be more optimal in edge cases but it does not seem that the test cases reflect this. The point of leetcode is supposed to be to include test cases that include incredibly complex edge cases."
                    },
                    {
                        "username": "Sarichi",
                        "content": "It must run in O(log N) not an O(N). If we were just asked to solve it, it would have been tagged as easy. They want us to implement using a binary search."
                    },
                    {
                        "username": "GTXFORCE",
                        "content": "My code just: \"sort(nums.begin(),nums.end()); return nums[0]\". It beats 100% in CPP.\\n\\nThe key is when an array is pre-sorted, sort algorithm can almost reach its best case, no longer NlogN !!\\n\\nSame story in problem when they ask you to Merage K sorted array, Instead of using priority queue, just concatenate them and do a fast sort, and that beats 92.26% cpp files. In addition, let say those K array are in extremely bad case, where K is huge, each array only has 1 or 2 elements and the arrays are put into worst order. The performance of concatenating and sorting of course will drop a lot yet so will priority queue, and you need a lot of extra memory to keep your queue alive as well.\\n\\n\\n\\n"
                    },
                    {
                        "username": "bulgarmarc",
                        "content": "[@abzelmes](/abzelmes) it is stated that you should solve it in O(logn) which implies to not sort the list, because sorting the list takes O(nlogn) "
                    },
                    {
                        "username": "kanishk82",
                        "content": "Clearly, fastest sorting algo is O(nlogn) which is greater than a liner search O(n), but for binary search it\\'s O(logn), which is the smallest. So better use a binary search"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@abzelmes](/abzelmes) The problem requires O(log n) time so that already precludes sorting."
                    },
                    {
                        "username": "HitenTandon",
                        "content": "best case sorting time is still O(N) so you\\'re still better of just finding the smallest element linearly"
                    },
                    {
                        "username": "abzelmes",
                        "content": "Obviously this is the best solution, but I found it fun to actually try to do it without sorting. I think they need to add this to the problems requirements. That you shouldn\\'t sort the array.\\nBecause otherwise it would be an easy problem"
                    },
                    {
                        "username": "arnavk09",
                        "content": "This problem in particular is one of those rare cases when the most intuitive solution (that seems like brute force in the beginning) is the one that gives the best answer somehow"
                    },
                    {
                        "username": "faux_hubris",
                        "content": "Use Binary Search to find the largest element i.e. the pivot. The element in the array after the pivot i.e. nums[pivot + 1] is your answer. If mums[nums.Length] > nums[0], then you know it can be considered as a sorted array without rotation. In that case, simply return nums[0]."
                    },
                    {
                        "username": "jayanta1250",
                        "content": "This is not a leetcode medium question if you think. There is nothing to worry about how many times the array is rotated . you have to just find the pivot using binary search. And think in a rotated array pivot is the largest number and next after pivot is the smallest . If the array in not rotated just you have to return the 1st element because that it is the smallest element. Easy thinking. Have a good day best of luck"
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. If array is rotated, it will have two halves : increasing and decreasing. So we can compare mid and mid + 1. If mid > mid + 1, we know this is the tipping point so return mid + 1. \\n\\nThis is because if an array is not rotated, mid > mid + 1 will never occur"
                    },
                    {
                        "username": "jamshidyuldashev7799",
                        "content": "Hi, it is very good.  "
                    },
                    {
                        "username": "tatkal",
                        "content": "Please change the difficulty tag to medium."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Use binary search to find the minimum element in the rotated sorted array. Check if the middle element is smaller than the element before it. If yes, then the minimum element is found. Otherwise, the check if the middle element is smaller than the last element of the array. If yes, then the search is narrowed down to the elements before the middle element. Otherwise, the search is narrowed down to the elements after the middle element. Return the first element of the array as the minimum element, since the first element will not have an element before it."
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(153)Find%20Minimum%20in%20Rotated%20sorted%20Array"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Carry3236](/Carry3236) Actually, the provided solution also works correctly for monotonically increasing arrays (a type of sorted array with no rotations). Let\\'s look at an example:\\n\\nSuppose we have the array `nums = [1,2,3,4,5]`.\\n\\nAt the beginning, `l = 0`, `r = 4`, so `mid = 2`. `nums[mid] = 3` and `nums[r] = 5`. Since `nums[mid]` is not greater than `nums[r]`, we move `r` to `mid`, which is `2`.\\n\\nIn the next iteration, `l = 0`, `r = 2`, so `mid = 1`. `nums[mid] = 2` and `nums[r] = 3`. Again, `nums[mid]` is not greater than `nums[r]`, so we move `r` to `mid`, which is `1`.\\n\\nIn the final iteration, `l = 0`, `r = 1`, so `mid = 0`. `nums[mid] = 1` and `nums[r] = 2`. `nums[mid]` is not greater than `nums[r]`, so we move `r` to `mid`, which is `0`.\\n\\nNow `l` and `r` both point to `0`, and the loop ends. We return `nums[l]`, which is `1` \\u2014 the minimum element in the array.\\n\\nThis confirms that the code does work for monotonically increasing arrays. It always finds the pivot point where the array is \"rotated\" (which, in the case of a monotonically increasing array, is the first element)."
                    },
                    {
                        "username": "Carry3236",
                        "content": "this fails in case of monotonic array ."
                    }
                ]
            },
            {
                "id": 1572020,
                "content": [
                    {
                        "username": "inomag",
                        "content": "The main idea is, the element is said to be minimum in the rotated sorted array if the previous element to it is greater than it or there is no previous element(i.e. no rotation). We can do this using Binary search\\n1. Find the mid element i.e. mid = (low+high)/2\\n2. If the (mid+1)th element is less than mid element then return (mid+1)th element\\n3. If the mid element is less than (mid-1)th element then return the mid element\\n4. If the last element is greater than mid element then search in left half\\n5. If the last element is less than mid element then search in right half\\n\\n**Time Complexity: O(logn)**\\n**Space Complexity: O(1)**\\n\\n*Solution is in the comments.*\\n\\n"
                    },
                    {
                        "username": "paawan3000",
                        "content": "ans"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Please, do not post answers in discussions.\\nPeople try to find tips here, not spoilers."
                    },
                    {
                        "username": "cagils",
                        "content": "We only need to compare mid with right one in the binary search. This will automatically handle the edge case of already sorted array.\\n\\n```\\n4 5 6 7 8 9 0 1 2 3\\nl       m         r\\nm > r => l = m + 1\\n4 5 6 7 8 9 0 1 2 3\\n          l   m   r\\nm < r => r = m\\n4 5 6 7 8 9 0 1 2 3\\n          l m r\\nm < r => r = m\\n4 5 6 7 8 9 0 1 2 3\\n          l r\\nm > r => l = m + 1\\n7 8 0 1 2 3 4 5 6\\n            lr\\nr >= l => return l\\n\\n7 8 0 1 2 3 4 5 6\\nl       m       r\\nm < r => r = m\\n7 8 0 1 2 3 4 5 6\\nl m     m\\nm > r => l = m + 1\\n7 8 0 1 2 3 4 5 6\\n    l m r\\nm < l => r = m\\n7 8 0 1 2 3 4 5 6\\n    l r\\nm < r => r = m\\n7 8 0 1 2 3 4 5 6\\n    lr\\nr >= l => return l\\n\\n8 0 1 2 3 4 5 6 7\\nl       m       r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl   m   r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl m r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl r\\nm > r => l = m + 1\\n8 0 1 2 3 4 5 6 7\\n  lr\\nr >=l => return l\\n\\n0 1 2 3 4\\nl   m   r\\nm < r => r = m\\n0 1 2 3 4\\nl m r\\nm < r => r = m\\n0 1 2 3 4\\nl r\\nm < r => r = m\\n0 1 2 3 4\\nlr\\nr >= l => return l\\n```"
                    },
                    {
                        "username": "akshaydusad",
                        "content": "Thanks a lot for this explanation, I was so confused as to why the mid was only being compared to the right."
                    },
                    {
                        "username": "punit_gautam",
                        "content": "return min(nums)"
                    },
                    {
                        "username": "aphamdd",
                        "content": "obviously this is a joke guys"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "OK.\\nNow show it during an interview :)"
                    },
                    {
                        "username": "InvaderTim1",
                        "content": "[@angeldimitrov](/angeldimitrov) I really hate the test cases on this one, they\\'re so small I couldn\\'t even visualize the while loop in action. I had to go make my own tests in VsCode."
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "[@Sarichi](/Sarichi) this solution with Python runs at \\'70% faster\\' than remainder of solutions, at the time of writing this. Sure, binary search may be more optimal in edge cases but it does not seem that the test cases reflect this. The point of leetcode is supposed to be to include test cases that include incredibly complex edge cases."
                    },
                    {
                        "username": "Sarichi",
                        "content": "It must run in O(log N) not an O(N). If we were just asked to solve it, it would have been tagged as easy. They want us to implement using a binary search."
                    },
                    {
                        "username": "GTXFORCE",
                        "content": "My code just: \"sort(nums.begin(),nums.end()); return nums[0]\". It beats 100% in CPP.\\n\\nThe key is when an array is pre-sorted, sort algorithm can almost reach its best case, no longer NlogN !!\\n\\nSame story in problem when they ask you to Merage K sorted array, Instead of using priority queue, just concatenate them and do a fast sort, and that beats 92.26% cpp files. In addition, let say those K array are in extremely bad case, where K is huge, each array only has 1 or 2 elements and the arrays are put into worst order. The performance of concatenating and sorting of course will drop a lot yet so will priority queue, and you need a lot of extra memory to keep your queue alive as well.\\n\\n\\n\\n"
                    },
                    {
                        "username": "bulgarmarc",
                        "content": "[@abzelmes](/abzelmes) it is stated that you should solve it in O(logn) which implies to not sort the list, because sorting the list takes O(nlogn) "
                    },
                    {
                        "username": "kanishk82",
                        "content": "Clearly, fastest sorting algo is O(nlogn) which is greater than a liner search O(n), but for binary search it\\'s O(logn), which is the smallest. So better use a binary search"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@abzelmes](/abzelmes) The problem requires O(log n) time so that already precludes sorting."
                    },
                    {
                        "username": "HitenTandon",
                        "content": "best case sorting time is still O(N) so you\\'re still better of just finding the smallest element linearly"
                    },
                    {
                        "username": "abzelmes",
                        "content": "Obviously this is the best solution, but I found it fun to actually try to do it without sorting. I think they need to add this to the problems requirements. That you shouldn\\'t sort the array.\\nBecause otherwise it would be an easy problem"
                    },
                    {
                        "username": "arnavk09",
                        "content": "This problem in particular is one of those rare cases when the most intuitive solution (that seems like brute force in the beginning) is the one that gives the best answer somehow"
                    },
                    {
                        "username": "faux_hubris",
                        "content": "Use Binary Search to find the largest element i.e. the pivot. The element in the array after the pivot i.e. nums[pivot + 1] is your answer. If mums[nums.Length] > nums[0], then you know it can be considered as a sorted array without rotation. In that case, simply return nums[0]."
                    },
                    {
                        "username": "jayanta1250",
                        "content": "This is not a leetcode medium question if you think. There is nothing to worry about how many times the array is rotated . you have to just find the pivot using binary search. And think in a rotated array pivot is the largest number and next after pivot is the smallest . If the array in not rotated just you have to return the 1st element because that it is the smallest element. Easy thinking. Have a good day best of luck"
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. If array is rotated, it will have two halves : increasing and decreasing. So we can compare mid and mid + 1. If mid > mid + 1, we know this is the tipping point so return mid + 1. \\n\\nThis is because if an array is not rotated, mid > mid + 1 will never occur"
                    },
                    {
                        "username": "jamshidyuldashev7799",
                        "content": "Hi, it is very good.  "
                    },
                    {
                        "username": "tatkal",
                        "content": "Please change the difficulty tag to medium."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Use binary search to find the minimum element in the rotated sorted array. Check if the middle element is smaller than the element before it. If yes, then the minimum element is found. Otherwise, the check if the middle element is smaller than the last element of the array. If yes, then the search is narrowed down to the elements before the middle element. Otherwise, the search is narrowed down to the elements after the middle element. Return the first element of the array as the minimum element, since the first element will not have an element before it."
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(153)Find%20Minimum%20in%20Rotated%20sorted%20Array"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Carry3236](/Carry3236) Actually, the provided solution also works correctly for monotonically increasing arrays (a type of sorted array with no rotations). Let\\'s look at an example:\\n\\nSuppose we have the array `nums = [1,2,3,4,5]`.\\n\\nAt the beginning, `l = 0`, `r = 4`, so `mid = 2`. `nums[mid] = 3` and `nums[r] = 5`. Since `nums[mid]` is not greater than `nums[r]`, we move `r` to `mid`, which is `2`.\\n\\nIn the next iteration, `l = 0`, `r = 2`, so `mid = 1`. `nums[mid] = 2` and `nums[r] = 3`. Again, `nums[mid]` is not greater than `nums[r]`, so we move `r` to `mid`, which is `1`.\\n\\nIn the final iteration, `l = 0`, `r = 1`, so `mid = 0`. `nums[mid] = 1` and `nums[r] = 2`. `nums[mid]` is not greater than `nums[r]`, so we move `r` to `mid`, which is `0`.\\n\\nNow `l` and `r` both point to `0`, and the loop ends. We return `nums[l]`, which is `1` \\u2014 the minimum element in the array.\\n\\nThis confirms that the code does work for monotonically increasing arrays. It always finds the pivot point where the array is \"rotated\" (which, in the case of a monotonically increasing array, is the first element)."
                    },
                    {
                        "username": "Carry3236",
                        "content": "this fails in case of monotonic array ."
                    }
                ]
            },
            {
                "id": 1676329,
                "content": [
                    {
                        "username": "inomag",
                        "content": "The main idea is, the element is said to be minimum in the rotated sorted array if the previous element to it is greater than it or there is no previous element(i.e. no rotation). We can do this using Binary search\\n1. Find the mid element i.e. mid = (low+high)/2\\n2. If the (mid+1)th element is less than mid element then return (mid+1)th element\\n3. If the mid element is less than (mid-1)th element then return the mid element\\n4. If the last element is greater than mid element then search in left half\\n5. If the last element is less than mid element then search in right half\\n\\n**Time Complexity: O(logn)**\\n**Space Complexity: O(1)**\\n\\n*Solution is in the comments.*\\n\\n"
                    },
                    {
                        "username": "paawan3000",
                        "content": "ans"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Please, do not post answers in discussions.\\nPeople try to find tips here, not spoilers."
                    },
                    {
                        "username": "cagils",
                        "content": "We only need to compare mid with right one in the binary search. This will automatically handle the edge case of already sorted array.\\n\\n```\\n4 5 6 7 8 9 0 1 2 3\\nl       m         r\\nm > r => l = m + 1\\n4 5 6 7 8 9 0 1 2 3\\n          l   m   r\\nm < r => r = m\\n4 5 6 7 8 9 0 1 2 3\\n          l m r\\nm < r => r = m\\n4 5 6 7 8 9 0 1 2 3\\n          l r\\nm > r => l = m + 1\\n7 8 0 1 2 3 4 5 6\\n            lr\\nr >= l => return l\\n\\n7 8 0 1 2 3 4 5 6\\nl       m       r\\nm < r => r = m\\n7 8 0 1 2 3 4 5 6\\nl m     m\\nm > r => l = m + 1\\n7 8 0 1 2 3 4 5 6\\n    l m r\\nm < l => r = m\\n7 8 0 1 2 3 4 5 6\\n    l r\\nm < r => r = m\\n7 8 0 1 2 3 4 5 6\\n    lr\\nr >= l => return l\\n\\n8 0 1 2 3 4 5 6 7\\nl       m       r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl   m   r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl m r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl r\\nm > r => l = m + 1\\n8 0 1 2 3 4 5 6 7\\n  lr\\nr >=l => return l\\n\\n0 1 2 3 4\\nl   m   r\\nm < r => r = m\\n0 1 2 3 4\\nl m r\\nm < r => r = m\\n0 1 2 3 4\\nl r\\nm < r => r = m\\n0 1 2 3 4\\nlr\\nr >= l => return l\\n```"
                    },
                    {
                        "username": "akshaydusad",
                        "content": "Thanks a lot for this explanation, I was so confused as to why the mid was only being compared to the right."
                    },
                    {
                        "username": "punit_gautam",
                        "content": "return min(nums)"
                    },
                    {
                        "username": "aphamdd",
                        "content": "obviously this is a joke guys"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "OK.\\nNow show it during an interview :)"
                    },
                    {
                        "username": "InvaderTim1",
                        "content": "[@angeldimitrov](/angeldimitrov) I really hate the test cases on this one, they\\'re so small I couldn\\'t even visualize the while loop in action. I had to go make my own tests in VsCode."
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "[@Sarichi](/Sarichi) this solution with Python runs at \\'70% faster\\' than remainder of solutions, at the time of writing this. Sure, binary search may be more optimal in edge cases but it does not seem that the test cases reflect this. The point of leetcode is supposed to be to include test cases that include incredibly complex edge cases."
                    },
                    {
                        "username": "Sarichi",
                        "content": "It must run in O(log N) not an O(N). If we were just asked to solve it, it would have been tagged as easy. They want us to implement using a binary search."
                    },
                    {
                        "username": "GTXFORCE",
                        "content": "My code just: \"sort(nums.begin(),nums.end()); return nums[0]\". It beats 100% in CPP.\\n\\nThe key is when an array is pre-sorted, sort algorithm can almost reach its best case, no longer NlogN !!\\n\\nSame story in problem when they ask you to Merage K sorted array, Instead of using priority queue, just concatenate them and do a fast sort, and that beats 92.26% cpp files. In addition, let say those K array are in extremely bad case, where K is huge, each array only has 1 or 2 elements and the arrays are put into worst order. The performance of concatenating and sorting of course will drop a lot yet so will priority queue, and you need a lot of extra memory to keep your queue alive as well.\\n\\n\\n\\n"
                    },
                    {
                        "username": "bulgarmarc",
                        "content": "[@abzelmes](/abzelmes) it is stated that you should solve it in O(logn) which implies to not sort the list, because sorting the list takes O(nlogn) "
                    },
                    {
                        "username": "kanishk82",
                        "content": "Clearly, fastest sorting algo is O(nlogn) which is greater than a liner search O(n), but for binary search it\\'s O(logn), which is the smallest. So better use a binary search"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@abzelmes](/abzelmes) The problem requires O(log n) time so that already precludes sorting."
                    },
                    {
                        "username": "HitenTandon",
                        "content": "best case sorting time is still O(N) so you\\'re still better of just finding the smallest element linearly"
                    },
                    {
                        "username": "abzelmes",
                        "content": "Obviously this is the best solution, but I found it fun to actually try to do it without sorting. I think they need to add this to the problems requirements. That you shouldn\\'t sort the array.\\nBecause otherwise it would be an easy problem"
                    },
                    {
                        "username": "arnavk09",
                        "content": "This problem in particular is one of those rare cases when the most intuitive solution (that seems like brute force in the beginning) is the one that gives the best answer somehow"
                    },
                    {
                        "username": "faux_hubris",
                        "content": "Use Binary Search to find the largest element i.e. the pivot. The element in the array after the pivot i.e. nums[pivot + 1] is your answer. If mums[nums.Length] > nums[0], then you know it can be considered as a sorted array without rotation. In that case, simply return nums[0]."
                    },
                    {
                        "username": "jayanta1250",
                        "content": "This is not a leetcode medium question if you think. There is nothing to worry about how many times the array is rotated . you have to just find the pivot using binary search. And think in a rotated array pivot is the largest number and next after pivot is the smallest . If the array in not rotated just you have to return the 1st element because that it is the smallest element. Easy thinking. Have a good day best of luck"
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. If array is rotated, it will have two halves : increasing and decreasing. So we can compare mid and mid + 1. If mid > mid + 1, we know this is the tipping point so return mid + 1. \\n\\nThis is because if an array is not rotated, mid > mid + 1 will never occur"
                    },
                    {
                        "username": "jamshidyuldashev7799",
                        "content": "Hi, it is very good.  "
                    },
                    {
                        "username": "tatkal",
                        "content": "Please change the difficulty tag to medium."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Use binary search to find the minimum element in the rotated sorted array. Check if the middle element is smaller than the element before it. If yes, then the minimum element is found. Otherwise, the check if the middle element is smaller than the last element of the array. If yes, then the search is narrowed down to the elements before the middle element. Otherwise, the search is narrowed down to the elements after the middle element. Return the first element of the array as the minimum element, since the first element will not have an element before it."
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(153)Find%20Minimum%20in%20Rotated%20sorted%20Array"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Carry3236](/Carry3236) Actually, the provided solution also works correctly for monotonically increasing arrays (a type of sorted array with no rotations). Let\\'s look at an example:\\n\\nSuppose we have the array `nums = [1,2,3,4,5]`.\\n\\nAt the beginning, `l = 0`, `r = 4`, so `mid = 2`. `nums[mid] = 3` and `nums[r] = 5`. Since `nums[mid]` is not greater than `nums[r]`, we move `r` to `mid`, which is `2`.\\n\\nIn the next iteration, `l = 0`, `r = 2`, so `mid = 1`. `nums[mid] = 2` and `nums[r] = 3`. Again, `nums[mid]` is not greater than `nums[r]`, so we move `r` to `mid`, which is `1`.\\n\\nIn the final iteration, `l = 0`, `r = 1`, so `mid = 0`. `nums[mid] = 1` and `nums[r] = 2`. `nums[mid]` is not greater than `nums[r]`, so we move `r` to `mid`, which is `0`.\\n\\nNow `l` and `r` both point to `0`, and the loop ends. We return `nums[l]`, which is `1` \\u2014 the minimum element in the array.\\n\\nThis confirms that the code does work for monotonically increasing arrays. It always finds the pivot point where the array is \"rotated\" (which, in the case of a monotonically increasing array, is the first element)."
                    },
                    {
                        "username": "Carry3236",
                        "content": "this fails in case of monotonic array ."
                    }
                ]
            },
            {
                "id": 1896652,
                "content": [
                    {
                        "username": "inomag",
                        "content": "The main idea is, the element is said to be minimum in the rotated sorted array if the previous element to it is greater than it or there is no previous element(i.e. no rotation). We can do this using Binary search\\n1. Find the mid element i.e. mid = (low+high)/2\\n2. If the (mid+1)th element is less than mid element then return (mid+1)th element\\n3. If the mid element is less than (mid-1)th element then return the mid element\\n4. If the last element is greater than mid element then search in left half\\n5. If the last element is less than mid element then search in right half\\n\\n**Time Complexity: O(logn)**\\n**Space Complexity: O(1)**\\n\\n*Solution is in the comments.*\\n\\n"
                    },
                    {
                        "username": "paawan3000",
                        "content": "ans"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Please, do not post answers in discussions.\\nPeople try to find tips here, not spoilers."
                    },
                    {
                        "username": "cagils",
                        "content": "We only need to compare mid with right one in the binary search. This will automatically handle the edge case of already sorted array.\\n\\n```\\n4 5 6 7 8 9 0 1 2 3\\nl       m         r\\nm > r => l = m + 1\\n4 5 6 7 8 9 0 1 2 3\\n          l   m   r\\nm < r => r = m\\n4 5 6 7 8 9 0 1 2 3\\n          l m r\\nm < r => r = m\\n4 5 6 7 8 9 0 1 2 3\\n          l r\\nm > r => l = m + 1\\n7 8 0 1 2 3 4 5 6\\n            lr\\nr >= l => return l\\n\\n7 8 0 1 2 3 4 5 6\\nl       m       r\\nm < r => r = m\\n7 8 0 1 2 3 4 5 6\\nl m     m\\nm > r => l = m + 1\\n7 8 0 1 2 3 4 5 6\\n    l m r\\nm < l => r = m\\n7 8 0 1 2 3 4 5 6\\n    l r\\nm < r => r = m\\n7 8 0 1 2 3 4 5 6\\n    lr\\nr >= l => return l\\n\\n8 0 1 2 3 4 5 6 7\\nl       m       r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl   m   r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl m r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl r\\nm > r => l = m + 1\\n8 0 1 2 3 4 5 6 7\\n  lr\\nr >=l => return l\\n\\n0 1 2 3 4\\nl   m   r\\nm < r => r = m\\n0 1 2 3 4\\nl m r\\nm < r => r = m\\n0 1 2 3 4\\nl r\\nm < r => r = m\\n0 1 2 3 4\\nlr\\nr >= l => return l\\n```"
                    },
                    {
                        "username": "akshaydusad",
                        "content": "Thanks a lot for this explanation, I was so confused as to why the mid was only being compared to the right."
                    },
                    {
                        "username": "punit_gautam",
                        "content": "return min(nums)"
                    },
                    {
                        "username": "aphamdd",
                        "content": "obviously this is a joke guys"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "OK.\\nNow show it during an interview :)"
                    },
                    {
                        "username": "InvaderTim1",
                        "content": "[@angeldimitrov](/angeldimitrov) I really hate the test cases on this one, they\\'re so small I couldn\\'t even visualize the while loop in action. I had to go make my own tests in VsCode."
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "[@Sarichi](/Sarichi) this solution with Python runs at \\'70% faster\\' than remainder of solutions, at the time of writing this. Sure, binary search may be more optimal in edge cases but it does not seem that the test cases reflect this. The point of leetcode is supposed to be to include test cases that include incredibly complex edge cases."
                    },
                    {
                        "username": "Sarichi",
                        "content": "It must run in O(log N) not an O(N). If we were just asked to solve it, it would have been tagged as easy. They want us to implement using a binary search."
                    },
                    {
                        "username": "GTXFORCE",
                        "content": "My code just: \"sort(nums.begin(),nums.end()); return nums[0]\". It beats 100% in CPP.\\n\\nThe key is when an array is pre-sorted, sort algorithm can almost reach its best case, no longer NlogN !!\\n\\nSame story in problem when they ask you to Merage K sorted array, Instead of using priority queue, just concatenate them and do a fast sort, and that beats 92.26% cpp files. In addition, let say those K array are in extremely bad case, where K is huge, each array only has 1 or 2 elements and the arrays are put into worst order. The performance of concatenating and sorting of course will drop a lot yet so will priority queue, and you need a lot of extra memory to keep your queue alive as well.\\n\\n\\n\\n"
                    },
                    {
                        "username": "bulgarmarc",
                        "content": "[@abzelmes](/abzelmes) it is stated that you should solve it in O(logn) which implies to not sort the list, because sorting the list takes O(nlogn) "
                    },
                    {
                        "username": "kanishk82",
                        "content": "Clearly, fastest sorting algo is O(nlogn) which is greater than a liner search O(n), but for binary search it\\'s O(logn), which is the smallest. So better use a binary search"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@abzelmes](/abzelmes) The problem requires O(log n) time so that already precludes sorting."
                    },
                    {
                        "username": "HitenTandon",
                        "content": "best case sorting time is still O(N) so you\\'re still better of just finding the smallest element linearly"
                    },
                    {
                        "username": "abzelmes",
                        "content": "Obviously this is the best solution, but I found it fun to actually try to do it without sorting. I think they need to add this to the problems requirements. That you shouldn\\'t sort the array.\\nBecause otherwise it would be an easy problem"
                    },
                    {
                        "username": "arnavk09",
                        "content": "This problem in particular is one of those rare cases when the most intuitive solution (that seems like brute force in the beginning) is the one that gives the best answer somehow"
                    },
                    {
                        "username": "faux_hubris",
                        "content": "Use Binary Search to find the largest element i.e. the pivot. The element in the array after the pivot i.e. nums[pivot + 1] is your answer. If mums[nums.Length] > nums[0], then you know it can be considered as a sorted array without rotation. In that case, simply return nums[0]."
                    },
                    {
                        "username": "jayanta1250",
                        "content": "This is not a leetcode medium question if you think. There is nothing to worry about how many times the array is rotated . you have to just find the pivot using binary search. And think in a rotated array pivot is the largest number and next after pivot is the smallest . If the array in not rotated just you have to return the 1st element because that it is the smallest element. Easy thinking. Have a good day best of luck"
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. If array is rotated, it will have two halves : increasing and decreasing. So we can compare mid and mid + 1. If mid > mid + 1, we know this is the tipping point so return mid + 1. \\n\\nThis is because if an array is not rotated, mid > mid + 1 will never occur"
                    },
                    {
                        "username": "jamshidyuldashev7799",
                        "content": "Hi, it is very good.  "
                    },
                    {
                        "username": "tatkal",
                        "content": "Please change the difficulty tag to medium."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Use binary search to find the minimum element in the rotated sorted array. Check if the middle element is smaller than the element before it. If yes, then the minimum element is found. Otherwise, the check if the middle element is smaller than the last element of the array. If yes, then the search is narrowed down to the elements before the middle element. Otherwise, the search is narrowed down to the elements after the middle element. Return the first element of the array as the minimum element, since the first element will not have an element before it."
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(153)Find%20Minimum%20in%20Rotated%20sorted%20Array"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Carry3236](/Carry3236) Actually, the provided solution also works correctly for monotonically increasing arrays (a type of sorted array with no rotations). Let\\'s look at an example:\\n\\nSuppose we have the array `nums = [1,2,3,4,5]`.\\n\\nAt the beginning, `l = 0`, `r = 4`, so `mid = 2`. `nums[mid] = 3` and `nums[r] = 5`. Since `nums[mid]` is not greater than `nums[r]`, we move `r` to `mid`, which is `2`.\\n\\nIn the next iteration, `l = 0`, `r = 2`, so `mid = 1`. `nums[mid] = 2` and `nums[r] = 3`. Again, `nums[mid]` is not greater than `nums[r]`, so we move `r` to `mid`, which is `1`.\\n\\nIn the final iteration, `l = 0`, `r = 1`, so `mid = 0`. `nums[mid] = 1` and `nums[r] = 2`. `nums[mid]` is not greater than `nums[r]`, so we move `r` to `mid`, which is `0`.\\n\\nNow `l` and `r` both point to `0`, and the loop ends. We return `nums[l]`, which is `1` \\u2014 the minimum element in the array.\\n\\nThis confirms that the code does work for monotonically increasing arrays. It always finds the pivot point where the array is \"rotated\" (which, in the case of a monotonically increasing array, is the first element)."
                    },
                    {
                        "username": "Carry3236",
                        "content": "this fails in case of monotonic array ."
                    }
                ]
            },
            {
                "id": 1574706,
                "content": [
                    {
                        "username": "inomag",
                        "content": "The main idea is, the element is said to be minimum in the rotated sorted array if the previous element to it is greater than it or there is no previous element(i.e. no rotation). We can do this using Binary search\\n1. Find the mid element i.e. mid = (low+high)/2\\n2. If the (mid+1)th element is less than mid element then return (mid+1)th element\\n3. If the mid element is less than (mid-1)th element then return the mid element\\n4. If the last element is greater than mid element then search in left half\\n5. If the last element is less than mid element then search in right half\\n\\n**Time Complexity: O(logn)**\\n**Space Complexity: O(1)**\\n\\n*Solution is in the comments.*\\n\\n"
                    },
                    {
                        "username": "paawan3000",
                        "content": "ans"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Please, do not post answers in discussions.\\nPeople try to find tips here, not spoilers."
                    },
                    {
                        "username": "cagils",
                        "content": "We only need to compare mid with right one in the binary search. This will automatically handle the edge case of already sorted array.\\n\\n```\\n4 5 6 7 8 9 0 1 2 3\\nl       m         r\\nm > r => l = m + 1\\n4 5 6 7 8 9 0 1 2 3\\n          l   m   r\\nm < r => r = m\\n4 5 6 7 8 9 0 1 2 3\\n          l m r\\nm < r => r = m\\n4 5 6 7 8 9 0 1 2 3\\n          l r\\nm > r => l = m + 1\\n7 8 0 1 2 3 4 5 6\\n            lr\\nr >= l => return l\\n\\n7 8 0 1 2 3 4 5 6\\nl       m       r\\nm < r => r = m\\n7 8 0 1 2 3 4 5 6\\nl m     m\\nm > r => l = m + 1\\n7 8 0 1 2 3 4 5 6\\n    l m r\\nm < l => r = m\\n7 8 0 1 2 3 4 5 6\\n    l r\\nm < r => r = m\\n7 8 0 1 2 3 4 5 6\\n    lr\\nr >= l => return l\\n\\n8 0 1 2 3 4 5 6 7\\nl       m       r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl   m   r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl m r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl r\\nm > r => l = m + 1\\n8 0 1 2 3 4 5 6 7\\n  lr\\nr >=l => return l\\n\\n0 1 2 3 4\\nl   m   r\\nm < r => r = m\\n0 1 2 3 4\\nl m r\\nm < r => r = m\\n0 1 2 3 4\\nl r\\nm < r => r = m\\n0 1 2 3 4\\nlr\\nr >= l => return l\\n```"
                    },
                    {
                        "username": "akshaydusad",
                        "content": "Thanks a lot for this explanation, I was so confused as to why the mid was only being compared to the right."
                    },
                    {
                        "username": "punit_gautam",
                        "content": "return min(nums)"
                    },
                    {
                        "username": "aphamdd",
                        "content": "obviously this is a joke guys"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "OK.\\nNow show it during an interview :)"
                    },
                    {
                        "username": "InvaderTim1",
                        "content": "[@angeldimitrov](/angeldimitrov) I really hate the test cases on this one, they\\'re so small I couldn\\'t even visualize the while loop in action. I had to go make my own tests in VsCode."
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "[@Sarichi](/Sarichi) this solution with Python runs at \\'70% faster\\' than remainder of solutions, at the time of writing this. Sure, binary search may be more optimal in edge cases but it does not seem that the test cases reflect this. The point of leetcode is supposed to be to include test cases that include incredibly complex edge cases."
                    },
                    {
                        "username": "Sarichi",
                        "content": "It must run in O(log N) not an O(N). If we were just asked to solve it, it would have been tagged as easy. They want us to implement using a binary search."
                    },
                    {
                        "username": "GTXFORCE",
                        "content": "My code just: \"sort(nums.begin(),nums.end()); return nums[0]\". It beats 100% in CPP.\\n\\nThe key is when an array is pre-sorted, sort algorithm can almost reach its best case, no longer NlogN !!\\n\\nSame story in problem when they ask you to Merage K sorted array, Instead of using priority queue, just concatenate them and do a fast sort, and that beats 92.26% cpp files. In addition, let say those K array are in extremely bad case, where K is huge, each array only has 1 or 2 elements and the arrays are put into worst order. The performance of concatenating and sorting of course will drop a lot yet so will priority queue, and you need a lot of extra memory to keep your queue alive as well.\\n\\n\\n\\n"
                    },
                    {
                        "username": "bulgarmarc",
                        "content": "[@abzelmes](/abzelmes) it is stated that you should solve it in O(logn) which implies to not sort the list, because sorting the list takes O(nlogn) "
                    },
                    {
                        "username": "kanishk82",
                        "content": "Clearly, fastest sorting algo is O(nlogn) which is greater than a liner search O(n), but for binary search it\\'s O(logn), which is the smallest. So better use a binary search"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@abzelmes](/abzelmes) The problem requires O(log n) time so that already precludes sorting."
                    },
                    {
                        "username": "HitenTandon",
                        "content": "best case sorting time is still O(N) so you\\'re still better of just finding the smallest element linearly"
                    },
                    {
                        "username": "abzelmes",
                        "content": "Obviously this is the best solution, but I found it fun to actually try to do it without sorting. I think they need to add this to the problems requirements. That you shouldn\\'t sort the array.\\nBecause otherwise it would be an easy problem"
                    },
                    {
                        "username": "arnavk09",
                        "content": "This problem in particular is one of those rare cases when the most intuitive solution (that seems like brute force in the beginning) is the one that gives the best answer somehow"
                    },
                    {
                        "username": "faux_hubris",
                        "content": "Use Binary Search to find the largest element i.e. the pivot. The element in the array after the pivot i.e. nums[pivot + 1] is your answer. If mums[nums.Length] > nums[0], then you know it can be considered as a sorted array without rotation. In that case, simply return nums[0]."
                    },
                    {
                        "username": "jayanta1250",
                        "content": "This is not a leetcode medium question if you think. There is nothing to worry about how many times the array is rotated . you have to just find the pivot using binary search. And think in a rotated array pivot is the largest number and next after pivot is the smallest . If the array in not rotated just you have to return the 1st element because that it is the smallest element. Easy thinking. Have a good day best of luck"
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. If array is rotated, it will have two halves : increasing and decreasing. So we can compare mid and mid + 1. If mid > mid + 1, we know this is the tipping point so return mid + 1. \\n\\nThis is because if an array is not rotated, mid > mid + 1 will never occur"
                    },
                    {
                        "username": "jamshidyuldashev7799",
                        "content": "Hi, it is very good.  "
                    },
                    {
                        "username": "tatkal",
                        "content": "Please change the difficulty tag to medium."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Use binary search to find the minimum element in the rotated sorted array. Check if the middle element is smaller than the element before it. If yes, then the minimum element is found. Otherwise, the check if the middle element is smaller than the last element of the array. If yes, then the search is narrowed down to the elements before the middle element. Otherwise, the search is narrowed down to the elements after the middle element. Return the first element of the array as the minimum element, since the first element will not have an element before it."
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(153)Find%20Minimum%20in%20Rotated%20sorted%20Array"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Carry3236](/Carry3236) Actually, the provided solution also works correctly for monotonically increasing arrays (a type of sorted array with no rotations). Let\\'s look at an example:\\n\\nSuppose we have the array `nums = [1,2,3,4,5]`.\\n\\nAt the beginning, `l = 0`, `r = 4`, so `mid = 2`. `nums[mid] = 3` and `nums[r] = 5`. Since `nums[mid]` is not greater than `nums[r]`, we move `r` to `mid`, which is `2`.\\n\\nIn the next iteration, `l = 0`, `r = 2`, so `mid = 1`. `nums[mid] = 2` and `nums[r] = 3`. Again, `nums[mid]` is not greater than `nums[r]`, so we move `r` to `mid`, which is `1`.\\n\\nIn the final iteration, `l = 0`, `r = 1`, so `mid = 0`. `nums[mid] = 1` and `nums[r] = 2`. `nums[mid]` is not greater than `nums[r]`, so we move `r` to `mid`, which is `0`.\\n\\nNow `l` and `r` both point to `0`, and the loop ends. We return `nums[l]`, which is `1` \\u2014 the minimum element in the array.\\n\\nThis confirms that the code does work for monotonically increasing arrays. It always finds the pivot point where the array is \"rotated\" (which, in the case of a monotonically increasing array, is the first element)."
                    },
                    {
                        "username": "Carry3236",
                        "content": "this fails in case of monotonic array ."
                    }
                ]
            },
            {
                "id": 1974186,
                "content": [
                    {
                        "username": "inomag",
                        "content": "The main idea is, the element is said to be minimum in the rotated sorted array if the previous element to it is greater than it or there is no previous element(i.e. no rotation). We can do this using Binary search\\n1. Find the mid element i.e. mid = (low+high)/2\\n2. If the (mid+1)th element is less than mid element then return (mid+1)th element\\n3. If the mid element is less than (mid-1)th element then return the mid element\\n4. If the last element is greater than mid element then search in left half\\n5. If the last element is less than mid element then search in right half\\n\\n**Time Complexity: O(logn)**\\n**Space Complexity: O(1)**\\n\\n*Solution is in the comments.*\\n\\n"
                    },
                    {
                        "username": "paawan3000",
                        "content": "ans"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Please, do not post answers in discussions.\\nPeople try to find tips here, not spoilers."
                    },
                    {
                        "username": "cagils",
                        "content": "We only need to compare mid with right one in the binary search. This will automatically handle the edge case of already sorted array.\\n\\n```\\n4 5 6 7 8 9 0 1 2 3\\nl       m         r\\nm > r => l = m + 1\\n4 5 6 7 8 9 0 1 2 3\\n          l   m   r\\nm < r => r = m\\n4 5 6 7 8 9 0 1 2 3\\n          l m r\\nm < r => r = m\\n4 5 6 7 8 9 0 1 2 3\\n          l r\\nm > r => l = m + 1\\n7 8 0 1 2 3 4 5 6\\n            lr\\nr >= l => return l\\n\\n7 8 0 1 2 3 4 5 6\\nl       m       r\\nm < r => r = m\\n7 8 0 1 2 3 4 5 6\\nl m     m\\nm > r => l = m + 1\\n7 8 0 1 2 3 4 5 6\\n    l m r\\nm < l => r = m\\n7 8 0 1 2 3 4 5 6\\n    l r\\nm < r => r = m\\n7 8 0 1 2 3 4 5 6\\n    lr\\nr >= l => return l\\n\\n8 0 1 2 3 4 5 6 7\\nl       m       r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl   m   r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl m r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl r\\nm > r => l = m + 1\\n8 0 1 2 3 4 5 6 7\\n  lr\\nr >=l => return l\\n\\n0 1 2 3 4\\nl   m   r\\nm < r => r = m\\n0 1 2 3 4\\nl m r\\nm < r => r = m\\n0 1 2 3 4\\nl r\\nm < r => r = m\\n0 1 2 3 4\\nlr\\nr >= l => return l\\n```"
                    },
                    {
                        "username": "akshaydusad",
                        "content": "Thanks a lot for this explanation, I was so confused as to why the mid was only being compared to the right."
                    },
                    {
                        "username": "punit_gautam",
                        "content": "return min(nums)"
                    },
                    {
                        "username": "aphamdd",
                        "content": "obviously this is a joke guys"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "OK.\\nNow show it during an interview :)"
                    },
                    {
                        "username": "InvaderTim1",
                        "content": "[@angeldimitrov](/angeldimitrov) I really hate the test cases on this one, they\\'re so small I couldn\\'t even visualize the while loop in action. I had to go make my own tests in VsCode."
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "[@Sarichi](/Sarichi) this solution with Python runs at \\'70% faster\\' than remainder of solutions, at the time of writing this. Sure, binary search may be more optimal in edge cases but it does not seem that the test cases reflect this. The point of leetcode is supposed to be to include test cases that include incredibly complex edge cases."
                    },
                    {
                        "username": "Sarichi",
                        "content": "It must run in O(log N) not an O(N). If we were just asked to solve it, it would have been tagged as easy. They want us to implement using a binary search."
                    },
                    {
                        "username": "GTXFORCE",
                        "content": "My code just: \"sort(nums.begin(),nums.end()); return nums[0]\". It beats 100% in CPP.\\n\\nThe key is when an array is pre-sorted, sort algorithm can almost reach its best case, no longer NlogN !!\\n\\nSame story in problem when they ask you to Merage K sorted array, Instead of using priority queue, just concatenate them and do a fast sort, and that beats 92.26% cpp files. In addition, let say those K array are in extremely bad case, where K is huge, each array only has 1 or 2 elements and the arrays are put into worst order. The performance of concatenating and sorting of course will drop a lot yet so will priority queue, and you need a lot of extra memory to keep your queue alive as well.\\n\\n\\n\\n"
                    },
                    {
                        "username": "bulgarmarc",
                        "content": "[@abzelmes](/abzelmes) it is stated that you should solve it in O(logn) which implies to not sort the list, because sorting the list takes O(nlogn) "
                    },
                    {
                        "username": "kanishk82",
                        "content": "Clearly, fastest sorting algo is O(nlogn) which is greater than a liner search O(n), but for binary search it\\'s O(logn), which is the smallest. So better use a binary search"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@abzelmes](/abzelmes) The problem requires O(log n) time so that already precludes sorting."
                    },
                    {
                        "username": "HitenTandon",
                        "content": "best case sorting time is still O(N) so you\\'re still better of just finding the smallest element linearly"
                    },
                    {
                        "username": "abzelmes",
                        "content": "Obviously this is the best solution, but I found it fun to actually try to do it without sorting. I think they need to add this to the problems requirements. That you shouldn\\'t sort the array.\\nBecause otherwise it would be an easy problem"
                    },
                    {
                        "username": "arnavk09",
                        "content": "This problem in particular is one of those rare cases when the most intuitive solution (that seems like brute force in the beginning) is the one that gives the best answer somehow"
                    },
                    {
                        "username": "faux_hubris",
                        "content": "Use Binary Search to find the largest element i.e. the pivot. The element in the array after the pivot i.e. nums[pivot + 1] is your answer. If mums[nums.Length] > nums[0], then you know it can be considered as a sorted array without rotation. In that case, simply return nums[0]."
                    },
                    {
                        "username": "jayanta1250",
                        "content": "This is not a leetcode medium question if you think. There is nothing to worry about how many times the array is rotated . you have to just find the pivot using binary search. And think in a rotated array pivot is the largest number and next after pivot is the smallest . If the array in not rotated just you have to return the 1st element because that it is the smallest element. Easy thinking. Have a good day best of luck"
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. If array is rotated, it will have two halves : increasing and decreasing. So we can compare mid and mid + 1. If mid > mid + 1, we know this is the tipping point so return mid + 1. \\n\\nThis is because if an array is not rotated, mid > mid + 1 will never occur"
                    },
                    {
                        "username": "jamshidyuldashev7799",
                        "content": "Hi, it is very good.  "
                    },
                    {
                        "username": "tatkal",
                        "content": "Please change the difficulty tag to medium."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Use binary search to find the minimum element in the rotated sorted array. Check if the middle element is smaller than the element before it. If yes, then the minimum element is found. Otherwise, the check if the middle element is smaller than the last element of the array. If yes, then the search is narrowed down to the elements before the middle element. Otherwise, the search is narrowed down to the elements after the middle element. Return the first element of the array as the minimum element, since the first element will not have an element before it."
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(153)Find%20Minimum%20in%20Rotated%20sorted%20Array"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Carry3236](/Carry3236) Actually, the provided solution also works correctly for monotonically increasing arrays (a type of sorted array with no rotations). Let\\'s look at an example:\\n\\nSuppose we have the array `nums = [1,2,3,4,5]`.\\n\\nAt the beginning, `l = 0`, `r = 4`, so `mid = 2`. `nums[mid] = 3` and `nums[r] = 5`. Since `nums[mid]` is not greater than `nums[r]`, we move `r` to `mid`, which is `2`.\\n\\nIn the next iteration, `l = 0`, `r = 2`, so `mid = 1`. `nums[mid] = 2` and `nums[r] = 3`. Again, `nums[mid]` is not greater than `nums[r]`, so we move `r` to `mid`, which is `1`.\\n\\nIn the final iteration, `l = 0`, `r = 1`, so `mid = 0`. `nums[mid] = 1` and `nums[r] = 2`. `nums[mid]` is not greater than `nums[r]`, so we move `r` to `mid`, which is `0`.\\n\\nNow `l` and `r` both point to `0`, and the loop ends. We return `nums[l]`, which is `1` \\u2014 the minimum element in the array.\\n\\nThis confirms that the code does work for monotonically increasing arrays. It always finds the pivot point where the array is \"rotated\" (which, in the case of a monotonically increasing array, is the first element)."
                    },
                    {
                        "username": "Carry3236",
                        "content": "this fails in case of monotonic array ."
                    }
                ]
            },
            {
                "id": 1575090,
                "content": [
                    {
                        "username": "inomag",
                        "content": "The main idea is, the element is said to be minimum in the rotated sorted array if the previous element to it is greater than it or there is no previous element(i.e. no rotation). We can do this using Binary search\\n1. Find the mid element i.e. mid = (low+high)/2\\n2. If the (mid+1)th element is less than mid element then return (mid+1)th element\\n3. If the mid element is less than (mid-1)th element then return the mid element\\n4. If the last element is greater than mid element then search in left half\\n5. If the last element is less than mid element then search in right half\\n\\n**Time Complexity: O(logn)**\\n**Space Complexity: O(1)**\\n\\n*Solution is in the comments.*\\n\\n"
                    },
                    {
                        "username": "paawan3000",
                        "content": "ans"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Please, do not post answers in discussions.\\nPeople try to find tips here, not spoilers."
                    },
                    {
                        "username": "cagils",
                        "content": "We only need to compare mid with right one in the binary search. This will automatically handle the edge case of already sorted array.\\n\\n```\\n4 5 6 7 8 9 0 1 2 3\\nl       m         r\\nm > r => l = m + 1\\n4 5 6 7 8 9 0 1 2 3\\n          l   m   r\\nm < r => r = m\\n4 5 6 7 8 9 0 1 2 3\\n          l m r\\nm < r => r = m\\n4 5 6 7 8 9 0 1 2 3\\n          l r\\nm > r => l = m + 1\\n7 8 0 1 2 3 4 5 6\\n            lr\\nr >= l => return l\\n\\n7 8 0 1 2 3 4 5 6\\nl       m       r\\nm < r => r = m\\n7 8 0 1 2 3 4 5 6\\nl m     m\\nm > r => l = m + 1\\n7 8 0 1 2 3 4 5 6\\n    l m r\\nm < l => r = m\\n7 8 0 1 2 3 4 5 6\\n    l r\\nm < r => r = m\\n7 8 0 1 2 3 4 5 6\\n    lr\\nr >= l => return l\\n\\n8 0 1 2 3 4 5 6 7\\nl       m       r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl   m   r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl m r\\nm < r => r = m\\n8 0 1 2 3 4 5 6 7\\nl r\\nm > r => l = m + 1\\n8 0 1 2 3 4 5 6 7\\n  lr\\nr >=l => return l\\n\\n0 1 2 3 4\\nl   m   r\\nm < r => r = m\\n0 1 2 3 4\\nl m r\\nm < r => r = m\\n0 1 2 3 4\\nl r\\nm < r => r = m\\n0 1 2 3 4\\nlr\\nr >= l => return l\\n```"
                    },
                    {
                        "username": "akshaydusad",
                        "content": "Thanks a lot for this explanation, I was so confused as to why the mid was only being compared to the right."
                    },
                    {
                        "username": "punit_gautam",
                        "content": "return min(nums)"
                    },
                    {
                        "username": "aphamdd",
                        "content": "obviously this is a joke guys"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "OK.\\nNow show it during an interview :)"
                    },
                    {
                        "username": "InvaderTim1",
                        "content": "[@angeldimitrov](/angeldimitrov) I really hate the test cases on this one, they\\'re so small I couldn\\'t even visualize the while loop in action. I had to go make my own tests in VsCode."
                    },
                    {
                        "username": "angeldimitrov",
                        "content": "[@Sarichi](/Sarichi) this solution with Python runs at \\'70% faster\\' than remainder of solutions, at the time of writing this. Sure, binary search may be more optimal in edge cases but it does not seem that the test cases reflect this. The point of leetcode is supposed to be to include test cases that include incredibly complex edge cases."
                    },
                    {
                        "username": "Sarichi",
                        "content": "It must run in O(log N) not an O(N). If we were just asked to solve it, it would have been tagged as easy. They want us to implement using a binary search."
                    },
                    {
                        "username": "GTXFORCE",
                        "content": "My code just: \"sort(nums.begin(),nums.end()); return nums[0]\". It beats 100% in CPP.\\n\\nThe key is when an array is pre-sorted, sort algorithm can almost reach its best case, no longer NlogN !!\\n\\nSame story in problem when they ask you to Merage K sorted array, Instead of using priority queue, just concatenate them and do a fast sort, and that beats 92.26% cpp files. In addition, let say those K array are in extremely bad case, where K is huge, each array only has 1 or 2 elements and the arrays are put into worst order. The performance of concatenating and sorting of course will drop a lot yet so will priority queue, and you need a lot of extra memory to keep your queue alive as well.\\n\\n\\n\\n"
                    },
                    {
                        "username": "bulgarmarc",
                        "content": "[@abzelmes](/abzelmes) it is stated that you should solve it in O(logn) which implies to not sort the list, because sorting the list takes O(nlogn) "
                    },
                    {
                        "username": "kanishk82",
                        "content": "Clearly, fastest sorting algo is O(nlogn) which is greater than a liner search O(n), but for binary search it\\'s O(logn), which is the smallest. So better use a binary search"
                    },
                    {
                        "username": "nikhila01",
                        "content": "[@abzelmes](/abzelmes) The problem requires O(log n) time so that already precludes sorting."
                    },
                    {
                        "username": "HitenTandon",
                        "content": "best case sorting time is still O(N) so you\\'re still better of just finding the smallest element linearly"
                    },
                    {
                        "username": "abzelmes",
                        "content": "Obviously this is the best solution, but I found it fun to actually try to do it without sorting. I think they need to add this to the problems requirements. That you shouldn\\'t sort the array.\\nBecause otherwise it would be an easy problem"
                    },
                    {
                        "username": "arnavk09",
                        "content": "This problem in particular is one of those rare cases when the most intuitive solution (that seems like brute force in the beginning) is the one that gives the best answer somehow"
                    },
                    {
                        "username": "faux_hubris",
                        "content": "Use Binary Search to find the largest element i.e. the pivot. The element in the array after the pivot i.e. nums[pivot + 1] is your answer. If mums[nums.Length] > nums[0], then you know it can be considered as a sorted array without rotation. In that case, simply return nums[0]."
                    },
                    {
                        "username": "jayanta1250",
                        "content": "This is not a leetcode medium question if you think. There is nothing to worry about how many times the array is rotated . you have to just find the pivot using binary search. And think in a rotated array pivot is the largest number and next after pivot is the smallest . If the array in not rotated just you have to return the 1st element because that it is the smallest element. Easy thinking. Have a good day best of luck"
                    },
                    {
                        "username": "mochiball",
                        "content": "Agreed. If array is rotated, it will have two halves : increasing and decreasing. So we can compare mid and mid + 1. If mid > mid + 1, we know this is the tipping point so return mid + 1. \\n\\nThis is because if an array is not rotated, mid > mid + 1 will never occur"
                    },
                    {
                        "username": "jamshidyuldashev7799",
                        "content": "Hi, it is very good.  "
                    },
                    {
                        "username": "tatkal",
                        "content": "Please change the difficulty tag to medium."
                    },
                    {
                        "username": "Radhika_20",
                        "content": "Use binary search to find the minimum element in the rotated sorted array. Check if the middle element is smaller than the element before it. If yes, then the minimum element is found. Otherwise, the check if the middle element is smaller than the last element of the array. If yes, then the search is narrowed down to the elements before the middle element. Otherwise, the search is narrowed down to the elements after the middle element. Return the first element of the array as the minimum element, since the first element will not have an element before it."
                    },
                    {
                        "username": "JYOTIHARODE",
                        "content": "https://github.com/jYOTIHARODE/leetcode-/blob/master/(153)Find%20Minimum%20in%20Rotated%20sorted%20Array"
                    },
                    {
                        "username": "bparanj",
                        "content": "[@Carry3236](/Carry3236) Actually, the provided solution also works correctly for monotonically increasing arrays (a type of sorted array with no rotations). Let\\'s look at an example:\\n\\nSuppose we have the array `nums = [1,2,3,4,5]`.\\n\\nAt the beginning, `l = 0`, `r = 4`, so `mid = 2`. `nums[mid] = 3` and `nums[r] = 5`. Since `nums[mid]` is not greater than `nums[r]`, we move `r` to `mid`, which is `2`.\\n\\nIn the next iteration, `l = 0`, `r = 2`, so `mid = 1`. `nums[mid] = 2` and `nums[r] = 3`. Again, `nums[mid]` is not greater than `nums[r]`, so we move `r` to `mid`, which is `1`.\\n\\nIn the final iteration, `l = 0`, `r = 1`, so `mid = 0`. `nums[mid] = 1` and `nums[r] = 2`. `nums[mid]` is not greater than `nums[r]`, so we move `r` to `mid`, which is `0`.\\n\\nNow `l` and `r` both point to `0`, and the loop ends. We return `nums[l]`, which is `1` \\u2014 the minimum element in the array.\\n\\nThis confirms that the code does work for monotonically increasing arrays. It always finds the pivot point where the array is \"rotated\" (which, in the case of a monotonically increasing array, is the first element)."
                    },
                    {
                        "username": "Carry3236",
                        "content": "this fails in case of monotonic array ."
                    }
                ]
            },
            {
                "id": 2014498,
                "content": [
                    {
                        "username": "kingbirdogd",
                        "content": "I totally don\\'t understand what this question meaning\\uFF01 It just return the min(array), it totally very bad design question!"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question requires time complexity of O(log n). Not sure if you\\'re trolling or whatever but min(array) is O(n)"
                    },
                    {
                        "username": "ImRik",
                        "content": "yup.....you can solve it using min(array) but that will take the time complexity O(N). The challenge here is to create a solution which takes the time complexity O(logN)"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "How many of you confuse at writing conditions for binary search? \\nwhen to take <  and when to take <= ."
                    },
                    {
                        "username": "mochiball",
                        "content": "I always stick with <= and it worked for me. I rarely modify it and its worked for me"
                    },
                    {
                        "username": "bhavyavohra8",
                        "content": "I get confused a lot"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "There are several patterns for binary search.\\nYou can check them here https://leetcode.com/explore/learn/card/binary-search/"
                    },
                    {
                        "username": "Ankur_028",
                        "content": "This question is all about pivot element. \\nsimply find pivot using binary search, and return min(nums[0], nums[pivot]). \\nI think this help \\uD83D\\uDC4D"
                    },
                    {
                        "username": "nale93",
                        "content": "`return min(nums)` beats 97% on memory and speed."
                    },
                    {
                        "username": "M-Huzaifa-Abdulahad007",
                        "content": "[11,13,15,17]\\nwhat the heck this test case is doing in rotated array question ?"
                    },
                    {
                        "username": "user0888gx",
                        "content": "could be rotated any multiple of 4 times\\n"
                    },
                    {
                        "username": "Akriti1701",
                        "content": "\nThe primary concept behind finding the minimum element in a rotated sorted array is that an element is considered the minimum if the preceding element is greater than it or if there is no preceding element, indicating no rotation has occurred. This can be efficiently accomplished using a binary search approach.\n\nHere are the steps to find the minimum element in a rotated sorted array:\n\nInitialize two pointers, 's' and 'e,' representing the start and end indices of the array, respectively.\n\nEnter a while loop while 's' is less than 'e' (indicating there is still a range to search within).\n\nCalculate the middle index 'mid' as 's + (e - s) / 2.'\n\nCheck if the element at index 's' is less than or equal to the element at index 'e.' If true, it means there is no rotation in this segment, so return the element at index 's' as the minimum.\n\nIf the above condition is not met, check if the element at index 's' is greater than the element at index 'mid.' If true, set 'e' to 'mid' as this indicates that the minimum element must be in the left half of the array.\n\nIf the element at index 'mid' is greater than the element at index 'e,' set 's' to 'mid + 1' as this indicates that the minimum element must be in the right half of the array.\n\nAfter the loop, check again if the element at 's' is less than or equal to the element at 'e.' If true, return the element at 's' as the minimum element.\n\nIf none of the above conditions were met, return -1 to indicate that no minimum element was found (this should not happen in a valid rotated sorted array).\n\n*Time Complexity: O(logn)*\n*Space Complexity: O(1)*\n"
                    },
                    {
                        "username": "ahmedabdoamin997",
                        "content": "        \n        binary search uses on sorted array\n        # so we check if median is greater than last, go right of list \n        # because all elements of left is the greatest (non important)\n\n        #  nums = [3,4,5,1,2]\n        # init : l = 0, r = 4, m = (0+4)/2\n        # stop l < r : return nums[l]\n\n        # l    0 3 3 \n        # r    4 4 3 \n        # m    2 3 "
                    },
                    {
                        "username": "leflxlight",
                        "content": "What is error in this code? \\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        // corner case:\\n        if(nums[0] <= nums[n-1])\\n          {\\n              return nums[0];\\n          }\\n        int s = 0;\\n        int e = n - 1;\\n        int ans = INT_MAX;\\n\\n        while(s<=e)\\n        {\\n            int mid = s + (e - s)/2;\\n            int next = (mid + 1)% n;\\n            int prev = (mid + n - 1) % n;\\n\\n            if(nums[mid]<=nums[next] && nums[mid]<=nums[prev])\\n            {\\n                ans =  nums[mid];\\n                break;\\n            }\\n            if(nums[s]<=nums[mid]){\\n                s = mid + 1;\\n            }\\n            else if(nums[mid]<=nums[e])\\n            {\\n                e = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "gsahu07",
                        "content": "Solved my 50th medium today. Yay!\\n#smallwins"
                    },
                    {
                        "username": "Rivo11",
                        "content": "Conclusion ... If i am in the left sorted .. save the first as min and search right ... else save the mid as min and search left."
                    }
                ]
            },
            {
                "id": 1966772,
                "content": [
                    {
                        "username": "kingbirdogd",
                        "content": "I totally don\\'t understand what this question meaning\\uFF01 It just return the min(array), it totally very bad design question!"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question requires time complexity of O(log n). Not sure if you\\'re trolling or whatever but min(array) is O(n)"
                    },
                    {
                        "username": "ImRik",
                        "content": "yup.....you can solve it using min(array) but that will take the time complexity O(N). The challenge here is to create a solution which takes the time complexity O(logN)"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "How many of you confuse at writing conditions for binary search? \\nwhen to take <  and when to take <= ."
                    },
                    {
                        "username": "mochiball",
                        "content": "I always stick with <= and it worked for me. I rarely modify it and its worked for me"
                    },
                    {
                        "username": "bhavyavohra8",
                        "content": "I get confused a lot"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "There are several patterns for binary search.\\nYou can check them here https://leetcode.com/explore/learn/card/binary-search/"
                    },
                    {
                        "username": "Ankur_028",
                        "content": "This question is all about pivot element. \\nsimply find pivot using binary search, and return min(nums[0], nums[pivot]). \\nI think this help \\uD83D\\uDC4D"
                    },
                    {
                        "username": "nale93",
                        "content": "`return min(nums)` beats 97% on memory and speed."
                    },
                    {
                        "username": "M-Huzaifa-Abdulahad007",
                        "content": "[11,13,15,17]\\nwhat the heck this test case is doing in rotated array question ?"
                    },
                    {
                        "username": "user0888gx",
                        "content": "could be rotated any multiple of 4 times\\n"
                    },
                    {
                        "username": "Akriti1701",
                        "content": "\nThe primary concept behind finding the minimum element in a rotated sorted array is that an element is considered the minimum if the preceding element is greater than it or if there is no preceding element, indicating no rotation has occurred. This can be efficiently accomplished using a binary search approach.\n\nHere are the steps to find the minimum element in a rotated sorted array:\n\nInitialize two pointers, 's' and 'e,' representing the start and end indices of the array, respectively.\n\nEnter a while loop while 's' is less than 'e' (indicating there is still a range to search within).\n\nCalculate the middle index 'mid' as 's + (e - s) / 2.'\n\nCheck if the element at index 's' is less than or equal to the element at index 'e.' If true, it means there is no rotation in this segment, so return the element at index 's' as the minimum.\n\nIf the above condition is not met, check if the element at index 's' is greater than the element at index 'mid.' If true, set 'e' to 'mid' as this indicates that the minimum element must be in the left half of the array.\n\nIf the element at index 'mid' is greater than the element at index 'e,' set 's' to 'mid + 1' as this indicates that the minimum element must be in the right half of the array.\n\nAfter the loop, check again if the element at 's' is less than or equal to the element at 'e.' If true, return the element at 's' as the minimum element.\n\nIf none of the above conditions were met, return -1 to indicate that no minimum element was found (this should not happen in a valid rotated sorted array).\n\n*Time Complexity: O(logn)*\n*Space Complexity: O(1)*\n"
                    },
                    {
                        "username": "ahmedabdoamin997",
                        "content": "        \n        binary search uses on sorted array\n        # so we check if median is greater than last, go right of list \n        # because all elements of left is the greatest (non important)\n\n        #  nums = [3,4,5,1,2]\n        # init : l = 0, r = 4, m = (0+4)/2\n        # stop l < r : return nums[l]\n\n        # l    0 3 3 \n        # r    4 4 3 \n        # m    2 3 "
                    },
                    {
                        "username": "leflxlight",
                        "content": "What is error in this code? \\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        // corner case:\\n        if(nums[0] <= nums[n-1])\\n          {\\n              return nums[0];\\n          }\\n        int s = 0;\\n        int e = n - 1;\\n        int ans = INT_MAX;\\n\\n        while(s<=e)\\n        {\\n            int mid = s + (e - s)/2;\\n            int next = (mid + 1)% n;\\n            int prev = (mid + n - 1) % n;\\n\\n            if(nums[mid]<=nums[next] && nums[mid]<=nums[prev])\\n            {\\n                ans =  nums[mid];\\n                break;\\n            }\\n            if(nums[s]<=nums[mid]){\\n                s = mid + 1;\\n            }\\n            else if(nums[mid]<=nums[e])\\n            {\\n                e = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "gsahu07",
                        "content": "Solved my 50th medium today. Yay!\\n#smallwins"
                    },
                    {
                        "username": "Rivo11",
                        "content": "Conclusion ... If i am in the left sorted .. save the first as min and search right ... else save the mid as min and search left."
                    }
                ]
            },
            {
                "id": 1919054,
                "content": [
                    {
                        "username": "kingbirdogd",
                        "content": "I totally don\\'t understand what this question meaning\\uFF01 It just return the min(array), it totally very bad design question!"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question requires time complexity of O(log n). Not sure if you\\'re trolling or whatever but min(array) is O(n)"
                    },
                    {
                        "username": "ImRik",
                        "content": "yup.....you can solve it using min(array) but that will take the time complexity O(N). The challenge here is to create a solution which takes the time complexity O(logN)"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "How many of you confuse at writing conditions for binary search? \\nwhen to take <  and when to take <= ."
                    },
                    {
                        "username": "mochiball",
                        "content": "I always stick with <= and it worked for me. I rarely modify it and its worked for me"
                    },
                    {
                        "username": "bhavyavohra8",
                        "content": "I get confused a lot"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "There are several patterns for binary search.\\nYou can check them here https://leetcode.com/explore/learn/card/binary-search/"
                    },
                    {
                        "username": "Ankur_028",
                        "content": "This question is all about pivot element. \\nsimply find pivot using binary search, and return min(nums[0], nums[pivot]). \\nI think this help \\uD83D\\uDC4D"
                    },
                    {
                        "username": "nale93",
                        "content": "`return min(nums)` beats 97% on memory and speed."
                    },
                    {
                        "username": "M-Huzaifa-Abdulahad007",
                        "content": "[11,13,15,17]\\nwhat the heck this test case is doing in rotated array question ?"
                    },
                    {
                        "username": "user0888gx",
                        "content": "could be rotated any multiple of 4 times\\n"
                    },
                    {
                        "username": "Akriti1701",
                        "content": "\nThe primary concept behind finding the minimum element in a rotated sorted array is that an element is considered the minimum if the preceding element is greater than it or if there is no preceding element, indicating no rotation has occurred. This can be efficiently accomplished using a binary search approach.\n\nHere are the steps to find the minimum element in a rotated sorted array:\n\nInitialize two pointers, 's' and 'e,' representing the start and end indices of the array, respectively.\n\nEnter a while loop while 's' is less than 'e' (indicating there is still a range to search within).\n\nCalculate the middle index 'mid' as 's + (e - s) / 2.'\n\nCheck if the element at index 's' is less than or equal to the element at index 'e.' If true, it means there is no rotation in this segment, so return the element at index 's' as the minimum.\n\nIf the above condition is not met, check if the element at index 's' is greater than the element at index 'mid.' If true, set 'e' to 'mid' as this indicates that the minimum element must be in the left half of the array.\n\nIf the element at index 'mid' is greater than the element at index 'e,' set 's' to 'mid + 1' as this indicates that the minimum element must be in the right half of the array.\n\nAfter the loop, check again if the element at 's' is less than or equal to the element at 'e.' If true, return the element at 's' as the minimum element.\n\nIf none of the above conditions were met, return -1 to indicate that no minimum element was found (this should not happen in a valid rotated sorted array).\n\n*Time Complexity: O(logn)*\n*Space Complexity: O(1)*\n"
                    },
                    {
                        "username": "ahmedabdoamin997",
                        "content": "        \n        binary search uses on sorted array\n        # so we check if median is greater than last, go right of list \n        # because all elements of left is the greatest (non important)\n\n        #  nums = [3,4,5,1,2]\n        # init : l = 0, r = 4, m = (0+4)/2\n        # stop l < r : return nums[l]\n\n        # l    0 3 3 \n        # r    4 4 3 \n        # m    2 3 "
                    },
                    {
                        "username": "leflxlight",
                        "content": "What is error in this code? \\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        // corner case:\\n        if(nums[0] <= nums[n-1])\\n          {\\n              return nums[0];\\n          }\\n        int s = 0;\\n        int e = n - 1;\\n        int ans = INT_MAX;\\n\\n        while(s<=e)\\n        {\\n            int mid = s + (e - s)/2;\\n            int next = (mid + 1)% n;\\n            int prev = (mid + n - 1) % n;\\n\\n            if(nums[mid]<=nums[next] && nums[mid]<=nums[prev])\\n            {\\n                ans =  nums[mid];\\n                break;\\n            }\\n            if(nums[s]<=nums[mid]){\\n                s = mid + 1;\\n            }\\n            else if(nums[mid]<=nums[e])\\n            {\\n                e = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "gsahu07",
                        "content": "Solved my 50th medium today. Yay!\\n#smallwins"
                    },
                    {
                        "username": "Rivo11",
                        "content": "Conclusion ... If i am in the left sorted .. save the first as min and search right ... else save the mid as min and search left."
                    }
                ]
            },
            {
                "id": 2072203,
                "content": [
                    {
                        "username": "kingbirdogd",
                        "content": "I totally don\\'t understand what this question meaning\\uFF01 It just return the min(array), it totally very bad design question!"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question requires time complexity of O(log n). Not sure if you\\'re trolling or whatever but min(array) is O(n)"
                    },
                    {
                        "username": "ImRik",
                        "content": "yup.....you can solve it using min(array) but that will take the time complexity O(N). The challenge here is to create a solution which takes the time complexity O(logN)"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "How many of you confuse at writing conditions for binary search? \\nwhen to take <  and when to take <= ."
                    },
                    {
                        "username": "mochiball",
                        "content": "I always stick with <= and it worked for me. I rarely modify it and its worked for me"
                    },
                    {
                        "username": "bhavyavohra8",
                        "content": "I get confused a lot"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "There are several patterns for binary search.\\nYou can check them here https://leetcode.com/explore/learn/card/binary-search/"
                    },
                    {
                        "username": "Ankur_028",
                        "content": "This question is all about pivot element. \\nsimply find pivot using binary search, and return min(nums[0], nums[pivot]). \\nI think this help \\uD83D\\uDC4D"
                    },
                    {
                        "username": "nale93",
                        "content": "`return min(nums)` beats 97% on memory and speed."
                    },
                    {
                        "username": "M-Huzaifa-Abdulahad007",
                        "content": "[11,13,15,17]\\nwhat the heck this test case is doing in rotated array question ?"
                    },
                    {
                        "username": "user0888gx",
                        "content": "could be rotated any multiple of 4 times\\n"
                    },
                    {
                        "username": "Akriti1701",
                        "content": "\nThe primary concept behind finding the minimum element in a rotated sorted array is that an element is considered the minimum if the preceding element is greater than it or if there is no preceding element, indicating no rotation has occurred. This can be efficiently accomplished using a binary search approach.\n\nHere are the steps to find the minimum element in a rotated sorted array:\n\nInitialize two pointers, 's' and 'e,' representing the start and end indices of the array, respectively.\n\nEnter a while loop while 's' is less than 'e' (indicating there is still a range to search within).\n\nCalculate the middle index 'mid' as 's + (e - s) / 2.'\n\nCheck if the element at index 's' is less than or equal to the element at index 'e.' If true, it means there is no rotation in this segment, so return the element at index 's' as the minimum.\n\nIf the above condition is not met, check if the element at index 's' is greater than the element at index 'mid.' If true, set 'e' to 'mid' as this indicates that the minimum element must be in the left half of the array.\n\nIf the element at index 'mid' is greater than the element at index 'e,' set 's' to 'mid + 1' as this indicates that the minimum element must be in the right half of the array.\n\nAfter the loop, check again if the element at 's' is less than or equal to the element at 'e.' If true, return the element at 's' as the minimum element.\n\nIf none of the above conditions were met, return -1 to indicate that no minimum element was found (this should not happen in a valid rotated sorted array).\n\n*Time Complexity: O(logn)*\n*Space Complexity: O(1)*\n"
                    },
                    {
                        "username": "ahmedabdoamin997",
                        "content": "        \n        binary search uses on sorted array\n        # so we check if median is greater than last, go right of list \n        # because all elements of left is the greatest (non important)\n\n        #  nums = [3,4,5,1,2]\n        # init : l = 0, r = 4, m = (0+4)/2\n        # stop l < r : return nums[l]\n\n        # l    0 3 3 \n        # r    4 4 3 \n        # m    2 3 "
                    },
                    {
                        "username": "leflxlight",
                        "content": "What is error in this code? \\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        // corner case:\\n        if(nums[0] <= nums[n-1])\\n          {\\n              return nums[0];\\n          }\\n        int s = 0;\\n        int e = n - 1;\\n        int ans = INT_MAX;\\n\\n        while(s<=e)\\n        {\\n            int mid = s + (e - s)/2;\\n            int next = (mid + 1)% n;\\n            int prev = (mid + n - 1) % n;\\n\\n            if(nums[mid]<=nums[next] && nums[mid]<=nums[prev])\\n            {\\n                ans =  nums[mid];\\n                break;\\n            }\\n            if(nums[s]<=nums[mid]){\\n                s = mid + 1;\\n            }\\n            else if(nums[mid]<=nums[e])\\n            {\\n                e = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "gsahu07",
                        "content": "Solved my 50th medium today. Yay!\\n#smallwins"
                    },
                    {
                        "username": "Rivo11",
                        "content": "Conclusion ... If i am in the left sorted .. save the first as min and search right ... else save the mid as min and search left."
                    }
                ]
            },
            {
                "id": 2069041,
                "content": [
                    {
                        "username": "kingbirdogd",
                        "content": "I totally don\\'t understand what this question meaning\\uFF01 It just return the min(array), it totally very bad design question!"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question requires time complexity of O(log n). Not sure if you\\'re trolling or whatever but min(array) is O(n)"
                    },
                    {
                        "username": "ImRik",
                        "content": "yup.....you can solve it using min(array) but that will take the time complexity O(N). The challenge here is to create a solution which takes the time complexity O(logN)"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "How many of you confuse at writing conditions for binary search? \\nwhen to take <  and when to take <= ."
                    },
                    {
                        "username": "mochiball",
                        "content": "I always stick with <= and it worked for me. I rarely modify it and its worked for me"
                    },
                    {
                        "username": "bhavyavohra8",
                        "content": "I get confused a lot"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "There are several patterns for binary search.\\nYou can check them here https://leetcode.com/explore/learn/card/binary-search/"
                    },
                    {
                        "username": "Ankur_028",
                        "content": "This question is all about pivot element. \\nsimply find pivot using binary search, and return min(nums[0], nums[pivot]). \\nI think this help \\uD83D\\uDC4D"
                    },
                    {
                        "username": "nale93",
                        "content": "`return min(nums)` beats 97% on memory and speed."
                    },
                    {
                        "username": "M-Huzaifa-Abdulahad007",
                        "content": "[11,13,15,17]\\nwhat the heck this test case is doing in rotated array question ?"
                    },
                    {
                        "username": "user0888gx",
                        "content": "could be rotated any multiple of 4 times\\n"
                    },
                    {
                        "username": "Akriti1701",
                        "content": "\nThe primary concept behind finding the minimum element in a rotated sorted array is that an element is considered the minimum if the preceding element is greater than it or if there is no preceding element, indicating no rotation has occurred. This can be efficiently accomplished using a binary search approach.\n\nHere are the steps to find the minimum element in a rotated sorted array:\n\nInitialize two pointers, 's' and 'e,' representing the start and end indices of the array, respectively.\n\nEnter a while loop while 's' is less than 'e' (indicating there is still a range to search within).\n\nCalculate the middle index 'mid' as 's + (e - s) / 2.'\n\nCheck if the element at index 's' is less than or equal to the element at index 'e.' If true, it means there is no rotation in this segment, so return the element at index 's' as the minimum.\n\nIf the above condition is not met, check if the element at index 's' is greater than the element at index 'mid.' If true, set 'e' to 'mid' as this indicates that the minimum element must be in the left half of the array.\n\nIf the element at index 'mid' is greater than the element at index 'e,' set 's' to 'mid + 1' as this indicates that the minimum element must be in the right half of the array.\n\nAfter the loop, check again if the element at 's' is less than or equal to the element at 'e.' If true, return the element at 's' as the minimum element.\n\nIf none of the above conditions were met, return -1 to indicate that no minimum element was found (this should not happen in a valid rotated sorted array).\n\n*Time Complexity: O(logn)*\n*Space Complexity: O(1)*\n"
                    },
                    {
                        "username": "ahmedabdoamin997",
                        "content": "        \n        binary search uses on sorted array\n        # so we check if median is greater than last, go right of list \n        # because all elements of left is the greatest (non important)\n\n        #  nums = [3,4,5,1,2]\n        # init : l = 0, r = 4, m = (0+4)/2\n        # stop l < r : return nums[l]\n\n        # l    0 3 3 \n        # r    4 4 3 \n        # m    2 3 "
                    },
                    {
                        "username": "leflxlight",
                        "content": "What is error in this code? \\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        // corner case:\\n        if(nums[0] <= nums[n-1])\\n          {\\n              return nums[0];\\n          }\\n        int s = 0;\\n        int e = n - 1;\\n        int ans = INT_MAX;\\n\\n        while(s<=e)\\n        {\\n            int mid = s + (e - s)/2;\\n            int next = (mid + 1)% n;\\n            int prev = (mid + n - 1) % n;\\n\\n            if(nums[mid]<=nums[next] && nums[mid]<=nums[prev])\\n            {\\n                ans =  nums[mid];\\n                break;\\n            }\\n            if(nums[s]<=nums[mid]){\\n                s = mid + 1;\\n            }\\n            else if(nums[mid]<=nums[e])\\n            {\\n                e = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "gsahu07",
                        "content": "Solved my 50th medium today. Yay!\\n#smallwins"
                    },
                    {
                        "username": "Rivo11",
                        "content": "Conclusion ... If i am in the left sorted .. save the first as min and search right ... else save the mid as min and search left."
                    }
                ]
            },
            {
                "id": 2068288,
                "content": [
                    {
                        "username": "kingbirdogd",
                        "content": "I totally don\\'t understand what this question meaning\\uFF01 It just return the min(array), it totally very bad design question!"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question requires time complexity of O(log n). Not sure if you\\'re trolling or whatever but min(array) is O(n)"
                    },
                    {
                        "username": "ImRik",
                        "content": "yup.....you can solve it using min(array) but that will take the time complexity O(N). The challenge here is to create a solution which takes the time complexity O(logN)"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "How many of you confuse at writing conditions for binary search? \\nwhen to take <  and when to take <= ."
                    },
                    {
                        "username": "mochiball",
                        "content": "I always stick with <= and it worked for me. I rarely modify it and its worked for me"
                    },
                    {
                        "username": "bhavyavohra8",
                        "content": "I get confused a lot"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "There are several patterns for binary search.\\nYou can check them here https://leetcode.com/explore/learn/card/binary-search/"
                    },
                    {
                        "username": "Ankur_028",
                        "content": "This question is all about pivot element. \\nsimply find pivot using binary search, and return min(nums[0], nums[pivot]). \\nI think this help \\uD83D\\uDC4D"
                    },
                    {
                        "username": "nale93",
                        "content": "`return min(nums)` beats 97% on memory and speed."
                    },
                    {
                        "username": "M-Huzaifa-Abdulahad007",
                        "content": "[11,13,15,17]\\nwhat the heck this test case is doing in rotated array question ?"
                    },
                    {
                        "username": "user0888gx",
                        "content": "could be rotated any multiple of 4 times\\n"
                    },
                    {
                        "username": "Akriti1701",
                        "content": "\nThe primary concept behind finding the minimum element in a rotated sorted array is that an element is considered the minimum if the preceding element is greater than it or if there is no preceding element, indicating no rotation has occurred. This can be efficiently accomplished using a binary search approach.\n\nHere are the steps to find the minimum element in a rotated sorted array:\n\nInitialize two pointers, 's' and 'e,' representing the start and end indices of the array, respectively.\n\nEnter a while loop while 's' is less than 'e' (indicating there is still a range to search within).\n\nCalculate the middle index 'mid' as 's + (e - s) / 2.'\n\nCheck if the element at index 's' is less than or equal to the element at index 'e.' If true, it means there is no rotation in this segment, so return the element at index 's' as the minimum.\n\nIf the above condition is not met, check if the element at index 's' is greater than the element at index 'mid.' If true, set 'e' to 'mid' as this indicates that the minimum element must be in the left half of the array.\n\nIf the element at index 'mid' is greater than the element at index 'e,' set 's' to 'mid + 1' as this indicates that the minimum element must be in the right half of the array.\n\nAfter the loop, check again if the element at 's' is less than or equal to the element at 'e.' If true, return the element at 's' as the minimum element.\n\nIf none of the above conditions were met, return -1 to indicate that no minimum element was found (this should not happen in a valid rotated sorted array).\n\n*Time Complexity: O(logn)*\n*Space Complexity: O(1)*\n"
                    },
                    {
                        "username": "ahmedabdoamin997",
                        "content": "        \n        binary search uses on sorted array\n        # so we check if median is greater than last, go right of list \n        # because all elements of left is the greatest (non important)\n\n        #  nums = [3,4,5,1,2]\n        # init : l = 0, r = 4, m = (0+4)/2\n        # stop l < r : return nums[l]\n\n        # l    0 3 3 \n        # r    4 4 3 \n        # m    2 3 "
                    },
                    {
                        "username": "leflxlight",
                        "content": "What is error in this code? \\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        // corner case:\\n        if(nums[0] <= nums[n-1])\\n          {\\n              return nums[0];\\n          }\\n        int s = 0;\\n        int e = n - 1;\\n        int ans = INT_MAX;\\n\\n        while(s<=e)\\n        {\\n            int mid = s + (e - s)/2;\\n            int next = (mid + 1)% n;\\n            int prev = (mid + n - 1) % n;\\n\\n            if(nums[mid]<=nums[next] && nums[mid]<=nums[prev])\\n            {\\n                ans =  nums[mid];\\n                break;\\n            }\\n            if(nums[s]<=nums[mid]){\\n                s = mid + 1;\\n            }\\n            else if(nums[mid]<=nums[e])\\n            {\\n                e = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "gsahu07",
                        "content": "Solved my 50th medium today. Yay!\\n#smallwins"
                    },
                    {
                        "username": "Rivo11",
                        "content": "Conclusion ... If i am in the left sorted .. save the first as min and search right ... else save the mid as min and search left."
                    }
                ]
            },
            {
                "id": 2059780,
                "content": [
                    {
                        "username": "kingbirdogd",
                        "content": "I totally don\\'t understand what this question meaning\\uFF01 It just return the min(array), it totally very bad design question!"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question requires time complexity of O(log n). Not sure if you\\'re trolling or whatever but min(array) is O(n)"
                    },
                    {
                        "username": "ImRik",
                        "content": "yup.....you can solve it using min(array) but that will take the time complexity O(N). The challenge here is to create a solution which takes the time complexity O(logN)"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "How many of you confuse at writing conditions for binary search? \\nwhen to take <  and when to take <= ."
                    },
                    {
                        "username": "mochiball",
                        "content": "I always stick with <= and it worked for me. I rarely modify it and its worked for me"
                    },
                    {
                        "username": "bhavyavohra8",
                        "content": "I get confused a lot"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "There are several patterns for binary search.\\nYou can check them here https://leetcode.com/explore/learn/card/binary-search/"
                    },
                    {
                        "username": "Ankur_028",
                        "content": "This question is all about pivot element. \\nsimply find pivot using binary search, and return min(nums[0], nums[pivot]). \\nI think this help \\uD83D\\uDC4D"
                    },
                    {
                        "username": "nale93",
                        "content": "`return min(nums)` beats 97% on memory and speed."
                    },
                    {
                        "username": "M-Huzaifa-Abdulahad007",
                        "content": "[11,13,15,17]\\nwhat the heck this test case is doing in rotated array question ?"
                    },
                    {
                        "username": "user0888gx",
                        "content": "could be rotated any multiple of 4 times\\n"
                    },
                    {
                        "username": "Akriti1701",
                        "content": "\nThe primary concept behind finding the minimum element in a rotated sorted array is that an element is considered the minimum if the preceding element is greater than it or if there is no preceding element, indicating no rotation has occurred. This can be efficiently accomplished using a binary search approach.\n\nHere are the steps to find the minimum element in a rotated sorted array:\n\nInitialize two pointers, 's' and 'e,' representing the start and end indices of the array, respectively.\n\nEnter a while loop while 's' is less than 'e' (indicating there is still a range to search within).\n\nCalculate the middle index 'mid' as 's + (e - s) / 2.'\n\nCheck if the element at index 's' is less than or equal to the element at index 'e.' If true, it means there is no rotation in this segment, so return the element at index 's' as the minimum.\n\nIf the above condition is not met, check if the element at index 's' is greater than the element at index 'mid.' If true, set 'e' to 'mid' as this indicates that the minimum element must be in the left half of the array.\n\nIf the element at index 'mid' is greater than the element at index 'e,' set 's' to 'mid + 1' as this indicates that the minimum element must be in the right half of the array.\n\nAfter the loop, check again if the element at 's' is less than or equal to the element at 'e.' If true, return the element at 's' as the minimum element.\n\nIf none of the above conditions were met, return -1 to indicate that no minimum element was found (this should not happen in a valid rotated sorted array).\n\n*Time Complexity: O(logn)*\n*Space Complexity: O(1)*\n"
                    },
                    {
                        "username": "ahmedabdoamin997",
                        "content": "        \n        binary search uses on sorted array\n        # so we check if median is greater than last, go right of list \n        # because all elements of left is the greatest (non important)\n\n        #  nums = [3,4,5,1,2]\n        # init : l = 0, r = 4, m = (0+4)/2\n        # stop l < r : return nums[l]\n\n        # l    0 3 3 \n        # r    4 4 3 \n        # m    2 3 "
                    },
                    {
                        "username": "leflxlight",
                        "content": "What is error in this code? \\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        // corner case:\\n        if(nums[0] <= nums[n-1])\\n          {\\n              return nums[0];\\n          }\\n        int s = 0;\\n        int e = n - 1;\\n        int ans = INT_MAX;\\n\\n        while(s<=e)\\n        {\\n            int mid = s + (e - s)/2;\\n            int next = (mid + 1)% n;\\n            int prev = (mid + n - 1) % n;\\n\\n            if(nums[mid]<=nums[next] && nums[mid]<=nums[prev])\\n            {\\n                ans =  nums[mid];\\n                break;\\n            }\\n            if(nums[s]<=nums[mid]){\\n                s = mid + 1;\\n            }\\n            else if(nums[mid]<=nums[e])\\n            {\\n                e = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "gsahu07",
                        "content": "Solved my 50th medium today. Yay!\\n#smallwins"
                    },
                    {
                        "username": "Rivo11",
                        "content": "Conclusion ... If i am in the left sorted .. save the first as min and search right ... else save the mid as min and search left."
                    }
                ]
            },
            {
                "id": 2052981,
                "content": [
                    {
                        "username": "kingbirdogd",
                        "content": "I totally don\\'t understand what this question meaning\\uFF01 It just return the min(array), it totally very bad design question!"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question requires time complexity of O(log n). Not sure if you\\'re trolling or whatever but min(array) is O(n)"
                    },
                    {
                        "username": "ImRik",
                        "content": "yup.....you can solve it using min(array) but that will take the time complexity O(N). The challenge here is to create a solution which takes the time complexity O(logN)"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "How many of you confuse at writing conditions for binary search? \\nwhen to take <  and when to take <= ."
                    },
                    {
                        "username": "mochiball",
                        "content": "I always stick with <= and it worked for me. I rarely modify it and its worked for me"
                    },
                    {
                        "username": "bhavyavohra8",
                        "content": "I get confused a lot"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "There are several patterns for binary search.\\nYou can check them here https://leetcode.com/explore/learn/card/binary-search/"
                    },
                    {
                        "username": "Ankur_028",
                        "content": "This question is all about pivot element. \\nsimply find pivot using binary search, and return min(nums[0], nums[pivot]). \\nI think this help \\uD83D\\uDC4D"
                    },
                    {
                        "username": "nale93",
                        "content": "`return min(nums)` beats 97% on memory and speed."
                    },
                    {
                        "username": "M-Huzaifa-Abdulahad007",
                        "content": "[11,13,15,17]\\nwhat the heck this test case is doing in rotated array question ?"
                    },
                    {
                        "username": "user0888gx",
                        "content": "could be rotated any multiple of 4 times\\n"
                    },
                    {
                        "username": "Akriti1701",
                        "content": "\nThe primary concept behind finding the minimum element in a rotated sorted array is that an element is considered the minimum if the preceding element is greater than it or if there is no preceding element, indicating no rotation has occurred. This can be efficiently accomplished using a binary search approach.\n\nHere are the steps to find the minimum element in a rotated sorted array:\n\nInitialize two pointers, 's' and 'e,' representing the start and end indices of the array, respectively.\n\nEnter a while loop while 's' is less than 'e' (indicating there is still a range to search within).\n\nCalculate the middle index 'mid' as 's + (e - s) / 2.'\n\nCheck if the element at index 's' is less than or equal to the element at index 'e.' If true, it means there is no rotation in this segment, so return the element at index 's' as the minimum.\n\nIf the above condition is not met, check if the element at index 's' is greater than the element at index 'mid.' If true, set 'e' to 'mid' as this indicates that the minimum element must be in the left half of the array.\n\nIf the element at index 'mid' is greater than the element at index 'e,' set 's' to 'mid + 1' as this indicates that the minimum element must be in the right half of the array.\n\nAfter the loop, check again if the element at 's' is less than or equal to the element at 'e.' If true, return the element at 's' as the minimum element.\n\nIf none of the above conditions were met, return -1 to indicate that no minimum element was found (this should not happen in a valid rotated sorted array).\n\n*Time Complexity: O(logn)*\n*Space Complexity: O(1)*\n"
                    },
                    {
                        "username": "ahmedabdoamin997",
                        "content": "        \n        binary search uses on sorted array\n        # so we check if median is greater than last, go right of list \n        # because all elements of left is the greatest (non important)\n\n        #  nums = [3,4,5,1,2]\n        # init : l = 0, r = 4, m = (0+4)/2\n        # stop l < r : return nums[l]\n\n        # l    0 3 3 \n        # r    4 4 3 \n        # m    2 3 "
                    },
                    {
                        "username": "leflxlight",
                        "content": "What is error in this code? \\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        // corner case:\\n        if(nums[0] <= nums[n-1])\\n          {\\n              return nums[0];\\n          }\\n        int s = 0;\\n        int e = n - 1;\\n        int ans = INT_MAX;\\n\\n        while(s<=e)\\n        {\\n            int mid = s + (e - s)/2;\\n            int next = (mid + 1)% n;\\n            int prev = (mid + n - 1) % n;\\n\\n            if(nums[mid]<=nums[next] && nums[mid]<=nums[prev])\\n            {\\n                ans =  nums[mid];\\n                break;\\n            }\\n            if(nums[s]<=nums[mid]){\\n                s = mid + 1;\\n            }\\n            else if(nums[mid]<=nums[e])\\n            {\\n                e = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "gsahu07",
                        "content": "Solved my 50th medium today. Yay!\\n#smallwins"
                    },
                    {
                        "username": "Rivo11",
                        "content": "Conclusion ... If i am in the left sorted .. save the first as min and search right ... else save the mid as min and search left."
                    }
                ]
            },
            {
                "id": 2050274,
                "content": [
                    {
                        "username": "kingbirdogd",
                        "content": "I totally don\\'t understand what this question meaning\\uFF01 It just return the min(array), it totally very bad design question!"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question requires time complexity of O(log n). Not sure if you\\'re trolling or whatever but min(array) is O(n)"
                    },
                    {
                        "username": "ImRik",
                        "content": "yup.....you can solve it using min(array) but that will take the time complexity O(N). The challenge here is to create a solution which takes the time complexity O(logN)"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "How many of you confuse at writing conditions for binary search? \\nwhen to take <  and when to take <= ."
                    },
                    {
                        "username": "mochiball",
                        "content": "I always stick with <= and it worked for me. I rarely modify it and its worked for me"
                    },
                    {
                        "username": "bhavyavohra8",
                        "content": "I get confused a lot"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "There are several patterns for binary search.\\nYou can check them here https://leetcode.com/explore/learn/card/binary-search/"
                    },
                    {
                        "username": "Ankur_028",
                        "content": "This question is all about pivot element. \\nsimply find pivot using binary search, and return min(nums[0], nums[pivot]). \\nI think this help \\uD83D\\uDC4D"
                    },
                    {
                        "username": "nale93",
                        "content": "`return min(nums)` beats 97% on memory and speed."
                    },
                    {
                        "username": "M-Huzaifa-Abdulahad007",
                        "content": "[11,13,15,17]\\nwhat the heck this test case is doing in rotated array question ?"
                    },
                    {
                        "username": "user0888gx",
                        "content": "could be rotated any multiple of 4 times\\n"
                    },
                    {
                        "username": "Akriti1701",
                        "content": "\nThe primary concept behind finding the minimum element in a rotated sorted array is that an element is considered the minimum if the preceding element is greater than it or if there is no preceding element, indicating no rotation has occurred. This can be efficiently accomplished using a binary search approach.\n\nHere are the steps to find the minimum element in a rotated sorted array:\n\nInitialize two pointers, 's' and 'e,' representing the start and end indices of the array, respectively.\n\nEnter a while loop while 's' is less than 'e' (indicating there is still a range to search within).\n\nCalculate the middle index 'mid' as 's + (e - s) / 2.'\n\nCheck if the element at index 's' is less than or equal to the element at index 'e.' If true, it means there is no rotation in this segment, so return the element at index 's' as the minimum.\n\nIf the above condition is not met, check if the element at index 's' is greater than the element at index 'mid.' If true, set 'e' to 'mid' as this indicates that the minimum element must be in the left half of the array.\n\nIf the element at index 'mid' is greater than the element at index 'e,' set 's' to 'mid + 1' as this indicates that the minimum element must be in the right half of the array.\n\nAfter the loop, check again if the element at 's' is less than or equal to the element at 'e.' If true, return the element at 's' as the minimum element.\n\nIf none of the above conditions were met, return -1 to indicate that no minimum element was found (this should not happen in a valid rotated sorted array).\n\n*Time Complexity: O(logn)*\n*Space Complexity: O(1)*\n"
                    },
                    {
                        "username": "ahmedabdoamin997",
                        "content": "        \n        binary search uses on sorted array\n        # so we check if median is greater than last, go right of list \n        # because all elements of left is the greatest (non important)\n\n        #  nums = [3,4,5,1,2]\n        # init : l = 0, r = 4, m = (0+4)/2\n        # stop l < r : return nums[l]\n\n        # l    0 3 3 \n        # r    4 4 3 \n        # m    2 3 "
                    },
                    {
                        "username": "leflxlight",
                        "content": "What is error in this code? \\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        // corner case:\\n        if(nums[0] <= nums[n-1])\\n          {\\n              return nums[0];\\n          }\\n        int s = 0;\\n        int e = n - 1;\\n        int ans = INT_MAX;\\n\\n        while(s<=e)\\n        {\\n            int mid = s + (e - s)/2;\\n            int next = (mid + 1)% n;\\n            int prev = (mid + n - 1) % n;\\n\\n            if(nums[mid]<=nums[next] && nums[mid]<=nums[prev])\\n            {\\n                ans =  nums[mid];\\n                break;\\n            }\\n            if(nums[s]<=nums[mid]){\\n                s = mid + 1;\\n            }\\n            else if(nums[mid]<=nums[e])\\n            {\\n                e = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "gsahu07",
                        "content": "Solved my 50th medium today. Yay!\\n#smallwins"
                    },
                    {
                        "username": "Rivo11",
                        "content": "Conclusion ... If i am in the left sorted .. save the first as min and search right ... else save the mid as min and search left."
                    }
                ]
            },
            {
                "id": 2046413,
                "content": [
                    {
                        "username": "kingbirdogd",
                        "content": "I totally don\\'t understand what this question meaning\\uFF01 It just return the min(array), it totally very bad design question!"
                    },
                    {
                        "username": "mochiball",
                        "content": "Question requires time complexity of O(log n). Not sure if you\\'re trolling or whatever but min(array) is O(n)"
                    },
                    {
                        "username": "ImRik",
                        "content": "yup.....you can solve it using min(array) but that will take the time complexity O(N). The challenge here is to create a solution which takes the time complexity O(logN)"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "How many of you confuse at writing conditions for binary search? \\nwhen to take <  and when to take <= ."
                    },
                    {
                        "username": "mochiball",
                        "content": "I always stick with <= and it worked for me. I rarely modify it and its worked for me"
                    },
                    {
                        "username": "bhavyavohra8",
                        "content": "I get confused a lot"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "There are several patterns for binary search.\\nYou can check them here https://leetcode.com/explore/learn/card/binary-search/"
                    },
                    {
                        "username": "Ankur_028",
                        "content": "This question is all about pivot element. \\nsimply find pivot using binary search, and return min(nums[0], nums[pivot]). \\nI think this help \\uD83D\\uDC4D"
                    },
                    {
                        "username": "nale93",
                        "content": "`return min(nums)` beats 97% on memory and speed."
                    },
                    {
                        "username": "M-Huzaifa-Abdulahad007",
                        "content": "[11,13,15,17]\\nwhat the heck this test case is doing in rotated array question ?"
                    },
                    {
                        "username": "user0888gx",
                        "content": "could be rotated any multiple of 4 times\\n"
                    },
                    {
                        "username": "Akriti1701",
                        "content": "\nThe primary concept behind finding the minimum element in a rotated sorted array is that an element is considered the minimum if the preceding element is greater than it or if there is no preceding element, indicating no rotation has occurred. This can be efficiently accomplished using a binary search approach.\n\nHere are the steps to find the minimum element in a rotated sorted array:\n\nInitialize two pointers, 's' and 'e,' representing the start and end indices of the array, respectively.\n\nEnter a while loop while 's' is less than 'e' (indicating there is still a range to search within).\n\nCalculate the middle index 'mid' as 's + (e - s) / 2.'\n\nCheck if the element at index 's' is less than or equal to the element at index 'e.' If true, it means there is no rotation in this segment, so return the element at index 's' as the minimum.\n\nIf the above condition is not met, check if the element at index 's' is greater than the element at index 'mid.' If true, set 'e' to 'mid' as this indicates that the minimum element must be in the left half of the array.\n\nIf the element at index 'mid' is greater than the element at index 'e,' set 's' to 'mid + 1' as this indicates that the minimum element must be in the right half of the array.\n\nAfter the loop, check again if the element at 's' is less than or equal to the element at 'e.' If true, return the element at 's' as the minimum element.\n\nIf none of the above conditions were met, return -1 to indicate that no minimum element was found (this should not happen in a valid rotated sorted array).\n\n*Time Complexity: O(logn)*\n*Space Complexity: O(1)*\n"
                    },
                    {
                        "username": "ahmedabdoamin997",
                        "content": "        \n        binary search uses on sorted array\n        # so we check if median is greater than last, go right of list \n        # because all elements of left is the greatest (non important)\n\n        #  nums = [3,4,5,1,2]\n        # init : l = 0, r = 4, m = (0+4)/2\n        # stop l < r : return nums[l]\n\n        # l    0 3 3 \n        # r    4 4 3 \n        # m    2 3 "
                    },
                    {
                        "username": "leflxlight",
                        "content": "What is error in this code? \\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        // corner case:\\n        if(nums[0] <= nums[n-1])\\n          {\\n              return nums[0];\\n          }\\n        int s = 0;\\n        int e = n - 1;\\n        int ans = INT_MAX;\\n\\n        while(s<=e)\\n        {\\n            int mid = s + (e - s)/2;\\n            int next = (mid + 1)% n;\\n            int prev = (mid + n - 1) % n;\\n\\n            if(nums[mid]<=nums[next] && nums[mid]<=nums[prev])\\n            {\\n                ans =  nums[mid];\\n                break;\\n            }\\n            if(nums[s]<=nums[mid]){\\n                s = mid + 1;\\n            }\\n            else if(nums[mid]<=nums[e])\\n            {\\n                e = mid - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "gsahu07",
                        "content": "Solved my 50th medium today. Yay!\\n#smallwins"
                    },
                    {
                        "username": "Rivo11",
                        "content": "Conclusion ... If i am in the left sorted .. save the first as min and search right ... else save the mid as min and search left."
                    }
                ]
            },
            {
                "id": 1997475,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "Author tried but coudn\\'t cover up the real task. Came out a super-easy task with a facepalm description."
                    },
                    {
                        "username": "MrxNoobie",
                        "content": "I don\\'t this question is suppose to be in medium section because, it does not really matter because you do this problem in 2 different ways.\\nIf you wish to do binary search then you just have to sort this array yourself\\nor else you can just do it linear way where you just check each value and find the min their.\\nTHIS IS NOT A QUESTION IF YOU JUST THINK IT CALMLY"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "You must write an algorithm that runs in O(log n) time."
                    },
                    {
                        "username": "shubhamsanvariyait",
                        "content": "can someone tell how this is acceptable \\ni wrote a basic code to return smallest number in array and it works"
                    },
                    {
                        "username": "Romijul",
                        "content": "\\uD83D\\uDCA5\\uD83D\\uDCA5\\uD83D\\uDCA5OPTIMAL APPROACH\\u2714\\u2714\\u2714\\n`int binarySearch(vector<int> &a, int s, int e) {`\\n`        while(s<e){`\\n`            int mid=s+(e-s)/2;`\\n`            if(a[mid]>a[e]){`\\n`                s=mid+1; // smallest element is right part `\\n`            }`\\n`            else{`\\n`                e=mid; //smallest element present at the left part , loop start to end (end=mid)`\\n`            }`\\n`        }`\\n`        return s; returning the index of smallest element`\\n`    }`\\n\\n\\nupvote"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Baymax_",
                        "content": "<i>Not sure how the test cases are defined here, but it looks like <b>Linear search is beating the Binary search approach</b></i> 😅"
                    },
                    {
                        "username": "arminmrm93",
                        "content": "Just an observation: It seems that maximum acceptable running time is not set properly for this problem. I just submitted the trivial O(n) solution (we all know what that is!) and it was accepted! "
                    },
                    {
                        "username": "Shashiala1234",
                        "content": "Take first element of the array as min ,and compare min with all elements of the array and at last return min value"
                    },
                    {
                        "username": "Shashiala1234",
                        "content": "[@yogeshputtaswamy93](/yogeshputtaswamy93) \\nyes"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Fortunately, or very unfortunately, this linear approach is actually beating up the binary search approach.\\nI think the test cases are appropriate or no proper time cap is set."
                    },
                    {
                        "username": "bhavyavohra8",
                        "content": "class Solution {\\n    public int findMin(int[] nums) {\\n        int st = 0, end = nums.length-1;\\n        int ans = -1;\\n        while(st <= end){\\n            int mid = st + (end - st)/2;\\n            if(nums[end] < nums[mid]){\\n                st = mid+1;\\n            }else if(nums[end] >= nums[mid]){\\n                ans = mid;\\n                end = mid-1;\\n            }\\n        }        \\n        return nums[ans];\\n    }\\n}\\n\\nwhy I am getting wrong answer?\\nfor the testcase - {3, 1, 2}, it is giving the output as 3 instead of 1."
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue in your code is the line `ans = mid;`. In your binary search, you are assigning `mid` to `ans` when `nums[mid]` is less than or equal to `nums[end]`. This means you\\'re storing the index of the smallest number found so far. However, in the case of a rotation, there may be smaller numbers after this index in the array. \\n\\nWhen you reach the smallest element, `end` is updated to `mid - 1` and then `st` becomes greater than `end` in the next iteration. This breaks the loop and you return `nums[ans]` as the minimum element. But `ans` is not updated in this final iteration and holds the value from the previous iteration, hence the wrong answer.\\n\\nA better approach would be to directly return `nums[st]` after the loop, because `st` would always point to the smallest element when the loop ends. Here\\'s the corrected code:\\n\\n```java\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        int st = 0, end = nums.length-1;\\n        while(st < end) {\\n            int mid = st + (end - st)/2;\\n            if(nums[end] < nums[mid]) {\\n                st = mid + 1;\\n            } else {\\n                end = mid;\\n            }\\n        }\\n        return nums[st];\\n    }\\n}\\n```\\n\\nThis solution is based on the insight that the smallest element is always to the right of the pivot. So, we keep moving the start to mid + 1 if the mid element is greater than the end element. If it\\'s not, that means we\\'re already in the sorted part of the array and we update the end to mid. We keep doing this until start and end meet, which would be pointing to the smallest element."
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think the main idea here is to look in the unsorted half of the array.\nIf it was shifted more than `len(nums)//2` - the minimum will be on the right half.\nIf it was shifted less/equal than `len(nums)//2` - the minimum will be on the left half.\n\n* the `//` signify floor."
                    },
                    {
                        "username": "nkorgik",
                        "content": "I found a solution guys. \\n\\nreturn min(nums) \\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "While it\\'s true that the Python built-in `min()` function can find the minimum value in the list, this approach doesn\\'t satisfy the time complexity constraint provided in the problem statement. \\n\\nThe `min()` function essentially scans the entire list to find the smallest element, which has a time complexity of O(n), where n is the number of elements in the list. This is too slow for large lists and does not utilize the properties of the list (sorted and rotated).\\n\\nThe problem statement asks for a solution with a time complexity of O(log n), implying that a more efficient algorithm like binary search should be used. Binary search works by repeatedly dividing the search space in half, which is much faster than checking every element individually for large lists.\\n\\nHere\\'s a Python code that uses a binary search algorithm to solve this problem:\\n\\n```python\\ndef findMin(nums):\\n    left, right = 0, len(nums) - 1\\n    while left < right:\\n        mid = (left + right) // 2\\n        if nums[mid] > nums[right]:\\n            left = mid + 1\\n        else:\\n            right = mid\\n    return nums[left]\\n```\\n\\nThis solution takes advantage of the fact that the array is sorted (aside from the rotation) to quickly find the minimum element."
                    }
                ]
            },
            {
                "id": 1992211,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "Author tried but coudn\\'t cover up the real task. Came out a super-easy task with a facepalm description."
                    },
                    {
                        "username": "MrxNoobie",
                        "content": "I don\\'t this question is suppose to be in medium section because, it does not really matter because you do this problem in 2 different ways.\\nIf you wish to do binary search then you just have to sort this array yourself\\nor else you can just do it linear way where you just check each value and find the min their.\\nTHIS IS NOT A QUESTION IF YOU JUST THINK IT CALMLY"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "You must write an algorithm that runs in O(log n) time."
                    },
                    {
                        "username": "shubhamsanvariyait",
                        "content": "can someone tell how this is acceptable \\ni wrote a basic code to return smallest number in array and it works"
                    },
                    {
                        "username": "Romijul",
                        "content": "\\uD83D\\uDCA5\\uD83D\\uDCA5\\uD83D\\uDCA5OPTIMAL APPROACH\\u2714\\u2714\\u2714\\n`int binarySearch(vector<int> &a, int s, int e) {`\\n`        while(s<e){`\\n`            int mid=s+(e-s)/2;`\\n`            if(a[mid]>a[e]){`\\n`                s=mid+1; // smallest element is right part `\\n`            }`\\n`            else{`\\n`                e=mid; //smallest element present at the left part , loop start to end (end=mid)`\\n`            }`\\n`        }`\\n`        return s; returning the index of smallest element`\\n`    }`\\n\\n\\nupvote"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Baymax_",
                        "content": "<i>Not sure how the test cases are defined here, but it looks like <b>Linear search is beating the Binary search approach</b></i> 😅"
                    },
                    {
                        "username": "arminmrm93",
                        "content": "Just an observation: It seems that maximum acceptable running time is not set properly for this problem. I just submitted the trivial O(n) solution (we all know what that is!) and it was accepted! "
                    },
                    {
                        "username": "Shashiala1234",
                        "content": "Take first element of the array as min ,and compare min with all elements of the array and at last return min value"
                    },
                    {
                        "username": "Shashiala1234",
                        "content": "[@yogeshputtaswamy93](/yogeshputtaswamy93) \\nyes"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Fortunately, or very unfortunately, this linear approach is actually beating up the binary search approach.\\nI think the test cases are appropriate or no proper time cap is set."
                    },
                    {
                        "username": "bhavyavohra8",
                        "content": "class Solution {\\n    public int findMin(int[] nums) {\\n        int st = 0, end = nums.length-1;\\n        int ans = -1;\\n        while(st <= end){\\n            int mid = st + (end - st)/2;\\n            if(nums[end] < nums[mid]){\\n                st = mid+1;\\n            }else if(nums[end] >= nums[mid]){\\n                ans = mid;\\n                end = mid-1;\\n            }\\n        }        \\n        return nums[ans];\\n    }\\n}\\n\\nwhy I am getting wrong answer?\\nfor the testcase - {3, 1, 2}, it is giving the output as 3 instead of 1."
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue in your code is the line `ans = mid;`. In your binary search, you are assigning `mid` to `ans` when `nums[mid]` is less than or equal to `nums[end]`. This means you\\'re storing the index of the smallest number found so far. However, in the case of a rotation, there may be smaller numbers after this index in the array. \\n\\nWhen you reach the smallest element, `end` is updated to `mid - 1` and then `st` becomes greater than `end` in the next iteration. This breaks the loop and you return `nums[ans]` as the minimum element. But `ans` is not updated in this final iteration and holds the value from the previous iteration, hence the wrong answer.\\n\\nA better approach would be to directly return `nums[st]` after the loop, because `st` would always point to the smallest element when the loop ends. Here\\'s the corrected code:\\n\\n```java\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        int st = 0, end = nums.length-1;\\n        while(st < end) {\\n            int mid = st + (end - st)/2;\\n            if(nums[end] < nums[mid]) {\\n                st = mid + 1;\\n            } else {\\n                end = mid;\\n            }\\n        }\\n        return nums[st];\\n    }\\n}\\n```\\n\\nThis solution is based on the insight that the smallest element is always to the right of the pivot. So, we keep moving the start to mid + 1 if the mid element is greater than the end element. If it\\'s not, that means we\\'re already in the sorted part of the array and we update the end to mid. We keep doing this until start and end meet, which would be pointing to the smallest element."
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think the main idea here is to look in the unsorted half of the array.\nIf it was shifted more than `len(nums)//2` - the minimum will be on the right half.\nIf it was shifted less/equal than `len(nums)//2` - the minimum will be on the left half.\n\n* the `//` signify floor."
                    },
                    {
                        "username": "nkorgik",
                        "content": "I found a solution guys. \\n\\nreturn min(nums) \\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "While it\\'s true that the Python built-in `min()` function can find the minimum value in the list, this approach doesn\\'t satisfy the time complexity constraint provided in the problem statement. \\n\\nThe `min()` function essentially scans the entire list to find the smallest element, which has a time complexity of O(n), where n is the number of elements in the list. This is too slow for large lists and does not utilize the properties of the list (sorted and rotated).\\n\\nThe problem statement asks for a solution with a time complexity of O(log n), implying that a more efficient algorithm like binary search should be used. Binary search works by repeatedly dividing the search space in half, which is much faster than checking every element individually for large lists.\\n\\nHere\\'s a Python code that uses a binary search algorithm to solve this problem:\\n\\n```python\\ndef findMin(nums):\\n    left, right = 0, len(nums) - 1\\n    while left < right:\\n        mid = (left + right) // 2\\n        if nums[mid] > nums[right]:\\n            left = mid + 1\\n        else:\\n            right = mid\\n    return nums[left]\\n```\\n\\nThis solution takes advantage of the fact that the array is sorted (aside from the rotation) to quickly find the minimum element."
                    }
                ]
            },
            {
                "id": 1991926,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "Author tried but coudn\\'t cover up the real task. Came out a super-easy task with a facepalm description."
                    },
                    {
                        "username": "MrxNoobie",
                        "content": "I don\\'t this question is suppose to be in medium section because, it does not really matter because you do this problem in 2 different ways.\\nIf you wish to do binary search then you just have to sort this array yourself\\nor else you can just do it linear way where you just check each value and find the min their.\\nTHIS IS NOT A QUESTION IF YOU JUST THINK IT CALMLY"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "You must write an algorithm that runs in O(log n) time."
                    },
                    {
                        "username": "shubhamsanvariyait",
                        "content": "can someone tell how this is acceptable \\ni wrote a basic code to return smallest number in array and it works"
                    },
                    {
                        "username": "Romijul",
                        "content": "\\uD83D\\uDCA5\\uD83D\\uDCA5\\uD83D\\uDCA5OPTIMAL APPROACH\\u2714\\u2714\\u2714\\n`int binarySearch(vector<int> &a, int s, int e) {`\\n`        while(s<e){`\\n`            int mid=s+(e-s)/2;`\\n`            if(a[mid]>a[e]){`\\n`                s=mid+1; // smallest element is right part `\\n`            }`\\n`            else{`\\n`                e=mid; //smallest element present at the left part , loop start to end (end=mid)`\\n`            }`\\n`        }`\\n`        return s; returning the index of smallest element`\\n`    }`\\n\\n\\nupvote"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Baymax_",
                        "content": "<i>Not sure how the test cases are defined here, but it looks like <b>Linear search is beating the Binary search approach</b></i> 😅"
                    },
                    {
                        "username": "arminmrm93",
                        "content": "Just an observation: It seems that maximum acceptable running time is not set properly for this problem. I just submitted the trivial O(n) solution (we all know what that is!) and it was accepted! "
                    },
                    {
                        "username": "Shashiala1234",
                        "content": "Take first element of the array as min ,and compare min with all elements of the array and at last return min value"
                    },
                    {
                        "username": "Shashiala1234",
                        "content": "[@yogeshputtaswamy93](/yogeshputtaswamy93) \\nyes"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Fortunately, or very unfortunately, this linear approach is actually beating up the binary search approach.\\nI think the test cases are appropriate or no proper time cap is set."
                    },
                    {
                        "username": "bhavyavohra8",
                        "content": "class Solution {\\n    public int findMin(int[] nums) {\\n        int st = 0, end = nums.length-1;\\n        int ans = -1;\\n        while(st <= end){\\n            int mid = st + (end - st)/2;\\n            if(nums[end] < nums[mid]){\\n                st = mid+1;\\n            }else if(nums[end] >= nums[mid]){\\n                ans = mid;\\n                end = mid-1;\\n            }\\n        }        \\n        return nums[ans];\\n    }\\n}\\n\\nwhy I am getting wrong answer?\\nfor the testcase - {3, 1, 2}, it is giving the output as 3 instead of 1."
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue in your code is the line `ans = mid;`. In your binary search, you are assigning `mid` to `ans` when `nums[mid]` is less than or equal to `nums[end]`. This means you\\'re storing the index of the smallest number found so far. However, in the case of a rotation, there may be smaller numbers after this index in the array. \\n\\nWhen you reach the smallest element, `end` is updated to `mid - 1` and then `st` becomes greater than `end` in the next iteration. This breaks the loop and you return `nums[ans]` as the minimum element. But `ans` is not updated in this final iteration and holds the value from the previous iteration, hence the wrong answer.\\n\\nA better approach would be to directly return `nums[st]` after the loop, because `st` would always point to the smallest element when the loop ends. Here\\'s the corrected code:\\n\\n```java\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        int st = 0, end = nums.length-1;\\n        while(st < end) {\\n            int mid = st + (end - st)/2;\\n            if(nums[end] < nums[mid]) {\\n                st = mid + 1;\\n            } else {\\n                end = mid;\\n            }\\n        }\\n        return nums[st];\\n    }\\n}\\n```\\n\\nThis solution is based on the insight that the smallest element is always to the right of the pivot. So, we keep moving the start to mid + 1 if the mid element is greater than the end element. If it\\'s not, that means we\\'re already in the sorted part of the array and we update the end to mid. We keep doing this until start and end meet, which would be pointing to the smallest element."
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think the main idea here is to look in the unsorted half of the array.\nIf it was shifted more than `len(nums)//2` - the minimum will be on the right half.\nIf it was shifted less/equal than `len(nums)//2` - the minimum will be on the left half.\n\n* the `//` signify floor."
                    },
                    {
                        "username": "nkorgik",
                        "content": "I found a solution guys. \\n\\nreturn min(nums) \\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "While it\\'s true that the Python built-in `min()` function can find the minimum value in the list, this approach doesn\\'t satisfy the time complexity constraint provided in the problem statement. \\n\\nThe `min()` function essentially scans the entire list to find the smallest element, which has a time complexity of O(n), where n is the number of elements in the list. This is too slow for large lists and does not utilize the properties of the list (sorted and rotated).\\n\\nThe problem statement asks for a solution with a time complexity of O(log n), implying that a more efficient algorithm like binary search should be used. Binary search works by repeatedly dividing the search space in half, which is much faster than checking every element individually for large lists.\\n\\nHere\\'s a Python code that uses a binary search algorithm to solve this problem:\\n\\n```python\\ndef findMin(nums):\\n    left, right = 0, len(nums) - 1\\n    while left < right:\\n        mid = (left + right) // 2\\n        if nums[mid] > nums[right]:\\n            left = mid + 1\\n        else:\\n            right = mid\\n    return nums[left]\\n```\\n\\nThis solution takes advantage of the fact that the array is sorted (aside from the rotation) to quickly find the minimum element."
                    }
                ]
            },
            {
                "id": 1983451,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "Author tried but coudn\\'t cover up the real task. Came out a super-easy task with a facepalm description."
                    },
                    {
                        "username": "MrxNoobie",
                        "content": "I don\\'t this question is suppose to be in medium section because, it does not really matter because you do this problem in 2 different ways.\\nIf you wish to do binary search then you just have to sort this array yourself\\nor else you can just do it linear way where you just check each value and find the min their.\\nTHIS IS NOT A QUESTION IF YOU JUST THINK IT CALMLY"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "You must write an algorithm that runs in O(log n) time."
                    },
                    {
                        "username": "shubhamsanvariyait",
                        "content": "can someone tell how this is acceptable \\ni wrote a basic code to return smallest number in array and it works"
                    },
                    {
                        "username": "Romijul",
                        "content": "\\uD83D\\uDCA5\\uD83D\\uDCA5\\uD83D\\uDCA5OPTIMAL APPROACH\\u2714\\u2714\\u2714\\n`int binarySearch(vector<int> &a, int s, int e) {`\\n`        while(s<e){`\\n`            int mid=s+(e-s)/2;`\\n`            if(a[mid]>a[e]){`\\n`                s=mid+1; // smallest element is right part `\\n`            }`\\n`            else{`\\n`                e=mid; //smallest element present at the left part , loop start to end (end=mid)`\\n`            }`\\n`        }`\\n`        return s; returning the index of smallest element`\\n`    }`\\n\\n\\nupvote"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Baymax_",
                        "content": "<i>Not sure how the test cases are defined here, but it looks like <b>Linear search is beating the Binary search approach</b></i> 😅"
                    },
                    {
                        "username": "arminmrm93",
                        "content": "Just an observation: It seems that maximum acceptable running time is not set properly for this problem. I just submitted the trivial O(n) solution (we all know what that is!) and it was accepted! "
                    },
                    {
                        "username": "Shashiala1234",
                        "content": "Take first element of the array as min ,and compare min with all elements of the array and at last return min value"
                    },
                    {
                        "username": "Shashiala1234",
                        "content": "[@yogeshputtaswamy93](/yogeshputtaswamy93) \\nyes"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Fortunately, or very unfortunately, this linear approach is actually beating up the binary search approach.\\nI think the test cases are appropriate or no proper time cap is set."
                    },
                    {
                        "username": "bhavyavohra8",
                        "content": "class Solution {\\n    public int findMin(int[] nums) {\\n        int st = 0, end = nums.length-1;\\n        int ans = -1;\\n        while(st <= end){\\n            int mid = st + (end - st)/2;\\n            if(nums[end] < nums[mid]){\\n                st = mid+1;\\n            }else if(nums[end] >= nums[mid]){\\n                ans = mid;\\n                end = mid-1;\\n            }\\n        }        \\n        return nums[ans];\\n    }\\n}\\n\\nwhy I am getting wrong answer?\\nfor the testcase - {3, 1, 2}, it is giving the output as 3 instead of 1."
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue in your code is the line `ans = mid;`. In your binary search, you are assigning `mid` to `ans` when `nums[mid]` is less than or equal to `nums[end]`. This means you\\'re storing the index of the smallest number found so far. However, in the case of a rotation, there may be smaller numbers after this index in the array. \\n\\nWhen you reach the smallest element, `end` is updated to `mid - 1` and then `st` becomes greater than `end` in the next iteration. This breaks the loop and you return `nums[ans]` as the minimum element. But `ans` is not updated in this final iteration and holds the value from the previous iteration, hence the wrong answer.\\n\\nA better approach would be to directly return `nums[st]` after the loop, because `st` would always point to the smallest element when the loop ends. Here\\'s the corrected code:\\n\\n```java\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        int st = 0, end = nums.length-1;\\n        while(st < end) {\\n            int mid = st + (end - st)/2;\\n            if(nums[end] < nums[mid]) {\\n                st = mid + 1;\\n            } else {\\n                end = mid;\\n            }\\n        }\\n        return nums[st];\\n    }\\n}\\n```\\n\\nThis solution is based on the insight that the smallest element is always to the right of the pivot. So, we keep moving the start to mid + 1 if the mid element is greater than the end element. If it\\'s not, that means we\\'re already in the sorted part of the array and we update the end to mid. We keep doing this until start and end meet, which would be pointing to the smallest element."
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think the main idea here is to look in the unsorted half of the array.\nIf it was shifted more than `len(nums)//2` - the minimum will be on the right half.\nIf it was shifted less/equal than `len(nums)//2` - the minimum will be on the left half.\n\n* the `//` signify floor."
                    },
                    {
                        "username": "nkorgik",
                        "content": "I found a solution guys. \\n\\nreturn min(nums) \\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "While it\\'s true that the Python built-in `min()` function can find the minimum value in the list, this approach doesn\\'t satisfy the time complexity constraint provided in the problem statement. \\n\\nThe `min()` function essentially scans the entire list to find the smallest element, which has a time complexity of O(n), where n is the number of elements in the list. This is too slow for large lists and does not utilize the properties of the list (sorted and rotated).\\n\\nThe problem statement asks for a solution with a time complexity of O(log n), implying that a more efficient algorithm like binary search should be used. Binary search works by repeatedly dividing the search space in half, which is much faster than checking every element individually for large lists.\\n\\nHere\\'s a Python code that uses a binary search algorithm to solve this problem:\\n\\n```python\\ndef findMin(nums):\\n    left, right = 0, len(nums) - 1\\n    while left < right:\\n        mid = (left + right) // 2\\n        if nums[mid] > nums[right]:\\n            left = mid + 1\\n        else:\\n            right = mid\\n    return nums[left]\\n```\\n\\nThis solution takes advantage of the fact that the array is sorted (aside from the rotation) to quickly find the minimum element."
                    }
                ]
            },
            {
                "id": 1969502,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "Author tried but coudn\\'t cover up the real task. Came out a super-easy task with a facepalm description."
                    },
                    {
                        "username": "MrxNoobie",
                        "content": "I don\\'t this question is suppose to be in medium section because, it does not really matter because you do this problem in 2 different ways.\\nIf you wish to do binary search then you just have to sort this array yourself\\nor else you can just do it linear way where you just check each value and find the min their.\\nTHIS IS NOT A QUESTION IF YOU JUST THINK IT CALMLY"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "You must write an algorithm that runs in O(log n) time."
                    },
                    {
                        "username": "shubhamsanvariyait",
                        "content": "can someone tell how this is acceptable \\ni wrote a basic code to return smallest number in array and it works"
                    },
                    {
                        "username": "Romijul",
                        "content": "\\uD83D\\uDCA5\\uD83D\\uDCA5\\uD83D\\uDCA5OPTIMAL APPROACH\\u2714\\u2714\\u2714\\n`int binarySearch(vector<int> &a, int s, int e) {`\\n`        while(s<e){`\\n`            int mid=s+(e-s)/2;`\\n`            if(a[mid]>a[e]){`\\n`                s=mid+1; // smallest element is right part `\\n`            }`\\n`            else{`\\n`                e=mid; //smallest element present at the left part , loop start to end (end=mid)`\\n`            }`\\n`        }`\\n`        return s; returning the index of smallest element`\\n`    }`\\n\\n\\nupvote"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Baymax_",
                        "content": "<i>Not sure how the test cases are defined here, but it looks like <b>Linear search is beating the Binary search approach</b></i> 😅"
                    },
                    {
                        "username": "arminmrm93",
                        "content": "Just an observation: It seems that maximum acceptable running time is not set properly for this problem. I just submitted the trivial O(n) solution (we all know what that is!) and it was accepted! "
                    },
                    {
                        "username": "Shashiala1234",
                        "content": "Take first element of the array as min ,and compare min with all elements of the array and at last return min value"
                    },
                    {
                        "username": "Shashiala1234",
                        "content": "[@yogeshputtaswamy93](/yogeshputtaswamy93) \\nyes"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Fortunately, or very unfortunately, this linear approach is actually beating up the binary search approach.\\nI think the test cases are appropriate or no proper time cap is set."
                    },
                    {
                        "username": "bhavyavohra8",
                        "content": "class Solution {\\n    public int findMin(int[] nums) {\\n        int st = 0, end = nums.length-1;\\n        int ans = -1;\\n        while(st <= end){\\n            int mid = st + (end - st)/2;\\n            if(nums[end] < nums[mid]){\\n                st = mid+1;\\n            }else if(nums[end] >= nums[mid]){\\n                ans = mid;\\n                end = mid-1;\\n            }\\n        }        \\n        return nums[ans];\\n    }\\n}\\n\\nwhy I am getting wrong answer?\\nfor the testcase - {3, 1, 2}, it is giving the output as 3 instead of 1."
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue in your code is the line `ans = mid;`. In your binary search, you are assigning `mid` to `ans` when `nums[mid]` is less than or equal to `nums[end]`. This means you\\'re storing the index of the smallest number found so far. However, in the case of a rotation, there may be smaller numbers after this index in the array. \\n\\nWhen you reach the smallest element, `end` is updated to `mid - 1` and then `st` becomes greater than `end` in the next iteration. This breaks the loop and you return `nums[ans]` as the minimum element. But `ans` is not updated in this final iteration and holds the value from the previous iteration, hence the wrong answer.\\n\\nA better approach would be to directly return `nums[st]` after the loop, because `st` would always point to the smallest element when the loop ends. Here\\'s the corrected code:\\n\\n```java\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        int st = 0, end = nums.length-1;\\n        while(st < end) {\\n            int mid = st + (end - st)/2;\\n            if(nums[end] < nums[mid]) {\\n                st = mid + 1;\\n            } else {\\n                end = mid;\\n            }\\n        }\\n        return nums[st];\\n    }\\n}\\n```\\n\\nThis solution is based on the insight that the smallest element is always to the right of the pivot. So, we keep moving the start to mid + 1 if the mid element is greater than the end element. If it\\'s not, that means we\\'re already in the sorted part of the array and we update the end to mid. We keep doing this until start and end meet, which would be pointing to the smallest element."
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think the main idea here is to look in the unsorted half of the array.\nIf it was shifted more than `len(nums)//2` - the minimum will be on the right half.\nIf it was shifted less/equal than `len(nums)//2` - the minimum will be on the left half.\n\n* the `//` signify floor."
                    },
                    {
                        "username": "nkorgik",
                        "content": "I found a solution guys. \\n\\nreturn min(nums) \\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "While it\\'s true that the Python built-in `min()` function can find the minimum value in the list, this approach doesn\\'t satisfy the time complexity constraint provided in the problem statement. \\n\\nThe `min()` function essentially scans the entire list to find the smallest element, which has a time complexity of O(n), where n is the number of elements in the list. This is too slow for large lists and does not utilize the properties of the list (sorted and rotated).\\n\\nThe problem statement asks for a solution with a time complexity of O(log n), implying that a more efficient algorithm like binary search should be used. Binary search works by repeatedly dividing the search space in half, which is much faster than checking every element individually for large lists.\\n\\nHere\\'s a Python code that uses a binary search algorithm to solve this problem:\\n\\n```python\\ndef findMin(nums):\\n    left, right = 0, len(nums) - 1\\n    while left < right:\\n        mid = (left + right) // 2\\n        if nums[mid] > nums[right]:\\n            left = mid + 1\\n        else:\\n            right = mid\\n    return nums[left]\\n```\\n\\nThis solution takes advantage of the fact that the array is sorted (aside from the rotation) to quickly find the minimum element."
                    }
                ]
            },
            {
                "id": 1967548,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "Author tried but coudn\\'t cover up the real task. Came out a super-easy task with a facepalm description."
                    },
                    {
                        "username": "MrxNoobie",
                        "content": "I don\\'t this question is suppose to be in medium section because, it does not really matter because you do this problem in 2 different ways.\\nIf you wish to do binary search then you just have to sort this array yourself\\nor else you can just do it linear way where you just check each value and find the min their.\\nTHIS IS NOT A QUESTION IF YOU JUST THINK IT CALMLY"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "You must write an algorithm that runs in O(log n) time."
                    },
                    {
                        "username": "shubhamsanvariyait",
                        "content": "can someone tell how this is acceptable \\ni wrote a basic code to return smallest number in array and it works"
                    },
                    {
                        "username": "Romijul",
                        "content": "\\uD83D\\uDCA5\\uD83D\\uDCA5\\uD83D\\uDCA5OPTIMAL APPROACH\\u2714\\u2714\\u2714\\n`int binarySearch(vector<int> &a, int s, int e) {`\\n`        while(s<e){`\\n`            int mid=s+(e-s)/2;`\\n`            if(a[mid]>a[e]){`\\n`                s=mid+1; // smallest element is right part `\\n`            }`\\n`            else{`\\n`                e=mid; //smallest element present at the left part , loop start to end (end=mid)`\\n`            }`\\n`        }`\\n`        return s; returning the index of smallest element`\\n`    }`\\n\\n\\nupvote"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Baymax_",
                        "content": "<i>Not sure how the test cases are defined here, but it looks like <b>Linear search is beating the Binary search approach</b></i> 😅"
                    },
                    {
                        "username": "arminmrm93",
                        "content": "Just an observation: It seems that maximum acceptable running time is not set properly for this problem. I just submitted the trivial O(n) solution (we all know what that is!) and it was accepted! "
                    },
                    {
                        "username": "Shashiala1234",
                        "content": "Take first element of the array as min ,and compare min with all elements of the array and at last return min value"
                    },
                    {
                        "username": "Shashiala1234",
                        "content": "[@yogeshputtaswamy93](/yogeshputtaswamy93) \\nyes"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Fortunately, or very unfortunately, this linear approach is actually beating up the binary search approach.\\nI think the test cases are appropriate or no proper time cap is set."
                    },
                    {
                        "username": "bhavyavohra8",
                        "content": "class Solution {\\n    public int findMin(int[] nums) {\\n        int st = 0, end = nums.length-1;\\n        int ans = -1;\\n        while(st <= end){\\n            int mid = st + (end - st)/2;\\n            if(nums[end] < nums[mid]){\\n                st = mid+1;\\n            }else if(nums[end] >= nums[mid]){\\n                ans = mid;\\n                end = mid-1;\\n            }\\n        }        \\n        return nums[ans];\\n    }\\n}\\n\\nwhy I am getting wrong answer?\\nfor the testcase - {3, 1, 2}, it is giving the output as 3 instead of 1."
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue in your code is the line `ans = mid;`. In your binary search, you are assigning `mid` to `ans` when `nums[mid]` is less than or equal to `nums[end]`. This means you\\'re storing the index of the smallest number found so far. However, in the case of a rotation, there may be smaller numbers after this index in the array. \\n\\nWhen you reach the smallest element, `end` is updated to `mid - 1` and then `st` becomes greater than `end` in the next iteration. This breaks the loop and you return `nums[ans]` as the minimum element. But `ans` is not updated in this final iteration and holds the value from the previous iteration, hence the wrong answer.\\n\\nA better approach would be to directly return `nums[st]` after the loop, because `st` would always point to the smallest element when the loop ends. Here\\'s the corrected code:\\n\\n```java\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        int st = 0, end = nums.length-1;\\n        while(st < end) {\\n            int mid = st + (end - st)/2;\\n            if(nums[end] < nums[mid]) {\\n                st = mid + 1;\\n            } else {\\n                end = mid;\\n            }\\n        }\\n        return nums[st];\\n    }\\n}\\n```\\n\\nThis solution is based on the insight that the smallest element is always to the right of the pivot. So, we keep moving the start to mid + 1 if the mid element is greater than the end element. If it\\'s not, that means we\\'re already in the sorted part of the array and we update the end to mid. We keep doing this until start and end meet, which would be pointing to the smallest element."
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think the main idea here is to look in the unsorted half of the array.\nIf it was shifted more than `len(nums)//2` - the minimum will be on the right half.\nIf it was shifted less/equal than `len(nums)//2` - the minimum will be on the left half.\n\n* the `//` signify floor."
                    },
                    {
                        "username": "nkorgik",
                        "content": "I found a solution guys. \\n\\nreturn min(nums) \\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "While it\\'s true that the Python built-in `min()` function can find the minimum value in the list, this approach doesn\\'t satisfy the time complexity constraint provided in the problem statement. \\n\\nThe `min()` function essentially scans the entire list to find the smallest element, which has a time complexity of O(n), where n is the number of elements in the list. This is too slow for large lists and does not utilize the properties of the list (sorted and rotated).\\n\\nThe problem statement asks for a solution with a time complexity of O(log n), implying that a more efficient algorithm like binary search should be used. Binary search works by repeatedly dividing the search space in half, which is much faster than checking every element individually for large lists.\\n\\nHere\\'s a Python code that uses a binary search algorithm to solve this problem:\\n\\n```python\\ndef findMin(nums):\\n    left, right = 0, len(nums) - 1\\n    while left < right:\\n        mid = (left + right) // 2\\n        if nums[mid] > nums[right]:\\n            left = mid + 1\\n        else:\\n            right = mid\\n    return nums[left]\\n```\\n\\nThis solution takes advantage of the fact that the array is sorted (aside from the rotation) to quickly find the minimum element."
                    }
                ]
            },
            {
                "id": 1967132,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "Author tried but coudn\\'t cover up the real task. Came out a super-easy task with a facepalm description."
                    },
                    {
                        "username": "MrxNoobie",
                        "content": "I don\\'t this question is suppose to be in medium section because, it does not really matter because you do this problem in 2 different ways.\\nIf you wish to do binary search then you just have to sort this array yourself\\nor else you can just do it linear way where you just check each value and find the min their.\\nTHIS IS NOT A QUESTION IF YOU JUST THINK IT CALMLY"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "You must write an algorithm that runs in O(log n) time."
                    },
                    {
                        "username": "shubhamsanvariyait",
                        "content": "can someone tell how this is acceptable \\ni wrote a basic code to return smallest number in array and it works"
                    },
                    {
                        "username": "Romijul",
                        "content": "\\uD83D\\uDCA5\\uD83D\\uDCA5\\uD83D\\uDCA5OPTIMAL APPROACH\\u2714\\u2714\\u2714\\n`int binarySearch(vector<int> &a, int s, int e) {`\\n`        while(s<e){`\\n`            int mid=s+(e-s)/2;`\\n`            if(a[mid]>a[e]){`\\n`                s=mid+1; // smallest element is right part `\\n`            }`\\n`            else{`\\n`                e=mid; //smallest element present at the left part , loop start to end (end=mid)`\\n`            }`\\n`        }`\\n`        return s; returning the index of smallest element`\\n`    }`\\n\\n\\nupvote"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Baymax_",
                        "content": "<i>Not sure how the test cases are defined here, but it looks like <b>Linear search is beating the Binary search approach</b></i> 😅"
                    },
                    {
                        "username": "arminmrm93",
                        "content": "Just an observation: It seems that maximum acceptable running time is not set properly for this problem. I just submitted the trivial O(n) solution (we all know what that is!) and it was accepted! "
                    },
                    {
                        "username": "Shashiala1234",
                        "content": "Take first element of the array as min ,and compare min with all elements of the array and at last return min value"
                    },
                    {
                        "username": "Shashiala1234",
                        "content": "[@yogeshputtaswamy93](/yogeshputtaswamy93) \\nyes"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Fortunately, or very unfortunately, this linear approach is actually beating up the binary search approach.\\nI think the test cases are appropriate or no proper time cap is set."
                    },
                    {
                        "username": "bhavyavohra8",
                        "content": "class Solution {\\n    public int findMin(int[] nums) {\\n        int st = 0, end = nums.length-1;\\n        int ans = -1;\\n        while(st <= end){\\n            int mid = st + (end - st)/2;\\n            if(nums[end] < nums[mid]){\\n                st = mid+1;\\n            }else if(nums[end] >= nums[mid]){\\n                ans = mid;\\n                end = mid-1;\\n            }\\n        }        \\n        return nums[ans];\\n    }\\n}\\n\\nwhy I am getting wrong answer?\\nfor the testcase - {3, 1, 2}, it is giving the output as 3 instead of 1."
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue in your code is the line `ans = mid;`. In your binary search, you are assigning `mid` to `ans` when `nums[mid]` is less than or equal to `nums[end]`. This means you\\'re storing the index of the smallest number found so far. However, in the case of a rotation, there may be smaller numbers after this index in the array. \\n\\nWhen you reach the smallest element, `end` is updated to `mid - 1` and then `st` becomes greater than `end` in the next iteration. This breaks the loop and you return `nums[ans]` as the minimum element. But `ans` is not updated in this final iteration and holds the value from the previous iteration, hence the wrong answer.\\n\\nA better approach would be to directly return `nums[st]` after the loop, because `st` would always point to the smallest element when the loop ends. Here\\'s the corrected code:\\n\\n```java\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        int st = 0, end = nums.length-1;\\n        while(st < end) {\\n            int mid = st + (end - st)/2;\\n            if(nums[end] < nums[mid]) {\\n                st = mid + 1;\\n            } else {\\n                end = mid;\\n            }\\n        }\\n        return nums[st];\\n    }\\n}\\n```\\n\\nThis solution is based on the insight that the smallest element is always to the right of the pivot. So, we keep moving the start to mid + 1 if the mid element is greater than the end element. If it\\'s not, that means we\\'re already in the sorted part of the array and we update the end to mid. We keep doing this until start and end meet, which would be pointing to the smallest element."
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think the main idea here is to look in the unsorted half of the array.\nIf it was shifted more than `len(nums)//2` - the minimum will be on the right half.\nIf it was shifted less/equal than `len(nums)//2` - the minimum will be on the left half.\n\n* the `//` signify floor."
                    },
                    {
                        "username": "nkorgik",
                        "content": "I found a solution guys. \\n\\nreturn min(nums) \\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "While it\\'s true that the Python built-in `min()` function can find the minimum value in the list, this approach doesn\\'t satisfy the time complexity constraint provided in the problem statement. \\n\\nThe `min()` function essentially scans the entire list to find the smallest element, which has a time complexity of O(n), where n is the number of elements in the list. This is too slow for large lists and does not utilize the properties of the list (sorted and rotated).\\n\\nThe problem statement asks for a solution with a time complexity of O(log n), implying that a more efficient algorithm like binary search should be used. Binary search works by repeatedly dividing the search space in half, which is much faster than checking every element individually for large lists.\\n\\nHere\\'s a Python code that uses a binary search algorithm to solve this problem:\\n\\n```python\\ndef findMin(nums):\\n    left, right = 0, len(nums) - 1\\n    while left < right:\\n        mid = (left + right) // 2\\n        if nums[mid] > nums[right]:\\n            left = mid + 1\\n        else:\\n            right = mid\\n    return nums[left]\\n```\\n\\nThis solution takes advantage of the fact that the array is sorted (aside from the rotation) to quickly find the minimum element."
                    }
                ]
            },
            {
                "id": 1942697,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "Author tried but coudn\\'t cover up the real task. Came out a super-easy task with a facepalm description."
                    },
                    {
                        "username": "MrxNoobie",
                        "content": "I don\\'t this question is suppose to be in medium section because, it does not really matter because you do this problem in 2 different ways.\\nIf you wish to do binary search then you just have to sort this array yourself\\nor else you can just do it linear way where you just check each value and find the min their.\\nTHIS IS NOT A QUESTION IF YOU JUST THINK IT CALMLY"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "You must write an algorithm that runs in O(log n) time."
                    },
                    {
                        "username": "shubhamsanvariyait",
                        "content": "can someone tell how this is acceptable \\ni wrote a basic code to return smallest number in array and it works"
                    },
                    {
                        "username": "Romijul",
                        "content": "\\uD83D\\uDCA5\\uD83D\\uDCA5\\uD83D\\uDCA5OPTIMAL APPROACH\\u2714\\u2714\\u2714\\n`int binarySearch(vector<int> &a, int s, int e) {`\\n`        while(s<e){`\\n`            int mid=s+(e-s)/2;`\\n`            if(a[mid]>a[e]){`\\n`                s=mid+1; // smallest element is right part `\\n`            }`\\n`            else{`\\n`                e=mid; //smallest element present at the left part , loop start to end (end=mid)`\\n`            }`\\n`        }`\\n`        return s; returning the index of smallest element`\\n`    }`\\n\\n\\nupvote"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Baymax_",
                        "content": "<i>Not sure how the test cases are defined here, but it looks like <b>Linear search is beating the Binary search approach</b></i> 😅"
                    },
                    {
                        "username": "arminmrm93",
                        "content": "Just an observation: It seems that maximum acceptable running time is not set properly for this problem. I just submitted the trivial O(n) solution (we all know what that is!) and it was accepted! "
                    },
                    {
                        "username": "Shashiala1234",
                        "content": "Take first element of the array as min ,and compare min with all elements of the array and at last return min value"
                    },
                    {
                        "username": "Shashiala1234",
                        "content": "[@yogeshputtaswamy93](/yogeshputtaswamy93) \\nyes"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Fortunately, or very unfortunately, this linear approach is actually beating up the binary search approach.\\nI think the test cases are appropriate or no proper time cap is set."
                    },
                    {
                        "username": "bhavyavohra8",
                        "content": "class Solution {\\n    public int findMin(int[] nums) {\\n        int st = 0, end = nums.length-1;\\n        int ans = -1;\\n        while(st <= end){\\n            int mid = st + (end - st)/2;\\n            if(nums[end] < nums[mid]){\\n                st = mid+1;\\n            }else if(nums[end] >= nums[mid]){\\n                ans = mid;\\n                end = mid-1;\\n            }\\n        }        \\n        return nums[ans];\\n    }\\n}\\n\\nwhy I am getting wrong answer?\\nfor the testcase - {3, 1, 2}, it is giving the output as 3 instead of 1."
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue in your code is the line `ans = mid;`. In your binary search, you are assigning `mid` to `ans` when `nums[mid]` is less than or equal to `nums[end]`. This means you\\'re storing the index of the smallest number found so far. However, in the case of a rotation, there may be smaller numbers after this index in the array. \\n\\nWhen you reach the smallest element, `end` is updated to `mid - 1` and then `st` becomes greater than `end` in the next iteration. This breaks the loop and you return `nums[ans]` as the minimum element. But `ans` is not updated in this final iteration and holds the value from the previous iteration, hence the wrong answer.\\n\\nA better approach would be to directly return `nums[st]` after the loop, because `st` would always point to the smallest element when the loop ends. Here\\'s the corrected code:\\n\\n```java\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        int st = 0, end = nums.length-1;\\n        while(st < end) {\\n            int mid = st + (end - st)/2;\\n            if(nums[end] < nums[mid]) {\\n                st = mid + 1;\\n            } else {\\n                end = mid;\\n            }\\n        }\\n        return nums[st];\\n    }\\n}\\n```\\n\\nThis solution is based on the insight that the smallest element is always to the right of the pivot. So, we keep moving the start to mid + 1 if the mid element is greater than the end element. If it\\'s not, that means we\\'re already in the sorted part of the array and we update the end to mid. We keep doing this until start and end meet, which would be pointing to the smallest element."
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think the main idea here is to look in the unsorted half of the array.\nIf it was shifted more than `len(nums)//2` - the minimum will be on the right half.\nIf it was shifted less/equal than `len(nums)//2` - the minimum will be on the left half.\n\n* the `//` signify floor."
                    },
                    {
                        "username": "nkorgik",
                        "content": "I found a solution guys. \\n\\nreturn min(nums) \\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "While it\\'s true that the Python built-in `min()` function can find the minimum value in the list, this approach doesn\\'t satisfy the time complexity constraint provided in the problem statement. \\n\\nThe `min()` function essentially scans the entire list to find the smallest element, which has a time complexity of O(n), where n is the number of elements in the list. This is too slow for large lists and does not utilize the properties of the list (sorted and rotated).\\n\\nThe problem statement asks for a solution with a time complexity of O(log n), implying that a more efficient algorithm like binary search should be used. Binary search works by repeatedly dividing the search space in half, which is much faster than checking every element individually for large lists.\\n\\nHere\\'s a Python code that uses a binary search algorithm to solve this problem:\\n\\n```python\\ndef findMin(nums):\\n    left, right = 0, len(nums) - 1\\n    while left < right:\\n        mid = (left + right) // 2\\n        if nums[mid] > nums[right]:\\n            left = mid + 1\\n        else:\\n            right = mid\\n    return nums[left]\\n```\\n\\nThis solution takes advantage of the fact that the array is sorted (aside from the rotation) to quickly find the minimum element."
                    }
                ]
            },
            {
                "id": 1933190,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "Author tried but coudn\\'t cover up the real task. Came out a super-easy task with a facepalm description."
                    },
                    {
                        "username": "MrxNoobie",
                        "content": "I don\\'t this question is suppose to be in medium section because, it does not really matter because you do this problem in 2 different ways.\\nIf you wish to do binary search then you just have to sort this array yourself\\nor else you can just do it linear way where you just check each value and find the min their.\\nTHIS IS NOT A QUESTION IF YOU JUST THINK IT CALMLY"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "You must write an algorithm that runs in O(log n) time."
                    },
                    {
                        "username": "shubhamsanvariyait",
                        "content": "can someone tell how this is acceptable \\ni wrote a basic code to return smallest number in array and it works"
                    },
                    {
                        "username": "Romijul",
                        "content": "\\uD83D\\uDCA5\\uD83D\\uDCA5\\uD83D\\uDCA5OPTIMAL APPROACH\\u2714\\u2714\\u2714\\n`int binarySearch(vector<int> &a, int s, int e) {`\\n`        while(s<e){`\\n`            int mid=s+(e-s)/2;`\\n`            if(a[mid]>a[e]){`\\n`                s=mid+1; // smallest element is right part `\\n`            }`\\n`            else{`\\n`                e=mid; //smallest element present at the left part , loop start to end (end=mid)`\\n`            }`\\n`        }`\\n`        return s; returning the index of smallest element`\\n`    }`\\n\\n\\nupvote"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Baymax_",
                        "content": "<i>Not sure how the test cases are defined here, but it looks like <b>Linear search is beating the Binary search approach</b></i> 😅"
                    },
                    {
                        "username": "arminmrm93",
                        "content": "Just an observation: It seems that maximum acceptable running time is not set properly for this problem. I just submitted the trivial O(n) solution (we all know what that is!) and it was accepted! "
                    },
                    {
                        "username": "Shashiala1234",
                        "content": "Take first element of the array as min ,and compare min with all elements of the array and at last return min value"
                    },
                    {
                        "username": "Shashiala1234",
                        "content": "[@yogeshputtaswamy93](/yogeshputtaswamy93) \\nyes"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Fortunately, or very unfortunately, this linear approach is actually beating up the binary search approach.\\nI think the test cases are appropriate or no proper time cap is set."
                    },
                    {
                        "username": "bhavyavohra8",
                        "content": "class Solution {\\n    public int findMin(int[] nums) {\\n        int st = 0, end = nums.length-1;\\n        int ans = -1;\\n        while(st <= end){\\n            int mid = st + (end - st)/2;\\n            if(nums[end] < nums[mid]){\\n                st = mid+1;\\n            }else if(nums[end] >= nums[mid]){\\n                ans = mid;\\n                end = mid-1;\\n            }\\n        }        \\n        return nums[ans];\\n    }\\n}\\n\\nwhy I am getting wrong answer?\\nfor the testcase - {3, 1, 2}, it is giving the output as 3 instead of 1."
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue in your code is the line `ans = mid;`. In your binary search, you are assigning `mid` to `ans` when `nums[mid]` is less than or equal to `nums[end]`. This means you\\'re storing the index of the smallest number found so far. However, in the case of a rotation, there may be smaller numbers after this index in the array. \\n\\nWhen you reach the smallest element, `end` is updated to `mid - 1` and then `st` becomes greater than `end` in the next iteration. This breaks the loop and you return `nums[ans]` as the minimum element. But `ans` is not updated in this final iteration and holds the value from the previous iteration, hence the wrong answer.\\n\\nA better approach would be to directly return `nums[st]` after the loop, because `st` would always point to the smallest element when the loop ends. Here\\'s the corrected code:\\n\\n```java\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        int st = 0, end = nums.length-1;\\n        while(st < end) {\\n            int mid = st + (end - st)/2;\\n            if(nums[end] < nums[mid]) {\\n                st = mid + 1;\\n            } else {\\n                end = mid;\\n            }\\n        }\\n        return nums[st];\\n    }\\n}\\n```\\n\\nThis solution is based on the insight that the smallest element is always to the right of the pivot. So, we keep moving the start to mid + 1 if the mid element is greater than the end element. If it\\'s not, that means we\\'re already in the sorted part of the array and we update the end to mid. We keep doing this until start and end meet, which would be pointing to the smallest element."
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think the main idea here is to look in the unsorted half of the array.\nIf it was shifted more than `len(nums)//2` - the minimum will be on the right half.\nIf it was shifted less/equal than `len(nums)//2` - the minimum will be on the left half.\n\n* the `//` signify floor."
                    },
                    {
                        "username": "nkorgik",
                        "content": "I found a solution guys. \\n\\nreturn min(nums) \\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "While it\\'s true that the Python built-in `min()` function can find the minimum value in the list, this approach doesn\\'t satisfy the time complexity constraint provided in the problem statement. \\n\\nThe `min()` function essentially scans the entire list to find the smallest element, which has a time complexity of O(n), where n is the number of elements in the list. This is too slow for large lists and does not utilize the properties of the list (sorted and rotated).\\n\\nThe problem statement asks for a solution with a time complexity of O(log n), implying that a more efficient algorithm like binary search should be used. Binary search works by repeatedly dividing the search space in half, which is much faster than checking every element individually for large lists.\\n\\nHere\\'s a Python code that uses a binary search algorithm to solve this problem:\\n\\n```python\\ndef findMin(nums):\\n    left, right = 0, len(nums) - 1\\n    while left < right:\\n        mid = (left + right) // 2\\n        if nums[mid] > nums[right]:\\n            left = mid + 1\\n        else:\\n            right = mid\\n    return nums[left]\\n```\\n\\nThis solution takes advantage of the fact that the array is sorted (aside from the rotation) to quickly find the minimum element."
                    }
                ]
            },
            {
                "id": 1915795,
                "content": [
                    {
                        "username": "a_andreasian",
                        "content": "Author tried but coudn\\'t cover up the real task. Came out a super-easy task with a facepalm description."
                    },
                    {
                        "username": "MrxNoobie",
                        "content": "I don\\'t this question is suppose to be in medium section because, it does not really matter because you do this problem in 2 different ways.\\nIf you wish to do binary search then you just have to sort this array yourself\\nor else you can just do it linear way where you just check each value and find the min their.\\nTHIS IS NOT A QUESTION IF YOU JUST THINK IT CALMLY"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "You must write an algorithm that runs in O(log n) time."
                    },
                    {
                        "username": "shubhamsanvariyait",
                        "content": "can someone tell how this is acceptable \\ni wrote a basic code to return smallest number in array and it works"
                    },
                    {
                        "username": "Romijul",
                        "content": "\\uD83D\\uDCA5\\uD83D\\uDCA5\\uD83D\\uDCA5OPTIMAL APPROACH\\u2714\\u2714\\u2714\\n`int binarySearch(vector<int> &a, int s, int e) {`\\n`        while(s<e){`\\n`            int mid=s+(e-s)/2;`\\n`            if(a[mid]>a[e]){`\\n`                s=mid+1; // smallest element is right part `\\n`            }`\\n`            else{`\\n`                e=mid; //smallest element present at the left part , loop start to end (end=mid)`\\n`            }`\\n`        }`\\n`        return s; returning the index of smallest element`\\n`    }`\\n\\n\\nupvote"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Baymax_",
                        "content": "<i>Not sure how the test cases are defined here, but it looks like <b>Linear search is beating the Binary search approach</b></i> 😅"
                    },
                    {
                        "username": "arminmrm93",
                        "content": "Just an observation: It seems that maximum acceptable running time is not set properly for this problem. I just submitted the trivial O(n) solution (we all know what that is!) and it was accepted! "
                    },
                    {
                        "username": "Shashiala1234",
                        "content": "Take first element of the array as min ,and compare min with all elements of the array and at last return min value"
                    },
                    {
                        "username": "Shashiala1234",
                        "content": "[@yogeshputtaswamy93](/yogeshputtaswamy93) \\nyes"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Fortunately, or very unfortunately, this linear approach is actually beating up the binary search approach.\\nI think the test cases are appropriate or no proper time cap is set."
                    },
                    {
                        "username": "bhavyavohra8",
                        "content": "class Solution {\\n    public int findMin(int[] nums) {\\n        int st = 0, end = nums.length-1;\\n        int ans = -1;\\n        while(st <= end){\\n            int mid = st + (end - st)/2;\\n            if(nums[end] < nums[mid]){\\n                st = mid+1;\\n            }else if(nums[end] >= nums[mid]){\\n                ans = mid;\\n                end = mid-1;\\n            }\\n        }        \\n        return nums[ans];\\n    }\\n}\\n\\nwhy I am getting wrong answer?\\nfor the testcase - {3, 1, 2}, it is giving the output as 3 instead of 1."
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue in your code is the line `ans = mid;`. In your binary search, you are assigning `mid` to `ans` when `nums[mid]` is less than or equal to `nums[end]`. This means you\\'re storing the index of the smallest number found so far. However, in the case of a rotation, there may be smaller numbers after this index in the array. \\n\\nWhen you reach the smallest element, `end` is updated to `mid - 1` and then `st` becomes greater than `end` in the next iteration. This breaks the loop and you return `nums[ans]` as the minimum element. But `ans` is not updated in this final iteration and holds the value from the previous iteration, hence the wrong answer.\\n\\nA better approach would be to directly return `nums[st]` after the loop, because `st` would always point to the smallest element when the loop ends. Here\\'s the corrected code:\\n\\n```java\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        int st = 0, end = nums.length-1;\\n        while(st < end) {\\n            int mid = st + (end - st)/2;\\n            if(nums[end] < nums[mid]) {\\n                st = mid + 1;\\n            } else {\\n                end = mid;\\n            }\\n        }\\n        return nums[st];\\n    }\\n}\\n```\\n\\nThis solution is based on the insight that the smallest element is always to the right of the pivot. So, we keep moving the start to mid + 1 if the mid element is greater than the end element. If it\\'s not, that means we\\'re already in the sorted part of the array and we update the end to mid. We keep doing this until start and end meet, which would be pointing to the smallest element."
                    },
                    {
                        "username": "liorbm1",
                        "content": "I think the main idea here is to look in the unsorted half of the array.\nIf it was shifted more than `len(nums)//2` - the minimum will be on the right half.\nIf it was shifted less/equal than `len(nums)//2` - the minimum will be on the left half.\n\n* the `//` signify floor."
                    },
                    {
                        "username": "nkorgik",
                        "content": "I found a solution guys. \\n\\nreturn min(nums) \\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "While it\\'s true that the Python built-in `min()` function can find the minimum value in the list, this approach doesn\\'t satisfy the time complexity constraint provided in the problem statement. \\n\\nThe `min()` function essentially scans the entire list to find the smallest element, which has a time complexity of O(n), where n is the number of elements in the list. This is too slow for large lists and does not utilize the properties of the list (sorted and rotated).\\n\\nThe problem statement asks for a solution with a time complexity of O(log n), implying that a more efficient algorithm like binary search should be used. Binary search works by repeatedly dividing the search space in half, which is much faster than checking every element individually for large lists.\\n\\nHere\\'s a Python code that uses a binary search algorithm to solve this problem:\\n\\n```python\\ndef findMin(nums):\\n    left, right = 0, len(nums) - 1\\n    while left < right:\\n        mid = (left + right) // 2\\n        if nums[mid] > nums[right]:\\n            left = mid + 1\\n        else:\\n            right = mid\\n    return nums[left]\\n```\\n\\nThis solution takes advantage of the fact that the array is sorted (aside from the rotation) to quickly find the minimum element."
                    }
                ]
            },
            {
                "id": 1914379,
                "content": [
                    {
                        "username": "enigma_007",
                        "content": "a hint which worked good for me:)\\njust compare the mid values of array with the low and the high and at any point of time either the left half or the right half is always sorted so this comparison can easily be put into a if else condition. If left half is sorted take the nums[low] value as it can be potential answer and move to the right part to get the minimum in that part. At last compare both the minimums and return the lesser number. Thanks:)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The approach you suggested works for the case where the array is rotated. However, if the array is not rotated (i.e., sorted in ascending order), comparing mid with low and high doesn\\'t help to determine the next search space.\\n\\nInstead, we should compare the mid value with the right (or last) value. This comparison gives us a clear rule to determine the next search space: If nums[mid] > nums[right], then the minimum must be in the right half (i.e., nums[mid+1 : right+1]), else the minimum is in the left half (i.e., nums[left : mid+1]).\\n\\nLet\\'s translate this into Python code:\\n\\n```python\\ndef findMin(nums):\\n    low, high = 0, len(nums) - 1\\n    while low < high:\\n        mid = low + (high - low) // 2\\n        if nums[mid] > nums[high]:\\n            low = mid + 1\\n        else:\\n            high = mid\\n    return nums[low]\\n```\\n\\nThis code implements binary search, and it continuously narrows down the search interval from [low, high] to [mid+1, high] or [low, mid], depending on the comparison between nums[mid] and nums[high]. The loop continues until low == high, at which point we\\'ve found the minimum element.\\n\\nThis algorithm is O(log N) as it halves the search space at each step."
                    },
                    {
                        "username": "enigma_007",
                        "content": "[@uphar_gaur](/uphar_gaur) see the rotation is applied on the original ascending sorted array and when you rotate the array k times the numbers do not assemble in a way you described. Say for instance we have 123456 as array and we do the rotations for 2 times then the rotated array would be 561234 and not 651234. Similarily there can never be a case in which 123456 is rotated to get 654321. Also regarding how i can be so sure that the array is always sorted is the fact that if it is rotated by more than half times the initial half would always be sorted and if it is rotated by less than half the array size times the later half will always be sorted.Hope, i have solved your query."
                    },
                    {
                        "username": "uphar_gaur",
                        "content": "how can u say one part is sorted at any time ,see 654321 here at any time none of the side is sorted\\n "
                    },
                    {
                        "username": "ppnnssy",
                        "content": "C++: \\n` return *min_element(nums.begin(), nums.end()) `"
                    },
                    {
                        "username": "user2194kq",
                        "content": "Most naive solution is to sort and return nums[0]."
                    },
                    {
                        "username": "bparanj",
                        "content": "While that approach would certainly work and return the correct result, it does not meet the performance requirement stated in the problem, which demands an algorithm that runs in O(log n) time. Sorting an array typically requires O(n log n) time, which is more costly than the required O(log n).\\n\\nThe problem statement also indicates that the array is already sorted, but rotated. So, sorting again isn\\'t taking advantage of the existing sorted nature of the array.\\n\\nHere, binary search can be used to take advantage of the sorted nature of the array and find the minimum element in O(log n) time, which meets the problem\\'s constraints. The goal is to identify the point of rotation (i.e., the minimum element), which can be done in a divide-and-conquer manner, as shown in previous discussions."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@shoumikc](/shoumikc) The funny thing is that what he\\'s proposing isn\\'t even a linear solution lol"
                    },
                    {
                        "username": "shoumik916",
                        "content": "obviously lol. that\\'s why the problem is marked medium and says your solution must be O(log n). A linear solution like the one you described would never be accepted in an interview"
                    },
                    {
                        "username": "iamrohit3007",
                        "content": "This is quite easy question ig!!"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "did you ever feel like it is O(logn) but feels like O(n)"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Is there anybody who gets confuse while setting condition for binary search like whethere it should be (l<r) or (l<=r) or like whether it should be l = mid-1 or l = mid or r = mid+1 or r = mid.\\nThis stuff confuses me a lot.\\nSomeone please share your thoughts to clear.\\nThanks in advance."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, setting the right conditions in a binary search can be tricky and it\\'s one of the most common sources of confusion when implementing it. Here\\'s a simple guideline to follow:\\n\\n1. `l < r` vs `l <= r`: The condition `l < r` is generally used when you\\'re doing a binary search where the search space reduces on each step, meaning that at some point `l` and `r` will be the same. When they are the same, you know you\\'ve found the element or it does not exist. `l <= r` is used when you\\'re doing a binary search where you need to consider the middle element as well. \\n\\n2. `l = mid + 1` vs `l = mid` and `r = mid - 1` vs `r = mid`: These decisions are often problem-specific and depend on whether you are looking for the first occurrence, last occurrence, or any occurrence. Usually, when the middle element is not the target, you move one step to the left or right to skip the current middle element.\\n\\nRemember, the best way to get comfortable with these decisions is to practice problems involving binary search and try to understand the reasoning behind the conditions.\\n\\nIn this problem, we use `l < r` because we are reducing the search space on each step, and `l = mid + 1` or `r = mid` because we have already checked the mid element, and we are sure that it\\'s not the answer so we need to move one step further.\\n\\nVisualizing these steps can be very helpful. Let\\'s consider an array: `[4, 5, 6, 7, 0, 1, 2]`.\\n\\nStep 1. `l < r` vs `l <= r`:\\n\\nA binary search algorithm repeatedly divides the search space (the portion of the array we are interested in) in half. `l` and `r` represent the bounds of this search space. Initially, `l` is at the start of the array, and `r` is at the end. \\n\\nWhen we say `l < r`, it means the search continues as long as the left boundary is strictly less than the right boundary, indicating that there is more than one element left in the search space.\\n\\nHere is a quick visualization:\\n\\n```\\nArray:  4  5  6  7  0  1  2\\nIndex:  0  1  2  3  4  5  6\\n         ^           ^\\n         |           |\\n         l           r\\n\\nAfter a few iterations:\\n\\nArray:  4  5  6  7  0  1  2\\nIndex:  0  1  2  3  4  5  6\\n                  ^  ^\\n                  |  |\\n                  l  r\\n```\\n\\nWhen `l` and `r` point to the same element, we stop, because we\\'ve narrowed down the search space to a single element.\\n\\nStep 2. `l = mid + 1` vs `l = mid` and `r = mid - 1` vs `r = mid`:\\n\\nLet\\'s say we\\'re at a point where `l` is at index 3 (value 7), `r` is at index 6 (value 2), and `mid` is at index 4 (value 0). Here we find that `nums[mid] < nums[r]`. So, the minimum must be in the left part of the array. We then set `r` to `mid`.\\n\\nWhy not `mid - 1`? Because the `mid` element is a potential answer (it could be the minimum), so we include it in our next search space. \\n\\n```\\nArray:  4  5  6  7  0  1  2\\nIndex:  0  1  2  3  4  5  6\\n                  ^  ^  ^\\n                  |  |  |\\n                  l mid r\\n                  \\nNext iteration:\\n\\nArray:  4  5  6  7  0  1  2\\nIndex:  0  1  2  3  4  5  6\\n                  ^  ^\\n                  |  |\\n                  l/r(mid)    \\n```\\n\\nWe can see here that including `mid` in our search space allows us to find the minimum element in the array.\\n"
                    },
                    {
                        "username": "danny02052",
                        "content": "\nFirst, let us understand the concept of Binary Search (BS). BS is a method of optimizing a search by reducing the search space by half in every iteration. This approach can be applied whenever there is a condition based on which the search space can be reduced by half. One such condition is when the array is sorted. However, it is not necessary for the array to be sorted always. If we can find any other condition to divide the search space in two, we can still apply BS. Lets use this information to determine when to use L<=R vs L<R.\n\nI typically use L<=R when I know precisely which value I am searching for. In this scenario, if the value is not present in the array and the loop breaks when R<L, then R becomes the floor of the value and L becomes the ceiling of the value we are searching for. On the other hand, I use L<R when I do not know when the loop will break - because I do not know the value I am searching for in the array. In this case, I only know which side of the search space to look into in the next iteration. A practical example of this scenario is searching for a pivot in a mountain array. We do not know what the peak or pivot is, but we do know on which side the peak will be. Therefore, when L==R, the loop breaks, and we get our solution.\n\nWhen we use L<=R ---->>  L or R is always updated as L = mid +1 or R = mid-1 because we have already included nums[mid] in our search space by doing L<=R."
                    },
                    {
                        "username": "Rol1304",
                        "content": "i tried using the condition nums[mid]>=nums[0] in the if statement but it works for only rotating the array by two but nums[mid]>=nums[e] is the correct one"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re on the right track! Let\\'s break down why `nums[mid] >= nums[e]` is the correct condition in this scenario.\\n\\nIn a sorted and rotated array where all numbers are unique, the pivot point will always be the maximum number (let\\'s call it max). The elements to the left of the max are in ascending order and all larger than the elements to the right of max.\\n\\nThis leads us to the following conclusions:\\n\\n1. If `nums[mid] >= nums[0]`, this tells us that `mid` is on the left side of max. This condition is not sufficient to determine where the minimum value is. As you mentioned, it only works for some cases.\\n\\n2. On the other hand, if `nums[mid] >= nums[e]`, this means that `mid` is on the left side of max and all the elements to its right are smaller than `nums[mid]`. Therefore, the minimum value must lie in the right half. Conversely, if `nums[mid] < nums[e]`, the `mid` is on the right side of max, so the minimum must be on the left. This condition correctly guides the binary search towards the minimum value.\\n\\nThat\\'s why you should use `nums[mid] >= nums[e]` to determine which side of the array to search. This makes sure that the search space is always decreased by half and that the minimum element is within the search space."
                    },
                    {
                        "username": "abzelmes",
                        "content": "I think you need to add a condition that people can\\'t sort the array and need to use it as-is. Otherwise its Sort then get nums[0].. but without sorting its quite fun!"
                    },
                    {
                        "username": "YashuCoder",
                        "content": "Here the fun fact is min function beats 100% "
                    },
                    {
                        "username": "aguirre_roman",
                        "content": "Yeah, all the built in functions  like min of the programming language will beat whatever we write, but that doesn\\'t work in an interview."
                    },
                    {
                        "username": "beijaflor",
                        "content": "(Assuming Python) This is only true because `min()` and `max()` are written in C (for CPython at least -- see https://github.com/python/cpython/blob/main/Python/bltinmodule.c#L1727) and can avoid the bookkeeping of the equivalent algorithm written in pure Python.  Either way, the builtin `min()` requires a linear search (so it\\'s O(n)) while we can get O(log n) performance by taking advantage of the fact that the list is sorted (albeit rotated by some factor `k`).  Solve this problem in C with binary search and I bet you can blow Python\\'s `min()` out of the water."
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "How does the below solution work? Its a medium problem under binary search, am I missing anything?\\n\\n `public int findMin(int[] nums) {\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<min){\\n                min = nums[i];\\n            }\\n        }\\n        return min;\\n    }`"
                    },
                    {
                        "username": "beijaflor",
                        "content": "A sequential search (what you are doing above) does \"work\", but it works in O(n) time instead of the O(log n) specified in the problem description.  Think about how you could use the binary search algorithm to solve this problem instead, which would give a solution with O(log n) time complexity.  Keep in mind that in order for binary search to work on a list, the elements of the list have to be sorted in order.  The problem statement hints that the input list in this problem is \"sorted\", but perhaps not in the most intuitive order.  How could you apply a basic binary search implementation (perhaps with a modification or two) to approach the problem."
                    }
                ]
            },
            {
                "id": 1904464,
                "content": [
                    {
                        "username": "enigma_007",
                        "content": "a hint which worked good for me:)\\njust compare the mid values of array with the low and the high and at any point of time either the left half or the right half is always sorted so this comparison can easily be put into a if else condition. If left half is sorted take the nums[low] value as it can be potential answer and move to the right part to get the minimum in that part. At last compare both the minimums and return the lesser number. Thanks:)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The approach you suggested works for the case where the array is rotated. However, if the array is not rotated (i.e., sorted in ascending order), comparing mid with low and high doesn\\'t help to determine the next search space.\\n\\nInstead, we should compare the mid value with the right (or last) value. This comparison gives us a clear rule to determine the next search space: If nums[mid] > nums[right], then the minimum must be in the right half (i.e., nums[mid+1 : right+1]), else the minimum is in the left half (i.e., nums[left : mid+1]).\\n\\nLet\\'s translate this into Python code:\\n\\n```python\\ndef findMin(nums):\\n    low, high = 0, len(nums) - 1\\n    while low < high:\\n        mid = low + (high - low) // 2\\n        if nums[mid] > nums[high]:\\n            low = mid + 1\\n        else:\\n            high = mid\\n    return nums[low]\\n```\\n\\nThis code implements binary search, and it continuously narrows down the search interval from [low, high] to [mid+1, high] or [low, mid], depending on the comparison between nums[mid] and nums[high]. The loop continues until low == high, at which point we\\'ve found the minimum element.\\n\\nThis algorithm is O(log N) as it halves the search space at each step."
                    },
                    {
                        "username": "enigma_007",
                        "content": "[@uphar_gaur](/uphar_gaur) see the rotation is applied on the original ascending sorted array and when you rotate the array k times the numbers do not assemble in a way you described. Say for instance we have 123456 as array and we do the rotations for 2 times then the rotated array would be 561234 and not 651234. Similarily there can never be a case in which 123456 is rotated to get 654321. Also regarding how i can be so sure that the array is always sorted is the fact that if it is rotated by more than half times the initial half would always be sorted and if it is rotated by less than half the array size times the later half will always be sorted.Hope, i have solved your query."
                    },
                    {
                        "username": "uphar_gaur",
                        "content": "how can u say one part is sorted at any time ,see 654321 here at any time none of the side is sorted\\n "
                    },
                    {
                        "username": "ppnnssy",
                        "content": "C++: \\n` return *min_element(nums.begin(), nums.end()) `"
                    },
                    {
                        "username": "user2194kq",
                        "content": "Most naive solution is to sort and return nums[0]."
                    },
                    {
                        "username": "bparanj",
                        "content": "While that approach would certainly work and return the correct result, it does not meet the performance requirement stated in the problem, which demands an algorithm that runs in O(log n) time. Sorting an array typically requires O(n log n) time, which is more costly than the required O(log n).\\n\\nThe problem statement also indicates that the array is already sorted, but rotated. So, sorting again isn\\'t taking advantage of the existing sorted nature of the array.\\n\\nHere, binary search can be used to take advantage of the sorted nature of the array and find the minimum element in O(log n) time, which meets the problem\\'s constraints. The goal is to identify the point of rotation (i.e., the minimum element), which can be done in a divide-and-conquer manner, as shown in previous discussions."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@shoumikc](/shoumikc) The funny thing is that what he\\'s proposing isn\\'t even a linear solution lol"
                    },
                    {
                        "username": "shoumik916",
                        "content": "obviously lol. that\\'s why the problem is marked medium and says your solution must be O(log n). A linear solution like the one you described would never be accepted in an interview"
                    },
                    {
                        "username": "iamrohit3007",
                        "content": "This is quite easy question ig!!"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "did you ever feel like it is O(logn) but feels like O(n)"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Is there anybody who gets confuse while setting condition for binary search like whethere it should be (l<r) or (l<=r) or like whether it should be l = mid-1 or l = mid or r = mid+1 or r = mid.\\nThis stuff confuses me a lot.\\nSomeone please share your thoughts to clear.\\nThanks in advance."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, setting the right conditions in a binary search can be tricky and it\\'s one of the most common sources of confusion when implementing it. Here\\'s a simple guideline to follow:\\n\\n1. `l < r` vs `l <= r`: The condition `l < r` is generally used when you\\'re doing a binary search where the search space reduces on each step, meaning that at some point `l` and `r` will be the same. When they are the same, you know you\\'ve found the element or it does not exist. `l <= r` is used when you\\'re doing a binary search where you need to consider the middle element as well. \\n\\n2. `l = mid + 1` vs `l = mid` and `r = mid - 1` vs `r = mid`: These decisions are often problem-specific and depend on whether you are looking for the first occurrence, last occurrence, or any occurrence. Usually, when the middle element is not the target, you move one step to the left or right to skip the current middle element.\\n\\nRemember, the best way to get comfortable with these decisions is to practice problems involving binary search and try to understand the reasoning behind the conditions.\\n\\nIn this problem, we use `l < r` because we are reducing the search space on each step, and `l = mid + 1` or `r = mid` because we have already checked the mid element, and we are sure that it\\'s not the answer so we need to move one step further.\\n\\nVisualizing these steps can be very helpful. Let\\'s consider an array: `[4, 5, 6, 7, 0, 1, 2]`.\\n\\nStep 1. `l < r` vs `l <= r`:\\n\\nA binary search algorithm repeatedly divides the search space (the portion of the array we are interested in) in half. `l` and `r` represent the bounds of this search space. Initially, `l` is at the start of the array, and `r` is at the end. \\n\\nWhen we say `l < r`, it means the search continues as long as the left boundary is strictly less than the right boundary, indicating that there is more than one element left in the search space.\\n\\nHere is a quick visualization:\\n\\n```\\nArray:  4  5  6  7  0  1  2\\nIndex:  0  1  2  3  4  5  6\\n         ^           ^\\n         |           |\\n         l           r\\n\\nAfter a few iterations:\\n\\nArray:  4  5  6  7  0  1  2\\nIndex:  0  1  2  3  4  5  6\\n                  ^  ^\\n                  |  |\\n                  l  r\\n```\\n\\nWhen `l` and `r` point to the same element, we stop, because we\\'ve narrowed down the search space to a single element.\\n\\nStep 2. `l = mid + 1` vs `l = mid` and `r = mid - 1` vs `r = mid`:\\n\\nLet\\'s say we\\'re at a point where `l` is at index 3 (value 7), `r` is at index 6 (value 2), and `mid` is at index 4 (value 0). Here we find that `nums[mid] < nums[r]`. So, the minimum must be in the left part of the array. We then set `r` to `mid`.\\n\\nWhy not `mid - 1`? Because the `mid` element is a potential answer (it could be the minimum), so we include it in our next search space. \\n\\n```\\nArray:  4  5  6  7  0  1  2\\nIndex:  0  1  2  3  4  5  6\\n                  ^  ^  ^\\n                  |  |  |\\n                  l mid r\\n                  \\nNext iteration:\\n\\nArray:  4  5  6  7  0  1  2\\nIndex:  0  1  2  3  4  5  6\\n                  ^  ^\\n                  |  |\\n                  l/r(mid)    \\n```\\n\\nWe can see here that including `mid` in our search space allows us to find the minimum element in the array.\\n"
                    },
                    {
                        "username": "danny02052",
                        "content": "\nFirst, let us understand the concept of Binary Search (BS). BS is a method of optimizing a search by reducing the search space by half in every iteration. This approach can be applied whenever there is a condition based on which the search space can be reduced by half. One such condition is when the array is sorted. However, it is not necessary for the array to be sorted always. If we can find any other condition to divide the search space in two, we can still apply BS. Lets use this information to determine when to use L<=R vs L<R.\n\nI typically use L<=R when I know precisely which value I am searching for. In this scenario, if the value is not present in the array and the loop breaks when R<L, then R becomes the floor of the value and L becomes the ceiling of the value we are searching for. On the other hand, I use L<R when I do not know when the loop will break - because I do not know the value I am searching for in the array. In this case, I only know which side of the search space to look into in the next iteration. A practical example of this scenario is searching for a pivot in a mountain array. We do not know what the peak or pivot is, but we do know on which side the peak will be. Therefore, when L==R, the loop breaks, and we get our solution.\n\nWhen we use L<=R ---->>  L or R is always updated as L = mid +1 or R = mid-1 because we have already included nums[mid] in our search space by doing L<=R."
                    },
                    {
                        "username": "Rol1304",
                        "content": "i tried using the condition nums[mid]>=nums[0] in the if statement but it works for only rotating the array by two but nums[mid]>=nums[e] is the correct one"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re on the right track! Let\\'s break down why `nums[mid] >= nums[e]` is the correct condition in this scenario.\\n\\nIn a sorted and rotated array where all numbers are unique, the pivot point will always be the maximum number (let\\'s call it max). The elements to the left of the max are in ascending order and all larger than the elements to the right of max.\\n\\nThis leads us to the following conclusions:\\n\\n1. If `nums[mid] >= nums[0]`, this tells us that `mid` is on the left side of max. This condition is not sufficient to determine where the minimum value is. As you mentioned, it only works for some cases.\\n\\n2. On the other hand, if `nums[mid] >= nums[e]`, this means that `mid` is on the left side of max and all the elements to its right are smaller than `nums[mid]`. Therefore, the minimum value must lie in the right half. Conversely, if `nums[mid] < nums[e]`, the `mid` is on the right side of max, so the minimum must be on the left. This condition correctly guides the binary search towards the minimum value.\\n\\nThat\\'s why you should use `nums[mid] >= nums[e]` to determine which side of the array to search. This makes sure that the search space is always decreased by half and that the minimum element is within the search space."
                    },
                    {
                        "username": "abzelmes",
                        "content": "I think you need to add a condition that people can\\'t sort the array and need to use it as-is. Otherwise its Sort then get nums[0].. but without sorting its quite fun!"
                    },
                    {
                        "username": "YashuCoder",
                        "content": "Here the fun fact is min function beats 100% "
                    },
                    {
                        "username": "aguirre_roman",
                        "content": "Yeah, all the built in functions  like min of the programming language will beat whatever we write, but that doesn\\'t work in an interview."
                    },
                    {
                        "username": "beijaflor",
                        "content": "(Assuming Python) This is only true because `min()` and `max()` are written in C (for CPython at least -- see https://github.com/python/cpython/blob/main/Python/bltinmodule.c#L1727) and can avoid the bookkeeping of the equivalent algorithm written in pure Python.  Either way, the builtin `min()` requires a linear search (so it\\'s O(n)) while we can get O(log n) performance by taking advantage of the fact that the list is sorted (albeit rotated by some factor `k`).  Solve this problem in C with binary search and I bet you can blow Python\\'s `min()` out of the water."
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "How does the below solution work? Its a medium problem under binary search, am I missing anything?\\n\\n `public int findMin(int[] nums) {\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<min){\\n                min = nums[i];\\n            }\\n        }\\n        return min;\\n    }`"
                    },
                    {
                        "username": "beijaflor",
                        "content": "A sequential search (what you are doing above) does \"work\", but it works in O(n) time instead of the O(log n) specified in the problem description.  Think about how you could use the binary search algorithm to solve this problem instead, which would give a solution with O(log n) time complexity.  Keep in mind that in order for binary search to work on a list, the elements of the list have to be sorted in order.  The problem statement hints that the input list in this problem is \"sorted\", but perhaps not in the most intuitive order.  How could you apply a basic binary search implementation (perhaps with a modification or two) to approach the problem."
                    }
                ]
            },
            {
                "id": 1903572,
                "content": [
                    {
                        "username": "enigma_007",
                        "content": "a hint which worked good for me:)\\njust compare the mid values of array with the low and the high and at any point of time either the left half or the right half is always sorted so this comparison can easily be put into a if else condition. If left half is sorted take the nums[low] value as it can be potential answer and move to the right part to get the minimum in that part. At last compare both the minimums and return the lesser number. Thanks:)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The approach you suggested works for the case where the array is rotated. However, if the array is not rotated (i.e., sorted in ascending order), comparing mid with low and high doesn\\'t help to determine the next search space.\\n\\nInstead, we should compare the mid value with the right (or last) value. This comparison gives us a clear rule to determine the next search space: If nums[mid] > nums[right], then the minimum must be in the right half (i.e., nums[mid+1 : right+1]), else the minimum is in the left half (i.e., nums[left : mid+1]).\\n\\nLet\\'s translate this into Python code:\\n\\n```python\\ndef findMin(nums):\\n    low, high = 0, len(nums) - 1\\n    while low < high:\\n        mid = low + (high - low) // 2\\n        if nums[mid] > nums[high]:\\n            low = mid + 1\\n        else:\\n            high = mid\\n    return nums[low]\\n```\\n\\nThis code implements binary search, and it continuously narrows down the search interval from [low, high] to [mid+1, high] or [low, mid], depending on the comparison between nums[mid] and nums[high]. The loop continues until low == high, at which point we\\'ve found the minimum element.\\n\\nThis algorithm is O(log N) as it halves the search space at each step."
                    },
                    {
                        "username": "enigma_007",
                        "content": "[@uphar_gaur](/uphar_gaur) see the rotation is applied on the original ascending sorted array and when you rotate the array k times the numbers do not assemble in a way you described. Say for instance we have 123456 as array and we do the rotations for 2 times then the rotated array would be 561234 and not 651234. Similarily there can never be a case in which 123456 is rotated to get 654321. Also regarding how i can be so sure that the array is always sorted is the fact that if it is rotated by more than half times the initial half would always be sorted and if it is rotated by less than half the array size times the later half will always be sorted.Hope, i have solved your query."
                    },
                    {
                        "username": "uphar_gaur",
                        "content": "how can u say one part is sorted at any time ,see 654321 here at any time none of the side is sorted\\n "
                    },
                    {
                        "username": "ppnnssy",
                        "content": "C++: \\n` return *min_element(nums.begin(), nums.end()) `"
                    },
                    {
                        "username": "user2194kq",
                        "content": "Most naive solution is to sort and return nums[0]."
                    },
                    {
                        "username": "bparanj",
                        "content": "While that approach would certainly work and return the correct result, it does not meet the performance requirement stated in the problem, which demands an algorithm that runs in O(log n) time. Sorting an array typically requires O(n log n) time, which is more costly than the required O(log n).\\n\\nThe problem statement also indicates that the array is already sorted, but rotated. So, sorting again isn\\'t taking advantage of the existing sorted nature of the array.\\n\\nHere, binary search can be used to take advantage of the sorted nature of the array and find the minimum element in O(log n) time, which meets the problem\\'s constraints. The goal is to identify the point of rotation (i.e., the minimum element), which can be done in a divide-and-conquer manner, as shown in previous discussions."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@shoumikc](/shoumikc) The funny thing is that what he\\'s proposing isn\\'t even a linear solution lol"
                    },
                    {
                        "username": "shoumik916",
                        "content": "obviously lol. that\\'s why the problem is marked medium and says your solution must be O(log n). A linear solution like the one you described would never be accepted in an interview"
                    },
                    {
                        "username": "iamrohit3007",
                        "content": "This is quite easy question ig!!"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "did you ever feel like it is O(logn) but feels like O(n)"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Is there anybody who gets confuse while setting condition for binary search like whethere it should be (l<r) or (l<=r) or like whether it should be l = mid-1 or l = mid or r = mid+1 or r = mid.\\nThis stuff confuses me a lot.\\nSomeone please share your thoughts to clear.\\nThanks in advance."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, setting the right conditions in a binary search can be tricky and it\\'s one of the most common sources of confusion when implementing it. Here\\'s a simple guideline to follow:\\n\\n1. `l < r` vs `l <= r`: The condition `l < r` is generally used when you\\'re doing a binary search where the search space reduces on each step, meaning that at some point `l` and `r` will be the same. When they are the same, you know you\\'ve found the element or it does not exist. `l <= r` is used when you\\'re doing a binary search where you need to consider the middle element as well. \\n\\n2. `l = mid + 1` vs `l = mid` and `r = mid - 1` vs `r = mid`: These decisions are often problem-specific and depend on whether you are looking for the first occurrence, last occurrence, or any occurrence. Usually, when the middle element is not the target, you move one step to the left or right to skip the current middle element.\\n\\nRemember, the best way to get comfortable with these decisions is to practice problems involving binary search and try to understand the reasoning behind the conditions.\\n\\nIn this problem, we use `l < r` because we are reducing the search space on each step, and `l = mid + 1` or `r = mid` because we have already checked the mid element, and we are sure that it\\'s not the answer so we need to move one step further.\\n\\nVisualizing these steps can be very helpful. Let\\'s consider an array: `[4, 5, 6, 7, 0, 1, 2]`.\\n\\nStep 1. `l < r` vs `l <= r`:\\n\\nA binary search algorithm repeatedly divides the search space (the portion of the array we are interested in) in half. `l` and `r` represent the bounds of this search space. Initially, `l` is at the start of the array, and `r` is at the end. \\n\\nWhen we say `l < r`, it means the search continues as long as the left boundary is strictly less than the right boundary, indicating that there is more than one element left in the search space.\\n\\nHere is a quick visualization:\\n\\n```\\nArray:  4  5  6  7  0  1  2\\nIndex:  0  1  2  3  4  5  6\\n         ^           ^\\n         |           |\\n         l           r\\n\\nAfter a few iterations:\\n\\nArray:  4  5  6  7  0  1  2\\nIndex:  0  1  2  3  4  5  6\\n                  ^  ^\\n                  |  |\\n                  l  r\\n```\\n\\nWhen `l` and `r` point to the same element, we stop, because we\\'ve narrowed down the search space to a single element.\\n\\nStep 2. `l = mid + 1` vs `l = mid` and `r = mid - 1` vs `r = mid`:\\n\\nLet\\'s say we\\'re at a point where `l` is at index 3 (value 7), `r` is at index 6 (value 2), and `mid` is at index 4 (value 0). Here we find that `nums[mid] < nums[r]`. So, the minimum must be in the left part of the array. We then set `r` to `mid`.\\n\\nWhy not `mid - 1`? Because the `mid` element is a potential answer (it could be the minimum), so we include it in our next search space. \\n\\n```\\nArray:  4  5  6  7  0  1  2\\nIndex:  0  1  2  3  4  5  6\\n                  ^  ^  ^\\n                  |  |  |\\n                  l mid r\\n                  \\nNext iteration:\\n\\nArray:  4  5  6  7  0  1  2\\nIndex:  0  1  2  3  4  5  6\\n                  ^  ^\\n                  |  |\\n                  l/r(mid)    \\n```\\n\\nWe can see here that including `mid` in our search space allows us to find the minimum element in the array.\\n"
                    },
                    {
                        "username": "danny02052",
                        "content": "\nFirst, let us understand the concept of Binary Search (BS). BS is a method of optimizing a search by reducing the search space by half in every iteration. This approach can be applied whenever there is a condition based on which the search space can be reduced by half. One such condition is when the array is sorted. However, it is not necessary for the array to be sorted always. If we can find any other condition to divide the search space in two, we can still apply BS. Lets use this information to determine when to use L<=R vs L<R.\n\nI typically use L<=R when I know precisely which value I am searching for. In this scenario, if the value is not present in the array and the loop breaks when R<L, then R becomes the floor of the value and L becomes the ceiling of the value we are searching for. On the other hand, I use L<R when I do not know when the loop will break - because I do not know the value I am searching for in the array. In this case, I only know which side of the search space to look into in the next iteration. A practical example of this scenario is searching for a pivot in a mountain array. We do not know what the peak or pivot is, but we do know on which side the peak will be. Therefore, when L==R, the loop breaks, and we get our solution.\n\nWhen we use L<=R ---->>  L or R is always updated as L = mid +1 or R = mid-1 because we have already included nums[mid] in our search space by doing L<=R."
                    },
                    {
                        "username": "Rol1304",
                        "content": "i tried using the condition nums[mid]>=nums[0] in the if statement but it works for only rotating the array by two but nums[mid]>=nums[e] is the correct one"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re on the right track! Let\\'s break down why `nums[mid] >= nums[e]` is the correct condition in this scenario.\\n\\nIn a sorted and rotated array where all numbers are unique, the pivot point will always be the maximum number (let\\'s call it max). The elements to the left of the max are in ascending order and all larger than the elements to the right of max.\\n\\nThis leads us to the following conclusions:\\n\\n1. If `nums[mid] >= nums[0]`, this tells us that `mid` is on the left side of max. This condition is not sufficient to determine where the minimum value is. As you mentioned, it only works for some cases.\\n\\n2. On the other hand, if `nums[mid] >= nums[e]`, this means that `mid` is on the left side of max and all the elements to its right are smaller than `nums[mid]`. Therefore, the minimum value must lie in the right half. Conversely, if `nums[mid] < nums[e]`, the `mid` is on the right side of max, so the minimum must be on the left. This condition correctly guides the binary search towards the minimum value.\\n\\nThat\\'s why you should use `nums[mid] >= nums[e]` to determine which side of the array to search. This makes sure that the search space is always decreased by half and that the minimum element is within the search space."
                    },
                    {
                        "username": "abzelmes",
                        "content": "I think you need to add a condition that people can\\'t sort the array and need to use it as-is. Otherwise its Sort then get nums[0].. but without sorting its quite fun!"
                    },
                    {
                        "username": "YashuCoder",
                        "content": "Here the fun fact is min function beats 100% "
                    },
                    {
                        "username": "aguirre_roman",
                        "content": "Yeah, all the built in functions  like min of the programming language will beat whatever we write, but that doesn\\'t work in an interview."
                    },
                    {
                        "username": "beijaflor",
                        "content": "(Assuming Python) This is only true because `min()` and `max()` are written in C (for CPython at least -- see https://github.com/python/cpython/blob/main/Python/bltinmodule.c#L1727) and can avoid the bookkeeping of the equivalent algorithm written in pure Python.  Either way, the builtin `min()` requires a linear search (so it\\'s O(n)) while we can get O(log n) performance by taking advantage of the fact that the list is sorted (albeit rotated by some factor `k`).  Solve this problem in C with binary search and I bet you can blow Python\\'s `min()` out of the water."
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "How does the below solution work? Its a medium problem under binary search, am I missing anything?\\n\\n `public int findMin(int[] nums) {\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<min){\\n                min = nums[i];\\n            }\\n        }\\n        return min;\\n    }`"
                    },
                    {
                        "username": "beijaflor",
                        "content": "A sequential search (what you are doing above) does \"work\", but it works in O(n) time instead of the O(log n) specified in the problem description.  Think about how you could use the binary search algorithm to solve this problem instead, which would give a solution with O(log n) time complexity.  Keep in mind that in order for binary search to work on a list, the elements of the list have to be sorted in order.  The problem statement hints that the input list in this problem is \"sorted\", but perhaps not in the most intuitive order.  How could you apply a basic binary search implementation (perhaps with a modification or two) to approach the problem."
                    }
                ]
            },
            {
                "id": 1892102,
                "content": [
                    {
                        "username": "enigma_007",
                        "content": "a hint which worked good for me:)\\njust compare the mid values of array with the low and the high and at any point of time either the left half or the right half is always sorted so this comparison can easily be put into a if else condition. If left half is sorted take the nums[low] value as it can be potential answer and move to the right part to get the minimum in that part. At last compare both the minimums and return the lesser number. Thanks:)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The approach you suggested works for the case where the array is rotated. However, if the array is not rotated (i.e., sorted in ascending order), comparing mid with low and high doesn\\'t help to determine the next search space.\\n\\nInstead, we should compare the mid value with the right (or last) value. This comparison gives us a clear rule to determine the next search space: If nums[mid] > nums[right], then the minimum must be in the right half (i.e., nums[mid+1 : right+1]), else the minimum is in the left half (i.e., nums[left : mid+1]).\\n\\nLet\\'s translate this into Python code:\\n\\n```python\\ndef findMin(nums):\\n    low, high = 0, len(nums) - 1\\n    while low < high:\\n        mid = low + (high - low) // 2\\n        if nums[mid] > nums[high]:\\n            low = mid + 1\\n        else:\\n            high = mid\\n    return nums[low]\\n```\\n\\nThis code implements binary search, and it continuously narrows down the search interval from [low, high] to [mid+1, high] or [low, mid], depending on the comparison between nums[mid] and nums[high]. The loop continues until low == high, at which point we\\'ve found the minimum element.\\n\\nThis algorithm is O(log N) as it halves the search space at each step."
                    },
                    {
                        "username": "enigma_007",
                        "content": "[@uphar_gaur](/uphar_gaur) see the rotation is applied on the original ascending sorted array and when you rotate the array k times the numbers do not assemble in a way you described. Say for instance we have 123456 as array and we do the rotations for 2 times then the rotated array would be 561234 and not 651234. Similarily there can never be a case in which 123456 is rotated to get 654321. Also regarding how i can be so sure that the array is always sorted is the fact that if it is rotated by more than half times the initial half would always be sorted and if it is rotated by less than half the array size times the later half will always be sorted.Hope, i have solved your query."
                    },
                    {
                        "username": "uphar_gaur",
                        "content": "how can u say one part is sorted at any time ,see 654321 here at any time none of the side is sorted\\n "
                    },
                    {
                        "username": "ppnnssy",
                        "content": "C++: \\n` return *min_element(nums.begin(), nums.end()) `"
                    },
                    {
                        "username": "user2194kq",
                        "content": "Most naive solution is to sort and return nums[0]."
                    },
                    {
                        "username": "bparanj",
                        "content": "While that approach would certainly work and return the correct result, it does not meet the performance requirement stated in the problem, which demands an algorithm that runs in O(log n) time. Sorting an array typically requires O(n log n) time, which is more costly than the required O(log n).\\n\\nThe problem statement also indicates that the array is already sorted, but rotated. So, sorting again isn\\'t taking advantage of the existing sorted nature of the array.\\n\\nHere, binary search can be used to take advantage of the sorted nature of the array and find the minimum element in O(log n) time, which meets the problem\\'s constraints. The goal is to identify the point of rotation (i.e., the minimum element), which can be done in a divide-and-conquer manner, as shown in previous discussions."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@shoumikc](/shoumikc) The funny thing is that what he\\'s proposing isn\\'t even a linear solution lol"
                    },
                    {
                        "username": "shoumik916",
                        "content": "obviously lol. that\\'s why the problem is marked medium and says your solution must be O(log n). A linear solution like the one you described would never be accepted in an interview"
                    },
                    {
                        "username": "iamrohit3007",
                        "content": "This is quite easy question ig!!"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "did you ever feel like it is O(logn) but feels like O(n)"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Is there anybody who gets confuse while setting condition for binary search like whethere it should be (l<r) or (l<=r) or like whether it should be l = mid-1 or l = mid or r = mid+1 or r = mid.\\nThis stuff confuses me a lot.\\nSomeone please share your thoughts to clear.\\nThanks in advance."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, setting the right conditions in a binary search can be tricky and it\\'s one of the most common sources of confusion when implementing it. Here\\'s a simple guideline to follow:\\n\\n1. `l < r` vs `l <= r`: The condition `l < r` is generally used when you\\'re doing a binary search where the search space reduces on each step, meaning that at some point `l` and `r` will be the same. When they are the same, you know you\\'ve found the element or it does not exist. `l <= r` is used when you\\'re doing a binary search where you need to consider the middle element as well. \\n\\n2. `l = mid + 1` vs `l = mid` and `r = mid - 1` vs `r = mid`: These decisions are often problem-specific and depend on whether you are looking for the first occurrence, last occurrence, or any occurrence. Usually, when the middle element is not the target, you move one step to the left or right to skip the current middle element.\\n\\nRemember, the best way to get comfortable with these decisions is to practice problems involving binary search and try to understand the reasoning behind the conditions.\\n\\nIn this problem, we use `l < r` because we are reducing the search space on each step, and `l = mid + 1` or `r = mid` because we have already checked the mid element, and we are sure that it\\'s not the answer so we need to move one step further.\\n\\nVisualizing these steps can be very helpful. Let\\'s consider an array: `[4, 5, 6, 7, 0, 1, 2]`.\\n\\nStep 1. `l < r` vs `l <= r`:\\n\\nA binary search algorithm repeatedly divides the search space (the portion of the array we are interested in) in half. `l` and `r` represent the bounds of this search space. Initially, `l` is at the start of the array, and `r` is at the end. \\n\\nWhen we say `l < r`, it means the search continues as long as the left boundary is strictly less than the right boundary, indicating that there is more than one element left in the search space.\\n\\nHere is a quick visualization:\\n\\n```\\nArray:  4  5  6  7  0  1  2\\nIndex:  0  1  2  3  4  5  6\\n         ^           ^\\n         |           |\\n         l           r\\n\\nAfter a few iterations:\\n\\nArray:  4  5  6  7  0  1  2\\nIndex:  0  1  2  3  4  5  6\\n                  ^  ^\\n                  |  |\\n                  l  r\\n```\\n\\nWhen `l` and `r` point to the same element, we stop, because we\\'ve narrowed down the search space to a single element.\\n\\nStep 2. `l = mid + 1` vs `l = mid` and `r = mid - 1` vs `r = mid`:\\n\\nLet\\'s say we\\'re at a point where `l` is at index 3 (value 7), `r` is at index 6 (value 2), and `mid` is at index 4 (value 0). Here we find that `nums[mid] < nums[r]`. So, the minimum must be in the left part of the array. We then set `r` to `mid`.\\n\\nWhy not `mid - 1`? Because the `mid` element is a potential answer (it could be the minimum), so we include it in our next search space. \\n\\n```\\nArray:  4  5  6  7  0  1  2\\nIndex:  0  1  2  3  4  5  6\\n                  ^  ^  ^\\n                  |  |  |\\n                  l mid r\\n                  \\nNext iteration:\\n\\nArray:  4  5  6  7  0  1  2\\nIndex:  0  1  2  3  4  5  6\\n                  ^  ^\\n                  |  |\\n                  l/r(mid)    \\n```\\n\\nWe can see here that including `mid` in our search space allows us to find the minimum element in the array.\\n"
                    },
                    {
                        "username": "danny02052",
                        "content": "\nFirst, let us understand the concept of Binary Search (BS). BS is a method of optimizing a search by reducing the search space by half in every iteration. This approach can be applied whenever there is a condition based on which the search space can be reduced by half. One such condition is when the array is sorted. However, it is not necessary for the array to be sorted always. If we can find any other condition to divide the search space in two, we can still apply BS. Lets use this information to determine when to use L<=R vs L<R.\n\nI typically use L<=R when I know precisely which value I am searching for. In this scenario, if the value is not present in the array and the loop breaks when R<L, then R becomes the floor of the value and L becomes the ceiling of the value we are searching for. On the other hand, I use L<R when I do not know when the loop will break - because I do not know the value I am searching for in the array. In this case, I only know which side of the search space to look into in the next iteration. A practical example of this scenario is searching for a pivot in a mountain array. We do not know what the peak or pivot is, but we do know on which side the peak will be. Therefore, when L==R, the loop breaks, and we get our solution.\n\nWhen we use L<=R ---->>  L or R is always updated as L = mid +1 or R = mid-1 because we have already included nums[mid] in our search space by doing L<=R."
                    },
                    {
                        "username": "Rol1304",
                        "content": "i tried using the condition nums[mid]>=nums[0] in the if statement but it works for only rotating the array by two but nums[mid]>=nums[e] is the correct one"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re on the right track! Let\\'s break down why `nums[mid] >= nums[e]` is the correct condition in this scenario.\\n\\nIn a sorted and rotated array where all numbers are unique, the pivot point will always be the maximum number (let\\'s call it max). The elements to the left of the max are in ascending order and all larger than the elements to the right of max.\\n\\nThis leads us to the following conclusions:\\n\\n1. If `nums[mid] >= nums[0]`, this tells us that `mid` is on the left side of max. This condition is not sufficient to determine where the minimum value is. As you mentioned, it only works for some cases.\\n\\n2. On the other hand, if `nums[mid] >= nums[e]`, this means that `mid` is on the left side of max and all the elements to its right are smaller than `nums[mid]`. Therefore, the minimum value must lie in the right half. Conversely, if `nums[mid] < nums[e]`, the `mid` is on the right side of max, so the minimum must be on the left. This condition correctly guides the binary search towards the minimum value.\\n\\nThat\\'s why you should use `nums[mid] >= nums[e]` to determine which side of the array to search. This makes sure that the search space is always decreased by half and that the minimum element is within the search space."
                    },
                    {
                        "username": "abzelmes",
                        "content": "I think you need to add a condition that people can\\'t sort the array and need to use it as-is. Otherwise its Sort then get nums[0].. but without sorting its quite fun!"
                    },
                    {
                        "username": "YashuCoder",
                        "content": "Here the fun fact is min function beats 100% "
                    },
                    {
                        "username": "aguirre_roman",
                        "content": "Yeah, all the built in functions  like min of the programming language will beat whatever we write, but that doesn\\'t work in an interview."
                    },
                    {
                        "username": "beijaflor",
                        "content": "(Assuming Python) This is only true because `min()` and `max()` are written in C (for CPython at least -- see https://github.com/python/cpython/blob/main/Python/bltinmodule.c#L1727) and can avoid the bookkeeping of the equivalent algorithm written in pure Python.  Either way, the builtin `min()` requires a linear search (so it\\'s O(n)) while we can get O(log n) performance by taking advantage of the fact that the list is sorted (albeit rotated by some factor `k`).  Solve this problem in C with binary search and I bet you can blow Python\\'s `min()` out of the water."
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "How does the below solution work? Its a medium problem under binary search, am I missing anything?\\n\\n `public int findMin(int[] nums) {\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<min){\\n                min = nums[i];\\n            }\\n        }\\n        return min;\\n    }`"
                    },
                    {
                        "username": "beijaflor",
                        "content": "A sequential search (what you are doing above) does \"work\", but it works in O(n) time instead of the O(log n) specified in the problem description.  Think about how you could use the binary search algorithm to solve this problem instead, which would give a solution with O(log n) time complexity.  Keep in mind that in order for binary search to work on a list, the elements of the list have to be sorted in order.  The problem statement hints that the input list in this problem is \"sorted\", but perhaps not in the most intuitive order.  How could you apply a basic binary search implementation (perhaps with a modification or two) to approach the problem."
                    }
                ]
            },
            {
                "id": 1886969,
                "content": [
                    {
                        "username": "enigma_007",
                        "content": "a hint which worked good for me:)\\njust compare the mid values of array with the low and the high and at any point of time either the left half or the right half is always sorted so this comparison can easily be put into a if else condition. If left half is sorted take the nums[low] value as it can be potential answer and move to the right part to get the minimum in that part. At last compare both the minimums and return the lesser number. Thanks:)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The approach you suggested works for the case where the array is rotated. However, if the array is not rotated (i.e., sorted in ascending order), comparing mid with low and high doesn\\'t help to determine the next search space.\\n\\nInstead, we should compare the mid value with the right (or last) value. This comparison gives us a clear rule to determine the next search space: If nums[mid] > nums[right], then the minimum must be in the right half (i.e., nums[mid+1 : right+1]), else the minimum is in the left half (i.e., nums[left : mid+1]).\\n\\nLet\\'s translate this into Python code:\\n\\n```python\\ndef findMin(nums):\\n    low, high = 0, len(nums) - 1\\n    while low < high:\\n        mid = low + (high - low) // 2\\n        if nums[mid] > nums[high]:\\n            low = mid + 1\\n        else:\\n            high = mid\\n    return nums[low]\\n```\\n\\nThis code implements binary search, and it continuously narrows down the search interval from [low, high] to [mid+1, high] or [low, mid], depending on the comparison between nums[mid] and nums[high]. The loop continues until low == high, at which point we\\'ve found the minimum element.\\n\\nThis algorithm is O(log N) as it halves the search space at each step."
                    },
                    {
                        "username": "enigma_007",
                        "content": "[@uphar_gaur](/uphar_gaur) see the rotation is applied on the original ascending sorted array and when you rotate the array k times the numbers do not assemble in a way you described. Say for instance we have 123456 as array and we do the rotations for 2 times then the rotated array would be 561234 and not 651234. Similarily there can never be a case in which 123456 is rotated to get 654321. Also regarding how i can be so sure that the array is always sorted is the fact that if it is rotated by more than half times the initial half would always be sorted and if it is rotated by less than half the array size times the later half will always be sorted.Hope, i have solved your query."
                    },
                    {
                        "username": "uphar_gaur",
                        "content": "how can u say one part is sorted at any time ,see 654321 here at any time none of the side is sorted\\n "
                    },
                    {
                        "username": "ppnnssy",
                        "content": "C++: \\n` return *min_element(nums.begin(), nums.end()) `"
                    },
                    {
                        "username": "user2194kq",
                        "content": "Most naive solution is to sort and return nums[0]."
                    },
                    {
                        "username": "bparanj",
                        "content": "While that approach would certainly work and return the correct result, it does not meet the performance requirement stated in the problem, which demands an algorithm that runs in O(log n) time. Sorting an array typically requires O(n log n) time, which is more costly than the required O(log n).\\n\\nThe problem statement also indicates that the array is already sorted, but rotated. So, sorting again isn\\'t taking advantage of the existing sorted nature of the array.\\n\\nHere, binary search can be used to take advantage of the sorted nature of the array and find the minimum element in O(log n) time, which meets the problem\\'s constraints. The goal is to identify the point of rotation (i.e., the minimum element), which can be done in a divide-and-conquer manner, as shown in previous discussions."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@shoumikc](/shoumikc) The funny thing is that what he\\'s proposing isn\\'t even a linear solution lol"
                    },
                    {
                        "username": "shoumik916",
                        "content": "obviously lol. that\\'s why the problem is marked medium and says your solution must be O(log n). A linear solution like the one you described would never be accepted in an interview"
                    },
                    {
                        "username": "iamrohit3007",
                        "content": "This is quite easy question ig!!"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "did you ever feel like it is O(logn) but feels like O(n)"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Is there anybody who gets confuse while setting condition for binary search like whethere it should be (l<r) or (l<=r) or like whether it should be l = mid-1 or l = mid or r = mid+1 or r = mid.\\nThis stuff confuses me a lot.\\nSomeone please share your thoughts to clear.\\nThanks in advance."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, setting the right conditions in a binary search can be tricky and it\\'s one of the most common sources of confusion when implementing it. Here\\'s a simple guideline to follow:\\n\\n1. `l < r` vs `l <= r`: The condition `l < r` is generally used when you\\'re doing a binary search where the search space reduces on each step, meaning that at some point `l` and `r` will be the same. When they are the same, you know you\\'ve found the element or it does not exist. `l <= r` is used when you\\'re doing a binary search where you need to consider the middle element as well. \\n\\n2. `l = mid + 1` vs `l = mid` and `r = mid - 1` vs `r = mid`: These decisions are often problem-specific and depend on whether you are looking for the first occurrence, last occurrence, or any occurrence. Usually, when the middle element is not the target, you move one step to the left or right to skip the current middle element.\\n\\nRemember, the best way to get comfortable with these decisions is to practice problems involving binary search and try to understand the reasoning behind the conditions.\\n\\nIn this problem, we use `l < r` because we are reducing the search space on each step, and `l = mid + 1` or `r = mid` because we have already checked the mid element, and we are sure that it\\'s not the answer so we need to move one step further.\\n\\nVisualizing these steps can be very helpful. Let\\'s consider an array: `[4, 5, 6, 7, 0, 1, 2]`.\\n\\nStep 1. `l < r` vs `l <= r`:\\n\\nA binary search algorithm repeatedly divides the search space (the portion of the array we are interested in) in half. `l` and `r` represent the bounds of this search space. Initially, `l` is at the start of the array, and `r` is at the end. \\n\\nWhen we say `l < r`, it means the search continues as long as the left boundary is strictly less than the right boundary, indicating that there is more than one element left in the search space.\\n\\nHere is a quick visualization:\\n\\n```\\nArray:  4  5  6  7  0  1  2\\nIndex:  0  1  2  3  4  5  6\\n         ^           ^\\n         |           |\\n         l           r\\n\\nAfter a few iterations:\\n\\nArray:  4  5  6  7  0  1  2\\nIndex:  0  1  2  3  4  5  6\\n                  ^  ^\\n                  |  |\\n                  l  r\\n```\\n\\nWhen `l` and `r` point to the same element, we stop, because we\\'ve narrowed down the search space to a single element.\\n\\nStep 2. `l = mid + 1` vs `l = mid` and `r = mid - 1` vs `r = mid`:\\n\\nLet\\'s say we\\'re at a point where `l` is at index 3 (value 7), `r` is at index 6 (value 2), and `mid` is at index 4 (value 0). Here we find that `nums[mid] < nums[r]`. So, the minimum must be in the left part of the array. We then set `r` to `mid`.\\n\\nWhy not `mid - 1`? Because the `mid` element is a potential answer (it could be the minimum), so we include it in our next search space. \\n\\n```\\nArray:  4  5  6  7  0  1  2\\nIndex:  0  1  2  3  4  5  6\\n                  ^  ^  ^\\n                  |  |  |\\n                  l mid r\\n                  \\nNext iteration:\\n\\nArray:  4  5  6  7  0  1  2\\nIndex:  0  1  2  3  4  5  6\\n                  ^  ^\\n                  |  |\\n                  l/r(mid)    \\n```\\n\\nWe can see here that including `mid` in our search space allows us to find the minimum element in the array.\\n"
                    },
                    {
                        "username": "danny02052",
                        "content": "\nFirst, let us understand the concept of Binary Search (BS). BS is a method of optimizing a search by reducing the search space by half in every iteration. This approach can be applied whenever there is a condition based on which the search space can be reduced by half. One such condition is when the array is sorted. However, it is not necessary for the array to be sorted always. If we can find any other condition to divide the search space in two, we can still apply BS. Lets use this information to determine when to use L<=R vs L<R.\n\nI typically use L<=R when I know precisely which value I am searching for. In this scenario, if the value is not present in the array and the loop breaks when R<L, then R becomes the floor of the value and L becomes the ceiling of the value we are searching for. On the other hand, I use L<R when I do not know when the loop will break - because I do not know the value I am searching for in the array. In this case, I only know which side of the search space to look into in the next iteration. A practical example of this scenario is searching for a pivot in a mountain array. We do not know what the peak or pivot is, but we do know on which side the peak will be. Therefore, when L==R, the loop breaks, and we get our solution.\n\nWhen we use L<=R ---->>  L or R is always updated as L = mid +1 or R = mid-1 because we have already included nums[mid] in our search space by doing L<=R."
                    },
                    {
                        "username": "Rol1304",
                        "content": "i tried using the condition nums[mid]>=nums[0] in the if statement but it works for only rotating the array by two but nums[mid]>=nums[e] is the correct one"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re on the right track! Let\\'s break down why `nums[mid] >= nums[e]` is the correct condition in this scenario.\\n\\nIn a sorted and rotated array where all numbers are unique, the pivot point will always be the maximum number (let\\'s call it max). The elements to the left of the max are in ascending order and all larger than the elements to the right of max.\\n\\nThis leads us to the following conclusions:\\n\\n1. If `nums[mid] >= nums[0]`, this tells us that `mid` is on the left side of max. This condition is not sufficient to determine where the minimum value is. As you mentioned, it only works for some cases.\\n\\n2. On the other hand, if `nums[mid] >= nums[e]`, this means that `mid` is on the left side of max and all the elements to its right are smaller than `nums[mid]`. Therefore, the minimum value must lie in the right half. Conversely, if `nums[mid] < nums[e]`, the `mid` is on the right side of max, so the minimum must be on the left. This condition correctly guides the binary search towards the minimum value.\\n\\nThat\\'s why you should use `nums[mid] >= nums[e]` to determine which side of the array to search. This makes sure that the search space is always decreased by half and that the minimum element is within the search space."
                    },
                    {
                        "username": "abzelmes",
                        "content": "I think you need to add a condition that people can\\'t sort the array and need to use it as-is. Otherwise its Sort then get nums[0].. but without sorting its quite fun!"
                    },
                    {
                        "username": "YashuCoder",
                        "content": "Here the fun fact is min function beats 100% "
                    },
                    {
                        "username": "aguirre_roman",
                        "content": "Yeah, all the built in functions  like min of the programming language will beat whatever we write, but that doesn\\'t work in an interview."
                    },
                    {
                        "username": "beijaflor",
                        "content": "(Assuming Python) This is only true because `min()` and `max()` are written in C (for CPython at least -- see https://github.com/python/cpython/blob/main/Python/bltinmodule.c#L1727) and can avoid the bookkeeping of the equivalent algorithm written in pure Python.  Either way, the builtin `min()` requires a linear search (so it\\'s O(n)) while we can get O(log n) performance by taking advantage of the fact that the list is sorted (albeit rotated by some factor `k`).  Solve this problem in C with binary search and I bet you can blow Python\\'s `min()` out of the water."
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "How does the below solution work? Its a medium problem under binary search, am I missing anything?\\n\\n `public int findMin(int[] nums) {\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<min){\\n                min = nums[i];\\n            }\\n        }\\n        return min;\\n    }`"
                    },
                    {
                        "username": "beijaflor",
                        "content": "A sequential search (what you are doing above) does \"work\", but it works in O(n) time instead of the O(log n) specified in the problem description.  Think about how you could use the binary search algorithm to solve this problem instead, which would give a solution with O(log n) time complexity.  Keep in mind that in order for binary search to work on a list, the elements of the list have to be sorted in order.  The problem statement hints that the input list in this problem is \"sorted\", but perhaps not in the most intuitive order.  How could you apply a basic binary search implementation (perhaps with a modification or two) to approach the problem."
                    }
                ]
            },
            {
                "id": 1876722,
                "content": [
                    {
                        "username": "enigma_007",
                        "content": "a hint which worked good for me:)\\njust compare the mid values of array with the low and the high and at any point of time either the left half or the right half is always sorted so this comparison can easily be put into a if else condition. If left half is sorted take the nums[low] value as it can be potential answer and move to the right part to get the minimum in that part. At last compare both the minimums and return the lesser number. Thanks:)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The approach you suggested works for the case where the array is rotated. However, if the array is not rotated (i.e., sorted in ascending order), comparing mid with low and high doesn\\'t help to determine the next search space.\\n\\nInstead, we should compare the mid value with the right (or last) value. This comparison gives us a clear rule to determine the next search space: If nums[mid] > nums[right], then the minimum must be in the right half (i.e., nums[mid+1 : right+1]), else the minimum is in the left half (i.e., nums[left : mid+1]).\\n\\nLet\\'s translate this into Python code:\\n\\n```python\\ndef findMin(nums):\\n    low, high = 0, len(nums) - 1\\n    while low < high:\\n        mid = low + (high - low) // 2\\n        if nums[mid] > nums[high]:\\n            low = mid + 1\\n        else:\\n            high = mid\\n    return nums[low]\\n```\\n\\nThis code implements binary search, and it continuously narrows down the search interval from [low, high] to [mid+1, high] or [low, mid], depending on the comparison between nums[mid] and nums[high]. The loop continues until low == high, at which point we\\'ve found the minimum element.\\n\\nThis algorithm is O(log N) as it halves the search space at each step."
                    },
                    {
                        "username": "enigma_007",
                        "content": "[@uphar_gaur](/uphar_gaur) see the rotation is applied on the original ascending sorted array and when you rotate the array k times the numbers do not assemble in a way you described. Say for instance we have 123456 as array and we do the rotations for 2 times then the rotated array would be 561234 and not 651234. Similarily there can never be a case in which 123456 is rotated to get 654321. Also regarding how i can be so sure that the array is always sorted is the fact that if it is rotated by more than half times the initial half would always be sorted and if it is rotated by less than half the array size times the later half will always be sorted.Hope, i have solved your query."
                    },
                    {
                        "username": "uphar_gaur",
                        "content": "how can u say one part is sorted at any time ,see 654321 here at any time none of the side is sorted\\n "
                    },
                    {
                        "username": "ppnnssy",
                        "content": "C++: \\n` return *min_element(nums.begin(), nums.end()) `"
                    },
                    {
                        "username": "user2194kq",
                        "content": "Most naive solution is to sort and return nums[0]."
                    },
                    {
                        "username": "bparanj",
                        "content": "While that approach would certainly work and return the correct result, it does not meet the performance requirement stated in the problem, which demands an algorithm that runs in O(log n) time. Sorting an array typically requires O(n log n) time, which is more costly than the required O(log n).\\n\\nThe problem statement also indicates that the array is already sorted, but rotated. So, sorting again isn\\'t taking advantage of the existing sorted nature of the array.\\n\\nHere, binary search can be used to take advantage of the sorted nature of the array and find the minimum element in O(log n) time, which meets the problem\\'s constraints. The goal is to identify the point of rotation (i.e., the minimum element), which can be done in a divide-and-conquer manner, as shown in previous discussions."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@shoumikc](/shoumikc) The funny thing is that what he\\'s proposing isn\\'t even a linear solution lol"
                    },
                    {
                        "username": "shoumik916",
                        "content": "obviously lol. that\\'s why the problem is marked medium and says your solution must be O(log n). A linear solution like the one you described would never be accepted in an interview"
                    },
                    {
                        "username": "iamrohit3007",
                        "content": "This is quite easy question ig!!"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "did you ever feel like it is O(logn) but feels like O(n)"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Is there anybody who gets confuse while setting condition for binary search like whethere it should be (l<r) or (l<=r) or like whether it should be l = mid-1 or l = mid or r = mid+1 or r = mid.\\nThis stuff confuses me a lot.\\nSomeone please share your thoughts to clear.\\nThanks in advance."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, setting the right conditions in a binary search can be tricky and it\\'s one of the most common sources of confusion when implementing it. Here\\'s a simple guideline to follow:\\n\\n1. `l < r` vs `l <= r`: The condition `l < r` is generally used when you\\'re doing a binary search where the search space reduces on each step, meaning that at some point `l` and `r` will be the same. When they are the same, you know you\\'ve found the element or it does not exist. `l <= r` is used when you\\'re doing a binary search where you need to consider the middle element as well. \\n\\n2. `l = mid + 1` vs `l = mid` and `r = mid - 1` vs `r = mid`: These decisions are often problem-specific and depend on whether you are looking for the first occurrence, last occurrence, or any occurrence. Usually, when the middle element is not the target, you move one step to the left or right to skip the current middle element.\\n\\nRemember, the best way to get comfortable with these decisions is to practice problems involving binary search and try to understand the reasoning behind the conditions.\\n\\nIn this problem, we use `l < r` because we are reducing the search space on each step, and `l = mid + 1` or `r = mid` because we have already checked the mid element, and we are sure that it\\'s not the answer so we need to move one step further.\\n\\nVisualizing these steps can be very helpful. Let\\'s consider an array: `[4, 5, 6, 7, 0, 1, 2]`.\\n\\nStep 1. `l < r` vs `l <= r`:\\n\\nA binary search algorithm repeatedly divides the search space (the portion of the array we are interested in) in half. `l` and `r` represent the bounds of this search space. Initially, `l` is at the start of the array, and `r` is at the end. \\n\\nWhen we say `l < r`, it means the search continues as long as the left boundary is strictly less than the right boundary, indicating that there is more than one element left in the search space.\\n\\nHere is a quick visualization:\\n\\n```\\nArray:  4  5  6  7  0  1  2\\nIndex:  0  1  2  3  4  5  6\\n         ^           ^\\n         |           |\\n         l           r\\n\\nAfter a few iterations:\\n\\nArray:  4  5  6  7  0  1  2\\nIndex:  0  1  2  3  4  5  6\\n                  ^  ^\\n                  |  |\\n                  l  r\\n```\\n\\nWhen `l` and `r` point to the same element, we stop, because we\\'ve narrowed down the search space to a single element.\\n\\nStep 2. `l = mid + 1` vs `l = mid` and `r = mid - 1` vs `r = mid`:\\n\\nLet\\'s say we\\'re at a point where `l` is at index 3 (value 7), `r` is at index 6 (value 2), and `mid` is at index 4 (value 0). Here we find that `nums[mid] < nums[r]`. So, the minimum must be in the left part of the array. We then set `r` to `mid`.\\n\\nWhy not `mid - 1`? Because the `mid` element is a potential answer (it could be the minimum), so we include it in our next search space. \\n\\n```\\nArray:  4  5  6  7  0  1  2\\nIndex:  0  1  2  3  4  5  6\\n                  ^  ^  ^\\n                  |  |  |\\n                  l mid r\\n                  \\nNext iteration:\\n\\nArray:  4  5  6  7  0  1  2\\nIndex:  0  1  2  3  4  5  6\\n                  ^  ^\\n                  |  |\\n                  l/r(mid)    \\n```\\n\\nWe can see here that including `mid` in our search space allows us to find the minimum element in the array.\\n"
                    },
                    {
                        "username": "danny02052",
                        "content": "\nFirst, let us understand the concept of Binary Search (BS). BS is a method of optimizing a search by reducing the search space by half in every iteration. This approach can be applied whenever there is a condition based on which the search space can be reduced by half. One such condition is when the array is sorted. However, it is not necessary for the array to be sorted always. If we can find any other condition to divide the search space in two, we can still apply BS. Lets use this information to determine when to use L<=R vs L<R.\n\nI typically use L<=R when I know precisely which value I am searching for. In this scenario, if the value is not present in the array and the loop breaks when R<L, then R becomes the floor of the value and L becomes the ceiling of the value we are searching for. On the other hand, I use L<R when I do not know when the loop will break - because I do not know the value I am searching for in the array. In this case, I only know which side of the search space to look into in the next iteration. A practical example of this scenario is searching for a pivot in a mountain array. We do not know what the peak or pivot is, but we do know on which side the peak will be. Therefore, when L==R, the loop breaks, and we get our solution.\n\nWhen we use L<=R ---->>  L or R is always updated as L = mid +1 or R = mid-1 because we have already included nums[mid] in our search space by doing L<=R."
                    },
                    {
                        "username": "Rol1304",
                        "content": "i tried using the condition nums[mid]>=nums[0] in the if statement but it works for only rotating the array by two but nums[mid]>=nums[e] is the correct one"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re on the right track! Let\\'s break down why `nums[mid] >= nums[e]` is the correct condition in this scenario.\\n\\nIn a sorted and rotated array where all numbers are unique, the pivot point will always be the maximum number (let\\'s call it max). The elements to the left of the max are in ascending order and all larger than the elements to the right of max.\\n\\nThis leads us to the following conclusions:\\n\\n1. If `nums[mid] >= nums[0]`, this tells us that `mid` is on the left side of max. This condition is not sufficient to determine where the minimum value is. As you mentioned, it only works for some cases.\\n\\n2. On the other hand, if `nums[mid] >= nums[e]`, this means that `mid` is on the left side of max and all the elements to its right are smaller than `nums[mid]`. Therefore, the minimum value must lie in the right half. Conversely, if `nums[mid] < nums[e]`, the `mid` is on the right side of max, so the minimum must be on the left. This condition correctly guides the binary search towards the minimum value.\\n\\nThat\\'s why you should use `nums[mid] >= nums[e]` to determine which side of the array to search. This makes sure that the search space is always decreased by half and that the minimum element is within the search space."
                    },
                    {
                        "username": "abzelmes",
                        "content": "I think you need to add a condition that people can\\'t sort the array and need to use it as-is. Otherwise its Sort then get nums[0].. but without sorting its quite fun!"
                    },
                    {
                        "username": "YashuCoder",
                        "content": "Here the fun fact is min function beats 100% "
                    },
                    {
                        "username": "aguirre_roman",
                        "content": "Yeah, all the built in functions  like min of the programming language will beat whatever we write, but that doesn\\'t work in an interview."
                    },
                    {
                        "username": "beijaflor",
                        "content": "(Assuming Python) This is only true because `min()` and `max()` are written in C (for CPython at least -- see https://github.com/python/cpython/blob/main/Python/bltinmodule.c#L1727) and can avoid the bookkeeping of the equivalent algorithm written in pure Python.  Either way, the builtin `min()` requires a linear search (so it\\'s O(n)) while we can get O(log n) performance by taking advantage of the fact that the list is sorted (albeit rotated by some factor `k`).  Solve this problem in C with binary search and I bet you can blow Python\\'s `min()` out of the water."
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "How does the below solution work? Its a medium problem under binary search, am I missing anything?\\n\\n `public int findMin(int[] nums) {\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<min){\\n                min = nums[i];\\n            }\\n        }\\n        return min;\\n    }`"
                    },
                    {
                        "username": "beijaflor",
                        "content": "A sequential search (what you are doing above) does \"work\", but it works in O(n) time instead of the O(log n) specified in the problem description.  Think about how you could use the binary search algorithm to solve this problem instead, which would give a solution with O(log n) time complexity.  Keep in mind that in order for binary search to work on a list, the elements of the list have to be sorted in order.  The problem statement hints that the input list in this problem is \"sorted\", but perhaps not in the most intuitive order.  How could you apply a basic binary search implementation (perhaps with a modification or two) to approach the problem."
                    }
                ]
            },
            {
                "id": 1843053,
                "content": [
                    {
                        "username": "enigma_007",
                        "content": "a hint which worked good for me:)\\njust compare the mid values of array with the low and the high and at any point of time either the left half or the right half is always sorted so this comparison can easily be put into a if else condition. If left half is sorted take the nums[low] value as it can be potential answer and move to the right part to get the minimum in that part. At last compare both the minimums and return the lesser number. Thanks:)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The approach you suggested works for the case where the array is rotated. However, if the array is not rotated (i.e., sorted in ascending order), comparing mid with low and high doesn\\'t help to determine the next search space.\\n\\nInstead, we should compare the mid value with the right (or last) value. This comparison gives us a clear rule to determine the next search space: If nums[mid] > nums[right], then the minimum must be in the right half (i.e., nums[mid+1 : right+1]), else the minimum is in the left half (i.e., nums[left : mid+1]).\\n\\nLet\\'s translate this into Python code:\\n\\n```python\\ndef findMin(nums):\\n    low, high = 0, len(nums) - 1\\n    while low < high:\\n        mid = low + (high - low) // 2\\n        if nums[mid] > nums[high]:\\n            low = mid + 1\\n        else:\\n            high = mid\\n    return nums[low]\\n```\\n\\nThis code implements binary search, and it continuously narrows down the search interval from [low, high] to [mid+1, high] or [low, mid], depending on the comparison between nums[mid] and nums[high]. The loop continues until low == high, at which point we\\'ve found the minimum element.\\n\\nThis algorithm is O(log N) as it halves the search space at each step."
                    },
                    {
                        "username": "enigma_007",
                        "content": "[@uphar_gaur](/uphar_gaur) see the rotation is applied on the original ascending sorted array and when you rotate the array k times the numbers do not assemble in a way you described. Say for instance we have 123456 as array and we do the rotations for 2 times then the rotated array would be 561234 and not 651234. Similarily there can never be a case in which 123456 is rotated to get 654321. Also regarding how i can be so sure that the array is always sorted is the fact that if it is rotated by more than half times the initial half would always be sorted and if it is rotated by less than half the array size times the later half will always be sorted.Hope, i have solved your query."
                    },
                    {
                        "username": "uphar_gaur",
                        "content": "how can u say one part is sorted at any time ,see 654321 here at any time none of the side is sorted\\n "
                    },
                    {
                        "username": "ppnnssy",
                        "content": "C++: \\n` return *min_element(nums.begin(), nums.end()) `"
                    },
                    {
                        "username": "user2194kq",
                        "content": "Most naive solution is to sort and return nums[0]."
                    },
                    {
                        "username": "bparanj",
                        "content": "While that approach would certainly work and return the correct result, it does not meet the performance requirement stated in the problem, which demands an algorithm that runs in O(log n) time. Sorting an array typically requires O(n log n) time, which is more costly than the required O(log n).\\n\\nThe problem statement also indicates that the array is already sorted, but rotated. So, sorting again isn\\'t taking advantage of the existing sorted nature of the array.\\n\\nHere, binary search can be used to take advantage of the sorted nature of the array and find the minimum element in O(log n) time, which meets the problem\\'s constraints. The goal is to identify the point of rotation (i.e., the minimum element), which can be done in a divide-and-conquer manner, as shown in previous discussions."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@shoumikc](/shoumikc) The funny thing is that what he\\'s proposing isn\\'t even a linear solution lol"
                    },
                    {
                        "username": "shoumik916",
                        "content": "obviously lol. that\\'s why the problem is marked medium and says your solution must be O(log n). A linear solution like the one you described would never be accepted in an interview"
                    },
                    {
                        "username": "iamrohit3007",
                        "content": "This is quite easy question ig!!"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "did you ever feel like it is O(logn) but feels like O(n)"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Is there anybody who gets confuse while setting condition for binary search like whethere it should be (l<r) or (l<=r) or like whether it should be l = mid-1 or l = mid or r = mid+1 or r = mid.\\nThis stuff confuses me a lot.\\nSomeone please share your thoughts to clear.\\nThanks in advance."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, setting the right conditions in a binary search can be tricky and it\\'s one of the most common sources of confusion when implementing it. Here\\'s a simple guideline to follow:\\n\\n1. `l < r` vs `l <= r`: The condition `l < r` is generally used when you\\'re doing a binary search where the search space reduces on each step, meaning that at some point `l` and `r` will be the same. When they are the same, you know you\\'ve found the element or it does not exist. `l <= r` is used when you\\'re doing a binary search where you need to consider the middle element as well. \\n\\n2. `l = mid + 1` vs `l = mid` and `r = mid - 1` vs `r = mid`: These decisions are often problem-specific and depend on whether you are looking for the first occurrence, last occurrence, or any occurrence. Usually, when the middle element is not the target, you move one step to the left or right to skip the current middle element.\\n\\nRemember, the best way to get comfortable with these decisions is to practice problems involving binary search and try to understand the reasoning behind the conditions.\\n\\nIn this problem, we use `l < r` because we are reducing the search space on each step, and `l = mid + 1` or `r = mid` because we have already checked the mid element, and we are sure that it\\'s not the answer so we need to move one step further.\\n\\nVisualizing these steps can be very helpful. Let\\'s consider an array: `[4, 5, 6, 7, 0, 1, 2]`.\\n\\nStep 1. `l < r` vs `l <= r`:\\n\\nA binary search algorithm repeatedly divides the search space (the portion of the array we are interested in) in half. `l` and `r` represent the bounds of this search space. Initially, `l` is at the start of the array, and `r` is at the end. \\n\\nWhen we say `l < r`, it means the search continues as long as the left boundary is strictly less than the right boundary, indicating that there is more than one element left in the search space.\\n\\nHere is a quick visualization:\\n\\n```\\nArray:  4  5  6  7  0  1  2\\nIndex:  0  1  2  3  4  5  6\\n         ^           ^\\n         |           |\\n         l           r\\n\\nAfter a few iterations:\\n\\nArray:  4  5  6  7  0  1  2\\nIndex:  0  1  2  3  4  5  6\\n                  ^  ^\\n                  |  |\\n                  l  r\\n```\\n\\nWhen `l` and `r` point to the same element, we stop, because we\\'ve narrowed down the search space to a single element.\\n\\nStep 2. `l = mid + 1` vs `l = mid` and `r = mid - 1` vs `r = mid`:\\n\\nLet\\'s say we\\'re at a point where `l` is at index 3 (value 7), `r` is at index 6 (value 2), and `mid` is at index 4 (value 0). Here we find that `nums[mid] < nums[r]`. So, the minimum must be in the left part of the array. We then set `r` to `mid`.\\n\\nWhy not `mid - 1`? Because the `mid` element is a potential answer (it could be the minimum), so we include it in our next search space. \\n\\n```\\nArray:  4  5  6  7  0  1  2\\nIndex:  0  1  2  3  4  5  6\\n                  ^  ^  ^\\n                  |  |  |\\n                  l mid r\\n                  \\nNext iteration:\\n\\nArray:  4  5  6  7  0  1  2\\nIndex:  0  1  2  3  4  5  6\\n                  ^  ^\\n                  |  |\\n                  l/r(mid)    \\n```\\n\\nWe can see here that including `mid` in our search space allows us to find the minimum element in the array.\\n"
                    },
                    {
                        "username": "danny02052",
                        "content": "\nFirst, let us understand the concept of Binary Search (BS). BS is a method of optimizing a search by reducing the search space by half in every iteration. This approach can be applied whenever there is a condition based on which the search space can be reduced by half. One such condition is when the array is sorted. However, it is not necessary for the array to be sorted always. If we can find any other condition to divide the search space in two, we can still apply BS. Lets use this information to determine when to use L<=R vs L<R.\n\nI typically use L<=R when I know precisely which value I am searching for. In this scenario, if the value is not present in the array and the loop breaks when R<L, then R becomes the floor of the value and L becomes the ceiling of the value we are searching for. On the other hand, I use L<R when I do not know when the loop will break - because I do not know the value I am searching for in the array. In this case, I only know which side of the search space to look into in the next iteration. A practical example of this scenario is searching for a pivot in a mountain array. We do not know what the peak or pivot is, but we do know on which side the peak will be. Therefore, when L==R, the loop breaks, and we get our solution.\n\nWhen we use L<=R ---->>  L or R is always updated as L = mid +1 or R = mid-1 because we have already included nums[mid] in our search space by doing L<=R."
                    },
                    {
                        "username": "Rol1304",
                        "content": "i tried using the condition nums[mid]>=nums[0] in the if statement but it works for only rotating the array by two but nums[mid]>=nums[e] is the correct one"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re on the right track! Let\\'s break down why `nums[mid] >= nums[e]` is the correct condition in this scenario.\\n\\nIn a sorted and rotated array where all numbers are unique, the pivot point will always be the maximum number (let\\'s call it max). The elements to the left of the max are in ascending order and all larger than the elements to the right of max.\\n\\nThis leads us to the following conclusions:\\n\\n1. If `nums[mid] >= nums[0]`, this tells us that `mid` is on the left side of max. This condition is not sufficient to determine where the minimum value is. As you mentioned, it only works for some cases.\\n\\n2. On the other hand, if `nums[mid] >= nums[e]`, this means that `mid` is on the left side of max and all the elements to its right are smaller than `nums[mid]`. Therefore, the minimum value must lie in the right half. Conversely, if `nums[mid] < nums[e]`, the `mid` is on the right side of max, so the minimum must be on the left. This condition correctly guides the binary search towards the minimum value.\\n\\nThat\\'s why you should use `nums[mid] >= nums[e]` to determine which side of the array to search. This makes sure that the search space is always decreased by half and that the minimum element is within the search space."
                    },
                    {
                        "username": "abzelmes",
                        "content": "I think you need to add a condition that people can\\'t sort the array and need to use it as-is. Otherwise its Sort then get nums[0].. but without sorting its quite fun!"
                    },
                    {
                        "username": "YashuCoder",
                        "content": "Here the fun fact is min function beats 100% "
                    },
                    {
                        "username": "aguirre_roman",
                        "content": "Yeah, all the built in functions  like min of the programming language will beat whatever we write, but that doesn\\'t work in an interview."
                    },
                    {
                        "username": "beijaflor",
                        "content": "(Assuming Python) This is only true because `min()` and `max()` are written in C (for CPython at least -- see https://github.com/python/cpython/blob/main/Python/bltinmodule.c#L1727) and can avoid the bookkeeping of the equivalent algorithm written in pure Python.  Either way, the builtin `min()` requires a linear search (so it\\'s O(n)) while we can get O(log n) performance by taking advantage of the fact that the list is sorted (albeit rotated by some factor `k`).  Solve this problem in C with binary search and I bet you can blow Python\\'s `min()` out of the water."
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "How does the below solution work? Its a medium problem under binary search, am I missing anything?\\n\\n `public int findMin(int[] nums) {\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<min){\\n                min = nums[i];\\n            }\\n        }\\n        return min;\\n    }`"
                    },
                    {
                        "username": "beijaflor",
                        "content": "A sequential search (what you are doing above) does \"work\", but it works in O(n) time instead of the O(log n) specified in the problem description.  Think about how you could use the binary search algorithm to solve this problem instead, which would give a solution with O(log n) time complexity.  Keep in mind that in order for binary search to work on a list, the elements of the list have to be sorted in order.  The problem statement hints that the input list in this problem is \"sorted\", but perhaps not in the most intuitive order.  How could you apply a basic binary search implementation (perhaps with a modification or two) to approach the problem."
                    }
                ]
            },
            {
                "id": 1815639,
                "content": [
                    {
                        "username": "enigma_007",
                        "content": "a hint which worked good for me:)\\njust compare the mid values of array with the low and the high and at any point of time either the left half or the right half is always sorted so this comparison can easily be put into a if else condition. If left half is sorted take the nums[low] value as it can be potential answer and move to the right part to get the minimum in that part. At last compare both the minimums and return the lesser number. Thanks:)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The approach you suggested works for the case where the array is rotated. However, if the array is not rotated (i.e., sorted in ascending order), comparing mid with low and high doesn\\'t help to determine the next search space.\\n\\nInstead, we should compare the mid value with the right (or last) value. This comparison gives us a clear rule to determine the next search space: If nums[mid] > nums[right], then the minimum must be in the right half (i.e., nums[mid+1 : right+1]), else the minimum is in the left half (i.e., nums[left : mid+1]).\\n\\nLet\\'s translate this into Python code:\\n\\n```python\\ndef findMin(nums):\\n    low, high = 0, len(nums) - 1\\n    while low < high:\\n        mid = low + (high - low) // 2\\n        if nums[mid] > nums[high]:\\n            low = mid + 1\\n        else:\\n            high = mid\\n    return nums[low]\\n```\\n\\nThis code implements binary search, and it continuously narrows down the search interval from [low, high] to [mid+1, high] or [low, mid], depending on the comparison between nums[mid] and nums[high]. The loop continues until low == high, at which point we\\'ve found the minimum element.\\n\\nThis algorithm is O(log N) as it halves the search space at each step."
                    },
                    {
                        "username": "enigma_007",
                        "content": "[@uphar_gaur](/uphar_gaur) see the rotation is applied on the original ascending sorted array and when you rotate the array k times the numbers do not assemble in a way you described. Say for instance we have 123456 as array and we do the rotations for 2 times then the rotated array would be 561234 and not 651234. Similarily there can never be a case in which 123456 is rotated to get 654321. Also regarding how i can be so sure that the array is always sorted is the fact that if it is rotated by more than half times the initial half would always be sorted and if it is rotated by less than half the array size times the later half will always be sorted.Hope, i have solved your query."
                    },
                    {
                        "username": "uphar_gaur",
                        "content": "how can u say one part is sorted at any time ,see 654321 here at any time none of the side is sorted\\n "
                    },
                    {
                        "username": "ppnnssy",
                        "content": "C++: \\n` return *min_element(nums.begin(), nums.end()) `"
                    },
                    {
                        "username": "user2194kq",
                        "content": "Most naive solution is to sort and return nums[0]."
                    },
                    {
                        "username": "bparanj",
                        "content": "While that approach would certainly work and return the correct result, it does not meet the performance requirement stated in the problem, which demands an algorithm that runs in O(log n) time. Sorting an array typically requires O(n log n) time, which is more costly than the required O(log n).\\n\\nThe problem statement also indicates that the array is already sorted, but rotated. So, sorting again isn\\'t taking advantage of the existing sorted nature of the array.\\n\\nHere, binary search can be used to take advantage of the sorted nature of the array and find the minimum element in O(log n) time, which meets the problem\\'s constraints. The goal is to identify the point of rotation (i.e., the minimum element), which can be done in a divide-and-conquer manner, as shown in previous discussions."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@shoumikc](/shoumikc) The funny thing is that what he\\'s proposing isn\\'t even a linear solution lol"
                    },
                    {
                        "username": "shoumik916",
                        "content": "obviously lol. that\\'s why the problem is marked medium and says your solution must be O(log n). A linear solution like the one you described would never be accepted in an interview"
                    },
                    {
                        "username": "iamrohit3007",
                        "content": "This is quite easy question ig!!"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "did you ever feel like it is O(logn) but feels like O(n)"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Is there anybody who gets confuse while setting condition for binary search like whethere it should be (l<r) or (l<=r) or like whether it should be l = mid-1 or l = mid or r = mid+1 or r = mid.\\nThis stuff confuses me a lot.\\nSomeone please share your thoughts to clear.\\nThanks in advance."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, setting the right conditions in a binary search can be tricky and it\\'s one of the most common sources of confusion when implementing it. Here\\'s a simple guideline to follow:\\n\\n1. `l < r` vs `l <= r`: The condition `l < r` is generally used when you\\'re doing a binary search where the search space reduces on each step, meaning that at some point `l` and `r` will be the same. When they are the same, you know you\\'ve found the element or it does not exist. `l <= r` is used when you\\'re doing a binary search where you need to consider the middle element as well. \\n\\n2. `l = mid + 1` vs `l = mid` and `r = mid - 1` vs `r = mid`: These decisions are often problem-specific and depend on whether you are looking for the first occurrence, last occurrence, or any occurrence. Usually, when the middle element is not the target, you move one step to the left or right to skip the current middle element.\\n\\nRemember, the best way to get comfortable with these decisions is to practice problems involving binary search and try to understand the reasoning behind the conditions.\\n\\nIn this problem, we use `l < r` because we are reducing the search space on each step, and `l = mid + 1` or `r = mid` because we have already checked the mid element, and we are sure that it\\'s not the answer so we need to move one step further.\\n\\nVisualizing these steps can be very helpful. Let\\'s consider an array: `[4, 5, 6, 7, 0, 1, 2]`.\\n\\nStep 1. `l < r` vs `l <= r`:\\n\\nA binary search algorithm repeatedly divides the search space (the portion of the array we are interested in) in half. `l` and `r` represent the bounds of this search space. Initially, `l` is at the start of the array, and `r` is at the end. \\n\\nWhen we say `l < r`, it means the search continues as long as the left boundary is strictly less than the right boundary, indicating that there is more than one element left in the search space.\\n\\nHere is a quick visualization:\\n\\n```\\nArray:  4  5  6  7  0  1  2\\nIndex:  0  1  2  3  4  5  6\\n         ^           ^\\n         |           |\\n         l           r\\n\\nAfter a few iterations:\\n\\nArray:  4  5  6  7  0  1  2\\nIndex:  0  1  2  3  4  5  6\\n                  ^  ^\\n                  |  |\\n                  l  r\\n```\\n\\nWhen `l` and `r` point to the same element, we stop, because we\\'ve narrowed down the search space to a single element.\\n\\nStep 2. `l = mid + 1` vs `l = mid` and `r = mid - 1` vs `r = mid`:\\n\\nLet\\'s say we\\'re at a point where `l` is at index 3 (value 7), `r` is at index 6 (value 2), and `mid` is at index 4 (value 0). Here we find that `nums[mid] < nums[r]`. So, the minimum must be in the left part of the array. We then set `r` to `mid`.\\n\\nWhy not `mid - 1`? Because the `mid` element is a potential answer (it could be the minimum), so we include it in our next search space. \\n\\n```\\nArray:  4  5  6  7  0  1  2\\nIndex:  0  1  2  3  4  5  6\\n                  ^  ^  ^\\n                  |  |  |\\n                  l mid r\\n                  \\nNext iteration:\\n\\nArray:  4  5  6  7  0  1  2\\nIndex:  0  1  2  3  4  5  6\\n                  ^  ^\\n                  |  |\\n                  l/r(mid)    \\n```\\n\\nWe can see here that including `mid` in our search space allows us to find the minimum element in the array.\\n"
                    },
                    {
                        "username": "danny02052",
                        "content": "\nFirst, let us understand the concept of Binary Search (BS). BS is a method of optimizing a search by reducing the search space by half in every iteration. This approach can be applied whenever there is a condition based on which the search space can be reduced by half. One such condition is when the array is sorted. However, it is not necessary for the array to be sorted always. If we can find any other condition to divide the search space in two, we can still apply BS. Lets use this information to determine when to use L<=R vs L<R.\n\nI typically use L<=R when I know precisely which value I am searching for. In this scenario, if the value is not present in the array and the loop breaks when R<L, then R becomes the floor of the value and L becomes the ceiling of the value we are searching for. On the other hand, I use L<R when I do not know when the loop will break - because I do not know the value I am searching for in the array. In this case, I only know which side of the search space to look into in the next iteration. A practical example of this scenario is searching for a pivot in a mountain array. We do not know what the peak or pivot is, but we do know on which side the peak will be. Therefore, when L==R, the loop breaks, and we get our solution.\n\nWhen we use L<=R ---->>  L or R is always updated as L = mid +1 or R = mid-1 because we have already included nums[mid] in our search space by doing L<=R."
                    },
                    {
                        "username": "Rol1304",
                        "content": "i tried using the condition nums[mid]>=nums[0] in the if statement but it works for only rotating the array by two but nums[mid]>=nums[e] is the correct one"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re on the right track! Let\\'s break down why `nums[mid] >= nums[e]` is the correct condition in this scenario.\\n\\nIn a sorted and rotated array where all numbers are unique, the pivot point will always be the maximum number (let\\'s call it max). The elements to the left of the max are in ascending order and all larger than the elements to the right of max.\\n\\nThis leads us to the following conclusions:\\n\\n1. If `nums[mid] >= nums[0]`, this tells us that `mid` is on the left side of max. This condition is not sufficient to determine where the minimum value is. As you mentioned, it only works for some cases.\\n\\n2. On the other hand, if `nums[mid] >= nums[e]`, this means that `mid` is on the left side of max and all the elements to its right are smaller than `nums[mid]`. Therefore, the minimum value must lie in the right half. Conversely, if `nums[mid] < nums[e]`, the `mid` is on the right side of max, so the minimum must be on the left. This condition correctly guides the binary search towards the minimum value.\\n\\nThat\\'s why you should use `nums[mid] >= nums[e]` to determine which side of the array to search. This makes sure that the search space is always decreased by half and that the minimum element is within the search space."
                    },
                    {
                        "username": "abzelmes",
                        "content": "I think you need to add a condition that people can\\'t sort the array and need to use it as-is. Otherwise its Sort then get nums[0].. but without sorting its quite fun!"
                    },
                    {
                        "username": "YashuCoder",
                        "content": "Here the fun fact is min function beats 100% "
                    },
                    {
                        "username": "aguirre_roman",
                        "content": "Yeah, all the built in functions  like min of the programming language will beat whatever we write, but that doesn\\'t work in an interview."
                    },
                    {
                        "username": "beijaflor",
                        "content": "(Assuming Python) This is only true because `min()` and `max()` are written in C (for CPython at least -- see https://github.com/python/cpython/blob/main/Python/bltinmodule.c#L1727) and can avoid the bookkeeping of the equivalent algorithm written in pure Python.  Either way, the builtin `min()` requires a linear search (so it\\'s O(n)) while we can get O(log n) performance by taking advantage of the fact that the list is sorted (albeit rotated by some factor `k`).  Solve this problem in C with binary search and I bet you can blow Python\\'s `min()` out of the water."
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "How does the below solution work? Its a medium problem under binary search, am I missing anything?\\n\\n `public int findMin(int[] nums) {\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<min){\\n                min = nums[i];\\n            }\\n        }\\n        return min;\\n    }`"
                    },
                    {
                        "username": "beijaflor",
                        "content": "A sequential search (what you are doing above) does \"work\", but it works in O(n) time instead of the O(log n) specified in the problem description.  Think about how you could use the binary search algorithm to solve this problem instead, which would give a solution with O(log n) time complexity.  Keep in mind that in order for binary search to work on a list, the elements of the list have to be sorted in order.  The problem statement hints that the input list in this problem is \"sorted\", but perhaps not in the most intuitive order.  How could you apply a basic binary search implementation (perhaps with a modification or two) to approach the problem."
                    }
                ]
            },
            {
                "id": 1814044,
                "content": [
                    {
                        "username": "enigma_007",
                        "content": "a hint which worked good for me:)\\njust compare the mid values of array with the low and the high and at any point of time either the left half or the right half is always sorted so this comparison can easily be put into a if else condition. If left half is sorted take the nums[low] value as it can be potential answer and move to the right part to get the minimum in that part. At last compare both the minimums and return the lesser number. Thanks:)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The approach you suggested works for the case where the array is rotated. However, if the array is not rotated (i.e., sorted in ascending order), comparing mid with low and high doesn\\'t help to determine the next search space.\\n\\nInstead, we should compare the mid value with the right (or last) value. This comparison gives us a clear rule to determine the next search space: If nums[mid] > nums[right], then the minimum must be in the right half (i.e., nums[mid+1 : right+1]), else the minimum is in the left half (i.e., nums[left : mid+1]).\\n\\nLet\\'s translate this into Python code:\\n\\n```python\\ndef findMin(nums):\\n    low, high = 0, len(nums) - 1\\n    while low < high:\\n        mid = low + (high - low) // 2\\n        if nums[mid] > nums[high]:\\n            low = mid + 1\\n        else:\\n            high = mid\\n    return nums[low]\\n```\\n\\nThis code implements binary search, and it continuously narrows down the search interval from [low, high] to [mid+1, high] or [low, mid], depending on the comparison between nums[mid] and nums[high]. The loop continues until low == high, at which point we\\'ve found the minimum element.\\n\\nThis algorithm is O(log N) as it halves the search space at each step."
                    },
                    {
                        "username": "enigma_007",
                        "content": "[@uphar_gaur](/uphar_gaur) see the rotation is applied on the original ascending sorted array and when you rotate the array k times the numbers do not assemble in a way you described. Say for instance we have 123456 as array and we do the rotations for 2 times then the rotated array would be 561234 and not 651234. Similarily there can never be a case in which 123456 is rotated to get 654321. Also regarding how i can be so sure that the array is always sorted is the fact that if it is rotated by more than half times the initial half would always be sorted and if it is rotated by less than half the array size times the later half will always be sorted.Hope, i have solved your query."
                    },
                    {
                        "username": "uphar_gaur",
                        "content": "how can u say one part is sorted at any time ,see 654321 here at any time none of the side is sorted\\n "
                    },
                    {
                        "username": "ppnnssy",
                        "content": "C++: \\n` return *min_element(nums.begin(), nums.end()) `"
                    },
                    {
                        "username": "user2194kq",
                        "content": "Most naive solution is to sort and return nums[0]."
                    },
                    {
                        "username": "bparanj",
                        "content": "While that approach would certainly work and return the correct result, it does not meet the performance requirement stated in the problem, which demands an algorithm that runs in O(log n) time. Sorting an array typically requires O(n log n) time, which is more costly than the required O(log n).\\n\\nThe problem statement also indicates that the array is already sorted, but rotated. So, sorting again isn\\'t taking advantage of the existing sorted nature of the array.\\n\\nHere, binary search can be used to take advantage of the sorted nature of the array and find the minimum element in O(log n) time, which meets the problem\\'s constraints. The goal is to identify the point of rotation (i.e., the minimum element), which can be done in a divide-and-conquer manner, as shown in previous discussions."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@shoumikc](/shoumikc) The funny thing is that what he\\'s proposing isn\\'t even a linear solution lol"
                    },
                    {
                        "username": "shoumik916",
                        "content": "obviously lol. that\\'s why the problem is marked medium and says your solution must be O(log n). A linear solution like the one you described would never be accepted in an interview"
                    },
                    {
                        "username": "iamrohit3007",
                        "content": "This is quite easy question ig!!"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "did you ever feel like it is O(logn) but feels like O(n)"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Is there anybody who gets confuse while setting condition for binary search like whethere it should be (l<r) or (l<=r) or like whether it should be l = mid-1 or l = mid or r = mid+1 or r = mid.\\nThis stuff confuses me a lot.\\nSomeone please share your thoughts to clear.\\nThanks in advance."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, setting the right conditions in a binary search can be tricky and it\\'s one of the most common sources of confusion when implementing it. Here\\'s a simple guideline to follow:\\n\\n1. `l < r` vs `l <= r`: The condition `l < r` is generally used when you\\'re doing a binary search where the search space reduces on each step, meaning that at some point `l` and `r` will be the same. When they are the same, you know you\\'ve found the element or it does not exist. `l <= r` is used when you\\'re doing a binary search where you need to consider the middle element as well. \\n\\n2. `l = mid + 1` vs `l = mid` and `r = mid - 1` vs `r = mid`: These decisions are often problem-specific and depend on whether you are looking for the first occurrence, last occurrence, or any occurrence. Usually, when the middle element is not the target, you move one step to the left or right to skip the current middle element.\\n\\nRemember, the best way to get comfortable with these decisions is to practice problems involving binary search and try to understand the reasoning behind the conditions.\\n\\nIn this problem, we use `l < r` because we are reducing the search space on each step, and `l = mid + 1` or `r = mid` because we have already checked the mid element, and we are sure that it\\'s not the answer so we need to move one step further.\\n\\nVisualizing these steps can be very helpful. Let\\'s consider an array: `[4, 5, 6, 7, 0, 1, 2]`.\\n\\nStep 1. `l < r` vs `l <= r`:\\n\\nA binary search algorithm repeatedly divides the search space (the portion of the array we are interested in) in half. `l` and `r` represent the bounds of this search space. Initially, `l` is at the start of the array, and `r` is at the end. \\n\\nWhen we say `l < r`, it means the search continues as long as the left boundary is strictly less than the right boundary, indicating that there is more than one element left in the search space.\\n\\nHere is a quick visualization:\\n\\n```\\nArray:  4  5  6  7  0  1  2\\nIndex:  0  1  2  3  4  5  6\\n         ^           ^\\n         |           |\\n         l           r\\n\\nAfter a few iterations:\\n\\nArray:  4  5  6  7  0  1  2\\nIndex:  0  1  2  3  4  5  6\\n                  ^  ^\\n                  |  |\\n                  l  r\\n```\\n\\nWhen `l` and `r` point to the same element, we stop, because we\\'ve narrowed down the search space to a single element.\\n\\nStep 2. `l = mid + 1` vs `l = mid` and `r = mid - 1` vs `r = mid`:\\n\\nLet\\'s say we\\'re at a point where `l` is at index 3 (value 7), `r` is at index 6 (value 2), and `mid` is at index 4 (value 0). Here we find that `nums[mid] < nums[r]`. So, the minimum must be in the left part of the array. We then set `r` to `mid`.\\n\\nWhy not `mid - 1`? Because the `mid` element is a potential answer (it could be the minimum), so we include it in our next search space. \\n\\n```\\nArray:  4  5  6  7  0  1  2\\nIndex:  0  1  2  3  4  5  6\\n                  ^  ^  ^\\n                  |  |  |\\n                  l mid r\\n                  \\nNext iteration:\\n\\nArray:  4  5  6  7  0  1  2\\nIndex:  0  1  2  3  4  5  6\\n                  ^  ^\\n                  |  |\\n                  l/r(mid)    \\n```\\n\\nWe can see here that including `mid` in our search space allows us to find the minimum element in the array.\\n"
                    },
                    {
                        "username": "danny02052",
                        "content": "\nFirst, let us understand the concept of Binary Search (BS). BS is a method of optimizing a search by reducing the search space by half in every iteration. This approach can be applied whenever there is a condition based on which the search space can be reduced by half. One such condition is when the array is sorted. However, it is not necessary for the array to be sorted always. If we can find any other condition to divide the search space in two, we can still apply BS. Lets use this information to determine when to use L<=R vs L<R.\n\nI typically use L<=R when I know precisely which value I am searching for. In this scenario, if the value is not present in the array and the loop breaks when R<L, then R becomes the floor of the value and L becomes the ceiling of the value we are searching for. On the other hand, I use L<R when I do not know when the loop will break - because I do not know the value I am searching for in the array. In this case, I only know which side of the search space to look into in the next iteration. A practical example of this scenario is searching for a pivot in a mountain array. We do not know what the peak or pivot is, but we do know on which side the peak will be. Therefore, when L==R, the loop breaks, and we get our solution.\n\nWhen we use L<=R ---->>  L or R is always updated as L = mid +1 or R = mid-1 because we have already included nums[mid] in our search space by doing L<=R."
                    },
                    {
                        "username": "Rol1304",
                        "content": "i tried using the condition nums[mid]>=nums[0] in the if statement but it works for only rotating the array by two but nums[mid]>=nums[e] is the correct one"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re on the right track! Let\\'s break down why `nums[mid] >= nums[e]` is the correct condition in this scenario.\\n\\nIn a sorted and rotated array where all numbers are unique, the pivot point will always be the maximum number (let\\'s call it max). The elements to the left of the max are in ascending order and all larger than the elements to the right of max.\\n\\nThis leads us to the following conclusions:\\n\\n1. If `nums[mid] >= nums[0]`, this tells us that `mid` is on the left side of max. This condition is not sufficient to determine where the minimum value is. As you mentioned, it only works for some cases.\\n\\n2. On the other hand, if `nums[mid] >= nums[e]`, this means that `mid` is on the left side of max and all the elements to its right are smaller than `nums[mid]`. Therefore, the minimum value must lie in the right half. Conversely, if `nums[mid] < nums[e]`, the `mid` is on the right side of max, so the minimum must be on the left. This condition correctly guides the binary search towards the minimum value.\\n\\nThat\\'s why you should use `nums[mid] >= nums[e]` to determine which side of the array to search. This makes sure that the search space is always decreased by half and that the minimum element is within the search space."
                    },
                    {
                        "username": "abzelmes",
                        "content": "I think you need to add a condition that people can\\'t sort the array and need to use it as-is. Otherwise its Sort then get nums[0].. but without sorting its quite fun!"
                    },
                    {
                        "username": "YashuCoder",
                        "content": "Here the fun fact is min function beats 100% "
                    },
                    {
                        "username": "aguirre_roman",
                        "content": "Yeah, all the built in functions  like min of the programming language will beat whatever we write, but that doesn\\'t work in an interview."
                    },
                    {
                        "username": "beijaflor",
                        "content": "(Assuming Python) This is only true because `min()` and `max()` are written in C (for CPython at least -- see https://github.com/python/cpython/blob/main/Python/bltinmodule.c#L1727) and can avoid the bookkeeping of the equivalent algorithm written in pure Python.  Either way, the builtin `min()` requires a linear search (so it\\'s O(n)) while we can get O(log n) performance by taking advantage of the fact that the list is sorted (albeit rotated by some factor `k`).  Solve this problem in C with binary search and I bet you can blow Python\\'s `min()` out of the water."
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "How does the below solution work? Its a medium problem under binary search, am I missing anything?\\n\\n `public int findMin(int[] nums) {\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<min){\\n                min = nums[i];\\n            }\\n        }\\n        return min;\\n    }`"
                    },
                    {
                        "username": "beijaflor",
                        "content": "A sequential search (what you are doing above) does \"work\", but it works in O(n) time instead of the O(log n) specified in the problem description.  Think about how you could use the binary search algorithm to solve this problem instead, which would give a solution with O(log n) time complexity.  Keep in mind that in order for binary search to work on a list, the elements of the list have to be sorted in order.  The problem statement hints that the input list in this problem is \"sorted\", but perhaps not in the most intuitive order.  How could you apply a basic binary search implementation (perhaps with a modification or two) to approach the problem."
                    }
                ]
            },
            {
                "id": 1809592,
                "content": [
                    {
                        "username": "enigma_007",
                        "content": "a hint which worked good for me:)\\njust compare the mid values of array with the low and the high and at any point of time either the left half or the right half is always sorted so this comparison can easily be put into a if else condition. If left half is sorted take the nums[low] value as it can be potential answer and move to the right part to get the minimum in that part. At last compare both the minimums and return the lesser number. Thanks:)"
                    },
                    {
                        "username": "bparanj",
                        "content": "The approach you suggested works for the case where the array is rotated. However, if the array is not rotated (i.e., sorted in ascending order), comparing mid with low and high doesn\\'t help to determine the next search space.\\n\\nInstead, we should compare the mid value with the right (or last) value. This comparison gives us a clear rule to determine the next search space: If nums[mid] > nums[right], then the minimum must be in the right half (i.e., nums[mid+1 : right+1]), else the minimum is in the left half (i.e., nums[left : mid+1]).\\n\\nLet\\'s translate this into Python code:\\n\\n```python\\ndef findMin(nums):\\n    low, high = 0, len(nums) - 1\\n    while low < high:\\n        mid = low + (high - low) // 2\\n        if nums[mid] > nums[high]:\\n            low = mid + 1\\n        else:\\n            high = mid\\n    return nums[low]\\n```\\n\\nThis code implements binary search, and it continuously narrows down the search interval from [low, high] to [mid+1, high] or [low, mid], depending on the comparison between nums[mid] and nums[high]. The loop continues until low == high, at which point we\\'ve found the minimum element.\\n\\nThis algorithm is O(log N) as it halves the search space at each step."
                    },
                    {
                        "username": "enigma_007",
                        "content": "[@uphar_gaur](/uphar_gaur) see the rotation is applied on the original ascending sorted array and when you rotate the array k times the numbers do not assemble in a way you described. Say for instance we have 123456 as array and we do the rotations for 2 times then the rotated array would be 561234 and not 651234. Similarily there can never be a case in which 123456 is rotated to get 654321. Also regarding how i can be so sure that the array is always sorted is the fact that if it is rotated by more than half times the initial half would always be sorted and if it is rotated by less than half the array size times the later half will always be sorted.Hope, i have solved your query."
                    },
                    {
                        "username": "uphar_gaur",
                        "content": "how can u say one part is sorted at any time ,see 654321 here at any time none of the side is sorted\\n "
                    },
                    {
                        "username": "ppnnssy",
                        "content": "C++: \\n` return *min_element(nums.begin(), nums.end()) `"
                    },
                    {
                        "username": "user2194kq",
                        "content": "Most naive solution is to sort and return nums[0]."
                    },
                    {
                        "username": "bparanj",
                        "content": "While that approach would certainly work and return the correct result, it does not meet the performance requirement stated in the problem, which demands an algorithm that runs in O(log n) time. Sorting an array typically requires O(n log n) time, which is more costly than the required O(log n).\\n\\nThe problem statement also indicates that the array is already sorted, but rotated. So, sorting again isn\\'t taking advantage of the existing sorted nature of the array.\\n\\nHere, binary search can be used to take advantage of the sorted nature of the array and find the minimum element in O(log n) time, which meets the problem\\'s constraints. The goal is to identify the point of rotation (i.e., the minimum element), which can be done in a divide-and-conquer manner, as shown in previous discussions."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@shoumikc](/shoumikc) The funny thing is that what he\\'s proposing isn\\'t even a linear solution lol"
                    },
                    {
                        "username": "shoumik916",
                        "content": "obviously lol. that\\'s why the problem is marked medium and says your solution must be O(log n). A linear solution like the one you described would never be accepted in an interview"
                    },
                    {
                        "username": "iamrohit3007",
                        "content": "This is quite easy question ig!!"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "did you ever feel like it is O(logn) but feels like O(n)"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "Is there anybody who gets confuse while setting condition for binary search like whethere it should be (l<r) or (l<=r) or like whether it should be l = mid-1 or l = mid or r = mid+1 or r = mid.\\nThis stuff confuses me a lot.\\nSomeone please share your thoughts to clear.\\nThanks in advance."
                    },
                    {
                        "username": "bparanj",
                        "content": "Yes, setting the right conditions in a binary search can be tricky and it\\'s one of the most common sources of confusion when implementing it. Here\\'s a simple guideline to follow:\\n\\n1. `l < r` vs `l <= r`: The condition `l < r` is generally used when you\\'re doing a binary search where the search space reduces on each step, meaning that at some point `l` and `r` will be the same. When they are the same, you know you\\'ve found the element or it does not exist. `l <= r` is used when you\\'re doing a binary search where you need to consider the middle element as well. \\n\\n2. `l = mid + 1` vs `l = mid` and `r = mid - 1` vs `r = mid`: These decisions are often problem-specific and depend on whether you are looking for the first occurrence, last occurrence, or any occurrence. Usually, when the middle element is not the target, you move one step to the left or right to skip the current middle element.\\n\\nRemember, the best way to get comfortable with these decisions is to practice problems involving binary search and try to understand the reasoning behind the conditions.\\n\\nIn this problem, we use `l < r` because we are reducing the search space on each step, and `l = mid + 1` or `r = mid` because we have already checked the mid element, and we are sure that it\\'s not the answer so we need to move one step further.\\n\\nVisualizing these steps can be very helpful. Let\\'s consider an array: `[4, 5, 6, 7, 0, 1, 2]`.\\n\\nStep 1. `l < r` vs `l <= r`:\\n\\nA binary search algorithm repeatedly divides the search space (the portion of the array we are interested in) in half. `l` and `r` represent the bounds of this search space. Initially, `l` is at the start of the array, and `r` is at the end. \\n\\nWhen we say `l < r`, it means the search continues as long as the left boundary is strictly less than the right boundary, indicating that there is more than one element left in the search space.\\n\\nHere is a quick visualization:\\n\\n```\\nArray:  4  5  6  7  0  1  2\\nIndex:  0  1  2  3  4  5  6\\n         ^           ^\\n         |           |\\n         l           r\\n\\nAfter a few iterations:\\n\\nArray:  4  5  6  7  0  1  2\\nIndex:  0  1  2  3  4  5  6\\n                  ^  ^\\n                  |  |\\n                  l  r\\n```\\n\\nWhen `l` and `r` point to the same element, we stop, because we\\'ve narrowed down the search space to a single element.\\n\\nStep 2. `l = mid + 1` vs `l = mid` and `r = mid - 1` vs `r = mid`:\\n\\nLet\\'s say we\\'re at a point where `l` is at index 3 (value 7), `r` is at index 6 (value 2), and `mid` is at index 4 (value 0). Here we find that `nums[mid] < nums[r]`. So, the minimum must be in the left part of the array. We then set `r` to `mid`.\\n\\nWhy not `mid - 1`? Because the `mid` element is a potential answer (it could be the minimum), so we include it in our next search space. \\n\\n```\\nArray:  4  5  6  7  0  1  2\\nIndex:  0  1  2  3  4  5  6\\n                  ^  ^  ^\\n                  |  |  |\\n                  l mid r\\n                  \\nNext iteration:\\n\\nArray:  4  5  6  7  0  1  2\\nIndex:  0  1  2  3  4  5  6\\n                  ^  ^\\n                  |  |\\n                  l/r(mid)    \\n```\\n\\nWe can see here that including `mid` in our search space allows us to find the minimum element in the array.\\n"
                    },
                    {
                        "username": "danny02052",
                        "content": "\nFirst, let us understand the concept of Binary Search (BS). BS is a method of optimizing a search by reducing the search space by half in every iteration. This approach can be applied whenever there is a condition based on which the search space can be reduced by half. One such condition is when the array is sorted. However, it is not necessary for the array to be sorted always. If we can find any other condition to divide the search space in two, we can still apply BS. Lets use this information to determine when to use L<=R vs L<R.\n\nI typically use L<=R when I know precisely which value I am searching for. In this scenario, if the value is not present in the array and the loop breaks when R<L, then R becomes the floor of the value and L becomes the ceiling of the value we are searching for. On the other hand, I use L<R when I do not know when the loop will break - because I do not know the value I am searching for in the array. In this case, I only know which side of the search space to look into in the next iteration. A practical example of this scenario is searching for a pivot in a mountain array. We do not know what the peak or pivot is, but we do know on which side the peak will be. Therefore, when L==R, the loop breaks, and we get our solution.\n\nWhen we use L<=R ---->>  L or R is always updated as L = mid +1 or R = mid-1 because we have already included nums[mid] in our search space by doing L<=R."
                    },
                    {
                        "username": "Rol1304",
                        "content": "i tried using the condition nums[mid]>=nums[0] in the if statement but it works for only rotating the array by two but nums[mid]>=nums[e] is the correct one"
                    },
                    {
                        "username": "bparanj",
                        "content": "You\\'re on the right track! Let\\'s break down why `nums[mid] >= nums[e]` is the correct condition in this scenario.\\n\\nIn a sorted and rotated array where all numbers are unique, the pivot point will always be the maximum number (let\\'s call it max). The elements to the left of the max are in ascending order and all larger than the elements to the right of max.\\n\\nThis leads us to the following conclusions:\\n\\n1. If `nums[mid] >= nums[0]`, this tells us that `mid` is on the left side of max. This condition is not sufficient to determine where the minimum value is. As you mentioned, it only works for some cases.\\n\\n2. On the other hand, if `nums[mid] >= nums[e]`, this means that `mid` is on the left side of max and all the elements to its right are smaller than `nums[mid]`. Therefore, the minimum value must lie in the right half. Conversely, if `nums[mid] < nums[e]`, the `mid` is on the right side of max, so the minimum must be on the left. This condition correctly guides the binary search towards the minimum value.\\n\\nThat\\'s why you should use `nums[mid] >= nums[e]` to determine which side of the array to search. This makes sure that the search space is always decreased by half and that the minimum element is within the search space."
                    },
                    {
                        "username": "abzelmes",
                        "content": "I think you need to add a condition that people can\\'t sort the array and need to use it as-is. Otherwise its Sort then get nums[0].. but without sorting its quite fun!"
                    },
                    {
                        "username": "YashuCoder",
                        "content": "Here the fun fact is min function beats 100% "
                    },
                    {
                        "username": "aguirre_roman",
                        "content": "Yeah, all the built in functions  like min of the programming language will beat whatever we write, but that doesn\\'t work in an interview."
                    },
                    {
                        "username": "beijaflor",
                        "content": "(Assuming Python) This is only true because `min()` and `max()` are written in C (for CPython at least -- see https://github.com/python/cpython/blob/main/Python/bltinmodule.c#L1727) and can avoid the bookkeeping of the equivalent algorithm written in pure Python.  Either way, the builtin `min()` requires a linear search (so it\\'s O(n)) while we can get O(log n) performance by taking advantage of the fact that the list is sorted (albeit rotated by some factor `k`).  Solve this problem in C with binary search and I bet you can blow Python\\'s `min()` out of the water."
                    },
                    {
                        "username": "RealNameHidden",
                        "content": "How does the below solution work? Its a medium problem under binary search, am I missing anything?\\n\\n `public int findMin(int[] nums) {\\n        int min = Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<min){\\n                min = nums[i];\\n            }\\n        }\\n        return min;\\n    }`"
                    },
                    {
                        "username": "beijaflor",
                        "content": "A sequential search (what you are doing above) does \"work\", but it works in O(n) time instead of the O(log n) specified in the problem description.  Think about how you could use the binary search algorithm to solve this problem instead, which would give a solution with O(log n) time complexity.  Keep in mind that in order for binary search to work on a list, the elements of the list have to be sorted in order.  The problem statement hints that the input list in this problem is \"sorted\", but perhaps not in the most intuitive order.  How could you apply a basic binary search implementation (perhaps with a modification or two) to approach the problem."
                    }
                ]
            },
            {
                "id": 1797864,
                "content": [
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Let's say array before sorting is:\na0, a1, ......., a(n-1)\n\nArray after rotation:\na(n-k), a(n-k+1), ......, a(n-1), a0, a1, ...., a(n-k+1)\n\nNo many how many times array is rotated, a0 will always remain the minimum element. So, idea here is to divide the array into two halves, if the first half is in increasing order, then it means that a0 lies in the second half, otherwise in the first half.\n\nNote that question can be re-written as finding the minimum index."
                    },
                    {
                        "username": "QASIM29",
                        "content": "O(N) for len() function isn\\'t that the case in every solution?\\n"
                    },
                    {
                        "username": "beijaflor",
                        "content": "Depends on the underlying data type.  In Python, the length of the builtin \"list\" type is stored as a pre-calculated field in the underlying struct along, thus yielding O(1) time complexity for `len(my_list)` lookups.\\n\\nhttps://wiki.python.org/moin/TimeComplexity "
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n    \\n       return *min_element(nums.begin(),nums.end());\\n        \\n        \\n        }\\n};"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    int findMin(vector<int>&nums){\\n\\n    int n  = nums.size();\\n\\n    if(nums[0] <=nums[n-1]){\\n        return nums[0];\\n    }\\n\\n    int s =0,e=n-1; \\n     while(s<=e){\\n\\n         int mid = (s+e)/2;\\n\\n         if(mid -1 >=0 && nums[mid] < nums[mid-1]){\\n             return nums[mid];\\n         }\\n         else if(nums[mid] > nums[n-1])\\n         {\\n             s  = mid+1;\\n         }\\n         else{\\n             e = mid -1;\\n         }\\n     }\\n     return INT_MIN;\\n}\\n};\\n"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Try to solve via While loop and Condition method"
                    },
                    {
                        "username": "Muskan003_NITA",
                        "content": "class Solution {\\npublic:\\n     int findMin(vector<int>& nums) {\\n        int s=0; int e=nums.size()-1; int m;\\n       //array already sorted hai usme change hi nhi hua toh minumum toh first index hoga n;\\n       if(nums[s]<=nums[e]){\\n          return nums[0];\\n       }\\n        while(s<e)\\n        {\\n           int m=s+(e-s)/2;\\n         if(nums[m]<nums[m-1]) {\\n             return nums[m];\\n         }\\n         else if(nums[m]>nums[m+1]){\\n             return nums[m+1];\\n         }\\n         else if (nums[s]<=nums[m]){\\n             s= m+1;\\n         }\\n         else if(nums[e]>=nums[m]){\\n             e=m-1;\\n         }\\n        \\n        \\n        }  \\n         return nums[s];\\n    }\\n};\\n\\n// why i am getting run time error  \\n//all test case passes but shows run time error"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error is likely due to accessing an out-of-bounds index in the array `nums` at these lines:\\n\\n```cpp\\nif(nums[m]<nums[m-1]) {\\n    return nums[m];\\n}\\nelse if(nums[m]>nums[m+1]){\\n    return nums[m+1];\\n}\\n```\\n\\nAt the beginning of the loop, when `m` is at 0 (which is the starting point), `m-1` will be -1. Similarly, at the end of the loop when `m` is at the last index, `m+1` will be out of bounds.\\n\\nTo fix these errors, you should modify your code to only check `nums[m]` against `nums[m-1]` and `nums[m+1]` if `m-1` and `m+1` are valid indices, respectively. Here\\'s how you can do it:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int s=0; \\n        int e=nums.size()-1;\\n        \\n        // If array is already sorted, return the first element\\n        if(nums[s] <= nums[e]){\\n            return nums[0];\\n        }\\n        \\n        while(s < e)\\n        {\\n            int m = s + (e - s) / 2;\\n            \\n            // Check if nums[m] is smaller than its predecessor\\n            if(m > 0 && nums[m] < nums[m-1]) {\\n                return nums[m];\\n            }\\n            // Check if nums[m] is greater than its successor\\n            else if(m < nums.size() - 1 && nums[m] > nums[m+1]){\\n                return nums[m+1];\\n            }\\n            else if (nums[s] <= nums[m]){\\n                s = m + 1;\\n            }\\n            else if(nums[e] >= nums[m]){\\n                e = m - 1;\\n            }\\n        }\\n        \\n        return nums[s];\\n    }\\n};\\n```\\n\\nThis version of the code avoids the runtime errors by ensuring that the indices used to access the elements in `nums` are always within bounds."
                    },
                    {
                        "username": "heliShah14",
                        "content": "Getting runtime error:\\n\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=0;\\n        if(nums[0]<nums[n-1]){\\n            return nums[0];\\n        }\\n        int mid=n/2;\\n        if(nums[mid]<nums[mid+1] && nums[mid]<nums[mid-1]){\\n            return nums[mid];\\n        }        \\n        if(nums[mid]>nums[0]){\\n            vector<int> slice(nums.begin()+mid, nums.end());\\n            ans=findMin(slice);\\n        }\\n        else{\\n            vector<int> slice(nums.begin(), nums.end()-mid);\\n            ans = findMin(slice);\\n        }\\n        return ans;                \\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue lies in the condition where you\\'re checking the middle value of the array. It fails when you\\'re considering an array with only 1 or 2 elements.\\n\\n```cpp\\nif(nums[mid]<nums[mid+1] && nums[mid]<nums[mid-1]){\\n    return nums[mid];\\n}\\n```\\n\\nIn the above condition, you\\'re accessing `mid+1` and `mid-1`, which may not be valid indices if the size of `nums` is 1 or 2.\\n\\nInstead, you should only perform this check when the size of `nums` is larger than 2:\\n\\n```cpp\\nif(n > 2 && nums[mid] < nums[mid + 1] && nums[mid] < nums[mid - 1]) {\\n    return nums[mid];\\n}\\n```\\n\\nIn addition, the way you\\'re slicing the array seems incorrect:\\n\\n```cpp\\nvector slice(nums.begin(), nums.end()-mid);\\n```\\n\\nIn the above line, you\\'re trying to construct `slice` from the beginning of `nums` to `mid` elements before the end of `nums`. This would give you more than half of the array when you\\'re supposed to get the first half. You likely intended to do:\\n\\n```cpp\\nvector slice(nums.begin(), nums.begin() + mid);\\n```\\n\\nThe correct code would be:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n = nums.size();\\n        int ans = 0;\\n        if(nums[0] < nums[n-1]) {\\n            return nums[0];\\n        }\\n        int mid = n / 2;\\n        if(n > 2 && nums[mid] < nums[mid + 1] && nums[mid] < nums[mid - 1]) {\\n            return nums[mid];\\n        }\\n        if(nums[mid] > nums[0]) {\\n            vector<int> slice(nums.begin() + mid, nums.end());\\n            ans = findMin(slice);\\n        }\\n        else {\\n            vector<int> slice(nums.begin(), nums.begin() + mid);\\n            ans = findMin(slice);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nThis version of the code avoids the runtime error by ensuring that the indices used to access elements in `nums` are always within bounds and correctly slicing the array. Note that this code is not the most efficient solution to the problem and it\\'s for demonstration purpose. The most efficient solution would be the binary search approach."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "applegeek519",
                        "content": "Simple JAVA solution ( 0 ms beats 100%)\\n\\n  public int findMin(int[] nums) {\\n        if(nums.length==1){\\n            return nums[0];\\n        }\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            if (nums[i] < nums[i+1] && nums[i] < nums[nums.length - 1]) {\\n                return nums[i];\\n            }\\n        }\\n        return nums[nums.length-1];\\n    }"
                    },
                    {
                        "username": "kaushik89ankit",
                        "content": "I just feel that in the end , nums[middle] should be compared with nums[start] and not nums[0]. Also , in case nums[middle] < nums[start] we should search between start and middle not middle-1"
                    }
                ]
            },
            {
                "id": 1796602,
                "content": [
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Let's say array before sorting is:\na0, a1, ......., a(n-1)\n\nArray after rotation:\na(n-k), a(n-k+1), ......, a(n-1), a0, a1, ...., a(n-k+1)\n\nNo many how many times array is rotated, a0 will always remain the minimum element. So, idea here is to divide the array into two halves, if the first half is in increasing order, then it means that a0 lies in the second half, otherwise in the first half.\n\nNote that question can be re-written as finding the minimum index."
                    },
                    {
                        "username": "QASIM29",
                        "content": "O(N) for len() function isn\\'t that the case in every solution?\\n"
                    },
                    {
                        "username": "beijaflor",
                        "content": "Depends on the underlying data type.  In Python, the length of the builtin \"list\" type is stored as a pre-calculated field in the underlying struct along, thus yielding O(1) time complexity for `len(my_list)` lookups.\\n\\nhttps://wiki.python.org/moin/TimeComplexity "
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n    \\n       return *min_element(nums.begin(),nums.end());\\n        \\n        \\n        }\\n};"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    int findMin(vector<int>&nums){\\n\\n    int n  = nums.size();\\n\\n    if(nums[0] <=nums[n-1]){\\n        return nums[0];\\n    }\\n\\n    int s =0,e=n-1; \\n     while(s<=e){\\n\\n         int mid = (s+e)/2;\\n\\n         if(mid -1 >=0 && nums[mid] < nums[mid-1]){\\n             return nums[mid];\\n         }\\n         else if(nums[mid] > nums[n-1])\\n         {\\n             s  = mid+1;\\n         }\\n         else{\\n             e = mid -1;\\n         }\\n     }\\n     return INT_MIN;\\n}\\n};\\n"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Try to solve via While loop and Condition method"
                    },
                    {
                        "username": "Muskan003_NITA",
                        "content": "class Solution {\\npublic:\\n     int findMin(vector<int>& nums) {\\n        int s=0; int e=nums.size()-1; int m;\\n       //array already sorted hai usme change hi nhi hua toh minumum toh first index hoga n;\\n       if(nums[s]<=nums[e]){\\n          return nums[0];\\n       }\\n        while(s<e)\\n        {\\n           int m=s+(e-s)/2;\\n         if(nums[m]<nums[m-1]) {\\n             return nums[m];\\n         }\\n         else if(nums[m]>nums[m+1]){\\n             return nums[m+1];\\n         }\\n         else if (nums[s]<=nums[m]){\\n             s= m+1;\\n         }\\n         else if(nums[e]>=nums[m]){\\n             e=m-1;\\n         }\\n        \\n        \\n        }  \\n         return nums[s];\\n    }\\n};\\n\\n// why i am getting run time error  \\n//all test case passes but shows run time error"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error is likely due to accessing an out-of-bounds index in the array `nums` at these lines:\\n\\n```cpp\\nif(nums[m]<nums[m-1]) {\\n    return nums[m];\\n}\\nelse if(nums[m]>nums[m+1]){\\n    return nums[m+1];\\n}\\n```\\n\\nAt the beginning of the loop, when `m` is at 0 (which is the starting point), `m-1` will be -1. Similarly, at the end of the loop when `m` is at the last index, `m+1` will be out of bounds.\\n\\nTo fix these errors, you should modify your code to only check `nums[m]` against `nums[m-1]` and `nums[m+1]` if `m-1` and `m+1` are valid indices, respectively. Here\\'s how you can do it:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int s=0; \\n        int e=nums.size()-1;\\n        \\n        // If array is already sorted, return the first element\\n        if(nums[s] <= nums[e]){\\n            return nums[0];\\n        }\\n        \\n        while(s < e)\\n        {\\n            int m = s + (e - s) / 2;\\n            \\n            // Check if nums[m] is smaller than its predecessor\\n            if(m > 0 && nums[m] < nums[m-1]) {\\n                return nums[m];\\n            }\\n            // Check if nums[m] is greater than its successor\\n            else if(m < nums.size() - 1 && nums[m] > nums[m+1]){\\n                return nums[m+1];\\n            }\\n            else if (nums[s] <= nums[m]){\\n                s = m + 1;\\n            }\\n            else if(nums[e] >= nums[m]){\\n                e = m - 1;\\n            }\\n        }\\n        \\n        return nums[s];\\n    }\\n};\\n```\\n\\nThis version of the code avoids the runtime errors by ensuring that the indices used to access the elements in `nums` are always within bounds."
                    },
                    {
                        "username": "heliShah14",
                        "content": "Getting runtime error:\\n\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=0;\\n        if(nums[0]<nums[n-1]){\\n            return nums[0];\\n        }\\n        int mid=n/2;\\n        if(nums[mid]<nums[mid+1] && nums[mid]<nums[mid-1]){\\n            return nums[mid];\\n        }        \\n        if(nums[mid]>nums[0]){\\n            vector<int> slice(nums.begin()+mid, nums.end());\\n            ans=findMin(slice);\\n        }\\n        else{\\n            vector<int> slice(nums.begin(), nums.end()-mid);\\n            ans = findMin(slice);\\n        }\\n        return ans;                \\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue lies in the condition where you\\'re checking the middle value of the array. It fails when you\\'re considering an array with only 1 or 2 elements.\\n\\n```cpp\\nif(nums[mid]<nums[mid+1] && nums[mid]<nums[mid-1]){\\n    return nums[mid];\\n}\\n```\\n\\nIn the above condition, you\\'re accessing `mid+1` and `mid-1`, which may not be valid indices if the size of `nums` is 1 or 2.\\n\\nInstead, you should only perform this check when the size of `nums` is larger than 2:\\n\\n```cpp\\nif(n > 2 && nums[mid] < nums[mid + 1] && nums[mid] < nums[mid - 1]) {\\n    return nums[mid];\\n}\\n```\\n\\nIn addition, the way you\\'re slicing the array seems incorrect:\\n\\n```cpp\\nvector slice(nums.begin(), nums.end()-mid);\\n```\\n\\nIn the above line, you\\'re trying to construct `slice` from the beginning of `nums` to `mid` elements before the end of `nums`. This would give you more than half of the array when you\\'re supposed to get the first half. You likely intended to do:\\n\\n```cpp\\nvector slice(nums.begin(), nums.begin() + mid);\\n```\\n\\nThe correct code would be:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n = nums.size();\\n        int ans = 0;\\n        if(nums[0] < nums[n-1]) {\\n            return nums[0];\\n        }\\n        int mid = n / 2;\\n        if(n > 2 && nums[mid] < nums[mid + 1] && nums[mid] < nums[mid - 1]) {\\n            return nums[mid];\\n        }\\n        if(nums[mid] > nums[0]) {\\n            vector<int> slice(nums.begin() + mid, nums.end());\\n            ans = findMin(slice);\\n        }\\n        else {\\n            vector<int> slice(nums.begin(), nums.begin() + mid);\\n            ans = findMin(slice);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nThis version of the code avoids the runtime error by ensuring that the indices used to access elements in `nums` are always within bounds and correctly slicing the array. Note that this code is not the most efficient solution to the problem and it\\'s for demonstration purpose. The most efficient solution would be the binary search approach."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "applegeek519",
                        "content": "Simple JAVA solution ( 0 ms beats 100%)\\n\\n  public int findMin(int[] nums) {\\n        if(nums.length==1){\\n            return nums[0];\\n        }\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            if (nums[i] < nums[i+1] && nums[i] < nums[nums.length - 1]) {\\n                return nums[i];\\n            }\\n        }\\n        return nums[nums.length-1];\\n    }"
                    },
                    {
                        "username": "kaushik89ankit",
                        "content": "I just feel that in the end , nums[middle] should be compared with nums[start] and not nums[0]. Also , in case nums[middle] < nums[start] we should search between start and middle not middle-1"
                    }
                ]
            },
            {
                "id": 1795276,
                "content": [
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Let's say array before sorting is:\na0, a1, ......., a(n-1)\n\nArray after rotation:\na(n-k), a(n-k+1), ......, a(n-1), a0, a1, ...., a(n-k+1)\n\nNo many how many times array is rotated, a0 will always remain the minimum element. So, idea here is to divide the array into two halves, if the first half is in increasing order, then it means that a0 lies in the second half, otherwise in the first half.\n\nNote that question can be re-written as finding the minimum index."
                    },
                    {
                        "username": "QASIM29",
                        "content": "O(N) for len() function isn\\'t that the case in every solution?\\n"
                    },
                    {
                        "username": "beijaflor",
                        "content": "Depends on the underlying data type.  In Python, the length of the builtin \"list\" type is stored as a pre-calculated field in the underlying struct along, thus yielding O(1) time complexity for `len(my_list)` lookups.\\n\\nhttps://wiki.python.org/moin/TimeComplexity "
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n    \\n       return *min_element(nums.begin(),nums.end());\\n        \\n        \\n        }\\n};"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    int findMin(vector<int>&nums){\\n\\n    int n  = nums.size();\\n\\n    if(nums[0] <=nums[n-1]){\\n        return nums[0];\\n    }\\n\\n    int s =0,e=n-1; \\n     while(s<=e){\\n\\n         int mid = (s+e)/2;\\n\\n         if(mid -1 >=0 && nums[mid] < nums[mid-1]){\\n             return nums[mid];\\n         }\\n         else if(nums[mid] > nums[n-1])\\n         {\\n             s  = mid+1;\\n         }\\n         else{\\n             e = mid -1;\\n         }\\n     }\\n     return INT_MIN;\\n}\\n};\\n"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Try to solve via While loop and Condition method"
                    },
                    {
                        "username": "Muskan003_NITA",
                        "content": "class Solution {\\npublic:\\n     int findMin(vector<int>& nums) {\\n        int s=0; int e=nums.size()-1; int m;\\n       //array already sorted hai usme change hi nhi hua toh minumum toh first index hoga n;\\n       if(nums[s]<=nums[e]){\\n          return nums[0];\\n       }\\n        while(s<e)\\n        {\\n           int m=s+(e-s)/2;\\n         if(nums[m]<nums[m-1]) {\\n             return nums[m];\\n         }\\n         else if(nums[m]>nums[m+1]){\\n             return nums[m+1];\\n         }\\n         else if (nums[s]<=nums[m]){\\n             s= m+1;\\n         }\\n         else if(nums[e]>=nums[m]){\\n             e=m-1;\\n         }\\n        \\n        \\n        }  \\n         return nums[s];\\n    }\\n};\\n\\n// why i am getting run time error  \\n//all test case passes but shows run time error"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error is likely due to accessing an out-of-bounds index in the array `nums` at these lines:\\n\\n```cpp\\nif(nums[m]<nums[m-1]) {\\n    return nums[m];\\n}\\nelse if(nums[m]>nums[m+1]){\\n    return nums[m+1];\\n}\\n```\\n\\nAt the beginning of the loop, when `m` is at 0 (which is the starting point), `m-1` will be -1. Similarly, at the end of the loop when `m` is at the last index, `m+1` will be out of bounds.\\n\\nTo fix these errors, you should modify your code to only check `nums[m]` against `nums[m-1]` and `nums[m+1]` if `m-1` and `m+1` are valid indices, respectively. Here\\'s how you can do it:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int s=0; \\n        int e=nums.size()-1;\\n        \\n        // If array is already sorted, return the first element\\n        if(nums[s] <= nums[e]){\\n            return nums[0];\\n        }\\n        \\n        while(s < e)\\n        {\\n            int m = s + (e - s) / 2;\\n            \\n            // Check if nums[m] is smaller than its predecessor\\n            if(m > 0 && nums[m] < nums[m-1]) {\\n                return nums[m];\\n            }\\n            // Check if nums[m] is greater than its successor\\n            else if(m < nums.size() - 1 && nums[m] > nums[m+1]){\\n                return nums[m+1];\\n            }\\n            else if (nums[s] <= nums[m]){\\n                s = m + 1;\\n            }\\n            else if(nums[e] >= nums[m]){\\n                e = m - 1;\\n            }\\n        }\\n        \\n        return nums[s];\\n    }\\n};\\n```\\n\\nThis version of the code avoids the runtime errors by ensuring that the indices used to access the elements in `nums` are always within bounds."
                    },
                    {
                        "username": "heliShah14",
                        "content": "Getting runtime error:\\n\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=0;\\n        if(nums[0]<nums[n-1]){\\n            return nums[0];\\n        }\\n        int mid=n/2;\\n        if(nums[mid]<nums[mid+1] && nums[mid]<nums[mid-1]){\\n            return nums[mid];\\n        }        \\n        if(nums[mid]>nums[0]){\\n            vector<int> slice(nums.begin()+mid, nums.end());\\n            ans=findMin(slice);\\n        }\\n        else{\\n            vector<int> slice(nums.begin(), nums.end()-mid);\\n            ans = findMin(slice);\\n        }\\n        return ans;                \\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue lies in the condition where you\\'re checking the middle value of the array. It fails when you\\'re considering an array with only 1 or 2 elements.\\n\\n```cpp\\nif(nums[mid]<nums[mid+1] && nums[mid]<nums[mid-1]){\\n    return nums[mid];\\n}\\n```\\n\\nIn the above condition, you\\'re accessing `mid+1` and `mid-1`, which may not be valid indices if the size of `nums` is 1 or 2.\\n\\nInstead, you should only perform this check when the size of `nums` is larger than 2:\\n\\n```cpp\\nif(n > 2 && nums[mid] < nums[mid + 1] && nums[mid] < nums[mid - 1]) {\\n    return nums[mid];\\n}\\n```\\n\\nIn addition, the way you\\'re slicing the array seems incorrect:\\n\\n```cpp\\nvector slice(nums.begin(), nums.end()-mid);\\n```\\n\\nIn the above line, you\\'re trying to construct `slice` from the beginning of `nums` to `mid` elements before the end of `nums`. This would give you more than half of the array when you\\'re supposed to get the first half. You likely intended to do:\\n\\n```cpp\\nvector slice(nums.begin(), nums.begin() + mid);\\n```\\n\\nThe correct code would be:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n = nums.size();\\n        int ans = 0;\\n        if(nums[0] < nums[n-1]) {\\n            return nums[0];\\n        }\\n        int mid = n / 2;\\n        if(n > 2 && nums[mid] < nums[mid + 1] && nums[mid] < nums[mid - 1]) {\\n            return nums[mid];\\n        }\\n        if(nums[mid] > nums[0]) {\\n            vector<int> slice(nums.begin() + mid, nums.end());\\n            ans = findMin(slice);\\n        }\\n        else {\\n            vector<int> slice(nums.begin(), nums.begin() + mid);\\n            ans = findMin(slice);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nThis version of the code avoids the runtime error by ensuring that the indices used to access elements in `nums` are always within bounds and correctly slicing the array. Note that this code is not the most efficient solution to the problem and it\\'s for demonstration purpose. The most efficient solution would be the binary search approach."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "applegeek519",
                        "content": "Simple JAVA solution ( 0 ms beats 100%)\\n\\n  public int findMin(int[] nums) {\\n        if(nums.length==1){\\n            return nums[0];\\n        }\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            if (nums[i] < nums[i+1] && nums[i] < nums[nums.length - 1]) {\\n                return nums[i];\\n            }\\n        }\\n        return nums[nums.length-1];\\n    }"
                    },
                    {
                        "username": "kaushik89ankit",
                        "content": "I just feel that in the end , nums[middle] should be compared with nums[start] and not nums[0]. Also , in case nums[middle] < nums[start] we should search between start and middle not middle-1"
                    }
                ]
            },
            {
                "id": 1795270,
                "content": [
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Let's say array before sorting is:\na0, a1, ......., a(n-1)\n\nArray after rotation:\na(n-k), a(n-k+1), ......, a(n-1), a0, a1, ...., a(n-k+1)\n\nNo many how many times array is rotated, a0 will always remain the minimum element. So, idea here is to divide the array into two halves, if the first half is in increasing order, then it means that a0 lies in the second half, otherwise in the first half.\n\nNote that question can be re-written as finding the minimum index."
                    },
                    {
                        "username": "QASIM29",
                        "content": "O(N) for len() function isn\\'t that the case in every solution?\\n"
                    },
                    {
                        "username": "beijaflor",
                        "content": "Depends on the underlying data type.  In Python, the length of the builtin \"list\" type is stored as a pre-calculated field in the underlying struct along, thus yielding O(1) time complexity for `len(my_list)` lookups.\\n\\nhttps://wiki.python.org/moin/TimeComplexity "
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n    \\n       return *min_element(nums.begin(),nums.end());\\n        \\n        \\n        }\\n};"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    int findMin(vector<int>&nums){\\n\\n    int n  = nums.size();\\n\\n    if(nums[0] <=nums[n-1]){\\n        return nums[0];\\n    }\\n\\n    int s =0,e=n-1; \\n     while(s<=e){\\n\\n         int mid = (s+e)/2;\\n\\n         if(mid -1 >=0 && nums[mid] < nums[mid-1]){\\n             return nums[mid];\\n         }\\n         else if(nums[mid] > nums[n-1])\\n         {\\n             s  = mid+1;\\n         }\\n         else{\\n             e = mid -1;\\n         }\\n     }\\n     return INT_MIN;\\n}\\n};\\n"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Try to solve via While loop and Condition method"
                    },
                    {
                        "username": "Muskan003_NITA",
                        "content": "class Solution {\\npublic:\\n     int findMin(vector<int>& nums) {\\n        int s=0; int e=nums.size()-1; int m;\\n       //array already sorted hai usme change hi nhi hua toh minumum toh first index hoga n;\\n       if(nums[s]<=nums[e]){\\n          return nums[0];\\n       }\\n        while(s<e)\\n        {\\n           int m=s+(e-s)/2;\\n         if(nums[m]<nums[m-1]) {\\n             return nums[m];\\n         }\\n         else if(nums[m]>nums[m+1]){\\n             return nums[m+1];\\n         }\\n         else if (nums[s]<=nums[m]){\\n             s= m+1;\\n         }\\n         else if(nums[e]>=nums[m]){\\n             e=m-1;\\n         }\\n        \\n        \\n        }  \\n         return nums[s];\\n    }\\n};\\n\\n// why i am getting run time error  \\n//all test case passes but shows run time error"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error is likely due to accessing an out-of-bounds index in the array `nums` at these lines:\\n\\n```cpp\\nif(nums[m]<nums[m-1]) {\\n    return nums[m];\\n}\\nelse if(nums[m]>nums[m+1]){\\n    return nums[m+1];\\n}\\n```\\n\\nAt the beginning of the loop, when `m` is at 0 (which is the starting point), `m-1` will be -1. Similarly, at the end of the loop when `m` is at the last index, `m+1` will be out of bounds.\\n\\nTo fix these errors, you should modify your code to only check `nums[m]` against `nums[m-1]` and `nums[m+1]` if `m-1` and `m+1` are valid indices, respectively. Here\\'s how you can do it:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int s=0; \\n        int e=nums.size()-1;\\n        \\n        // If array is already sorted, return the first element\\n        if(nums[s] <= nums[e]){\\n            return nums[0];\\n        }\\n        \\n        while(s < e)\\n        {\\n            int m = s + (e - s) / 2;\\n            \\n            // Check if nums[m] is smaller than its predecessor\\n            if(m > 0 && nums[m] < nums[m-1]) {\\n                return nums[m];\\n            }\\n            // Check if nums[m] is greater than its successor\\n            else if(m < nums.size() - 1 && nums[m] > nums[m+1]){\\n                return nums[m+1];\\n            }\\n            else if (nums[s] <= nums[m]){\\n                s = m + 1;\\n            }\\n            else if(nums[e] >= nums[m]){\\n                e = m - 1;\\n            }\\n        }\\n        \\n        return nums[s];\\n    }\\n};\\n```\\n\\nThis version of the code avoids the runtime errors by ensuring that the indices used to access the elements in `nums` are always within bounds."
                    },
                    {
                        "username": "heliShah14",
                        "content": "Getting runtime error:\\n\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=0;\\n        if(nums[0]<nums[n-1]){\\n            return nums[0];\\n        }\\n        int mid=n/2;\\n        if(nums[mid]<nums[mid+1] && nums[mid]<nums[mid-1]){\\n            return nums[mid];\\n        }        \\n        if(nums[mid]>nums[0]){\\n            vector<int> slice(nums.begin()+mid, nums.end());\\n            ans=findMin(slice);\\n        }\\n        else{\\n            vector<int> slice(nums.begin(), nums.end()-mid);\\n            ans = findMin(slice);\\n        }\\n        return ans;                \\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue lies in the condition where you\\'re checking the middle value of the array. It fails when you\\'re considering an array with only 1 or 2 elements.\\n\\n```cpp\\nif(nums[mid]<nums[mid+1] && nums[mid]<nums[mid-1]){\\n    return nums[mid];\\n}\\n```\\n\\nIn the above condition, you\\'re accessing `mid+1` and `mid-1`, which may not be valid indices if the size of `nums` is 1 or 2.\\n\\nInstead, you should only perform this check when the size of `nums` is larger than 2:\\n\\n```cpp\\nif(n > 2 && nums[mid] < nums[mid + 1] && nums[mid] < nums[mid - 1]) {\\n    return nums[mid];\\n}\\n```\\n\\nIn addition, the way you\\'re slicing the array seems incorrect:\\n\\n```cpp\\nvector slice(nums.begin(), nums.end()-mid);\\n```\\n\\nIn the above line, you\\'re trying to construct `slice` from the beginning of `nums` to `mid` elements before the end of `nums`. This would give you more than half of the array when you\\'re supposed to get the first half. You likely intended to do:\\n\\n```cpp\\nvector slice(nums.begin(), nums.begin() + mid);\\n```\\n\\nThe correct code would be:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n = nums.size();\\n        int ans = 0;\\n        if(nums[0] < nums[n-1]) {\\n            return nums[0];\\n        }\\n        int mid = n / 2;\\n        if(n > 2 && nums[mid] < nums[mid + 1] && nums[mid] < nums[mid - 1]) {\\n            return nums[mid];\\n        }\\n        if(nums[mid] > nums[0]) {\\n            vector<int> slice(nums.begin() + mid, nums.end());\\n            ans = findMin(slice);\\n        }\\n        else {\\n            vector<int> slice(nums.begin(), nums.begin() + mid);\\n            ans = findMin(slice);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nThis version of the code avoids the runtime error by ensuring that the indices used to access elements in `nums` are always within bounds and correctly slicing the array. Note that this code is not the most efficient solution to the problem and it\\'s for demonstration purpose. The most efficient solution would be the binary search approach."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "applegeek519",
                        "content": "Simple JAVA solution ( 0 ms beats 100%)\\n\\n  public int findMin(int[] nums) {\\n        if(nums.length==1){\\n            return nums[0];\\n        }\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            if (nums[i] < nums[i+1] && nums[i] < nums[nums.length - 1]) {\\n                return nums[i];\\n            }\\n        }\\n        return nums[nums.length-1];\\n    }"
                    },
                    {
                        "username": "kaushik89ankit",
                        "content": "I just feel that in the end , nums[middle] should be compared with nums[start] and not nums[0]. Also , in case nums[middle] < nums[start] we should search between start and middle not middle-1"
                    }
                ]
            },
            {
                "id": 1793004,
                "content": [
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Let's say array before sorting is:\na0, a1, ......., a(n-1)\n\nArray after rotation:\na(n-k), a(n-k+1), ......, a(n-1), a0, a1, ...., a(n-k+1)\n\nNo many how many times array is rotated, a0 will always remain the minimum element. So, idea here is to divide the array into two halves, if the first half is in increasing order, then it means that a0 lies in the second half, otherwise in the first half.\n\nNote that question can be re-written as finding the minimum index."
                    },
                    {
                        "username": "QASIM29",
                        "content": "O(N) for len() function isn\\'t that the case in every solution?\\n"
                    },
                    {
                        "username": "beijaflor",
                        "content": "Depends on the underlying data type.  In Python, the length of the builtin \"list\" type is stored as a pre-calculated field in the underlying struct along, thus yielding O(1) time complexity for `len(my_list)` lookups.\\n\\nhttps://wiki.python.org/moin/TimeComplexity "
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n    \\n       return *min_element(nums.begin(),nums.end());\\n        \\n        \\n        }\\n};"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    int findMin(vector<int>&nums){\\n\\n    int n  = nums.size();\\n\\n    if(nums[0] <=nums[n-1]){\\n        return nums[0];\\n    }\\n\\n    int s =0,e=n-1; \\n     while(s<=e){\\n\\n         int mid = (s+e)/2;\\n\\n         if(mid -1 >=0 && nums[mid] < nums[mid-1]){\\n             return nums[mid];\\n         }\\n         else if(nums[mid] > nums[n-1])\\n         {\\n             s  = mid+1;\\n         }\\n         else{\\n             e = mid -1;\\n         }\\n     }\\n     return INT_MIN;\\n}\\n};\\n"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Try to solve via While loop and Condition method"
                    },
                    {
                        "username": "Muskan003_NITA",
                        "content": "class Solution {\\npublic:\\n     int findMin(vector<int>& nums) {\\n        int s=0; int e=nums.size()-1; int m;\\n       //array already sorted hai usme change hi nhi hua toh minumum toh first index hoga n;\\n       if(nums[s]<=nums[e]){\\n          return nums[0];\\n       }\\n        while(s<e)\\n        {\\n           int m=s+(e-s)/2;\\n         if(nums[m]<nums[m-1]) {\\n             return nums[m];\\n         }\\n         else if(nums[m]>nums[m+1]){\\n             return nums[m+1];\\n         }\\n         else if (nums[s]<=nums[m]){\\n             s= m+1;\\n         }\\n         else if(nums[e]>=nums[m]){\\n             e=m-1;\\n         }\\n        \\n        \\n        }  \\n         return nums[s];\\n    }\\n};\\n\\n// why i am getting run time error  \\n//all test case passes but shows run time error"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error is likely due to accessing an out-of-bounds index in the array `nums` at these lines:\\n\\n```cpp\\nif(nums[m]<nums[m-1]) {\\n    return nums[m];\\n}\\nelse if(nums[m]>nums[m+1]){\\n    return nums[m+1];\\n}\\n```\\n\\nAt the beginning of the loop, when `m` is at 0 (which is the starting point), `m-1` will be -1. Similarly, at the end of the loop when `m` is at the last index, `m+1` will be out of bounds.\\n\\nTo fix these errors, you should modify your code to only check `nums[m]` against `nums[m-1]` and `nums[m+1]` if `m-1` and `m+1` are valid indices, respectively. Here\\'s how you can do it:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int s=0; \\n        int e=nums.size()-1;\\n        \\n        // If array is already sorted, return the first element\\n        if(nums[s] <= nums[e]){\\n            return nums[0];\\n        }\\n        \\n        while(s < e)\\n        {\\n            int m = s + (e - s) / 2;\\n            \\n            // Check if nums[m] is smaller than its predecessor\\n            if(m > 0 && nums[m] < nums[m-1]) {\\n                return nums[m];\\n            }\\n            // Check if nums[m] is greater than its successor\\n            else if(m < nums.size() - 1 && nums[m] > nums[m+1]){\\n                return nums[m+1];\\n            }\\n            else if (nums[s] <= nums[m]){\\n                s = m + 1;\\n            }\\n            else if(nums[e] >= nums[m]){\\n                e = m - 1;\\n            }\\n        }\\n        \\n        return nums[s];\\n    }\\n};\\n```\\n\\nThis version of the code avoids the runtime errors by ensuring that the indices used to access the elements in `nums` are always within bounds."
                    },
                    {
                        "username": "heliShah14",
                        "content": "Getting runtime error:\\n\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=0;\\n        if(nums[0]<nums[n-1]){\\n            return nums[0];\\n        }\\n        int mid=n/2;\\n        if(nums[mid]<nums[mid+1] && nums[mid]<nums[mid-1]){\\n            return nums[mid];\\n        }        \\n        if(nums[mid]>nums[0]){\\n            vector<int> slice(nums.begin()+mid, nums.end());\\n            ans=findMin(slice);\\n        }\\n        else{\\n            vector<int> slice(nums.begin(), nums.end()-mid);\\n            ans = findMin(slice);\\n        }\\n        return ans;                \\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue lies in the condition where you\\'re checking the middle value of the array. It fails when you\\'re considering an array with only 1 or 2 elements.\\n\\n```cpp\\nif(nums[mid]<nums[mid+1] && nums[mid]<nums[mid-1]){\\n    return nums[mid];\\n}\\n```\\n\\nIn the above condition, you\\'re accessing `mid+1` and `mid-1`, which may not be valid indices if the size of `nums` is 1 or 2.\\n\\nInstead, you should only perform this check when the size of `nums` is larger than 2:\\n\\n```cpp\\nif(n > 2 && nums[mid] < nums[mid + 1] && nums[mid] < nums[mid - 1]) {\\n    return nums[mid];\\n}\\n```\\n\\nIn addition, the way you\\'re slicing the array seems incorrect:\\n\\n```cpp\\nvector slice(nums.begin(), nums.end()-mid);\\n```\\n\\nIn the above line, you\\'re trying to construct `slice` from the beginning of `nums` to `mid` elements before the end of `nums`. This would give you more than half of the array when you\\'re supposed to get the first half. You likely intended to do:\\n\\n```cpp\\nvector slice(nums.begin(), nums.begin() + mid);\\n```\\n\\nThe correct code would be:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n = nums.size();\\n        int ans = 0;\\n        if(nums[0] < nums[n-1]) {\\n            return nums[0];\\n        }\\n        int mid = n / 2;\\n        if(n > 2 && nums[mid] < nums[mid + 1] && nums[mid] < nums[mid - 1]) {\\n            return nums[mid];\\n        }\\n        if(nums[mid] > nums[0]) {\\n            vector<int> slice(nums.begin() + mid, nums.end());\\n            ans = findMin(slice);\\n        }\\n        else {\\n            vector<int> slice(nums.begin(), nums.begin() + mid);\\n            ans = findMin(slice);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nThis version of the code avoids the runtime error by ensuring that the indices used to access elements in `nums` are always within bounds and correctly slicing the array. Note that this code is not the most efficient solution to the problem and it\\'s for demonstration purpose. The most efficient solution would be the binary search approach."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "applegeek519",
                        "content": "Simple JAVA solution ( 0 ms beats 100%)\\n\\n  public int findMin(int[] nums) {\\n        if(nums.length==1){\\n            return nums[0];\\n        }\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            if (nums[i] < nums[i+1] && nums[i] < nums[nums.length - 1]) {\\n                return nums[i];\\n            }\\n        }\\n        return nums[nums.length-1];\\n    }"
                    },
                    {
                        "username": "kaushik89ankit",
                        "content": "I just feel that in the end , nums[middle] should be compared with nums[start] and not nums[0]. Also , in case nums[middle] < nums[start] we should search between start and middle not middle-1"
                    }
                ]
            },
            {
                "id": 1783784,
                "content": [
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Let's say array before sorting is:\na0, a1, ......., a(n-1)\n\nArray after rotation:\na(n-k), a(n-k+1), ......, a(n-1), a0, a1, ...., a(n-k+1)\n\nNo many how many times array is rotated, a0 will always remain the minimum element. So, idea here is to divide the array into two halves, if the first half is in increasing order, then it means that a0 lies in the second half, otherwise in the first half.\n\nNote that question can be re-written as finding the minimum index."
                    },
                    {
                        "username": "QASIM29",
                        "content": "O(N) for len() function isn\\'t that the case in every solution?\\n"
                    },
                    {
                        "username": "beijaflor",
                        "content": "Depends on the underlying data type.  In Python, the length of the builtin \"list\" type is stored as a pre-calculated field in the underlying struct along, thus yielding O(1) time complexity for `len(my_list)` lookups.\\n\\nhttps://wiki.python.org/moin/TimeComplexity "
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n    \\n       return *min_element(nums.begin(),nums.end());\\n        \\n        \\n        }\\n};"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    int findMin(vector<int>&nums){\\n\\n    int n  = nums.size();\\n\\n    if(nums[0] <=nums[n-1]){\\n        return nums[0];\\n    }\\n\\n    int s =0,e=n-1; \\n     while(s<=e){\\n\\n         int mid = (s+e)/2;\\n\\n         if(mid -1 >=0 && nums[mid] < nums[mid-1]){\\n             return nums[mid];\\n         }\\n         else if(nums[mid] > nums[n-1])\\n         {\\n             s  = mid+1;\\n         }\\n         else{\\n             e = mid -1;\\n         }\\n     }\\n     return INT_MIN;\\n}\\n};\\n"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Try to solve via While loop and Condition method"
                    },
                    {
                        "username": "Muskan003_NITA",
                        "content": "class Solution {\\npublic:\\n     int findMin(vector<int>& nums) {\\n        int s=0; int e=nums.size()-1; int m;\\n       //array already sorted hai usme change hi nhi hua toh minumum toh first index hoga n;\\n       if(nums[s]<=nums[e]){\\n          return nums[0];\\n       }\\n        while(s<e)\\n        {\\n           int m=s+(e-s)/2;\\n         if(nums[m]<nums[m-1]) {\\n             return nums[m];\\n         }\\n         else if(nums[m]>nums[m+1]){\\n             return nums[m+1];\\n         }\\n         else if (nums[s]<=nums[m]){\\n             s= m+1;\\n         }\\n         else if(nums[e]>=nums[m]){\\n             e=m-1;\\n         }\\n        \\n        \\n        }  \\n         return nums[s];\\n    }\\n};\\n\\n// why i am getting run time error  \\n//all test case passes but shows run time error"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error is likely due to accessing an out-of-bounds index in the array `nums` at these lines:\\n\\n```cpp\\nif(nums[m]<nums[m-1]) {\\n    return nums[m];\\n}\\nelse if(nums[m]>nums[m+1]){\\n    return nums[m+1];\\n}\\n```\\n\\nAt the beginning of the loop, when `m` is at 0 (which is the starting point), `m-1` will be -1. Similarly, at the end of the loop when `m` is at the last index, `m+1` will be out of bounds.\\n\\nTo fix these errors, you should modify your code to only check `nums[m]` against `nums[m-1]` and `nums[m+1]` if `m-1` and `m+1` are valid indices, respectively. Here\\'s how you can do it:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int s=0; \\n        int e=nums.size()-1;\\n        \\n        // If array is already sorted, return the first element\\n        if(nums[s] <= nums[e]){\\n            return nums[0];\\n        }\\n        \\n        while(s < e)\\n        {\\n            int m = s + (e - s) / 2;\\n            \\n            // Check if nums[m] is smaller than its predecessor\\n            if(m > 0 && nums[m] < nums[m-1]) {\\n                return nums[m];\\n            }\\n            // Check if nums[m] is greater than its successor\\n            else if(m < nums.size() - 1 && nums[m] > nums[m+1]){\\n                return nums[m+1];\\n            }\\n            else if (nums[s] <= nums[m]){\\n                s = m + 1;\\n            }\\n            else if(nums[e] >= nums[m]){\\n                e = m - 1;\\n            }\\n        }\\n        \\n        return nums[s];\\n    }\\n};\\n```\\n\\nThis version of the code avoids the runtime errors by ensuring that the indices used to access the elements in `nums` are always within bounds."
                    },
                    {
                        "username": "heliShah14",
                        "content": "Getting runtime error:\\n\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=0;\\n        if(nums[0]<nums[n-1]){\\n            return nums[0];\\n        }\\n        int mid=n/2;\\n        if(nums[mid]<nums[mid+1] && nums[mid]<nums[mid-1]){\\n            return nums[mid];\\n        }        \\n        if(nums[mid]>nums[0]){\\n            vector<int> slice(nums.begin()+mid, nums.end());\\n            ans=findMin(slice);\\n        }\\n        else{\\n            vector<int> slice(nums.begin(), nums.end()-mid);\\n            ans = findMin(slice);\\n        }\\n        return ans;                \\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue lies in the condition where you\\'re checking the middle value of the array. It fails when you\\'re considering an array with only 1 or 2 elements.\\n\\n```cpp\\nif(nums[mid]<nums[mid+1] && nums[mid]<nums[mid-1]){\\n    return nums[mid];\\n}\\n```\\n\\nIn the above condition, you\\'re accessing `mid+1` and `mid-1`, which may not be valid indices if the size of `nums` is 1 or 2.\\n\\nInstead, you should only perform this check when the size of `nums` is larger than 2:\\n\\n```cpp\\nif(n > 2 && nums[mid] < nums[mid + 1] && nums[mid] < nums[mid - 1]) {\\n    return nums[mid];\\n}\\n```\\n\\nIn addition, the way you\\'re slicing the array seems incorrect:\\n\\n```cpp\\nvector slice(nums.begin(), nums.end()-mid);\\n```\\n\\nIn the above line, you\\'re trying to construct `slice` from the beginning of `nums` to `mid` elements before the end of `nums`. This would give you more than half of the array when you\\'re supposed to get the first half. You likely intended to do:\\n\\n```cpp\\nvector slice(nums.begin(), nums.begin() + mid);\\n```\\n\\nThe correct code would be:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n = nums.size();\\n        int ans = 0;\\n        if(nums[0] < nums[n-1]) {\\n            return nums[0];\\n        }\\n        int mid = n / 2;\\n        if(n > 2 && nums[mid] < nums[mid + 1] && nums[mid] < nums[mid - 1]) {\\n            return nums[mid];\\n        }\\n        if(nums[mid] > nums[0]) {\\n            vector<int> slice(nums.begin() + mid, nums.end());\\n            ans = findMin(slice);\\n        }\\n        else {\\n            vector<int> slice(nums.begin(), nums.begin() + mid);\\n            ans = findMin(slice);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nThis version of the code avoids the runtime error by ensuring that the indices used to access elements in `nums` are always within bounds and correctly slicing the array. Note that this code is not the most efficient solution to the problem and it\\'s for demonstration purpose. The most efficient solution would be the binary search approach."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "applegeek519",
                        "content": "Simple JAVA solution ( 0 ms beats 100%)\\n\\n  public int findMin(int[] nums) {\\n        if(nums.length==1){\\n            return nums[0];\\n        }\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            if (nums[i] < nums[i+1] && nums[i] < nums[nums.length - 1]) {\\n                return nums[i];\\n            }\\n        }\\n        return nums[nums.length-1];\\n    }"
                    },
                    {
                        "username": "kaushik89ankit",
                        "content": "I just feel that in the end , nums[middle] should be compared with nums[start] and not nums[0]. Also , in case nums[middle] < nums[start] we should search between start and middle not middle-1"
                    }
                ]
            },
            {
                "id": 1766857,
                "content": [
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Let's say array before sorting is:\na0, a1, ......., a(n-1)\n\nArray after rotation:\na(n-k), a(n-k+1), ......, a(n-1), a0, a1, ...., a(n-k+1)\n\nNo many how many times array is rotated, a0 will always remain the minimum element. So, idea here is to divide the array into two halves, if the first half is in increasing order, then it means that a0 lies in the second half, otherwise in the first half.\n\nNote that question can be re-written as finding the minimum index."
                    },
                    {
                        "username": "QASIM29",
                        "content": "O(N) for len() function isn\\'t that the case in every solution?\\n"
                    },
                    {
                        "username": "beijaflor",
                        "content": "Depends on the underlying data type.  In Python, the length of the builtin \"list\" type is stored as a pre-calculated field in the underlying struct along, thus yielding O(1) time complexity for `len(my_list)` lookups.\\n\\nhttps://wiki.python.org/moin/TimeComplexity "
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n    \\n       return *min_element(nums.begin(),nums.end());\\n        \\n        \\n        }\\n};"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    int findMin(vector<int>&nums){\\n\\n    int n  = nums.size();\\n\\n    if(nums[0] <=nums[n-1]){\\n        return nums[0];\\n    }\\n\\n    int s =0,e=n-1; \\n     while(s<=e){\\n\\n         int mid = (s+e)/2;\\n\\n         if(mid -1 >=0 && nums[mid] < nums[mid-1]){\\n             return nums[mid];\\n         }\\n         else if(nums[mid] > nums[n-1])\\n         {\\n             s  = mid+1;\\n         }\\n         else{\\n             e = mid -1;\\n         }\\n     }\\n     return INT_MIN;\\n}\\n};\\n"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Try to solve via While loop and Condition method"
                    },
                    {
                        "username": "Muskan003_NITA",
                        "content": "class Solution {\\npublic:\\n     int findMin(vector<int>& nums) {\\n        int s=0; int e=nums.size()-1; int m;\\n       //array already sorted hai usme change hi nhi hua toh minumum toh first index hoga n;\\n       if(nums[s]<=nums[e]){\\n          return nums[0];\\n       }\\n        while(s<e)\\n        {\\n           int m=s+(e-s)/2;\\n         if(nums[m]<nums[m-1]) {\\n             return nums[m];\\n         }\\n         else if(nums[m]>nums[m+1]){\\n             return nums[m+1];\\n         }\\n         else if (nums[s]<=nums[m]){\\n             s= m+1;\\n         }\\n         else if(nums[e]>=nums[m]){\\n             e=m-1;\\n         }\\n        \\n        \\n        }  \\n         return nums[s];\\n    }\\n};\\n\\n// why i am getting run time error  \\n//all test case passes but shows run time error"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error is likely due to accessing an out-of-bounds index in the array `nums` at these lines:\\n\\n```cpp\\nif(nums[m]<nums[m-1]) {\\n    return nums[m];\\n}\\nelse if(nums[m]>nums[m+1]){\\n    return nums[m+1];\\n}\\n```\\n\\nAt the beginning of the loop, when `m` is at 0 (which is the starting point), `m-1` will be -1. Similarly, at the end of the loop when `m` is at the last index, `m+1` will be out of bounds.\\n\\nTo fix these errors, you should modify your code to only check `nums[m]` against `nums[m-1]` and `nums[m+1]` if `m-1` and `m+1` are valid indices, respectively. Here\\'s how you can do it:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int s=0; \\n        int e=nums.size()-1;\\n        \\n        // If array is already sorted, return the first element\\n        if(nums[s] <= nums[e]){\\n            return nums[0];\\n        }\\n        \\n        while(s < e)\\n        {\\n            int m = s + (e - s) / 2;\\n            \\n            // Check if nums[m] is smaller than its predecessor\\n            if(m > 0 && nums[m] < nums[m-1]) {\\n                return nums[m];\\n            }\\n            // Check if nums[m] is greater than its successor\\n            else if(m < nums.size() - 1 && nums[m] > nums[m+1]){\\n                return nums[m+1];\\n            }\\n            else if (nums[s] <= nums[m]){\\n                s = m + 1;\\n            }\\n            else if(nums[e] >= nums[m]){\\n                e = m - 1;\\n            }\\n        }\\n        \\n        return nums[s];\\n    }\\n};\\n```\\n\\nThis version of the code avoids the runtime errors by ensuring that the indices used to access the elements in `nums` are always within bounds."
                    },
                    {
                        "username": "heliShah14",
                        "content": "Getting runtime error:\\n\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=0;\\n        if(nums[0]<nums[n-1]){\\n            return nums[0];\\n        }\\n        int mid=n/2;\\n        if(nums[mid]<nums[mid+1] && nums[mid]<nums[mid-1]){\\n            return nums[mid];\\n        }        \\n        if(nums[mid]>nums[0]){\\n            vector<int> slice(nums.begin()+mid, nums.end());\\n            ans=findMin(slice);\\n        }\\n        else{\\n            vector<int> slice(nums.begin(), nums.end()-mid);\\n            ans = findMin(slice);\\n        }\\n        return ans;                \\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue lies in the condition where you\\'re checking the middle value of the array. It fails when you\\'re considering an array with only 1 or 2 elements.\\n\\n```cpp\\nif(nums[mid]<nums[mid+1] && nums[mid]<nums[mid-1]){\\n    return nums[mid];\\n}\\n```\\n\\nIn the above condition, you\\'re accessing `mid+1` and `mid-1`, which may not be valid indices if the size of `nums` is 1 or 2.\\n\\nInstead, you should only perform this check when the size of `nums` is larger than 2:\\n\\n```cpp\\nif(n > 2 && nums[mid] < nums[mid + 1] && nums[mid] < nums[mid - 1]) {\\n    return nums[mid];\\n}\\n```\\n\\nIn addition, the way you\\'re slicing the array seems incorrect:\\n\\n```cpp\\nvector slice(nums.begin(), nums.end()-mid);\\n```\\n\\nIn the above line, you\\'re trying to construct `slice` from the beginning of `nums` to `mid` elements before the end of `nums`. This would give you more than half of the array when you\\'re supposed to get the first half. You likely intended to do:\\n\\n```cpp\\nvector slice(nums.begin(), nums.begin() + mid);\\n```\\n\\nThe correct code would be:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n = nums.size();\\n        int ans = 0;\\n        if(nums[0] < nums[n-1]) {\\n            return nums[0];\\n        }\\n        int mid = n / 2;\\n        if(n > 2 && nums[mid] < nums[mid + 1] && nums[mid] < nums[mid - 1]) {\\n            return nums[mid];\\n        }\\n        if(nums[mid] > nums[0]) {\\n            vector<int> slice(nums.begin() + mid, nums.end());\\n            ans = findMin(slice);\\n        }\\n        else {\\n            vector<int> slice(nums.begin(), nums.begin() + mid);\\n            ans = findMin(slice);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nThis version of the code avoids the runtime error by ensuring that the indices used to access elements in `nums` are always within bounds and correctly slicing the array. Note that this code is not the most efficient solution to the problem and it\\'s for demonstration purpose. The most efficient solution would be the binary search approach."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "applegeek519",
                        "content": "Simple JAVA solution ( 0 ms beats 100%)\\n\\n  public int findMin(int[] nums) {\\n        if(nums.length==1){\\n            return nums[0];\\n        }\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            if (nums[i] < nums[i+1] && nums[i] < nums[nums.length - 1]) {\\n                return nums[i];\\n            }\\n        }\\n        return nums[nums.length-1];\\n    }"
                    },
                    {
                        "username": "kaushik89ankit",
                        "content": "I just feel that in the end , nums[middle] should be compared with nums[start] and not nums[0]. Also , in case nums[middle] < nums[start] we should search between start and middle not middle-1"
                    }
                ]
            },
            {
                "id": 1756372,
                "content": [
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Let's say array before sorting is:\na0, a1, ......., a(n-1)\n\nArray after rotation:\na(n-k), a(n-k+1), ......, a(n-1), a0, a1, ...., a(n-k+1)\n\nNo many how many times array is rotated, a0 will always remain the minimum element. So, idea here is to divide the array into two halves, if the first half is in increasing order, then it means that a0 lies in the second half, otherwise in the first half.\n\nNote that question can be re-written as finding the minimum index."
                    },
                    {
                        "username": "QASIM29",
                        "content": "O(N) for len() function isn\\'t that the case in every solution?\\n"
                    },
                    {
                        "username": "beijaflor",
                        "content": "Depends on the underlying data type.  In Python, the length of the builtin \"list\" type is stored as a pre-calculated field in the underlying struct along, thus yielding O(1) time complexity for `len(my_list)` lookups.\\n\\nhttps://wiki.python.org/moin/TimeComplexity "
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n    \\n       return *min_element(nums.begin(),nums.end());\\n        \\n        \\n        }\\n};"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    int findMin(vector<int>&nums){\\n\\n    int n  = nums.size();\\n\\n    if(nums[0] <=nums[n-1]){\\n        return nums[0];\\n    }\\n\\n    int s =0,e=n-1; \\n     while(s<=e){\\n\\n         int mid = (s+e)/2;\\n\\n         if(mid -1 >=0 && nums[mid] < nums[mid-1]){\\n             return nums[mid];\\n         }\\n         else if(nums[mid] > nums[n-1])\\n         {\\n             s  = mid+1;\\n         }\\n         else{\\n             e = mid -1;\\n         }\\n     }\\n     return INT_MIN;\\n}\\n};\\n"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Try to solve via While loop and Condition method"
                    },
                    {
                        "username": "Muskan003_NITA",
                        "content": "class Solution {\\npublic:\\n     int findMin(vector<int>& nums) {\\n        int s=0; int e=nums.size()-1; int m;\\n       //array already sorted hai usme change hi nhi hua toh minumum toh first index hoga n;\\n       if(nums[s]<=nums[e]){\\n          return nums[0];\\n       }\\n        while(s<e)\\n        {\\n           int m=s+(e-s)/2;\\n         if(nums[m]<nums[m-1]) {\\n             return nums[m];\\n         }\\n         else if(nums[m]>nums[m+1]){\\n             return nums[m+1];\\n         }\\n         else if (nums[s]<=nums[m]){\\n             s= m+1;\\n         }\\n         else if(nums[e]>=nums[m]){\\n             e=m-1;\\n         }\\n        \\n        \\n        }  \\n         return nums[s];\\n    }\\n};\\n\\n// why i am getting run time error  \\n//all test case passes but shows run time error"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error is likely due to accessing an out-of-bounds index in the array `nums` at these lines:\\n\\n```cpp\\nif(nums[m]<nums[m-1]) {\\n    return nums[m];\\n}\\nelse if(nums[m]>nums[m+1]){\\n    return nums[m+1];\\n}\\n```\\n\\nAt the beginning of the loop, when `m` is at 0 (which is the starting point), `m-1` will be -1. Similarly, at the end of the loop when `m` is at the last index, `m+1` will be out of bounds.\\n\\nTo fix these errors, you should modify your code to only check `nums[m]` against `nums[m-1]` and `nums[m+1]` if `m-1` and `m+1` are valid indices, respectively. Here\\'s how you can do it:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int s=0; \\n        int e=nums.size()-1;\\n        \\n        // If array is already sorted, return the first element\\n        if(nums[s] <= nums[e]){\\n            return nums[0];\\n        }\\n        \\n        while(s < e)\\n        {\\n            int m = s + (e - s) / 2;\\n            \\n            // Check if nums[m] is smaller than its predecessor\\n            if(m > 0 && nums[m] < nums[m-1]) {\\n                return nums[m];\\n            }\\n            // Check if nums[m] is greater than its successor\\n            else if(m < nums.size() - 1 && nums[m] > nums[m+1]){\\n                return nums[m+1];\\n            }\\n            else if (nums[s] <= nums[m]){\\n                s = m + 1;\\n            }\\n            else if(nums[e] >= nums[m]){\\n                e = m - 1;\\n            }\\n        }\\n        \\n        return nums[s];\\n    }\\n};\\n```\\n\\nThis version of the code avoids the runtime errors by ensuring that the indices used to access the elements in `nums` are always within bounds."
                    },
                    {
                        "username": "heliShah14",
                        "content": "Getting runtime error:\\n\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=0;\\n        if(nums[0]<nums[n-1]){\\n            return nums[0];\\n        }\\n        int mid=n/2;\\n        if(nums[mid]<nums[mid+1] && nums[mid]<nums[mid-1]){\\n            return nums[mid];\\n        }        \\n        if(nums[mid]>nums[0]){\\n            vector<int> slice(nums.begin()+mid, nums.end());\\n            ans=findMin(slice);\\n        }\\n        else{\\n            vector<int> slice(nums.begin(), nums.end()-mid);\\n            ans = findMin(slice);\\n        }\\n        return ans;                \\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue lies in the condition where you\\'re checking the middle value of the array. It fails when you\\'re considering an array with only 1 or 2 elements.\\n\\n```cpp\\nif(nums[mid]<nums[mid+1] && nums[mid]<nums[mid-1]){\\n    return nums[mid];\\n}\\n```\\n\\nIn the above condition, you\\'re accessing `mid+1` and `mid-1`, which may not be valid indices if the size of `nums` is 1 or 2.\\n\\nInstead, you should only perform this check when the size of `nums` is larger than 2:\\n\\n```cpp\\nif(n > 2 && nums[mid] < nums[mid + 1] && nums[mid] < nums[mid - 1]) {\\n    return nums[mid];\\n}\\n```\\n\\nIn addition, the way you\\'re slicing the array seems incorrect:\\n\\n```cpp\\nvector slice(nums.begin(), nums.end()-mid);\\n```\\n\\nIn the above line, you\\'re trying to construct `slice` from the beginning of `nums` to `mid` elements before the end of `nums`. This would give you more than half of the array when you\\'re supposed to get the first half. You likely intended to do:\\n\\n```cpp\\nvector slice(nums.begin(), nums.begin() + mid);\\n```\\n\\nThe correct code would be:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n = nums.size();\\n        int ans = 0;\\n        if(nums[0] < nums[n-1]) {\\n            return nums[0];\\n        }\\n        int mid = n / 2;\\n        if(n > 2 && nums[mid] < nums[mid + 1] && nums[mid] < nums[mid - 1]) {\\n            return nums[mid];\\n        }\\n        if(nums[mid] > nums[0]) {\\n            vector<int> slice(nums.begin() + mid, nums.end());\\n            ans = findMin(slice);\\n        }\\n        else {\\n            vector<int> slice(nums.begin(), nums.begin() + mid);\\n            ans = findMin(slice);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nThis version of the code avoids the runtime error by ensuring that the indices used to access elements in `nums` are always within bounds and correctly slicing the array. Note that this code is not the most efficient solution to the problem and it\\'s for demonstration purpose. The most efficient solution would be the binary search approach."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "applegeek519",
                        "content": "Simple JAVA solution ( 0 ms beats 100%)\\n\\n  public int findMin(int[] nums) {\\n        if(nums.length==1){\\n            return nums[0];\\n        }\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            if (nums[i] < nums[i+1] && nums[i] < nums[nums.length - 1]) {\\n                return nums[i];\\n            }\\n        }\\n        return nums[nums.length-1];\\n    }"
                    },
                    {
                        "username": "kaushik89ankit",
                        "content": "I just feel that in the end , nums[middle] should be compared with nums[start] and not nums[0]. Also , in case nums[middle] < nums[start] we should search between start and middle not middle-1"
                    }
                ]
            },
            {
                "id": 1753522,
                "content": [
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Let's say array before sorting is:\na0, a1, ......., a(n-1)\n\nArray after rotation:\na(n-k), a(n-k+1), ......, a(n-1), a0, a1, ...., a(n-k+1)\n\nNo many how many times array is rotated, a0 will always remain the minimum element. So, idea here is to divide the array into two halves, if the first half is in increasing order, then it means that a0 lies in the second half, otherwise in the first half.\n\nNote that question can be re-written as finding the minimum index."
                    },
                    {
                        "username": "QASIM29",
                        "content": "O(N) for len() function isn\\'t that the case in every solution?\\n"
                    },
                    {
                        "username": "beijaflor",
                        "content": "Depends on the underlying data type.  In Python, the length of the builtin \"list\" type is stored as a pre-calculated field in the underlying struct along, thus yielding O(1) time complexity for `len(my_list)` lookups.\\n\\nhttps://wiki.python.org/moin/TimeComplexity "
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n    \\n       return *min_element(nums.begin(),nums.end());\\n        \\n        \\n        }\\n};"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    int findMin(vector<int>&nums){\\n\\n    int n  = nums.size();\\n\\n    if(nums[0] <=nums[n-1]){\\n        return nums[0];\\n    }\\n\\n    int s =0,e=n-1; \\n     while(s<=e){\\n\\n         int mid = (s+e)/2;\\n\\n         if(mid -1 >=0 && nums[mid] < nums[mid-1]){\\n             return nums[mid];\\n         }\\n         else if(nums[mid] > nums[n-1])\\n         {\\n             s  = mid+1;\\n         }\\n         else{\\n             e = mid -1;\\n         }\\n     }\\n     return INT_MIN;\\n}\\n};\\n"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Try to solve via While loop and Condition method"
                    },
                    {
                        "username": "Muskan003_NITA",
                        "content": "class Solution {\\npublic:\\n     int findMin(vector<int>& nums) {\\n        int s=0; int e=nums.size()-1; int m;\\n       //array already sorted hai usme change hi nhi hua toh minumum toh first index hoga n;\\n       if(nums[s]<=nums[e]){\\n          return nums[0];\\n       }\\n        while(s<e)\\n        {\\n           int m=s+(e-s)/2;\\n         if(nums[m]<nums[m-1]) {\\n             return nums[m];\\n         }\\n         else if(nums[m]>nums[m+1]){\\n             return nums[m+1];\\n         }\\n         else if (nums[s]<=nums[m]){\\n             s= m+1;\\n         }\\n         else if(nums[e]>=nums[m]){\\n             e=m-1;\\n         }\\n        \\n        \\n        }  \\n         return nums[s];\\n    }\\n};\\n\\n// why i am getting run time error  \\n//all test case passes but shows run time error"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error is likely due to accessing an out-of-bounds index in the array `nums` at these lines:\\n\\n```cpp\\nif(nums[m]<nums[m-1]) {\\n    return nums[m];\\n}\\nelse if(nums[m]>nums[m+1]){\\n    return nums[m+1];\\n}\\n```\\n\\nAt the beginning of the loop, when `m` is at 0 (which is the starting point), `m-1` will be -1. Similarly, at the end of the loop when `m` is at the last index, `m+1` will be out of bounds.\\n\\nTo fix these errors, you should modify your code to only check `nums[m]` against `nums[m-1]` and `nums[m+1]` if `m-1` and `m+1` are valid indices, respectively. Here\\'s how you can do it:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int s=0; \\n        int e=nums.size()-1;\\n        \\n        // If array is already sorted, return the first element\\n        if(nums[s] <= nums[e]){\\n            return nums[0];\\n        }\\n        \\n        while(s < e)\\n        {\\n            int m = s + (e - s) / 2;\\n            \\n            // Check if nums[m] is smaller than its predecessor\\n            if(m > 0 && nums[m] < nums[m-1]) {\\n                return nums[m];\\n            }\\n            // Check if nums[m] is greater than its successor\\n            else if(m < nums.size() - 1 && nums[m] > nums[m+1]){\\n                return nums[m+1];\\n            }\\n            else if (nums[s] <= nums[m]){\\n                s = m + 1;\\n            }\\n            else if(nums[e] >= nums[m]){\\n                e = m - 1;\\n            }\\n        }\\n        \\n        return nums[s];\\n    }\\n};\\n```\\n\\nThis version of the code avoids the runtime errors by ensuring that the indices used to access the elements in `nums` are always within bounds."
                    },
                    {
                        "username": "heliShah14",
                        "content": "Getting runtime error:\\n\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=0;\\n        if(nums[0]<nums[n-1]){\\n            return nums[0];\\n        }\\n        int mid=n/2;\\n        if(nums[mid]<nums[mid+1] && nums[mid]<nums[mid-1]){\\n            return nums[mid];\\n        }        \\n        if(nums[mid]>nums[0]){\\n            vector<int> slice(nums.begin()+mid, nums.end());\\n            ans=findMin(slice);\\n        }\\n        else{\\n            vector<int> slice(nums.begin(), nums.end()-mid);\\n            ans = findMin(slice);\\n        }\\n        return ans;                \\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue lies in the condition where you\\'re checking the middle value of the array. It fails when you\\'re considering an array with only 1 or 2 elements.\\n\\n```cpp\\nif(nums[mid]<nums[mid+1] && nums[mid]<nums[mid-1]){\\n    return nums[mid];\\n}\\n```\\n\\nIn the above condition, you\\'re accessing `mid+1` and `mid-1`, which may not be valid indices if the size of `nums` is 1 or 2.\\n\\nInstead, you should only perform this check when the size of `nums` is larger than 2:\\n\\n```cpp\\nif(n > 2 && nums[mid] < nums[mid + 1] && nums[mid] < nums[mid - 1]) {\\n    return nums[mid];\\n}\\n```\\n\\nIn addition, the way you\\'re slicing the array seems incorrect:\\n\\n```cpp\\nvector slice(nums.begin(), nums.end()-mid);\\n```\\n\\nIn the above line, you\\'re trying to construct `slice` from the beginning of `nums` to `mid` elements before the end of `nums`. This would give you more than half of the array when you\\'re supposed to get the first half. You likely intended to do:\\n\\n```cpp\\nvector slice(nums.begin(), nums.begin() + mid);\\n```\\n\\nThe correct code would be:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n = nums.size();\\n        int ans = 0;\\n        if(nums[0] < nums[n-1]) {\\n            return nums[0];\\n        }\\n        int mid = n / 2;\\n        if(n > 2 && nums[mid] < nums[mid + 1] && nums[mid] < nums[mid - 1]) {\\n            return nums[mid];\\n        }\\n        if(nums[mid] > nums[0]) {\\n            vector<int> slice(nums.begin() + mid, nums.end());\\n            ans = findMin(slice);\\n        }\\n        else {\\n            vector<int> slice(nums.begin(), nums.begin() + mid);\\n            ans = findMin(slice);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nThis version of the code avoids the runtime error by ensuring that the indices used to access elements in `nums` are always within bounds and correctly slicing the array. Note that this code is not the most efficient solution to the problem and it\\'s for demonstration purpose. The most efficient solution would be the binary search approach."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "applegeek519",
                        "content": "Simple JAVA solution ( 0 ms beats 100%)\\n\\n  public int findMin(int[] nums) {\\n        if(nums.length==1){\\n            return nums[0];\\n        }\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            if (nums[i] < nums[i+1] && nums[i] < nums[nums.length - 1]) {\\n                return nums[i];\\n            }\\n        }\\n        return nums[nums.length-1];\\n    }"
                    },
                    {
                        "username": "kaushik89ankit",
                        "content": "I just feel that in the end , nums[middle] should be compared with nums[start] and not nums[0]. Also , in case nums[middle] < nums[start] we should search between start and middle not middle-1"
                    }
                ]
            },
            {
                "id": 1746042,
                "content": [
                    {
                        "username": "ashutoshbhardwaj25122000",
                        "content": "Let's say array before sorting is:\na0, a1, ......., a(n-1)\n\nArray after rotation:\na(n-k), a(n-k+1), ......, a(n-1), a0, a1, ...., a(n-k+1)\n\nNo many how many times array is rotated, a0 will always remain the minimum element. So, idea here is to divide the array into two halves, if the first half is in increasing order, then it means that a0 lies in the second half, otherwise in the first half.\n\nNote that question can be re-written as finding the minimum index."
                    },
                    {
                        "username": "QASIM29",
                        "content": "O(N) for len() function isn\\'t that the case in every solution?\\n"
                    },
                    {
                        "username": "beijaflor",
                        "content": "Depends on the underlying data type.  In Python, the length of the builtin \"list\" type is stored as a pre-calculated field in the underlying struct along, thus yielding O(1) time complexity for `len(my_list)` lookups.\\n\\nhttps://wiki.python.org/moin/TimeComplexity "
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n    \\n       return *min_element(nums.begin(),nums.end());\\n        \\n        \\n        }\\n};"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    int findMin(vector<int>&nums){\\n\\n    int n  = nums.size();\\n\\n    if(nums[0] <=nums[n-1]){\\n        return nums[0];\\n    }\\n\\n    int s =0,e=n-1; \\n     while(s<=e){\\n\\n         int mid = (s+e)/2;\\n\\n         if(mid -1 >=0 && nums[mid] < nums[mid-1]){\\n             return nums[mid];\\n         }\\n         else if(nums[mid] > nums[n-1])\\n         {\\n             s  = mid+1;\\n         }\\n         else{\\n             e = mid -1;\\n         }\\n     }\\n     return INT_MIN;\\n}\\n};\\n"
                    },
                    {
                        "username": "Yash_Agrawal2117",
                        "content": "Try to solve via While loop and Condition method"
                    },
                    {
                        "username": "Muskan003_NITA",
                        "content": "class Solution {\\npublic:\\n     int findMin(vector<int>& nums) {\\n        int s=0; int e=nums.size()-1; int m;\\n       //array already sorted hai usme change hi nhi hua toh minumum toh first index hoga n;\\n       if(nums[s]<=nums[e]){\\n          return nums[0];\\n       }\\n        while(s<e)\\n        {\\n           int m=s+(e-s)/2;\\n         if(nums[m]<nums[m-1]) {\\n             return nums[m];\\n         }\\n         else if(nums[m]>nums[m+1]){\\n             return nums[m+1];\\n         }\\n         else if (nums[s]<=nums[m]){\\n             s= m+1;\\n         }\\n         else if(nums[e]>=nums[m]){\\n             e=m-1;\\n         }\\n        \\n        \\n        }  \\n         return nums[s];\\n    }\\n};\\n\\n// why i am getting run time error  \\n//all test case passes but shows run time error"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error is likely due to accessing an out-of-bounds index in the array `nums` at these lines:\\n\\n```cpp\\nif(nums[m]<nums[m-1]) {\\n    return nums[m];\\n}\\nelse if(nums[m]>nums[m+1]){\\n    return nums[m+1];\\n}\\n```\\n\\nAt the beginning of the loop, when `m` is at 0 (which is the starting point), `m-1` will be -1. Similarly, at the end of the loop when `m` is at the last index, `m+1` will be out of bounds.\\n\\nTo fix these errors, you should modify your code to only check `nums[m]` against `nums[m-1]` and `nums[m+1]` if `m-1` and `m+1` are valid indices, respectively. Here\\'s how you can do it:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int s=0; \\n        int e=nums.size()-1;\\n        \\n        // If array is already sorted, return the first element\\n        if(nums[s] <= nums[e]){\\n            return nums[0];\\n        }\\n        \\n        while(s < e)\\n        {\\n            int m = s + (e - s) / 2;\\n            \\n            // Check if nums[m] is smaller than its predecessor\\n            if(m > 0 && nums[m] < nums[m-1]) {\\n                return nums[m];\\n            }\\n            // Check if nums[m] is greater than its successor\\n            else if(m < nums.size() - 1 && nums[m] > nums[m+1]){\\n                return nums[m+1];\\n            }\\n            else if (nums[s] <= nums[m]){\\n                s = m + 1;\\n            }\\n            else if(nums[e] >= nums[m]){\\n                e = m - 1;\\n            }\\n        }\\n        \\n        return nums[s];\\n    }\\n};\\n```\\n\\nThis version of the code avoids the runtime errors by ensuring that the indices used to access the elements in `nums` are always within bounds."
                    },
                    {
                        "username": "heliShah14",
                        "content": "Getting runtime error:\\n\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n=nums.size();\\n        int ans=0;\\n        if(nums[0]<nums[n-1]){\\n            return nums[0];\\n        }\\n        int mid=n/2;\\n        if(nums[mid]<nums[mid+1] && nums[mid]<nums[mid-1]){\\n            return nums[mid];\\n        }        \\n        if(nums[mid]>nums[0]){\\n            vector<int> slice(nums.begin()+mid, nums.end());\\n            ans=findMin(slice);\\n        }\\n        else{\\n            vector<int> slice(nums.begin(), nums.end()-mid);\\n            ans = findMin(slice);\\n        }\\n        return ans;                \\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "The issue lies in the condition where you\\'re checking the middle value of the array. It fails when you\\'re considering an array with only 1 or 2 elements.\\n\\n```cpp\\nif(nums[mid]<nums[mid+1] && nums[mid]<nums[mid-1]){\\n    return nums[mid];\\n}\\n```\\n\\nIn the above condition, you\\'re accessing `mid+1` and `mid-1`, which may not be valid indices if the size of `nums` is 1 or 2.\\n\\nInstead, you should only perform this check when the size of `nums` is larger than 2:\\n\\n```cpp\\nif(n > 2 && nums[mid] < nums[mid + 1] && nums[mid] < nums[mid - 1]) {\\n    return nums[mid];\\n}\\n```\\n\\nIn addition, the way you\\'re slicing the array seems incorrect:\\n\\n```cpp\\nvector slice(nums.begin(), nums.end()-mid);\\n```\\n\\nIn the above line, you\\'re trying to construct `slice` from the beginning of `nums` to `mid` elements before the end of `nums`. This would give you more than half of the array when you\\'re supposed to get the first half. You likely intended to do:\\n\\n```cpp\\nvector slice(nums.begin(), nums.begin() + mid);\\n```\\n\\nThe correct code would be:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int n = nums.size();\\n        int ans = 0;\\n        if(nums[0] < nums[n-1]) {\\n            return nums[0];\\n        }\\n        int mid = n / 2;\\n        if(n > 2 && nums[mid] < nums[mid + 1] && nums[mid] < nums[mid - 1]) {\\n            return nums[mid];\\n        }\\n        if(nums[mid] > nums[0]) {\\n            vector<int> slice(nums.begin() + mid, nums.end());\\n            ans = findMin(slice);\\n        }\\n        else {\\n            vector<int> slice(nums.begin(), nums.begin() + mid);\\n            ans = findMin(slice);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nThis version of the code avoids the runtime error by ensuring that the indices used to access elements in `nums` are always within bounds and correctly slicing the array. Note that this code is not the most efficient solution to the problem and it\\'s for demonstration purpose. The most efficient solution would be the binary search approach."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "applegeek519",
                        "content": "Simple JAVA solution ( 0 ms beats 100%)\\n\\n  public int findMin(int[] nums) {\\n        if(nums.length==1){\\n            return nums[0];\\n        }\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            if (nums[i] < nums[i+1] && nums[i] < nums[nums.length - 1]) {\\n                return nums[i];\\n            }\\n        }\\n        return nums[nums.length-1];\\n    }"
                    },
                    {
                        "username": "kaushik89ankit",
                        "content": "I just feel that in the end , nums[middle] should be compared with nums[start] and not nums[0]. Also , in case nums[middle] < nums[start] we should search between start and middle not middle-1"
                    }
                ]
            },
            {
                "id": 1734680,
                "content": [
                    {
                        "username": "vjamdade1998",
                        "content": "class Solution {\\n    public int findMin(int[] arr) {\\n        // Arrays.sort(nums);\\n        // return nums[0];\\n        int i=0;\\n        if(arr[i]<=arr[arr.length-1])\\n            return arr[0];\\n        while(arr[i]<arr[i+1] && i+1<arr.length)\\n        {\\n            i++;\\n        }\\n        return arr[i+1];\\n\\n    }\\n    \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "pegasus991",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        l=len(nums)\\n        start=0\\n        end=l-1\\n        if(l==1):\\n            return nums[0]\\n        if(l==2):\\n            if(nums[0]<nums[1]):\\n                return nums[0]\\n            else:\\n                return nums[1]\\n        while(start<=end):\\n            mid=start+(end-start)//2\\n            prev=(mid+l-1)%l\\n            nex=(mid+1)%l\\n            if(nums[mid]<nums[prev] and nums[mid]<nums[nex]):\\n                return nums[mid]\\n            elif(nums[mid]<nums[end]):\\n                end=mid-1\\n            elif(nums[mid]>nums[start]):\\n                start=mid+1 \\n\\ncan anyone tell what is wrong with this code ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach seems almost correct, but there\\'s a little confusion in the else if conditions. In a sorted and rotated array, the pivot (the point of rotation, i.e., the minimum element) is the only point where the next number is less than the current. \\n\\nThe elements to the right of the pivot are smaller than the elements to the left of the pivot. Therefore, we have two sorted subarrays and we need to decide which part to discard depending upon the mid element. Here\\'s the correct code:\\n\\n```python\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        if len(nums) == 1:\\n            return nums[0]\\n        left = 0\\n        right = len(nums) - 1\\n        if nums[right] > nums[0]:  # no rotation\\n            return nums[0]\\n        while right >= left:\\n            mid = left + (right - left) // 2\\n            if nums[mid] > nums[mid + 1]:  # point of change is the smallest element\\n                return nums[mid + 1]\\n            if nums[mid - 1] > nums[mid]:  # point of change is the smallest element\\n                return nums[mid]\\n            if nums[mid] > nums[0]:  # left side is sorted so the pivot is on right side\\n                left = mid + 1\\n            else:  # right side is sorted so the pivot is on the left side\\n                right = mid - 1\\n```\\n\\nThis solution works in O(log n) time as it discards one of the halves in each step, and it uses O(1) space."
                    },
                    {
                        "username": "musharrafalam9888",
                        "content": "class Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int res;\\n        int l = 0; \\n        int r = (nums.size())-1;\\n        while(l<=r){\\n            if(nums[l]<nums[r]){\\n                res = min(res, nums[l]);\\n            }\\n            int m = l + (r - l)/2;        \\n            res = min(res, nums[l]);\\n            if(nums[m]>=nums[l]){\\n                l = m + 1;\\n            }\\n            else{\\n                r = m - 1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n1 test case is showing error [3, 1, 2]"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach is almost correct, but it seems you made a mistake in the line:\\n\\n```cpp\\nres = min(res, nums[l]);\\n```\\n\\nThis should be:\\n\\n```cpp\\nres = min(res, nums[m]);\\n```\\n\\nThe correct code will look like this:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int res = nums[0];\\n        int l = 0;\\n        int r = nums.size() - 1;\\n        while (l <= r) {\\n            int m = l + (r - l) / 2;\\n            res = min(res, nums[m]);\\n            if (nums[m] >= nums[l]) {\\n                l = m + 1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nThe reason for this is that you are trying to find the minimum element, and you should compare and update the current minimum value with the middle element `nums[m]`, not the left boundary `nums[l]`."
                    },
                    {
                        "username": "Srijan555",
                        "content": "class Solution {\\n    public int findMin(int[] nums) {\\n        int size=nums.length;\\n        int s=0,e=size-1;\\n        while(s<=e){\\n            \\n            int m=s+(e-s)/2;\\n            if(nums[m]<=nums[m-1] && nums[m]<=nums[m+1] && size>2){\\n                //System.out.println(\"Middle element is \"+nums[m]);\\n                return nums[m];\\n            }\\n            else{\\n                System.out.println(\"inside else\"+nums[s]+\",\"+nums[m]+\",\"+nums[e]);\\n                if(nums[m+1]<nums[m-1]){\\n                    s=m+1;\\n                }else if(nums[m+1]>nums[m-1]){\\n                    e=m-1;\\n                }\\n            }\\n        }\\n        return nums[0];\\n    }\\n}\\n\\n\\nGETTING BELOW ERROR:\\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 4\\n  at line 8, Solution.findMin\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your issue arises from accessing array indices without verifying if they are valid. In particular, these two lines are problematic: \\n\\n```java\\nif(nums[m]<=nums[m-1] && nums[m]<=nums[m+1] && size>2){\\n```\\n\\nand\\n\\n```java\\nif(nums[m+1]<nums[m-1]){\\n```\\n\\nIn both lines, you\\'re accessing `m-1` and `m+1` without checking whether `m-1` is >=0 and `m+1` is < `size`. When `m` is 0 or `size-1`, these conditions will lead to the `ArrayIndexOutOfBoundsException`.\\n\\nHere is the corrected version of your code:\\n\\n```java\\npublic class Solution {\\n    public int findMin(int[] nums) {\\n        int size=nums.length;\\n        int s=0,e=size-1;\\n        while(s<e){\\n            int m=s+(e-s)/2;\\n            if(nums[m] > nums[e]){\\n                s = m+1;\\n            }else {\\n                e = m;\\n            }\\n        }\\n        return nums[s];\\n    }\\n}\\n```\\nThis is a simpler and safer implementation using binary search that avoids problematic index access. The code always compares the middle element with the end element and moves the search range accordingly, which guarantees that the search range will shrink and eventually reach the minimum element."
                    },
                    {
                        "username": "Adarsh5101",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...`\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        if(nums[0] <= nums[nums.length-1]){\\n            return nums[0];\\n        }\\n        int left = 0,right = nums.length-1;\\n        while(left <= right){\\n            int mid =  left +(right - left)/2;\\n            if(mid-1 >= 0 && nums[mid] < nums[mid-1] ){\\n                return nums[mid];\\n            }else if(nums[mid] > nums[right]){\\n                left = mid+1;\\n            }else{\\n                right = mid-1;\\n            }\\n        }\\n        return nums[left];\\n    }\\n}"
                    },
                    {
                        "username": "Saima_H",
                        "content": "why do we use mid=start+(end-start)/2;?\nand not mid=(start+end)/2;\nbelow is the code in java tht is accepted but im unable to understand the above stmts.\nAlso if we are checking if nums.length==1 return nums[0]\n\nthen why do we use while(start<=end)\ncan anybody clear this doubt.\n\n\nclass Solution {\n    public int findMin(int[] nums) {\n        int n=nums.length;\n         if(n==1) return nums[0];\n        int start = 0, end=n-1;\n        if(nums[0]<nums[end]) return nums[0];\n        \n        while(start<=end)\n        {\n            int mid = start+(end-start)/2;\n            if(nums[mid+1]<nums[mid]) return nums[mid+1];\n            if(nums[mid-1]>nums[mid]) return nums[mid];\n                        \n            if(nums[mid]>nums[0])\n            {\n                start = mid+1;\n            }\n            else end = mid-1;\n        }\n    return -1;\n    }\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "In this case, `mid = start + (end - start) / 2` and `mid = (start + end) / 2` might seem to do the same thing - finding the middle index of a range in an array. However, there is a subtle but important difference that comes into play when working with large numbers.\\n\\nIn some languages, such as Java, C++, and Python, the sum `start + end` might exceed the maximum positive int value (2^31 - 1 for Java and C++). This can result in overflow, causing incorrect calculations or errors. To avoid this issue, we use the formula `start + (end - start) / 2` to find the mid-point without risking overflow.\\n\\nRegarding your second question, the `while (start <= end)` loop is a typical construct when using binary search, which is the technique employed in this problem. Although you return `nums[0]` when `n == 1`, there are other cases where the array length is larger than 1 and the smallest number is at index 0 (like a sorted array without any rotation). The condition `nums[0] < nums[end]` checks if the array is already sorted and simply returns `nums[0]` if that is the case. If the array has been rotated, the binary search is executed to find the minimum."
                    },
                    {
                        "username": "Gaurav_maurya",
                        "content": "we use mid = start + (end-start)/2; because in some cases if you add start + end  it will might get overflow over the range of integer for example 2,147,483,647 + 2,147,483,647 will be 4,29,49,67,294 which is out of limit. the about method will work in this and if you open it .\nIt shows like start + end/2 - start/2  = start/2 +end/2 = ( start+ end )/2 this eventually gives you the same output "
                    },
                    {
                        "username": "ankit_049",
                        "content": "when you find solution in o(logn) then use binary search  (hint : find pivot)\nbut one is easy answer on o(n) is sort vector and return first index element \n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "If you want an O(n) solution you don\\'t need to sort the input. You can just do linear search."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "BEST OPTIMIZED SOLUTION FOR search in rotated sorted array | O(log n) solution | java program |\nclass Solution {\n    public int findMin(int[] nums) {\n        int min = min(nums);\n        return nums[min];\n    }\n    public static int min(int[] nums){\n        int start = 0;\n        int end = nums.length - 1;\n        while(start < end){\n            int mid = start + (end - start) / 2;\n            if(mid > 0 && nums[mid - 1] > nums[mid]){\n                return mid;\n            }\n            else if(nums[start] <= nums[mid] && nums[mid] > nums[end]){\n                start = mid + 1;\n            }\n            else{\n                end = mid - 1;\n            }\n        }\n        return start;\n    }\n}"
                    },
                    {
                        "username": "proGeekCoder",
                        "content": "Hey Guys, \n\nI have used the below approach and stuck. Can someone point, where am I going wrong?\n\nI feel confused!\n\n```\nclass Solution:\n    def findMin(self, nums: List[int]) -> int:\n        low, high = 0, len(nums) - 1\n\n        while low < high:\n            mid = low + (high - low) // 2\n\n            if nums[low] < nums[mid]:\n                # the left part of the array is sorted\n                low = mid\n            else:\n                if nums[mid] < nums[high]:\n                    # right part of the array is sorted but left part of the array is not sorted\n                    high = mid\n                # else:\n                    # left and right part of the array is not sorted. \n                    # I don't understand what to do here! if both parts of the array is not sorted, how will I reduce the search space?\n                    \n        return nums[low]\n\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach is good and is aligned with the binary search solution for this problem, but you seem to have some misconceptions. \\n\\nIn a rotated sorted array, one half of the array is always sorted. If the array isn\\'t sorted, that means it has been rotated and the minimum element is somewhere in the unsorted part.\\n\\nLet\\'s correct your approach:\\n\\n1. Find the mid element.\\n2. If the mid element is greater than the high element, then the minimum element lies in the right half. So, set `low = mid + 1`.\\n3. Else, the minimum element lies in the left half, so set `high = mid`.\\n\\nThe termination condition for the while loop should be `low < high`, not `low <= high`. When `low == high`, that\\'s when you have found the smallest element.\\n\\nHere\\'s the corrected code:\\n\\n```python\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        low, high = 0, len(nums) - 1\\n\\n        while low < high:\\n            mid = low + (high - low) // 2\\n\\n            if nums[mid] > nums[high]:\\n                low = mid + 1\\n            else:\\n                high = mid\\n\\n        return nums[low]\\n```\\nThis code works because in a rotated sorted array, if you split it into two halves, then one must be sorted and one must be a rotated sorted array. The minimum element is either the first element of the sorted half (if there are no rotations), or it lies within the rotated sorted half. By comparing the middle element and the last element, you can tell which half is sorted and which half is rotated. If the middle element is greater than the last element, then the left half is sorted and the right half is a rotated sorted array. If the middle element is less than the last element, then the right half is sorted and the left half is a rotated sorted array. In either case, you can adjust your search boundary (`low` or `high`) accordingly. You repeat this process until your search boundary contains only one element, which is the smallest element in the array."
                    }
                ]
            },
            {
                "id": 1733546,
                "content": [
                    {
                        "username": "vjamdade1998",
                        "content": "class Solution {\\n    public int findMin(int[] arr) {\\n        // Arrays.sort(nums);\\n        // return nums[0];\\n        int i=0;\\n        if(arr[i]<=arr[arr.length-1])\\n            return arr[0];\\n        while(arr[i]<arr[i+1] && i+1<arr.length)\\n        {\\n            i++;\\n        }\\n        return arr[i+1];\\n\\n    }\\n    \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "pegasus991",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        l=len(nums)\\n        start=0\\n        end=l-1\\n        if(l==1):\\n            return nums[0]\\n        if(l==2):\\n            if(nums[0]<nums[1]):\\n                return nums[0]\\n            else:\\n                return nums[1]\\n        while(start<=end):\\n            mid=start+(end-start)//2\\n            prev=(mid+l-1)%l\\n            nex=(mid+1)%l\\n            if(nums[mid]<nums[prev] and nums[mid]<nums[nex]):\\n                return nums[mid]\\n            elif(nums[mid]<nums[end]):\\n                end=mid-1\\n            elif(nums[mid]>nums[start]):\\n                start=mid+1 \\n\\ncan anyone tell what is wrong with this code ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach seems almost correct, but there\\'s a little confusion in the else if conditions. In a sorted and rotated array, the pivot (the point of rotation, i.e., the minimum element) is the only point where the next number is less than the current. \\n\\nThe elements to the right of the pivot are smaller than the elements to the left of the pivot. Therefore, we have two sorted subarrays and we need to decide which part to discard depending upon the mid element. Here\\'s the correct code:\\n\\n```python\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        if len(nums) == 1:\\n            return nums[0]\\n        left = 0\\n        right = len(nums) - 1\\n        if nums[right] > nums[0]:  # no rotation\\n            return nums[0]\\n        while right >= left:\\n            mid = left + (right - left) // 2\\n            if nums[mid] > nums[mid + 1]:  # point of change is the smallest element\\n                return nums[mid + 1]\\n            if nums[mid - 1] > nums[mid]:  # point of change is the smallest element\\n                return nums[mid]\\n            if nums[mid] > nums[0]:  # left side is sorted so the pivot is on right side\\n                left = mid + 1\\n            else:  # right side is sorted so the pivot is on the left side\\n                right = mid - 1\\n```\\n\\nThis solution works in O(log n) time as it discards one of the halves in each step, and it uses O(1) space."
                    },
                    {
                        "username": "musharrafalam9888",
                        "content": "class Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int res;\\n        int l = 0; \\n        int r = (nums.size())-1;\\n        while(l<=r){\\n            if(nums[l]<nums[r]){\\n                res = min(res, nums[l]);\\n            }\\n            int m = l + (r - l)/2;        \\n            res = min(res, nums[l]);\\n            if(nums[m]>=nums[l]){\\n                l = m + 1;\\n            }\\n            else{\\n                r = m - 1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n1 test case is showing error [3, 1, 2]"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach is almost correct, but it seems you made a mistake in the line:\\n\\n```cpp\\nres = min(res, nums[l]);\\n```\\n\\nThis should be:\\n\\n```cpp\\nres = min(res, nums[m]);\\n```\\n\\nThe correct code will look like this:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int res = nums[0];\\n        int l = 0;\\n        int r = nums.size() - 1;\\n        while (l <= r) {\\n            int m = l + (r - l) / 2;\\n            res = min(res, nums[m]);\\n            if (nums[m] >= nums[l]) {\\n                l = m + 1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nThe reason for this is that you are trying to find the minimum element, and you should compare and update the current minimum value with the middle element `nums[m]`, not the left boundary `nums[l]`."
                    },
                    {
                        "username": "Srijan555",
                        "content": "class Solution {\\n    public int findMin(int[] nums) {\\n        int size=nums.length;\\n        int s=0,e=size-1;\\n        while(s<=e){\\n            \\n            int m=s+(e-s)/2;\\n            if(nums[m]<=nums[m-1] && nums[m]<=nums[m+1] && size>2){\\n                //System.out.println(\"Middle element is \"+nums[m]);\\n                return nums[m];\\n            }\\n            else{\\n                System.out.println(\"inside else\"+nums[s]+\",\"+nums[m]+\",\"+nums[e]);\\n                if(nums[m+1]<nums[m-1]){\\n                    s=m+1;\\n                }else if(nums[m+1]>nums[m-1]){\\n                    e=m-1;\\n                }\\n            }\\n        }\\n        return nums[0];\\n    }\\n}\\n\\n\\nGETTING BELOW ERROR:\\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 4\\n  at line 8, Solution.findMin\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your issue arises from accessing array indices without verifying if they are valid. In particular, these two lines are problematic: \\n\\n```java\\nif(nums[m]<=nums[m-1] && nums[m]<=nums[m+1] && size>2){\\n```\\n\\nand\\n\\n```java\\nif(nums[m+1]<nums[m-1]){\\n```\\n\\nIn both lines, you\\'re accessing `m-1` and `m+1` without checking whether `m-1` is >=0 and `m+1` is < `size`. When `m` is 0 or `size-1`, these conditions will lead to the `ArrayIndexOutOfBoundsException`.\\n\\nHere is the corrected version of your code:\\n\\n```java\\npublic class Solution {\\n    public int findMin(int[] nums) {\\n        int size=nums.length;\\n        int s=0,e=size-1;\\n        while(s<e){\\n            int m=s+(e-s)/2;\\n            if(nums[m] > nums[e]){\\n                s = m+1;\\n            }else {\\n                e = m;\\n            }\\n        }\\n        return nums[s];\\n    }\\n}\\n```\\nThis is a simpler and safer implementation using binary search that avoids problematic index access. The code always compares the middle element with the end element and moves the search range accordingly, which guarantees that the search range will shrink and eventually reach the minimum element."
                    },
                    {
                        "username": "Adarsh5101",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...`\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        if(nums[0] <= nums[nums.length-1]){\\n            return nums[0];\\n        }\\n        int left = 0,right = nums.length-1;\\n        while(left <= right){\\n            int mid =  left +(right - left)/2;\\n            if(mid-1 >= 0 && nums[mid] < nums[mid-1] ){\\n                return nums[mid];\\n            }else if(nums[mid] > nums[right]){\\n                left = mid+1;\\n            }else{\\n                right = mid-1;\\n            }\\n        }\\n        return nums[left];\\n    }\\n}"
                    },
                    {
                        "username": "Saima_H",
                        "content": "why do we use mid=start+(end-start)/2;?\nand not mid=(start+end)/2;\nbelow is the code in java tht is accepted but im unable to understand the above stmts.\nAlso if we are checking if nums.length==1 return nums[0]\n\nthen why do we use while(start<=end)\ncan anybody clear this doubt.\n\n\nclass Solution {\n    public int findMin(int[] nums) {\n        int n=nums.length;\n         if(n==1) return nums[0];\n        int start = 0, end=n-1;\n        if(nums[0]<nums[end]) return nums[0];\n        \n        while(start<=end)\n        {\n            int mid = start+(end-start)/2;\n            if(nums[mid+1]<nums[mid]) return nums[mid+1];\n            if(nums[mid-1]>nums[mid]) return nums[mid];\n                        \n            if(nums[mid]>nums[0])\n            {\n                start = mid+1;\n            }\n            else end = mid-1;\n        }\n    return -1;\n    }\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "In this case, `mid = start + (end - start) / 2` and `mid = (start + end) / 2` might seem to do the same thing - finding the middle index of a range in an array. However, there is a subtle but important difference that comes into play when working with large numbers.\\n\\nIn some languages, such as Java, C++, and Python, the sum `start + end` might exceed the maximum positive int value (2^31 - 1 for Java and C++). This can result in overflow, causing incorrect calculations or errors. To avoid this issue, we use the formula `start + (end - start) / 2` to find the mid-point without risking overflow.\\n\\nRegarding your second question, the `while (start <= end)` loop is a typical construct when using binary search, which is the technique employed in this problem. Although you return `nums[0]` when `n == 1`, there are other cases where the array length is larger than 1 and the smallest number is at index 0 (like a sorted array without any rotation). The condition `nums[0] < nums[end]` checks if the array is already sorted and simply returns `nums[0]` if that is the case. If the array has been rotated, the binary search is executed to find the minimum."
                    },
                    {
                        "username": "Gaurav_maurya",
                        "content": "we use mid = start + (end-start)/2; because in some cases if you add start + end  it will might get overflow over the range of integer for example 2,147,483,647 + 2,147,483,647 will be 4,29,49,67,294 which is out of limit. the about method will work in this and if you open it .\nIt shows like start + end/2 - start/2  = start/2 +end/2 = ( start+ end )/2 this eventually gives you the same output "
                    },
                    {
                        "username": "ankit_049",
                        "content": "when you find solution in o(logn) then use binary search  (hint : find pivot)\nbut one is easy answer on o(n) is sort vector and return first index element \n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "If you want an O(n) solution you don\\'t need to sort the input. You can just do linear search."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "BEST OPTIMIZED SOLUTION FOR search in rotated sorted array | O(log n) solution | java program |\nclass Solution {\n    public int findMin(int[] nums) {\n        int min = min(nums);\n        return nums[min];\n    }\n    public static int min(int[] nums){\n        int start = 0;\n        int end = nums.length - 1;\n        while(start < end){\n            int mid = start + (end - start) / 2;\n            if(mid > 0 && nums[mid - 1] > nums[mid]){\n                return mid;\n            }\n            else if(nums[start] <= nums[mid] && nums[mid] > nums[end]){\n                start = mid + 1;\n            }\n            else{\n                end = mid - 1;\n            }\n        }\n        return start;\n    }\n}"
                    },
                    {
                        "username": "proGeekCoder",
                        "content": "Hey Guys, \n\nI have used the below approach and stuck. Can someone point, where am I going wrong?\n\nI feel confused!\n\n```\nclass Solution:\n    def findMin(self, nums: List[int]) -> int:\n        low, high = 0, len(nums) - 1\n\n        while low < high:\n            mid = low + (high - low) // 2\n\n            if nums[low] < nums[mid]:\n                # the left part of the array is sorted\n                low = mid\n            else:\n                if nums[mid] < nums[high]:\n                    # right part of the array is sorted but left part of the array is not sorted\n                    high = mid\n                # else:\n                    # left and right part of the array is not sorted. \n                    # I don't understand what to do here! if both parts of the array is not sorted, how will I reduce the search space?\n                    \n        return nums[low]\n\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach is good and is aligned with the binary search solution for this problem, but you seem to have some misconceptions. \\n\\nIn a rotated sorted array, one half of the array is always sorted. If the array isn\\'t sorted, that means it has been rotated and the minimum element is somewhere in the unsorted part.\\n\\nLet\\'s correct your approach:\\n\\n1. Find the mid element.\\n2. If the mid element is greater than the high element, then the minimum element lies in the right half. So, set `low = mid + 1`.\\n3. Else, the minimum element lies in the left half, so set `high = mid`.\\n\\nThe termination condition for the while loop should be `low < high`, not `low <= high`. When `low == high`, that\\'s when you have found the smallest element.\\n\\nHere\\'s the corrected code:\\n\\n```python\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        low, high = 0, len(nums) - 1\\n\\n        while low < high:\\n            mid = low + (high - low) // 2\\n\\n            if nums[mid] > nums[high]:\\n                low = mid + 1\\n            else:\\n                high = mid\\n\\n        return nums[low]\\n```\\nThis code works because in a rotated sorted array, if you split it into two halves, then one must be sorted and one must be a rotated sorted array. The minimum element is either the first element of the sorted half (if there are no rotations), or it lies within the rotated sorted half. By comparing the middle element and the last element, you can tell which half is sorted and which half is rotated. If the middle element is greater than the last element, then the left half is sorted and the right half is a rotated sorted array. If the middle element is less than the last element, then the right half is sorted and the left half is a rotated sorted array. In either case, you can adjust your search boundary (`low` or `high`) accordingly. You repeat this process until your search boundary contains only one element, which is the smallest element in the array."
                    }
                ]
            },
            {
                "id": 1727775,
                "content": [
                    {
                        "username": "vjamdade1998",
                        "content": "class Solution {\\n    public int findMin(int[] arr) {\\n        // Arrays.sort(nums);\\n        // return nums[0];\\n        int i=0;\\n        if(arr[i]<=arr[arr.length-1])\\n            return arr[0];\\n        while(arr[i]<arr[i+1] && i+1<arr.length)\\n        {\\n            i++;\\n        }\\n        return arr[i+1];\\n\\n    }\\n    \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "pegasus991",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        l=len(nums)\\n        start=0\\n        end=l-1\\n        if(l==1):\\n            return nums[0]\\n        if(l==2):\\n            if(nums[0]<nums[1]):\\n                return nums[0]\\n            else:\\n                return nums[1]\\n        while(start<=end):\\n            mid=start+(end-start)//2\\n            prev=(mid+l-1)%l\\n            nex=(mid+1)%l\\n            if(nums[mid]<nums[prev] and nums[mid]<nums[nex]):\\n                return nums[mid]\\n            elif(nums[mid]<nums[end]):\\n                end=mid-1\\n            elif(nums[mid]>nums[start]):\\n                start=mid+1 \\n\\ncan anyone tell what is wrong with this code ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach seems almost correct, but there\\'s a little confusion in the else if conditions. In a sorted and rotated array, the pivot (the point of rotation, i.e., the minimum element) is the only point where the next number is less than the current. \\n\\nThe elements to the right of the pivot are smaller than the elements to the left of the pivot. Therefore, we have two sorted subarrays and we need to decide which part to discard depending upon the mid element. Here\\'s the correct code:\\n\\n```python\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        if len(nums) == 1:\\n            return nums[0]\\n        left = 0\\n        right = len(nums) - 1\\n        if nums[right] > nums[0]:  # no rotation\\n            return nums[0]\\n        while right >= left:\\n            mid = left + (right - left) // 2\\n            if nums[mid] > nums[mid + 1]:  # point of change is the smallest element\\n                return nums[mid + 1]\\n            if nums[mid - 1] > nums[mid]:  # point of change is the smallest element\\n                return nums[mid]\\n            if nums[mid] > nums[0]:  # left side is sorted so the pivot is on right side\\n                left = mid + 1\\n            else:  # right side is sorted so the pivot is on the left side\\n                right = mid - 1\\n```\\n\\nThis solution works in O(log n) time as it discards one of the halves in each step, and it uses O(1) space."
                    },
                    {
                        "username": "musharrafalam9888",
                        "content": "class Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int res;\\n        int l = 0; \\n        int r = (nums.size())-1;\\n        while(l<=r){\\n            if(nums[l]<nums[r]){\\n                res = min(res, nums[l]);\\n            }\\n            int m = l + (r - l)/2;        \\n            res = min(res, nums[l]);\\n            if(nums[m]>=nums[l]){\\n                l = m + 1;\\n            }\\n            else{\\n                r = m - 1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n1 test case is showing error [3, 1, 2]"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach is almost correct, but it seems you made a mistake in the line:\\n\\n```cpp\\nres = min(res, nums[l]);\\n```\\n\\nThis should be:\\n\\n```cpp\\nres = min(res, nums[m]);\\n```\\n\\nThe correct code will look like this:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int res = nums[0];\\n        int l = 0;\\n        int r = nums.size() - 1;\\n        while (l <= r) {\\n            int m = l + (r - l) / 2;\\n            res = min(res, nums[m]);\\n            if (nums[m] >= nums[l]) {\\n                l = m + 1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nThe reason for this is that you are trying to find the minimum element, and you should compare and update the current minimum value with the middle element `nums[m]`, not the left boundary `nums[l]`."
                    },
                    {
                        "username": "Srijan555",
                        "content": "class Solution {\\n    public int findMin(int[] nums) {\\n        int size=nums.length;\\n        int s=0,e=size-1;\\n        while(s<=e){\\n            \\n            int m=s+(e-s)/2;\\n            if(nums[m]<=nums[m-1] && nums[m]<=nums[m+1] && size>2){\\n                //System.out.println(\"Middle element is \"+nums[m]);\\n                return nums[m];\\n            }\\n            else{\\n                System.out.println(\"inside else\"+nums[s]+\",\"+nums[m]+\",\"+nums[e]);\\n                if(nums[m+1]<nums[m-1]){\\n                    s=m+1;\\n                }else if(nums[m+1]>nums[m-1]){\\n                    e=m-1;\\n                }\\n            }\\n        }\\n        return nums[0];\\n    }\\n}\\n\\n\\nGETTING BELOW ERROR:\\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 4\\n  at line 8, Solution.findMin\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your issue arises from accessing array indices without verifying if they are valid. In particular, these two lines are problematic: \\n\\n```java\\nif(nums[m]<=nums[m-1] && nums[m]<=nums[m+1] && size>2){\\n```\\n\\nand\\n\\n```java\\nif(nums[m+1]<nums[m-1]){\\n```\\n\\nIn both lines, you\\'re accessing `m-1` and `m+1` without checking whether `m-1` is >=0 and `m+1` is < `size`. When `m` is 0 or `size-1`, these conditions will lead to the `ArrayIndexOutOfBoundsException`.\\n\\nHere is the corrected version of your code:\\n\\n```java\\npublic class Solution {\\n    public int findMin(int[] nums) {\\n        int size=nums.length;\\n        int s=0,e=size-1;\\n        while(s<e){\\n            int m=s+(e-s)/2;\\n            if(nums[m] > nums[e]){\\n                s = m+1;\\n            }else {\\n                e = m;\\n            }\\n        }\\n        return nums[s];\\n    }\\n}\\n```\\nThis is a simpler and safer implementation using binary search that avoids problematic index access. The code always compares the middle element with the end element and moves the search range accordingly, which guarantees that the search range will shrink and eventually reach the minimum element."
                    },
                    {
                        "username": "Adarsh5101",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...`\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        if(nums[0] <= nums[nums.length-1]){\\n            return nums[0];\\n        }\\n        int left = 0,right = nums.length-1;\\n        while(left <= right){\\n            int mid =  left +(right - left)/2;\\n            if(mid-1 >= 0 && nums[mid] < nums[mid-1] ){\\n                return nums[mid];\\n            }else if(nums[mid] > nums[right]){\\n                left = mid+1;\\n            }else{\\n                right = mid-1;\\n            }\\n        }\\n        return nums[left];\\n    }\\n}"
                    },
                    {
                        "username": "Saima_H",
                        "content": "why do we use mid=start+(end-start)/2;?\nand not mid=(start+end)/2;\nbelow is the code in java tht is accepted but im unable to understand the above stmts.\nAlso if we are checking if nums.length==1 return nums[0]\n\nthen why do we use while(start<=end)\ncan anybody clear this doubt.\n\n\nclass Solution {\n    public int findMin(int[] nums) {\n        int n=nums.length;\n         if(n==1) return nums[0];\n        int start = 0, end=n-1;\n        if(nums[0]<nums[end]) return nums[0];\n        \n        while(start<=end)\n        {\n            int mid = start+(end-start)/2;\n            if(nums[mid+1]<nums[mid]) return nums[mid+1];\n            if(nums[mid-1]>nums[mid]) return nums[mid];\n                        \n            if(nums[mid]>nums[0])\n            {\n                start = mid+1;\n            }\n            else end = mid-1;\n        }\n    return -1;\n    }\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "In this case, `mid = start + (end - start) / 2` and `mid = (start + end) / 2` might seem to do the same thing - finding the middle index of a range in an array. However, there is a subtle but important difference that comes into play when working with large numbers.\\n\\nIn some languages, such as Java, C++, and Python, the sum `start + end` might exceed the maximum positive int value (2^31 - 1 for Java and C++). This can result in overflow, causing incorrect calculations or errors. To avoid this issue, we use the formula `start + (end - start) / 2` to find the mid-point without risking overflow.\\n\\nRegarding your second question, the `while (start <= end)` loop is a typical construct when using binary search, which is the technique employed in this problem. Although you return `nums[0]` when `n == 1`, there are other cases where the array length is larger than 1 and the smallest number is at index 0 (like a sorted array without any rotation). The condition `nums[0] < nums[end]` checks if the array is already sorted and simply returns `nums[0]` if that is the case. If the array has been rotated, the binary search is executed to find the minimum."
                    },
                    {
                        "username": "Gaurav_maurya",
                        "content": "we use mid = start + (end-start)/2; because in some cases if you add start + end  it will might get overflow over the range of integer for example 2,147,483,647 + 2,147,483,647 will be 4,29,49,67,294 which is out of limit. the about method will work in this and if you open it .\nIt shows like start + end/2 - start/2  = start/2 +end/2 = ( start+ end )/2 this eventually gives you the same output "
                    },
                    {
                        "username": "ankit_049",
                        "content": "when you find solution in o(logn) then use binary search  (hint : find pivot)\nbut one is easy answer on o(n) is sort vector and return first index element \n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "If you want an O(n) solution you don\\'t need to sort the input. You can just do linear search."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "BEST OPTIMIZED SOLUTION FOR search in rotated sorted array | O(log n) solution | java program |\nclass Solution {\n    public int findMin(int[] nums) {\n        int min = min(nums);\n        return nums[min];\n    }\n    public static int min(int[] nums){\n        int start = 0;\n        int end = nums.length - 1;\n        while(start < end){\n            int mid = start + (end - start) / 2;\n            if(mid > 0 && nums[mid - 1] > nums[mid]){\n                return mid;\n            }\n            else if(nums[start] <= nums[mid] && nums[mid] > nums[end]){\n                start = mid + 1;\n            }\n            else{\n                end = mid - 1;\n            }\n        }\n        return start;\n    }\n}"
                    },
                    {
                        "username": "proGeekCoder",
                        "content": "Hey Guys, \n\nI have used the below approach and stuck. Can someone point, where am I going wrong?\n\nI feel confused!\n\n```\nclass Solution:\n    def findMin(self, nums: List[int]) -> int:\n        low, high = 0, len(nums) - 1\n\n        while low < high:\n            mid = low + (high - low) // 2\n\n            if nums[low] < nums[mid]:\n                # the left part of the array is sorted\n                low = mid\n            else:\n                if nums[mid] < nums[high]:\n                    # right part of the array is sorted but left part of the array is not sorted\n                    high = mid\n                # else:\n                    # left and right part of the array is not sorted. \n                    # I don't understand what to do here! if both parts of the array is not sorted, how will I reduce the search space?\n                    \n        return nums[low]\n\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach is good and is aligned with the binary search solution for this problem, but you seem to have some misconceptions. \\n\\nIn a rotated sorted array, one half of the array is always sorted. If the array isn\\'t sorted, that means it has been rotated and the minimum element is somewhere in the unsorted part.\\n\\nLet\\'s correct your approach:\\n\\n1. Find the mid element.\\n2. If the mid element is greater than the high element, then the minimum element lies in the right half. So, set `low = mid + 1`.\\n3. Else, the minimum element lies in the left half, so set `high = mid`.\\n\\nThe termination condition for the while loop should be `low < high`, not `low <= high`. When `low == high`, that\\'s when you have found the smallest element.\\n\\nHere\\'s the corrected code:\\n\\n```python\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        low, high = 0, len(nums) - 1\\n\\n        while low < high:\\n            mid = low + (high - low) // 2\\n\\n            if nums[mid] > nums[high]:\\n                low = mid + 1\\n            else:\\n                high = mid\\n\\n        return nums[low]\\n```\\nThis code works because in a rotated sorted array, if you split it into two halves, then one must be sorted and one must be a rotated sorted array. The minimum element is either the first element of the sorted half (if there are no rotations), or it lies within the rotated sorted half. By comparing the middle element and the last element, you can tell which half is sorted and which half is rotated. If the middle element is greater than the last element, then the left half is sorted and the right half is a rotated sorted array. If the middle element is less than the last element, then the right half is sorted and the left half is a rotated sorted array. In either case, you can adjust your search boundary (`low` or `high`) accordingly. You repeat this process until your search boundary contains only one element, which is the smallest element in the array."
                    }
                ]
            },
            {
                "id": 1722320,
                "content": [
                    {
                        "username": "vjamdade1998",
                        "content": "class Solution {\\n    public int findMin(int[] arr) {\\n        // Arrays.sort(nums);\\n        // return nums[0];\\n        int i=0;\\n        if(arr[i]<=arr[arr.length-1])\\n            return arr[0];\\n        while(arr[i]<arr[i+1] && i+1<arr.length)\\n        {\\n            i++;\\n        }\\n        return arr[i+1];\\n\\n    }\\n    \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "pegasus991",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        l=len(nums)\\n        start=0\\n        end=l-1\\n        if(l==1):\\n            return nums[0]\\n        if(l==2):\\n            if(nums[0]<nums[1]):\\n                return nums[0]\\n            else:\\n                return nums[1]\\n        while(start<=end):\\n            mid=start+(end-start)//2\\n            prev=(mid+l-1)%l\\n            nex=(mid+1)%l\\n            if(nums[mid]<nums[prev] and nums[mid]<nums[nex]):\\n                return nums[mid]\\n            elif(nums[mid]<nums[end]):\\n                end=mid-1\\n            elif(nums[mid]>nums[start]):\\n                start=mid+1 \\n\\ncan anyone tell what is wrong with this code ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach seems almost correct, but there\\'s a little confusion in the else if conditions. In a sorted and rotated array, the pivot (the point of rotation, i.e., the minimum element) is the only point where the next number is less than the current. \\n\\nThe elements to the right of the pivot are smaller than the elements to the left of the pivot. Therefore, we have two sorted subarrays and we need to decide which part to discard depending upon the mid element. Here\\'s the correct code:\\n\\n```python\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        if len(nums) == 1:\\n            return nums[0]\\n        left = 0\\n        right = len(nums) - 1\\n        if nums[right] > nums[0]:  # no rotation\\n            return nums[0]\\n        while right >= left:\\n            mid = left + (right - left) // 2\\n            if nums[mid] > nums[mid + 1]:  # point of change is the smallest element\\n                return nums[mid + 1]\\n            if nums[mid - 1] > nums[mid]:  # point of change is the smallest element\\n                return nums[mid]\\n            if nums[mid] > nums[0]:  # left side is sorted so the pivot is on right side\\n                left = mid + 1\\n            else:  # right side is sorted so the pivot is on the left side\\n                right = mid - 1\\n```\\n\\nThis solution works in O(log n) time as it discards one of the halves in each step, and it uses O(1) space."
                    },
                    {
                        "username": "musharrafalam9888",
                        "content": "class Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int res;\\n        int l = 0; \\n        int r = (nums.size())-1;\\n        while(l<=r){\\n            if(nums[l]<nums[r]){\\n                res = min(res, nums[l]);\\n            }\\n            int m = l + (r - l)/2;        \\n            res = min(res, nums[l]);\\n            if(nums[m]>=nums[l]){\\n                l = m + 1;\\n            }\\n            else{\\n                r = m - 1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n1 test case is showing error [3, 1, 2]"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach is almost correct, but it seems you made a mistake in the line:\\n\\n```cpp\\nres = min(res, nums[l]);\\n```\\n\\nThis should be:\\n\\n```cpp\\nres = min(res, nums[m]);\\n```\\n\\nThe correct code will look like this:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int res = nums[0];\\n        int l = 0;\\n        int r = nums.size() - 1;\\n        while (l <= r) {\\n            int m = l + (r - l) / 2;\\n            res = min(res, nums[m]);\\n            if (nums[m] >= nums[l]) {\\n                l = m + 1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nThe reason for this is that you are trying to find the minimum element, and you should compare and update the current minimum value with the middle element `nums[m]`, not the left boundary `nums[l]`."
                    },
                    {
                        "username": "Srijan555",
                        "content": "class Solution {\\n    public int findMin(int[] nums) {\\n        int size=nums.length;\\n        int s=0,e=size-1;\\n        while(s<=e){\\n            \\n            int m=s+(e-s)/2;\\n            if(nums[m]<=nums[m-1] && nums[m]<=nums[m+1] && size>2){\\n                //System.out.println(\"Middle element is \"+nums[m]);\\n                return nums[m];\\n            }\\n            else{\\n                System.out.println(\"inside else\"+nums[s]+\",\"+nums[m]+\",\"+nums[e]);\\n                if(nums[m+1]<nums[m-1]){\\n                    s=m+1;\\n                }else if(nums[m+1]>nums[m-1]){\\n                    e=m-1;\\n                }\\n            }\\n        }\\n        return nums[0];\\n    }\\n}\\n\\n\\nGETTING BELOW ERROR:\\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 4\\n  at line 8, Solution.findMin\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your issue arises from accessing array indices without verifying if they are valid. In particular, these two lines are problematic: \\n\\n```java\\nif(nums[m]<=nums[m-1] && nums[m]<=nums[m+1] && size>2){\\n```\\n\\nand\\n\\n```java\\nif(nums[m+1]<nums[m-1]){\\n```\\n\\nIn both lines, you\\'re accessing `m-1` and `m+1` without checking whether `m-1` is >=0 and `m+1` is < `size`. When `m` is 0 or `size-1`, these conditions will lead to the `ArrayIndexOutOfBoundsException`.\\n\\nHere is the corrected version of your code:\\n\\n```java\\npublic class Solution {\\n    public int findMin(int[] nums) {\\n        int size=nums.length;\\n        int s=0,e=size-1;\\n        while(s<e){\\n            int m=s+(e-s)/2;\\n            if(nums[m] > nums[e]){\\n                s = m+1;\\n            }else {\\n                e = m;\\n            }\\n        }\\n        return nums[s];\\n    }\\n}\\n```\\nThis is a simpler and safer implementation using binary search that avoids problematic index access. The code always compares the middle element with the end element and moves the search range accordingly, which guarantees that the search range will shrink and eventually reach the minimum element."
                    },
                    {
                        "username": "Adarsh5101",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...`\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        if(nums[0] <= nums[nums.length-1]){\\n            return nums[0];\\n        }\\n        int left = 0,right = nums.length-1;\\n        while(left <= right){\\n            int mid =  left +(right - left)/2;\\n            if(mid-1 >= 0 && nums[mid] < nums[mid-1] ){\\n                return nums[mid];\\n            }else if(nums[mid] > nums[right]){\\n                left = mid+1;\\n            }else{\\n                right = mid-1;\\n            }\\n        }\\n        return nums[left];\\n    }\\n}"
                    },
                    {
                        "username": "Saima_H",
                        "content": "why do we use mid=start+(end-start)/2;?\nand not mid=(start+end)/2;\nbelow is the code in java tht is accepted but im unable to understand the above stmts.\nAlso if we are checking if nums.length==1 return nums[0]\n\nthen why do we use while(start<=end)\ncan anybody clear this doubt.\n\n\nclass Solution {\n    public int findMin(int[] nums) {\n        int n=nums.length;\n         if(n==1) return nums[0];\n        int start = 0, end=n-1;\n        if(nums[0]<nums[end]) return nums[0];\n        \n        while(start<=end)\n        {\n            int mid = start+(end-start)/2;\n            if(nums[mid+1]<nums[mid]) return nums[mid+1];\n            if(nums[mid-1]>nums[mid]) return nums[mid];\n                        \n            if(nums[mid]>nums[0])\n            {\n                start = mid+1;\n            }\n            else end = mid-1;\n        }\n    return -1;\n    }\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "In this case, `mid = start + (end - start) / 2` and `mid = (start + end) / 2` might seem to do the same thing - finding the middle index of a range in an array. However, there is a subtle but important difference that comes into play when working with large numbers.\\n\\nIn some languages, such as Java, C++, and Python, the sum `start + end` might exceed the maximum positive int value (2^31 - 1 for Java and C++). This can result in overflow, causing incorrect calculations or errors. To avoid this issue, we use the formula `start + (end - start) / 2` to find the mid-point without risking overflow.\\n\\nRegarding your second question, the `while (start <= end)` loop is a typical construct when using binary search, which is the technique employed in this problem. Although you return `nums[0]` when `n == 1`, there are other cases where the array length is larger than 1 and the smallest number is at index 0 (like a sorted array without any rotation). The condition `nums[0] < nums[end]` checks if the array is already sorted and simply returns `nums[0]` if that is the case. If the array has been rotated, the binary search is executed to find the minimum."
                    },
                    {
                        "username": "Gaurav_maurya",
                        "content": "we use mid = start + (end-start)/2; because in some cases if you add start + end  it will might get overflow over the range of integer for example 2,147,483,647 + 2,147,483,647 will be 4,29,49,67,294 which is out of limit. the about method will work in this and if you open it .\nIt shows like start + end/2 - start/2  = start/2 +end/2 = ( start+ end )/2 this eventually gives you the same output "
                    },
                    {
                        "username": "ankit_049",
                        "content": "when you find solution in o(logn) then use binary search  (hint : find pivot)\nbut one is easy answer on o(n) is sort vector and return first index element \n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "If you want an O(n) solution you don\\'t need to sort the input. You can just do linear search."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "BEST OPTIMIZED SOLUTION FOR search in rotated sorted array | O(log n) solution | java program |\nclass Solution {\n    public int findMin(int[] nums) {\n        int min = min(nums);\n        return nums[min];\n    }\n    public static int min(int[] nums){\n        int start = 0;\n        int end = nums.length - 1;\n        while(start < end){\n            int mid = start + (end - start) / 2;\n            if(mid > 0 && nums[mid - 1] > nums[mid]){\n                return mid;\n            }\n            else if(nums[start] <= nums[mid] && nums[mid] > nums[end]){\n                start = mid + 1;\n            }\n            else{\n                end = mid - 1;\n            }\n        }\n        return start;\n    }\n}"
                    },
                    {
                        "username": "proGeekCoder",
                        "content": "Hey Guys, \n\nI have used the below approach and stuck. Can someone point, where am I going wrong?\n\nI feel confused!\n\n```\nclass Solution:\n    def findMin(self, nums: List[int]) -> int:\n        low, high = 0, len(nums) - 1\n\n        while low < high:\n            mid = low + (high - low) // 2\n\n            if nums[low] < nums[mid]:\n                # the left part of the array is sorted\n                low = mid\n            else:\n                if nums[mid] < nums[high]:\n                    # right part of the array is sorted but left part of the array is not sorted\n                    high = mid\n                # else:\n                    # left and right part of the array is not sorted. \n                    # I don't understand what to do here! if both parts of the array is not sorted, how will I reduce the search space?\n                    \n        return nums[low]\n\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach is good and is aligned with the binary search solution for this problem, but you seem to have some misconceptions. \\n\\nIn a rotated sorted array, one half of the array is always sorted. If the array isn\\'t sorted, that means it has been rotated and the minimum element is somewhere in the unsorted part.\\n\\nLet\\'s correct your approach:\\n\\n1. Find the mid element.\\n2. If the mid element is greater than the high element, then the minimum element lies in the right half. So, set `low = mid + 1`.\\n3. Else, the minimum element lies in the left half, so set `high = mid`.\\n\\nThe termination condition for the while loop should be `low < high`, not `low <= high`. When `low == high`, that\\'s when you have found the smallest element.\\n\\nHere\\'s the corrected code:\\n\\n```python\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        low, high = 0, len(nums) - 1\\n\\n        while low < high:\\n            mid = low + (high - low) // 2\\n\\n            if nums[mid] > nums[high]:\\n                low = mid + 1\\n            else:\\n                high = mid\\n\\n        return nums[low]\\n```\\nThis code works because in a rotated sorted array, if you split it into two halves, then one must be sorted and one must be a rotated sorted array. The minimum element is either the first element of the sorted half (if there are no rotations), or it lies within the rotated sorted half. By comparing the middle element and the last element, you can tell which half is sorted and which half is rotated. If the middle element is greater than the last element, then the left half is sorted and the right half is a rotated sorted array. If the middle element is less than the last element, then the right half is sorted and the left half is a rotated sorted array. In either case, you can adjust your search boundary (`low` or `high`) accordingly. You repeat this process until your search boundary contains only one element, which is the smallest element in the array."
                    }
                ]
            },
            {
                "id": 1718549,
                "content": [
                    {
                        "username": "vjamdade1998",
                        "content": "class Solution {\\n    public int findMin(int[] arr) {\\n        // Arrays.sort(nums);\\n        // return nums[0];\\n        int i=0;\\n        if(arr[i]<=arr[arr.length-1])\\n            return arr[0];\\n        while(arr[i]<arr[i+1] && i+1<arr.length)\\n        {\\n            i++;\\n        }\\n        return arr[i+1];\\n\\n    }\\n    \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "pegasus991",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        l=len(nums)\\n        start=0\\n        end=l-1\\n        if(l==1):\\n            return nums[0]\\n        if(l==2):\\n            if(nums[0]<nums[1]):\\n                return nums[0]\\n            else:\\n                return nums[1]\\n        while(start<=end):\\n            mid=start+(end-start)//2\\n            prev=(mid+l-1)%l\\n            nex=(mid+1)%l\\n            if(nums[mid]<nums[prev] and nums[mid]<nums[nex]):\\n                return nums[mid]\\n            elif(nums[mid]<nums[end]):\\n                end=mid-1\\n            elif(nums[mid]>nums[start]):\\n                start=mid+1 \\n\\ncan anyone tell what is wrong with this code ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach seems almost correct, but there\\'s a little confusion in the else if conditions. In a sorted and rotated array, the pivot (the point of rotation, i.e., the minimum element) is the only point where the next number is less than the current. \\n\\nThe elements to the right of the pivot are smaller than the elements to the left of the pivot. Therefore, we have two sorted subarrays and we need to decide which part to discard depending upon the mid element. Here\\'s the correct code:\\n\\n```python\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        if len(nums) == 1:\\n            return nums[0]\\n        left = 0\\n        right = len(nums) - 1\\n        if nums[right] > nums[0]:  # no rotation\\n            return nums[0]\\n        while right >= left:\\n            mid = left + (right - left) // 2\\n            if nums[mid] > nums[mid + 1]:  # point of change is the smallest element\\n                return nums[mid + 1]\\n            if nums[mid - 1] > nums[mid]:  # point of change is the smallest element\\n                return nums[mid]\\n            if nums[mid] > nums[0]:  # left side is sorted so the pivot is on right side\\n                left = mid + 1\\n            else:  # right side is sorted so the pivot is on the left side\\n                right = mid - 1\\n```\\n\\nThis solution works in O(log n) time as it discards one of the halves in each step, and it uses O(1) space."
                    },
                    {
                        "username": "musharrafalam9888",
                        "content": "class Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int res;\\n        int l = 0; \\n        int r = (nums.size())-1;\\n        while(l<=r){\\n            if(nums[l]<nums[r]){\\n                res = min(res, nums[l]);\\n            }\\n            int m = l + (r - l)/2;        \\n            res = min(res, nums[l]);\\n            if(nums[m]>=nums[l]){\\n                l = m + 1;\\n            }\\n            else{\\n                r = m - 1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n1 test case is showing error [3, 1, 2]"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach is almost correct, but it seems you made a mistake in the line:\\n\\n```cpp\\nres = min(res, nums[l]);\\n```\\n\\nThis should be:\\n\\n```cpp\\nres = min(res, nums[m]);\\n```\\n\\nThe correct code will look like this:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int res = nums[0];\\n        int l = 0;\\n        int r = nums.size() - 1;\\n        while (l <= r) {\\n            int m = l + (r - l) / 2;\\n            res = min(res, nums[m]);\\n            if (nums[m] >= nums[l]) {\\n                l = m + 1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nThe reason for this is that you are trying to find the minimum element, and you should compare and update the current minimum value with the middle element `nums[m]`, not the left boundary `nums[l]`."
                    },
                    {
                        "username": "Srijan555",
                        "content": "class Solution {\\n    public int findMin(int[] nums) {\\n        int size=nums.length;\\n        int s=0,e=size-1;\\n        while(s<=e){\\n            \\n            int m=s+(e-s)/2;\\n            if(nums[m]<=nums[m-1] && nums[m]<=nums[m+1] && size>2){\\n                //System.out.println(\"Middle element is \"+nums[m]);\\n                return nums[m];\\n            }\\n            else{\\n                System.out.println(\"inside else\"+nums[s]+\",\"+nums[m]+\",\"+nums[e]);\\n                if(nums[m+1]<nums[m-1]){\\n                    s=m+1;\\n                }else if(nums[m+1]>nums[m-1]){\\n                    e=m-1;\\n                }\\n            }\\n        }\\n        return nums[0];\\n    }\\n}\\n\\n\\nGETTING BELOW ERROR:\\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 4\\n  at line 8, Solution.findMin\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your issue arises from accessing array indices without verifying if they are valid. In particular, these two lines are problematic: \\n\\n```java\\nif(nums[m]<=nums[m-1] && nums[m]<=nums[m+1] && size>2){\\n```\\n\\nand\\n\\n```java\\nif(nums[m+1]<nums[m-1]){\\n```\\n\\nIn both lines, you\\'re accessing `m-1` and `m+1` without checking whether `m-1` is >=0 and `m+1` is < `size`. When `m` is 0 or `size-1`, these conditions will lead to the `ArrayIndexOutOfBoundsException`.\\n\\nHere is the corrected version of your code:\\n\\n```java\\npublic class Solution {\\n    public int findMin(int[] nums) {\\n        int size=nums.length;\\n        int s=0,e=size-1;\\n        while(s<e){\\n            int m=s+(e-s)/2;\\n            if(nums[m] > nums[e]){\\n                s = m+1;\\n            }else {\\n                e = m;\\n            }\\n        }\\n        return nums[s];\\n    }\\n}\\n```\\nThis is a simpler and safer implementation using binary search that avoids problematic index access. The code always compares the middle element with the end element and moves the search range accordingly, which guarantees that the search range will shrink and eventually reach the minimum element."
                    },
                    {
                        "username": "Adarsh5101",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...`\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        if(nums[0] <= nums[nums.length-1]){\\n            return nums[0];\\n        }\\n        int left = 0,right = nums.length-1;\\n        while(left <= right){\\n            int mid =  left +(right - left)/2;\\n            if(mid-1 >= 0 && nums[mid] < nums[mid-1] ){\\n                return nums[mid];\\n            }else if(nums[mid] > nums[right]){\\n                left = mid+1;\\n            }else{\\n                right = mid-1;\\n            }\\n        }\\n        return nums[left];\\n    }\\n}"
                    },
                    {
                        "username": "Saima_H",
                        "content": "why do we use mid=start+(end-start)/2;?\nand not mid=(start+end)/2;\nbelow is the code in java tht is accepted but im unable to understand the above stmts.\nAlso if we are checking if nums.length==1 return nums[0]\n\nthen why do we use while(start<=end)\ncan anybody clear this doubt.\n\n\nclass Solution {\n    public int findMin(int[] nums) {\n        int n=nums.length;\n         if(n==1) return nums[0];\n        int start = 0, end=n-1;\n        if(nums[0]<nums[end]) return nums[0];\n        \n        while(start<=end)\n        {\n            int mid = start+(end-start)/2;\n            if(nums[mid+1]<nums[mid]) return nums[mid+1];\n            if(nums[mid-1]>nums[mid]) return nums[mid];\n                        \n            if(nums[mid]>nums[0])\n            {\n                start = mid+1;\n            }\n            else end = mid-1;\n        }\n    return -1;\n    }\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "In this case, `mid = start + (end - start) / 2` and `mid = (start + end) / 2` might seem to do the same thing - finding the middle index of a range in an array. However, there is a subtle but important difference that comes into play when working with large numbers.\\n\\nIn some languages, such as Java, C++, and Python, the sum `start + end` might exceed the maximum positive int value (2^31 - 1 for Java and C++). This can result in overflow, causing incorrect calculations or errors. To avoid this issue, we use the formula `start + (end - start) / 2` to find the mid-point without risking overflow.\\n\\nRegarding your second question, the `while (start <= end)` loop is a typical construct when using binary search, which is the technique employed in this problem. Although you return `nums[0]` when `n == 1`, there are other cases where the array length is larger than 1 and the smallest number is at index 0 (like a sorted array without any rotation). The condition `nums[0] < nums[end]` checks if the array is already sorted and simply returns `nums[0]` if that is the case. If the array has been rotated, the binary search is executed to find the minimum."
                    },
                    {
                        "username": "Gaurav_maurya",
                        "content": "we use mid = start + (end-start)/2; because in some cases if you add start + end  it will might get overflow over the range of integer for example 2,147,483,647 + 2,147,483,647 will be 4,29,49,67,294 which is out of limit. the about method will work in this and if you open it .\nIt shows like start + end/2 - start/2  = start/2 +end/2 = ( start+ end )/2 this eventually gives you the same output "
                    },
                    {
                        "username": "ankit_049",
                        "content": "when you find solution in o(logn) then use binary search  (hint : find pivot)\nbut one is easy answer on o(n) is sort vector and return first index element \n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "If you want an O(n) solution you don\\'t need to sort the input. You can just do linear search."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "BEST OPTIMIZED SOLUTION FOR search in rotated sorted array | O(log n) solution | java program |\nclass Solution {\n    public int findMin(int[] nums) {\n        int min = min(nums);\n        return nums[min];\n    }\n    public static int min(int[] nums){\n        int start = 0;\n        int end = nums.length - 1;\n        while(start < end){\n            int mid = start + (end - start) / 2;\n            if(mid > 0 && nums[mid - 1] > nums[mid]){\n                return mid;\n            }\n            else if(nums[start] <= nums[mid] && nums[mid] > nums[end]){\n                start = mid + 1;\n            }\n            else{\n                end = mid - 1;\n            }\n        }\n        return start;\n    }\n}"
                    },
                    {
                        "username": "proGeekCoder",
                        "content": "Hey Guys, \n\nI have used the below approach and stuck. Can someone point, where am I going wrong?\n\nI feel confused!\n\n```\nclass Solution:\n    def findMin(self, nums: List[int]) -> int:\n        low, high = 0, len(nums) - 1\n\n        while low < high:\n            mid = low + (high - low) // 2\n\n            if nums[low] < nums[mid]:\n                # the left part of the array is sorted\n                low = mid\n            else:\n                if nums[mid] < nums[high]:\n                    # right part of the array is sorted but left part of the array is not sorted\n                    high = mid\n                # else:\n                    # left and right part of the array is not sorted. \n                    # I don't understand what to do here! if both parts of the array is not sorted, how will I reduce the search space?\n                    \n        return nums[low]\n\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach is good and is aligned with the binary search solution for this problem, but you seem to have some misconceptions. \\n\\nIn a rotated sorted array, one half of the array is always sorted. If the array isn\\'t sorted, that means it has been rotated and the minimum element is somewhere in the unsorted part.\\n\\nLet\\'s correct your approach:\\n\\n1. Find the mid element.\\n2. If the mid element is greater than the high element, then the minimum element lies in the right half. So, set `low = mid + 1`.\\n3. Else, the minimum element lies in the left half, so set `high = mid`.\\n\\nThe termination condition for the while loop should be `low < high`, not `low <= high`. When `low == high`, that\\'s when you have found the smallest element.\\n\\nHere\\'s the corrected code:\\n\\n```python\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        low, high = 0, len(nums) - 1\\n\\n        while low < high:\\n            mid = low + (high - low) // 2\\n\\n            if nums[mid] > nums[high]:\\n                low = mid + 1\\n            else:\\n                high = mid\\n\\n        return nums[low]\\n```\\nThis code works because in a rotated sorted array, if you split it into two halves, then one must be sorted and one must be a rotated sorted array. The minimum element is either the first element of the sorted half (if there are no rotations), or it lies within the rotated sorted half. By comparing the middle element and the last element, you can tell which half is sorted and which half is rotated. If the middle element is greater than the last element, then the left half is sorted and the right half is a rotated sorted array. If the middle element is less than the last element, then the right half is sorted and the left half is a rotated sorted array. In either case, you can adjust your search boundary (`low` or `high`) accordingly. You repeat this process until your search boundary contains only one element, which is the smallest element in the array."
                    }
                ]
            },
            {
                "id": 1710734,
                "content": [
                    {
                        "username": "vjamdade1998",
                        "content": "class Solution {\\n    public int findMin(int[] arr) {\\n        // Arrays.sort(nums);\\n        // return nums[0];\\n        int i=0;\\n        if(arr[i]<=arr[arr.length-1])\\n            return arr[0];\\n        while(arr[i]<arr[i+1] && i+1<arr.length)\\n        {\\n            i++;\\n        }\\n        return arr[i+1];\\n\\n    }\\n    \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "pegasus991",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        l=len(nums)\\n        start=0\\n        end=l-1\\n        if(l==1):\\n            return nums[0]\\n        if(l==2):\\n            if(nums[0]<nums[1]):\\n                return nums[0]\\n            else:\\n                return nums[1]\\n        while(start<=end):\\n            mid=start+(end-start)//2\\n            prev=(mid+l-1)%l\\n            nex=(mid+1)%l\\n            if(nums[mid]<nums[prev] and nums[mid]<nums[nex]):\\n                return nums[mid]\\n            elif(nums[mid]<nums[end]):\\n                end=mid-1\\n            elif(nums[mid]>nums[start]):\\n                start=mid+1 \\n\\ncan anyone tell what is wrong with this code ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach seems almost correct, but there\\'s a little confusion in the else if conditions. In a sorted and rotated array, the pivot (the point of rotation, i.e., the minimum element) is the only point where the next number is less than the current. \\n\\nThe elements to the right of the pivot are smaller than the elements to the left of the pivot. Therefore, we have two sorted subarrays and we need to decide which part to discard depending upon the mid element. Here\\'s the correct code:\\n\\n```python\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        if len(nums) == 1:\\n            return nums[0]\\n        left = 0\\n        right = len(nums) - 1\\n        if nums[right] > nums[0]:  # no rotation\\n            return nums[0]\\n        while right >= left:\\n            mid = left + (right - left) // 2\\n            if nums[mid] > nums[mid + 1]:  # point of change is the smallest element\\n                return nums[mid + 1]\\n            if nums[mid - 1] > nums[mid]:  # point of change is the smallest element\\n                return nums[mid]\\n            if nums[mid] > nums[0]:  # left side is sorted so the pivot is on right side\\n                left = mid + 1\\n            else:  # right side is sorted so the pivot is on the left side\\n                right = mid - 1\\n```\\n\\nThis solution works in O(log n) time as it discards one of the halves in each step, and it uses O(1) space."
                    },
                    {
                        "username": "musharrafalam9888",
                        "content": "class Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int res;\\n        int l = 0; \\n        int r = (nums.size())-1;\\n        while(l<=r){\\n            if(nums[l]<nums[r]){\\n                res = min(res, nums[l]);\\n            }\\n            int m = l + (r - l)/2;        \\n            res = min(res, nums[l]);\\n            if(nums[m]>=nums[l]){\\n                l = m + 1;\\n            }\\n            else{\\n                r = m - 1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n1 test case is showing error [3, 1, 2]"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach is almost correct, but it seems you made a mistake in the line:\\n\\n```cpp\\nres = min(res, nums[l]);\\n```\\n\\nThis should be:\\n\\n```cpp\\nres = min(res, nums[m]);\\n```\\n\\nThe correct code will look like this:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int res = nums[0];\\n        int l = 0;\\n        int r = nums.size() - 1;\\n        while (l <= r) {\\n            int m = l + (r - l) / 2;\\n            res = min(res, nums[m]);\\n            if (nums[m] >= nums[l]) {\\n                l = m + 1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nThe reason for this is that you are trying to find the minimum element, and you should compare and update the current minimum value with the middle element `nums[m]`, not the left boundary `nums[l]`."
                    },
                    {
                        "username": "Srijan555",
                        "content": "class Solution {\\n    public int findMin(int[] nums) {\\n        int size=nums.length;\\n        int s=0,e=size-1;\\n        while(s<=e){\\n            \\n            int m=s+(e-s)/2;\\n            if(nums[m]<=nums[m-1] && nums[m]<=nums[m+1] && size>2){\\n                //System.out.println(\"Middle element is \"+nums[m]);\\n                return nums[m];\\n            }\\n            else{\\n                System.out.println(\"inside else\"+nums[s]+\",\"+nums[m]+\",\"+nums[e]);\\n                if(nums[m+1]<nums[m-1]){\\n                    s=m+1;\\n                }else if(nums[m+1]>nums[m-1]){\\n                    e=m-1;\\n                }\\n            }\\n        }\\n        return nums[0];\\n    }\\n}\\n\\n\\nGETTING BELOW ERROR:\\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 4\\n  at line 8, Solution.findMin\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your issue arises from accessing array indices without verifying if they are valid. In particular, these two lines are problematic: \\n\\n```java\\nif(nums[m]<=nums[m-1] && nums[m]<=nums[m+1] && size>2){\\n```\\n\\nand\\n\\n```java\\nif(nums[m+1]<nums[m-1]){\\n```\\n\\nIn both lines, you\\'re accessing `m-1` and `m+1` without checking whether `m-1` is >=0 and `m+1` is < `size`. When `m` is 0 or `size-1`, these conditions will lead to the `ArrayIndexOutOfBoundsException`.\\n\\nHere is the corrected version of your code:\\n\\n```java\\npublic class Solution {\\n    public int findMin(int[] nums) {\\n        int size=nums.length;\\n        int s=0,e=size-1;\\n        while(s<e){\\n            int m=s+(e-s)/2;\\n            if(nums[m] > nums[e]){\\n                s = m+1;\\n            }else {\\n                e = m;\\n            }\\n        }\\n        return nums[s];\\n    }\\n}\\n```\\nThis is a simpler and safer implementation using binary search that avoids problematic index access. The code always compares the middle element with the end element and moves the search range accordingly, which guarantees that the search range will shrink and eventually reach the minimum element."
                    },
                    {
                        "username": "Adarsh5101",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...`\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        if(nums[0] <= nums[nums.length-1]){\\n            return nums[0];\\n        }\\n        int left = 0,right = nums.length-1;\\n        while(left <= right){\\n            int mid =  left +(right - left)/2;\\n            if(mid-1 >= 0 && nums[mid] < nums[mid-1] ){\\n                return nums[mid];\\n            }else if(nums[mid] > nums[right]){\\n                left = mid+1;\\n            }else{\\n                right = mid-1;\\n            }\\n        }\\n        return nums[left];\\n    }\\n}"
                    },
                    {
                        "username": "Saima_H",
                        "content": "why do we use mid=start+(end-start)/2;?\nand not mid=(start+end)/2;\nbelow is the code in java tht is accepted but im unable to understand the above stmts.\nAlso if we are checking if nums.length==1 return nums[0]\n\nthen why do we use while(start<=end)\ncan anybody clear this doubt.\n\n\nclass Solution {\n    public int findMin(int[] nums) {\n        int n=nums.length;\n         if(n==1) return nums[0];\n        int start = 0, end=n-1;\n        if(nums[0]<nums[end]) return nums[0];\n        \n        while(start<=end)\n        {\n            int mid = start+(end-start)/2;\n            if(nums[mid+1]<nums[mid]) return nums[mid+1];\n            if(nums[mid-1]>nums[mid]) return nums[mid];\n                        \n            if(nums[mid]>nums[0])\n            {\n                start = mid+1;\n            }\n            else end = mid-1;\n        }\n    return -1;\n    }\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "In this case, `mid = start + (end - start) / 2` and `mid = (start + end) / 2` might seem to do the same thing - finding the middle index of a range in an array. However, there is a subtle but important difference that comes into play when working with large numbers.\\n\\nIn some languages, such as Java, C++, and Python, the sum `start + end` might exceed the maximum positive int value (2^31 - 1 for Java and C++). This can result in overflow, causing incorrect calculations or errors. To avoid this issue, we use the formula `start + (end - start) / 2` to find the mid-point without risking overflow.\\n\\nRegarding your second question, the `while (start <= end)` loop is a typical construct when using binary search, which is the technique employed in this problem. Although you return `nums[0]` when `n == 1`, there are other cases where the array length is larger than 1 and the smallest number is at index 0 (like a sorted array without any rotation). The condition `nums[0] < nums[end]` checks if the array is already sorted and simply returns `nums[0]` if that is the case. If the array has been rotated, the binary search is executed to find the minimum."
                    },
                    {
                        "username": "Gaurav_maurya",
                        "content": "we use mid = start + (end-start)/2; because in some cases if you add start + end  it will might get overflow over the range of integer for example 2,147,483,647 + 2,147,483,647 will be 4,29,49,67,294 which is out of limit. the about method will work in this and if you open it .\nIt shows like start + end/2 - start/2  = start/2 +end/2 = ( start+ end )/2 this eventually gives you the same output "
                    },
                    {
                        "username": "ankit_049",
                        "content": "when you find solution in o(logn) then use binary search  (hint : find pivot)\nbut one is easy answer on o(n) is sort vector and return first index element \n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "If you want an O(n) solution you don\\'t need to sort the input. You can just do linear search."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "BEST OPTIMIZED SOLUTION FOR search in rotated sorted array | O(log n) solution | java program |\nclass Solution {\n    public int findMin(int[] nums) {\n        int min = min(nums);\n        return nums[min];\n    }\n    public static int min(int[] nums){\n        int start = 0;\n        int end = nums.length - 1;\n        while(start < end){\n            int mid = start + (end - start) / 2;\n            if(mid > 0 && nums[mid - 1] > nums[mid]){\n                return mid;\n            }\n            else if(nums[start] <= nums[mid] && nums[mid] > nums[end]){\n                start = mid + 1;\n            }\n            else{\n                end = mid - 1;\n            }\n        }\n        return start;\n    }\n}"
                    },
                    {
                        "username": "proGeekCoder",
                        "content": "Hey Guys, \n\nI have used the below approach and stuck. Can someone point, where am I going wrong?\n\nI feel confused!\n\n```\nclass Solution:\n    def findMin(self, nums: List[int]) -> int:\n        low, high = 0, len(nums) - 1\n\n        while low < high:\n            mid = low + (high - low) // 2\n\n            if nums[low] < nums[mid]:\n                # the left part of the array is sorted\n                low = mid\n            else:\n                if nums[mid] < nums[high]:\n                    # right part of the array is sorted but left part of the array is not sorted\n                    high = mid\n                # else:\n                    # left and right part of the array is not sorted. \n                    # I don't understand what to do here! if both parts of the array is not sorted, how will I reduce the search space?\n                    \n        return nums[low]\n\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach is good and is aligned with the binary search solution for this problem, but you seem to have some misconceptions. \\n\\nIn a rotated sorted array, one half of the array is always sorted. If the array isn\\'t sorted, that means it has been rotated and the minimum element is somewhere in the unsorted part.\\n\\nLet\\'s correct your approach:\\n\\n1. Find the mid element.\\n2. If the mid element is greater than the high element, then the minimum element lies in the right half. So, set `low = mid + 1`.\\n3. Else, the minimum element lies in the left half, so set `high = mid`.\\n\\nThe termination condition for the while loop should be `low < high`, not `low <= high`. When `low == high`, that\\'s when you have found the smallest element.\\n\\nHere\\'s the corrected code:\\n\\n```python\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        low, high = 0, len(nums) - 1\\n\\n        while low < high:\\n            mid = low + (high - low) // 2\\n\\n            if nums[mid] > nums[high]:\\n                low = mid + 1\\n            else:\\n                high = mid\\n\\n        return nums[low]\\n```\\nThis code works because in a rotated sorted array, if you split it into two halves, then one must be sorted and one must be a rotated sorted array. The minimum element is either the first element of the sorted half (if there are no rotations), or it lies within the rotated sorted half. By comparing the middle element and the last element, you can tell which half is sorted and which half is rotated. If the middle element is greater than the last element, then the left half is sorted and the right half is a rotated sorted array. If the middle element is less than the last element, then the right half is sorted and the left half is a rotated sorted array. In either case, you can adjust your search boundary (`low` or `high`) accordingly. You repeat this process until your search boundary contains only one element, which is the smallest element in the array."
                    }
                ]
            },
            {
                "id": 1709639,
                "content": [
                    {
                        "username": "vjamdade1998",
                        "content": "class Solution {\\n    public int findMin(int[] arr) {\\n        // Arrays.sort(nums);\\n        // return nums[0];\\n        int i=0;\\n        if(arr[i]<=arr[arr.length-1])\\n            return arr[0];\\n        while(arr[i]<arr[i+1] && i+1<arr.length)\\n        {\\n            i++;\\n        }\\n        return arr[i+1];\\n\\n    }\\n    \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "pegasus991",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        l=len(nums)\\n        start=0\\n        end=l-1\\n        if(l==1):\\n            return nums[0]\\n        if(l==2):\\n            if(nums[0]<nums[1]):\\n                return nums[0]\\n            else:\\n                return nums[1]\\n        while(start<=end):\\n            mid=start+(end-start)//2\\n            prev=(mid+l-1)%l\\n            nex=(mid+1)%l\\n            if(nums[mid]<nums[prev] and nums[mid]<nums[nex]):\\n                return nums[mid]\\n            elif(nums[mid]<nums[end]):\\n                end=mid-1\\n            elif(nums[mid]>nums[start]):\\n                start=mid+1 \\n\\ncan anyone tell what is wrong with this code ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach seems almost correct, but there\\'s a little confusion in the else if conditions. In a sorted and rotated array, the pivot (the point of rotation, i.e., the minimum element) is the only point where the next number is less than the current. \\n\\nThe elements to the right of the pivot are smaller than the elements to the left of the pivot. Therefore, we have two sorted subarrays and we need to decide which part to discard depending upon the mid element. Here\\'s the correct code:\\n\\n```python\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        if len(nums) == 1:\\n            return nums[0]\\n        left = 0\\n        right = len(nums) - 1\\n        if nums[right] > nums[0]:  # no rotation\\n            return nums[0]\\n        while right >= left:\\n            mid = left + (right - left) // 2\\n            if nums[mid] > nums[mid + 1]:  # point of change is the smallest element\\n                return nums[mid + 1]\\n            if nums[mid - 1] > nums[mid]:  # point of change is the smallest element\\n                return nums[mid]\\n            if nums[mid] > nums[0]:  # left side is sorted so the pivot is on right side\\n                left = mid + 1\\n            else:  # right side is sorted so the pivot is on the left side\\n                right = mid - 1\\n```\\n\\nThis solution works in O(log n) time as it discards one of the halves in each step, and it uses O(1) space."
                    },
                    {
                        "username": "musharrafalam9888",
                        "content": "class Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int res;\\n        int l = 0; \\n        int r = (nums.size())-1;\\n        while(l<=r){\\n            if(nums[l]<nums[r]){\\n                res = min(res, nums[l]);\\n            }\\n            int m = l + (r - l)/2;        \\n            res = min(res, nums[l]);\\n            if(nums[m]>=nums[l]){\\n                l = m + 1;\\n            }\\n            else{\\n                r = m - 1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n1 test case is showing error [3, 1, 2]"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach is almost correct, but it seems you made a mistake in the line:\\n\\n```cpp\\nres = min(res, nums[l]);\\n```\\n\\nThis should be:\\n\\n```cpp\\nres = min(res, nums[m]);\\n```\\n\\nThe correct code will look like this:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int res = nums[0];\\n        int l = 0;\\n        int r = nums.size() - 1;\\n        while (l <= r) {\\n            int m = l + (r - l) / 2;\\n            res = min(res, nums[m]);\\n            if (nums[m] >= nums[l]) {\\n                l = m + 1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nThe reason for this is that you are trying to find the minimum element, and you should compare and update the current minimum value with the middle element `nums[m]`, not the left boundary `nums[l]`."
                    },
                    {
                        "username": "Srijan555",
                        "content": "class Solution {\\n    public int findMin(int[] nums) {\\n        int size=nums.length;\\n        int s=0,e=size-1;\\n        while(s<=e){\\n            \\n            int m=s+(e-s)/2;\\n            if(nums[m]<=nums[m-1] && nums[m]<=nums[m+1] && size>2){\\n                //System.out.println(\"Middle element is \"+nums[m]);\\n                return nums[m];\\n            }\\n            else{\\n                System.out.println(\"inside else\"+nums[s]+\",\"+nums[m]+\",\"+nums[e]);\\n                if(nums[m+1]<nums[m-1]){\\n                    s=m+1;\\n                }else if(nums[m+1]>nums[m-1]){\\n                    e=m-1;\\n                }\\n            }\\n        }\\n        return nums[0];\\n    }\\n}\\n\\n\\nGETTING BELOW ERROR:\\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 4\\n  at line 8, Solution.findMin\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your issue arises from accessing array indices without verifying if they are valid. In particular, these two lines are problematic: \\n\\n```java\\nif(nums[m]<=nums[m-1] && nums[m]<=nums[m+1] && size>2){\\n```\\n\\nand\\n\\n```java\\nif(nums[m+1]<nums[m-1]){\\n```\\n\\nIn both lines, you\\'re accessing `m-1` and `m+1` without checking whether `m-1` is >=0 and `m+1` is < `size`. When `m` is 0 or `size-1`, these conditions will lead to the `ArrayIndexOutOfBoundsException`.\\n\\nHere is the corrected version of your code:\\n\\n```java\\npublic class Solution {\\n    public int findMin(int[] nums) {\\n        int size=nums.length;\\n        int s=0,e=size-1;\\n        while(s<e){\\n            int m=s+(e-s)/2;\\n            if(nums[m] > nums[e]){\\n                s = m+1;\\n            }else {\\n                e = m;\\n            }\\n        }\\n        return nums[s];\\n    }\\n}\\n```\\nThis is a simpler and safer implementation using binary search that avoids problematic index access. The code always compares the middle element with the end element and moves the search range accordingly, which guarantees that the search range will shrink and eventually reach the minimum element."
                    },
                    {
                        "username": "Adarsh5101",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...`\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        if(nums[0] <= nums[nums.length-1]){\\n            return nums[0];\\n        }\\n        int left = 0,right = nums.length-1;\\n        while(left <= right){\\n            int mid =  left +(right - left)/2;\\n            if(mid-1 >= 0 && nums[mid] < nums[mid-1] ){\\n                return nums[mid];\\n            }else if(nums[mid] > nums[right]){\\n                left = mid+1;\\n            }else{\\n                right = mid-1;\\n            }\\n        }\\n        return nums[left];\\n    }\\n}"
                    },
                    {
                        "username": "Saima_H",
                        "content": "why do we use mid=start+(end-start)/2;?\nand not mid=(start+end)/2;\nbelow is the code in java tht is accepted but im unable to understand the above stmts.\nAlso if we are checking if nums.length==1 return nums[0]\n\nthen why do we use while(start<=end)\ncan anybody clear this doubt.\n\n\nclass Solution {\n    public int findMin(int[] nums) {\n        int n=nums.length;\n         if(n==1) return nums[0];\n        int start = 0, end=n-1;\n        if(nums[0]<nums[end]) return nums[0];\n        \n        while(start<=end)\n        {\n            int mid = start+(end-start)/2;\n            if(nums[mid+1]<nums[mid]) return nums[mid+1];\n            if(nums[mid-1]>nums[mid]) return nums[mid];\n                        \n            if(nums[mid]>nums[0])\n            {\n                start = mid+1;\n            }\n            else end = mid-1;\n        }\n    return -1;\n    }\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "In this case, `mid = start + (end - start) / 2` and `mid = (start + end) / 2` might seem to do the same thing - finding the middle index of a range in an array. However, there is a subtle but important difference that comes into play when working with large numbers.\\n\\nIn some languages, such as Java, C++, and Python, the sum `start + end` might exceed the maximum positive int value (2^31 - 1 for Java and C++). This can result in overflow, causing incorrect calculations or errors. To avoid this issue, we use the formula `start + (end - start) / 2` to find the mid-point without risking overflow.\\n\\nRegarding your second question, the `while (start <= end)` loop is a typical construct when using binary search, which is the technique employed in this problem. Although you return `nums[0]` when `n == 1`, there are other cases where the array length is larger than 1 and the smallest number is at index 0 (like a sorted array without any rotation). The condition `nums[0] < nums[end]` checks if the array is already sorted and simply returns `nums[0]` if that is the case. If the array has been rotated, the binary search is executed to find the minimum."
                    },
                    {
                        "username": "Gaurav_maurya",
                        "content": "we use mid = start + (end-start)/2; because in some cases if you add start + end  it will might get overflow over the range of integer for example 2,147,483,647 + 2,147,483,647 will be 4,29,49,67,294 which is out of limit. the about method will work in this and if you open it .\nIt shows like start + end/2 - start/2  = start/2 +end/2 = ( start+ end )/2 this eventually gives you the same output "
                    },
                    {
                        "username": "ankit_049",
                        "content": "when you find solution in o(logn) then use binary search  (hint : find pivot)\nbut one is easy answer on o(n) is sort vector and return first index element \n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "If you want an O(n) solution you don\\'t need to sort the input. You can just do linear search."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "BEST OPTIMIZED SOLUTION FOR search in rotated sorted array | O(log n) solution | java program |\nclass Solution {\n    public int findMin(int[] nums) {\n        int min = min(nums);\n        return nums[min];\n    }\n    public static int min(int[] nums){\n        int start = 0;\n        int end = nums.length - 1;\n        while(start < end){\n            int mid = start + (end - start) / 2;\n            if(mid > 0 && nums[mid - 1] > nums[mid]){\n                return mid;\n            }\n            else if(nums[start] <= nums[mid] && nums[mid] > nums[end]){\n                start = mid + 1;\n            }\n            else{\n                end = mid - 1;\n            }\n        }\n        return start;\n    }\n}"
                    },
                    {
                        "username": "proGeekCoder",
                        "content": "Hey Guys, \n\nI have used the below approach and stuck. Can someone point, where am I going wrong?\n\nI feel confused!\n\n```\nclass Solution:\n    def findMin(self, nums: List[int]) -> int:\n        low, high = 0, len(nums) - 1\n\n        while low < high:\n            mid = low + (high - low) // 2\n\n            if nums[low] < nums[mid]:\n                # the left part of the array is sorted\n                low = mid\n            else:\n                if nums[mid] < nums[high]:\n                    # right part of the array is sorted but left part of the array is not sorted\n                    high = mid\n                # else:\n                    # left and right part of the array is not sorted. \n                    # I don't understand what to do here! if both parts of the array is not sorted, how will I reduce the search space?\n                    \n        return nums[low]\n\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach is good and is aligned with the binary search solution for this problem, but you seem to have some misconceptions. \\n\\nIn a rotated sorted array, one half of the array is always sorted. If the array isn\\'t sorted, that means it has been rotated and the minimum element is somewhere in the unsorted part.\\n\\nLet\\'s correct your approach:\\n\\n1. Find the mid element.\\n2. If the mid element is greater than the high element, then the minimum element lies in the right half. So, set `low = mid + 1`.\\n3. Else, the minimum element lies in the left half, so set `high = mid`.\\n\\nThe termination condition for the while loop should be `low < high`, not `low <= high`. When `low == high`, that\\'s when you have found the smallest element.\\n\\nHere\\'s the corrected code:\\n\\n```python\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        low, high = 0, len(nums) - 1\\n\\n        while low < high:\\n            mid = low + (high - low) // 2\\n\\n            if nums[mid] > nums[high]:\\n                low = mid + 1\\n            else:\\n                high = mid\\n\\n        return nums[low]\\n```\\nThis code works because in a rotated sorted array, if you split it into two halves, then one must be sorted and one must be a rotated sorted array. The minimum element is either the first element of the sorted half (if there are no rotations), or it lies within the rotated sorted half. By comparing the middle element and the last element, you can tell which half is sorted and which half is rotated. If the middle element is greater than the last element, then the left half is sorted and the right half is a rotated sorted array. If the middle element is less than the last element, then the right half is sorted and the left half is a rotated sorted array. In either case, you can adjust your search boundary (`low` or `high`) accordingly. You repeat this process until your search boundary contains only one element, which is the smallest element in the array."
                    }
                ]
            },
            {
                "id": 1708280,
                "content": [
                    {
                        "username": "vjamdade1998",
                        "content": "class Solution {\\n    public int findMin(int[] arr) {\\n        // Arrays.sort(nums);\\n        // return nums[0];\\n        int i=0;\\n        if(arr[i]<=arr[arr.length-1])\\n            return arr[0];\\n        while(arr[i]<arr[i+1] && i+1<arr.length)\\n        {\\n            i++;\\n        }\\n        return arr[i+1];\\n\\n    }\\n    \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "pegasus991",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        l=len(nums)\\n        start=0\\n        end=l-1\\n        if(l==1):\\n            return nums[0]\\n        if(l==2):\\n            if(nums[0]<nums[1]):\\n                return nums[0]\\n            else:\\n                return nums[1]\\n        while(start<=end):\\n            mid=start+(end-start)//2\\n            prev=(mid+l-1)%l\\n            nex=(mid+1)%l\\n            if(nums[mid]<nums[prev] and nums[mid]<nums[nex]):\\n                return nums[mid]\\n            elif(nums[mid]<nums[end]):\\n                end=mid-1\\n            elif(nums[mid]>nums[start]):\\n                start=mid+1 \\n\\ncan anyone tell what is wrong with this code ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach seems almost correct, but there\\'s a little confusion in the else if conditions. In a sorted and rotated array, the pivot (the point of rotation, i.e., the minimum element) is the only point where the next number is less than the current. \\n\\nThe elements to the right of the pivot are smaller than the elements to the left of the pivot. Therefore, we have two sorted subarrays and we need to decide which part to discard depending upon the mid element. Here\\'s the correct code:\\n\\n```python\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        if len(nums) == 1:\\n            return nums[0]\\n        left = 0\\n        right = len(nums) - 1\\n        if nums[right] > nums[0]:  # no rotation\\n            return nums[0]\\n        while right >= left:\\n            mid = left + (right - left) // 2\\n            if nums[mid] > nums[mid + 1]:  # point of change is the smallest element\\n                return nums[mid + 1]\\n            if nums[mid - 1] > nums[mid]:  # point of change is the smallest element\\n                return nums[mid]\\n            if nums[mid] > nums[0]:  # left side is sorted so the pivot is on right side\\n                left = mid + 1\\n            else:  # right side is sorted so the pivot is on the left side\\n                right = mid - 1\\n```\\n\\nThis solution works in O(log n) time as it discards one of the halves in each step, and it uses O(1) space."
                    },
                    {
                        "username": "musharrafalam9888",
                        "content": "class Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int res;\\n        int l = 0; \\n        int r = (nums.size())-1;\\n        while(l<=r){\\n            if(nums[l]<nums[r]){\\n                res = min(res, nums[l]);\\n            }\\n            int m = l + (r - l)/2;        \\n            res = min(res, nums[l]);\\n            if(nums[m]>=nums[l]){\\n                l = m + 1;\\n            }\\n            else{\\n                r = m - 1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n1 test case is showing error [3, 1, 2]"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach is almost correct, but it seems you made a mistake in the line:\\n\\n```cpp\\nres = min(res, nums[l]);\\n```\\n\\nThis should be:\\n\\n```cpp\\nres = min(res, nums[m]);\\n```\\n\\nThe correct code will look like this:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int res = nums[0];\\n        int l = 0;\\n        int r = nums.size() - 1;\\n        while (l <= r) {\\n            int m = l + (r - l) / 2;\\n            res = min(res, nums[m]);\\n            if (nums[m] >= nums[l]) {\\n                l = m + 1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nThe reason for this is that you are trying to find the minimum element, and you should compare and update the current minimum value with the middle element `nums[m]`, not the left boundary `nums[l]`."
                    },
                    {
                        "username": "Srijan555",
                        "content": "class Solution {\\n    public int findMin(int[] nums) {\\n        int size=nums.length;\\n        int s=0,e=size-1;\\n        while(s<=e){\\n            \\n            int m=s+(e-s)/2;\\n            if(nums[m]<=nums[m-1] && nums[m]<=nums[m+1] && size>2){\\n                //System.out.println(\"Middle element is \"+nums[m]);\\n                return nums[m];\\n            }\\n            else{\\n                System.out.println(\"inside else\"+nums[s]+\",\"+nums[m]+\",\"+nums[e]);\\n                if(nums[m+1]<nums[m-1]){\\n                    s=m+1;\\n                }else if(nums[m+1]>nums[m-1]){\\n                    e=m-1;\\n                }\\n            }\\n        }\\n        return nums[0];\\n    }\\n}\\n\\n\\nGETTING BELOW ERROR:\\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 4\\n  at line 8, Solution.findMin\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your issue arises from accessing array indices without verifying if they are valid. In particular, these two lines are problematic: \\n\\n```java\\nif(nums[m]<=nums[m-1] && nums[m]<=nums[m+1] && size>2){\\n```\\n\\nand\\n\\n```java\\nif(nums[m+1]<nums[m-1]){\\n```\\n\\nIn both lines, you\\'re accessing `m-1` and `m+1` without checking whether `m-1` is >=0 and `m+1` is < `size`. When `m` is 0 or `size-1`, these conditions will lead to the `ArrayIndexOutOfBoundsException`.\\n\\nHere is the corrected version of your code:\\n\\n```java\\npublic class Solution {\\n    public int findMin(int[] nums) {\\n        int size=nums.length;\\n        int s=0,e=size-1;\\n        while(s<e){\\n            int m=s+(e-s)/2;\\n            if(nums[m] > nums[e]){\\n                s = m+1;\\n            }else {\\n                e = m;\\n            }\\n        }\\n        return nums[s];\\n    }\\n}\\n```\\nThis is a simpler and safer implementation using binary search that avoids problematic index access. The code always compares the middle element with the end element and moves the search range accordingly, which guarantees that the search range will shrink and eventually reach the minimum element."
                    },
                    {
                        "username": "Adarsh5101",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...`\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        if(nums[0] <= nums[nums.length-1]){\\n            return nums[0];\\n        }\\n        int left = 0,right = nums.length-1;\\n        while(left <= right){\\n            int mid =  left +(right - left)/2;\\n            if(mid-1 >= 0 && nums[mid] < nums[mid-1] ){\\n                return nums[mid];\\n            }else if(nums[mid] > nums[right]){\\n                left = mid+1;\\n            }else{\\n                right = mid-1;\\n            }\\n        }\\n        return nums[left];\\n    }\\n}"
                    },
                    {
                        "username": "Saima_H",
                        "content": "why do we use mid=start+(end-start)/2;?\nand not mid=(start+end)/2;\nbelow is the code in java tht is accepted but im unable to understand the above stmts.\nAlso if we are checking if nums.length==1 return nums[0]\n\nthen why do we use while(start<=end)\ncan anybody clear this doubt.\n\n\nclass Solution {\n    public int findMin(int[] nums) {\n        int n=nums.length;\n         if(n==1) return nums[0];\n        int start = 0, end=n-1;\n        if(nums[0]<nums[end]) return nums[0];\n        \n        while(start<=end)\n        {\n            int mid = start+(end-start)/2;\n            if(nums[mid+1]<nums[mid]) return nums[mid+1];\n            if(nums[mid-1]>nums[mid]) return nums[mid];\n                        \n            if(nums[mid]>nums[0])\n            {\n                start = mid+1;\n            }\n            else end = mid-1;\n        }\n    return -1;\n    }\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "In this case, `mid = start + (end - start) / 2` and `mid = (start + end) / 2` might seem to do the same thing - finding the middle index of a range in an array. However, there is a subtle but important difference that comes into play when working with large numbers.\\n\\nIn some languages, such as Java, C++, and Python, the sum `start + end` might exceed the maximum positive int value (2^31 - 1 for Java and C++). This can result in overflow, causing incorrect calculations or errors. To avoid this issue, we use the formula `start + (end - start) / 2` to find the mid-point without risking overflow.\\n\\nRegarding your second question, the `while (start <= end)` loop is a typical construct when using binary search, which is the technique employed in this problem. Although you return `nums[0]` when `n == 1`, there are other cases where the array length is larger than 1 and the smallest number is at index 0 (like a sorted array without any rotation). The condition `nums[0] < nums[end]` checks if the array is already sorted and simply returns `nums[0]` if that is the case. If the array has been rotated, the binary search is executed to find the minimum."
                    },
                    {
                        "username": "Gaurav_maurya",
                        "content": "we use mid = start + (end-start)/2; because in some cases if you add start + end  it will might get overflow over the range of integer for example 2,147,483,647 + 2,147,483,647 will be 4,29,49,67,294 which is out of limit. the about method will work in this and if you open it .\nIt shows like start + end/2 - start/2  = start/2 +end/2 = ( start+ end )/2 this eventually gives you the same output "
                    },
                    {
                        "username": "ankit_049",
                        "content": "when you find solution in o(logn) then use binary search  (hint : find pivot)\nbut one is easy answer on o(n) is sort vector and return first index element \n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "If you want an O(n) solution you don\\'t need to sort the input. You can just do linear search."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "BEST OPTIMIZED SOLUTION FOR search in rotated sorted array | O(log n) solution | java program |\nclass Solution {\n    public int findMin(int[] nums) {\n        int min = min(nums);\n        return nums[min];\n    }\n    public static int min(int[] nums){\n        int start = 0;\n        int end = nums.length - 1;\n        while(start < end){\n            int mid = start + (end - start) / 2;\n            if(mid > 0 && nums[mid - 1] > nums[mid]){\n                return mid;\n            }\n            else if(nums[start] <= nums[mid] && nums[mid] > nums[end]){\n                start = mid + 1;\n            }\n            else{\n                end = mid - 1;\n            }\n        }\n        return start;\n    }\n}"
                    },
                    {
                        "username": "proGeekCoder",
                        "content": "Hey Guys, \n\nI have used the below approach and stuck. Can someone point, where am I going wrong?\n\nI feel confused!\n\n```\nclass Solution:\n    def findMin(self, nums: List[int]) -> int:\n        low, high = 0, len(nums) - 1\n\n        while low < high:\n            mid = low + (high - low) // 2\n\n            if nums[low] < nums[mid]:\n                # the left part of the array is sorted\n                low = mid\n            else:\n                if nums[mid] < nums[high]:\n                    # right part of the array is sorted but left part of the array is not sorted\n                    high = mid\n                # else:\n                    # left and right part of the array is not sorted. \n                    # I don't understand what to do here! if both parts of the array is not sorted, how will I reduce the search space?\n                    \n        return nums[low]\n\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach is good and is aligned with the binary search solution for this problem, but you seem to have some misconceptions. \\n\\nIn a rotated sorted array, one half of the array is always sorted. If the array isn\\'t sorted, that means it has been rotated and the minimum element is somewhere in the unsorted part.\\n\\nLet\\'s correct your approach:\\n\\n1. Find the mid element.\\n2. If the mid element is greater than the high element, then the minimum element lies in the right half. So, set `low = mid + 1`.\\n3. Else, the minimum element lies in the left half, so set `high = mid`.\\n\\nThe termination condition for the while loop should be `low < high`, not `low <= high`. When `low == high`, that\\'s when you have found the smallest element.\\n\\nHere\\'s the corrected code:\\n\\n```python\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        low, high = 0, len(nums) - 1\\n\\n        while low < high:\\n            mid = low + (high - low) // 2\\n\\n            if nums[mid] > nums[high]:\\n                low = mid + 1\\n            else:\\n                high = mid\\n\\n        return nums[low]\\n```\\nThis code works because in a rotated sorted array, if you split it into two halves, then one must be sorted and one must be a rotated sorted array. The minimum element is either the first element of the sorted half (if there are no rotations), or it lies within the rotated sorted half. By comparing the middle element and the last element, you can tell which half is sorted and which half is rotated. If the middle element is greater than the last element, then the left half is sorted and the right half is a rotated sorted array. If the middle element is less than the last element, then the right half is sorted and the left half is a rotated sorted array. In either case, you can adjust your search boundary (`low` or `high`) accordingly. You repeat this process until your search boundary contains only one element, which is the smallest element in the array."
                    }
                ]
            },
            {
                "id": 1694711,
                "content": [
                    {
                        "username": "vjamdade1998",
                        "content": "class Solution {\\n    public int findMin(int[] arr) {\\n        // Arrays.sort(nums);\\n        // return nums[0];\\n        int i=0;\\n        if(arr[i]<=arr[arr.length-1])\\n            return arr[0];\\n        while(arr[i]<arr[i+1] && i+1<arr.length)\\n        {\\n            i++;\\n        }\\n        return arr[i+1];\\n\\n    }\\n    \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "pegasus991",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        l=len(nums)\\n        start=0\\n        end=l-1\\n        if(l==1):\\n            return nums[0]\\n        if(l==2):\\n            if(nums[0]<nums[1]):\\n                return nums[0]\\n            else:\\n                return nums[1]\\n        while(start<=end):\\n            mid=start+(end-start)//2\\n            prev=(mid+l-1)%l\\n            nex=(mid+1)%l\\n            if(nums[mid]<nums[prev] and nums[mid]<nums[nex]):\\n                return nums[mid]\\n            elif(nums[mid]<nums[end]):\\n                end=mid-1\\n            elif(nums[mid]>nums[start]):\\n                start=mid+1 \\n\\ncan anyone tell what is wrong with this code ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach seems almost correct, but there\\'s a little confusion in the else if conditions. In a sorted and rotated array, the pivot (the point of rotation, i.e., the minimum element) is the only point where the next number is less than the current. \\n\\nThe elements to the right of the pivot are smaller than the elements to the left of the pivot. Therefore, we have two sorted subarrays and we need to decide which part to discard depending upon the mid element. Here\\'s the correct code:\\n\\n```python\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        if len(nums) == 1:\\n            return nums[0]\\n        left = 0\\n        right = len(nums) - 1\\n        if nums[right] > nums[0]:  # no rotation\\n            return nums[0]\\n        while right >= left:\\n            mid = left + (right - left) // 2\\n            if nums[mid] > nums[mid + 1]:  # point of change is the smallest element\\n                return nums[mid + 1]\\n            if nums[mid - 1] > nums[mid]:  # point of change is the smallest element\\n                return nums[mid]\\n            if nums[mid] > nums[0]:  # left side is sorted so the pivot is on right side\\n                left = mid + 1\\n            else:  # right side is sorted so the pivot is on the left side\\n                right = mid - 1\\n```\\n\\nThis solution works in O(log n) time as it discards one of the halves in each step, and it uses O(1) space."
                    },
                    {
                        "username": "musharrafalam9888",
                        "content": "class Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int res;\\n        int l = 0; \\n        int r = (nums.size())-1;\\n        while(l<=r){\\n            if(nums[l]<nums[r]){\\n                res = min(res, nums[l]);\\n            }\\n            int m = l + (r - l)/2;        \\n            res = min(res, nums[l]);\\n            if(nums[m]>=nums[l]){\\n                l = m + 1;\\n            }\\n            else{\\n                r = m - 1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n1 test case is showing error [3, 1, 2]"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach is almost correct, but it seems you made a mistake in the line:\\n\\n```cpp\\nres = min(res, nums[l]);\\n```\\n\\nThis should be:\\n\\n```cpp\\nres = min(res, nums[m]);\\n```\\n\\nThe correct code will look like this:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int res = nums[0];\\n        int l = 0;\\n        int r = nums.size() - 1;\\n        while (l <= r) {\\n            int m = l + (r - l) / 2;\\n            res = min(res, nums[m]);\\n            if (nums[m] >= nums[l]) {\\n                l = m + 1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nThe reason for this is that you are trying to find the minimum element, and you should compare and update the current minimum value with the middle element `nums[m]`, not the left boundary `nums[l]`."
                    },
                    {
                        "username": "Srijan555",
                        "content": "class Solution {\\n    public int findMin(int[] nums) {\\n        int size=nums.length;\\n        int s=0,e=size-1;\\n        while(s<=e){\\n            \\n            int m=s+(e-s)/2;\\n            if(nums[m]<=nums[m-1] && nums[m]<=nums[m+1] && size>2){\\n                //System.out.println(\"Middle element is \"+nums[m]);\\n                return nums[m];\\n            }\\n            else{\\n                System.out.println(\"inside else\"+nums[s]+\",\"+nums[m]+\",\"+nums[e]);\\n                if(nums[m+1]<nums[m-1]){\\n                    s=m+1;\\n                }else if(nums[m+1]>nums[m-1]){\\n                    e=m-1;\\n                }\\n            }\\n        }\\n        return nums[0];\\n    }\\n}\\n\\n\\nGETTING BELOW ERROR:\\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 4\\n  at line 8, Solution.findMin\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your issue arises from accessing array indices without verifying if they are valid. In particular, these two lines are problematic: \\n\\n```java\\nif(nums[m]<=nums[m-1] && nums[m]<=nums[m+1] && size>2){\\n```\\n\\nand\\n\\n```java\\nif(nums[m+1]<nums[m-1]){\\n```\\n\\nIn both lines, you\\'re accessing `m-1` and `m+1` without checking whether `m-1` is >=0 and `m+1` is < `size`. When `m` is 0 or `size-1`, these conditions will lead to the `ArrayIndexOutOfBoundsException`.\\n\\nHere is the corrected version of your code:\\n\\n```java\\npublic class Solution {\\n    public int findMin(int[] nums) {\\n        int size=nums.length;\\n        int s=0,e=size-1;\\n        while(s<e){\\n            int m=s+(e-s)/2;\\n            if(nums[m] > nums[e]){\\n                s = m+1;\\n            }else {\\n                e = m;\\n            }\\n        }\\n        return nums[s];\\n    }\\n}\\n```\\nThis is a simpler and safer implementation using binary search that avoids problematic index access. The code always compares the middle element with the end element and moves the search range accordingly, which guarantees that the search range will shrink and eventually reach the minimum element."
                    },
                    {
                        "username": "Adarsh5101",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...`\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        if(nums[0] <= nums[nums.length-1]){\\n            return nums[0];\\n        }\\n        int left = 0,right = nums.length-1;\\n        while(left <= right){\\n            int mid =  left +(right - left)/2;\\n            if(mid-1 >= 0 && nums[mid] < nums[mid-1] ){\\n                return nums[mid];\\n            }else if(nums[mid] > nums[right]){\\n                left = mid+1;\\n            }else{\\n                right = mid-1;\\n            }\\n        }\\n        return nums[left];\\n    }\\n}"
                    },
                    {
                        "username": "Saima_H",
                        "content": "why do we use mid=start+(end-start)/2;?\nand not mid=(start+end)/2;\nbelow is the code in java tht is accepted but im unable to understand the above stmts.\nAlso if we are checking if nums.length==1 return nums[0]\n\nthen why do we use while(start<=end)\ncan anybody clear this doubt.\n\n\nclass Solution {\n    public int findMin(int[] nums) {\n        int n=nums.length;\n         if(n==1) return nums[0];\n        int start = 0, end=n-1;\n        if(nums[0]<nums[end]) return nums[0];\n        \n        while(start<=end)\n        {\n            int mid = start+(end-start)/2;\n            if(nums[mid+1]<nums[mid]) return nums[mid+1];\n            if(nums[mid-1]>nums[mid]) return nums[mid];\n                        \n            if(nums[mid]>nums[0])\n            {\n                start = mid+1;\n            }\n            else end = mid-1;\n        }\n    return -1;\n    }\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "In this case, `mid = start + (end - start) / 2` and `mid = (start + end) / 2` might seem to do the same thing - finding the middle index of a range in an array. However, there is a subtle but important difference that comes into play when working with large numbers.\\n\\nIn some languages, such as Java, C++, and Python, the sum `start + end` might exceed the maximum positive int value (2^31 - 1 for Java and C++). This can result in overflow, causing incorrect calculations or errors. To avoid this issue, we use the formula `start + (end - start) / 2` to find the mid-point without risking overflow.\\n\\nRegarding your second question, the `while (start <= end)` loop is a typical construct when using binary search, which is the technique employed in this problem. Although you return `nums[0]` when `n == 1`, there are other cases where the array length is larger than 1 and the smallest number is at index 0 (like a sorted array without any rotation). The condition `nums[0] < nums[end]` checks if the array is already sorted and simply returns `nums[0]` if that is the case. If the array has been rotated, the binary search is executed to find the minimum."
                    },
                    {
                        "username": "Gaurav_maurya",
                        "content": "we use mid = start + (end-start)/2; because in some cases if you add start + end  it will might get overflow over the range of integer for example 2,147,483,647 + 2,147,483,647 will be 4,29,49,67,294 which is out of limit. the about method will work in this and if you open it .\nIt shows like start + end/2 - start/2  = start/2 +end/2 = ( start+ end )/2 this eventually gives you the same output "
                    },
                    {
                        "username": "ankit_049",
                        "content": "when you find solution in o(logn) then use binary search  (hint : find pivot)\nbut one is easy answer on o(n) is sort vector and return first index element \n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "If you want an O(n) solution you don\\'t need to sort the input. You can just do linear search."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "BEST OPTIMIZED SOLUTION FOR search in rotated sorted array | O(log n) solution | java program |\nclass Solution {\n    public int findMin(int[] nums) {\n        int min = min(nums);\n        return nums[min];\n    }\n    public static int min(int[] nums){\n        int start = 0;\n        int end = nums.length - 1;\n        while(start < end){\n            int mid = start + (end - start) / 2;\n            if(mid > 0 && nums[mid - 1] > nums[mid]){\n                return mid;\n            }\n            else if(nums[start] <= nums[mid] && nums[mid] > nums[end]){\n                start = mid + 1;\n            }\n            else{\n                end = mid - 1;\n            }\n        }\n        return start;\n    }\n}"
                    },
                    {
                        "username": "proGeekCoder",
                        "content": "Hey Guys, \n\nI have used the below approach and stuck. Can someone point, where am I going wrong?\n\nI feel confused!\n\n```\nclass Solution:\n    def findMin(self, nums: List[int]) -> int:\n        low, high = 0, len(nums) - 1\n\n        while low < high:\n            mid = low + (high - low) // 2\n\n            if nums[low] < nums[mid]:\n                # the left part of the array is sorted\n                low = mid\n            else:\n                if nums[mid] < nums[high]:\n                    # right part of the array is sorted but left part of the array is not sorted\n                    high = mid\n                # else:\n                    # left and right part of the array is not sorted. \n                    # I don't understand what to do here! if both parts of the array is not sorted, how will I reduce the search space?\n                    \n        return nums[low]\n\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach is good and is aligned with the binary search solution for this problem, but you seem to have some misconceptions. \\n\\nIn a rotated sorted array, one half of the array is always sorted. If the array isn\\'t sorted, that means it has been rotated and the minimum element is somewhere in the unsorted part.\\n\\nLet\\'s correct your approach:\\n\\n1. Find the mid element.\\n2. If the mid element is greater than the high element, then the minimum element lies in the right half. So, set `low = mid + 1`.\\n3. Else, the minimum element lies in the left half, so set `high = mid`.\\n\\nThe termination condition for the while loop should be `low < high`, not `low <= high`. When `low == high`, that\\'s when you have found the smallest element.\\n\\nHere\\'s the corrected code:\\n\\n```python\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        low, high = 0, len(nums) - 1\\n\\n        while low < high:\\n            mid = low + (high - low) // 2\\n\\n            if nums[mid] > nums[high]:\\n                low = mid + 1\\n            else:\\n                high = mid\\n\\n        return nums[low]\\n```\\nThis code works because in a rotated sorted array, if you split it into two halves, then one must be sorted and one must be a rotated sorted array. The minimum element is either the first element of the sorted half (if there are no rotations), or it lies within the rotated sorted half. By comparing the middle element and the last element, you can tell which half is sorted and which half is rotated. If the middle element is greater than the last element, then the left half is sorted and the right half is a rotated sorted array. If the middle element is less than the last element, then the right half is sorted and the left half is a rotated sorted array. In either case, you can adjust your search boundary (`low` or `high`) accordingly. You repeat this process until your search boundary contains only one element, which is the smallest element in the array."
                    }
                ]
            },
            {
                "id": 1683511,
                "content": [
                    {
                        "username": "vjamdade1998",
                        "content": "class Solution {\\n    public int findMin(int[] arr) {\\n        // Arrays.sort(nums);\\n        // return nums[0];\\n        int i=0;\\n        if(arr[i]<=arr[arr.length-1])\\n            return arr[0];\\n        while(arr[i]<arr[i+1] && i+1<arr.length)\\n        {\\n            i++;\\n        }\\n        return arr[i+1];\\n\\n    }\\n    \\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "pegasus991",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        l=len(nums)\\n        start=0\\n        end=l-1\\n        if(l==1):\\n            return nums[0]\\n        if(l==2):\\n            if(nums[0]<nums[1]):\\n                return nums[0]\\n            else:\\n                return nums[1]\\n        while(start<=end):\\n            mid=start+(end-start)//2\\n            prev=(mid+l-1)%l\\n            nex=(mid+1)%l\\n            if(nums[mid]<nums[prev] and nums[mid]<nums[nex]):\\n                return nums[mid]\\n            elif(nums[mid]<nums[end]):\\n                end=mid-1\\n            elif(nums[mid]>nums[start]):\\n                start=mid+1 \\n\\ncan anyone tell what is wrong with this code ?"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach seems almost correct, but there\\'s a little confusion in the else if conditions. In a sorted and rotated array, the pivot (the point of rotation, i.e., the minimum element) is the only point where the next number is less than the current. \\n\\nThe elements to the right of the pivot are smaller than the elements to the left of the pivot. Therefore, we have two sorted subarrays and we need to decide which part to discard depending upon the mid element. Here\\'s the correct code:\\n\\n```python\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        if len(nums) == 1:\\n            return nums[0]\\n        left = 0\\n        right = len(nums) - 1\\n        if nums[right] > nums[0]:  # no rotation\\n            return nums[0]\\n        while right >= left:\\n            mid = left + (right - left) // 2\\n            if nums[mid] > nums[mid + 1]:  # point of change is the smallest element\\n                return nums[mid + 1]\\n            if nums[mid - 1] > nums[mid]:  # point of change is the smallest element\\n                return nums[mid]\\n            if nums[mid] > nums[0]:  # left side is sorted so the pivot is on right side\\n                left = mid + 1\\n            else:  # right side is sorted so the pivot is on the left side\\n                right = mid - 1\\n```\\n\\nThis solution works in O(log n) time as it discards one of the halves in each step, and it uses O(1) space."
                    },
                    {
                        "username": "musharrafalam9888",
                        "content": "class Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int res;\\n        int l = 0; \\n        int r = (nums.size())-1;\\n        while(l<=r){\\n            if(nums[l]<nums[r]){\\n                res = min(res, nums[l]);\\n            }\\n            int m = l + (r - l)/2;        \\n            res = min(res, nums[l]);\\n            if(nums[m]>=nums[l]){\\n                l = m + 1;\\n            }\\n            else{\\n                r = m - 1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n1 test case is showing error [3, 1, 2]"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach is almost correct, but it seems you made a mistake in the line:\\n\\n```cpp\\nres = min(res, nums[l]);\\n```\\n\\nThis should be:\\n\\n```cpp\\nres = min(res, nums[m]);\\n```\\n\\nThe correct code will look like this:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int findMin(vector<int>& nums) {\\n        int res = nums[0];\\n        int l = 0;\\n        int r = nums.size() - 1;\\n        while (l <= r) {\\n            int m = l + (r - l) / 2;\\n            res = min(res, nums[m]);\\n            if (nums[m] >= nums[l]) {\\n                l = m + 1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nThe reason for this is that you are trying to find the minimum element, and you should compare and update the current minimum value with the middle element `nums[m]`, not the left boundary `nums[l]`."
                    },
                    {
                        "username": "Srijan555",
                        "content": "class Solution {\\n    public int findMin(int[] nums) {\\n        int size=nums.length;\\n        int s=0,e=size-1;\\n        while(s<=e){\\n            \\n            int m=s+(e-s)/2;\\n            if(nums[m]<=nums[m-1] && nums[m]<=nums[m+1] && size>2){\\n                //System.out.println(\"Middle element is \"+nums[m]);\\n                return nums[m];\\n            }\\n            else{\\n                System.out.println(\"inside else\"+nums[s]+\",\"+nums[m]+\",\"+nums[e]);\\n                if(nums[m+1]<nums[m-1]){\\n                    s=m+1;\\n                }else if(nums[m+1]>nums[m-1]){\\n                    e=m-1;\\n                }\\n            }\\n        }\\n        return nums[0];\\n    }\\n}\\n\\n\\nGETTING BELOW ERROR:\\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 4\\n  at line 8, Solution.findMin\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your issue arises from accessing array indices without verifying if they are valid. In particular, these two lines are problematic: \\n\\n```java\\nif(nums[m]<=nums[m-1] && nums[m]<=nums[m+1] && size>2){\\n```\\n\\nand\\n\\n```java\\nif(nums[m+1]<nums[m-1]){\\n```\\n\\nIn both lines, you\\'re accessing `m-1` and `m+1` without checking whether `m-1` is >=0 and `m+1` is < `size`. When `m` is 0 or `size-1`, these conditions will lead to the `ArrayIndexOutOfBoundsException`.\\n\\nHere is the corrected version of your code:\\n\\n```java\\npublic class Solution {\\n    public int findMin(int[] nums) {\\n        int size=nums.length;\\n        int s=0,e=size-1;\\n        while(s<e){\\n            int m=s+(e-s)/2;\\n            if(nums[m] > nums[e]){\\n                s = m+1;\\n            }else {\\n                e = m;\\n            }\\n        }\\n        return nums[s];\\n    }\\n}\\n```\\nThis is a simpler and safer implementation using binary search that avoids problematic index access. The code always compares the middle element with the end element and moves the search range accordingly, which guarantees that the search range will shrink and eventually reach the minimum element."
                    },
                    {
                        "username": "Adarsh5101",
                        "content": " `your inline code...your inline code...` `your inline code...your inline code...`\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        if(nums[0] <= nums[nums.length-1]){\\n            return nums[0];\\n        }\\n        int left = 0,right = nums.length-1;\\n        while(left <= right){\\n            int mid =  left +(right - left)/2;\\n            if(mid-1 >= 0 && nums[mid] < nums[mid-1] ){\\n                return nums[mid];\\n            }else if(nums[mid] > nums[right]){\\n                left = mid+1;\\n            }else{\\n                right = mid-1;\\n            }\\n        }\\n        return nums[left];\\n    }\\n}"
                    },
                    {
                        "username": "Saima_H",
                        "content": "why do we use mid=start+(end-start)/2;?\nand not mid=(start+end)/2;\nbelow is the code in java tht is accepted but im unable to understand the above stmts.\nAlso if we are checking if nums.length==1 return nums[0]\n\nthen why do we use while(start<=end)\ncan anybody clear this doubt.\n\n\nclass Solution {\n    public int findMin(int[] nums) {\n        int n=nums.length;\n         if(n==1) return nums[0];\n        int start = 0, end=n-1;\n        if(nums[0]<nums[end]) return nums[0];\n        \n        while(start<=end)\n        {\n            int mid = start+(end-start)/2;\n            if(nums[mid+1]<nums[mid]) return nums[mid+1];\n            if(nums[mid-1]>nums[mid]) return nums[mid];\n                        \n            if(nums[mid]>nums[0])\n            {\n                start = mid+1;\n            }\n            else end = mid-1;\n        }\n    return -1;\n    }\n}"
                    },
                    {
                        "username": "bparanj",
                        "content": "In this case, `mid = start + (end - start) / 2` and `mid = (start + end) / 2` might seem to do the same thing - finding the middle index of a range in an array. However, there is a subtle but important difference that comes into play when working with large numbers.\\n\\nIn some languages, such as Java, C++, and Python, the sum `start + end` might exceed the maximum positive int value (2^31 - 1 for Java and C++). This can result in overflow, causing incorrect calculations or errors. To avoid this issue, we use the formula `start + (end - start) / 2` to find the mid-point without risking overflow.\\n\\nRegarding your second question, the `while (start <= end)` loop is a typical construct when using binary search, which is the technique employed in this problem. Although you return `nums[0]` when `n == 1`, there are other cases where the array length is larger than 1 and the smallest number is at index 0 (like a sorted array without any rotation). The condition `nums[0] < nums[end]` checks if the array is already sorted and simply returns `nums[0]` if that is the case. If the array has been rotated, the binary search is executed to find the minimum."
                    },
                    {
                        "username": "Gaurav_maurya",
                        "content": "we use mid = start + (end-start)/2; because in some cases if you add start + end  it will might get overflow over the range of integer for example 2,147,483,647 + 2,147,483,647 will be 4,29,49,67,294 which is out of limit. the about method will work in this and if you open it .\nIt shows like start + end/2 - start/2  = start/2 +end/2 = ( start+ end )/2 this eventually gives you the same output "
                    },
                    {
                        "username": "ankit_049",
                        "content": "when you find solution in o(logn) then use binary search  (hint : find pivot)\nbut one is easy answer on o(n) is sort vector and return first index element \n"
                    },
                    {
                        "username": "nikhila01",
                        "content": "If you want an O(n) solution you don\\'t need to sort the input. You can just do linear search."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "BEST OPTIMIZED SOLUTION FOR search in rotated sorted array | O(log n) solution | java program |\nclass Solution {\n    public int findMin(int[] nums) {\n        int min = min(nums);\n        return nums[min];\n    }\n    public static int min(int[] nums){\n        int start = 0;\n        int end = nums.length - 1;\n        while(start < end){\n            int mid = start + (end - start) / 2;\n            if(mid > 0 && nums[mid - 1] > nums[mid]){\n                return mid;\n            }\n            else if(nums[start] <= nums[mid] && nums[mid] > nums[end]){\n                start = mid + 1;\n            }\n            else{\n                end = mid - 1;\n            }\n        }\n        return start;\n    }\n}"
                    },
                    {
                        "username": "proGeekCoder",
                        "content": "Hey Guys, \n\nI have used the below approach and stuck. Can someone point, where am I going wrong?\n\nI feel confused!\n\n```\nclass Solution:\n    def findMin(self, nums: List[int]) -> int:\n        low, high = 0, len(nums) - 1\n\n        while low < high:\n            mid = low + (high - low) // 2\n\n            if nums[low] < nums[mid]:\n                # the left part of the array is sorted\n                low = mid\n            else:\n                if nums[mid] < nums[high]:\n                    # right part of the array is sorted but left part of the array is not sorted\n                    high = mid\n                # else:\n                    # left and right part of the array is not sorted. \n                    # I don't understand what to do here! if both parts of the array is not sorted, how will I reduce the search space?\n                    \n        return nums[low]\n\n```"
                    },
                    {
                        "username": "bparanj",
                        "content": "Your approach is good and is aligned with the binary search solution for this problem, but you seem to have some misconceptions. \\n\\nIn a rotated sorted array, one half of the array is always sorted. If the array isn\\'t sorted, that means it has been rotated and the minimum element is somewhere in the unsorted part.\\n\\nLet\\'s correct your approach:\\n\\n1. Find the mid element.\\n2. If the mid element is greater than the high element, then the minimum element lies in the right half. So, set `low = mid + 1`.\\n3. Else, the minimum element lies in the left half, so set `high = mid`.\\n\\nThe termination condition for the while loop should be `low < high`, not `low <= high`. When `low == high`, that\\'s when you have found the smallest element.\\n\\nHere\\'s the corrected code:\\n\\n```python\\nclass Solution:\\n    def findMin(self, nums: List[int]) -> int:\\n        low, high = 0, len(nums) - 1\\n\\n        while low < high:\\n            mid = low + (high - low) // 2\\n\\n            if nums[mid] > nums[high]:\\n                low = mid + 1\\n            else:\\n                high = mid\\n\\n        return nums[low]\\n```\\nThis code works because in a rotated sorted array, if you split it into two halves, then one must be sorted and one must be a rotated sorted array. The minimum element is either the first element of the sorted half (if there are no rotations), or it lies within the rotated sorted half. By comparing the middle element and the last element, you can tell which half is sorted and which half is rotated. If the middle element is greater than the last element, then the left half is sorted and the right half is a rotated sorted array. If the middle element is less than the last element, then the right half is sorted and the left half is a rotated sorted array. In either case, you can adjust your search boundary (`low` or `high`) accordingly. You repeat this process until your search boundary contains only one element, which is the smallest element in the array."
                    }
                ]
            }
        ]
    }
]